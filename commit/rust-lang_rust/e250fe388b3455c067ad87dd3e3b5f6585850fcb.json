{"sha": "e250fe388b3455c067ad87dd3e3b5f6585850fcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNTBmZTM4OGIzNDU1YzA2N2FkODdkZDNlM2I1ZjY1ODU4NTBmY2I=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-05T02:17:19Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-05T23:22:03Z"}, "message": "misc collections code cleanup", "tree": {"sha": "f1cd6d77aab9e6f6fdd646858567f6e26084eea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1cd6d77aab9e6f6fdd646858567f6e26084eea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e250fe388b3455c067ad87dd3e3b5f6585850fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e250fe388b3455c067ad87dd3e3b5f6585850fcb", "html_url": "https://github.com/rust-lang/rust/commit/e250fe388b3455c067ad87dd3e3b5f6585850fcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e250fe388b3455c067ad87dd3e3b5f6585850fcb/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "189930fcae287565dcef856ae8d60a83190a4b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/189930fcae287565dcef856ae8d60a83190a4b92", "html_url": "https://github.com/rust-lang/rust/commit/189930fcae287565dcef856ae8d60a83190a4b92"}], "stats": {"total": 2500, "additions": 1233, "deletions": 1267}, "files": [{"sha": "b0a5911720a40aa384c75374604c84b7c0d42967", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -13,40 +13,40 @@ use std::rand;\n use std::rand::Rng;\n use test::{Bencher, black_box};\n \n-pub fn insert_rand_n<M, I, R>(n: uint,\n+pub fn insert_rand_n<M, I, R>(n: usize,\n                               map: &mut M,\n                               b: &mut Bencher,\n                               mut insert: I,\n                               mut remove: R) where\n-    I: FnMut(&mut M, uint),\n-    R: FnMut(&mut M, uint),\n+    I: FnMut(&mut M, usize),\n+    R: FnMut(&mut M, usize),\n {\n     // setup\n     let mut rng = rand::weak_rng();\n \n     for _ in 0..n {\n-        insert(map, rng.gen::<uint>() % n);\n+        insert(map, rng.gen::<usize>() % n);\n     }\n \n     // measure\n     b.iter(|| {\n-        let k = rng.gen::<uint>() % n;\n+        let k = rng.gen::<usize>() % n;\n         insert(map, k);\n         remove(map, k);\n     });\n     black_box(map);\n }\n \n-pub fn insert_seq_n<M, I, R>(n: uint,\n+pub fn insert_seq_n<M, I, R>(n: usize,\n                              map: &mut M,\n                              b: &mut Bencher,\n                              mut insert: I,\n                              mut remove: R) where\n-    I: FnMut(&mut M, uint),\n-    R: FnMut(&mut M, uint),\n+    I: FnMut(&mut M, usize),\n+    R: FnMut(&mut M, usize),\n {\n     // setup\n-    for i in 0u..n {\n+    for i in 0..n {\n         insert(map, i * 2);\n     }\n \n@@ -60,18 +60,17 @@ pub fn insert_seq_n<M, I, R>(n: uint,\n     black_box(map);\n }\n \n-pub fn find_rand_n<M, T, I, F>(n: uint,\n+pub fn find_rand_n<M, T, I, F>(n: usize,\n                                map: &mut M,\n                                b: &mut Bencher,\n                                mut insert: I,\n                                mut find: F) where\n-    I: FnMut(&mut M, uint),\n-    F: FnMut(&M, uint) -> T,\n+    I: FnMut(&mut M, usize),\n+    F: FnMut(&M, usize) -> T,\n {\n     // setup\n     let mut rng = rand::weak_rng();\n-    let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n-                              .collect::<Vec<_>>();\n+    let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n \n     for k in &keys {\n         insert(map, *k);\n@@ -88,16 +87,16 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n     })\n }\n \n-pub fn find_seq_n<M, T, I, F>(n: uint,\n+pub fn find_seq_n<M, T, I, F>(n: usize,\n                               map: &mut M,\n                               b: &mut Bencher,\n                               mut insert: I,\n                               mut find: F) where\n-    I: FnMut(&mut M, uint),\n-    F: FnMut(&M, uint) -> T,\n+    I: FnMut(&mut M, usize),\n+    F: FnMut(&M, usize) -> T,\n {\n     // setup\n-    for i in 0u..n {\n+    for i in 0..n {\n         insert(map, i);\n     }\n "}, {"sha": "fe477c3495f81279daf1917e43719feb9156cbfc", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -28,12 +28,12 @@\n //! ```\n //! use std::cmp::Ordering;\n //! use std::collections::BinaryHeap;\n-//! use std::uint;\n+//! use std::usize;\n //!\n //! #[derive(Copy, Eq, PartialEq)]\n //! struct State {\n-//!     cost: uint,\n-//!     position: uint,\n+//!     cost: usize,\n+//!     position: usize,\n //! }\n //!\n //! // The priority queue depends on `Ord`.\n@@ -53,21 +53,21 @@\n //!     }\n //! }\n //!\n-//! // Each node is represented as an `uint`, for a shorter implementation.\n+//! // Each node is represented as an `usize`, for a shorter implementation.\n //! struct Edge {\n-//!     node: uint,\n-//!     cost: uint,\n+//!     node: usize,\n+//!     cost: usize,\n //! }\n //!\n //! // Dijkstra's shortest path algorithm.\n //!\n //! // Start at `start` and use `dist` to track the current shortest distance\n //! // to each node. This implementation isn't memory-efficient as it may leave duplicate\n-//! // nodes in the queue. It also uses `uint::MAX` as a sentinel value,\n+//! // nodes in the queue. It also uses `usize::MAX` as a sentinel value,\n //! // for a simpler implementation.\n-//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n+//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> usize {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| uint::MAX).collect();\n+//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| usize::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!\n@@ -98,7 +98,7 @@\n //!     }\n //!\n //!     // Goal not reachable\n-//!     uint::MAX\n+//!     usize::MAX\n //! }\n //!\n //! fn main() {\n@@ -143,7 +143,7 @@\n //!     assert_eq!(shortest_path(&graph, 0, 3), 3);\n //!     assert_eq!(shortest_path(&graph, 3, 0), 7);\n //!     assert_eq!(shortest_path(&graph, 0, 4), 5);\n-//!     assert_eq!(shortest_path(&graph, 4, 0), uint::MAX);\n+//!     assert_eq!(shortest_path(&graph, 4, 0), usize::MAX);\n //! }\n //! ```\n \n@@ -201,7 +201,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4u);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n+    pub fn with_capacity(capacity: usize) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n@@ -295,7 +295,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4u);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint { self.data.capacity() }\n+    pub fn capacity(&self) -> usize { self.data.capacity() }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n@@ -306,7 +306,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -318,7 +318,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4u);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.data.reserve_exact(additional);\n     }\n \n@@ -327,7 +327,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -339,7 +339,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4u);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.data.reserve(additional);\n     }\n \n@@ -497,7 +497,7 @@ impl<T: Ord> BinaryHeap<T> {\n     // zeroed element), shift along the others and move it back into the\n     // vector over the junk element. This reduces the constant factor\n     // compared to using swaps, which involves twice as many moves.\n-    fn sift_up(&mut self, start: uint, mut pos: uint) {\n+    fn sift_up(&mut self, start: usize, mut pos: usize) {\n         unsafe {\n             let new = replace(&mut self.data[pos], zeroed());\n \n@@ -514,7 +514,7 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    fn sift_down_range(&mut self, mut pos: uint, end: uint) {\n+    fn sift_down_range(&mut self, mut pos: usize, end: usize) {\n         unsafe {\n             let start = pos;\n             let new = replace(&mut self.data[pos], zeroed());\n@@ -536,14 +536,14 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    fn sift_down(&mut self, pos: uint) {\n+    fn sift_down(&mut self, pos: usize) {\n         let len = self.len();\n         self.sift_down_range(pos, len);\n     }\n \n     /// Returns the length of the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.data.len() }\n+    pub fn len(&self) -> usize { self.data.len() }\n \n     /// Checks if the binary heap is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -584,7 +584,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -610,7 +610,7 @@ impl<T> Iterator for IntoIter<T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -636,7 +636,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -692,7 +692,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let data = vec!(5, 9, 3);\n+        let data = vec![5, 9, 3];\n         let iterout = [9, 5, 3];\n         let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n@@ -704,27 +704,27 @@ mod tests {\n \n     #[test]\n     fn test_iterator_reverse() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(3, 5, 9);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![3, 5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.iter().rev().map(|&x| x).collect();\n+        let v: Vec<_> = pq.iter().rev().map(|&x| x).collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_move_iter() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(9, 5, 3);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![9, 5, 3];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.into_iter().collect();\n+        let v: Vec<_> = pq.into_iter().collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_move_iter_size_hint() {\n-        let data = vec!(5, 9);\n+        let data = vec![5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n         let mut it = pq.into_iter();\n@@ -741,17 +741,17 @@ mod tests {\n \n     #[test]\n     fn test_move_iter_reverse() {\n-        let data = vec!(5, 9, 3);\n-        let iterout = vec!(3, 5, 9);\n+        let data = vec![5, 9, 3];\n+        let iterout = vec![3, 5, 9];\n         let pq = BinaryHeap::from_vec(data);\n \n-        let v: Vec<int> = pq.into_iter().rev().collect();\n+        let v: Vec<_> = pq.into_iter().rev().collect();\n         assert_eq!(v, iterout);\n     }\n \n     #[test]\n     fn test_peek_and_pop() {\n-        let data = vec!(2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1);\n+        let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n         let mut sorted = data.clone();\n         sorted.sort();\n         let mut heap = BinaryHeap::from_vec(data);\n@@ -763,7 +763,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        let mut heap = BinaryHeap::from_vec(vec!(2, 4, 9));\n+        let mut heap = BinaryHeap::from_vec(vec![2, 4, 9]);\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == 9);\n         heap.push(11);\n@@ -785,7 +785,7 @@ mod tests {\n \n     #[test]\n     fn test_push_unique() {\n-        let mut heap = BinaryHeap::from_vec(vec!(box 2, box 4, box 9));\n+        let mut heap = BinaryHeap::from_vec(vec![box 2, box 4, box 9]);\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.peek().unwrap() == box 9);\n         heap.push(box 11);\n@@ -807,7 +807,7 @@ mod tests {\n \n     #[test]\n     fn test_push_pop() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.push_pop(6), 6);\n         assert_eq!(heap.len(), 5);\n@@ -821,7 +821,7 @@ mod tests {\n \n     #[test]\n     fn test_replace() {\n-        let mut heap = BinaryHeap::from_vec(vec!(5, 5, 2, 1, 3));\n+        let mut heap = BinaryHeap::from_vec(vec![5, 5, 2, 1, 3]);\n         assert_eq!(heap.len(), 5);\n         assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n@@ -833,7 +833,7 @@ mod tests {\n         assert_eq!(heap.len(), 5);\n     }\n \n-    fn check_to_vec(mut data: Vec<int>) {\n+    fn check_to_vec(mut data: Vec<i32>) {\n         let heap = BinaryHeap::from_vec(data.clone());\n         let mut v = heap.clone().into_vec();\n         v.sort();\n@@ -845,44 +845,44 @@ mod tests {\n \n     #[test]\n     fn test_to_vec() {\n-        check_to_vec(vec!());\n-        check_to_vec(vec!(5));\n-        check_to_vec(vec!(3, 2));\n-        check_to_vec(vec!(2, 3));\n-        check_to_vec(vec!(5, 1, 2));\n-        check_to_vec(vec!(1, 100, 2, 3));\n-        check_to_vec(vec!(1, 3, 5, 7, 9, 2, 4, 6, 8, 0));\n-        check_to_vec(vec!(2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1));\n-        check_to_vec(vec!(9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n-        check_to_vec(vec!(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0));\n-        check_to_vec(vec!(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2));\n-        check_to_vec(vec!(5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1));\n+        check_to_vec(vec![]);\n+        check_to_vec(vec![5]);\n+        check_to_vec(vec![3, 2]);\n+        check_to_vec(vec![2, 3]);\n+        check_to_vec(vec![5, 1, 2]);\n+        check_to_vec(vec![1, 100, 2, 3]);\n+        check_to_vec(vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 0]);\n+        check_to_vec(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+        check_to_vec(vec![9, 11, 9, 9, 9, 9, 11, 2, 3, 4, 11, 9, 0, 0, 0, 0]);\n+        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+        check_to_vec(vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);\n+        check_to_vec(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 1, 2]);\n+        check_to_vec(vec![5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n     }\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut heap = BinaryHeap::<int>::new();\n+        let mut heap = BinaryHeap::<i32>::new();\n         assert!(heap.pop().is_none());\n     }\n \n     #[test]\n     fn test_empty_peek() {\n-        let empty = BinaryHeap::<int>::new();\n+        let empty = BinaryHeap::<i32>::new();\n         assert!(empty.peek().is_none());\n     }\n \n     #[test]\n     fn test_empty_replace() {\n-        let mut heap = BinaryHeap::<int>::new();\n+        let mut heap = BinaryHeap::new();\n         assert!(heap.replace(5).is_none());\n     }\n \n     #[test]\n     fn test_from_iter() {\n-        let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n+        let xs = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n \n-        let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<_> = xs.iter().rev().cloned().collect();\n \n         for &x in &xs {\n             assert_eq!(q.pop().unwrap(), x);\n@@ -891,8 +891,7 @@ mod tests {\n \n     #[test]\n     fn test_drain() {\n-        let mut q: BinaryHeap<_> =\n-            [9u, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+        let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n \n         assert_eq!(q.drain().take(5).count(), 5);\n "}, {"sha": "2728e08d6158c5c75f97208d7bb490f5b6a3205b", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -18,7 +18,7 @@\n // rather `or` and `and`.\n \n // (1) Be careful, most things can overflow here because the amount of bits in\n-//     memory can overflow `uint`.\n+//     memory can overflow `usize`.\n // (2) Make sure that the underlying vector has no excess length:\n //     E. g. `nbits == 16`, `storage.len() == 2` would be excess length,\n //     because the last word isn't used at all. This is important because some\n@@ -54,7 +54,7 @@\n //!     bv.set(0, false);\n //!     bv.set(1, false);\n //!\n-//!     for i in iter::range_inclusive(2, (max_prime as f64).sqrt() as uint) {\n+//!     for i in iter::range_inclusive(2, (max_prime as f64).sqrt() as usize) {\n //!         // if i is a prime\n //!         if bv[i] {\n //!             // Mark all multiples of i as non-prime (any multiples below i * i\n@@ -66,7 +66,7 @@\n //! };\n //!\n //! // Simple primality tests below our max bound\n-//! let print_primes = 20u;\n+//! let print_primes = 20;\n //! print!(\"The primes below {} are: \", print_primes);\n //! for x in 0..print_primes {\n //!     if primes.contains(&x) {\n@@ -93,7 +93,7 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::num::Int;\n use core::ops::Index;\n use core::slice;\n-use core::{u8, u32, uint};\n+use core::{u8, u32, usize};\n use bitv_set; //so meta\n \n use Vec;\n@@ -162,15 +162,15 @@ pub struct Bitv {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n-    nbits: uint\n+    nbits: usize\n }\n \n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<uint> for Bitv {\n+impl Index<usize> for Bitv {\n     type Output = bool;\n \n     #[inline]\n-    fn index(&self, i: &uint) -> &bool {\n+    fn index(&self, i: &usize) -> &bool {\n         if self.get(*i).expect(\"index out of bounds\") {\n             &TRUE\n         } else {\n@@ -180,15 +180,15 @@ impl Index<uint> for Bitv {\n }\n \n /// Computes how many blocks are needed to store that many bits\n-fn blocks_for_bits(bits: uint) -> uint {\n+fn blocks_for_bits(bits: usize) -> usize {\n     // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n     // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n     // one too many. So we need to check if that's the case. We can do that by computing if\n     // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n     // superior modulo operator on a power of two to this.\n     //\n     // Note that we can technically avoid this branch with the expression\n-    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost uint::MAX this will overflow.\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n     if bits % u32::BITS == 0 {\n         bits / u32::BITS\n     } else {\n@@ -197,7 +197,7 @@ fn blocks_for_bits(bits: uint) -> uint {\n }\n \n /// Computes the bitmask for the final word of the vector\n-fn mask_for_bits(bits: uint) -> u32 {\n+fn mask_for_bits(bits: usize) -> u32 {\n     // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n     !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n@@ -272,7 +272,7 @@ impl Bitv {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n+    pub fn from_elem(nbits: usize, bit: bool) -> Bitv {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n             storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n@@ -290,7 +290,7 @@ impl Bitv {\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: uint) -> Bitv {\n+    pub fn with_capacity(nbits: usize) -> Bitv {\n         Bitv {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n             nbits: 0,\n@@ -351,7 +351,7 @@ impl Bitv {\n     /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n     /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n     /// ```\n-    pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n+    pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n         let mut bitv = Bitv::from_elem(len, false);\n         for i in 0u..len {\n             bitv.set(i, f(i));\n@@ -376,7 +376,7 @@ impl Bitv {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: uint) -> Option<bool> {\n+    pub fn get(&self, i: usize) -> Option<bool> {\n         if i >= self.nbits {\n             return None;\n         }\n@@ -405,7 +405,7 @@ impl Bitv {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"panic semantics are likely to change in the future\")]\n-    pub fn set(&mut self, i: uint, x: bool) {\n+    pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n@@ -649,7 +649,7 @@ impl Bitv {\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n+        fn bit(bitv: &Bitv, byte: usize, bit: usize) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n                 0\n@@ -709,7 +709,7 @@ impl Bitv {\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         if len < self.len() {\n             self.nbits = len;\n             // This fixes (2).\n@@ -723,7 +723,7 @@ impl Bitv {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -736,7 +736,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n         if desired_cap > self.capacity() {\n@@ -753,7 +753,7 @@ impl Bitv {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -766,7 +766,7 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 13);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let storage_len = self.storage.len();\n         if desired_cap > self.capacity() {\n@@ -788,15 +788,15 @@ impl Bitv {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n-        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n+    pub fn capacity(&self) -> usize {\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n     /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new len overflows a `uint`.\n+    /// Panics if the new len overflows a `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -808,7 +808,7 @@ impl Bitv {\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n     /// ```\n-    pub fn grow(&mut self, n: uint, value: bool) {\n+    pub fn grow(&mut self, n: usize, value: bool) {\n         // Note: we just bulk set all the bits in the last word in this fn in multiple places\n         // which is technically wrong if not all of these bits are to be used. However, at the end\n         // of this fn we call `fix_last_block` at the end of this fn, which should fix this.\n@@ -901,7 +901,7 @@ impl Bitv {\n     /// Return the total number of bits in this vector\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.nbits }\n+    pub fn len(&self) -> usize { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n@@ -1012,8 +1012,8 @@ impl cmp::Eq for Bitv {}\n #[derive(Clone)]\n pub struct Iter<'a> {\n     bitv: &'a Bitv,\n-    next_idx: uint,\n-    end_idx: uint,\n+    next_idx: usize,\n+    end_idx: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1031,7 +1031,7 @@ impl<'a> Iterator for Iter<'a> {\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let rem = self.end_idx - self.next_idx;\n         (rem, Some(rem))\n     }\n@@ -1056,12 +1056,12 @@ impl<'a> ExactSizeIterator for Iter<'a> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.end_idx - self.next_idx\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<bool> {\n+    fn idx(&mut self, index: usize) -> Option<bool> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1083,7 +1083,7 @@ impl<'a> IntoIterator for &'a Bitv {\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n-/// as a `uint`.\n+/// as a `usize`.\n ///\n /// # Examples\n ///\n@@ -1130,18 +1130,18 @@ impl Default for BitvSet {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<uint> for BitvSet {\n-    fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n+impl FromIterator<usize> for BitvSet {\n+    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<uint> for BitvSet {\n+impl Extend<usize> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<Item=uint>>(&mut self, iterator: I) {\n+    fn extend<I: Iterator<Item=usize>>(&mut self, iterator: I) {\n         for i in iterator {\n             self.insert(i);\n         }\n@@ -1207,7 +1207,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: uint) -> BitvSet {\n+    pub fn with_capacity(nbits: usize) -> BitvSet {\n         let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n     }\n@@ -1245,7 +1245,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.bitv.capacity()\n     }\n \n@@ -1266,7 +1266,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: uint) {\n+    pub fn reserve_len(&mut self, len: usize) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n             self.bitv.reserve(len - cur_len);\n@@ -1292,7 +1292,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: uint) {\n+    pub fn reserve_len_exact(&mut self, len: usize) {\n         let cur_len = self.bitv.len();\n         if len >= cur_len {\n             self.bitv.reserve_exact(len - cur_len);\n@@ -1448,7 +1448,7 @@ impl BitvSet {\n         })\n     }\n \n-    /// Iterator over each uint stored in `self` intersect `other`.\n+    /// Iterator over each usize stored in `self` intersect `other`.\n     /// See [intersect_with](#method.intersect_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1478,7 +1478,7 @@ impl BitvSet {\n         }.take(min))\n     }\n \n-    /// Iterator over each uint stored in the `self` setminus `other`.\n+    /// Iterator over each usize stored in the `self` setminus `other`.\n     /// See [difference_with](#method.difference_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1651,7 +1651,7 @@ impl BitvSet {\n     /// Return the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint  {\n+    pub fn len(&self) -> usize  {\n         self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n@@ -1672,7 +1672,7 @@ impl BitvSet {\n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, value: &uint) -> bool {\n+    pub fn contains(&self, value: &usize) -> bool {\n         let bitv = &self.bitv;\n         *value < bitv.nbits && bitv[*value]\n     }\n@@ -1709,7 +1709,7 @@ impl BitvSet {\n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: uint) -> bool {\n+    pub fn insert(&mut self, value: usize) -> bool {\n         if self.contains(&value) {\n             return false;\n         }\n@@ -1727,7 +1727,7 @@ impl BitvSet {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, value: &uint) -> bool {\n+    pub fn remove(&mut self, value: &usize) -> bool {\n         if !self.contains(value) {\n             return false;\n         }\n@@ -1767,7 +1767,7 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n     set: &'a BitvSet,\n-    next_idx: uint\n+    next_idx: usize\n }\n \n /// An iterator combining two `BitvSet` iterators.\n@@ -1777,7 +1777,7 @@ struct TwoBitPositions<'a> {\n     other: &'a BitvSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n-    next_idx: uint\n+    next_idx: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1791,9 +1791,9 @@ pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SetIter<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> {\n+    fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n@@ -1807,16 +1807,16 @@ impl<'a> Iterator for SetIter<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, Some(self.set.bitv.len() - self.next_idx))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> {\n+    fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bitv.len() ||\n               self.next_idx < self.other.bitv.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n@@ -1844,42 +1844,42 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Intersection<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Difference<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for SymmetricDifference<'a> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n }\n \n impl<'a> IntoIterator for &'a BitvSet {\n@@ -2288,7 +2288,7 @@ mod tests {\n \n     #[test]\n     fn test_to_bools() {\n-        let bools = vec!(false, false, true, false, false, true, true, false);\n+        let bools = vec![false, false, true, false, false, true, true, false];\n         assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n@@ -2299,7 +2299,7 @@ mod tests {\n \n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n-        let long = (0i32..10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n+        let long: Vec<_> = (0i32..10000).map(|i| i % 2 == 0).collect();\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n@@ -2530,20 +2530,20 @@ mod bitv_bench {\n \n     use super::Bitv;\n \n-    static BENCH_BITS : uint = 1 << 14;\n+    static BENCH_BITS : usize = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n \n     #[bench]\n-    fn bench_uint_small(b: &mut Bencher) {\n+    fn bench_usize_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = 0 as uint;\n+        let mut bitv = 0 as usize;\n         b.iter(|| {\n             for _ in 0u..100 {\n-                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n+                bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -2555,7 +2555,7 @@ mod bitv_bench {\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+                bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n             black_box(&bitv);\n         });\n@@ -2567,7 +2567,7 @@ mod bitv_bench {\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n+                bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n             black_box(&bitv);\n         });\n@@ -2579,7 +2579,7 @@ mod bitv_bench {\n         let mut bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0u..100 {\n-                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n+                bitv.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n             black_box(&bitv);\n         });\n@@ -2601,7 +2601,7 @@ mod bitv_bench {\n             let mut sum = 0u;\n             for _ in 0u..10 {\n                 for pres in &bitv {\n-                    sum += pres as uint;\n+                    sum += pres as usize;\n                 }\n             }\n             sum\n@@ -2614,7 +2614,7 @@ mod bitv_bench {\n         b.iter(|| {\n             let mut sum = 0u;\n             for pres in &bitv {\n-                sum += pres as uint;\n+                sum += pres as usize;\n             }\n             sum\n         })\n@@ -2645,9 +2645,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_from_uints() {\n-        let uints = vec![0, 2, 2, 3];\n-        let a: BitvSet = uints.into_iter().collect();\n+    fn test_bitv_set_from_usizes() {\n+        let usizes = vec![0, 2, 2, 3];\n+        let a: BitvSet = usizes.into_iter().collect();\n         let mut b = BitvSet::new();\n         b.insert(0);\n         b.insert(2);\n@@ -2657,16 +2657,16 @@ mod bitv_set_test {\n \n     #[test]\n     fn test_bitv_set_iterator() {\n-        let uints = vec![0, 2, 2, 3];\n-        let bitv: BitvSet = uints.into_iter().collect();\n+        let usizes = vec![0, 2, 2, 3];\n+        let bitv: BitvSet = usizes.into_iter().collect();\n \n-        let idxs: Vec<uint> = bitv.iter().collect();\n+        let idxs: Vec<_> = bitv.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n         let long: BitvSet = (0u..10000).filter(|&n| n % 2 == 0).collect();\n-        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n+        let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n-        let idxs: Vec<uint> = long.iter().collect();\n+        let idxs: Vec<_> = long.iter().collect();\n         assert_eq!(idxs, real);\n     }\n \n@@ -2731,7 +2731,7 @@ mod bitv_set_test {\n         assert!(b.insert(3));\n \n         let expected = [3, 5, 11, 77];\n-        let actual = a.intersection(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.intersection(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2750,7 +2750,7 @@ mod bitv_set_test {\n         assert!(b.insert(200));\n \n         let expected = [1, 5, 500];\n-        let actual = a.difference(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.difference(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2771,7 +2771,7 @@ mod bitv_set_test {\n         assert!(b.insert(220));\n \n         let expected = [1, 5, 11, 14, 220];\n-        let actual = a.symmetric_difference(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.symmetric_difference(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -2796,7 +2796,7 @@ mod bitv_set_test {\n         assert!(b.insert(19));\n \n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n-        let actual = a.union(&b).collect::<Vec<uint>>();\n+        let actual: Vec<_> = a.union(&b).collect();\n         assert_eq!(actual, expected);\n     }\n \n@@ -3025,7 +3025,7 @@ mod bitv_set_bench {\n \n     use super::{Bitv, BitvSet};\n \n-    static BENCH_BITS : uint = 1 << 14;\n+    static BENCH_BITS : usize = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n@@ -3037,8 +3037,8 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.insert((r.next_u32() as uint) % u32::BITS);\n+            for _ in 0..100 {\n+                bitv.insert((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -3049,8 +3049,8 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in 0u..100 {\n-                bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n+            for _ in 0..100 {\n+                bitv.insert((r.next_u32() as usize) % BENCH_BITS);\n             }\n             black_box(&bitv);\n         });\n@@ -3061,9 +3061,9 @@ mod bitv_set_bench {\n         let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n-            let mut sum = 0u;\n+            let mut sum = 0;\n             for idx in &bitv {\n-                sum += idx as uint;\n+                sum += idx as usize;\n             }\n             sum\n         })"}, {"sha": "d792bd8d1522d304e95c08d31d46e6e5a87d0b0b", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 47, "deletions": 63, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -63,36 +63,20 @@ use super::node::{self, Node, Found, GoDown};\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n /// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n-/// however, performance is excellent. `BTreeMap` is able to readily outperform `TreeMap` under\n-/// many workloads, and is competitive where it doesn't. BTreeMap also generally *scales* better\n-/// than TreeMap, making it more appropriate for large datasets.\n-///\n-/// However, `TreeMap` may still be more appropriate to use in many contexts. If elements are very\n-/// large or expensive to compare, `TreeMap` may be more appropriate. It won't allocate any\n-/// more space than is needed, and will perform the minimal number of comparisons necessary.\n-/// `TreeMap` also provides much better performance stability guarantees. Generally, very few\n-/// changes need to be made to update a BST, and two updates are expected to take about the same\n-/// amount of time on roughly equal sized BSTs. However a B-Tree's performance is much more\n-/// amortized. If a node is overfull, it must be split into two nodes. If a node is underfull, it\n-/// may be merged with another. Both of these operations are relatively expensive to perform, and\n-/// it's possible to force one to occur at every single level of the tree in a single insertion or\n-/// deletion. In fact, a malicious or otherwise unlucky sequence of insertions and deletions can\n-/// force this degenerate behaviour to occur on every operation. While the total amount of work\n-/// done on each operation isn't *catastrophic*, and *is* still bounded by O(B log<sub>B</sub>n),\n-/// it is certainly much slower when it does.\n+/// however, performance is excellent.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n-    length: uint,\n-    depth: uint,\n-    b: uint,\n+    length: usize,\n+    depth: usize,\n+    b: usize,\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n     traversals: RingBuf<T>,\n-    size: uint,\n+    size: usize,\n }\n \n /// An iterator over a BTreeMap's entries.\n@@ -171,7 +155,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with the given B.\n     ///\n     /// B cannot be less than 2.\n-    pub fn with_b(b: uint) -> BTreeMap<K, V> {\n+    pub fn with_b(b: usize) -> BTreeMap<K, V> {\n         assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {\n             length: 0,\n@@ -1001,7 +985,7 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.size, Some(self.size))\n     }\n }\n@@ -1038,7 +1022,7 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n@@ -1052,7 +1036,7 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n@@ -1066,7 +1050,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n@@ -1080,7 +1064,7 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n@@ -1095,7 +1079,7 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n@@ -1289,7 +1273,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// a.insert(2u, \"b\");\n     ///\n-    /// let keys: Vec<uint> = a.keys().cloned().collect();\n+    /// let keys: Vec<usize> = a.keys().cloned().collect();\n     /// assert_eq!(keys, vec![1u,2,]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1335,7 +1319,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.length }\n+    pub fn len(&self) -> usize { self.length }\n \n     /// Return true if the map contains no elements.\n     ///\n@@ -1546,7 +1530,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     /// use std::collections::btree_map::Entry;\n     ///\n-    /// let mut count: BTreeMap<&str, uint> = BTreeMap::new();\n+    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n     ///\n     /// // count the number of occurrences of letters in the vec\n     /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n@@ -1622,7 +1606,7 @@ mod test {\n     #[test]\n     fn test_basic_large() {\n         let mut map = BTreeMap::new();\n-        let size = 10000u;\n+        let size = 10000;\n         assert_eq!(map.len(), 0);\n \n         for i in 0..size {\n@@ -1669,7 +1653,7 @@ mod test {\n         let mut map = BTreeMap::new();\n         assert_eq!(map.remove(&1), None);\n         assert_eq!(map.get(&1), None);\n-        assert_eq!(map.insert(1u, 1u), None);\n+        assert_eq!(map.insert(1, 1), None);\n         assert_eq!(map.get(&1), Some(&1));\n         assert_eq!(map.insert(1, 2), Some(1));\n         assert_eq!(map.get(&1), Some(&2));\n@@ -1682,12 +1666,12 @@ mod test {\n \n     #[test]\n     fn test_iter() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n+        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n             for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n@@ -1702,12 +1686,12 @@ mod test {\n \n     #[test]\n     fn test_iter_rev() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n+        fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n             for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n@@ -1722,13 +1706,13 @@ mod test {\n \n     #[test]\n     fn test_iter_mixed() {\n-        let size = 10000u;\n+        let size = 10000;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test<T>(size: uint, mut iter: T)\n-                where T: Iterator<Item=(uint, uint)> + DoubleEndedIterator {\n+        fn test<T>(size: usize, mut iter: T)\n+                where T: Iterator<Item=(usize, usize)> + DoubleEndedIterator {\n             for i in 0..size / 4 {\n                 assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n@@ -1748,13 +1732,13 @@ mod test {\n \n     #[test]\n     fn test_range_small() {\n-        let size = 5u;\n+        let size = 5;\n \n         // Forwards\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        let mut j = 0u;\n-        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2u..size) {\n+        let mut j = 0;\n+        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2..size) {\n             assert_eq!(k, i);\n             assert_eq!(v, i);\n             j += 1;\n@@ -1764,10 +1748,10 @@ mod test {\n \n     #[test]\n     fn test_range_1000() {\n-        let size = 1000u;\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let size = 1000;\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-        fn test(map: &BTreeMap<uint, uint>, size: uint, min: Bound<&uint>, max: Bound<&uint>) {\n+        fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n             let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n             let mut pairs = (0..size).map(|i| (i, i));\n \n@@ -1787,8 +1771,8 @@ mod test {\n \n     #[test]\n     fn test_range() {\n-        let size = 200u;\n-        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n+        let size = 200;\n+        let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n         for i in 0..size {\n             for j in i..size {\n@@ -1808,7 +1792,7 @@ mod test {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: BTreeMap<_, _> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -1872,15 +1856,15 @@ mod bench {\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1889,15 +1873,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1906,15 +1890,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n@@ -1923,22 +1907,22 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n+        let mut m = BTreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n-    fn bench_iter(b: &mut Bencher, size: uint) {\n-        let mut map = BTreeMap::<uint, uint>::new();\n+    fn bench_iter(b: &mut Bencher, size: i32) {\n+        let mut map = BTreeMap::<i32, i32>::new();\n         let mut rng = weak_rng();\n \n         for _ in 0..size {"}, {"sha": "429c62c857116970aab064df277cfeb90bcab6b0", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -65,7 +65,7 @@ pub struct Node<K, V> {\n     //\n     // Note: instead of accessing this field directly, please call the `len()` method, which should\n     // be more stable in the face of representation changes.\n-    _len: uint,\n+    _len: usize,\n \n     // FIXME(gereeter) It shouldn't be necessary to store the capacity in every node, as it should\n     // be constant throughout the tree. Once a solution to this is found, it might be possible to\n@@ -74,7 +74,7 @@ pub struct Node<K, V> {\n     //\n     // Note: instead of accessing this field directly, please call the `capacity()` method, which\n     // should be more stable in the face of representation changes.\n-    _capacity: uint,\n+    _capacity: usize,\n }\n \n struct NodeSlice<'a, K: 'a, V: 'a> {\n@@ -102,7 +102,7 @@ struct MutNodeSlice<'a, K: 'a, V: 'a> {\n ///\n /// Fails if `target_alignment` is not a power of two.\n #[inline]\n-fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n     assert!(num::UnsignedInt::is_power_of_two(target_alignment));\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n@@ -120,10 +120,10 @@ fn test_rounding() {\n // Returns a tuple of (val_offset, edge_offset),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_offsets(keys_size: uint,\n-                     vals_size: uint, vals_align: uint,\n-                     edges_align: uint)\n-                     -> (uint, uint) {\n+fn calculate_offsets(keys_size: usize,\n+                     vals_size: usize, vals_align: usize,\n+                     edges_align: usize)\n+                     -> (usize, usize) {\n     let vals_offset = round_up_to_next(keys_size, vals_align);\n     let end_of_vals = vals_offset + vals_size;\n \n@@ -135,10 +135,10 @@ fn calculate_offsets(keys_size: uint,\n // Returns a tuple of (minimum required alignment, array_size),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_allocation(keys_size: uint, keys_align: uint,\n-                        vals_size: uint, vals_align: uint,\n-                        edges_size: uint, edges_align: uint)\n-                        -> (uint, uint) {\n+fn calculate_allocation(keys_size: usize, keys_align: usize,\n+                        vals_size: usize, vals_align: usize,\n+                        edges_size: usize, edges_align: usize)\n+                        -> (usize, usize) {\n     let (_, edges_offset) = calculate_offsets(keys_size,\n                                               vals_size, vals_align,\n                                                          edges_align);\n@@ -159,7 +159,7 @@ fn test_offset_calculation() {\n     assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24));\n }\n \n-fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let (keys_size, keys_align) = (capacity * mem::size_of::<K>(), mem::min_align_of::<K>());\n     let (vals_size, vals_align) = (capacity * mem::size_of::<V>(), mem::min_align_of::<V>());\n     let (edges_size, edges_align) = if is_leaf {\n@@ -175,7 +175,7 @@ fn calculate_allocation_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, u\n     )\n }\n \n-fn calculate_offsets_generic<K, V>(capacity: uint, is_leaf: bool) -> (uint, uint) {\n+fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n     let keys_size = capacity * mem::size_of::<K>();\n     let vals_size = capacity * mem::size_of::<V>();\n     let vals_align = mem::min_align_of::<V>();\n@@ -203,16 +203,16 @@ impl<T> RawItems<T> {\n         RawItems::from_parts(slice.as_ptr(), slice.len())\n     }\n \n-    unsafe fn from_parts(ptr: *const T, len: uint) -> RawItems<T> {\n+    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n         if mem::size_of::<T>() == 0 {\n             RawItems {\n                 head: ptr,\n-                tail: (ptr as uint + len) as *const T,\n+                tail: (ptr as usize + len) as *const T,\n             }\n         } else {\n             RawItems {\n                 head: ptr,\n-                tail: ptr.offset(len as int),\n+                tail: ptr.offset(len as isize),\n             }\n         }\n     }\n@@ -221,7 +221,7 @@ impl<T> RawItems<T> {\n         ptr::write(self.tail as *mut T, val);\n \n         if mem::size_of::<T>() == 0 {\n-            self.tail = (self.tail as uint + 1) as *const T;\n+            self.tail = (self.tail as usize + 1) as *const T;\n         } else {\n             self.tail = self.tail.offset(1);\n         }\n@@ -239,7 +239,7 @@ impl<T> Iterator for RawItems<T> {\n                 let ret = Some(ptr::read(self.head));\n \n                 if mem::size_of::<T>() == 0 {\n-                    self.head = (self.head as uint + 1) as *const T;\n+                    self.head = (self.head as usize + 1) as *const T;\n                 } else {\n                     self.head = self.head.offset(1);\n                 }\n@@ -257,7 +257,7 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n         } else {\n             unsafe {\n                 if mem::size_of::<T>() == 0 {\n-                    self.tail = (self.tail as uint - 1) as *const T;\n+                    self.tail = (self.tail as usize - 1) as *const T;\n                 } else {\n                     self.tail = self.tail.offset(-1);\n                 }\n@@ -299,7 +299,7 @@ impl<K, V> Drop for Node<K, V> {\n impl<K, V> Node<K, V> {\n     /// Make a new internal node. The caller must initialize the result to fix the invariant that\n     /// there are `len() + 1` edges.\n-    unsafe fn new_internal(capacity: uint) -> Node<K, V> {\n+    unsafe fn new_internal(capacity: usize) -> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n \n         let buffer = heap::allocate(size, alignment);\n@@ -309,15 +309,15 @@ impl<K, V> Node<K, V> {\n \n         Node {\n             keys: Unique(buffer as *mut K),\n-            vals: Unique(buffer.offset(vals_offset as int) as *mut V),\n-            edges: Unique(buffer.offset(edges_offset as int) as *mut Node<K, V>),\n+            vals: Unique(buffer.offset(vals_offset as isize) as *mut V),\n+            edges: Unique(buffer.offset(edges_offset as isize) as *mut Node<K, V>),\n             _len: 0,\n             _capacity: capacity,\n         }\n     }\n \n     /// Make a new leaf node\n-    fn new_leaf(capacity: uint) -> Node<K, V> {\n+    fn new_leaf(capacity: usize) -> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n \n         let buffer = unsafe { heap::allocate(size, alignment) };\n@@ -327,7 +327,7 @@ impl<K, V> Node<K, V> {\n \n         Node {\n             keys: Unique(buffer as *mut K),\n-            vals: Unique(unsafe { buffer.offset(vals_offset as int) as *mut V }),\n+            vals: Unique(unsafe { buffer.offset(vals_offset as isize) as *mut V }),\n             edges: Unique(ptr::null_mut()),\n             _len: 0,\n             _capacity: capacity,\n@@ -479,15 +479,15 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///\n /// ```rust,ignore\n /// struct Nasty<'a> {\n-///     first: &'a Node<uint, uint>,\n-///     second: &'a Node<uint, uint>,\n+///     first: &'a Node<usize, usize>,\n+///     second: &'a Node<usize, usize>,\n ///     flag: &'a Cell<bool>,\n /// }\n ///\n /// impl<'a> Deref for Nasty<'a> {\n-///     type Target = Node<uint, uint>;\n+///     type Target = Node<usize, usize>;\n ///\n-///     fn deref(&self) -> &Node<uint, uint> {\n+///     fn deref(&self) -> &Node<usize, usize> {\n ///         if self.flag.get() {\n ///             &*self.second\n ///         } else {\n@@ -524,7 +524,7 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n #[derive(Copy)]\n pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n-    index: uint\n+    index: usize\n }\n \n pub mod handle {\n@@ -546,7 +546,7 @@ impl<K: Ord, V> Node<K, V> {\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n-        // worse for uints.\n+        // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n             (index, true) => Found(Handle { node: node, index: index }),\n             (index, false) => GoDown(Handle { node: node, index: index }),\n@@ -557,12 +557,12 @@ impl<K: Ord, V> Node<K, V> {\n // Public interface\n impl <K, V> Node<K, V> {\n     /// Make a leaf root from scratch\n-    pub fn make_leaf_root(b: uint) -> Node<K, V> {\n+    pub fn make_leaf_root(b: usize) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n     }\n \n     /// Make an internal root and swap it with an old root\n-    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: uint, key: K, value: V,\n+    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: usize, key: K, value: V,\n             right: Node<K,V>) {\n         let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n@@ -575,12 +575,12 @@ impl <K, V> Node<K, V> {\n     }\n \n     /// How many key-value pairs the node contains\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self._len\n     }\n \n     /// How many key-value pairs the node can fit\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self._capacity\n     }\n \n@@ -1038,7 +1038,7 @@ impl<K, V> Node<K, V> {\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, handle::KV,\n+    pub fn kv_handle(&mut self, index: usize) -> Handle<&mut Node<K, V>, handle::KV,\n                                                        handle::LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n@@ -1114,15 +1114,15 @@ impl<K, V> Node<K, V> {\n \n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n-    unsafe fn insert_kv(&mut self, index: uint, key: K, val: V) -> &mut V {\n+    unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n         ptr::copy_memory(\n-            self.keys_mut().as_mut_ptr().offset(index as int + 1),\n-            self.keys().as_ptr().offset(index as int),\n+            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.keys().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n         ptr::copy_memory(\n-            self.vals_mut().as_mut_ptr().offset(index as int + 1),\n-            self.vals().as_ptr().offset(index as int),\n+            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.vals().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n \n@@ -1136,10 +1136,10 @@ impl<K, V> Node<K, V> {\n \n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n-    unsafe fn insert_edge(&mut self, index: uint, edge: Node<K, V>) {\n+    unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n         ptr::copy_memory(\n-            self.edges_mut().as_mut_ptr().offset(index as int + 1),\n-            self.edges().as_ptr().offset(index as int),\n+            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n+            self.edges().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n@@ -1166,18 +1166,18 @@ impl<K, V> Node<K, V> {\n \n     // This must be followed by remove_edge on an internal node.\n     #[inline]\n-    unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n+    unsafe fn remove_kv(&mut self, index: usize) -> (K, V) {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy_memory(\n-            self.keys_mut().as_mut_ptr().offset(index as int),\n-            self.keys().as_ptr().offset(index as int + 1),\n+            self.keys_mut().as_mut_ptr().offset(index as isize),\n+            self.keys().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n         ptr::copy_memory(\n-            self.vals_mut().as_mut_ptr().offset(index as int),\n-            self.vals().as_ptr().offset(index as int + 1),\n+            self.vals_mut().as_mut_ptr().offset(index as isize),\n+            self.vals().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n \n@@ -1188,12 +1188,12 @@ impl<K, V> Node<K, V> {\n \n     // This can only be called immediately after a call to remove_kv.\n     #[inline]\n-    unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n+    unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy_memory(\n-            self.edges_mut().as_mut_ptr().offset(index as int),\n-            self.edges().as_ptr().offset(index as int + 1),\n+            self.edges_mut().as_mut_ptr().offset(index as isize),\n+            self.edges().as_ptr().offset(index as isize + 1),\n             self.len() - index + 1\n         );\n \n@@ -1220,18 +1220,18 @@ impl<K, V> Node<K, V> {\n             let right_offset = self.len() - right.len();\n             ptr::copy_nonoverlapping_memory(\n                 right.keys_mut().as_mut_ptr(),\n-                self.keys().as_ptr().offset(right_offset as int),\n+                self.keys().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping_memory(\n                 right.vals_mut().as_mut_ptr(),\n-                self.vals().as_ptr().offset(right_offset as int),\n+                self.vals().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping_memory(\n                     right.edges_mut().as_mut_ptr(),\n-                    self.edges().as_ptr().offset(right_offset as int),\n+                    self.edges().as_ptr().offset(right_offset as isize),\n                     right.len() + 1\n                 );\n             }\n@@ -1260,18 +1260,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping_memory(\n-                self.keys_mut().as_mut_ptr().offset(old_len as int + 1),\n+                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping_memory(\n-                self.vals_mut().as_mut_ptr().offset(old_len as int + 1),\n+                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping_memory(\n-                    self.edges_mut().as_mut_ptr().offset(old_len as int + 1),\n+                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n                     right.len() + 1\n                 );\n@@ -1284,12 +1284,12 @@ impl<K, V> Node<K, V> {\n }\n \n /// Get the capacity of a node from the order of the parent B-Tree\n-fn capacity_from_b(b: uint) -> uint {\n+fn capacity_from_b(b: usize) -> usize {\n     2 * b - 1\n }\n \n /// Get the minimum load of a node from its capacity\n-fn min_load_from_capacity(cap: uint) -> uint {\n+fn min_load_from_capacity(cap: usize) -> usize {\n     // B - 1\n     cap / 2\n }\n@@ -1334,7 +1334,7 @@ struct MoveTraversalImpl<K, V> {\n \n     // For deallocation when we are done iterating.\n     ptr: *mut u8,\n-    capacity: uint,\n+    capacity: usize,\n     is_leaf: bool\n }\n \n@@ -1490,7 +1490,7 @@ macro_rules! node_slice_impl {\n      $as_slices_internal:ident, $index:ident, $iter:ident) => {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n-            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n+            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (usize, bool)\n                     where Q: BorrowFrom<K> + Ord {\n                 for (i, k) in self.keys.iter().enumerate() {\n                     match key.cmp(BorrowFrom::borrow_from(k)) {"}, {"sha": "b02c522f86da92471eeda0c049a58f71df16b867", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -101,7 +101,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// B cannot be less than 2.\n     #[unstable(feature = \"collections\",\n                reason = \"probably want this to be on the type, eventually\")]\n-    pub fn with_b(b: uint) -> BTreeSet<T> {\n+    pub fn with_b(b: usize) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }\n }\n@@ -114,13 +114,13 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// for x in set.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let v: Vec<uint> = set.iter().map(|&x| x).collect();\n+    /// let v: Vec<usize> = set.iter().map(|&x| x).collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -135,9 +135,9 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<uint> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n-    /// let v: Vec<uint> = set.into_iter().collect();\n+    /// let v: Vec<usize> = set.into_iter().collect();\n     /// assert_eq!(v, vec![1u,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -196,7 +196,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(2u);\n     /// b.insert(3u);\n     ///\n-    /// let diff: Vec<uint> = a.difference(&b).cloned().collect();\n+    /// let diff: Vec<usize> = a.difference(&b).cloned().collect();\n     /// assert_eq!(diff, vec![1u]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -219,7 +219,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(2u);\n     /// b.insert(3u);\n     ///\n-    /// let sym_diff: Vec<uint> = a.symmetric_difference(&b).cloned().collect();\n+    /// let sym_diff: Vec<usize> = a.symmetric_difference(&b).cloned().collect();\n     /// assert_eq!(sym_diff, vec![1u,3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -243,7 +243,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(2u);\n     /// b.insert(3u);\n     ///\n-    /// let intersection: Vec<uint> = a.intersection(&b).cloned().collect();\n+    /// let intersection: Vec<usize> = a.intersection(&b).cloned().collect();\n     /// assert_eq!(intersection, vec![2u]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -265,7 +265,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// let mut b = BTreeSet::new();\n     /// b.insert(2u);\n     ///\n-    /// let union: Vec<uint> = a.union(&b).cloned().collect();\n+    /// let union: Vec<usize> = a.union(&b).cloned().collect();\n     /// assert_eq!(union, vec![1u,2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -286,7 +286,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.map.len() }\n+    pub fn len(&self) -> usize { self.map.len() }\n \n     /// Returns true if the set contains no elements\n     ///\n@@ -625,7 +625,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -640,7 +640,7 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n@@ -770,23 +770,23 @@ mod test {\n     }\n \n     struct Counter<'a, 'b> {\n-        i: &'a mut uint,\n-        expected: &'b [int],\n+        i: &'a mut usize,\n+        expected: &'b [i32],\n     }\n \n-    impl<'a, 'b, 'c> FnMut<(&'c int,)> for Counter<'a, 'b> {\n+    impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n         type Output = bool;\n \n-        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;\n             true\n         }\n     }\n \n-    fn check<F>(a: &[int], b: &[int], expected: &[int], f: F) where\n+    fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n         // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n-        F: FnOnce(&BTreeSet<int>, &BTreeSet<int>, Counter) -> bool,\n+        F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,\n     {\n         let mut set_a = BTreeSet::new();\n         let mut set_b = BTreeSet::new();\n@@ -801,7 +801,7 @@ mod test {\n \n     #[test]\n     fn test_intersection() {\n-        fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n+        fn check_intersection(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n         }\n \n@@ -817,7 +817,7 @@ mod test {\n \n     #[test]\n     fn test_difference() {\n-        fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n+        fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.difference(y).all(f))\n         }\n \n@@ -834,8 +834,7 @@ mod test {\n \n     #[test]\n     fn test_symmetric_difference() {\n-        fn check_symmetric_difference(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n+        fn check_symmetric_difference(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n         }\n \n@@ -849,8 +848,7 @@ mod test {\n \n     #[test]\n     fn test_union() {\n-        fn check_union(a: &[int], b: &[int],\n-                                      expected: &[int]) {\n+        fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n             check(a, b, expected, |x, y, f| x.union(y).all(f))\n         }\n \n@@ -865,9 +863,9 @@ mod test {\n     #[test]\n     fn test_zip() {\n         let mut x = BTreeSet::new();\n-        x.insert(5u);\n-        x.insert(12u);\n-        x.insert(11u);\n+        x.insert(5);\n+        x.insert(12);\n+        x.insert(11);\n \n         let mut y = BTreeSet::new();\n         y.insert(\"foo\");\n@@ -878,13 +876,13 @@ mod test {\n         let mut z = x.iter().zip(y.iter());\n \n         // FIXME: #5801: this needs a type hint to compile...\n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&5u, &(\"bar\")));\n+        let result: Option<(&usize, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&5, &(\"bar\")));\n \n-        let result: Option<(&uint, & &'static str)> = z.next();\n-        assert_eq!(result.unwrap(), (&11u, &(\"foo\")));\n+        let result: Option<(&usize, & &'static str)> = z.next();\n+        assert_eq!(result.unwrap(), (&11, &(\"foo\")));\n \n-        let result: Option<(&uint, & &'static str)> = z.next();\n+        let result: Option<(&usize, & &'static str)> = z.next();\n         assert!(result.is_none());\n     }\n "}, {"sha": "748230c5d24cf9765a1dc9ba12fe5c0b64c0ab92", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -35,7 +35,7 @@ use core::ptr;\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DList<T> {\n-    length: uint,\n+    length: usize,\n     list_head: Link<T>,\n     list_tail: Rawlink<Node<T>>,\n }\n@@ -61,7 +61,7 @@ struct Node<T> {\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n-    nelem: uint,\n+    nelem: usize,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n@@ -82,7 +82,7 @@ pub struct IterMut<'a, T:'a> {\n     list: &'a mut DList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n-    nelem: uint,\n+    nelem: usize,\n }\n \n /// An iterator over mutable references to the items of a `DList`.\n@@ -345,7 +345,7 @@ impl<T> DList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.length\n     }\n \n@@ -578,7 +578,7 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: uint) -> DList<T> {\n+    pub fn split_off(&mut self, at: usize) -> DList<T> {\n         let len = self.len();\n         assert!(at < len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n@@ -659,7 +659,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.nelem, Some(self.nelem))\n     }\n }\n@@ -701,7 +701,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.nelem, Some(self.nelem))\n     }\n }\n@@ -810,7 +810,7 @@ impl<A> Iterator for IntoIter<A> {\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.list.length, Some(self.list.length))\n     }\n }\n@@ -935,11 +935,11 @@ mod tests {\n     use super::{DList, Node};\n \n     pub fn check_links<T>(list: &DList<T>) {\n-        let mut len = 0u;\n+        let mut len = 0;\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n         match list.list_head {\n-            None => { assert_eq!(0u, list.length); return }\n+            None => { assert_eq!(0, list.length); return }\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n@@ -968,7 +968,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m: DList<Box<int>> = DList::new();\n+        let mut m = DList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -1007,7 +1007,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> DList<int> {\n+    fn generate_test() -> DList<i32> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n@@ -1020,7 +1020,7 @@ mod tests {\n     fn test_append() {\n         // Empty to empty\n         {\n-            let mut m: DList<int> = DList::new();\n+            let mut m = DList::<i32>::new();\n             let mut n = DList::new();\n             m.append(&mut n);\n             check_links(&m);\n@@ -1122,7 +1122,7 @@ mod tests {\n     fn test_iterator() {\n         let m = generate_test();\n         for (i, elt) in m.iter().enumerate() {\n-            assert_eq!(i as int, *elt);\n+            assert_eq!(i as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n@@ -1170,7 +1170,7 @@ mod tests {\n     fn test_rev_iter() {\n         let m = generate_test();\n         for (i, elt) in m.iter().rev().enumerate() {\n-            assert_eq!((6 - i) as int, *elt);\n+            assert_eq!((6 - i) as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert_eq!(n.iter().rev().next(), None);\n@@ -1187,7 +1187,7 @@ mod tests {\n         let mut m = generate_test();\n         let mut len = m.len();\n         for (i, elt) in m.iter_mut().enumerate() {\n-            assert_eq!(i as int, *elt);\n+            assert_eq!(i as i32, *elt);\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n@@ -1245,14 +1245,14 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<int>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n         for (i, elt) in m.iter_mut().rev().enumerate() {\n-            assert_eq!((6-i) as int, *elt);\n+            assert_eq!((6 - i) as i32, *elt);\n         }\n         let mut n = DList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n@@ -1268,13 +1268,13 @@ mod tests {\n         Thread::scoped(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<&int>>());\n+            assert_eq!(a, n.iter().collect::<Vec<_>>());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_eq() {\n-        let mut n: DList<u8> = list_from(&[]);\n+        let mut n = list_from(&[]);\n         let mut m = list_from(&[]);\n         assert!(n == m);\n         n.push_front(1);\n@@ -1307,7 +1307,7 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let n: DList<int> = list_from(&[]);\n+        let n = list_from(&[]);\n         let m = list_from(&[1,2,3]);\n         assert!(n < m);\n         assert!(m > n);\n@@ -1349,7 +1349,7 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        for _ in 0u..25 {\n+        for _ in 0..25 {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n@@ -1358,18 +1358,16 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<i32> = (0..10).collect();\n+        let list: DList<_> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                   .map(|&s| s)\n-                                                                   .collect();\n+        let list: DList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]\n-    fn fuzz_test(sz: int) {\n-        let mut m: DList<int> = DList::new();\n+    fn fuzz_test(sz: i32) {\n+        let mut m: DList<_> = DList::new();\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n@@ -1398,7 +1396,7 @@ mod tests {\n \n         check_links(&m);\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         for (a, &b) in m.into_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n@@ -1410,29 +1408,29 @@ mod tests {\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0; 64];\n         b.iter(|| {\n-            let _: DList<int> = v.iter().map(|x| *x).collect();\n+            let _: DList<_> = v.iter().cloned().collect();\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_front(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n@@ -1441,7 +1439,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: DList<int> = DList::new();\n+        let mut m: DList<_> = DList::new();\n         b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n@@ -1451,31 +1449,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<int> = v.iter().map(|&x|x).collect();\n+        let m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n+        let mut m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<int> = v.iter().map(|&x|x).collect();\n+        let m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n+        let mut m: DList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);\n         })"}, {"sha": "da146506077478a22dd1ff58e56f17393cb785c2", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -26,7 +26,7 @@ use core::ops::{Sub, BitOr, BitAnd, BitXor};\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set\n     // for which no variant exists\n-    bits: uint\n+    bits: usize\n }\n \n impl<E> Copy for EnumSet<E> {}\n@@ -47,37 +47,37 @@ impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     }\n }\n \n-/// An interface for casting C-like enum to uint and back.\n+/// An interface for casting C-like enum to usize and back.\n /// A typically implementation is as below.\n ///\n /// ```{rust,ignore}\n-/// #[repr(uint)]\n+/// #[repr(usize)]\n /// enum Foo {\n ///     A, B, C\n /// }\n ///\n /// impl CLike for Foo {\n-///     fn to_uint(&self) -> uint {\n-///         *self as uint\n+///     fn to_usize(&self) -> usize {\n+///         *self as usize\n ///     }\n ///\n-///     fn from_uint(v: uint) -> Foo {\n+///     fn from_usize(v: usize) -> Foo {\n ///         unsafe { mem::transmute(v) }\n ///     }\n /// }\n /// ```\n pub trait CLike {\n-    /// Converts a C-like enum to a `uint`.\n-    fn to_uint(&self) -> uint;\n-    /// Converts a `uint` to a C-like enum.\n-    fn from_uint(uint) -> Self;\n+    /// Converts a C-like enum to a `usize`.\n+    fn to_usize(&self) -> usize;\n+    /// Converts a `usize` to a C-like enum.\n+    fn from_usize(usize) -> Self;\n }\n \n-fn bit<E:CLike>(e: &E) -> uint {\n-    use core::uint;\n-    let value = e.to_uint();\n-    assert!(value < uint::BITS,\n-            \"EnumSet only supports up to {} variants.\", uint::BITS - 1);\n+fn bit<E:CLike>(e: &E) -> usize {\n+    use core::usize;\n+    let value = e.to_usize();\n+    assert!(value < usize::BITS,\n+            \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n     1 << value\n }\n \n@@ -92,7 +92,7 @@ impl<E:CLike> EnumSet<E> {\n     /// Returns the number of elements in the given `EnumSet`.\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.bits.count_ones()\n     }\n \n@@ -205,8 +205,8 @@ impl<E:CLike> BitXor for EnumSet<E> {\n \n /// An iterator over an EnumSet\n pub struct Iter<E> {\n-    index: uint,\n-    bits: uint,\n+    index: usize,\n+    bits: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -220,7 +220,7 @@ impl<E> Clone for Iter<E> {\n }\n \n impl<E:CLike> Iter<E> {\n-    fn new(bits: uint) -> Iter<E> {\n+    fn new(bits: usize) -> Iter<E> {\n         Iter { index: 0, bits: bits }\n     }\n }\n@@ -237,13 +237,13 @@ impl<E:CLike> Iterator for Iter<E> {\n             self.index += 1;\n             self.bits >>= 1;\n         }\n-        let elem = CLike::from_uint(self.index);\n+        let elem = CLike::from_usize(self.index);\n         self.index += 1;\n         self.bits >>= 1;\n         Some(elem)\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let exact = self.bits.count_ones();\n         (exact, Some(exact))\n     }\n@@ -282,17 +282,17 @@ mod test {\n     use super::{EnumSet, CLike};\n \n     #[derive(Copy, PartialEq, Debug)]\n-    #[repr(uint)]\n+    #[repr(usize)]\n     enum Foo {\n         A, B, C\n     }\n \n     impl CLike for Foo {\n-        fn to_uint(&self) -> uint {\n-            *self as uint\n+        fn to_usize(&self) -> usize {\n+            *self as usize\n         }\n \n-        fn from_uint(v: uint) -> Foo {\n+        fn from_usize(v: usize) -> Foo {\n             unsafe { mem::transmute(v) }\n         }\n     }\n@@ -486,7 +486,7 @@ mod test {\n     fn test_overflow() {\n         #[allow(dead_code)]\n         #[derive(Copy)]\n-        #[repr(uint)]\n+        #[repr(usize)]\n         enum Bar {\n             V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n             V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n@@ -498,11 +498,11 @@ mod test {\n         }\n \n         impl CLike for Bar {\n-            fn to_uint(&self) -> uint {\n-                *self as uint\n+            fn to_usize(&self) -> usize {\n+                *self as usize\n             }\n \n-            fn from_uint(v: uint) -> Bar {\n+            fn from_usize(v: usize) -> Bar {\n                 unsafe { mem::transmute(v) }\n             }\n         }"}, {"sha": "85c4a64c0c1722575fcf06b47caf5533b8c48a0a", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 103, "deletions": 111, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -32,8 +32,8 @@ use std::cmp;\n \n use alloc::heap;\n \n-static INITIAL_CAPACITY: uint = 7u; // 2^3 - 1\n-static MINIMUM_CAPACITY: uint = 1u; // 2 - 1\n+static INITIAL_CAPACITY: usize = 7u; // 2^3 - 1\n+static MINIMUM_CAPACITY: usize = 1u; // 2 - 1\n \n /// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -44,9 +44,9 @@ pub struct RingBuf<T> {\n     // If tail == head the buffer is empty. The length of the ringbuf\n     // is defined as the distance between the two.\n \n-    tail: uint,\n-    head: uint,\n-    cap: uint,\n+    tail: usize,\n+    head: usize,\n+    cap: usize,\n     ptr: *mut T\n }\n \n@@ -59,7 +59,7 @@ unsafe impl<T: Sync> Sync for RingBuf<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RingBuf<T> {\n     fn clone(&self) -> RingBuf<T> {\n-        self.iter().map(|t| t.clone()).collect()\n+        self.iter().cloned().collect()\n     }\n }\n \n@@ -99,14 +99,14 @@ impl<T> RingBuf<T> {\n \n     /// Moves an element out of the buffer\n     #[inline]\n-    unsafe fn buffer_read(&mut self, off: uint) -> T {\n-        ptr::read(self.ptr.offset(off as int))\n+    unsafe fn buffer_read(&mut self, off: usize) -> T {\n+        ptr::read(self.ptr.offset(off as isize))\n     }\n \n     /// Writes an element into the buffer, moving it.\n     #[inline]\n-    unsafe fn buffer_write(&mut self, off: uint, t: T) {\n-        ptr::write(self.ptr.offset(off as int), t);\n+    unsafe fn buffer_write(&mut self, off: usize, t: T) {\n+        ptr::write(self.ptr.offset(off as isize), t);\n     }\n \n     /// Returns true iff the buffer is at capacity\n@@ -115,31 +115,31 @@ impl<T> RingBuf<T> {\n \n     /// Returns the index in the underlying buffer for a given logical element index.\n     #[inline]\n-    fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n+    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy(&self, dst: uint, src: uint, len: uint) {\n+    unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n         debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_memory(\n-            self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int),\n+            self.ptr.offset(dst as isize),\n+            self.ptr.offset(src as isize),\n             len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy_nonoverlapping(&self, dst: uint, src: uint, len: uint) {\n+    unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n         debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_nonoverlapping_memory(\n-            self.ptr.offset(dst as int),\n-            self.ptr.offset(src as int),\n+            self.ptr.offset(dst as isize),\n+            self.ptr.offset(src as isize),\n             len);\n     }\n }\n@@ -153,7 +153,7 @@ impl<T> RingBuf<T> {\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: uint) -> RingBuf<T> {\n+    pub fn with_capacity(n: usize) -> RingBuf<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n@@ -192,10 +192,10 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: uint) -> Option<&T> {\n+    pub fn get(&self, i: usize) -> Option<&T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n-            unsafe { Some(&*self.ptr.offset(idx as int)) }\n+            unsafe { Some(&*self.ptr.offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -222,10 +222,10 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n+    pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n         if i < self.len() {\n             let idx = self.wrap_index(self.tail + i);\n-            unsafe { Some(&mut *self.ptr.offset(idx as int)) }\n+            unsafe { Some(&mut *self.ptr.offset(idx as isize)) }\n         } else {\n             None\n         }\n@@ -251,13 +251,13 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf[2], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap(&mut self, i: uint, j: uint) {\n+    pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n         let ri = self.wrap_index(self.tail + i);\n         let rj = self.wrap_index(self.tail + j);\n         unsafe {\n-            ptr::swap(self.ptr.offset(ri as int), self.ptr.offset(rj as int))\n+            ptr::swap(self.ptr.offset(ri as isize), self.ptr.offset(rj as isize))\n         }\n     }\n \n@@ -274,7 +274,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint { self.cap - 1 }\n+    pub fn capacity(&self) -> usize { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n@@ -285,7 +285,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -297,7 +297,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.reserve(additional);\n     }\n \n@@ -306,7 +306,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -318,7 +318,7 @@ impl<T> RingBuf<T> {\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let new_len = self.len() + additional;\n         assert!(new_len + 1 > self.len(), \"capacity overflow\");\n         if new_len > self.capacity() {\n@@ -482,7 +482,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n             self.pop_back();\n         }\n@@ -604,7 +604,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n+    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -878,7 +878,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n-    pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n+    pub fn swap_back_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length - 1 {\n             self.swap(index, length - 1);\n@@ -911,7 +911,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n-    pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n+    pub fn swap_front_remove(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n         if length > 0 && index < length && index != 0 {\n             self.swap(index, 0);\n@@ -939,7 +939,7 @@ impl<T> RingBuf<T> {\n     /// buf.insert(1,11);\n     /// assert_eq!(Some(&11), buf.get(1));\n     /// ```\n-    pub fn insert(&mut self, i: uint, t: T) {\n+    pub fn insert(&mut self, i: usize, t: T) {\n         assert!(i <= self.len(), \"index out of bounds\");\n         if self.is_full() {\n             self.reserve(1);\n@@ -1144,7 +1144,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(Some(&15), buf.get(2));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, i: uint) -> Option<T> {\n+    pub fn remove(&mut self, i: usize) -> Option<T> {\n         if self.is_empty() || self.len() <= i {\n             return None;\n         }\n@@ -1312,7 +1312,7 @@ impl<T: Clone> RingBuf<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n         if new_len > len {\n@@ -1325,14 +1325,14 @@ impl<T: Clone> RingBuf<T> {\n \n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n-fn wrap_index(index: uint, size: uint) -> uint {\n+fn wrap_index(index: usize, size: usize) -> usize {\n     // size is always a power of 2\n     index & (size - 1)\n }\n \n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n-fn count(tail: uint, head: uint, size: uint) -> uint {\n+fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n     (head - tail) & (size - 1)\n }\n@@ -1341,8 +1341,8 @@ fn count(tail: uint, head: uint, size: uint) -> uint {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n-    tail: uint,\n-    head: uint\n+    tail: usize,\n+    head: usize\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1371,7 +1371,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n@@ -1395,13 +1395,13 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (len, _) = self.size_hint();\n         len\n     }\n \n     #[inline]\n-    fn idx(&mut self, j: uint) -> Option<&'a T> {\n+    fn idx(&mut self, j: usize) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {\n@@ -1418,9 +1418,9 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n-    tail: uint,\n-    head: uint,\n-    cap: uint,\n+    tail: usize,\n+    head: usize,\n+    cap: usize,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n@@ -1437,12 +1437,12 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         self.tail = wrap_index(self.tail + 1, self.cap);\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(tail as int))\n+            Some(&mut *self.ptr.offset(tail as isize))\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = count(self.tail, self.head, self.cap);\n         (len, Some(len))\n     }\n@@ -1458,7 +1458,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         self.head = wrap_index(self.head - 1, self.cap);\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(self.head as int))\n+            Some(&mut *self.ptr.offset(self.head as isize))\n         }\n     }\n }\n@@ -1482,7 +1482,7 @@ impl<T> Iterator for IntoIter<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n@@ -1526,7 +1526,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.inner.len();\n         (len, Some(len))\n     }\n@@ -1580,21 +1580,21 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<uint> for RingBuf<A> {\n+impl<A> Index<usize> for RingBuf<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a A {\n+    fn index<'a>(&'a self, i: &usize) -> &'a A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<uint> for RingBuf<A> {\n+impl<A> IndexMut<usize> for RingBuf<A> {\n     type Output = A;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n+    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n@@ -1673,13 +1673,13 @@ mod tests {\n     #[allow(deprecated)]\n     fn test_simple() {\n         let mut d = RingBuf::new();\n-        assert_eq!(d.len(), 0u);\n+        assert_eq!(d.len(), 0);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n-        assert_eq!(d.len(), 3u);\n+        assert_eq!(d.len(), 3);\n         d.push_back(137);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         assert_eq!(*d.front().unwrap(), 42);\n         assert_eq!(*d.back().unwrap(), 137);\n         let mut i = d.pop_front();\n@@ -1690,15 +1690,15 @@ mod tests {\n         assert_eq!(i, Some(137));\n         i = d.pop_back();\n         assert_eq!(i, Some(17));\n-        assert_eq!(d.len(), 0u);\n+        assert_eq!(d.len(), 0);\n         d.push_back(3);\n-        assert_eq!(d.len(), 1u);\n+        assert_eq!(d.len(), 1);\n         d.push_front(2);\n-        assert_eq!(d.len(), 2u);\n+        assert_eq!(d.len(), 2);\n         d.push_back(4);\n-        assert_eq!(d.len(), 3u);\n+        assert_eq!(d.len(), 3);\n         d.push_front(1);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         debug!(\"{}\", d[0]);\n         debug!(\"{}\", d[1]);\n         debug!(\"{}\", d[2]);\n@@ -1743,29 +1743,29 @@ mod tests {\n     #[test]\n     fn test_push_front_grow() {\n         let mut deq = RingBuf::new();\n-        for i in 0u..66 {\n+        for i in 0..66 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        for i in 0u..66 {\n+        for i in 0..66 {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n         let mut deq = RingBuf::new();\n-        for i in 0u..66 {\n+        for i in 0..66 {\n             deq.push_back(i);\n         }\n \n-        for i in 0u..66 {\n+        for i in 0..66 {\n             assert_eq!(deq[i], i);\n         }\n     }\n \n     #[test]\n     fn test_index() {\n         let mut deq = RingBuf::new();\n-        for i in 1u..4 {\n+        for i in 1..4 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq[1], 2);\n@@ -1775,7 +1775,7 @@ mod tests {\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n         let mut deq = RingBuf::new();\n-        for i in 1u..4 {\n+        for i in 1..4 {\n             deq.push_front(i);\n         }\n         deq[3];\n@@ -1784,7 +1784,7 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let ring: RingBuf<u64> = RingBuf::new();\n+            let ring: RingBuf<i32> = RingBuf::new();\n             test::black_box(ring);\n         })\n     }\n@@ -1815,7 +1815,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n+        let mut deq= RingBuf::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1828,7 +1828,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq: RingBuf<i32> = RingBuf::with_capacity(101);\n+        let mut deq = RingBuf::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1852,7 +1852,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<i32> = (0..1000).collect();\n+        let ring: RingBuf<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1865,7 +1865,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<i32> = (0..1000).collect();\n+        let mut ring: RingBuf<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1978,33 +1978,25 @@ mod tests {\n     #[test]\n     fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n-        d.push_back(0u64);\n-        d.reserve_exact(50);\n-        assert!(d.capacity() >= 51);\n-        let mut d = RingBuf::new();\n-        d.push_back(0u32);\n+        d.push_back(0);\n         d.reserve_exact(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n         let mut d = RingBuf::new();\n-        d.push_back(0u64);\n-        d.reserve(50);\n-        assert!(d.capacity() >= 51);\n-        let mut d = RingBuf::new();\n-        d.push_back(0u32);\n+        d.push_back(0);\n         d.reserve(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<i32> = (0..5).collect();\n+        let mut d: RingBuf<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().map(|&x|x).collect::<Vec<i32>>(), vec!(4, 2, 3, 1));\n+        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n@@ -2018,15 +2010,15 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n         }\n \n         for i in 6..9 {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().collect::<Vec<_>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -2049,14 +2041,14 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n         }\n \n         for i in 6..9 {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&i32>>(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n     }\n \n     #[test]\n@@ -2070,16 +2062,16 @@ mod tests {\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<i32>>(),\n-                   vec!(4, 3, 2));\n+        assert_eq!(d.iter_mut().rev().cloned().collect::<Vec<_>>(),\n+                   vec![4, 3, 2]);\n     }\n \n     #[test]\n     fn test_mut_iter() {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().next().is_none());\n \n-        for i in 0u..3 {\n+        for i in 0..3 {\n             d.push_front(i);\n         }\n \n@@ -2102,7 +2094,7 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        for i in 0u..3 {\n+        for i in 0..3 {\n             d.push_front(i);\n         }\n \n@@ -2141,7 +2133,7 @@ mod tests {\n             }\n \n             let b = vec![0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n         }\n \n         // wrapped iter\n@@ -2155,7 +2147,7 @@ mod tests {\n             }\n \n             let b = vec![8,7,6,0,1,2,3,4];\n-            assert_eq!(d.into_iter().collect::<Vec<i32>>(), b);\n+            assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n         }\n \n         // partially used\n@@ -2224,7 +2216,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d: RingBuf<i32> = RingBuf::new();\n+            let mut d: RingBuf<_> = RingBuf::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2250,12 +2242,12 @@ mod tests {\n     fn test_from_iter() {\n         use core::iter;\n         let v = vec!(1,2,3,4,5,6,7);\n-        let deq: RingBuf<i32> = v.iter().map(|&x| x).collect();\n-        let u: Vec<i32> = deq.iter().map(|&x| x).collect();\n+        let deq: RingBuf<_> = v.iter().cloned().collect();\n+        let u: Vec<_> = deq.iter().cloned().collect();\n         assert_eq!(u, v);\n \n-        let seq = iter::count(0u, 2).take(256);\n-        let deq: RingBuf<uint> = seq.collect();\n+        let seq = iter::count(0, 2).take(256);\n+        let deq: RingBuf<_> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n@@ -2269,14 +2261,14 @@ mod tests {\n         d.push_front(42);\n         d.push_back(137);\n         d.push_back(137);\n-        assert_eq!(d.len(), 4u);\n+        assert_eq!(d.len(), 4);\n         let mut e = d.clone();\n-        assert_eq!(e.len(), 4u);\n+        assert_eq!(e.len(), 4);\n         while !d.is_empty() {\n             assert_eq!(d.pop_back(), e.pop_back());\n         }\n-        assert_eq!(d.len(), 0u);\n-        assert_eq!(e.len(), 0u);\n+        assert_eq!(d.len(), 0);\n+        assert_eq!(e.len(), 0);\n     }\n \n     #[test]\n@@ -2333,18 +2325,18 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<i32> = (0..10).collect();\n+        let ringbuf: RingBuf<_> = (0..10).collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                        .map(|&s| s)\n+        let ringbuf: RingBuf<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+                                                                        .cloned()\n                                                                         .collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n     fn test_drop() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {\n@@ -2364,7 +2356,7 @@ mod tests {\n \n     #[test]\n     fn test_drop_with_pop() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {\n@@ -2388,7 +2380,7 @@ mod tests {\n \n     #[test]\n     fn test_drop_clear() {\n-        static mut drops: uint = 0;\n+        static mut drops: i32 = 0;\n         struct Elem;\n         impl Drop for Elem {\n             fn drop(&mut self) {"}, {"sha": "3fe3fe04a5432f906ab67b92a63e7b3f57f94191", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 298, "deletions": 300, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -26,7 +26,7 @@\n //! block of memory that a mutable slice points to:\n //!\n //! ```rust\n-//! let x: &mut[int] = &mut [1, 2, 3];\n+//! let x: &mut[i32] = &mut [1, 2, 3];\n //! x[1] = 7;\n //! assert_eq!(x[0], 1);\n //! assert_eq!(x[1], 7);\n@@ -168,25 +168,25 @@ pub trait SliceExt {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"uncertain about this API approach\")]\n-    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<Self::Item>, start: usize, end: usize) -> usize;\n \n     /// Deprecated: use `&s[start .. end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n-    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n+    fn slice(&self, start: usize, end: usize) -> &[Self::Item];\n \n     /// Deprecated: use `&s[start..]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n-    fn slice_from(&self, start: uint) -> &[Self::Item];\n+    fn slice_from(&self, start: usize) -> &[Self::Item];\n \n     /// Deprecated: use `&s[..end]` notation instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n-    fn slice_to(&self, end: uint) -> &[Self::Item];\n+    fn slice_to(&self, end: usize) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -205,7 +205,7 @@ pub trait SliceExt {\n     /// assert_eq!([30, 20, 50], v2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n+    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n \n     /// Returns an iterator over the slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -245,7 +245,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n+    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<Self::Item, F>\n                  where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -265,7 +265,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n+    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<Self::Item, F>\n                   where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n@@ -288,7 +288,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn windows(&self, size: uint) -> Windows<Self::Item>;\n+    fn windows(&self, size: usize) -> Windows<Self::Item>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -311,7 +311,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n+    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n@@ -324,7 +324,7 @@ pub trait SliceExt {\n     /// assert_eq!(None, v.get(3));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get(&self, index: uint) -> Option<&Self::Item>;\n+    fn get(&self, index: usize) -> Option<&Self::Item>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     ///\n@@ -365,7 +365,7 @@ pub trait SliceExt {\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n+    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n \n     /// Returns an unsafe pointer to the slice's buffer\n     ///\n@@ -410,7 +410,7 @@ pub trait SliceExt {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n         F: FnMut(&Self::Item) -> Ordering;\n \n     /// Return the number of elements in the slice\n@@ -422,7 +422,7 @@ pub trait SliceExt {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n \n     /// Returns true if the slice has a length of 0\n     ///\n@@ -438,7 +438,7 @@ pub trait SliceExt {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n+    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n@@ -449,19 +449,19 @@ pub trait SliceExt {\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n+    fn slice_mut(&mut self, start: usize, end: usize) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[start ..]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n+    fn slice_from_mut(&mut self, start: usize) -> &mut [Self::Item];\n \n     /// Deprecated: use `&mut s[.. end]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n+    fn slice_to_mut(&mut self, end: usize) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -495,15 +495,15 @@ pub trait SliceExt {\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n+    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<Self::Item, F>\n                      where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n+    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<Self::Item, F>\n                       where F: FnMut(&Self::Item) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -515,7 +515,7 @@ pub trait SliceExt {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -536,7 +536,7 @@ pub trait SliceExt {\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap(&mut self, a: uint, b: uint);\n+    fn swap(&mut self, a: usize, b: usize);\n \n     /// Divides one `&mut` into two at an index.\n     ///\n@@ -573,7 +573,7 @@ pub trait SliceExt {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -589,7 +589,7 @@ pub trait SliceExt {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n@@ -651,7 +651,7 @@ pub trait SliceExt {\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n     #[unstable(feature = \"collections\")]\n-    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n     ///\n@@ -692,12 +692,12 @@ pub trait SliceExt {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;\n \n     /// Deprecated: use `binary_search` instead.\n     #[unstable(feature = \"collections\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n-    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n+    fn binary_search_elem(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord {\n         self.binary_search(x)\n     }\n \n@@ -743,11 +743,11 @@ pub trait SliceExt {\n \n     /// Find the first index containing a matching value.\n     #[unstable(feature = \"collections\")]\n-    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n     #[unstable(feature = \"collections\")]\n-    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     /// Returns true if the slice contains an element with the given value.\n     ///\n@@ -804,30 +804,30 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+    fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n         for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n     }\n \n     #[inline]\n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+    fn slice<'a>(&'a self, start: usize, end: usize) -> &'a [T] {\n         &self[start .. end]\n     }\n \n     #[inline]\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+    fn slice_from<'a>(&'a self, start: usize) -> &'a [T] {\n         &self[start ..]\n     }\n \n     #[inline]\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+    fn slice_to<'a>(&'a self, end: usize) -> &'a [T] {\n         &self[.. end]\n     }\n \n     #[inline]\n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+    fn split_at<'a>(&'a self, mid: usize) -> (&'a [T], &'a [T]) {\n         core_slice::SliceExt::split_at(self, mid)\n     }\n \n@@ -843,29 +843,29 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+    fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n                  where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::splitn(self, n, pred)\n     }\n \n     #[inline]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+    fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n                   where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::rsplitn(self, n, pred)\n     }\n \n     #[inline]\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+    fn windows<'a>(&'a self, size: usize) -> Windows<'a, T> {\n         core_slice::SliceExt::windows(self, size)\n     }\n \n     #[inline]\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+    fn chunks<'a>(&'a self, size: usize) -> Chunks<'a, T> {\n         core_slice::SliceExt::chunks(self, size)\n     }\n \n     #[inline]\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+    fn get<'a>(&'a self, index: usize) -> Option<&'a T> {\n         core_slice::SliceExt::get(self, index)\n     }\n \n@@ -890,7 +890,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a T {\n+    unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a T {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n@@ -900,13 +900,13 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint>\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n                         where F: FnMut(&T) -> Ordering {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n     #[inline]\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         core_slice::SliceExt::len(self)\n     }\n \n@@ -916,7 +916,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+    fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut T> {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n@@ -926,17 +926,17 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+    fn slice_mut<'a>(&'a mut self, start: usize, end: usize) -> &'a mut [T] {\n         &mut self[start .. end]\n     }\n \n     #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+    fn slice_from_mut<'a>(&'a mut self, start: usize) -> &'a mut [T] {\n         &mut self[start ..]\n     }\n \n     #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+    fn slice_to_mut<'a>(&'a mut self, end: usize) -> &'a mut [T] {\n         &mut self[.. end]\n     }\n \n@@ -972,29 +972,29 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+    fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n                      where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::splitn_mut(self, n, pred)\n     }\n \n     #[inline]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+    fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n                       where F: FnMut(&T) -> bool {\n         core_slice::SliceExt::rsplitn_mut(self, n, pred)\n     }\n \n     #[inline]\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, T> {\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: usize) -> ChunksMut<'a, T> {\n         core_slice::SliceExt::chunks_mut(self, chunk_size)\n     }\n \n     #[inline]\n-    fn swap(&mut self, a: uint, b: uint) {\n+    fn swap(&mut self, a: usize, b: usize) {\n         core_slice::SliceExt::swap(self, a, b)\n     }\n \n     #[inline]\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+    fn split_at_mut<'a>(&'a mut self, mid: usize) -> (&'a mut [T], &'a mut [T]) {\n         core_slice::SliceExt::split_at_mut(self, mid)\n     }\n \n@@ -1004,7 +1004,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: usize) -> &'a mut T {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n@@ -1029,7 +1029,7 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n@@ -1038,7 +1038,7 @@ impl<T> SliceExt for [T] {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n@@ -1050,11 +1050,11 @@ impl<T> SliceExt for [T] {\n         core_slice::SliceExt::prev_permutation(self)\n     }\n \n-    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::position_elem(self, t)\n     }\n \n-    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         core_slice::SliceExt::rposition_elem(self, t)\n     }\n \n@@ -1153,13 +1153,13 @@ pub struct ElementSwaps {\n     /// If `true`, emit the last swap that returns the sequence to initial\n     /// state.\n     emit_reset: bool,\n-    swaps_made : uint,\n+    swaps_made : usize,\n }\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n     #[unstable(feature = \"collections\")]\n-    pub fn new(length: uint) -> ElementSwaps {\n+    pub fn new(length: usize) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n         // element (equal to the original index).\n@@ -1200,17 +1200,17 @@ enum Direction { Pos, Neg }\n /// An `Index` and `Direction` together.\n #[derive(Copy, Clone)]\n struct SizeDirection {\n-    size: uint,\n+    size: usize,\n     dir: Direction,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ElementSwaps {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        fn new_pos(i: uint, s: Direction) -> uint {\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        fn new_pos(i: usize, s: Direction) -> usize {\n             i + match s { Pos => 1, Neg => -1 }\n         }\n \n@@ -1252,7 +1252,7 @@ impl Iterator for ElementSwaps {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         // For a vector of size n, there are exactly n! permutations.\n         let n = (2..self.sdir.len() + 1).product();\n         (n - self.swaps_made, Some(n - self.swaps_made))\n@@ -1291,7 +1291,7 @@ impl<T: Clone> Iterator for Permutations<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.swaps.size_hint()\n     }\n }\n@@ -1332,7 +1332,7 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n                 let tmp = ptr::read(read_ptr);\n                 ptr::copy_memory(buf_v.offset(j + 1),\n                                  &*buf_v.offset(j),\n-                                 (i - j) as uint);\n+                                 (i - j) as usize);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n                                                 &tmp,\n                                                 1);\n@@ -1344,8 +1344,8 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     // warning: this wildly uses unsafe.\n-    static BASE_INSERTION: uint = 32;\n-    static LARGE_INSERTION: uint = 16;\n+    static BASE_INSERTION: usize = 32;\n+    static LARGE_INSERTION: usize = 16;\n \n     // FIXME #12092: smaller insertion runs seems to make sorting\n     // vectors of large elements a little faster on some platforms,\n@@ -1410,7 +1410,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // `.offset(j)` is always in bounds.\n                 ptr::copy_memory(buf_dat.offset(j + 1),\n                                  &*buf_dat.offset(j),\n-                                 i - j as uint);\n+                                 i - j as usize);\n                 ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n             }\n         }\n@@ -1458,11 +1458,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     // case).\n                     if left == right_start {\n                         // the number remaining in this run.\n-                        let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n+                        let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n                         ptr::copy_nonoverlapping_memory(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n-                        let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n+                        let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n                         ptr::copy_nonoverlapping_memory(out, &*left, elems);\n                         break;\n                     }\n@@ -1506,7 +1506,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n #[cfg(test)]\n mod tests {\n     use core::cmp::Ordering::{Greater, Less, Equal};\n-    use core::prelude::{Some, None, range, Clone};\n+    use core::prelude::{Some, None, Clone};\n     use core::prelude::{Iterator, IteratorExt};\n     use core::prelude::{AsSlice};\n     use core::prelude::Ord;\n@@ -1519,56 +1519,56 @@ mod tests {\n     use vec::Vec;\n     use super::{ElementSwaps, SliceConcatExt, SliceExt};\n \n-    fn square(n: uint) -> uint { n * n }\n+    fn square(n: usize) -> usize { n * n }\n \n-    fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n+    fn is_odd(n: &usize) -> bool { *n % 2 == 1 }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = (0u..3).map(square).collect::<Vec<_>>();\n+        let mut v: Vec<_> = (0..3).map(square).collect();\n         {\n             let v = v;\n-            assert_eq!(v.len(), 3u);\n-            assert_eq!(v[0], 0u);\n-            assert_eq!(v[1], 1u);\n-            assert_eq!(v[2], 4u);\n+            assert_eq!(v.len(), 3);\n+            assert_eq!(v[0], 0);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 4);\n         }\n \n         // Test on-heap from_fn.\n-        v = (0u..5).map(square).collect::<Vec<_>>();\n+        v = (0..5).map(square).collect();\n         {\n             let v = v;\n-            assert_eq!(v.len(), 5u);\n-            assert_eq!(v[0], 0u);\n-            assert_eq!(v[1], 1u);\n-            assert_eq!(v[2], 4u);\n-            assert_eq!(v[3], 9u);\n-            assert_eq!(v[4], 16u);\n+            assert_eq!(v.len(), 5);\n+            assert_eq!(v[0], 0);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 4);\n+            assert_eq!(v[3], 9);\n+            assert_eq!(v[4], 16);\n         }\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = vec![10u, 10u];\n+        let mut v = vec![10, 10];\n         {\n             let v = v;\n-            assert_eq!(v.len(), 2u);\n-            assert_eq!(v[0], 10u);\n-            assert_eq!(v[1], 10u);\n+            assert_eq!(v.len(), 2);\n+            assert_eq!(v[0], 10);\n+            assert_eq!(v[1], 10);\n         }\n \n         // Test on-heap from_elem.\n-        v = vec![20u, 20u, 20u, 20u, 20u, 20u];\n+        v = vec![20; 6];\n         {\n-            let v = v;\n-            assert_eq!(v[0], 20u);\n-            assert_eq!(v[1], 20u);\n-            assert_eq!(v[2], 20u);\n-            assert_eq!(v[3], 20u);\n-            assert_eq!(v[4], 20u);\n-            assert_eq!(v[5], 20u);\n+            let v = v.as_slice();\n+            assert_eq!(v[0], 20);\n+            assert_eq!(v[1], 20);\n+            assert_eq!(v[2], 20);\n+            assert_eq!(v[3], 20);\n+            assert_eq!(v[4], 20);\n+            assert_eq!(v[5], 20);\n         }\n     }\n \n@@ -1624,68 +1624,68 @@ mod tests {\n     #[test]\n     fn test_tail() {\n         let mut a = vec![11];\n-        let b: &[int] = &[];\n+        let b: &[i32] = &[];\n         assert_eq!(a.tail(), b);\n         a = vec![11, 12];\n-        let b: &[int] = &[12];\n+        let b: &[i32] = &[12];\n         assert_eq!(a.tail(), b);\n     }\n \n     #[test]\n     fn test_tail_mut() {\n         let mut a = vec![11];\n-        let b: &mut [int] = &mut [];\n+        let b: &mut [i32] = &mut [];\n         assert!(a.tail_mut() == b);\n         a = vec![11, 12];\n-        let b: &mut [int] = &mut [12];\n+        let b: &mut [_] = &mut [12];\n         assert!(a.tail_mut() == b);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_empty() {\n-        let a: Vec<int> = vec![];\n+        let a = Vec::<i32>::new();\n         a.tail();\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_mut_empty() {\n-        let mut a: Vec<int> = vec![];\n+        let mut a = Vec::<i32>::new();\n         a.tail_mut();\n     }\n \n     #[test]\n     fn test_init() {\n         let mut a = vec![11];\n-        let b: &[int] = &[];\n+        let b: &[i32] = &[];\n         assert_eq!(a.init(), b);\n         a = vec![11, 12];\n-        let b: &[int] = &[11];\n+        let b: &[_] = &[11];\n         assert_eq!(a.init(), b);\n     }\n \n     #[test]\n     fn test_init_mut() {\n         let mut a = vec![11];\n-        let b: &mut [int] = &mut [];\n+        let b: &mut [i32] = &mut [];\n         assert!(a.init_mut() == b);\n         a = vec![11, 12];\n-        let b: &mut [int] = &mut [11];\n+        let b: &mut [_] = &mut [11];\n         assert!(a.init_mut() == b);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_empty() {\n-        let a: Vec<int> = vec![];\n+        let a = Vec::<i32>::new();\n         a.init();\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_mut_empty() {\n-        let mut a: Vec<int> = vec![];\n+        let mut a = Vec::<i32>::new();\n         a.init_mut();\n     }\n \n@@ -1713,26 +1713,26 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n-        assert_eq!(v_a.len(), 3u);\n-        let v_a = v_a;\n+        let v_a = vec_fixed[1..vec_fixed.len()].to_vec();\n+        assert_eq!(v_a.len(), 3);\n+\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n-        assert_eq!(v_b.len(), 2u);\n-        let v_b = v_b;\n+        let v_b = vec_stack[1..3].to_vec();\n+        assert_eq!(v_b.len(), 2);\n+\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n-        assert_eq!(v_d.len(), 5u);\n-        let v_d = v_d;\n+        let v_d = vec_unique[1..6].to_vec();\n+        assert_eq!(v_d.len(), 5);\n+\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);\n         assert_eq!(v_d[2], 4);\n@@ -1742,21 +1742,21 @@ mod tests {\n \n     #[test]\n     fn test_slice_from() {\n-        let vec: &[int] = &[1, 2, 3, 4];\n+        let vec: &[_] = &[1, 2, 3, 4];\n         assert_eq!(&vec[], vec);\n-        let b: &[int] = &[3, 4];\n+        let b: &[_] = &[3, 4];\n         assert_eq!(&vec[2..], b);\n-        let b: &[int] = &[];\n+        let b: &[_] = &[];\n         assert_eq!(&vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n-        let vec: &[int] = &[1, 2, 3, 4];\n+        let vec: &[_] = &[1, 2, 3, 4];\n         assert_eq!(&vec[..4], vec);\n-        let b: &[int] = &[1, 2];\n+        let b: &[_] = &[1, 2];\n         assert_eq!(&vec[..2], b);\n-        let b: &[int] = &[];\n+        let b: &[_] = &[];\n         assert_eq!(&vec[..0], b);\n     }\n \n@@ -1812,12 +1812,12 @@ mod tests {\n         // Test on-stack push().\n         let mut v = vec![];\n         v.push(1);\n-        assert_eq!(v.len(), 1u);\n+        assert_eq!(v.len(), 1);\n         assert_eq!(v[0], 1);\n \n         // Test on-heap push().\n         v.push(2);\n-        assert_eq!(v.len(), 2u);\n+        assert_eq!(v.len(), 2);\n         assert_eq!(v[0], 1);\n         assert_eq!(v[1], 2);\n     }\n@@ -1842,19 +1842,19 @@ mod tests {\n \n     #[test]\n     fn test_dedup() {\n-        fn case(a: Vec<uint>, b: Vec<uint>) {\n+        fn case(a: Vec<i32>, b: Vec<i32>) {\n             let mut v = a;\n             v.dedup();\n             assert_eq!(v, b);\n         }\n         case(vec![], vec![]);\n-        case(vec![1u], vec![1]);\n-        case(vec![1u,1], vec![1]);\n-        case(vec![1u,2,3], vec![1,2,3]);\n-        case(vec![1u,1,2,3], vec![1,2,3]);\n-        case(vec![1u,2,2,3], vec![1,2,3]);\n-        case(vec![1u,2,3,3], vec![1,2,3]);\n-        case(vec![1u,1,2,2,2,3,3], vec![1,2,3]);\n+        case(vec![1], vec![1]);\n+        case(vec![1,1], vec![1]);\n+        case(vec![1,2,3], vec![1,2,3]);\n+        case(vec![1,1,2,3], vec![1,2,3]);\n+        case(vec![1,2,2,3], vec![1,2,3]);\n+        case(vec![1,2,3,3], vec![1,2,3]);\n+        case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n     }\n \n     #[test]\n@@ -1887,9 +1887,9 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut v = vec![1u, 2, 3, 4, 5];\n+        let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, vec![1u, 3, 5]);\n+        assert_eq!(v, vec![1, 3, 5]);\n     }\n \n     #[test]\n@@ -1964,56 +1964,56 @@ mod tests {\n \n     #[test]\n     fn test_lexicographic_permutations() {\n-        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n+        let v : &mut[_] = &mut[1, 2, 3, 4, 5];\n         assert!(v.prev_permutation() == false);\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 3, 5, 4];\n+        let b: &mut[_] = &mut[1, 2, 3, 5, 4];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[1, 2, 3, 4, 5];\n+        let b: &mut[_] = &mut[1, 2, 3, 4, 5];\n         assert!(v == b);\n         assert!(v.next_permutation());\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 4, 3, 5];\n+        let b: &mut[_] = &mut[1, 2, 4, 3, 5];\n         assert!(v == b);\n         assert!(v.next_permutation());\n-        let b: &mut[int] = &mut[1, 2, 4, 5, 3];\n+        let b: &mut[_] = &mut[1, 2, 4, 5, 3];\n         assert!(v == b);\n \n-        let v : &mut[int] = &mut[1, 0, 0, 0];\n+        let v : &mut[_] = &mut[1, 0, 0, 0];\n         assert!(v.next_permutation() == false);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 1, 0, 0];\n+        let b: &mut[_] = &mut[0, 1, 0, 0];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 0, 1, 0];\n+        let b: &mut[_] = &mut[0, 0, 1, 0];\n         assert!(v == b);\n         assert!(v.prev_permutation());\n-        let b: &mut[int] = &mut[0, 0, 0, 1];\n+        let b: &mut[_] = &mut[0, 0, 0, 1];\n         assert!(v == b);\n         assert!(v.prev_permutation() == false);\n     }\n \n     #[test]\n     fn test_lexicographic_permutations_empty_and_short() {\n-        let empty : &mut[int] = &mut[];\n+        let empty : &mut[i32] = &mut[];\n         assert!(empty.next_permutation() == false);\n-        let b: &mut[int] = &mut[];\n+        let b: &mut[i32] = &mut[];\n         assert!(empty == b);\n         assert!(empty.prev_permutation() == false);\n         assert!(empty == b);\n \n-        let one_elem : &mut[int] = &mut[4];\n+        let one_elem : &mut[_] = &mut[4];\n         assert!(one_elem.prev_permutation() == false);\n-        let b: &mut[int] = &mut[4];\n+        let b: &mut[_] = &mut[4];\n         assert!(one_elem == b);\n         assert!(one_elem.next_permutation() == false);\n         assert!(one_elem == b);\n \n-        let two_elem : &mut[int] = &mut[1, 2];\n+        let two_elem : &mut[_] = &mut[1, 2];\n         assert!(two_elem.prev_permutation() == false);\n-        let b : &mut[int] = &mut[1, 2];\n-        let c : &mut[int] = &mut[2, 1];\n+        let b : &mut[_] = &mut[1, 2];\n+        let c : &mut[_] = &mut[2, 1];\n         assert!(two_elem == b);\n         assert!(two_elem.next_permutation());\n         assert!(two_elem == c);\n@@ -2030,9 +2030,9 @@ mod tests {\n         assert!([].position_elem(&1).is_none());\n \n         let v1 = vec![1, 2, 3, 3, 2, 5];\n-        assert_eq!(v1.position_elem(&1), Some(0u));\n-        assert_eq!(v1.position_elem(&2), Some(1u));\n-        assert_eq!(v1.position_elem(&5), Some(5u));\n+        assert_eq!(v1.position_elem(&1), Some(0));\n+        assert_eq!(v1.position_elem(&2), Some(1));\n+        assert_eq!(v1.position_elem(&5), Some(5));\n         assert!(v1.position_elem(&4).is_none());\n     }\n \n@@ -2083,24 +2083,23 @@ mod tests {\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: Vec<int> = vec![10, 20];\n+        let mut v = vec![10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n \n-        let mut v3: Vec<int> = vec![];\n+        let mut v3 = Vec::<i32>::new();\n         v3.reverse();\n         assert!(v3.is_empty());\n     }\n \n     #[test]\n     fn test_sort() {\n-        for len in 4u..25 {\n+        for len in 4..25 {\n             for _ in 0..100 {\n-                let mut v = thread_rng().gen_iter::<uint>().take(len)\n-                                      .collect::<Vec<uint>>();\n+                let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n                 let mut v1 = v.clone();\n \n                 v.sort();\n@@ -2115,30 +2114,30 @@ mod tests {\n         }\n \n         // shouldn't panic\n-        let mut v: [uint; 0] = [];\n+        let mut v: [i32; 0] = [];\n         v.sort();\n \n-        let mut v = [0xDEADBEEFu];\n+        let mut v = [0xDEADBEEFu64];\n         v.sort();\n         assert!(v == [0xDEADBEEF]);\n     }\n \n     #[test]\n     fn test_sort_stability() {\n         for len in 4..25 {\n-            for _ in 0u..10 {\n+            for _ in 0..10 {\n                 let mut counts = [0; 10];\n \n                 // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n                 // where the first item of each tuple is random, but\n                 // the second item represents which occurrence of that\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n-                let mut v = (0..len).map(|_| {\n-                        let n = thread_rng().gen::<uint>() % 10;\n+                let mut v: Vec<_> = (0..len).map(|_| {\n+                        let n = thread_rng().gen::<usize>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n-                    }).collect::<Vec<(uint, int)>>();\n+                    }).collect();\n \n                 // only sort on the first element, so an unstable sort\n                 // may mix up the counts.\n@@ -2156,28 +2155,28 @@ mod tests {\n \n     #[test]\n     fn test_concat() {\n-        let v: [Vec<int>; 0] = [];\n-        let c: Vec<int> = v.concat();\n+        let v: [Vec<i32>; 0] = [];\n+        let c = v.concat();\n         assert_eq!(c, []);\n-        let d: Vec<int> = [vec![1], vec![2,3]].concat();\n+        let d = [vec![1], vec![2,3]].concat();\n         assert_eq!(d, vec![1, 2, 3]);\n \n-        let v: [&[int]; 2] = [&[1], &[2, 3]];\n+        let v: &[&[_]] = &[&[1], &[2, 3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int]; 3] = [&[1], &[2], &[3]];\n+        let v: &[&[_]] = &[&[1], &[2], &[3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        let v: [Vec<int>; 0] = [];\n+        let v: [Vec<i32>; 0] = [];\n         assert_eq!(v.connect(&0), vec![]);\n         assert_eq!([vec![1], vec![2, 3]].connect(&0), vec![1, 0, 2, 3]);\n         assert_eq!([vec![1], vec![2], vec![3]].connect(&0), vec![1, 0, 2, 0, 3]);\n \n-        let v: [&[int]; 2] = [&[1], &[2, 3]];\n+        let v: [&[_]; 2] = [&[1], &[2, 3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int]; 3] = [&[1], &[2], &[3]];\n+        let v: [&[_]; 3] = [&[1], &[2], &[3]];\n         assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n@@ -2209,13 +2208,13 @@ mod tests {\n \n     #[test]\n     fn test_remove() {\n-        let mut a = vec![1,2,3,4];\n+        let mut a = vec![1, 2, 3, 4];\n \n         assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, vec![1,2,4]);\n+        assert_eq!(a, vec![1, 2, 4]);\n \n         assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, vec![1,2]);\n+        assert_eq!(a, vec![1, 2]);\n \n         assert_eq!(a.remove(0), 1);\n         assert_eq!(a, vec![2]);\n@@ -2234,19 +2233,16 @@ mod tests {\n \n     #[test]\n     fn test_capacity() {\n-        let mut v = vec![0u64];\n-        v.reserve_exact(10u);\n-        assert!(v.capacity() >= 11u);\n-        let mut v = vec![0u32];\n-        v.reserve_exact(10u);\n-        assert!(v.capacity() >= 11u);\n+        let mut v = vec![0];\n+        v.reserve_exact(10);\n+        assert!(v.capacity() >= 11);\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let v = vec![1, 2, 3, 4, 5];\n-        let v = v.slice(1u, 3u);\n-        assert_eq!(v.len(), 2u);\n+        let v = v.slice(1, 3);\n+        assert_eq!(v.len(), 2);\n         assert_eq!(v[0], 2);\n         assert_eq!(v[1], 3);\n     }\n@@ -2256,7 +2252,7 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n                  (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n-        let mut i = 0u;\n+        let mut i = 0;\n         for _ in v.permutations() {\n             if i == 2 {\n                 panic!()\n@@ -2267,15 +2263,15 @@ mod tests {\n \n     #[test]\n     fn test_total_ord() {\n-        let c: &[int] = &[1, 2, 3];\n+        let c = &[1, 2, 3];\n         [1, 2, 3, 4][].cmp(c) == Greater;\n-        let c: &[int] = &[1, 2, 3, 4];\n+        let c = &[1, 2, 3, 4];\n         [1, 2, 3][].cmp(c) == Less;\n-        let c: &[int] = &[1, 2, 3, 6];\n+        let c = &[1, 2, 3, 6];\n         [1, 2, 3, 4][].cmp(c) == Equal;\n-        let c: &[int] = &[1, 2, 3, 4, 5, 6];\n+        let c = &[1, 2, 3, 4, 5, 6];\n         [1, 2, 3, 4, 5, 5, 5, 5][].cmp(c) == Less;\n-        let c: &[int] = &[1, 2, 3, 4];\n+        let c = &[1, 2, 3, 4];\n         [2, 2][].cmp(c) == Greater;\n     }\n \n@@ -2387,128 +2383,129 @@ mod tests {\n     #[test]\n     fn test_move_iterator() {\n         let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.into_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+        assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n         let xs = vec![1u,2,3,4,5];\n-        assert_eq!(xs.into_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n     }\n \n     #[test]\n     fn test_splitator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1], &[3], &[5]];\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4], &[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[], &[], &[]];\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1], &[3,4,5]];\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator_mut() {\n         let xs = &mut [1,2,3,4,5];\n \n-        let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n+        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&mut [int]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n+        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&mut [int]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>(),\n+        let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n+        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &mut [int] = &mut [];\n-        let splits: &[&mut [int]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>(),\n+        let xs: &mut [i32] = &mut [];\n+        let splits: &[&mut[i32]] = &[&mut []];\n+        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n                    splits);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[5], &[3], &[1]];\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[2,3,4,5], &[]];\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[1,2,3,4]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32] = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n-        let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[5], &[1,2,3]];\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                    splits);\n-        let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>(),\n+        let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n                    splits);\n \n-        let xs: &[int] = &[];\n-        let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n+        let xs: &[i32]  = &[];\n+        let splits: &[&[i32]] = &[&[]];\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1,2,3,4];\n \n-        let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n-        let wins: &[&[int]] = &[&[1,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n+        let wins: &[&[_]] = &[&[1,2], &[2,3], &[3,4]];\n+        assert_eq!(v.windows(2).collect::<Vec<_>>(), wins);\n+\n+        let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n+        assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -2527,22 +2524,23 @@ mod tests {\n \n         assert_eq!(v.chunks(2).len(), 3);\n \n-        let chunks: &[&[int]] = &[&[1,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n-        let chunks: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2], &[3,4], &[5]];\n+        assert_eq!(v.chunks(2).collect::<Vec<_>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2,3], &[4,5]];\n+        assert_eq!(v.chunks(3).collect::<Vec<_>>(), chunks);\n+        let chunks: &[&[_]] = &[&[1,2,3,4,5]];\n+        assert_eq!(v.chunks(6).collect::<Vec<_>>(), chunks);\n \n-        let chunks: &[&[int]] = &[&[5], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n+        let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n-        let chunk: &[int] = &[1,2];\n+\n+        let chunk: &[_] = &[1,2];\n         assert_eq!(it.idx(0).unwrap(), chunk);\n-        let chunk: &[int] = &[3,4];\n+        let chunk: &[_] = &[3,4];\n         assert_eq!(it.idx(1).unwrap(), chunk);\n-        let chunk: &[int] = &[5];\n+        let chunk: &[_] = &[5];\n         assert_eq!(it.idx(2).unwrap(), chunk);\n         assert_eq!(it.idx(3), None);\n     }\n@@ -2590,20 +2588,20 @@ mod tests {\n                 assert_eq!(format!(\"{:?}\", x), x_str);\n             })\n         }\n-        let empty: Vec<int> = vec![];\n+        let empty = Vec::<i32>::new();\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1], \"[1]\");\n         test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n                        \"[[], [1], [1, 1]]\");\n \n-        let empty_mut: &mut [int] = &mut[];\n+        let empty_mut: &mut [i32] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n-        let v: &mut[int] = &mut[1];\n+        let v = &mut[1];\n         test_show_vec!(v, \"[1]\");\n-        let v: &mut[int] = &mut[1, 2, 3];\n+        let v = &mut[1, 2, 3];\n         test_show_vec!(v, \"[1, 2, 3]\");\n-        let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n+        let v: &mut[&mut[_]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n         test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n@@ -2616,8 +2614,8 @@ mod tests {\n             }}\n         }\n \n-        t!(&[int]);\n-        t!(Vec<int>);\n+        t!(&[i32]);\n+        t!(Vec<i32>);\n     }\n \n     #[test]\n@@ -2829,15 +2827,15 @@ mod tests {\n         let h = x.last_mut();\n         assert_eq!(*h.unwrap(), 5);\n \n-        let y: &mut [int] = &mut [];\n+        let y: &mut [i32] = &mut [];\n         assert!(y.last_mut().is_none());\n     }\n \n     #[test]\n     fn test_to_vec() {\n-        let xs = box [1u, 2, 3];\n+        let xs = box [1, 2, 3];\n         let ys = xs.to_vec();\n-        assert_eq!(ys, [1u, 2, 3]);\n+        assert_eq!(ys, [1, 2, 3]);\n     }\n }\n \n@@ -2854,7 +2852,7 @@ mod bench {\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = (0u..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n+        let v: Vec<_> = (0..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2868,7 +2866,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = repeat(0).take(100).collect::<Vec<_>>();\n+        let mut v: Vec<_> = repeat(0).take(100).collect();\n \n         b.iter(|| {\n             let mut i = 0;\n@@ -2881,25 +2879,25 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> =\n-            (0..100u).map(|i| (0..i).collect()).collect();\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.concat();\n         });\n     }\n \n     #[bench]\n     fn connect(b: &mut Bencher) {\n-        let xss: Vec<Vec<uint>> =\n-            (0..100u).map(|i| (0..i).collect()).collect();\n+        let xss: Vec<Vec<i32>> =\n+            (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.connect(&0)\n         });\n     }\n \n     #[bench]\n     fn push(b: &mut Bencher) {\n-        let mut vec: Vec<uint> = vec![];\n+        let mut vec = Vec::<i32>::new();\n         b.iter(|| {\n             vec.push(0);\n             black_box(&vec);\n@@ -2908,24 +2906,24 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n             vec.starts_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = vec![0];\n+        let vec: Vec<_> = vec![0];\n         b.iter(|| {\n             vec.starts_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n-        let mut match_vec: Vec<uint> = (0u..99).collect();\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n             vec.starts_with(&match_vec)\n@@ -2934,24 +2932,24 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n             vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = vec![0];\n+        let vec: Vec<_> = vec![0];\n         b.iter(|| {\n             vec.ends_with(&vec)\n         })\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n-        let mut match_vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n+        let mut match_vec: Vec<_> = (0..100).collect();\n         match_vec[0] = 200;\n         b.iter(|| {\n             vec.starts_with(&match_vec)\n@@ -2960,9 +2958,9 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = (0u..100).collect();\n+        let vec: Vec<_> = (0..100).collect();\n         b.iter(|| {\n-            vec.contains(&99u)\n+            vec.contains(&99)\n         })\n     }\n \n@@ -2976,7 +2974,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_set_memory(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: Vec<uint> = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n@@ -2989,11 +2987,11 @@ mod bench {\n     #[bench]\n     fn zero_1kb_loop_set(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v: Vec<uint> = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for i in 0u..1024 {\n+            for i in 0..1024 {\n                 v[i] = 0;\n             }\n         });\n@@ -3002,7 +3000,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_mut_iter(b: &mut Bencher) {\n         b.iter(|| {\n-            let mut v = Vec::with_capacity(1024);\n+            let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 v.set_len(1024);\n             }\n@@ -3017,10 +3015,10 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(30).collect::<Vec<_>>();\n+            let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n             for _ in 0u..100 {\n                 let l = v.len();\n-                v.insert(rng.gen::<uint>() % (l + 1),\n+                v.insert(rng.gen::<usize>() % (l + 1),\n                          (1, 1));\n             }\n         })\n@@ -3029,10 +3027,10 @@ mod bench {\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(130).collect::<Vec<_>>();\n+            let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n             for _ in 0u..100 {\n                 let l = v.len();\n-                v.remove(rng.gen::<uint>() % l);\n+                v.remove(rng.gen::<usize>() % l);\n             }\n         })\n     }\n@@ -3041,7 +3039,7 @@ mod bench {\n     fn sort_random_small(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(5).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n             v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<u64>() as u64;\n@@ -3051,7 +3049,7 @@ mod bench {\n     fn sort_random_medium(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(100).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n             v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<u64>() as u64;\n@@ -3061,22 +3059,22 @@ mod bench {\n     fn sort_random_large(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<u64>().take(10000).collect::<Vec<u64>>();\n+            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n             v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<u64>() as u64;\n     }\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = (0u..10000).collect::<Vec<_>>();\n+        let mut v: Vec<_> = (0..10000).collect();\n         b.iter(|| {\n             v.sort();\n         });\n         b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n \n-    type BigSortable = (u64,u64,u64,u64);\n+    type BigSortable = (u64, u64, u64, u64);\n \n     #[bench]\n     fn sort_big_random_small(b: &mut Bencher) {\n@@ -3113,7 +3111,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = (0..10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n+        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "e6fb3005ff38cabc73de77ee47bacace74444b4a", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -241,7 +241,7 @@ impl<'a> Iterator for Decompositions<'a> {\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, _) = self.iter.size_hint();\n         (lower, None)\n     }\n@@ -367,7 +367,7 @@ impl<'a> Iterator for Utf16Units<'a> {\n     fn next(&mut self) -> Option<u16> { self.encoder.next() }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.encoder.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.encoder.size_hint() }\n }\n \n /*\n@@ -629,7 +629,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n \n@@ -679,7 +679,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n \n@@ -694,13 +694,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let v: Vec<(uint, uint)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n-    /// let v: Vec<(uint, uint)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(1,4), (4,7)]);\n     ///\n-    /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -762,19 +762,19 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n-    fn slice(&self, begin: uint, end: uint) -> &str;\n+    fn slice(&self, begin: usize, end: usize) -> &str;\n \n     /// Deprecated: use `s[a..]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n-    fn slice_from(&self, begin: uint) -> &str;\n+    fn slice_from(&self, begin: usize) -> &str;\n \n     /// Deprecated: use `s[..a]` instead.\n     #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n-    fn slice_to(&self, end: uint) -> &str;\n+    fn slice_to(&self, end: usize) -> &str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -801,7 +801,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"may have yet to prove its worth\")]\n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n \n@@ -812,7 +812,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Caller must check both UTF-8 character boundaries and the boundaries of\n     /// the entire slice as well.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n \n@@ -925,7 +925,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n \n@@ -945,7 +945,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n+    /// let mut i = 0;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n     ///     println!(\"{}: {}\", i, ch);\n@@ -975,7 +975,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// # Return value\n     ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// A record {ch: char, next: usize} containing the char value and the byte\n     /// index of the next Unicode character.\n     ///\n     /// # Panics\n@@ -984,7 +984,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_range_at(&self, start: uint) -> CharRange {\n+    fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n \n@@ -1000,7 +1000,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n \n@@ -1021,7 +1021,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n \n@@ -1033,7 +1033,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n \n@@ -1073,7 +1073,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n+    fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(&self[], pat)\n     }\n \n@@ -1101,7 +1101,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n \n@@ -1126,7 +1126,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favor of a more generic find in the future\")]\n-    fn find_str(&self, needle: &str) -> Option<uint> {\n+    fn find_str(&self, needle: &str) -> Option<usize> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n \n@@ -1170,7 +1170,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n-    fn subslice_offset(&self, inner: &str) -> uint {\n+    fn subslice_offset(&self, inner: &str) -> usize {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n \n@@ -1202,7 +1202,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         core_str::StrExt::len(&self[])\n     }\n \n@@ -1264,8 +1264,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-    /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1301,7 +1301,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n-    fn width(&self, is_cjk: bool) -> uint {\n+    fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n@@ -1326,15 +1326,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n+    fn slice(&self, begin: usize, end: usize) -> &str {\n         &self[begin..end]\n     }\n \n-    fn slice_from(&self, begin: uint) -> &str {\n+    fn slice_from(&self, begin: usize) -> &str {\n         &self[begin..]\n     }\n \n-    fn slice_to(&self, end: uint) -> &str {\n+    fn slice_to(&self, end: usize) -> &str {\n         &self[..end]\n     }\n }\n@@ -1357,51 +1357,51 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert_eq!(\"\".len(), 0u);\n-        assert_eq!(\"hello world\".len(), 11u);\n-        assert_eq!(\"\\x63\".len(), 1u);\n-        assert_eq!(\"\\u{a2}\".len(), 2u);\n-        assert_eq!(\"\\u{3c0}\".len(), 2u);\n-        assert_eq!(\"\\u{2620}\".len(), 3u);\n-        assert_eq!(\"\\u{1d11e}\".len(), 4u);\n-\n-        assert_eq!(\"\".chars().count(), 0u);\n-        assert_eq!(\"hello world\".chars().count(), 11u);\n-        assert_eq!(\"\\x63\".chars().count(), 1u);\n-        assert_eq!(\"\\u{a2}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{3c0}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{2620}\".chars().count(), 1u);\n-        assert_eq!(\"\\u{1d11e}\".chars().count(), 1u);\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19u);\n-\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10u);\n-        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10u);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0u);\n-        assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0u);\n-        assert_eq!(\"\".width(false), 0u);\n-        assert_eq!(\"\".width(true), 0u);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4u);\n-        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8u);\n+        assert_eq!(\"\".len(), 0);\n+        assert_eq!(\"hello world\".len(), 11);\n+        assert_eq!(\"\\x63\".len(), 1);\n+        assert_eq!(\"\\u{a2}\".len(), 2);\n+        assert_eq!(\"\\u{3c0}\".len(), 2);\n+        assert_eq!(\"\\u{2620}\".len(), 3);\n+        assert_eq!(\"\\u{1d11e}\".len(), 4);\n+\n+        assert_eq!(\"\".chars().count(), 0);\n+        assert_eq!(\"hello world\".chars().count(), 11);\n+        assert_eq!(\"\\x63\".chars().count(), 1);\n+        assert_eq!(\"\\u{a2}\".chars().count(), 1);\n+        assert_eq!(\"\\u{3c0}\".chars().count(), 1);\n+        assert_eq!(\"\\u{2620}\".chars().count(), 1);\n+        assert_eq!(\"\\u{1d11e}\".chars().count(), 1);\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19);\n+\n+        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10);\n+        assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10);\n+        assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0);\n+        assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0);\n+        assert_eq!(\"\".width(false), 0);\n+        assert_eq!(\"\".width(true), 0);\n+        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4);\n+        assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8);\n     }\n \n     #[test]\n     fn test_find() {\n-        assert_eq!(\"hello\".find('l'), Some(2u));\n-        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".find('l'), Some(2));\n+        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4));\n         assert!(\"hello\".find('x').is_none());\n         assert!(\"hello\".find(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30));\n     }\n \n     #[test]\n     fn test_rfind() {\n-        assert_eq!(\"hello\".rfind('l'), Some(3u));\n-        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4u));\n+        assert_eq!(\"hello\".rfind('l'), Some(3));\n+        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4));\n         assert!(\"hello\".rfind('x').is_none());\n         assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30u));\n-        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30));\n     }\n \n     #[test]\n@@ -1424,37 +1424,37 @@ mod tests {\n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert_eq!(\"\".find_str(\"\"), Some(0u));\n+        assert_eq!(\"\".find_str(\"\"), Some(0));\n         assert!(\"banana\".find_str(\"apple pie\").is_none());\n \n         let data = \"abcabc\";\n-        assert_eq!(data[0u..6u].find_str(\"ab\"), Some(0u));\n-        assert_eq!(data[2u..6u].find_str(\"ab\"), Some(3u - 2u));\n-        assert!(data[2u..4u].find_str(\"ab\").is_none());\n+        assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n+        assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n+        assert!(data[2..4].find_str(\"ab\").is_none());\n \n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut data = String::from_str(string);\n         data.push_str(string);\n         assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data[0u..43u].find_str(\"\"), Some(0u));\n-        assert_eq!(data[6u..43u].find_str(\"\"), Some(6u - 6u));\n+        assert_eq!(data[0..43].find_str(\"\"), Some(0));\n+        assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n \n-        assert_eq!(data[0u..43u].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n-        assert_eq!(data[0u..43u].find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n-        assert_eq!(data[0u..43u].find_str(\"\u0e22\u4e2d\"), Some(24u));\n-        assert_eq!(data[0u..43u].find_str(\"i\u1ec7t\"), Some(34u));\n-        assert_eq!(data[0u..43u].find_str(\"Nam\"), Some(40u));\n+        assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+        assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n+        assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n+        assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n+        assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n \n-        assert_eq!(data[43u..86u].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"i\u1ec7t\"), Some(77u - 43u));\n-        assert_eq!(data[43u..86u].find_str(\"Nam\"), Some(83u - 43u));\n+        assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n+        assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n+        assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n+        assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n+        assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n     }\n \n     #[test]\n     fn test_slice_chars() {\n-        fn t(a: &str, b: &str, start: uint) {\n+        fn t(a: &str, b: &str, start: usize) {\n             assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n         }\n         t(\"\", \"\", 0);\n@@ -1527,7 +1527,7 @@ mod tests {\n         assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n         assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n         fn a_million_letter_a() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaaaaaaa\");\n@@ -1536,7 +1536,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_a() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"aaaaa\");\n@@ -1547,7 +1547,7 @@ mod tests {\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n             unsafe {String::from_str(letters.slice_unchecked(\n-                                     0u,\n+                                     0,\n                                      500000))});\n     }\n \n@@ -1644,7 +1644,7 @@ mod tests {\n         assert_eq!(\"\u534e\", data.slice(30, 33));\n \n         fn a_million_letter_x() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n@@ -1653,7 +1653,7 @@ mod tests {\n             rs\n         }\n         fn half_a_million_letter_x() -> String {\n-            let mut i = 0u;\n+            let mut i = 0;\n             let mut rs = String::new();\n             while i < 100000 {\n                 rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n@@ -1663,23 +1663,23 @@ mod tests {\n         }\n         let letters = a_million_letter_x();\n         assert!(half_a_million_letter_x() ==\n-            String::from_str(letters.slice(0u, 3u * 500000u)));\n+            String::from_str(letters.slice(0, 3 * 500000)));\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert_eq!(\"\u534e\", ss.slice(3u, 6u));\n-        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6u, 16u));\n+        assert_eq!(\"\u534e\", ss.slice(3, 6));\n+        assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n \n-        assert_eq!(\"ab\", \"abc\".slice(0u, 2u));\n-        assert_eq!(\"bc\", \"abc\".slice(1u, 3u));\n-        assert_eq!(\"\", \"abc\".slice(1u, 1u));\n+        assert_eq!(\"ab\", \"abc\".slice(0, 2));\n+        assert_eq!(\"bc\", \"abc\".slice(1, 3));\n+        assert_eq!(\"\", \"abc\".slice(1, 1));\n \n-        assert_eq!(\"\u4e2d\", ss.slice(0u, 3u));\n-        assert_eq!(\"\u534eV\", ss.slice(3u, 7u));\n-        assert_eq!(\"\", ss.slice(3u, 3u));\n+        assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n+        assert_eq!(\"\u534eV\", ss.slice(3, 7));\n+        assert_eq!(\"\", ss.slice(3, 3));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -1695,7 +1695,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_slice_fail() {\n-        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0u, 2u);\n+        \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n     }\n \n     #[test]\n@@ -1961,17 +1961,17 @@ mod tests {\n \n         let v: Vec<u8> = s1.as_bytes().to_vec();\n         let s2: String = String::from_str(from_utf8(&v).unwrap());\n-        let mut i: uint = 0u;\n-        let n1: uint = s1.len();\n-        let n2: uint = v.len();\n+        let mut i = 0;\n+        let n1 = s1.len();\n+        let n2 = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n             let a: u8 = s1.as_bytes()[i];\n             let b: u8 = s2.as_bytes()[i];\n             debug!(\"{}\", a);\n             debug!(\"{}\", b);\n             assert_eq!(a, b);\n-            i += 1u;\n+            i += 1;\n         }\n     }\n \n@@ -2093,7 +2093,7 @@ mod tests {\n         let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.chars();\n+        let it = s.chars();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -2108,7 +2108,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.chars().rev();\n+        let it = s.chars().rev();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -2188,7 +2188,7 @@ mod tests {\n         let v = ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices();\n+        let it = s.char_indices();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -2205,7 +2205,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices().rev();\n+        let it = s.char_indices().rev();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -2725,11 +2725,11 @@ mod tests {\n \n         // test the indices iterators\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n-        let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n-        let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+        let gr_inds = s.grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+        let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n         assert_eq!(gr_inds, b);\n-        let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n-        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n+        let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(usize, &str)>>();\n+        let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0, \"a\u0310\")];\n         assert_eq!(gr_inds, b);\n         let mut gr_inds_iter = s.grapheme_indices(true);\n         {\n@@ -2785,7 +2785,7 @@ mod tests {\n \n     #[test]\n     fn test_str_container() {\n-        fn sum_len(v: &[&str]) -> uint {\n+        fn sum_len(v: &[&str]) -> usize {\n             v.iter().map(|x| x.len()).sum()\n         }\n "}, {"sha": "e3db8d04d4aba4f54d6606e264d5aef85b4a7b12", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -80,7 +80,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> String {\n+    pub fn with_capacity(capacity: usize) -> String {\n         String {\n             vec: Vec::with_capacity(capacity),\n         }\n@@ -157,10 +157,10 @@ impl String {\n         static TAG_CONT_U8: u8 = 128u8;\n         static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n         let total = v.len();\n-        fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n+        fn unsafe_get(xs: &[u8], i: usize) -> u8 {\n             unsafe { *xs.get_unchecked(i) }\n         }\n-        fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n+        fn safe_get(xs: &[u8], i: usize, total: usize) -> u8 {\n             if i >= total {\n                 0\n             } else {\n@@ -319,7 +319,7 @@ impl String {\n     /// * We assume that the `Vec` contains valid UTF-8.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n+    pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n         String {\n             vec: Vec::from_raw_parts(buf, length, capacity),\n         }\n@@ -375,7 +375,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.vec.capacity()\n     }\n \n@@ -385,7 +385,7 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -396,7 +396,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.vec.reserve(additional)\n     }\n \n@@ -410,7 +410,7 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -421,7 +421,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         self.vec.reserve_exact(additional)\n     }\n \n@@ -508,7 +508,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, new_len: uint) {\n+    pub fn truncate(&mut self, new_len: usize) {\n         assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n     }\n@@ -563,7 +563,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, idx: uint) -> char {\n+    pub fn remove(&mut self, idx: usize) -> char {\n         let len = self.len();\n         assert!(idx <= len);\n \n@@ -590,7 +590,7 @@ impl String {\n     /// this function will panic.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, idx: uint, ch: char) {\n+    pub fn insert(&mut self, idx: usize, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n@@ -641,7 +641,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.vec.len() }\n+    pub fn len(&self) -> usize { self.vec.len() }\n \n     /// Returns true if the string contains no bytes\n     ///\n@@ -854,26 +854,26 @@ impl<'a> Add<&'a str> for String {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::Range<uint>> for String {\n+impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &str {\n+    fn index(&self, index: &ops::Range<usize>) -> &str {\n         &self[][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeTo<uint>> for String {\n+impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n         &self[][*index]\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ops::Index<ops::RangeFrom<uint>> for String {\n+impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n         &self[][*index]\n     }\n }\n@@ -1298,7 +1298,7 @@ mod tests {\n     fn test_simple_types() {\n         assert_eq!(1.to_string(), \"1\");\n         assert_eq!((-1).to_string(), \"-1\");\n-        assert_eq!(200u.to_string(), \"200\");\n+        assert_eq!(200.to_string(), \"200\");\n         assert_eq!(2u8.to_string(), \"2\");\n         assert_eq!(true.to_string(), \"true\");\n         assert_eq!(false.to_string(), \"false\");\n@@ -1307,7 +1307,7 @@ mod tests {\n \n     #[test]\n     fn test_vectors() {\n-        let x: Vec<int> = vec![];\n+        let x: Vec<i32> = vec![];\n         assert_eq!(format!(\"{:?}\", x), \"[]\");\n         assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n         assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");"}, {"sha": "f14b34bc2153bebba75768d78e84c0a647e908b9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -66,7 +66,7 @@ use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::slice;\n-use core::uint;\n+use core::usize;\n \n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n@@ -138,8 +138,8 @@ use core::uint;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n-    len: uint,\n-    cap: uint,\n+    len: usize,\n+    cap: usize,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -196,9 +196,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> Vec<T> {\n+    pub fn with_capacity(capacity: usize) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: uint::MAX }\n+            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: usize::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n@@ -245,8 +245,8 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n-                                 capacity: uint) -> Vec<T> {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n+                                 capacity: usize) -> Vec<T> {\n         Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n     }\n \n@@ -258,7 +258,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"may be better expressed via composition\")]\n-    pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n+    pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n@@ -276,7 +276,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.cap\n     }\n \n@@ -285,7 +285,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -295,9 +295,9 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `uint` overflow\";\n+            let err_msg = \"Vec::reserve: `usize` overflow\";\n             let new_cap = self.len.checked_add(additional).expect(err_msg)\n                 .checked_next_power_of_two().expect(err_msg);\n             self.grow_capacity(new_cap);\n@@ -314,7 +314,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -324,10 +324,10 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 11);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: uint) {\n+    pub fn reserve_exact(&mut self, additional: usize) {\n         if self.cap - self.len < additional {\n             match self.len.checked_add(additional) {\n-                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                None => panic!(\"Vec::reserve: `usize` overflow\"),\n                 Some(new_cap) => self.grow_capacity(new_cap)\n             }\n         }\n@@ -401,7 +401,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, len: uint) {\n+    pub fn truncate(&mut self, len: usize) {\n         unsafe {\n             // drop any extra elements\n             while len < self.len {\n@@ -455,7 +455,7 @@ impl<T> Vec<T> {\n             let cap = self.cap;\n             let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as uint + self.len()) as *const T\n+                (ptr as usize + self.len()) as *const T\n             } else {\n                 ptr.offset(self.len() as int) as *const T\n             };\n@@ -480,7 +480,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn set_len(&mut self, len: uint) {\n+    pub unsafe fn set_len(&mut self, len: usize) {\n         self.len = len;\n     }\n \n@@ -506,7 +506,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn swap_remove(&mut self, index: uint) -> T {\n+    pub fn swap_remove(&mut self, index: usize) -> T {\n         let length = self.len();\n         self.swap(index, length - 1);\n         self.pop().unwrap()\n@@ -530,7 +530,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, index: uint, element: T) {\n+    pub fn insert(&mut self, index: usize, element: T) {\n         let len = self.len();\n         assert!(index <= len);\n         // space for the new element\n@@ -566,7 +566,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, index: uint) -> T {\n+    pub fn remove(&mut self, index: usize) -> T {\n         let len = self.len();\n         assert!(index < len);\n         unsafe { // infallible\n@@ -602,11 +602,11 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n         let len = self.len();\n-        let mut del = 0u;\n+        let mut del = 0;\n         {\n             let v = &mut **self;\n \n-            for i in 0u..len {\n+            for i in 0..len {\n                 if !f(&v[i]) {\n                     del += 1;\n                 } else if del > 0 {\n@@ -623,7 +623,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Panics if the number of elements in the vector overflows a `usize`.\n     ///\n     /// # Examples\n     ///\n@@ -687,7 +687,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the number of elements in the vector overflows a `uint`.\n+    /// Panics if the number of elements in the vector overflows a `usize`.\n     ///\n     /// # Examples\n     /// ```rust\n@@ -741,7 +741,7 @@ impl<T> Vec<T> {\n         unsafe {\n             let begin = *self.ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (*self.ptr as uint + self.len()) as *const T\n+                (*self.ptr as usize + self.len()) as *const T\n             } else {\n                 (*self.ptr).offset(self.len() as int) as *const T\n             };\n@@ -781,7 +781,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.len }\n+    pub fn len(&self) -> usize { self.len }\n \n     /// Returns `true` if the vector contains no elements.\n     ///\n@@ -808,7 +808,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![0u, 1, 2];\n+    /// let v = vec![0, 1, 2];\n     /// let w = v.map_in_place(|i| i + 3);\n     /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n     ///\n@@ -850,7 +850,7 @@ impl<T> Vec<T> {\n             //        After `array.offset(offset)`: 0x9.\n             //        (0x1 + 0x8 = 0x1 - 0x8)\n             //\n-            // 2) If the size of the elements in the vector is >1, the `uint` ->\n+            // 2) If the size of the elements in the vector is >1, the `usize` ->\n             //    `int` conversion can't overflow.\n             let offset = vec.len() as int;\n             let start = vec.as_mut_ptr();\n@@ -977,8 +977,8 @@ impl<T> Vec<T> {\n                     let u = f(t);\n \n                     // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `uint` as we only do this for a\n-                    // number of times that fits into a `uint` (and start with\n+                    // cannot overflow the `usize` as we only do this for a\n+                    // number of times that fits into a `usize` (and start with\n                     // `0`). Again, we should not panic between these steps.\n                     mem::forget(u);\n                     pv.num_u += 1;\n@@ -1052,7 +1052,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n-    pub fn resize(&mut self, new_len: uint, value: T) {\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n         if new_len > len {\n@@ -1205,7 +1205,7 @@ impl<T> Vec<T> {\n     ///\n     /// If the capacity for `self` is already equal to or greater than the\n     /// requested capacity, then no action is taken.\n-    fn grow_capacity(&mut self, capacity: uint) {\n+    fn grow_capacity(&mut self, capacity: usize) {\n         if mem::size_of::<T>() == 0 { return }\n \n         if capacity > self.cap {\n@@ -1223,7 +1223,7 @@ impl<T> Vec<T> {\n \n // FIXME: #13996: need a way to mark the return value as `noalias`\n #[inline(never)]\n-unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T {\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: usize, size: usize) -> *mut T {\n     if old_size == 0 {\n         allocate(size, mem::min_align_of::<T>()) as *mut T\n     } else {\n@@ -1232,7 +1232,7 @@ unsafe fn alloc_or_realloc<T>(ptr: *mut T, old_size: uint, size: uint) -> *mut T\n }\n \n #[inline]\n-unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+unsafe fn dealloc<T>(ptr: *mut T, len: usize) {\n     if mem::size_of::<T>() != 0 {\n         deallocate(ptr as *mut u8,\n                    len * mem::size_of::<T>(),\n@@ -1274,49 +1274,49 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Index<uint> for Vec<T> {\n+impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n     #[inline]\n-    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+    fn index<'a>(&'a self, index: &usize) -> &'a T {\n         // NB built-in indexing via `&[T]`\n         &(**self)[*index]\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IndexMut<uint> for Vec<T> {\n+impl<T> IndexMut<usize> for Vec<T> {\n     type Output = T;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+    fn index_mut<'a>(&'a mut self, index: &usize) -> &'a mut T {\n         // NB built-in indexing via `&mut [T]`\n         &mut (**self)[*index]\n     }\n }\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n+impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n }\n@@ -1330,26 +1330,26 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n+impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n@@ -1609,7 +1609,7 @@ impl<'a, T> IntoCow<'a, Vec<T>, [T]> for &'a [T] where T: Clone {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     allocation: *mut T, // the block of memory allocated for the vector\n-    cap: uint, // the capacity of the vector\n+    cap: usize, // the capacity of the vector\n     ptr: *const T,\n     end: *const T\n }\n@@ -1645,7 +1645,7 @@ impl<T> Iterator for IntoIter<T> {\n                     // purposefully don't use 'ptr.offset' because for\n                     // vectors with 0-size elements this would return the\n                     // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+                    self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n                     Some(ptr::read(mem::transmute(1u)))\n@@ -1660,8 +1660,8 @@ impl<T> Iterator for IntoIter<T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let diff = (self.end as uint) - (self.ptr as uint);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n         let exact = diff / (if size == 0 {1} else {size});\n         (exact, Some(exact))\n@@ -1678,7 +1678,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n             } else {\n                 if mem::size_of::<T>() == 0 {\n                     // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as uint - 1);\n+                    self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n                     Some(ptr::read(mem::transmute(1u)))\n@@ -1733,7 +1733,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n                     // purposefully don't use 'ptr.offset' because for\n                     // vectors with 0-size elements this would return the\n                     // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+                    self.ptr = mem::transmute(self.ptr as usize + 1);\n \n                     // Use a non-null pointer value\n                     Some(ptr::read(mem::transmute(1u)))\n@@ -1748,8 +1748,8 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let diff = (self.end as uint) - (self.ptr as uint);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n         let exact = diff / (if size == 0 {1} else {size});\n         (exact, Some(exact))\n@@ -1766,7 +1766,7 @@ impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n             } else {\n                 if mem::size_of::<T>() == 0 {\n                     // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as uint - 1);\n+                    self.end = mem::transmute(self.end as usize - 1);\n \n                     // Use a non-null pointer value\n                     Some(ptr::read(mem::transmute(1u)))\n@@ -1862,8 +1862,8 @@ struct PartialVecNonZeroSized<T,U> {\n /// When the destructor of this struct runs, all `num_t` `T`s and `num_u` `U`s\n /// are destructed.\n struct PartialVecZeroSized<T,U> {\n-    num_t: uint,\n-    num_u: uint,\n+    num_t: usize,\n+    num_u: usize,\n     marker_t: InvariantType<T>,\n     marker_u: InvariantType<U>,\n }\n@@ -1920,7 +1920,7 @@ mod tests {\n     use super::as_vec;\n \n     struct DropCounter<'a> {\n-        count: &'a mut int\n+        count: &'a mut u32\n     }\n \n     #[unsafe_destructor]\n@@ -1949,7 +1949,7 @@ mod tests {\n \n     #[test]\n     fn test_small_vec_struct() {\n-        assert!(size_of::<Vec<u8>>() == size_of::<uint>() * 3);\n+        assert!(size_of::<Vec<u8>>() == size_of::<usize>() * 3);\n     }\n \n     #[test]\n@@ -2020,7 +2020,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_from_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let slice = &mut values[2 ..];\n             assert!(slice == [3, 4, 5]);\n@@ -2034,7 +2034,7 @@ mod tests {\n \n     #[test]\n     fn test_slice_to_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let slice = &mut values[.. 2];\n             assert!(slice == [1, 2]);\n@@ -2048,7 +2048,7 @@ mod tests {\n \n     #[test]\n     fn test_split_at_mut() {\n-        let mut values = vec![1u8,2,3,4,5];\n+        let mut values = vec![1, 2, 3, 4, 5];\n         {\n             let (left, right) = values.split_at_mut(2);\n             {\n@@ -2068,12 +2068,12 @@ mod tests {\n             }\n         }\n \n-        assert!(values == vec![2u8, 3, 5, 6, 7]);\n+        assert!(values == vec![2, 3, 5, 6, 7]);\n     }\n \n     #[test]\n     fn test_clone() {\n-        let v: Vec<int> = vec!();\n+        let v: Vec<i32> = vec![];\n         let w = vec!(1, 2, 3);\n \n         assert_eq!(v, v.clone());\n@@ -2108,9 +2108,9 @@ mod tests {\n \n     #[test]\n     fn test_retain() {\n-        let mut vec = vec![1u, 2, 3, 4];\n+        let mut vec = vec![1, 2, 3, 4];\n         vec.retain(|&x| x % 2 == 0);\n-        assert!(vec == vec![2u, 4]);\n+        assert!(vec == vec![2, 4]);\n     }\n \n     #[test]\n@@ -2169,20 +2169,20 @@ mod tests {\n             // Test on-stack copy-from-buf.\n             let a = [1, 2, 3];\n             let ptr = a.as_ptr();\n-            let b = Vec::from_raw_buf(ptr, 3u);\n+            let b = Vec::from_raw_buf(ptr, 3);\n             assert_eq!(b, vec![1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n             let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n-            let d = Vec::from_raw_buf(ptr, 5u);\n+            let d = Vec::from_raw_buf(ptr, 5);\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n         }\n     }\n \n     #[test]\n     fn test_vec_truncate_drop() {\n-        static mut drops: uint = 0;\n+        static mut drops: u32 = 0;\n         struct Elem(int);\n         impl Drop for Elem {\n             fn drop(&mut self) {\n@@ -2201,7 +2201,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_vec_truncate_fail() {\n-        struct BadElem(int);\n+        struct BadElem(i32);\n         impl Drop for BadElem {\n             fn drop(&mut self) {\n                 let BadElem(ref mut x) = *self;\n@@ -2217,62 +2217,62 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let vec = vec!(1, 2, 3);\n+        let vec = vec![1, 2, 3];\n         assert!(vec[1] == 2);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let vec = vec!(1, 2, 3);\n+        let vec = vec![1, 2, 3];\n         let _ = vec[3];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[-1..];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_2() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[-1..4];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_4() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[1..6];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_5() {\n-        let x: Vec<int> = vec![1, 2, 3, 4, 5];\n+        let x = vec![1, 2, 3, 4, 5];\n         &x[3..2];\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_swap_remove_empty() {\n-        let mut vec: Vec<uint> = vec!();\n+        let mut vec= Vec::<i32>::new();\n         vec.swap_remove(0);\n     }\n \n     #[test]\n     fn test_move_iter_unwrap() {\n-        let mut vec: Vec<uint> = Vec::with_capacity(7);\n+        let mut vec = Vec::with_capacity(7);\n         vec.push(1);\n         vec.push(2);\n         let ptr = vec.as_ptr();\n@@ -2285,14 +2285,14 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_map_in_place_incompatible_types_fail() {\n-        let v = vec![0u, 1, 2];\n+        let v = vec![0, 1, 2];\n         v.map_in_place(|_| ());\n     }\n \n     #[test]\n     fn test_map_in_place() {\n-        let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1, 0, 1]);\n+        let v = vec![0, 1, 2];\n+        assert_eq!(v.map_in_place(|i: u32| i as i32 - 1), [-1, 0, 1]);\n     }\n \n     #[test]\n@@ -2318,7 +2318,7 @@ mod tests {\n                 DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n             }\n         }\n-        const NUM_ELEMENTS: uint = 2;\n+        const NUM_ELEMENTS: usize = 2;\n         static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n \n         let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n@@ -2334,7 +2334,7 @@ mod tests {\n     #[test]\n     fn test_move_items() {\n         let vec = vec![1, 2, 3];\n-        let mut vec2 : Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec {\n             vec2.push(i);\n         }\n@@ -2344,7 +2344,7 @@ mod tests {\n     #[test]\n     fn test_move_items_reverse() {\n         let vec = vec![1, 2, 3];\n-        let mut vec2 : Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.into_iter().rev() {\n             vec2.push(i);\n         }\n@@ -2354,7 +2354,7 @@ mod tests {\n     #[test]\n     fn test_move_items_zero_sized() {\n         let vec = vec![(), (), ()];\n-        let mut vec2 : Vec<()> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec {\n             vec2.push(i);\n         }\n@@ -2364,7 +2364,7 @@ mod tests {\n     #[test]\n     fn test_drain_items() {\n         let mut vec = vec![1, 2, 3];\n-        let mut vec2: Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain() {\n             vec2.push(i);\n         }\n@@ -2375,18 +2375,18 @@ mod tests {\n     #[test]\n     fn test_drain_items_reverse() {\n         let mut vec = vec![1, 2, 3];\n-        let mut vec2: Vec<i32> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain().rev() {\n             vec2.push(i);\n         }\n         assert_eq!(vec, []);\n-        assert_eq!(vec2, [ 3, 2, 1 ]);\n+        assert_eq!(vec2, [3, 2, 1]);\n     }\n \n     #[test]\n     fn test_drain_items_zero_sized() {\n         let mut vec = vec![(), (), ()];\n-        let mut vec2: Vec<()> = vec![];\n+        let mut vec2 = vec![];\n         for i in vec.drain() {\n             vec2.push(i);\n         }\n@@ -2396,9 +2396,9 @@ mod tests {\n \n     #[test]\n     fn test_into_boxed_slice() {\n-        let xs = vec![1u, 2, 3];\n+        let xs = vec![1, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys, [1u, 2, 3]);\n+        assert_eq!(ys, [1, 2, 3]);\n     }\n \n     #[test]\n@@ -2421,17 +2421,17 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {\n-            let v: Vec<uint> = Vec::new();\n+            let v: Vec<u32> = Vec::new();\n             assert_eq!(v.len(), 0);\n             assert_eq!(v.capacity(), 0);\n         })\n     }\n \n-    fn do_bench_with_capacity(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let v: Vec<uint> = Vec::with_capacity(src_len);\n+            let v: Vec<u32> = Vec::with_capacity(src_len);\n             assert_eq!(v.len(), 0);\n             assert_eq!(v.capacity(), src_len);\n         })\n@@ -2457,7 +2457,7 @@ mod tests {\n         do_bench_with_capacity(b, 1000)\n     }\n \n-    fn do_bench_from_fn(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n@@ -2487,11 +2487,11 @@ mod tests {\n         do_bench_from_fn(b, 1000)\n     }\n \n-    fn do_bench_from_elem(b: &mut Bencher, src_len: uint) {\n+    fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = repeat(5).take(src_len).collect();\n+            let dst: Vec<usize> = repeat(5).take(src_len).collect();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().all(|x| *x == 5));\n         })\n@@ -2517,8 +2517,8 @@ mod tests {\n         do_bench_from_elem(b, 1000)\n     }\n \n-    fn do_bench_from_slice(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2549,13 +2549,13 @@ mod tests {\n         do_bench_from_slice(b, 1000)\n     }\n \n-    fn do_bench_from_iter(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<_> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst: Vec<uint> = FromIterator::from_iter(src.clone().into_iter());\n+            let dst: Vec<_> = FromIterator::from_iter(src.clone().into_iter());\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         });\n@@ -2581,9 +2581,9 @@ mod tests {\n         do_bench_from_iter(b, 1000)\n     }\n \n-    fn do_bench_extend(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2630,9 +2630,9 @@ mod tests {\n         do_bench_extend(b, 1000, 1000)\n     }\n \n-    fn do_bench_push_all(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_push_all(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2679,9 +2679,9 @@ mod tests {\n         do_bench_push_all(b, 1000, 1000)\n     }\n \n-    fn do_bench_push_all_move(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0u..dst_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_push_all_move(b: &mut Bencher, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2728,8 +2728,8 @@ mod tests {\n         do_bench_push_all_move(b, 1000, 1000)\n     }\n \n-    fn do_bench_clone(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n+    fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n+        let src: Vec<usize> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2760,9 +2760,9 @@ mod tests {\n         do_bench_clone(b, 1000)\n     }\n \n-    fn do_bench_clone_from(b: &mut Bencher, times: uint, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(0..src_len);\n-        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n+    fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: usize) {\n+        let dst: Vec<_> = FromIterator::from_iter(0..src_len);\n+        let src: Vec<_> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = (times * src_len) as u64;\n "}, {"sha": "08511ae3e27cf0099de210400b4de3842cfc7578", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 77, "deletions": 79, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -29,8 +29,6 @@ use core::ops::{Index, IndexMut};\n use {vec, slice};\n use vec::Vec;\n \n-// FIXME(conventions): capacity management???\n-\n /// A map optimized for small integer keys.\n ///\n /// # Examples\n@@ -117,7 +115,7 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n-        let mut count: uint = 0;\n+        let mut count: usize = 0;\n         for elt in self {\n             elt.hash(state);\n             count += 1;\n@@ -148,7 +146,7 @@ impl<V> VecMap<V> {\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> VecMap<V> {\n+    pub fn with_capacity(capacity: usize) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n@@ -164,7 +162,7 @@ impl<V> VecMap<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.v.capacity()\n     }\n \n@@ -183,7 +181,7 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: uint) {\n+    pub fn reserve_len(&mut self, len: usize) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n             self.v.reserve(len - cur_len);\n@@ -207,19 +205,19 @@ impl<V> VecMap<V> {\n     /// assert!(map.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: uint) {\n+    pub fn reserve_len_exact(&mut self, len: usize) {\n         let cur_len = self.v.len();\n         if len >= cur_len {\n             self.v.reserve_exact(len - cur_len);\n         }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order of the keys.\n-    /// The iterator's element type is `uint`.\n+    /// The iterator's element type is `usize`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((uint, &'r V)) -> uint = first; // coerce to fn pointer\n+        let first: fn((usize, &'r V)) -> usize = first; // coerce to fn pointer\n \n         Keys { iter: self.iter().map(first) }\n     }\n@@ -229,13 +227,13 @@ impl<V> VecMap<V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n-        let second: fn((uint, &'r V)) -> &'r V = second; // coerce to fn pointer\n+        let second: fn((usize, &'r V)) -> &'r V = second; // coerce to fn pointer\n \n         Values { iter: self.iter().map(second) }\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of the keys.\n-    /// The iterator's element type is `(uint, &'r V)`.\n+    /// The iterator's element type is `(usize, &'r V)`.\n     ///\n     /// # Examples\n     ///\n@@ -263,7 +261,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of the keys,\n     /// with mutable references to the values.\n-    /// The iterator's element type is `(uint, &'r mut V)`.\n+    /// The iterator's element type is `(usize, &'r mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -294,7 +292,7 @@ impl<V> VecMap<V> {\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, consuming the original `VecMap`.\n-    /// The iterator's element type is `(uint, &'r V)`.\n+    /// The iterator's element type is `(usize, &'r V)`.\n     ///\n     /// # Examples\n     ///\n@@ -306,23 +304,23 @@ impl<V> VecMap<V> {\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n     ///\n-    /// let vec: Vec<(uint, &str)> = map.into_iter().collect();\n+    /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n-        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n+        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n             v.map(|v| (i, v))\n         }\n-        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n+        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n         IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n \n     /// Returns an iterator visiting all key-value pairs in ascending order of\n     /// the keys, emptying (but not consuming) the original `VecMap`.\n-    /// The iterator's element type is `(uint, &'r V)`. Keeps the allocated memory for reuse.\n+    /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n     ///\n     /// # Examples\n     ///\n@@ -334,17 +332,17 @@ impl<V> VecMap<V> {\n     /// map.insert(3, \"c\");\n     /// map.insert(2, \"b\");\n     ///\n-    /// let vec: Vec<(uint, &str)> = map.drain().collect();\n+    /// let vec: Vec<(usize, &str)> = map.drain().collect();\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n-        fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n+        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n             v.map(|v| (i, v))\n         }\n-        let filter: fn((uint, Option<V>)) -> Option<(uint, V)> = filter; // coerce to fn ptr\n+        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n \n         Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n     }\n@@ -362,7 +360,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n \n@@ -411,7 +409,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, key: &uint) -> Option<&V> {\n+    pub fn get(&self, key: &usize) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -436,7 +434,7 @@ impl<V> VecMap<V> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key(&self, key: &uint) -> bool {\n+    pub fn contains_key(&self, key: &usize) -> bool {\n         self.get(key).is_some()\n     }\n \n@@ -456,7 +454,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n+    pub fn get_mut(&mut self, key: &usize) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n               Some(ref mut value) => Some(value),\n@@ -484,7 +482,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n+    pub fn insert(&mut self, key: usize, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n             self.v.extend((0..key - len + 1).map(|_| None));\n@@ -506,7 +504,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, key: &uint) -> Option<V> {\n+    pub fn remove(&mut self, key: &usize) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n@@ -669,8 +667,8 @@ impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> FromIterator<(uint, V)> for VecMap<V> {\n-    fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n+impl<V> FromIterator<(usize, V)> for VecMap<V> {\n+    fn from_iter<Iter: Iterator<Item=(usize, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n         map.extend(iter);\n         map\n@@ -702,29 +700,29 @@ impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> Extend<(uint, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, iter: Iter) {\n+impl<V> Extend<(usize, V)> for VecMap<V> {\n+    fn extend<Iter: Iterator<Item=(usize, V)>>(&mut self, iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<V> Index<uint> for VecMap<V> {\n+impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n     #[inline]\n-    fn index<'a>(&'a self, i: &uint) -> &'a V {\n+    fn index<'a>(&'a self, i: &usize) -> &'a V {\n         self.get(i).expect(\"key not present\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> IndexMut<uint> for VecMap<V> {\n+impl<V> IndexMut<usize> for VecMap<V> {\n     type Output = V;\n \n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut V {\n         self.get_mut(i).expect(\"key not present\")\n     }\n }\n@@ -757,7 +755,7 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 (0, Some(self.back - self.front))\n             }\n         }\n@@ -794,8 +792,8 @@ macro_rules! double_ended_iterator {\n /// An iterator over the key-value pairs of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, V:'a> {\n-    front: uint,\n-    back: uint,\n+    front: usize,\n+    back: usize,\n     iter: slice::Iter<'a, Option<V>>\n }\n \n@@ -810,25 +808,25 @@ impl<'a, V> Clone for Iter<'a, V> {\n     }\n }\n \n-iterator! { impl Iter -> (uint, &'a V), as_ref }\n-double_ended_iterator! { impl Iter -> (uint, &'a V), as_ref }\n+iterator! { impl Iter -> (usize, &'a V), as_ref }\n+double_ended_iterator! { impl Iter -> (usize, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, V:'a> {\n-    front: uint,\n-    back: uint,\n+    front: usize,\n+    back: usize,\n     iter: slice::IterMut<'a, Option<V>>\n }\n \n-iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n-double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n+iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n+double_ended_iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> usize>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -843,7 +841,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n /// An iterator over the values of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -860,47 +858,47 @@ impl<'a, V> Clone for Values<'a, V> {\n pub struct IntoIter<V> {\n     iter: FilterMap<\n     Enumerate<vec::IntoIter<Option<V>>>,\n-    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+    fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     Enumerate<vec::Drain<'a, Option<V>>>,\n-    fn((uint, Option<V>)) -> Option<(uint, V)>>\n+    fn((usize, Option<V>)) -> Option<(usize, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n-    type Item = (uint, V);\n+    type Item = (usize, V);\n \n-    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n #[unstable(feature = \"collections\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n-    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Keys<'a, V> {\n-    type Item = uint;\n+    type Item = usize;\n \n-    fn next(&mut self) -> Option<uint> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<usize> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n-    fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<usize> { self.iter.next_back() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> Iterator for Values<'a, V> {\n     type Item = &'a V;\n \n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n@@ -909,14 +907,14 @@ impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Iterator for IntoIter<V> {\n-    type Item = (uint, V);\n+    type Item = (usize, V);\n \n-    fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> DoubleEndedIterator for IntoIter<V> {\n-    fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n }\n \n #[cfg(test)]\n@@ -990,7 +988,7 @@ mod test_map {\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n-        let keys = map.keys().collect::<Vec<uint>>();\n+        let keys: Vec<_> = map.keys().collect();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n         assert!(keys.contains(&2));\n@@ -1003,7 +1001,7 @@ mod test_map {\n         map.insert(1, 'a');\n         map.insert(2, 'b');\n         map.insert(3, 'c');\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n+        let values: Vec<_> = map.values().cloned().collect();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n         assert!(values.contains(&'b'));\n@@ -1137,7 +1135,7 @@ mod test_map {\n         map.insert(3, \"c\");\n         map.insert(2, \"b\");\n \n-        let vec: Vec<(usize, &str)> = map.drain().collect();\n+        let vec: Vec<_> = map.drain().collect();\n \n         assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n         assert_eq!(map.len(), 0);\n@@ -1146,7 +1144,7 @@ mod test_map {\n     #[test]\n     fn test_show() {\n         let mut map = VecMap::new();\n-        let empty = VecMap::<int>::new();\n+        let empty = VecMap::<i32>::new();\n \n         map.insert(1, 2);\n         map.insert(3, 4);\n@@ -1195,7 +1193,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5).is_none());\n+        assert!(b.insert(2, 5).is_none());\n         assert!(a < b);\n         assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n@@ -1213,7 +1211,7 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1).is_none());\n+        assert!(a.insert(1, 1).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n         assert!(b.insert(2, 2).is_none());\n@@ -1245,9 +1243,9 @@ mod test_map {\n \n     #[test]\n     fn test_from_iter() {\n-        let xs: Vec<(uint, char)> = vec![(1u, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n+        let xs = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n \n-        let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n+        let map: VecMap<_> = xs.iter().cloned().collect();\n \n         for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n@@ -1256,7 +1254,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: VecMap<int> = VecMap::new();\n+        let mut map = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -1268,7 +1266,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: VecMap<int> = VecMap::new();\n+        let mut map = VecMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -1281,7 +1279,7 @@ mod test_map {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: VecMap<i32> = xs.iter().map(|&x| x).collect();\n+        let mut map: VecMap<_> = xs.iter().cloned().collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -1337,15 +1335,15 @@ mod bench {\n \n     #[bench]\n     pub fn insert_rand_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_rand_n(100, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_rand_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_rand_n(10_000, &mut m, b,\n                       |m, i| { m.insert(i, 1); },\n                       |m, i| { m.remove(&i); });\n@@ -1354,15 +1352,15 @@ mod bench {\n     // Insert seq\n     #[bench]\n     pub fn insert_seq_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_seq_n(100, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n     }\n \n     #[bench]\n     pub fn insert_seq_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         insert_seq_n(10_000, &mut m, b,\n                      |m, i| { m.insert(i, 1); },\n                      |m, i| { m.remove(&i); });\n@@ -1371,15 +1369,15 @@ mod bench {\n     // Find rand\n     #[bench]\n     pub fn find_rand_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n                     |m, i| { m.get(&i); });\n@@ -1388,15 +1386,15 @@ mod bench {\n     // Find seq\n     #[bench]\n     pub fn find_seq_100(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n-        let mut m : VecMap<uint> = VecMap::new();\n+        let mut m = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n                    |m, i| { m.get(&i); });"}, {"sha": "bacb0f3fa71764b6848bff19938b37dee136c18e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -1591,10 +1591,10 @@ pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx>\n }\n \n impl CLike for BuiltinBound {\n-    fn to_uint(&self) -> uint {\n+    fn to_usize(&self) -> uint {\n         *self as uint\n     }\n-    fn from_uint(v: uint) -> BuiltinBound {\n+    fn from_usize(v: uint) -> BuiltinBound {\n         unsafe { mem::transmute(v) }\n     }\n }"}, {"sha": "53d3b069467d348e6ecc76c9509641758c944d52", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -136,7 +136,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n         for item in self {\n-            bits |= item.to_uint();\n+            bits |= item.to_usize();\n         }\n         s.emit_uint(bits)\n     }\n@@ -150,7 +150,7 @@ impl<\n         let mut set = EnumSet::new();\n         for bit in 0..uint::BITS {\n             if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_uint(1 << bit));\n+                set.insert(CLike::from_usize(1 << bit));\n             }\n         }\n         Ok(set)"}, {"sha": "ca506e8c36f50a7111063c15c152eacd226f25e1", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -21,7 +21,7 @@ fn new_drop(b : &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {\n-        let m : HashMap<int, int> = HashMap::new();\n+        let m : HashMap<i32, i32> = HashMap::new();\n         assert_eq!(m.len(), 0);\n     })\n }"}, {"sha": "e1a8c8fd7038fc21ad4f6c0b48a33ac200dde57c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -45,9 +45,9 @@ use super::table::BucketState::{\n };\n use super::state::HashState;\n \n-const INITIAL_LOG2_CAP: uint = 5;\n+const INITIAL_LOG2_CAP: usize = 5;\n #[unstable(feature = \"std_misc\")]\n-pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n+pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n \n /// The default behavior of HashMap implements a load factor of 90.9%.\n /// This behavior is characterized by the following condition:\n@@ -62,7 +62,7 @@ impl DefaultResizePolicy {\n     }\n \n     #[inline]\n-    fn min_capacity(&self, usable_size: uint) -> uint {\n+    fn min_capacity(&self, usable_size: usize) -> usize {\n         // Here, we are rephrasing the logic by specifying the lower limit\n         // on capacity:\n         //\n@@ -72,7 +72,7 @@ impl DefaultResizePolicy {\n \n     /// An inverse of `min_capacity`, approximately.\n     #[inline]\n-    fn usable_capacity(&self, cap: uint) -> uint {\n+    fn usable_capacity(&self, cap: usize) -> usize {\n         // As the number of entries approaches usable capacity,\n         // min_capacity(size) must be smaller than the internal capacity,\n         // so that the map is not resized:\n@@ -369,7 +369,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: uint,\n+                        mut ib: usize,\n                         mut hash: SafeHash,\n                         mut k: K,\n                         mut v: V)\n@@ -515,7 +515,7 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n+    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n         HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n }\n@@ -569,7 +569,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n@@ -593,7 +593,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.resize_policy.usable_capacity(self.table.capacity())\n     }\n \n@@ -603,7 +603,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new allocation size overflows `uint`.\n+    /// Panics if the new allocation size overflows `usize`.\n     ///\n     /// # Example\n     ///\n@@ -613,7 +613,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n         let min_cap = self.resize_policy.min_capacity(new_size);\n \n@@ -631,7 +631,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///   1) Make sure the new capacity is enough for all the elements, accounting\n     ///      for the load factor.\n     ///   2) Ensure new_capacity is a power of two or zero.\n-    fn resize(&mut self, new_capacity: uint) {\n+    fn resize(&mut self, new_capacity: usize) {\n         assert!(self.table.size() <= new_capacity);\n         assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n \n@@ -793,7 +793,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n \n             if (ib as int) < robin_ib {\n                 // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as uint, hash, k, v);\n+                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n             }\n \n             probe = bucket.next();\n@@ -953,7 +953,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.table.size() }\n+    pub fn len(&self) -> usize { self.table.size() }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -1188,7 +1188,7 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             return Vacant(VacantEntry {\n                 hash: hash,\n                 key: k,\n-                elem: NeqElem(bucket, robin_ib as uint),\n+                elem: NeqElem(bucket, robin_ib as usize),\n             });\n         }\n \n@@ -1371,7 +1371,7 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,\n     /// and will kick the current one out on insertion.\n-    NeqElem(FullBucket<K, V, M>, uint),\n+    NeqElem(FullBucket<K, V, M>, usize),\n     /// The index is genuinely vacant.\n     NoElem(EmptyBucket<K, V, M>),\n }\n@@ -1674,11 +1674,11 @@ mod test_map {\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n-        k: uint\n+        k: usize\n     }\n \n     impl Dropable {\n-        fn new(k: uint) -> Dropable {\n+        fn new(k: usize) -> Dropable {\n             DROP_VECTOR.with(|slot| {\n                 slot.borrow_mut()[k] += 1;\n             });\n@@ -1711,24 +1711,24 @@ mod test_map {\n             let mut m = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in 0u..100 {\n+            for i in 0..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n-            for i in 0u..50 {\n+            for i in 0..50 {\n                 let k = Dropable::new(i);\n                 let v = m.remove(&k);\n \n@@ -1741,20 +1741,20 @@ mod test_map {\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..50 {\n+                for i in 0..50 {\n                     assert_eq!(v.borrow()[i], 0);\n                     assert_eq!(v.borrow()[i+100], 0);\n                 }\n \n-                for i in 50u..100 {\n+                for i in 50..100 {\n                     assert_eq!(v.borrow()[i], 1);\n                     assert_eq!(v.borrow()[i+100], 1);\n                 }\n             });\n         }\n \n         DROP_VECTOR.with(|v| {\n-            for i in 0u..200 {\n+            for i in 0..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1770,19 +1770,19 @@ mod test_map {\n             let mut hm = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in 0u..100 {\n+            for i in 0..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 hm.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n@@ -1797,19 +1797,19 @@ mod test_map {\n             let mut half = hm.into_iter().take(50);\n \n             DROP_VECTOR.with(|v| {\n-                for i in 0u..200 {\n+                for i in 0..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n             for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = (0u..100).filter(|&i| {\n+                let nk = (0..100).filter(|&i| {\n                     v.borrow()[i] == 1\n                 }).count();\n \n-                let nv = (0u..100).filter(|&i| {\n+                let nv = (0..100).filter(|&i| {\n                     v.borrow()[i+100] == 1\n                 }).count();\n \n@@ -1819,7 +1819,7 @@ mod test_map {\n         };\n \n         DROP_VECTOR.with(|v| {\n-            for i in 0u..200 {\n+            for i in 0..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1964,7 +1964,7 @@ mod test_map {\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n-        for i in 0u..32 {\n+        for i in 0..32 {\n             assert!(m.insert(i, i*2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n@@ -1981,8 +1981,8 @@ mod test_map {\n     #[test]\n     fn test_keys() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<HashMap<int, char>>();\n-        let keys = map.keys().map(|&k| k).collect::<Vec<int>>();\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let keys: Vec<_> = map.keys().cloned().collect();\n         assert_eq!(keys.len(), 3);\n         assert!(keys.contains(&1));\n         assert!(keys.contains(&2));\n@@ -1992,8 +1992,8 @@ mod test_map {\n     #[test]\n     fn test_values() {\n         let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map = vec.into_iter().collect::<HashMap<int, char>>();\n-        let values = map.values().map(|&v| v).collect::<Vec<char>>();\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let values: Vec<_> = map.values().cloned().collect();\n         assert_eq!(values.len(), 3);\n         assert!(values.contains(&'a'));\n         assert!(values.contains(&'b'));\n@@ -2031,8 +2031,8 @@ mod test_map {\n \n     #[test]\n     fn test_show() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n-        let empty: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n+        let empty: HashMap<i32, i32> = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(3, 4);\n@@ -2051,7 +2051,7 @@ mod test_map {\n         assert_eq!(m.len(), 0);\n         assert!(m.is_empty());\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         let old_cap = m.table.capacity();\n         while old_cap == m.table.capacity() {\n             m.insert(i, i);\n@@ -2079,7 +2079,7 @@ mod test_map {\n \n         assert_eq!(cap, initial_cap * 2);\n \n-        let mut i = 0u;\n+        let mut i = 0;\n         for _ in 0..cap * 3 / 4 {\n             m.insert(i, i);\n             i += 1;\n@@ -2121,21 +2121,21 @@ mod test_map {\n     #[test]\n     fn test_reserve_shrink_to_fit() {\n         let mut m = HashMap::new();\n-        m.insert(0u, 0u);\n+        m.insert(0, 0);\n         m.remove(&0);\n         assert!(m.capacity() >= m.len());\n-        for i in 0us..128 {\n+        for i in 0..128 {\n             m.insert(i, i);\n         }\n         m.reserve(256);\n \n         let usable_cap = m.capacity();\n-        for i in 128us..128+256 {\n+        for i in 128..(128 + 256) {\n             m.insert(i, i);\n             assert_eq!(m.capacity(), usable_cap);\n         }\n \n-        for i in 100us..128+256 {\n+        for i in 100..(128 + 256) {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2144,7 +2144,7 @@ mod test_map {\n         assert!(!m.is_empty());\n         assert!(m.capacity() >= m.len());\n \n-        for i in 0us..100 {\n+        for i in 0..100 {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2159,7 +2159,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         for &(k, v) in &xs {\n             assert_eq!(map.get(&k), Some(&v));\n@@ -2170,7 +2170,7 @@ mod test_map {\n     fn test_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2183,7 +2183,7 @@ mod test_map {\n     fn test_iter_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2196,7 +2196,7 @@ mod test_map {\n     fn test_mut_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2209,7 +2209,7 @@ mod test_map {\n     fn test_iter_mut_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2220,7 +2220,7 @@ mod test_map {\n \n     #[test]\n     fn test_index() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -2232,7 +2232,7 @@ mod test_map {\n     #[test]\n     #[should_fail]\n     fn test_index_nonexistent() {\n-        let mut map: HashMap<int, int> = HashMap::new();\n+        let mut map = HashMap::new();\n \n         map.insert(1, 2);\n         map.insert(2, 1);\n@@ -2245,7 +2245,7 @@ mod test_map {\n     fn test_entry(){\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n-        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         // Existing key (insert)\n         match map.entry(1) {\n@@ -2296,7 +2296,7 @@ mod test_map {\n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n         // Test for #19292\n-        fn check(m: &HashMap<int, ()>) {\n+        fn check(m: &HashMap<isize, ()>) {\n             for k in m.keys() {\n                 assert!(m.contains_key(k),\n                         \"{} is in keys() but not in the map?\", k);\n@@ -2307,12 +2307,12 @@ mod test_map {\n         let mut rng = weak_rng();\n \n         // Populate the map with some items.\n-        for _ in 0u..50 {\n+        for _ in 0..50 {\n             let x = rng.gen_range(-10, 10);\n             m.insert(x, ());\n         }\n \n-        for i in 0u..1000 {\n+        for i in 0..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n                 Vacant(_) => {},"}, {"sha": "a4641f14e3084825920f8b661cbb3a5f9a8f9ca1", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -76,7 +76,7 @@ use super::state::HashState;\n /// #[derive(Hash, Eq, PartialEq, Debug)]\n /// struct Viking<'a> {\n ///     name: &'a str,\n-///     power: uint,\n+///     power: usize,\n /// }\n ///\n /// let mut vikings = HashSet::new();\n@@ -123,7 +123,7 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n+    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n@@ -174,7 +174,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n             map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n@@ -192,7 +192,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.map.capacity()\n     }\n \n@@ -202,7 +202,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new allocation size overflows `uint`.\n+    /// Panics if the new allocation size overflows `usize`.\n     ///\n     /// # Example\n     ///\n@@ -212,7 +212,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.map.reserve(additional)\n     }\n \n@@ -402,7 +402,7 @@ impl<T, S, H> HashSet<T, S>\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> uint { self.map.len() }\n+    pub fn len(&self) -> usize { self.map.len() }\n \n     /// Returns true if the set contains no elements\n     ///\n@@ -456,7 +456,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let set: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -475,8 +475,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut b: HashSet<uint> = HashSet::new();\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut b = HashSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n     /// b.insert(4);\n@@ -496,8 +496,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sup: HashSet<uint> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<uint> = HashSet::new();\n+    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n     /// set.insert(2);\n@@ -517,8 +517,8 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let sub: HashSet<uint> = [1, 2].iter().map(|&x| x).collect();\n-    /// let mut set: HashSet<uint> = HashSet::new();\n+    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n     ///\n@@ -670,10 +670,10 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a | &b;\n+    /// let set = &a | &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 3, 4, 5];\n@@ -703,10 +703,10 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![2, 3, 4].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a & &b;\n+    /// let set = &a & &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [2, 3];\n@@ -736,10 +736,10 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a ^ &b;\n+    /// let set = &a ^ &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2, 4, 5];\n@@ -769,10 +769,10 @@ impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     /// ```\n     /// use std::collections::HashSet;\n     ///\n-    /// let a: HashSet<int> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<int> = vec![3, 4, 5].into_iter().collect();\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n     ///\n-    /// let set: HashSet<int> = &a - &b;\n+    /// let set = &a - &b;\n     ///\n     /// let mut i = 0;\n     /// let expected = [1, 2];\n@@ -1029,7 +1029,7 @@ mod test_set {\n     #[test]\n     fn test_iterate() {\n         let mut a = HashSet::new();\n-        for i in 0u..32 {\n+        for i in 0..32 {\n             assert!(a.insert(i));\n         }\n         let mut observed: u32 = 0;\n@@ -1152,7 +1152,7 @@ mod test_set {\n     fn test_from_iter() {\n         let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-        let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n+        let set: HashSet<_> = xs.iter().cloned().collect();\n \n         for x in &xs {\n             assert!(set.contains(x));\n@@ -1198,8 +1198,8 @@ mod test_set {\n \n     #[test]\n     fn test_show() {\n-        let mut set: HashSet<int> = HashSet::new();\n-        let empty: HashSet<int> = HashSet::new();\n+        let mut set = HashSet::new();\n+        let empty = HashSet::<i32>::new();\n \n         set.insert(1);\n         set.insert(2);\n@@ -1212,19 +1212,19 @@ mod test_set {\n \n     #[test]\n     fn test_trivial_drain() {\n-        let mut s = HashSet::<int>::new();\n+        let mut s = HashSet::<i32>::new();\n         for _ in s.drain() {}\n         assert!(s.is_empty());\n         drop(s);\n \n-        let mut s = HashSet::<int>::new();\n+        let mut s = HashSet::<i32>::new();\n         drop(s.drain());\n         assert!(s.is_empty());\n     }\n \n     #[test]\n     fn test_drain() {\n-        let mut s: HashSet<i32> = (1..100).collect();\n+        let mut s: HashSet<_> = (1..100).collect();\n \n         // try this a bunch of times to make sure we don't screw up internal state.\n         for _ in 0..20 {"}, {"sha": "0bb6bd4cf356a24c93cdcc388068a0d41900a1c5", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e250fe388b3455c067ad87dd3e3b5f6585850fcb/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e250fe388b3455c067ad87dd3e3b5f6585850fcb", "patch": "@@ -67,8 +67,8 @@ const EMPTY_BUCKET: u64 = 0u64;\n /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n #[unsafe_no_drop_flag]\n pub struct RawTable<K, V> {\n-    capacity: uint,\n-    size:     uint,\n+    capacity: usize,\n+    size:     usize,\n     hashes:   *mut u64,\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -88,21 +88,21 @@ impl<K,V> Copy for RawBucket<K,V> {}\n \n pub struct Bucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}\n \n pub struct EmptyBucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n pub struct FullBucket<K, V, M> {\n     raw:   RawBucket<K, V>,\n-    idx:   uint,\n+    idx:   usize,\n     table: M\n }\n \n@@ -190,7 +190,7 @@ impl<K, V, M> FullBucket<K, V, M> {\n         self.table\n     }\n     /// Get the raw index.\n-    pub fn index(&self) -> uint {\n+    pub fn index(&self) -> usize {\n         self.idx\n     }\n }\n@@ -212,21 +212,21 @@ impl<K, V, M> Bucket<K, V, M> {\n         self.table\n     }\n     /// Get the raw index.\n-    pub fn index(&self) -> uint {\n+    pub fn index(&self) -> usize {\n         self.idx\n     }\n }\n \n impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n-        Bucket::at_index(table, hash.inspect() as uint)\n+        Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n-    pub fn at_index(table: M, ib_index: uint) -> Bucket<K, V, M> {\n+    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         let ib_index = ib_index & (table.capacity() - 1);\n         Bucket {\n             raw: unsafe {\n-               table.first_bucket_raw().offset(ib_index as int)\n+               table.first_bucket_raw().offset(ib_index as isize)\n             },\n             idx: ib_index,\n             table: table\n@@ -276,7 +276,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n         // ... and it's zero at all other times.\n         let maybe_wraparound_dist = (self.idx ^ (self.idx + 1)) & self.table.capacity();\n         // Finally, we obtain the offset 1 or the offset -cap + 1.\n-        let dist = 1 - (maybe_wraparound_dist as int);\n+        let dist = 1 - (maybe_wraparound_dist as isize);\n \n         self.idx += 1;\n \n@@ -366,11 +366,11 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     ///\n     /// In the cited blog posts above, this is called the \"distance to\n     /// initial bucket\", or DIB. Also known as \"probe count\".\n-    pub fn distance(&self) -> uint {\n+    pub fn distance(&self) -> usize {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx - self.hash().inspect() as uint) & (self.table.capacity() - 1)\n+        (self.idx - self.hash().inspect() as usize) & (self.table.capacity() - 1)\n     }\n \n     #[inline]\n@@ -503,7 +503,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n /// # Panics\n ///\n /// Panics if `target_alignment` is not a power of two.\n-fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n     assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n@@ -520,10 +520,10 @@ fn test_rounding() {\n \n // Returns a tuple of (key_offset, val_offset),\n // from the start of a mallocated array.\n-fn calculate_offsets(hashes_size: uint,\n-                     keys_size: uint, keys_align: uint,\n-                     vals_align: uint)\n-                     -> (uint, uint) {\n+fn calculate_offsets(hashes_size: usize,\n+                     keys_size: usize, keys_align: usize,\n+                     vals_align: usize)\n+                     -> (usize, usize) {\n     let keys_offset = round_up_to_next(hashes_size, keys_align);\n     let end_of_keys = keys_offset + keys_size;\n \n@@ -534,10 +534,10 @@ fn calculate_offsets(hashes_size: uint,\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n-fn calculate_allocation(hash_size: uint, hash_align: uint,\n-                        keys_size: uint, keys_align: uint,\n-                        vals_size: uint, vals_align: uint)\n-                        -> (uint, uint, uint) {\n+fn calculate_allocation(hash_size: usize, hash_align: usize,\n+                        keys_size: usize, keys_align: usize,\n+                        vals_size: usize, vals_align: usize)\n+                        -> (usize, usize, usize) {\n     let hash_offset = 0;\n     let (_, vals_offset) = calculate_offsets(hash_size,\n                                              keys_size, keys_align,\n@@ -562,7 +562,7 @@ fn test_offset_calculation() {\n impl<K, V> RawTable<K, V> {\n     /// Does not initialize the buckets. The caller should ensure they,\n     /// at the very least, set every hash to EMPTY_BUCKET.\n-    unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n+    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n         if capacity == 0 {\n             return RawTable {\n                 size: 0,\n@@ -601,7 +601,7 @@ impl<K, V> RawTable<K, V> {\n         let buffer = allocate(size, malloc_alignment);\n         if buffer.is_null() { ::alloc::oom() }\n \n-        let hashes = buffer.offset(hash_offset as int) as *mut u64;\n+        let hashes = buffer.offset(hash_offset as isize) as *mut u64;\n \n         RawTable {\n             capacity: capacity,\n@@ -623,15 +623,15 @@ impl<K, V> RawTable<K, V> {\n         unsafe {\n             RawBucket {\n                 hash: self.hashes,\n-                key:  buffer.offset(keys_offset as int) as *mut K,\n-                val:  buffer.offset(vals_offset as int) as *mut V\n+                key:  buffer.offset(keys_offset as isize) as *mut K,\n+                val:  buffer.offset(vals_offset as isize) as *mut V\n             }\n         }\n     }\n \n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n-    pub fn new(capacity: uint) -> RawTable<K, V> {\n+    pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n             zero_memory(ret.hashes, capacity);\n@@ -640,21 +640,21 @@ impl<K, V> RawTable<K, V> {\n     }\n \n     /// The hashtable's capacity, similar to a vector's.\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.capacity\n     }\n \n     /// The number of elements ever `put` in the hashtable, minus the number\n     /// of elements ever `take`n.\n-    pub fn size(&self) -> uint {\n+    pub fn size(&self) -> usize {\n         self.size\n     }\n \n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n             hashes_end: unsafe {\n-                self.hashes.offset(self.capacity as int)\n+                self.hashes.offset(self.capacity as isize)\n             },\n             marker: marker::ContravariantLifetime,\n         }\n@@ -705,7 +705,7 @@ impl<K, V> RawTable<K, V> {\n     unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> {\n         let raw_bucket = self.first_bucket_raw();\n         RevMoveBuckets {\n-            raw: raw_bucket.offset(self.capacity as int),\n+            raw: raw_bucket.offset(self.capacity as isize),\n             hashes_end: raw_bucket.hash,\n             elems_left: self.size,\n             marker:     marker::ContravariantLifetime,\n@@ -758,7 +758,7 @@ impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n-    elems_left: uint,\n+    elems_left: usize,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n@@ -791,7 +791,7 @@ impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n /// Iterator over shared references to entries in a table.\n pub struct Iter<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: uint,\n+    elems_left: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -808,7 +808,7 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n /// Iterator over mutable references to entries in a table.\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n-    elems_left: uint,\n+    elems_left: usize,\n }\n \n /// Iterator over the entries in a table, consuming the table."}]}