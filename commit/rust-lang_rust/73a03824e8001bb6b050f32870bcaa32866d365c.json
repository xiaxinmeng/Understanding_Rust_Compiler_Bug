{"sha": "73a03824e8001bb6b050f32870bcaa32866d365c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYTAzODI0ZTgwMDFiYjZiMDUwZjMyODcwYmNhYTMyODY2ZDM2NWM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-21T23:37:50Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-22T00:03:00Z"}, "message": "Remove a level of indirection from std::arena.", "tree": {"sha": "5cf12811656e91173c36e62647ef488874b725d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cf12811656e91173c36e62647ef488874b725d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73a03824e8001bb6b050f32870bcaa32866d365c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73a03824e8001bb6b050f32870bcaa32866d365c", "html_url": "https://github.com/rust-lang/rust/commit/73a03824e8001bb6b050f32870bcaa32866d365c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73a03824e8001bb6b050f32870bcaa32866d365c/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f24e0e7b13be0bbead7d7f27b0af5943235c04da", "url": "https://api.github.com/repos/rust-lang/rust/commits/f24e0e7b13be0bbead7d7f27b0af5943235c04da", "html_url": "https://github.com/rust-lang/rust/commit/f24e0e7b13be0bbead7d7f27b0af5943235c04da"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "13f538db54ffeea85193c01cd1a5113fac77b656", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/73a03824e8001bb6b050f32870bcaa32866d365c/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a03824e8001bb6b050f32870bcaa32866d365c/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=73a03824e8001bb6b050f32870bcaa32866d365c", "patch": "@@ -46,15 +46,15 @@ const tydesc_drop_glue_index: size_t = 3 as size_t;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-type chunk = {data: ~[u8], mut fill: uint, is_pod: bool};\n+type chunk = {data: @[u8], mut fill: uint, is_pod: bool};\n \n struct arena {\n     // The head is seperated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n-    priv mut head: @chunk;\n-    priv mut pod_head: @chunk;\n-    priv mut chunks: @list<@chunk>;\n+    priv mut head: chunk;\n+    priv mut pod_head: chunk;\n+    priv mut chunks: @list<chunk>;\n     drop {\n         unsafe {\n             destroy_chunk(self.head);\n@@ -65,10 +65,10 @@ struct arena {\n     }\n }\n \n-fn chunk(size: uint, is_pod: bool) -> @chunk {\n-    let mut v = ~[];\n-    vec::reserve(v, size);\n-    @{ data: v, mut fill: 0u, is_pod: is_pod }\n+fn chunk(size: uint, is_pod: bool) -> chunk {\n+    let mut v = @[];\n+    unsafe { at_vec::unsafe::reserve(v, size); }\n+    { data: v, mut fill: 0u, is_pod: is_pod }\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n@@ -88,9 +88,9 @@ fn round_up_to(base: uint, align: uint) -> uint {\n \n // Walk down a chunk, running the destructors for any objects stored\n // in it.\n-unsafe fn destroy_chunk(chunk: @chunk) {\n+unsafe fn destroy_chunk(chunk: chunk) {\n     let mut idx = 0;\n-    let buf = vec::unsafe::to_ptr(chunk.data);\n+    let buf = vec::unsafe::to_ptr_slice(chunk.data);\n     let fill = chunk.fill;\n \n     while idx < fill {\n@@ -133,9 +133,9 @@ impl &arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let chunk_size = vec::capacity(self.pod_head.data);\n+        let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @cons(self.pod_head, self.chunks);\n+        self.chunks = @cons(copy self.pod_head, self.chunks);\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -144,11 +144,11 @@ impl &arena {\n \n     #[inline(always)]\n     fn alloc_pod_inner(n_bytes: uint, align: uint) -> *u8 {\n-        let head = self.pod_head;\n+        let head = &mut self.pod_head;\n \n         let start = round_up_to(head.fill, align);\n         let end = start + n_bytes;\n-        if end > vec::capacity(head.data) {\n+        if end > at_vec::capacity(head.data) {\n             return self.alloc_pod_grow(n_bytes, align);\n         }\n         head.fill = end;\n@@ -157,7 +157,7 @@ impl &arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            ptr::offset(vec::unsafe::to_ptr(head.data), start)\n+            ptr::offset(vec::unsafe::to_ptr_slice(head.data), start)\n         }\n     }\n \n@@ -175,9 +175,9 @@ impl &arena {\n     // Functions for the non-POD part of the arena\n     fn alloc_nonpod_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let chunk_size = vec::capacity(self.head.data);\n+        let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n-        self.chunks = @cons(self.head, self.chunks);\n+        self.chunks = @cons(copy self.head, self.chunks);\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n@@ -186,13 +186,13 @@ impl &arena {\n \n     #[inline(always)]\n     fn alloc_nonpod_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n-        let head = self.head;\n+        let head = &mut self.head;\n \n         let tydesc_start = head.fill;\n         let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n         let start = round_up_to(after_tydesc, align);\n         let end = start + n_bytes;\n-        if end > vec::capacity(head.data) {\n+        if end > at_vec::capacity(head.data) {\n             return self.alloc_nonpod_grow(n_bytes, align);\n         }\n         head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n@@ -201,7 +201,7 @@ impl &arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            let buf = vec::unsafe::to_ptr(head.data);\n+            let buf = vec::unsafe::to_ptr_slice(head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }"}]}