{"sha": "c0661ce7444223b0fff1f5d54adb41022ab788cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNjYxY2U3NDQ0MjIzYjBmZmYxZjVkNTRhZGI0MTAyMmFiNzg4Y2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-15T15:37:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-15T15:37:28Z"}, "message": "Merge #2853\n\n2853: Manage `cargo check` state updates in `main_loop` to reduce lock contention r=matklad a=kiljacken\n\nState is now updated exclusively from `main_loop` so several threads theoretically can't compete for the lock. Updates to the state are requested via the existing task channel.\r\n\r\nAlso updates some naming to make slightly more sense.\r\n\r\nBased upon an idea/suggestion from @matklad on Zulip:\r\n\r\n> I think I've noticed at leas something suspicious!\r\n> \r\n> In WorldSnapshot, we store an Arc<RwLock<CheckWatcherSharedState>>. We read lock this lock in handle_diagnostics.\r\n> \r\n> Additionally, we .write this lock from the watcher thread in CheckWatcherState::run.\r\n> \r\n> I think in general this is less then ideal, b/c diagnostics request can be blocked on another thread. I think it makes sense to architect this in a way which does not block.\r\n>\r\n> For that, we stop sharing the state between ServerWorld and CheckWatcherState. Instead, the watcher thread sends new diagnostics via a channel, and we accomodate thouse diagnostics intot he server state in the main loop.\r\n> \r\n> So, instead of:\r\n> ```rust\r\n> struct Server {\r\n>     diagnostics: Arc<Mutex<Vec<Diagnostics>>>,\r\n> }\r\n> \r\n> struct Watcher {\r\n>     diagnostics: Arc<Mutex<Vec<Diagnostics>>>,\r\n> }\r\n> ```\r\n> we'll have something like this:\r\n> ```rust\r\n> struct Server {\r\n>     // this bit now *owns* diagnostics\r\n>     diagnostisc: Vec<Diagnostics>\r\n> }\r\n> \r\n> struct Watcher {\r\n>     diagnostics_sink: Sender<Vec<Diagnostics>>,\r\n> }\r\n> ```\r\n> I am not sure this is the cuprit of slowness on widnows, but I think we should fix it, because it's very useful when all changes to the server's state can occur only via the main loop.\r\n> \r\n> Note how VFS is set up in a similar way: instead of modifing some global hash map with files, VFS sends a message to the main looop that hey, I have these new files for you. The main loop than incorporates the changes itself.\r\n> \r\n> Note that I think we'll still need some locks here, to share the state between ServerWorld and WorldSnapshot, but we won't actually be changing anyting mid-snapshot\r\n\n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>", "tree": {"sha": "24aa00d87f5a90d10d0ec37178331ec1c3f9428a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24aa00d87f5a90d10d0ec37178331ec1c3f9428a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeHzG4CRBK7hj4Ov3rIwAAdHIIABrFmGa4/3n73kRRrX6jWMzD\nw0OI4E+G7LQ36+xvJquGZfi7MpNbzFlGGtlLgqAAoIYn3ae29nytbZ4p92fxfdQX\n2ZO52/grCXZ+RcDpynlhiB7i9VX0KAiRMhXkpQtSqcCAtu0QGC4vUzg7ctetFci2\nociqE6vP8wvf77SHKrp+8/0ymCwfnFl+5IzNKij/hABbYutSODXhKg+kRTOf5rid\nfv1JCZWHO4tUnhUY39wOVdGlKPU3+sEs+Mahg0mPzceShnUpPwcAzY18eF8KOpZJ\nxaQK+613dikPG6BQ9CCXcjMfEMGjosKbTUxlzZqKA2CwUJZ5Bp/a4h4//TD4NhM=\n=6Ob+\n-----END PGP SIGNATURE-----\n", "payload": "tree 24aa00d87f5a90d10d0ec37178331ec1c3f9428a\nparent 80136367682ced76fb1a74403435c742685620c8\nparent 7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579102648 +0000\ncommitter GitHub <noreply@github.com> 1579102648 +0000\n\nMerge #2853\n\n2853: Manage `cargo check` state updates in `main_loop` to reduce lock contention r=matklad a=kiljacken\n\nState is now updated exclusively from `main_loop` so several threads theoretically can't compete for the lock. Updates to the state are requested via the existing task channel.\r\n\r\nAlso updates some naming to make slightly more sense.\r\n\r\nBased upon an idea/suggestion from @matklad on Zulip:\r\n\r\n> I think I've noticed at leas something suspicious!\r\n> \r\n> In WorldSnapshot, we store an Arc<RwLock<CheckWatcherSharedState>>. We read lock this lock in handle_diagnostics.\r\n> \r\n> Additionally, we .write this lock from the watcher thread in CheckWatcherState::run.\r\n> \r\n> I think in general this is less then ideal, b/c diagnostics request can be blocked on another thread. I think it makes sense to architect this in a way which does not block.\r\n>\r\n> For that, we stop sharing the state between ServerWorld and CheckWatcherState. Instead, the watcher thread sends new diagnostics via a channel, and we accomodate thouse diagnostics intot he server state in the main loop.\r\n> \r\n> So, instead of:\r\n> ```rust\r\n> struct Server {\r\n>     diagnostics: Arc<Mutex<Vec<Diagnostics>>>,\r\n> }\r\n> \r\n> struct Watcher {\r\n>     diagnostics: Arc<Mutex<Vec<Diagnostics>>>,\r\n> }\r\n> ```\r\n> we'll have something like this:\r\n> ```rust\r\n> struct Server {\r\n>     // this bit now *owns* diagnostics\r\n>     diagnostisc: Vec<Diagnostics>\r\n> }\r\n> \r\n> struct Watcher {\r\n>     diagnostics_sink: Sender<Vec<Diagnostics>>,\r\n> }\r\n> ```\r\n> I am not sure this is the cuprit of slowness on widnows, but I think we should fix it, because it's very useful when all changes to the server's state can occur only via the main loop.\r\n> \r\n> Note how VFS is set up in a similar way: instead of modifing some global hash map with files, VFS sends a message to the main looop that hey, I have these new files for you. The main loop than incorporates the changes itself.\r\n> \r\n> Note that I think we'll still need some locks here, to share the state between ServerWorld and WorldSnapshot, but we won't actually be changing anyting mid-snapshot\r\n\n\nCo-authored-by: Emil Lauridsen <mine809@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb", "html_url": "https://github.com/rust-lang/rust/commit/c0661ce7444223b0fff1f5d54adb41022ab788cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0661ce7444223b0fff1f5d54adb41022ab788cb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80136367682ced76fb1a74403435c742685620c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/80136367682ced76fb1a74403435c742685620c8", "html_url": "https://github.com/rust-lang/rust/commit/80136367682ced76fb1a74403435c742685620c8"}, {"sha": "7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3", "html_url": "https://github.com/rust-lang/rust/commit/7a8c6351bf50c1dcfb111be9f91da3c1f9cf2ec3"}], "stats": {"total": 165, "additions": 97, "deletions": 68}, "files": [{"sha": "7f4c9280cb3eb65e54d7f6ef078c3a45915012cd", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=c0661ce7444223b0fff1f5d54adb41022ab788cb", "patch": "@@ -38,30 +38,29 @@ pub struct CheckOptions {\n #[derive(Debug)]\n pub struct CheckWatcher {\n     pub task_recv: Receiver<CheckTask>,\n-    pub shared: Arc<RwLock<CheckWatcherSharedState>>,\n+    pub state: Arc<RwLock<CheckState>>,\n     cmd_send: Option<Sender<CheckCommand>>,\n     handle: Option<JoinHandle<()>>,\n }\n \n impl CheckWatcher {\n     pub fn new(options: &CheckOptions, workspace_root: PathBuf) -> CheckWatcher {\n         let options = options.clone();\n-        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n+        let state = Arc::new(RwLock::new(CheckState::new()));\n \n         let (task_send, task_recv) = unbounded::<CheckTask>();\n         let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n-        let shared_ = shared.clone();\n         let handle = std::thread::spawn(move || {\n-            let mut check = CheckWatcherState::new(options, workspace_root, shared_);\n+            let mut check = CheckWatcherThread::new(options, workspace_root);\n             check.run(&task_send, &cmd_recv);\n         });\n-        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), shared }\n+        CheckWatcher { task_recv, cmd_send: Some(cmd_send), handle: Some(handle), state }\n     }\n \n     /// Returns a CheckWatcher that doesn't actually do anything\n     pub fn dummy() -> CheckWatcher {\n-        let shared = Arc::new(RwLock::new(CheckWatcherSharedState::new()));\n-        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, shared }\n+        let state = Arc::new(RwLock::new(CheckState::new()));\n+        CheckWatcher { task_recv: never(), cmd_send: None, handle: None, state }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n@@ -89,30 +88,26 @@ impl std::ops::Drop for CheckWatcher {\n }\n \n #[derive(Debug)]\n-pub struct CheckWatcherSharedState {\n+pub struct CheckState {\n     diagnostic_collection: HashMap<Url, Vec<Diagnostic>>,\n     suggested_fix_collection: HashMap<Url, Vec<SuggestedFix>>,\n }\n \n-impl CheckWatcherSharedState {\n-    fn new() -> CheckWatcherSharedState {\n-        CheckWatcherSharedState {\n+impl CheckState {\n+    fn new() -> CheckState {\n+        CheckState {\n             diagnostic_collection: HashMap::new(),\n             suggested_fix_collection: HashMap::new(),\n         }\n     }\n \n     /// Clear the cached diagnostics, and schedule updating diagnostics by the\n     /// server, to clear stale results.\n-    pub fn clear(&mut self, task_send: &Sender<CheckTask>) {\n+    pub fn clear(&mut self) -> Vec<Url> {\n         let cleared_files: Vec<Url> = self.diagnostic_collection.keys().cloned().collect();\n-\n         self.diagnostic_collection.clear();\n         self.suggested_fix_collection.clear();\n-\n-        for uri in cleared_files {\n-            task_send.send(CheckTask::Update(uri.clone())).unwrap();\n-        }\n+        cleared_files\n     }\n \n     pub fn diagnostics_for(&self, uri: &Url) -> Option<&[Diagnostic]> {\n@@ -123,6 +118,13 @@ impl CheckWatcherSharedState {\n         self.suggested_fix_collection.get(uri).map(|d| d.as_slice())\n     }\n \n+    pub fn add_diagnostic_with_fixes(&mut self, file_uri: Url, diagnostic: DiagnosticWithFixes) {\n+        for fix in diagnostic.suggested_fixes {\n+            self.add_suggested_fix_for_diagnostic(fix, &diagnostic.diagnostic);\n+        }\n+        self.add_diagnostic(file_uri, diagnostic.diagnostic);\n+    }\n+\n     fn add_diagnostic(&mut self, file_uri: Url, diagnostic: Diagnostic) {\n         let diagnostics = self.diagnostic_collection.entry(file_uri).or_default();\n \n@@ -158,8 +160,11 @@ impl CheckWatcherSharedState {\n \n #[derive(Debug)]\n pub enum CheckTask {\n-    /// Request a update of the given files diagnostics\n-    Update(Url),\n+    /// Request a clearing of all cached diagnostics from the check watcher\n+    ClearDiagnostics,\n+\n+    /// Request adding a diagnostic with fixes included to a file\n+    AddDiagnostic(Url, DiagnosticWithFixes),\n \n     /// Request check progress notification to client\n     Status(WorkDoneProgress),\n@@ -170,26 +175,20 @@ pub enum CheckCommand {\n     Update,\n }\n \n-struct CheckWatcherState {\n+struct CheckWatcherThread {\n     options: CheckOptions,\n     workspace_root: PathBuf,\n     watcher: WatchThread,\n     last_update_req: Option<Instant>,\n-    shared: Arc<RwLock<CheckWatcherSharedState>>,\n }\n \n-impl CheckWatcherState {\n-    fn new(\n-        options: CheckOptions,\n-        workspace_root: PathBuf,\n-        shared: Arc<RwLock<CheckWatcherSharedState>>,\n-    ) -> CheckWatcherState {\n-        CheckWatcherState {\n+impl CheckWatcherThread {\n+    fn new(options: CheckOptions, workspace_root: PathBuf) -> CheckWatcherThread {\n+        CheckWatcherThread {\n             options,\n             workspace_root,\n             watcher: WatchThread::dummy(),\n             last_update_req: None,\n-            shared,\n         }\n     }\n \n@@ -215,7 +214,7 @@ impl CheckWatcherState {\n \n             if self.should_recheck() {\n                 self.last_update_req.take();\n-                self.shared.write().clear(task_send);\n+                task_send.send(CheckTask::ClearDiagnostics).unwrap();\n \n                 // By replacing the watcher, we drop the previous one which\n                 // causes it to shut down automatically.\n@@ -240,7 +239,7 @@ impl CheckWatcherState {\n         }\n     }\n \n-    fn handle_message(&mut self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n+    fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n                 task_send\n@@ -279,18 +278,9 @@ impl CheckWatcherState {\n                     };\n \n                 let MappedRustDiagnostic { location, diagnostic, suggested_fixes } = map_result;\n-                let file_uri = location.uri.clone();\n \n-                if !suggested_fixes.is_empty() {\n-                    for suggested_fix in suggested_fixes {\n-                        self.shared\n-                            .write()\n-                            .add_suggested_fix_for_diagnostic(suggested_fix, &diagnostic);\n-                    }\n-                }\n-                self.shared.write().add_diagnostic(file_uri, diagnostic);\n-\n-                task_send.send(CheckTask::Update(location.uri)).unwrap();\n+                let diagnostic = DiagnosticWithFixes { diagnostic, suggested_fixes };\n+                task_send.send(CheckTask::AddDiagnostic(location.uri, diagnostic)).unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n@@ -299,6 +289,12 @@ impl CheckWatcherState {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct DiagnosticWithFixes {\n+    diagnostic: Diagnostic,\n+    suggested_fixes: Vec<SuggestedFix>,\n+}\n+\n /// WatchThread exists to wrap around the communication needed to be able to\n /// run `cargo check` without blocking. Currently the Rust standard library\n /// doesn't provide a way to read sub-process output without blocking, so we"}, {"sha": "7822be2e2107ed43cf9cb7418728646816f1bec3", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=c0661ce7444223b0fff1f5d54adb41022ab788cb", "patch": "@@ -9,7 +9,7 @@ use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{ClientCapabilities, NumberOrString};\n+use lsp_types::{ClientCapabilities, NumberOrString, Url};\n use ra_cargo_watch::{CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n@@ -336,28 +336,7 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n-        Event::CheckWatcher(task) => match task {\n-            CheckTask::Update(uri) => {\n-                // We manually send a diagnostic update when the watcher asks\n-                // us to, to avoid the issue of having to change the file to\n-                // receive updated diagnostics.\n-                let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-                if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n-                    let params =\n-                        handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n-                    let not = notification_new::<req::PublishDiagnostics>(params);\n-                    task_sender.send(Task::Notify(not)).unwrap();\n-                }\n-            }\n-            CheckTask::Status(progress) => {\n-                let params = req::ProgressParams {\n-                    token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n-                    value: req::ProgressParamsValue::WorkDone(progress),\n-                };\n-                let not = notification_new::<req::Progress>(params);\n-                task_sender.send(Task::Notify(not)).unwrap();\n-            }\n-        },\n+        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -605,6 +584,60 @@ fn on_notification(\n     Ok(())\n }\n \n+fn on_check_task(\n+    task: CheckTask,\n+    world_state: &WorldState,\n+    task_sender: &Sender<Task>,\n+) -> Result<()> {\n+    match task {\n+        CheckTask::ClearDiagnostics => {\n+            let cleared_files = world_state.check_watcher.state.write().clear();\n+\n+            // Send updated diagnostics for each cleared file\n+            for url in cleared_files {\n+                publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+            }\n+        }\n+\n+        CheckTask::AddDiagnostic(url, diagnostic) => {\n+            world_state\n+                .check_watcher\n+                .state\n+                .write()\n+                .add_diagnostic_with_fixes(url.clone(), diagnostic);\n+\n+            // We manually send a diagnostic update when the watcher asks\n+            // us to, to avoid the issue of having to change the file to\n+            // receive updated diagnostics.\n+            publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+        }\n+\n+        CheckTask::Status(progress) => {\n+            let params = req::ProgressParams {\n+                token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n+                value: req::ProgressParamsValue::WorkDone(progress),\n+            };\n+            let not = notification_new::<req::Progress>(params);\n+            task_sender.send(Task::Notify(not)).unwrap();\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn publish_diagnostics_for_url(\n+    url: &Url,\n+    world_state: &WorldState,\n+    task_sender: &Sender<Task>,\n+) -> Result<()> {\n+    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n+        let params = handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n+        let not = notification_new::<req::PublishDiagnostics>(params);\n+        task_sender.send(Task::Notify(not)).unwrap();\n+    }\n+    Ok(())\n+}\n+\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,"}, {"sha": "7a3030a51aea47727e9de0451d2ef2ec754d23c6", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0661ce7444223b0fff1f5d54adb41022ab788cb/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=c0661ce7444223b0fff1f5d54adb41022ab788cb", "patch": "@@ -13,7 +13,7 @@ use lsp_server::ErrorCode;\n use lsp_types::Url;\n use parking_lot::RwLock;\n use ra_cargo_watch::{\n-    url_from_path_with_drive_lowercasing, CheckOptions, CheckWatcher, CheckWatcherSharedState,\n+    url_from_path_with_drive_lowercasing, CheckOptions, CheckState, CheckWatcher,\n };\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n@@ -64,7 +64,7 @@ pub struct WorldSnapshot {\n     pub analysis: Analysis,\n     pub vfs: Arc<RwLock<Vfs>>,\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n-    pub check_watcher: Arc<RwLock<CheckWatcherSharedState>>,\n+    pub check_watcher: Arc<RwLock<CheckState>>,\n }\n \n impl WorldState {\n@@ -220,7 +220,7 @@ impl WorldState {\n             analysis: self.analysis_host.analysis(),\n             vfs: Arc::clone(&self.vfs),\n             latest_requests: Arc::clone(&self.latest_requests),\n-            check_watcher: self.check_watcher.shared.clone(),\n+            check_watcher: self.check_watcher.state.clone(),\n         }\n     }\n "}]}