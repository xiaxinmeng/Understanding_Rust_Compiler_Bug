{"sha": "cb86f38497db255efbfc018685ee92b1d24acc77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiODZmMzg0OTdkYjI1NWVmYmZjMDE4Njg1ZWU5MmIxZDI0YWNjNzc=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-22T20:29:41Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "libtest: Failing benchmarks no longer crash the harness.", "tree": {"sha": "5d1c0a3be55bda179ba681ebaea61820b6e7658b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d1c0a3be55bda179ba681ebaea61820b6e7658b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb86f38497db255efbfc018685ee92b1d24acc77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb86f38497db255efbfc018685ee92b1d24acc77", "html_url": "https://github.com/rust-lang/rust/commit/cb86f38497db255efbfc018685ee92b1d24acc77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb86f38497db255efbfc018685ee92b1d24acc77/comments", "author": null, "committer": null, "parents": [{"sha": "360b26389c90716650d20fedf329c1a5332bbdbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/360b26389c90716650d20fedf329c1a5332bbdbb", "html_url": "https://github.com/rust-lang/rust/commit/360b26389c90716650d20fedf329c1a5332bbdbb"}], "stats": {"total": 128, "additions": 91, "deletions": 37}, "files": [{"sha": "ffa27688cf1a70d4ac71face0478209e5736bb82", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 91, "deletions": 37, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cb86f38497db255efbfc018685ee92b1d24acc77/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb86f38497db255efbfc018685ee92b1d24acc77/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=cb86f38497db255efbfc018685ee92b1d24acc77", "patch": "@@ -887,10 +887,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         .map(|t| t.desc.name.as_slice().len())\n         .unwrap_or(0);\n \n-    let is_multithreaded = match opts.test_threads {\n-        Some(n) => n > 1,\n-        None => get_concurrency() > 1,\n-    };\n+    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n \n     let mut out: Box<OutputFormatter> = match opts.format {\n         OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n@@ -1014,6 +1011,15 @@ pub enum TestEvent {\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n+struct Sink(Arc<Mutex<Vec<u8>>>);\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n \n pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n where\n@@ -1051,10 +1057,7 @@ where\n             _ => false,\n         });\n \n-    let concurrency = match opts.test_threads {\n-        Some(n) => n,\n-        None => get_concurrency(),\n-    };\n+    let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n \n     let mut remaining = filtered_tests;\n     remaining.reverse();\n@@ -1384,16 +1387,6 @@ pub fn run_test(\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Box<FnBox() + Send>) {\n-        struct Sink(Arc<Mutex<Vec<u8>>>);\n-        impl Write for Sink {\n-            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-                Write::write(&mut *self.0.lock().unwrap(), data)\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                Ok(())\n-            }\n-        }\n-\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let data2 = data.clone();\n@@ -1438,24 +1431,27 @@ pub fn run_test(\n \n     match testfn {\n         DynBenchFn(bencher) => {\n-            let bs = ::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n-            return;\n+            ::bench::benchmark(desc,\n+                                monitor_ch,\n+                                opts.nocapture,\n+                                |harness| bencher.run(harness));\n         }\n         StaticBenchFn(benchfn) => {\n-            let bs = ::bench::benchmark(|harness| (benchfn.clone())(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n-            return;\n+            ::bench::benchmark(desc,\n+                                monitor_ch,\n+                                opts.nocapture,\n+                                |harness| (benchfn.clone())(harness));\n         }\n         DynTestFn(f) => {\n             let cb = move || {\n                 __rust_begin_short_backtrace(f)\n             };\n             run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n         }\n-        StaticTestFn(f) =>\n+        StaticTestFn(f) => {\n             run_test_inner(desc, monitor_ch, opts.nocapture,\n-                           Box::new(move || __rust_begin_short_backtrace(f))),\n+                           Box::new(move || __rust_begin_short_backtrace(f)))\n+        }\n     }\n }\n \n@@ -1655,11 +1651,14 @@ where\n }\n \n pub mod bench {\n+    use std::panic::{catch_unwind, AssertUnwindSafe};\n     use std::cmp;\n+    use std::io;\n+    use std::sync::{Arc, Mutex};\n     use stats;\n-    use super::{Bencher, BenchSamples, BenchMode};\n+    use super::{Bencher, BenchSamples, BenchMode, Sink, MonitorMsg, TestDesc, Sender, TestResult};\n \n-    pub fn benchmark<F>(f: F) -> BenchSamples\n+    pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n     where\n         F: FnMut(&mut Bencher),\n     {\n@@ -1669,26 +1668,53 @@ pub mod bench {\n             bytes: 0,\n         };\n \n-        return match bs.bench(f) {\n-            Some(ns_iter_summ) => {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let data2 = data.clone();\n+\n+        let oldio = if !nocapture {\n+            Some((\n+                io::set_print(Some(Box::new(Sink(data2.clone())))),\n+                io::set_panic(Some(Box::new(Sink(data2)))),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n+\n+        if let Some((printio, panicio)) = oldio {\n+            io::set_print(printio);\n+            io::set_panic(panicio);\n+        };\n+\n+        let test_result = match result { //bs.bench(f) {\n+            Ok(Some(ns_iter_summ)) => {\n                 let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n                 let mb_s = bs.bytes * 1000 / ns_iter;\n \n-                BenchSamples {\n+                let bs = BenchSamples {\n                     ns_iter_summ,\n                     mb_s: mb_s as usize,\n-                }\n+                };\n+                TestResult::TrBench(bs)\n             }\n-            None => {\n+            Ok(None) => {\n                 // iter not called, so no data.\n                 // FIXME: error in this case?\n                 let samples: &mut [f64] = &mut [0.0_f64; 1];\n-                BenchSamples {\n+                let bs = BenchSamples {\n                     ns_iter_summ: stats::Summary::new(samples),\n                     mb_s: 0,\n-                }\n+                };\n+                TestResult::TrBench(bs)\n+            }\n+            Err(_) => {\n+                TestResult::TrFailed\n             }\n         };\n+\n+        let stdout = data.lock().unwrap().to_vec();\n+        monitor_ch.send((desc, test_result, stdout)).unwrap();\n     }\n \n     pub fn run_once<F>(f: F)\n@@ -2067,14 +2093,42 @@ mod tests {\n     #[test]\n     pub fn test_bench_no_iter() {\n         fn f(_: &mut Bencher) {}\n-        bench::benchmark(f);\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        ::bench::benchmark(desc,\n+                            tx,\n+                            true,\n+                            f);\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     pub fn test_bench_iter() {\n         fn f(b: &mut Bencher) {\n             b.iter(|| {})\n         }\n-        bench::benchmark(f);\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        ::bench::benchmark(desc,\n+                            tx,\n+                            true,\n+                            f);\n+        rx.recv().unwrap();\n     }\n }"}]}