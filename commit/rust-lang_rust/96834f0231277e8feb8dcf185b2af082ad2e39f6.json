{"sha": "96834f0231277e8feb8dcf185b2af082ad2e39f6", "node_id": "C_kwDOAAsO6NoAKDk2ODM0ZjAyMzEyNzdlOGZlYjhkY2YxODViMmFmMDgyYWQyZTM5ZjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T04:06:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T04:06:04Z"}, "message": "Auto merge of #107191 - Voultapher:reverse-timsort-scan-direction, r=thomcc\n\nReverse Timsort scan direction\n\nAnother PR in the series of stable sort improvements. Best reviewed by looking at the individual commits.\n\nThe main perf gain here is for fully ascending (sorted) or reversed inputs for cheap to compare types such as `u64`, these see a ~1.5x speedup.\n\n![timsort_evo2_hot_u64_10k](https://user-images.githubusercontent.com/6864584/213913351-cfdf452f-a37c-4bc6-a811-d10c60e66eca.png)\n\n![timsort_evo2_hot_string_10k](https://user-images.githubusercontent.com/6864584/213913354-d9cc395a-2b48-4f54-b687-09174b9e35ce.png)\n\nTypes such as string with indirect pre-fetching see only minor changes. Further speedups are planned in future PRs so, I wouldn't spend too much time for benchmarks here.", "tree": {"sha": "46bc6d81fa66df61191983401a960844b78ddfe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46bc6d81fa66df61191983401a960844b78ddfe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96834f0231277e8feb8dcf185b2af082ad2e39f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96834f0231277e8feb8dcf185b2af082ad2e39f6", "html_url": "https://github.com/rust-lang/rust/commit/96834f0231277e8feb8dcf185b2af082ad2e39f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96834f0231277e8feb8dcf185b2af082ad2e39f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7740f9a571b3c6510607b17b29c81eeb24a7c79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7740f9a571b3c6510607b17b29c81eeb24a7c79a", "html_url": "https://github.com/rust-lang/rust/commit/7740f9a571b3c6510607b17b29c81eeb24a7c79a"}, {"sha": "5eff2645335e86f714a92a592f81936fead1f6a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eff2645335e86f714a92a592f81936fead1f6a4", "html_url": "https://github.com/rust-lang/rust/commit/5eff2645335e86f714a92a592f81936fead1f6a4"}], "stats": {"total": 491, "additions": 271, "deletions": 220}, "files": [{"sha": "4ca4eb86bde280d95be01dcd3888aa1723f172ea", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 271, "deletions": 220, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/96834f0231277e8feb8dcf185b2af082ad2e39f6/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96834f0231277e8feb8dcf185b2af082ad2e39f6/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=96834f0231277e8feb8dcf185b2af082ad2e39f6", "patch": "@@ -13,115 +13,184 @@ use crate::cmp;\n use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n use crate::ptr;\n \n-/// When dropped, copies from `src` into `dest`.\n-struct CopyOnDrop<T> {\n+// When dropped, copies from `src` into `dest`.\n+struct InsertionHole<T> {\n     src: *const T,\n     dest: *mut T,\n }\n \n-impl<T> Drop for CopyOnDrop<T> {\n+impl<T> Drop for InsertionHole<T> {\n     fn drop(&mut self) {\n-        // SAFETY: This is a helper class.\n-        //         Please refer to its usage for correctness.\n-        //         Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n+        // SAFETY: This is a helper class. Please refer to its usage for correctness. Namely, one\n+        // must be sure that `src` and `dst` does not overlap as required by\n+        // `ptr::copy_nonoverlapping` and are both valid for writes.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }\n     }\n }\n \n-/// Shifts the first element to the right until it encounters a greater or equal element.\n-fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n+/// Inserts `v[v.len() - 1]` into pre-sorted sequence `v[..v.len() - 1]` so that whole `v[..]`\n+/// becomes sorted.\n+unsafe fn insert_tail<T, F>(v: &mut [T], is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n-    let len = v.len();\n-    // SAFETY: The unsafe operations below involves indexing without a bounds check (by offsetting a\n-    // pointer) and copying memory (`ptr::copy_nonoverlapping`).\n-    //\n-    // a. Indexing:\n-    //  1. We checked the size of the array to >=2.\n-    //  2. All the indexing that we will do is always between {0 <= index < len} at most.\n-    //\n-    // b. Memory copying\n-    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n-    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n-    //     Namely, `i` and `i-1`.\n-    //  3. If the slice is properly aligned, the elements are properly aligned.\n-    //     It is the caller's responsibility to make sure the slice is properly aligned.\n-    //\n-    // See comments below for further detail.\n+    debug_assert!(v.len() >= 2);\n+\n+    let arr_ptr = v.as_mut_ptr();\n+    let i = v.len() - 1;\n+\n+    // SAFETY: caller must ensure v is at least len 2.\n     unsafe {\n-        // If the first two elements are out-of-order...\n-        if len >= 2 && is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n-            // Read the first element into a stack-allocated variable. If a following comparison\n-            // operation panics, `hole` will get dropped and automatically write the element back\n-            // into the slice.\n-            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n-            let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(1) };\n-            ptr::copy_nonoverlapping(v.add(1), v.add(0), 1);\n-\n-            for i in 2..len {\n-                if !is_less(&*v.add(i), &*tmp) {\n+        // See insert_head which talks about why this approach is beneficial.\n+        let i_ptr = arr_ptr.add(i);\n+\n+        // It's important that we use i_ptr here. If this check is positive and we continue,\n+        // We want to make sure that no other copy of the value was seen by is_less.\n+        // Otherwise we would have to copy it back.\n+        if is_less(&*i_ptr, &*i_ptr.sub(1)) {\n+            // It's important, that we use tmp for comparison from now on. As it is the value that\n+            // will be copied back. And notionally we could have created a divergence if we copy\n+            // back the wrong value.\n+            let tmp = mem::ManuallyDrop::new(ptr::read(i_ptr));\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole { src: &*tmp, dest: i_ptr.sub(1) };\n+            ptr::copy_nonoverlapping(hole.dest, i_ptr, 1);\n+\n+            // SAFETY: We know i is at least 1.\n+            for j in (0..(i - 1)).rev() {\n+                let j_ptr = arr_ptr.add(j);\n+                if !is_less(&*tmp, &*j_ptr) {\n                     break;\n                 }\n \n-                // Move `i`-th element one place to the left, thus shifting the hole to the right.\n-                ptr::copy_nonoverlapping(v.add(i), v.add(i - 1), 1);\n-                hole.dest = v.add(i);\n+                ptr::copy_nonoverlapping(j_ptr, hole.dest, 1);\n+                hole.dest = j_ptr;\n             }\n             // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n         }\n     }\n }\n \n-/// Shifts the last element to the left until it encounters a smaller or equal element.\n-fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n+/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n+///\n+/// This is the integral subroutine of insertion sort.\n+unsafe fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n-    let len = v.len();\n-    // SAFETY: The unsafe operations below involves indexing without a bound check (by offsetting a\n-    // pointer) and copying memory (`ptr::copy_nonoverlapping`).\n-    //\n-    // a. Indexing:\n-    //  1. We checked the size of the array to >= 2.\n-    //  2. All the indexing that we will do is always between `0 <= index < len-1` at most.\n-    //\n-    // b. Memory copying\n-    //  1. We are obtaining pointers to references which are guaranteed to be valid.\n-    //  2. They cannot overlap because we obtain pointers to difference indices of the slice.\n-    //     Namely, `i` and `i+1`.\n-    //  3. If the slice is properly aligned, the elements are properly aligned.\n-    //     It is the caller's responsibility to make sure the slice is properly aligned.\n-    //\n-    // See comments below for further detail.\n+    debug_assert!(v.len() >= 2);\n+\n+    // SAFETY: caller must ensure v is at least len 2.\n     unsafe {\n-        // If the last two elements are out-of-order...\n-        if len >= 2 && is_less(v.get_unchecked(len - 1), v.get_unchecked(len - 2)) {\n-            // Read the last element into a stack-allocated variable. If a following comparison\n-            // operation panics, `hole` will get dropped and automatically write the element back\n-            // into the slice.\n-            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n-            let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(len - 2) };\n-            ptr::copy_nonoverlapping(v.add(len - 2), v.add(len - 1), 1);\n-\n-            for i in (0..len - 2).rev() {\n-                if !is_less(&*tmp, &*v.add(i)) {\n+        if is_less(v.get_unchecked(1), v.get_unchecked(0)) {\n+            let arr_ptr = v.as_mut_ptr();\n+\n+            // There are three ways to implement insertion here:\n+            //\n+            // 1. Swap adjacent elements until the first one gets to its final destination.\n+            //    However, this way we copy data around more than is necessary. If elements are big\n+            //    structures (costly to copy), this method will be slow.\n+            //\n+            // 2. Iterate until the right place for the first element is found. Then shift the\n+            //    elements succeeding it to make room for it and finally place it into the\n+            //    remaining hole. This is a good method.\n+            //\n+            // 3. Copy the first element into a temporary variable. Iterate until the right place\n+            //    for it is found. As we go along, copy every traversed element into the slot\n+            //    preceding it. Finally, copy data from the temporary variable into the remaining\n+            //    hole. This method is very good. Benchmarks demonstrated slightly better\n+            //    performance than with the 2nd method.\n+            //\n+            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n+            let tmp = mem::ManuallyDrop::new(ptr::read(arr_ptr));\n+\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `is_less`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `is_less` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole { src: &*tmp, dest: arr_ptr.add(1) };\n+            ptr::copy_nonoverlapping(arr_ptr.add(1), arr_ptr.add(0), 1);\n+\n+            for i in 2..v.len() {\n+                if !is_less(&v.get_unchecked(i), &*tmp) {\n                     break;\n                 }\n-\n-                // Move `i`-th element one place to the right, thus shifting the hole to the left.\n-                ptr::copy_nonoverlapping(v.add(i), v.add(i + 1), 1);\n-                hole.dest = v.add(i);\n+                ptr::copy_nonoverlapping(arr_ptr.add(i), arr_ptr.add(i - 1), 1);\n+                hole.dest = arr_ptr.add(i);\n             }\n             // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n         }\n     }\n }\n \n+/// Sort `v` assuming `v[..offset]` is already sorted.\n+///\n+/// Never inline this function to avoid code bloat. It still optimizes nicely and has practically no\n+/// performance impact. Even improving performance in some cases.\n+#[inline(never)]\n+fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+\n+    // Using assert here improves performance.\n+    assert!(offset != 0 && offset <= len);\n+\n+    // Shift each element of the unsorted region v[i..] as far left as is needed to make v sorted.\n+    for i in offset..len {\n+        // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len\n+        // >= 2. The range is exclusive and we know `i` must be at least 1 so this slice has at\n+        // >least len 2.\n+        unsafe {\n+            insert_tail(&mut v[..=i], is_less);\n+        }\n+    }\n+}\n+\n+/// Sort `v` assuming `v[offset..]` is already sorted.\n+///\n+/// Never inline this function to avoid code bloat. It still optimizes nicely and has practically no\n+/// performance impact. Even improving performance in some cases.\n+#[inline(never)]\n+fn insertion_sort_shift_right<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+\n+    // Using assert here improves performance.\n+    assert!(offset != 0 && offset <= len && len >= 2);\n+\n+    // Shift each element of the unsorted region v[..i] as far left as is needed to make v sorted.\n+    for i in (0..offset).rev() {\n+        // SAFETY: we tested that `offset` must be at least 1, so this loop is only entered if len\n+        // >= 2.We ensured that the slice length is always at least 2 long. We know that start_found\n+        // will be at least one less than end, and the range is exclusive. Which gives us i always\n+        // <= (end - 2).\n+        unsafe {\n+            insert_head(&mut v[i..len], is_less);\n+        }\n+    }\n+}\n+\n /// Partially sorts a slice by shifting several out-of-order elements around.\n ///\n /// Returns `true` if the slice is sorted at the end. This function is *O*(*n*) worst-case.\n@@ -161,26 +230,19 @@ where\n         // Swap the found pair of elements. This puts them in correct order.\n         v.swap(i - 1, i);\n \n-        // Shift the smaller element to the left.\n-        shift_tail(&mut v[..i], is_less);\n-        // Shift the greater element to the right.\n-        shift_head(&mut v[i..], is_less);\n+        if i >= 2 {\n+            // Shift the smaller element to the left.\n+            insertion_sort_shift_left(&mut v[..i], i - 1, is_less);\n+\n+            // Shift the greater element to the right.\n+            insertion_sort_shift_right(&mut v[..i], 1, is_less);\n+        }\n     }\n \n     // Didn't manage to sort the slice in the limited number of steps.\n     false\n }\n \n-/// Sorts a slice using insertion sort, which is *O*(*n*^2) worst-case.\n-fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    for i in 1..v.len() {\n-        shift_tail(&mut v[..i + 1], is_less);\n-    }\n-}\n-\n /// Sorts `v` using heapsort, which guarantees *O*(*n* \\* log(*n*)) worst-case.\n #[cold]\n #[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n@@ -510,7 +572,7 @@ where\n \n         // SAFETY: `pivot` is a reference to the first element of `v`, so `ptr::read` is safe.\n         let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n+        let _pivot_guard = InsertionHole { src: &*tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -563,7 +625,7 @@ where\n     // operation panics, the pivot will be automatically written back into the slice.\n     // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n     let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n+    let _pivot_guard = InsertionHole { src: &*tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice.\n@@ -745,7 +807,9 @@ where\n \n         // Very short slices get sorted using insertion sort.\n         if len <= MAX_INSERTION {\n-            insertion_sort(v, is_less);\n+            if len >= 2 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n             return;\n         }\n \n@@ -847,10 +911,14 @@ fn partition_at_index_loop<'a, T, F>(\n     let mut was_balanced = true;\n \n     loop {\n+        let len = v.len();\n+\n         // For slices of up to this length it's probably faster to simply sort them.\n         const MAX_INSERTION: usize = 10;\n-        if v.len() <= MAX_INSERTION {\n-            insertion_sort(v, is_less);\n+        if len <= MAX_INSERTION {\n+            if len >= 2 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n             return;\n         }\n \n@@ -890,7 +958,7 @@ fn partition_at_index_loop<'a, T, F>(\n         }\n \n         let (mid, _) = partition(v, pivot, is_less);\n-        was_balanced = cmp::min(mid, v.len() - mid) >= v.len() / 8;\n+        was_balanced = cmp::min(mid, len - mid) >= len / 8;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n         let (left, right) = v.split_at_mut(mid);\n@@ -957,75 +1025,6 @@ where\n     (left, pivot, right)\n }\n \n-/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n-///\n-/// This is the integral subroutine of insertion sort.\n-fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    if v.len() >= 2 && is_less(&v[1], &v[0]) {\n-        // SAFETY: Copy tmp back even if panic, and ensure unique observation.\n-        unsafe {\n-            // There are three ways to implement insertion here:\n-            //\n-            // 1. Swap adjacent elements until the first one gets to its final destination.\n-            //    However, this way we copy data around more than is necessary. If elements are big\n-            //    structures (costly to copy), this method will be slow.\n-            //\n-            // 2. Iterate until the right place for the first element is found. Then shift the\n-            //    elements succeeding it to make room for it and finally place it into the\n-            //    remaining hole. This is a good method.\n-            //\n-            // 3. Copy the first element into a temporary variable. Iterate until the right place\n-            //    for it is found. As we go along, copy every traversed element into the slot\n-            //    preceding it. Finally, copy data from the temporary variable into the remaining\n-            //    hole. This method is very good. Benchmarks demonstrated slightly better\n-            //    performance than with the 2nd method.\n-            //\n-            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n-\n-            // Intermediate state of the insertion process is always tracked by `hole`, which\n-            // serves two purposes:\n-            // 1. Protects integrity of `v` from panics in `is_less`.\n-            // 2. Fills the remaining hole in `v` in the end.\n-            //\n-            // Panic safety:\n-            //\n-            // If `is_less` panics at any point during the process, `hole` will get dropped and\n-            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n-            // initially held exactly once.\n-            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n-            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n-\n-            for i in 2..v.len() {\n-                if !is_less(&v[i], &*tmp) {\n-                    break;\n-                }\n-                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n-                hole.dest = &mut v[i];\n-            }\n-            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n-        }\n-    }\n-\n-    // When dropped, copies from `src` into `dest`.\n-    struct InsertionHole<T> {\n-        src: *const T,\n-        dest: *mut T,\n-    }\n-\n-    impl<T> Drop for InsertionHole<T> {\n-        fn drop(&mut self) {\n-            // SAFETY: The caller must ensure that src and dest are correctly set.\n-            unsafe {\n-                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n-            }\n-        }\n-    }\n-}\n-\n /// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n /// stores the result into `v[..]`.\n ///\n@@ -1183,8 +1182,6 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n-    // Very short runs are extended using insertion sort to span at least this many elements.\n-    const MIN_RUN: usize = 10;\n \n     // The caller should have already checked that.\n     debug_assert!(!T::IS_ZST);\n@@ -1194,9 +1191,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // Short arrays get sorted in-place via insertion sort to avoid allocations.\n     if len <= MAX_INSERTION {\n         if len >= 2 {\n-            for i in (0..len - 1).rev() {\n-                insert_head(&mut v[i..], is_less);\n-            }\n+            insertion_sort_shift_left(v, 1, is_less);\n         }\n         return;\n     }\n@@ -1206,59 +1201,43 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // `is_less` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n     // which will always have length at most `len / 2`.\n     let buf = BufGuard::new(len / 2, elem_alloc_fn, elem_dealloc_fn);\n-    let buf_ptr = buf.buf_ptr;\n+    let buf_ptr = buf.buf_ptr.as_ptr();\n \n     let mut runs = RunVec::new(run_alloc_fn, run_dealloc_fn);\n \n-    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n-    // strange decision, but consider the fact that merges more often go in the opposite direction\n-    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n-    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n-    let mut end = len;\n-    while end > 0 {\n-        // Find the next natural run, and reverse it if it's strictly descending.\n-        let mut start = end - 1;\n-        if start > 0 {\n-            start -= 1;\n-\n-            // SAFETY: The v.get_unchecked must be fed with correct inbound indicies.\n-            unsafe {\n-                if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n-                        start -= 1;\n-                    }\n-                    v[start..end].reverse();\n-                } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n-                    {\n-                        start -= 1;\n-                    }\n-                }\n-            }\n+    let mut end = 0;\n+    let mut start = 0;\n+\n+    // Scan forward. Memory pre-fetching prefers forward scanning vs backwards scanning, and the\n+    // code-gen is usually better. For the most sensitive types such as integers, these are merged\n+    // bidirectionally at once. So there is no benefit in scanning backwards.\n+    while end < len {\n+        let (streak_end, was_reversed) = find_streak(&v[start..], is_less);\n+        end += streak_end;\n+        if was_reversed {\n+            v[start..end].reverse();\n         }\n \n         // Insert some more elements into the run if it's too short. Insertion sort is faster than\n         // merge sort on short sequences, so this significantly improves performance.\n-        while start > 0 && end - start < MIN_RUN {\n-            start -= 1;\n-            insert_head(&mut v[start..end], is_less);\n-        }\n+        end = provide_sorted_batch(v, start, end, is_less);\n \n         // Push this run onto the stack.\n         runs.push(TimSortRun { start, len: end - start });\n-        end = start;\n+        start = end;\n \n         // Merge some pairs of adjacent runs to satisfy the invariants.\n-        while let Some(r) = collapse(runs.as_slice()) {\n-            let left = runs[r + 1];\n-            let right = runs[r];\n+        while let Some(r) = collapse(runs.as_slice(), len) {\n+            let left = runs[r];\n+            let right = runs[r + 1];\n+            let merge_slice = &mut v[left.start..right.start + right.len];\n             // SAFETY: `buf_ptr` must hold enough capacity for the shorter of the two sides, and\n             // neither side may be on length 0.\n             unsafe {\n-                merge(&mut v[left.start..right.start + right.len], left.len, buf_ptr, is_less);\n+                merge(merge_slice, left.len, buf_ptr, is_less);\n             }\n-            runs[r] = TimSortRun { start: left.start, len: left.len + right.len };\n-            runs.remove(r + 1);\n+            runs[r + 1] = TimSortRun { start: left.start, len: left.len + right.len };\n+            runs.remove(r);\n         }\n     }\n \n@@ -1280,10 +1259,10 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     // run starts at index 0, it will always demand a merge operation until the stack is fully\n     // collapsed, in order to complete the sort.\n     #[inline]\n-    fn collapse(runs: &[TimSortRun]) -> Option<usize> {\n+    fn collapse(runs: &[TimSortRun], stop: usize) -> Option<usize> {\n         let n = runs.len();\n         if n >= 2\n-            && (runs[n - 1].start == 0\n+            && (runs[n - 1].start + runs[n - 1].len == stop\n                 || runs[n - 2].len <= runs[n - 1].len\n                 || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n                 || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n@@ -1301,7 +1280,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n     where\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n-        buf_ptr: *mut T,\n+        buf_ptr: ptr::NonNull<T>,\n         capacity: usize,\n         elem_dealloc_fn: ElemDeallocF,\n     }\n@@ -1318,7 +1297,11 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         where\n             ElemAllocF: Fn(usize) -> *mut T,\n         {\n-            Self { buf_ptr: elem_alloc_fn(len), capacity: len, elem_dealloc_fn }\n+            Self {\n+                buf_ptr: ptr::NonNull::new(elem_alloc_fn(len)).unwrap(),\n+                capacity: len,\n+                elem_dealloc_fn,\n+            }\n         }\n     }\n \n@@ -1327,7 +1310,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         ElemDeallocF: Fn(*mut T, usize),\n     {\n         fn drop(&mut self) {\n-            (self.elem_dealloc_fn)(self.buf_ptr, self.capacity);\n+            (self.elem_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);\n         }\n     }\n \n@@ -1336,7 +1319,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         RunAllocF: Fn(usize) -> *mut TimSortRun,\n         RunDeallocF: Fn(*mut TimSortRun, usize),\n     {\n-        buf_ptr: *mut TimSortRun,\n+        buf_ptr: ptr::NonNull<TimSortRun>,\n         capacity: usize,\n         len: usize,\n         run_alloc_fn: RunAllocF,\n@@ -1353,7 +1336,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             const START_RUN_CAPACITY: usize = 16;\n \n             Self {\n-                buf_ptr: run_alloc_fn(START_RUN_CAPACITY),\n+                buf_ptr: ptr::NonNull::new(run_alloc_fn(START_RUN_CAPACITY)).unwrap(),\n                 capacity: START_RUN_CAPACITY,\n                 len: 0,\n                 run_alloc_fn,\n@@ -1364,23 +1347,23 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         fn push(&mut self, val: TimSortRun) {\n             if self.len == self.capacity {\n                 let old_capacity = self.capacity;\n-                let old_buf_ptr = self.buf_ptr;\n+                let old_buf_ptr = self.buf_ptr.as_ptr();\n \n                 self.capacity = self.capacity * 2;\n-                self.buf_ptr = (self.run_alloc_fn)(self.capacity);\n+                self.buf_ptr = ptr::NonNull::new((self.run_alloc_fn)(self.capacity)).unwrap();\n \n                 // SAFETY: buf_ptr new and old were correctly allocated and old_buf_ptr has\n                 // old_capacity valid elements.\n                 unsafe {\n-                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr, old_capacity);\n+                    ptr::copy_nonoverlapping(old_buf_ptr, self.buf_ptr.as_ptr(), old_capacity);\n                 }\n \n                 (self.run_dealloc_fn)(old_buf_ptr, old_capacity);\n             }\n \n             // SAFETY: The invariant was just checked.\n             unsafe {\n-                self.buf_ptr.add(self.len).write(val);\n+                self.buf_ptr.as_ptr().add(self.len).write(val);\n             }\n             self.len += 1;\n         }\n@@ -1393,7 +1376,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             // SAFETY: buf_ptr needs to be valid and len invariant upheld.\n             unsafe {\n                 // the place we are taking from.\n-                let ptr = self.buf_ptr.add(index);\n+                let ptr = self.buf_ptr.as_ptr().add(index);\n \n                 // Shift everything down to fill in that spot.\n                 ptr::copy(ptr.add(1), ptr, self.len - index - 1);\n@@ -1403,7 +1386,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n \n         fn as_slice(&self) -> &[TimSortRun] {\n             // SAFETY: Safe as long as buf_ptr is valid and len invariant was upheld.\n-            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr, self.len) }\n+            unsafe { &*ptr::slice_from_raw_parts(self.buf_ptr.as_ptr(), self.len) }\n         }\n \n         fn len(&self) -> usize {\n@@ -1422,7 +1405,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             if index < self.len {\n                 // SAFETY: buf_ptr and len invariant must be upheld.\n                 unsafe {\n-                    return &*(self.buf_ptr.add(index));\n+                    return &*(self.buf_ptr.as_ptr().add(index));\n                 }\n             }\n \n@@ -1439,7 +1422,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n             if index < self.len {\n                 // SAFETY: buf_ptr and len invariant must be upheld.\n                 unsafe {\n-                    return &mut *(self.buf_ptr.add(index));\n+                    return &mut *(self.buf_ptr.as_ptr().add(index));\n                 }\n             }\n \n@@ -1455,7 +1438,7 @@ pub fn merge_sort<T, CmpF, ElemAllocF, ElemDeallocF, RunAllocF, RunDeallocF>(\n         fn drop(&mut self) {\n             // As long as TimSortRun is Copy we don't need to drop them individually but just the\n             // whole allocation.\n-            (self.run_dealloc_fn)(self.buf_ptr, self.capacity);\n+            (self.run_dealloc_fn)(self.buf_ptr.as_ptr(), self.capacity);\n         }\n     }\n }\n@@ -1466,3 +1449,71 @@ pub struct TimSortRun {\n     len: usize,\n     start: usize,\n }\n+\n+/// Takes a range as denoted by start and end, that is already sorted and extends it to the right if\n+/// necessary with sorts optimized for smaller ranges such as insertion sort.\n+#[cfg(not(no_global_oom_handling))]\n+fn provide_sorted_batch<T, F>(v: &mut [T], start: usize, mut end: usize, is_less: &mut F) -> usize\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+    assert!(end >= start && end <= len);\n+\n+    // This value is a balance between least comparisons and best performance, as\n+    // influenced by for example cache locality.\n+    const MIN_INSERTION_RUN: usize = 10;\n+\n+    // Insert some more elements into the run if it's too short. Insertion sort is faster than\n+    // merge sort on short sequences, so this significantly improves performance.\n+    let start_end_diff = end - start;\n+\n+    if start_end_diff < MIN_INSERTION_RUN && end < len {\n+        // v[start_found..end] are elements that are already sorted in the input. We want to extend\n+        // the sorted region to the left, so we push up MIN_INSERTION_RUN - 1 to the right. Which is\n+        // more efficient that trying to push those already sorted elements to the left.\n+        end = cmp::min(start + MIN_INSERTION_RUN, len);\n+        let presorted_start = cmp::max(start_end_diff, 1);\n+\n+        insertion_sort_shift_left(&mut v[start..end], presorted_start, is_less);\n+    }\n+\n+    end\n+}\n+\n+/// Finds a streak of presorted elements starting at the beginning of the slice. Returns the first\n+/// value that is not part of said streak, and a bool denoting wether the streak was reversed.\n+/// Streaks can be increasing or decreasing.\n+fn find_streak<T, F>(v: &[T], is_less: &mut F) -> (usize, bool)\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    let len = v.len();\n+\n+    if len < 2 {\n+        return (len, false);\n+    }\n+\n+    let mut end = 2;\n+\n+    // SAFETY: See below specific.\n+    unsafe {\n+        // SAFETY: We checked that len >= 2, so 0 and 1 are valid indices.\n+        let assume_reverse = is_less(v.get_unchecked(1), v.get_unchecked(0));\n+\n+        // SAFETY: We know end >= 2 and check end < len.\n+        // From that follows that accessing v at end and end - 1 is safe.\n+        if assume_reverse {\n+            while end < len && is_less(v.get_unchecked(end), v.get_unchecked(end - 1)) {\n+                end += 1;\n+            }\n+\n+            (end, true)\n+        } else {\n+            while end < len && !is_less(v.get_unchecked(end), v.get_unchecked(end - 1)) {\n+                end += 1;\n+            }\n+            (end, false)\n+        }\n+    }\n+}"}]}