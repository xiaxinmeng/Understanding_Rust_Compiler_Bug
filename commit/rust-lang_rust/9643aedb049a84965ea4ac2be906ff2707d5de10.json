{"sha": "9643aedb049a84965ea4ac2be906ff2707d5de10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NDNhZWRiMDQ5YTg0OTY1ZWE0YWMyYmU5MDZmZjI3MDdkNWRlMTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-24T17:04:08Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-24T19:22:23Z"}, "message": "Remove uses of variable name 'res' from rustc\n\nThis in preparation of making 'res' a keyword for defining resources.\nPlease don't introduce too many new ones in the meantime...", "tree": {"sha": "3bf8252710630d05a36900226834f050dc7272f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bf8252710630d05a36900226834f050dc7272f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9643aedb049a84965ea4ac2be906ff2707d5de10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9643aedb049a84965ea4ac2be906ff2707d5de10", "html_url": "https://github.com/rust-lang/rust/commit/9643aedb049a84965ea4ac2be906ff2707d5de10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9643aedb049a84965ea4ac2be906ff2707d5de10/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d507d5fe91ce2708e4278c8bd100932c89b5e254", "url": "https://api.github.com/repos/rust-lang/rust/commits/d507d5fe91ce2708e4278c8bd100932c89b5e254", "html_url": "https://github.com/rust-lang/rust/commit/d507d5fe91ce2708e4278c8bd100932c89b5e254"}], "stats": {"total": 652, "additions": 321, "deletions": 331}, "files": [{"sha": "27623422e5d28be0ea78a2abba3c36f4324800c2", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -71,11 +71,11 @@ fn parse_ident(@pstate st, str_def sd, char last) -> ast::ident {\n \n fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n     -> ast::ident {\n-    auto res = \"\";\n+    auto rslt = \"\";\n     while (! is_last(peek(st) as char)) {\n-        res += str::unsafe_from_byte(next(st));\n+        rslt += str::unsafe_from_byte(next(st));\n     }\n-    ret res;\n+    ret rslt;\n }\n \n \n@@ -95,17 +95,17 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n }\n \n fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n-    let vec[@ty::constr_def] res = [];\n+    let vec[@ty::constr_def] rslt = [];\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n                 auto ignore = next(st);\n-                vec::push(res, parse_constr(st, sd));\n+                vec::push(rslt, parse_constr(st, sd));\n             } while (peek(st) as char == ';')\n         }\n         case (_) { }\n     }\n-    ret res;\n+    ret rslt;\n }\n \n fn parse_path(@pstate st, str_def sd) -> ast::path {\n@@ -370,8 +370,7 @@ fn parse_ty_fn(@pstate st, str_def sd) ->\n     }\n     st.pos += 1u; // eat the ']'\n     auto cs = parse_constrs(st, sd);\n-    auto res = parse_ty_or_bang(st, sd);\n-    alt (res) {\n+    alt (parse_ty_or_bang(st, sd)) {\n         case (a_bang) {\n             ret tup(inputs, ty::mk_bot(st.tcx), ast::noreturn, cs);\n         }"}, {"sha": "5b88c46af8fe44d7735a81d592f298a476689878", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -158,31 +158,31 @@ fn digits_to_string(str s) -> int {\n \n fn scan_exponent(&reader rdr) -> option::t[str] {\n     auto c = rdr.curr();\n-    auto res = \"\";\n+    auto rslt = \"\";\n     if (c == 'e' || c == 'E') {\n-        res += str::from_bytes([c as u8]);\n+        rslt += str::from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '-' || c == '+') {\n-            res += str::from_bytes([c as u8]);\n+            rslt += str::from_bytes([c as u8]);\n             rdr.bump();\n         }\n         auto exponent = scan_dec_digits(rdr);\n         if (str::byte_len(exponent) > 0u) {\n-            ret some(res + exponent);\n+            ret some(rslt + exponent);\n         } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n     } else { ret none[str]; }\n }\n \n fn scan_dec_digits(&reader rdr) -> str {\n     auto c = rdr.curr();\n-    let str res = \"\";\n+    let str rslt = \"\";\n     while (is_dec_digit(c) || c == '_') {\n-        if (c != '_') { res += str::from_bytes([c as u8]); }\n+        if (c != '_') { rslt += str::from_bytes([c as u8]); }\n         rdr.bump();\n         c = rdr.curr();\n     }\n-    ret res;\n+    ret rslt;\n }\n \n fn scan_number(char c, &reader rdr) -> token::token {"}, {"sha": "04dd8da3c8ad571d6b17b6d62bb24398dbcd8f3b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -58,7 +58,7 @@ fn new_parser(session::session sess, eval::env env,\n                      mutable uint lo,\n                      mutable uint hi,\n                      mutable uint last_lo,\n-                     mutable restriction res,\n+                     mutable restriction restr,\n                      lexer::reader rdr,\n                      vec[op_spec] precs,\n                      mutable ast::node_id next_id_var,\n@@ -75,8 +75,8 @@ fn new_parser(session::session sess, eval::env env,\n             hi = rdr.get_chpos();\n         }\n         fn fatal(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n-        fn restrict(restriction r) { res = r; }\n-        fn get_restriction() -> restriction { ret res; }\n+        fn restrict(restriction r) { restr = r; }\n+        fn get_restriction() -> restriction { ret restr; }\n         fn get_session() -> session::session { ret sess; }\n         fn get_span() -> common::span { ret rec(lo=lo, hi=hi); }\n         fn get_lo_pos() -> uint { ret lo; }\n@@ -1653,15 +1653,15 @@ fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     let util::common::spanned[vec[ast::arg]] inputs =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n                   p);\n-    let ty_or_bang res;\n+    let ty_or_bang rslt;\n     auto constrs = parse_constrs(inputs.node, p).node;\n     if (p.peek() == token::RARROW) {\n         p.bump();\n-        res = parse_ty_or_bang(p);\n+        rslt = parse_ty_or_bang(p);\n     } else {\n-        res = a_ty(@spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil));\n+        rslt = a_ty(@spanned(inputs.span.lo, inputs.span.hi, ast::ty_nil));\n     }\n-    alt (res) {\n+    alt (rslt) {\n         case (a_ty(?t)) {\n             ret rec(inputs=inputs.node,\n                     output=t,"}, {"sha": "749c58a50579cb811ae151664bc27064c13d74c7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 241, "deletions": 250, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -338,7 +338,9 @@ fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n     ret @rec(path=cx.path + [name] with *cx);\n }\n \n-fn res(@block_ctxt bcx, ValueRef val) -> result { ret rec(bcx=bcx, val=val); }\n+fn rslt(@block_ctxt bcx, ValueRef val) -> result {\n+    ret rec(bcx=bcx, val=val);\n+}\n \n fn ty_str(type_names tn, TypeRef t) -> str {\n     ret lib::llvm::type_to_str(tn, t);\n@@ -1119,7 +1121,7 @@ fn trans_non_gc_free(&@block_ctxt cx, ValueRef v) -> result {\n     cx.build.Call(cx.fcx.lcx.ccx.upcalls.free,\n                   [cx.fcx.lltaskptr, cx.build.PointerCast(v, T_ptr(T_i8())),\n                    C_int(0)]);\n-    ret res(cx, C_int(0));\n+    ret rslt(cx, C_int(0));\n }\n \n fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n@@ -1167,14 +1169,14 @@ fn llalign_of(TypeRef t) -> ValueRef {\n \n fn size_of(&@block_ctxt cx, &ty::t t) -> result {\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, llsize_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n+        ret rslt(cx, llsize_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n fn align_of(&@block_ctxt cx, &ty::t t) -> result {\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, llalign_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n+        ret rslt(cx, llalign_of(type_of(cx.fcx.lcx.ccx, cx.sp, t)));\n     }\n     ret dynamic_align_of(cx, t);\n }\n@@ -1282,13 +1284,13 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n         off = align_to(bcx, off, max_align);\n-        ret res(bcx, off);\n+        ret rslt(bcx, off);\n     }\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_param(?p)) {\n             auto szptr =\n                 field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-            ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n+            ret rslt(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty::ty_tup(?elts)) {\n             let vec[ty::t] tys = [];\n@@ -1326,17 +1328,17 @@ fn dynamic_size_of(&@block_ctxt cx, ty::t t) -> result {\n             }\n             auto max_size_val = bcx.build.Load(max_size);\n             auto total_size = bcx.build.Add(max_size_val, llsize_of(T_int()));\n-            ret res(bcx, total_size);\n+            ret rslt(bcx, total_size);\n         }\n         case (ty::ty_ivec(?mt)) {\n-            auto rslt = field_of_tydesc(cx, mt.ty, false,\n-                                        abi::tydesc_field_size);\n-            auto bcx = rslt.bcx;\n-            auto llunitszptr = rslt.val;\n+            auto rs = field_of_tydesc(cx, mt.ty, false,\n+                                      abi::tydesc_field_size);\n+            auto bcx = rs.bcx;\n+            auto llunitszptr = rs.val;\n             auto llunitsz = bcx.build.Load(llunitszptr);\n             auto llsz = bcx.build.Add(llsize_of(T_opaque_ivec()),\n                 bcx.build.Mul(llunitsz, C_uint(abi::ivec_default_length)));\n-            ret res(bcx, llsz);\n+            ret rslt(bcx, llsz);\n         }\n     }\n }\n@@ -1346,7 +1348,7 @@ fn dynamic_align_of(&@block_ctxt cx, &ty::t t) -> result {\n         case (ty::ty_param(?p)) {\n             auto aptr =\n                 field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-            ret res(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n+            ret rslt(aptr.bcx, aptr.bcx.build.Load(aptr.val));\n         }\n         case (ty::ty_tup(?elts)) {\n             auto a = C_int(1);\n@@ -1356,7 +1358,7 @@ fn dynamic_align_of(&@block_ctxt cx, &ty::t t) -> result {\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n-            ret res(bcx, a);\n+            ret rslt(bcx, a);\n         }\n         case (ty::ty_rec(?flds)) {\n             auto a = C_int(1);\n@@ -1366,17 +1368,17 @@ fn dynamic_align_of(&@block_ctxt cx, &ty::t t) -> result {\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n-            ret res(bcx, a);\n+            ret rslt(bcx, a);\n         }\n         case (ty::ty_tag(_, _)) {\n-            ret res(cx, C_int(1)); // FIXME: stub\n+            ret rslt(cx, C_int(1)); // FIXME: stub\n         }\n         case (ty::ty_ivec(?tm)) {\n-            auto rslt = align_of(cx, tm.ty);\n-            auto bcx = rslt.bcx;\n-            auto llunitalign = rslt.val;\n+            auto rs = align_of(cx, tm.ty);\n+            auto bcx = rs.bcx;\n+            auto llunitalign = rs.val;\n             auto llalign = umax(bcx, llalign_of(T_int()), llunitalign);\n-            ret res(bcx, llalign);\n+            ret rslt(bcx, llalign);\n         }\n     }\n }\n@@ -1395,7 +1397,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t, ValueRef base, &vec[int] ixs) ->\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         let vec[ValueRef] v = [];\n         for (int i in ixs) { v += [C_int(i)]; }\n-        ret res(cx, cx.build.GEP(base, v));\n+        ret rslt(cx, cx.build.GEP(base, v));\n     }\n     // It is a dynamic-containing type that, if we convert directly to an LLVM\n     // TypeRef, will be all wrong; there's no proper LLVM type to represent\n@@ -1465,10 +1467,10 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t, ValueRef base, &vec[int] ixs) ->\n     auto raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n     auto bumped = bcx.build.GEP(raw, [sz.val]);\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, s.target)) {\n-        ret res(bcx, bumped);\n+        ret rslt(bcx, bumped);\n     }\n     auto typ = T_ptr(type_of(bcx.fcx.lcx.ccx, bcx.sp, s.target));\n-    ret res(bcx, bcx.build.PointerCast(bumped, typ));\n+    ret rslt(bcx, bcx.build.PointerCast(bumped, typ));\n }\n \n \n@@ -1506,15 +1508,15 @@ fn GEP_tag(@block_ctxt cx, ValueRef llblobptr, &ast::def_id tag_id,\n     } else { llunionptr = llblobptr; }\n     // Do the GEP_tup_like().\n \n-    auto rslt = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix]);\n+    auto rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix]);\n     // Cast the result to the appropriate type, if necessary.\n \n     auto val;\n     if (!ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, elem_ty)) {\n-        auto llelemty = type_of(rslt.bcx.fcx.lcx.ccx, cx.sp, elem_ty);\n-        val = rslt.bcx.build.PointerCast(rslt.val, T_ptr(llelemty));\n-    } else { val = rslt.val; }\n-    ret res(rslt.bcx, val);\n+        auto llelemty = type_of(rs.bcx.fcx.lcx.ccx, cx.sp, elem_ty);\n+        val = rs.bcx.build.PointerCast(rs.val, T_ptr(llelemty));\n+    } else { val = rs.val; }\n+    ret rslt(rs.bcx, val);\n }\n \n \n@@ -1528,7 +1530,7 @@ fn trans_raw_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n     auto rval =\n         cx.build.Call(cx.fcx.lcx.ccx.upcalls.malloc,\n                       [cx.fcx.lltaskptr, llsize, tydesc]);\n-    ret res(cx, cx.build.PointerCast(rval, llptr_ty));\n+    ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n \n@@ -1568,7 +1570,7 @@ fn field_of_tydesc(&@block_ctxt cx, &ty::t t, bool escapes, int field) ->\n    result {\n     auto ti = none[@tydesc_info];\n     auto tydesc = get_tydesc(cx, t, escapes, ti);\n-    ret res(tydesc.bcx,\n+    ret rslt(tydesc.bcx,\n             tydesc.bcx.build.GEP(tydesc.val, [C_int(0), C_int(field)]));\n }\n \n@@ -1631,7 +1633,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n \n             // If the tydesc escapes in this context, the cached derived\n             // tydesc also has to be one that was marked as escaping.\n-            if (!(escapes && !info.escapes)) { ret res(cx, info.lltydesc); }\n+            if (!(escapes && !info.escapes)) { ret rslt(cx, info.lltydesc); }\n         }\n         case (none) {/* fall through */ }\n     }\n@@ -1689,15 +1691,15 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n                                              llparamtydescs);\n     }\n     bcx.fcx.derived_tydescs.insert(t, rec(lltydesc=v, escapes=escapes));\n-    ret res(cx, v);\n+    ret rslt(cx, v);\n }\n \n fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n               &mutable option::t[@tydesc_info] static_ti) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n \n     alt (ty::type_param(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (some(?id)) { ret res(cx, cx.fcx.lltydescs.(id)); }\n+        case (some(?id)) { ret rslt(cx, cx.fcx.lltydescs.(id)); }\n         case (none) {/* fall through */ }\n     }\n     // Does it contain a type param? If so, generate a derived tydesc.\n@@ -1710,7 +1712,7 @@ fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     let vec[uint] tps = [];\n     auto info = get_static_tydesc(cx, t, tps);\n     static_ti = some[@tydesc_info](info);\n-    ret res(cx, info.tydesc);\n+    ret rslt(cx, info.tydesc);\n }\n \n fn get_static_tydesc(&@block_ctxt cx, &ty::t t, &vec[uint] ty_params) ->\n@@ -1934,54 +1936,50 @@ fn incr_refcnt_of_boxed(&@block_ctxt cx, ValueRef box_ptr) -> result {\n     rc = rc_adj_cx.build.Add(rc, C_int(1));\n     rc_adj_cx.build.Store(rc, rc_ptr);\n     rc_adj_cx.build.Br(next_cx.llbb);\n-    ret res(next_cx, C_nil());\n+    ret rslt(next_cx, C_nil());\n }\n \n fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n \n-    auto rslt;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+    auto rs = alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_str) {\n             auto v = cx.build.Load(v0);\n-            rslt = trans_non_gc_free(cx, v);\n+            trans_non_gc_free(cx, v)\n         }\n         case (ty::ty_vec(_)) {\n             auto v = cx.build.Load(v0);\n-            auto res = iter_sequence(cx, v, t, bind drop_ty(_, _, _));\n+            auto rs = iter_sequence(cx, v, t, bind drop_ty(_, _, _));\n             // FIXME: switch gc/non-gc on layer of the type.\n-\n-            rslt = trans_non_gc_free(res.bcx, v);\n+            trans_non_gc_free(rs.bcx, v)\n         }\n         case (ty::ty_box(?body_mt)) {\n             auto v = cx.build.Load(v0);\n             auto body =\n                 cx.build.GEP(v, [C_int(0), C_int(abi::box_rc_field_body)]);\n             auto body_ty = body_mt.ty;\n             auto body_val = load_if_immediate(cx, body, body_ty);\n-            auto res = drop_ty(cx, body_val, body_ty);\n+            auto rs = drop_ty(cx, body_val, body_ty);\n             // FIXME: switch gc/non-gc on layer of the type.\n-\n-            rslt = trans_non_gc_free(res.bcx, v);\n+            trans_non_gc_free(rs.bcx, v)\n         }\n         case (ty::ty_port(_)) {\n             auto v = cx.build.Load(v0);\n             cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_port,\n                           [cx.fcx.lltaskptr,\n                            cx.build.PointerCast(v, T_opaque_port_ptr())]);\n-            rslt = res(cx, C_int(0));\n+            rslt(cx, C_int(0))\n         }\n         case (ty::ty_chan(_)) {\n             auto v = cx.build.Load(v0);\n             cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_chan,\n                           [cx.fcx.lltaskptr,\n                            cx.build.PointerCast(v, T_opaque_chan_ptr())]);\n-            rslt = res(cx, C_int(0));\n+            rslt(cx, C_int(0))\n         }\n         case (ty::ty_task) {\n             // TODO: call upcall_kill\n-\n-            rslt = res(cx, C_nil());\n+            rslt(cx, C_nil())\n         }\n         case (ty::ty_obj(_)) {\n             auto box_cell =\n@@ -2001,8 +1999,7 @@ fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                                   abi::tydesc_field_drop_glue, ti);\n             // Then free the body.\n             // FIXME: switch gc/non-gc on layer of the type.\n-\n-            rslt = trans_non_gc_free(cx_, b);\n+            trans_non_gc_free(cx_, b)\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell =\n@@ -2023,12 +2020,11 @@ fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                                   abi::tydesc_field_drop_glue, ti);\n             // Then free the body.\n             // FIXME: switch gc/non-gc on layer of the type.\n-\n-            rslt = trans_non_gc_free(cx, v);\n+            trans_non_gc_free(cx, v)\n         }\n-        case (_) { rslt = res(cx, C_nil()); }\n-    }\n-    rslt.bcx.build.RetVoid();\n+        case (_) { rslt(cx, C_nil()) }\n+    };\n+    rs.bcx.build.RetVoid();\n }\n \n fn maybe_free_ivec_heap_part(&@block_ctxt cx, ValueRef v0, ty::t unit_ty) ->\n@@ -2056,16 +2052,16 @@ fn maybe_free_ivec_heap_part(&@block_ctxt cx, ValueRef v0, ty::t unit_ty) ->\n         };\n     auto after_free_cx = trans_non_gc_free(maybe_on_heap_cx, heap_ptr).bcx;\n     after_free_cx.build.Br(next_cx.llbb);\n-    ret res(next_cx, C_nil());\n+    ret rslt(next_cx, C_nil());\n }\n \n fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n \n-    auto rslt;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_str) { rslt = decr_refcnt_maybe_free(cx, v0, v0, t); }\n-        case (ty::ty_vec(_)) { rslt = decr_refcnt_maybe_free(cx, v0, v0, t); }\n+    auto ccx = cx.fcx.lcx.ccx;\n+    auto rs = alt (ty::struct(ccx.tcx, t)) {\n+        case (ty::ty_str) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n+        case (ty::ty_vec(_)) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n         case (ty::ty_ivec(?tm)) {\n             auto v1;\n             if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, tm.ty)) {\n@@ -2074,35 +2070,31 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                 v1 = v0;\n             }\n \n-            rslt = iter_structural_ty(cx, v1, t, drop_ty);\n-            rslt = maybe_free_ivec_heap_part(rslt.bcx, v1, tm.ty);\n-        }\n-        case (ty::ty_box(_)) { rslt = decr_refcnt_maybe_free(cx, v0, v0, t); }\n-        case (ty::ty_port(_)) {\n-            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+            auto rslt = iter_structural_ty(cx, v1, t, drop_ty);\n+            maybe_free_ivec_heap_part(rslt.bcx, v1, tm.ty)\n         }\n-        case (ty::ty_chan(_)) {\n-            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n-        }\n-        case (ty::ty_task) { rslt = decr_refcnt_maybe_free(cx, v0, v0, t); }\n+        case (ty::ty_box(_)) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n+        case (ty::ty_port(_)) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n+        case (ty::ty_chan(_)) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n+        case (ty::ty_task) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n         case (ty::ty_obj(_)) {\n             auto box_cell =\n                 cx.build.GEP(v0, [C_int(0), C_int(abi::obj_field_box)]);\n-            rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n+            decr_refcnt_maybe_free(cx, box_cell, v0, t)\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell =\n                 cx.build.GEP(v0, [C_int(0), C_int(abi::fn_field_box)]);\n-            rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n+            decr_refcnt_maybe_free(cx, box_cell, v0, t)\n         }\n         case (_) {\n-            if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t) &&\n-                    ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n-                rslt = iter_structural_ty(cx, v0, t, bind drop_ty(_, _, _));\n-            } else { rslt = res(cx, C_nil()); }\n+            if (ty::type_has_pointers(ccx.tcx, t) &&\n+                    ty::type_is_structural(ccx.tcx, t)) {\n+                iter_structural_ty(cx, v0, t, bind drop_ty(_, _, _))\n+            } else { rslt(cx, C_nil()) }\n         }\n-    }\n-    rslt.bcx.build.RetVoid();\n+    };\n+    rs.bcx.build.RetVoid();\n }\n \n fn decr_refcnt_maybe_free(&@block_ctxt cx, ValueRef box_ptr_alias,\n@@ -2135,7 +2127,7 @@ fn decr_refcnt_maybe_free(&@block_ctxt cx, ValueRef box_ptr_alias,\n         next_cx.build.Phi(t_else, [v_else, v_else, v_else, free_res.val],\n                           [cx.llbb, load_rc_cx.llbb, rc_adj_cx.llbb,\n                            free_res.bcx.llbb]);\n-    ret res(next_cx, phi);\n+    ret rslt(next_cx, phi);\n }\n \n \n@@ -2228,7 +2220,7 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n                 scx.build.ICmp(lib::llvm::LLVMIntNE, llop,\n                                C_u8(abi::cmp_glue_op_lt));\n             scx.build.Store(result_if_equal, flag);\n-            r = res(scx, C_nil());\n+            r = rslt(scx, C_nil());\n         }\n         fn inner(@block_ctxt last_cx, bool load_inner, ValueRef flag,\n                  ValueRef llop, &@block_ctxt cx, ValueRef av0, ValueRef bv0,\n@@ -2261,7 +2253,7 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n             auto stop_r = call_cmp_glue(stop_cx, av, bv, t, llop);\n             stop_r.bcx.build.Store(stop_r.val, flag);\n             stop_r.bcx.build.Br(last_cx.llbb);\n-            ret res(cnt_cx, C_nil());\n+            ret rslt(cnt_cx, C_nil());\n         }\n         if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n             r =\n@@ -2413,7 +2405,7 @@ fn compare_numerical_values(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n     auto last_result =\n         last_cx.build.Phi(T_i1(), [eq_result, lt_result, le_result],\n                           [eq_cx.llbb, lt_cx.llbb, le_cx.llbb]);\n-    ret res(last_cx, last_result);\n+    ret rslt(last_cx, last_result);\n }\n \n \n@@ -2458,7 +2450,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         cx.build.CondBr(null_test, next_cx.llbb, inner_cx.llbb);\n         auto r = f(inner_cx, box_a_ptr, box_b_ptr, tbox);\n         r.bcx.build.Br(next_cx.llbb);\n-        ret res(next_cx, C_nil());\n+        ret rslt(next_cx, C_nil());\n     }\n     fn iter_ivec(@block_ctxt bcx, ValueRef av, ValueRef bv, ty::t unit_ty,\n                  &val_pair_and_ty_fn f) -> result {\n@@ -2469,9 +2461,9 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             ret f(bcx, av, bv, unit_ty);\n         }\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n-        auto rslt = size_of(bcx, unit_ty);\n-        auto unit_sz = rslt.val;\n-        bcx = rslt.bcx;\n+        auto rs = size_of(bcx, unit_ty);\n+        auto unit_sz = rs.val;\n+        bcx = rs.bcx;\n         auto a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n         auto a_len = a_len_and_data._0;\n         auto a_elem = a_len_and_data._1;\n@@ -2507,21 +2499,20 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         loop_header_cx.build.CondBr(not_yet_at_end, loop_body_cx.llbb,\n                                     next_cx.llbb);\n \n-        rslt = f(loop_body_cx,\n-            load_if_immediate(loop_body_cx, dest_elem, unit_ty),\n-            load_if_immediate(loop_body_cx, src_elem, unit_ty), unit_ty);\n+        rs = f(loop_body_cx,\n+               load_if_immediate(loop_body_cx, dest_elem, unit_ty),\n+               load_if_immediate(loop_body_cx, src_elem, unit_ty), unit_ty);\n \n-        loop_body_cx = rslt.bcx;\n+        loop_body_cx = rs.bcx;\n         loop_body_cx.build.Store(loop_body_cx.build.InBoundsGEP(dest_elem,\n             [C_int(1)]), dest_elem_ptr);\n         loop_body_cx.build.Store(loop_body_cx.build.InBoundsGEP(src_elem,\n             [C_int(1)]), src_elem_ptr);\n         loop_body_cx.build.Br(loop_header_cx.llbb);\n \n-        ret res(next_cx, C_nil());\n+        ret rslt(next_cx, C_nil());\n     }\n-\n-    let result r = res(cx, C_nil());\n+    let result r = rslt(cx, C_nil());\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n         case (ty::ty_tup(?args)) {\n             let int i = 0;\n@@ -2612,9 +2603,9 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                                 auto llfld_b =\n                                     load_if_immediate(variant_cx, llfldp_b,\n                                                       ty_subst);\n-                                auto res =\n+                                rslt =\n                                     f(variant_cx, llfld_a, llfld_b, ty_subst);\n-                                variant_cx = res.bcx;\n+                                variant_cx = rslt.bcx;\n                                 j += 1;\n                             }\n                         }\n@@ -2627,7 +2618,7 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                 }\n                 i += 1u;\n             }\n-            ret res(next_cx, C_nil());\n+            ret rslt(next_cx, C_nil());\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell_a =\n@@ -2691,7 +2682,7 @@ fn iter_sequence_raw(@block_ctxt cx, ValueRef dst,\n     body_cx.build.Br(cond_cx.llbb);\n     cond_cx.build.AddIncomingToPhi(dst_curr, [dst_next], [body_cx.llbb]);\n     cond_cx.build.AddIncomingToPhi(src_curr, [src_next], [body_cx.llbb]);\n-    ret res(next_cx, C_nil());\n+    ret rslt(next_cx, C_nil());\n }\n \n fn iter_sequence_inner(&@block_ctxt cx, ValueRef src,\n@@ -2892,7 +2883,7 @@ fn call_tydesc_glue(&@block_ctxt cx, ValueRef v, &ty::t t, int field) ->\n     auto td = get_tydesc(cx, t, false, ti);\n     call_tydesc_glue_full(td.bcx, spill_if_immediate(td.bcx, v, t), td.val,\n                           field, ti);\n-    ret res(td.bcx, C_nil());\n+    ret rslt(td.bcx, C_nil());\n }\n \n fn maybe_call_dtor(&@block_ctxt cx, ValueRef v) -> @block_ctxt {\n@@ -2941,14 +2932,14 @@ fn call_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n         [llcmpresultptr, r.bcx.fcx.lltaskptr, C_null(T_ptr(T_nil())),\n          lltydescs, llrawlhsptr, llrawrhsptr, llop];\n     r.bcx.build.Call(llfn, llargs);\n-    ret res(r.bcx, r.bcx.build.Load(llcmpresultptr));\n+    ret rslt(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n \n fn take_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n     if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n-    ret res(cx, C_nil());\n+    ret rslt(cx, C_nil());\n }\n \n fn drop_slot(&@block_ctxt cx, ValueRef slot, &ty::t t) -> result {\n@@ -2964,14 +2955,14 @@ fn drop_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n     if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n-    ret res(cx, C_nil());\n+    ret rslt(cx, C_nil());\n }\n \n fn free_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n     if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n-    ret res(cx, C_nil());\n+    ret rslt(cx, C_nil());\n }\n \n fn call_memmove(&@block_ctxt cx, ValueRef dst, ValueRef src,\n@@ -2989,7 +2980,7 @@ fn call_memmove(&@block_ctxt cx, ValueRef dst, ValueRef src,\n     auto size = cx.build.IntCast(n_bytes, T_i32());\n     auto align = C_int(0);\n     auto volatile = C_bool(false);\n-    ret res(cx,\n+    ret rslt(cx,\n             cx.build.Call(memmove,\n                           [dst_ptr, src_ptr, size, align, volatile]));\n }\n@@ -3008,7 +2999,7 @@ fn call_bzero(&@block_ctxt cx, ValueRef dst, ValueRef n_bytes,\n             cx.build.IntCast(align_bytes, T_i32())\n         } else { cx.build.IntCast(C_int(0), T_i32()) };\n     auto volatile = C_bool(false);\n-    ret res(cx,\n+    ret rslt(cx,\n             cx.build.Call(memset,\n                           [dst_ptr, C_u8(0u), size, align, volatile]));\n }\n@@ -3018,7 +3009,7 @@ fn memmove_ty(&@block_ctxt cx, ValueRef dst, ValueRef src, &ty::t t) ->\n     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(cx, t);\n         ret call_memmove(llsz.bcx, dst, src, llsz.val);\n-    } else { ret res(cx, cx.build.Store(cx.build.Load(src), dst)); }\n+    } else { ret rslt(cx, cx.build.Store(cx.build.Load(src), dst)); }\n }\n \n // Duplicates the heap-owned memory owned by a value of the given type.\n@@ -3036,7 +3027,7 @@ fn duplicate_heap_parts(&@block_ctxt cx, ValueRef vptr, ty::t typ) -> result {\n             ret iter_structural_ty(cx, vptr, typ, duplicate_heap_parts);\n         }\n \n-        ret res(cx, C_nil());\n+        ret rslt(cx, C_nil());\n       }\n     }\n }\n@@ -3047,16 +3038,16 @@ fn copy_val(&@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n             &ty::t t) -> result {\n     if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n             ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, cx.build.Store(src, dst));\n+        ret rslt(cx, cx.build.Store(src, dst));\n     } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t) ||\n                    ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, C_nil());\n+        ret rslt(cx, C_nil());\n     } else if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         auto r = take_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, r.bcx.build.Load(dst), t);\n         }\n-        ret res(r.bcx, r.bcx.build.Store(src, dst));\n+        ret rslt(r.bcx, r.bcx.build.Store(src, dst));\n     } else if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t) ||\n                    ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto r = take_ty(cx, src, t);\n@@ -3081,15 +3072,15 @@ fn move_val(@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n             &ty::t t) -> result {\n     if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n             ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, cx.build.Store(src, dst));\n+        ret rslt(cx, cx.build.Store(src, dst));\n     } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t) ||\n                    ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret res(cx, C_nil());\n+        ret rslt(cx, C_nil());\n     } else if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         if (action == DROP_EXISTING) {\n             cx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n         }\n-        auto r = res(cx, cx.build.Store(cx.build.Load(src), dst));\n+        auto r = rslt(cx, cx.build.Store(cx.build.Load(src), dst));\n         ret zero_alloca(r.bcx, src, t);\n     } else if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t) ||\n                    ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -3161,15 +3152,15 @@ fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n             sub =\n                 autoderef(sub.bcx, sub.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n-            ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n+            ret rslt(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast::neg) {\n             sub =\n                 autoderef(sub.bcx, sub.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             if (ty::struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty::ty_float) {\n-                ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n-            } else { ret res(sub.bcx, sub.bcx.build.Neg(sub.val)); }\n+                ret rslt(sub.bcx, sub.bcx.build.FNeg(sub.val));\n+            } else { ret rslt(sub.bcx, sub.bcx.build.Neg(sub.val)); }\n         }\n         case (ast::box(_)) {\n             auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n@@ -3197,7 +3188,7 @@ fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n             sub = copy_val(sub.bcx, INIT, body, e_val, e_ty);\n-            ret res(sub.bcx, box);\n+            ret rslt(sub.bcx, box);\n         }\n         case (ast::deref) {\n             cx.fcx.lcx.ccx.sess.bug(\"deref expressions should have been \" +\n@@ -3231,17 +3222,17 @@ fn trans_compare(&@block_ctxt cx0, ast::binop op, &ty::t t0, ValueRef lhs0,\n         case (ast::ge) { llop = C_u8(abi::cmp_glue_op_lt); }\n         case (ast::gt) { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n-    auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n+    auto rs = call_cmp_glue(cx, lhs, rhs, t, llop);\n \n     // Invert the result if necessary.\n     // FIXME: Use or-patterns when we have them.\n     alt (op) {\n-        case (ast::eq) { ret res(rslt.bcx, rslt.val); }\n-        case (ast::lt) { ret res(rslt.bcx, rslt.val); }\n-        case (ast::le) { ret res(rslt.bcx, rslt.val); }\n-        case (ast::ne) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n-        case (ast::ge) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n-        case (ast::gt) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n+        case (ast::eq) { ret rslt(rs.bcx, rs.val); }\n+        case (ast::lt) { ret rslt(rs.bcx, rs.val); }\n+        case (ast::le) { ret rslt(rs.bcx, rs.val); }\n+        case (ast::ne) { ret rslt(rs.bcx, rs.bcx.build.Not(rs.val)); }\n+        case (ast::ge) { ret rslt(rs.bcx, rs.bcx.build.Not(rs.val)); }\n+        case (ast::gt) { ret rslt(rs.bcx, rs.bcx.build.Not(rs.val)); }\n     }\n }\n \n@@ -3265,7 +3256,7 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n     bcx = llelt_tydesc.bcx;\n     auto dst = bcx.build.PointerCast(lhs, T_ptr(T_opaque_vec_ptr()));\n     auto src = bcx.build.PointerCast(rhs, T_opaque_vec_ptr());\n-    ret res(bcx,\n+    ret rslt(bcx,\n             bcx.build.Call(cx.fcx.lcx.ccx.upcalls.vec_append,\n                            [cx.fcx.lltaskptr, llvec_tydesc.val,\n                             llelt_tydesc.val, dst, src, skip_null]));\n@@ -3505,7 +3496,7 @@ mod ivec {\n                                stack_data_no_spill, heap_data_spill],\n                               [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n                                stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n-        ret res(next_cx, data_ptr);\n+        ret rslt(next_cx, data_ptr);\n     }\n     fn trans_append(&@block_ctxt cx, &ty::t t, ValueRef orig_lhs,\n                     ValueRef orig_rhs) -> result {\n@@ -3531,31 +3522,31 @@ mod ivec {\n             }\n         }\n \n-        auto rslt = size_of(cx, unit_ty);\n-        auto bcx = rslt.bcx;\n-        auto unit_sz = rslt.val;\n+        auto rs = size_of(cx, unit_ty);\n+        auto bcx = rs.bcx;\n+        auto unit_sz = rs.val;\n \n         // Gather the various type descriptors we'll need.\n \n         // FIXME (issue #511): This is needed to prevent a leak.\n         auto no_tydesc_info = none;\n \n-        rslt = get_tydesc(bcx, t, false, no_tydesc_info);\n-        auto vec_tydesc = rslt.val;\n-        bcx = rslt.bcx;\n-        rslt = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n-        auto unit_tydesc = rslt.val;\n-        bcx = rslt.bcx;\n+        rs = get_tydesc(bcx, t, false, no_tydesc_info);\n+        auto vec_tydesc = rs.val;\n+        bcx = rs.bcx;\n+        rs = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n+        auto unit_tydesc = rs.val;\n+        bcx = rs.bcx;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n         auto rhs_len = rhs_len_and_data._0;\n         auto rhs_data = rhs_len_and_data._1;\n         bcx = rhs_len_and_data._2;\n-        rslt = reserve_space(bcx, llunitty, lhs, rhs_len);\n-        auto lhs_data = rslt.val;\n-        bcx = rslt.bcx;\n+        rs = reserve_space(bcx, llunitty, lhs, rhs_len);\n+        auto lhs_data = rs.val;\n+        bcx = rs.bcx;\n         // Work out the end pointer.\n \n         auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n@@ -3583,9 +3574,9 @@ mod ivec {\n         auto copy_src = load_if_immediate(copy_loop_body_cx, copy_src_ptr,\n                                           unit_ty);\n \n-        rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src,\n-                        unit_ty);\n-        auto post_copy_cx = rslt.bcx;\n+        rs = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src,\n+                      unit_ty);\n+        auto post_copy_cx = rs.bcx;\n         // Increment both pointers.\n \n         if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n@@ -3602,7 +3593,7 @@ mod ivec {\n         }\n \n         post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n-        ret res(next_cx, C_nil());\n+        ret rslt(next_cx, C_nil());\n     }\n \n     type alloc_result = rec(@block_ctxt bcx,\n@@ -3740,9 +3731,9 @@ mod ivec {\n                             heap_cx.build.InBoundsGEP(stub_ptr_heap,\n                                                       stub_a));\n         auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n-        auto rslt = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n-        auto heap_part = rslt.val;\n-        heap_cx = rslt.bcx;\n+        auto rs = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n+        auto heap_part = rs.val;\n+        heap_cx = rs.bcx;\n         heap_cx.build.Store(heap_part,\n                             heap_cx.build.InBoundsGEP(stub_ptr_heap,\n                                                       stub_p));\n@@ -3790,10 +3781,10 @@ mod ivec {\n                                  rhs_copy_cx.llbb);\n         auto dest_ptr_lhs_copy = lhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         auto lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n-        rslt =\n+        rs =\n             copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy, lhs_val,\n                      unit_ty);\n-        lhs_do_copy_cx = rslt.bcx;\n+        lhs_do_copy_cx = rs.bcx;\n         {\n             auto d = lhs_do_copy_cx.build.InBoundsGEP(dest_ptr_lhs_copy,\n                                                       [C_int(1)]);\n@@ -3814,10 +3805,10 @@ mod ivec {\n                                  next_cx.llbb);\n         auto dest_ptr_rhs_copy = rhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         auto rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n-        rslt =\n+        rs =\n             copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy, rhs_val,\n                      unit_ty);\n-        rhs_do_copy_cx = rslt.bcx;\n+        rhs_do_copy_cx = rs.bcx;\n         {\n             auto d = rhs_do_copy_cx.build.InBoundsGEP(dest_ptr_rhs_copy,\n                                                       [C_int(1)]);\n@@ -3829,7 +3820,7 @@ mod ivec {\n         rhs_do_copy_cx.build.Br(rhs_copy_cx.llbb);\n         // Finally done!\n \n-        ret res(next_cx, llvecptr);\n+        ret rslt(next_cx, llvecptr);\n     }\n \n     // NB: This does *not* adjust reference counts. The caller must have done\n@@ -3877,18 +3868,18 @@ mod ivec {\n \n         auto heap_part_sz = on_heap_cx.build.Add(alen,\n             llsize_of(T_opaque_ivec_heap_part()));\n-        auto rslt = trans_raw_malloc(on_heap_cx, T_ptr(llheappartty),\n-                                     heap_part_sz);\n-        on_heap_cx = rslt.bcx;\n-        auto new_heap_ptr = rslt.val;\n+        auto rs = trans_raw_malloc(on_heap_cx, T_ptr(llheappartty),\n+                                   heap_part_sz);\n+        on_heap_cx = rs.bcx;\n+        auto new_heap_ptr = rs.val;\n \n-        rslt = call_memmove(on_heap_cx, new_heap_ptr, heap_ptr, heap_part_sz);\n-        on_heap_cx = rslt.bcx;\n+        rs = call_memmove(on_heap_cx, new_heap_ptr, heap_ptr, heap_part_sz);\n+        on_heap_cx = rs.bcx;\n \n         on_heap_cx.build.Store(new_heap_ptr, heap_ptr_ptr);\n         on_heap_cx.build.Br(next_cx.llbb);\n \n-        ret res(next_cx, C_nil());\n+        ret rslt(next_cx, C_nil());\n     }\n }\n \n@@ -3900,7 +3891,7 @@ fn trans_vec_add(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n     tmp = load_if_immediate(bcx, tmp, t);\n     find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, tmp, t))];\n-    ret res(bcx, tmp);\n+    ret rslt(bcx, tmp);\n }\n \n fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n@@ -3919,37 +3910,37 @@ fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n                 ret trans_vec_add(cx, intype, lhs, rhs);\n             }\n             if (is_float) {\n-                ret res(cx, cx.build.FAdd(lhs, rhs));\n-            } else { ret res(cx, cx.build.Add(lhs, rhs)); }\n+                ret rslt(cx, cx.build.FAdd(lhs, rhs));\n+            } else { ret rslt(cx, cx.build.Add(lhs, rhs)); }\n         }\n         case (ast::sub) {\n             if (is_float) {\n-                ret res(cx, cx.build.FSub(lhs, rhs));\n-            } else { ret res(cx, cx.build.Sub(lhs, rhs)); }\n+                ret rslt(cx, cx.build.FSub(lhs, rhs));\n+            } else { ret rslt(cx, cx.build.Sub(lhs, rhs)); }\n         }\n         case (ast::mul) {\n             if (is_float) {\n-                ret res(cx, cx.build.FMul(lhs, rhs));\n-            } else { ret res(cx, cx.build.Mul(lhs, rhs)); }\n+                ret rslt(cx, cx.build.FMul(lhs, rhs));\n+            } else { ret rslt(cx, cx.build.Mul(lhs, rhs)); }\n         }\n         case (ast::div) {\n-            if (is_float) { ret res(cx, cx.build.FDiv(lhs, rhs)); }\n+            if (is_float) { ret rslt(cx, cx.build.FDiv(lhs, rhs)); }\n             if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx, intype)) {\n-                ret res(cx, cx.build.SDiv(lhs, rhs));\n-            } else { ret res(cx, cx.build.UDiv(lhs, rhs)); }\n+                ret rslt(cx, cx.build.SDiv(lhs, rhs));\n+            } else { ret rslt(cx, cx.build.UDiv(lhs, rhs)); }\n         }\n         case (ast::rem) {\n-            if (is_float) { ret res(cx, cx.build.FRem(lhs, rhs)); }\n+            if (is_float) { ret rslt(cx, cx.build.FRem(lhs, rhs)); }\n             if (ty::type_is_signed(cx.fcx.lcx.ccx.tcx, intype)) {\n-                ret res(cx, cx.build.SRem(lhs, rhs));\n-            } else { ret res(cx, cx.build.URem(lhs, rhs)); }\n-        }\n-        case (ast::bitor) { ret res(cx, cx.build.Or(lhs, rhs)); }\n-        case (ast::bitand) { ret res(cx, cx.build.And(lhs, rhs)); }\n-        case (ast::bitxor) { ret res(cx, cx.build.Xor(lhs, rhs)); }\n-        case (ast::lsl) { ret res(cx, cx.build.Shl(lhs, rhs)); }\n-        case (ast::lsr) { ret res(cx, cx.build.LShr(lhs, rhs)); }\n-        case (ast::asr) { ret res(cx, cx.build.AShr(lhs, rhs)); }\n+                ret rslt(cx, cx.build.SRem(lhs, rhs));\n+            } else { ret rslt(cx, cx.build.URem(lhs, rhs)); }\n+        }\n+        case (ast::bitor) { ret rslt(cx, cx.build.Or(lhs, rhs)); }\n+        case (ast::bitand) { ret rslt(cx, cx.build.And(lhs, rhs)); }\n+        case (ast::bitxor) { ret rslt(cx, cx.build.Xor(lhs, rhs)); }\n+        case (ast::lsl) { ret rslt(cx, cx.build.Shl(lhs, rhs)); }\n+        case (ast::lsr) { ret rslt(cx, cx.build.LShr(lhs, rhs)); }\n+        case (ast::asr) { ret rslt(cx, cx.build.AShr(lhs, rhs)); }\n         case (_) { ret trans_compare(cx, op, intype, lhs, rhs); }\n     }\n }\n@@ -3978,7 +3969,7 @@ fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n             case (_) { break; }\n         }\n     }\n-    ret res(cx, v1);\n+    ret rslt(cx, v1);\n }\n \n fn autoderefed_ty(&@crate_ctxt ccx, &ty::t t) -> ty::t {\n@@ -4010,7 +4001,7 @@ fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n                 autoderef(rhs_res.bcx, rhs_res.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n-            auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n+            auto lhs_false_res = rslt(lhs_false_cx, C_bool(false));\n             // The following line ensures that any cleanups for rhs\n             // are done within the block for rhs. This is necessary\n             // because and/or are lazy. So the rhs may never execute,\n@@ -4035,7 +4026,7 @@ fn trans_binary(&@block_ctxt cx, ast::binop op, &@ast::expr a, &@ast::expr b)\n                 autoderef(rhs_res.bcx, rhs_res.val,\n                           ty::expr_ty(cx.fcx.lcx.ccx.tcx, b));\n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n-            auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n+            auto lhs_true_res = rslt(lhs_true_cx, C_bool(true));\n             // see the and case for an explanation\n \n             auto rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n@@ -4088,7 +4079,7 @@ fn join_results(&@block_ctxt parent_cx, TypeRef t, &vec[result] ins) ->\n     auto join_cx = new_sub_block_ctxt(parent_cx, \"join\");\n     for (result r in live) { r.bcx.build.Br(join_cx.llbb); }\n     auto phi = join_cx.build.Phi(t, vals, bbs);\n-    ret res(join_cx, phi);\n+    ret rslt(join_cx, phi);\n }\n \n fn join_branches(&@block_ctxt parent_cx, &vec[result] ins) -> @block_ctxt {\n@@ -4129,10 +4120,10 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n                 }\n             }\n         }\n-        case (_) { res(else_cx, C_nil()) }\n+        case (_) { rslt(else_cx, C_nil()) }\n     };\n     cond_res.bcx.build.CondBr(cond_res.val, then_cx.llbb, else_cx.llbb);\n-    ret res(join_branches(cx, [then_res, else_res]), C_nil());\n+    ret rslt(join_branches(cx, [then_res, else_res]), C_nil());\n }\n \n fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n@@ -4149,7 +4140,7 @@ fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         scope_cx.cleanups += [clean(bind drop_slot(_, local_res.val, t))];\n         bcx = trans_block(bcx, body, return).bcx;\n         bcx.build.Br(next_cx.llbb);\n-        ret res(next_cx, C_nil());\n+        ret rslt(next_cx, C_nil());\n     }\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     auto seq_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, seq);\n@@ -4158,7 +4149,7 @@ fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                       bind inner(_, local, _, _, body, next_cx));\n     it.bcx.build.Br(next_cx.llbb);\n-    ret res(next_cx, it.val);\n+    ret rslt(next_cx, it.val);\n }\n \n \n@@ -4418,7 +4409,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n             r =\n                 trans_call(cx, f, some[ValueRef](cx.build.Load(pair)), args,\n                            seq.id);\n-            ret res(r.bcx, C_nil());\n+            ret rslt(r.bcx, C_nil());\n         }\n     }\n }\n@@ -4436,7 +4427,7 @@ fn trans_while(&@block_ctxt cx, &@ast::expr cond, &ast::block body) ->\n     auto cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n     cond_bcx.build.CondBr(cond_res.val, body_cx.llbb, next_cx.llbb);\n     cx.build.Br(cond_cx.llbb);\n-    ret res(next_cx, C_nil());\n+    ret rslt(next_cx, C_nil());\n }\n \n fn trans_do_while(&@block_ctxt cx, &ast::block body, &@ast::expr cond) ->\n@@ -4449,23 +4440,23 @@ fn trans_do_while(&@block_ctxt cx, &ast::block body, &@ast::expr cond) ->\n     auto cond_res = trans_expr(body_res.bcx, cond);\n     cond_res.bcx.build.CondBr(cond_res.val, body_cx.llbb, next_cx.llbb);\n     cx.build.Br(body_cx.llbb);\n-    ret res(next_cx, body_res.val);\n+    ret rslt(next_cx, body_res.val);\n }\n \n \n // Pattern matching translation\n fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                    &@block_ctxt next_cx) -> result {\n     alt (pat.node) {\n-        case (ast::pat_wild(_)) { ret res(cx, llval); }\n-        case (ast::pat_bind(_, _)) { ret res(cx, llval); }\n+        case (ast::pat_wild(_)) { ret rslt(cx, llval); }\n+        case (ast::pat_bind(_, _)) { ret rslt(cx, llval); }\n         case (ast::pat_lit(?lt, ?id)) {\n             auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, id);\n             auto lltype = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n             auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n             auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n             lleq.bcx.build.CondBr(lleq.val, matched_cx.llbb, next_cx.llbb);\n-            ret res(matched_cx, llval);\n+            ret rslt(matched_cx, llval);\n         }\n         case (ast::pat_tag(?ident, ?subpats, ?id)) {\n             auto lltagptr =\n@@ -4513,20 +4504,20 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                     i += 1;\n                 }\n             }\n-            ret res(matched_cx, llval);\n+            ret rslt(matched_cx, llval);\n         }\n     }\n }\n \n fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                      bool bind_alias) -> result {\n     alt (pat.node) {\n-        case (ast::pat_wild(_)) { ret res(cx, llval); }\n-        case (ast::pat_lit(_, _)) { ret res(cx, llval); }\n+        case (ast::pat_wild(_)) { ret rslt(cx, llval); }\n+        case (ast::pat_lit(_, _)) { ret rslt(cx, llval); }\n         case (ast::pat_bind(?name, ?id)) {\n             if (bind_alias) {\n                 cx.fcx.lllocals.insert(id, llval);\n-                ret res(cx, llval);\n+                ret rslt(cx, llval);\n             } else {\n                 auto t = node_id_type(cx.fcx.lcx.ccx, id);\n                 auto rslt = alloc_ty(cx, t);\n@@ -4539,7 +4530,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             }\n         }\n         case (ast::pat_tag(_, ?subpats, ?id)) {\n-            if (vec::len[@ast::pat](subpats) == 0u) { ret res(cx, llval); }\n+            if (vec::len[@ast::pat](subpats) == 0u) { ret rslt(cx, llval); }\n             // Get the appropriate variant for this tag.\n \n             auto vdef =\n@@ -4562,7 +4553,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                 this_cx = subpat_res.bcx;\n                 i += 1;\n             }\n-            ret res(this_cx, llval);\n+            ret rslt(this_cx, llval);\n         }\n     }\n }\n@@ -4588,7 +4579,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n     auto default_res =\n         trans_fail(default_cx, some[common::span](expr.span),\n                    \"non-exhaustive match failure\");\n-    ret res(join_branches(cx, arm_results), C_nil());\n+    ret rslt(join_branches(cx, arm_results), C_nil());\n }\n \n type generic_info =\n@@ -4604,15 +4595,15 @@ type lval_result =\n         option::t[ty::t] method_ty);\n \n fn lval_mem(&@block_ctxt cx, ValueRef val) -> lval_result {\n-    ret rec(res=res(cx, val),\n+    ret rec(res=rslt(cx, val),\n             is_mem=true,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n             method_ty=none[ty::t]);\n }\n \n fn lval_val(&@block_ctxt cx, ValueRef val) -> lval_result {\n-    ret rec(res=res(cx, val),\n+    ret rec(res=rslt(cx, val),\n             is_mem=false,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n@@ -4658,9 +4649,8 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n             vec::push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec(item_type=tpt._1, static_tis=tis, tydescs=tydescs);\n-        lv =\n-            rec(res=res(bcx, lv.res.val), generic=some[generic_info](gen)\n-                with lv);\n+        lv = rec(res=rslt(bcx, lv.res.val), generic=some[generic_info](gen)\n+                 with lv);\n     }\n     ret lv;\n }\n@@ -4958,15 +4948,15 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n         if (ty::type_is_native(cx.fcx.lcx.ccx.tcx,\n                                ty::expr_ty(cx.fcx.lcx.ccx.tcx, e))) {\n             e_res =\n-                res(e_res.bcx,\n+                rslt(e_res.bcx,\n                     e_res.bcx.build.PtrToInt(e_res.val, lldsttype));\n         } else if (ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n             e_res =\n-                res(e_res.bcx,\n+                rslt(e_res.bcx,\n                     e_res.bcx.build.IntToPtr(e_res.val, lldsttype));\n         } else {\n             e_res =\n-                res(e_res.bcx,\n+                rslt(e_res.bcx,\n                     int_cast(e_res.bcx, lldsttype, llsrctype, e_res.val,\n                              ty::type_is_signed(cx.fcx.lcx.ccx.tcx, t)));\n         }\n@@ -5251,7 +5241,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                             pair_box);\n             find_scope_cx(cx).cleanups +=\n                 [clean(bind drop_slot(_, pair_v, pair_ty))];\n-            ret res(bcx, pair_v);\n+            ret rslt(bcx, pair_v);\n         }\n     }\n }\n@@ -5307,7 +5297,7 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n         // we are now passing it as an arg, so need to load it.\n         val = bcx.build.Load(val);\n     }\n-    ret res(bcx, val);\n+    ret rslt(bcx, val);\n }\n \n \n@@ -5470,7 +5460,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n \n         }\n     }\n-    ret res(bcx, retval);\n+    ret rslt(bcx, retval);\n }\n \n fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n@@ -5491,7 +5481,7 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n         bcx = copy_val(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n-    ret res(bcx, tup_val);\n+    ret rslt(bcx, tup_val);\n }\n \n fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n@@ -5549,7 +5539,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n     }\n     auto fill = bcx.build.GEP(vec_val, [C_int(0), C_int(abi::vec_elt_fill)]);\n     bcx.build.Store(data_sz, fill);\n-    ret res(bcx, vec_val);\n+    ret rslt(bcx, vec_val);\n }\n \n \n@@ -5644,7 +5634,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n         bcx = copy_val(bcx, INIT, lleltptr, llsrc, unit_ty).bcx;\n         i += 1u;\n     }\n-    ret res(bcx, llvecptr);\n+    ret rslt(bcx, llvecptr);\n }\n \n fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n@@ -5674,7 +5664,7 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n         auto dst_res = GEP_tup_like(bcx, t, rec_val, [0, i]);\n         bcx = dst_res.bcx;\n         auto expr_provided = false;\n-        auto src_res = res(bcx, C_nil());\n+        auto src_res = rslt(bcx, C_nil());\n         for (ast::field f in fields) {\n             if (str::eq(f.node.ident, tf.ident)) {\n                 expr_provided = true;\n@@ -5684,13 +5674,13 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n         if (!expr_provided) {\n             src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n             src_res =\n-                res(src_res.bcx, load_if_immediate(bcx, src_res.val, e_ty));\n+                rslt(src_res.bcx, load_if_immediate(bcx, src_res.val, e_ty));\n         }\n         bcx = src_res.bcx;\n         bcx = copy_val(bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n-    ret res(bcx, rec_val);\n+    ret rslt(bcx, rec_val);\n }\n \n fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n@@ -5703,7 +5693,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n \n     alt (e.node) {\n         case (ast::expr_lit(?lit)) {\n-            ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, e.id));\n+            ret rslt(cx, trans_lit(cx.fcx.lcx.ccx, *lit, e.id));\n         }\n         case (ast::expr_unary(?op, ?x)) {\n             if (op != ast::deref) { ret trans_unary(cx, op, x, e.id); }\n@@ -5751,7 +5741,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto s = mangle_internal_name_by_path(ccx, sub_cx.path);\n             auto llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n             trans_fn(sub_cx, e.span, f, llfn, none, [], e.id);\n-            ret res(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n+            ret rslt(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n         }\n         case (ast::expr_block(?blk)) {\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n@@ -5761,7 +5751,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                                 output);\n             cx.build.Br(sub_cx.llbb);\n             sub.bcx.build.Br(next_cx.llbb);\n-            ret res(next_cx, sub.val);\n+            ret rslt(next_cx, sub.val);\n         }\n         case (ast::expr_move(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n@@ -5775,7 +5765,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto move_res =\n                 move_val(rhs_res.res.bcx, DROP_EXISTING, lhs_res.res.val,\n                          rhs_res.res.val, t);\n-            ret res(move_res.bcx, C_nil());\n+            ret rslt(move_res.bcx, C_nil());\n         }\n         case (ast::expr_assign(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n@@ -5789,7 +5779,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto copy_res =\n                 copy_val(rhs_res.bcx, DROP_EXISTING, lhs_res.res.val,\n                          rhs_res.val, t);\n-            ret res(copy_res.bcx, C_nil());\n+            ret rslt(copy_res.bcx, C_nil());\n         }\n         case (ast::expr_swap(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n@@ -5808,7 +5798,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n                            t);\n             auto move3_res =\n                 memmove_ty(move2_res.bcx, rhs_res.res.val, tmp_res.val, t);\n-            ret res(move3_res.bcx, C_nil());\n+            ret rslt(move3_res.bcx, C_nil());\n         }\n         case (ast::expr_assign_op(?op, ?dst, ?src)) {\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n@@ -5838,7 +5828,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n \n             auto copy_res =\n                 copy_val(v.bcx, DROP_EXISTING, lhs_res.res.val, v.val, t);\n-            ret res(copy_res.bcx, C_nil());\n+            ret rslt(copy_res.bcx, C_nil());\n         }\n         case (ast::expr_bind(?f, ?args)) {\n             ret trans_bind(cx, f, args, e.id);\n@@ -5905,7 +5895,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n \n     auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     auto sub = trans_lval(cx, e);\n-    ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n+    ret rslt(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n \n fn with_out_method(fn(&out_method) -> result  work, @block_ctxt cx,\n@@ -5926,7 +5916,8 @@ fn with_out_method(fn(&out_method) -> result  work, @block_ctxt cx,\n         auto cleanup = bind drop_hoisted_ty(_, res_alloca.val, tp);\n         find_scope_cx(cx).cleanups += [clean(cleanup)];\n         auto done = work(save_in(res_alloca.val));\n-        done = res(done.bcx, load_if_immediate(done.bcx, res_alloca.val, tp));\n+        done = rslt(done.bcx,\n+                    load_if_immediate(done.bcx, res_alloca.val, tp));\n         ret done;\n     }\n }\n@@ -6036,7 +6027,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     }\n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     log_bcx.build.Br(after_cx.llbb);\n-    ret res(after_cx, C_nil());\n+    ret rslt(after_cx, C_nil());\n }\n \n fn trans_check_expr(&@block_ctxt cx, &@ast::expr e, &str s) -> result {\n@@ -6046,7 +6037,7 @@ fn trans_check_expr(&@block_ctxt cx, &@ast::expr e, &str s) -> result {\n     auto fail_res = trans_fail(fail_cx, some[common::span](e.span), expr_str);\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     cond_res.bcx.build.CondBr(cond_res.val, next_cx.llbb, fail_cx.llbb);\n-    ret res(next_cx, C_nil());\n+    ret rslt(next_cx, C_nil());\n }\n \n fn trans_fail(&@block_ctxt cx, &option::t[common::span] sp_opt, &str fail_str)\n@@ -6070,7 +6061,7 @@ fn trans_fail(&@block_ctxt cx, &option::t[common::span] sp_opt, &str fail_str)\n     auto args = [cx.fcx.lltaskptr, V_fail_str, V_filename, C_int(V_line)];\n     cx.build.Call(cx.fcx.lcx.ccx.upcalls._fail, args);\n     cx.build.Unreachable();\n-    ret res(cx, C_nil());\n+    ret rslt(cx, C_nil());\n }\n \n fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n@@ -6102,7 +6093,7 @@ fn trans_put(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n             llargs += [r.val];\n         }\n     }\n-    ret res(bcx, bcx.build.FastCall(llcallee, llargs));\n+    ret rslt(bcx, bcx.build.FastCall(llcallee, llargs));\n }\n \n fn trans_break_cont(&span sp, &@block_ctxt cx, bool to_end) -> result {\n@@ -6124,7 +6115,7 @@ fn trans_break_cont(&span sp, &@block_ctxt cx, bool to_end) -> result {\n                         case (_) { bcx.build.Br(cleanup_cx.llbb); }\n                     }\n                 }\n-                ret res(new_sub_block_ctxt(bcx, \"break_cont.unreachable\"),\n+                ret rslt(new_sub_block_ctxt(bcx, \"break_cont.unreachable\"),\n                         C_nil());\n             }\n             case (_) {\n@@ -6183,7 +6174,7 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n         }\n     }\n     bcx.build.RetVoid();\n-    ret res(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n+    ret rslt(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n }\n \n fn trans_be(&@block_ctxt cx, &@ast::expr e) -> result {\n@@ -6214,7 +6205,7 @@ fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n     auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n     auto dropref = clean(bind drop_ty(_, port_val, t));\n     find_scope_cx(bcx).cleanups += [dropref];\n-    ret res(bcx, port_val);\n+    ret rslt(bcx, port_val);\n }\n \n fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n@@ -6230,7 +6221,7 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n     auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n     find_scope_cx(bcx).cleanups += [dropref];\n-    ret res(bcx, chan_val);\n+    ret rslt(bcx, chan_val);\n }\n \n fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n@@ -6325,7 +6316,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto dropref = clean(bind drop_ty(_, new_task, task_ty));\n     find_scope_cx(bcx).cleanups += [dropref];\n-    ret res(bcx, new_task);\n+    ret rslt(bcx, new_task);\n }\n \n fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n@@ -6374,7 +6365,7 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     finish_fn(fcx, fbcx.llbb);\n     // TODO: make sure we clean up everything we need to.\n \n-    ret res(cx, llfndecl);\n+    ret rslt(cx, llfndecl);\n }\n \n // Does a deep copy of a value. This is needed for passing arguments to child\n@@ -6390,10 +6381,10 @@ fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n \n     auto tcx = bcx.fcx.lcx.ccx.tcx;\n     if(ty::type_is_scalar(tcx, t)) {\n-        ret res(bcx, v);\n+        ret rslt(bcx, v);\n     }\n     else if(ty::type_is_str(tcx, t)) {\n-        ret res(bcx,\n+        ret rslt(bcx,\n                 bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n                                [bcx.fcx.lltaskptr, v]));\n     }\n@@ -6409,7 +6400,7 @@ fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n         auto chan_val = bcx.build.PointerCast(chan_raw_val, \n                                               val_ty(v));\n \n-        ret res(bcx, chan_val);\n+        ret rslt(bcx, chan_val);\n     } \n     else if(ty::type_is_structural(tcx, t)) {\n         fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n@@ -6451,7 +6442,7 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n     auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n                    [bcx.fcx.lltaskptr, llchanval, lldataptr]);\n-    ret res(bcx, chn.val);\n+    ret rslt(bcx, chn.val);\n }\n \n fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n@@ -6480,7 +6471,7 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n     bcx = cp.bcx;\n     // TODO: Any cleanup need to be done here?\n \n-    ret res(bcx, to);\n+    ret rslt(bcx, to);\n }\n \n \n@@ -6771,7 +6762,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     }\n \n     // Return the object we built.\n-    ret res(bcx, pair);\n+    ret rslt(bcx, pair);\n }\n \n fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n@@ -6808,7 +6799,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n         }\n         case (_) { bcx = zero_alloca(bcx, llptr, ty).bcx; }\n     }\n-    ret res(bcx, llptr);\n+    ret rslt(bcx, llptr);\n }\n \n fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty::t t) -> result {\n@@ -6822,7 +6813,7 @@ fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty::t t) -> result {\n         auto null = lib::llvm::llvm::LLVMConstNull(llty);\n         bcx.build.Store(null, llptr);\n     }\n-    ret res(bcx, llptr);\n+    ret rslt(bcx, llptr);\n }\n \n fn trans_stmt(&@block_ctxt cx, &ast::stmt s) -> result {\n@@ -6841,7 +6832,7 @@ fn trans_stmt(&@block_ctxt cx, &ast::stmt s) -> result {\n         }\n         case (_) { cx.fcx.lcx.ccx.sess.unimpl(\"stmt variant\"); }\n     }\n-    ret res(bcx, C_nil());\n+    ret rslt(bcx, C_nil());\n }\n \n fn new_builder(BasicBlockRef llbb) -> builder {\n@@ -6999,7 +6990,7 @@ fn alloc_ty(&@block_ctxt cx, &ty::t t) -> result {\n     // past caller conventions and may well make sense again,\n     // so we leave it as-is.\n \n-    ret res(cx, val);\n+    ret rslt(cx, val);\n }\n \n fn alloc_local(&@block_ctxt cx, &@ast::local local) -> result {\n@@ -7015,7 +7006,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n         // FIXME Update bcx.sp\n         bcx = alloc_local(bcx, local).bcx;\n     }\n-    auto r = res(bcx, C_nil());\n+    auto r = rslt(bcx, C_nil());\n     for (@ast::stmt s in b.node.stmts) {\n         r = trans_stmt(bcx, *s);\n         bcx = r.bcx;\n@@ -7054,16 +7045,16 @@ fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n                         auto res_copy =\n                             copy_val(bcx, INIT, target, r.val, r_ty);\n                         bcx = res_copy.bcx;\n-                        r = res(bcx, C_nil());\n+                        r = rslt(bcx, C_nil());\n                     }\n                     case (return) { }\n                 }\n             }\n         }\n-        case (none) { r = res(bcx, C_nil()); }\n+        case (none) { r = rslt(bcx, C_nil()); }\n     }\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n-    ret res(bcx, r.val);\n+    ret rslt(bcx, r.val);\n }\n \n fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n@@ -7344,16 +7335,16 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     // trans_mod, trans_item, trans_obj, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n \n-    auto res =\n+    auto rslt =\n         if (!ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n                 !ty::type_is_bot(cx.ccx.tcx, block_ty)) {\n             trans_block(bcx, f.body, save_in(fcx.llretptr))\n         } else { trans_block(bcx, f.body, return) };\n-    if (!is_terminated(res.bcx)) {\n+    if (!is_terminated(rslt.bcx)) {\n         // FIXME: until LLVM has a unit type, we are moving around\n         // C_nil values rather than their void type.\n \n-        res.bcx.build.RetVoid();\n+       rslt.bcx.build.RetVoid();\n     }\n     // Insert the mandatory first few basic blocks before lltop.\n "}, {"sha": "8ea7b54de0ca1992a7f6acfeeaa859c308aa7d6b", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -54,9 +54,9 @@ fn empty_prestate(uint num_vars) -> prestate { be true_precond(num_vars); }\n fn empty_poststate(uint num_vars) -> poststate { be true_precond(num_vars); }\n \n fn false_postcond(uint num_vars) -> postcond {\n-    auto res = create_tritv(num_vars);\n-    tritv_set_all(res);\n-    ret res;\n+    auto rslt = create_tritv(num_vars);\n+    tritv_set_all(rslt);\n+    ret rslt;\n }\n \n fn empty_pre_post(uint num_vars) -> pre_and_post {"}, {"sha": "ef20a58b52f783188665ac505187f1aa55b885c9", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -23,42 +23,42 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(&@expr e, @mutable vec[node_id] res) {\n-    vec::push(*res, e.id);\n+fn collect_ids_expr(&@expr e, @mutable vec[node_id] rs) {\n+    vec::push(*rs, e.id);\n }\n \n-fn collect_ids_block(&block b, @mutable vec[node_id] res) {\n-    vec::push(*res, b.node.id);\n+fn collect_ids_block(&block b, @mutable vec[node_id] rs) {\n+    vec::push(*rs, b.node.id);\n }\n \n-fn collect_ids_stmt(&@stmt s, @mutable vec[node_id] res) {\n+fn collect_ids_stmt(&@stmt s, @mutable vec[node_id] rs) {\n     alt (s.node) {\n         case (stmt_decl(_, ?id)) {\n             log \"node_id \" + istr(id);\n             log_stmt(*s);\n-            vec::push(*res, id);\n+            vec::push(*rs, id);\n         }\n         case (stmt_expr(_, ?id)) {\n             log \"node_id \" + istr(id);\n             log_stmt(*s);\n-            vec::push(*res, id);\n+            vec::push(*rs, id);\n         }\n         case (_) { }\n     }\n }\n \n-fn collect_ids_local(&@local l, @mutable vec[node_id] res) {\n-    vec::push(*res, l.node.id);\n+fn collect_ids_local(&@local l, @mutable vec[node_id] rs) {\n+    vec::push(*rs, l.node.id);\n }\n \n fn node_ids_in_fn(&_fn f, &span sp, &ident i, node_id id,\n-                  @mutable vec[node_id] res) {\n+                  @mutable vec[node_id] rs) {\n     auto collect_ids = walk::default_visitor();\n     collect_ids =\n-        rec(visit_expr_pre=bind collect_ids_expr(_, res),\n-            visit_block_pre=bind collect_ids_block(_, res),\n-            visit_stmt_pre=bind collect_ids_stmt(_, res),\n-            visit_local_pre=bind collect_ids_local(_, res) with collect_ids);\n+        rec(visit_expr_pre=bind collect_ids_expr(_, rs),\n+            visit_block_pre=bind collect_ids_block(_, rs),\n+            visit_stmt_pre=bind collect_ids_stmt(_, rs),\n+            visit_local_pre=bind collect_ids_local(_, rs) with collect_ids);\n     walk::walk_fn(collect_ids, f, sp, i, id);\n }\n "}, {"sha": "af040ad38bf4988d7b39643637468aa4c4e5fd96", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -49,17 +49,17 @@ import pretty::ppaux::lit_to_str;\n fn def_id_to_str(def_id d) -> str { ret istr(d._0) + \",\" + istr(d._1); }\n \n fn comma_str(vec[@constr_arg_use] args) -> str {\n-    auto res = \"\";\n+    auto rslt = \"\";\n     auto comma = false;\n     for (@constr_arg_use a in args) {\n-        if (comma) { res += \", \"; } else { comma = true; }\n+        if (comma) { rslt += \", \"; } else { comma = true; }\n         alt (a.node) {\n-            case (carg_base) { res += \"*\"; }\n-            case (carg_ident(?i)) { res += i._0; }\n-            case (carg_lit(?l)) { res += lit_to_str(l); }\n+            case (carg_base) { rslt += \"*\"; }\n+            case (carg_ident(?i)) { rslt += i._0; }\n+            case (carg_lit(?l)) { rslt += lit_to_str(l); }\n         }\n     }\n-    ret res;\n+    ret rslt;\n }\n \n fn constraint_to_str(&ty::ctxt tcx, &constr c) -> str {\n@@ -120,11 +120,11 @@ fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n \n fn tos(vec[uint] v) -> str {\n-    auto res = \"\";\n-    for (uint i in v) { if (i == 0u) { res += \"0\"; } \n-        else if (i == 1u) { res += \"1\"; }\n-        else { res += \"?\"; } }\n-    ret res;\n+    auto rslt = \"\";\n+    for (uint i in v) { if (i == 0u) { rslt += \"0\"; } \n+        else if (i == 1u) { rslt += \"1\"; }\n+        else { rslt += \"?\"; } }\n+    ret rslt;\n }\n \n fn log_cond(vec[uint] v) { log tos(v); }\n@@ -497,15 +497,15 @@ fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n             ret [rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n         }\n         case (cpred(?p, ?descs)) {\n-            let vec[norm_constraint] res = [];\n+            let vec[norm_constraint] rslt = [];\n             for (pred_desc pd in *descs) {\n-                vec::push(res,\n+                vec::push(rslt,\n                           rec(bit_num=pd.node.bit_num,\n                               c=respan(pd.span,\n                                        rec(id=id,\n                                            c=npred(p, pd.node.args)))));\n             }\n-            ret res;\n+            ret rslt;\n         }\n     }\n }\n@@ -514,11 +514,11 @@ fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n-    let vec[norm_constraint] res = [];\n+    let vec[norm_constraint] rslt = [];\n     for each (@tup(node_id, constraint) p in fcx.enclosing.constrs.items()) {\n-        res += norm_a_constraint(p._0, p._1);\n+        rslt += norm_a_constraint(p._0, p._1);\n     }\n-    ret res;\n+    ret rslt;\n }\n \n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n@@ -617,11 +617,11 @@ fn pred_desc_to_str(&pred_desc p) -> str {\n \n fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n                           &@ty::constr_def c) -> constr__ {\n-    let vec[@constr_arg_use] res = [];\n+    let vec[@constr_arg_use] rslt = [];\n     for (@constr_arg a in c.node.args) {\n-        res += [substitute_arg(cx, actuals, a)];\n+        rslt += [substitute_arg(cx, actuals, a)];\n     }\n-    ret npred(c.node.path, res);\n+    ret npred(c.node.path, rslt);\n }\n \n type subst = vec[tup(arg, @expr)];"}, {"sha": "cbfda84d1950ac6415f9cc6faf101465f52dc26f", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -43,10 +43,10 @@ import tritv::*;\n \n fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n     assert (fcx.enclosing.constrs.contains_key(c.id));\n-    auto res = fcx.enclosing.constrs.get(c.id);\n+    auto rslt = fcx.enclosing.constrs.get(c.id);\n     alt (c.c) {\n         case (ninit(_)) {\n-            alt (res) {\n+            alt (rslt) {\n                 case (cinit(?n, _, _)) { ret n; }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\"\n@@ -55,7 +55,7 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n             }\n         }\n         case (npred(_, ?args)) {\n-            alt (res) {\n+            alt (rslt) {\n                 case (cpred(_, ?descs)) { ret match_args(fcx, *descs, args); }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n@@ -166,11 +166,11 @@ fn gen(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n }\n \n fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n-    auto res = clone(pre);\n-    relax_prestate(bit_num(fcx, c), res);\n+    auto rslt = clone(pre);\n+    relax_prestate(bit_num(fcx, c), rslt);\n     // idea is this is scoped\n-    relax_poststate(bit_num(fcx, c), res);\n-    ret res;\n+    relax_poststate(bit_num(fcx, c), rslt);\n+    ret rslt;\n }\n \n fn relax_precond_block_non_recursive(&fn_ctxt fcx, node_id i, &block b) {"}, {"sha": "eed418578ebdd51bfc84426ce1ad92d86d77c259", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -123,12 +123,12 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp, &ident f_name,\n \n     add_constraint(cx.tcx, respan(f_sp, rec(id=id, c=ninit(f_name))), next,\n                    res_map);\n-    auto res =\n+    auto rslt =\n         rec(constrs=res_map,\n             num_constraints=vec::len(*cx.cs) + 1u,\n             cf=f.decl.cf);\n-    ccx.fm.insert(id, res);\n-    log f_name + \" has \" + uistr(num_constraints(res)) + \" constraints\";\n+    ccx.fm.insert(id, rslt);\n+    log f_name + \" has \" + uistr(num_constraints(rslt)) + \" constraints\";\n }\n \n "}, {"sha": "8d75c6cdb0a26dd4f2ef6f57dc02ee8f580f4916", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -314,16 +314,16 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_exprs(fcx, elt_exprs(elts), e.id);\n         }\n         case (expr_path(?p)) {\n-            auto res = expr_pp(fcx.ccx, e);\n-            clear_pp(res);\n+            auto rslt = expr_pp(fcx.ccx, e);\n+            clear_pp(rslt);\n             auto df = node_id_to_def_strict(fcx.ccx.tcx, e.id);\n             alt (df) {\n                 case (def_local(?d_id)) {\n                     auto i =\n                         bit_num(fcx,\n                                 rec(id=d_id._1,\n                                     c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n-                    require_and_preserve(i, res);\n+                    require_and_preserve(i, rslt);\n                 }\n                 case (_) {/* nothing to check */ }\n             }"}, {"sha": "1e7a5bf6377329a6ff15244c30af3fa52ab5f72d", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -102,10 +102,10 @@ fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n \n fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, ast::node_id id,\n                              &vec[@expr] es) -> bool {\n-    auto res = seq_states(fcx, pres, es);\n-    auto changed = res._0;\n+    auto rslt = seq_states(fcx, pres, es);\n+    auto changed = rslt._0;\n     changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-    changed = extend_poststate_ann(fcx.ccx, id, res._1) || changed;\n+    changed = extend_poststate_ann(fcx.ccx, id, rslt._1) || changed;\n     ret changed;\n }\n "}, {"sha": "1531fde1092f18de3faef7bde0cfa4b8bf65b269", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -224,15 +224,15 @@ fn tritv_doesntcare(&t v) -> bool {\n \n fn to_vec(&t v) -> vec[uint] {\n   let uint i = 0u;\n-  let vec[uint] res = [];\n+  let vec[uint] rslt = [];\n   while (i < v.nbits) {\n-    res += [alt (tritv_get(v, i)) {\n+    rslt += [alt (tritv_get(v, i)) {\n         case (dont_care) { 2u }\n         case (ttrue)     { 1u }\n         case (tfalse)    { 0u } }];\n     i += 1u;\n   }\n-  ret res;\n+  ret rslt;\n }\n //\n // Local Variables:"}, {"sha": "de36d441838fae40323f3df494dba438049c2d27", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9643aedb049a84965ea4ac2be906ff2707d5de10/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9643aedb049a84965ea4ac2be906ff2707d5de10", "patch": "@@ -1956,7 +1956,7 @@ mod unify {\n                     case (ures_ok(?unified_type)) {\n                         result_type = unified_type;\n                     }\n-                    case (?res) { ret res; }\n+                    case (?rs) { ret rs; }\n                 }\n             }\n             case (none) {/* fall through */ }\n@@ -2179,7 +2179,7 @@ mod unify {\n                         // Just bind the type variable to the expected type.\n                         alt (record_var_binding(cx, actual_id, expected)) {\n                             case (ures_ok(_)) {/* fall through */ }\n-                            case (?res) { ret res; }\n+                            case (?rs) { ret rs; }\n                         }\n                     }\n                 }\n@@ -2193,7 +2193,7 @@ mod unify {\n \n                 alt (record_var_binding(cx, expected_id, actual)) {\n                     case (ures_ok(_)) {/* fall through */ }\n-                    case (?res) { ret res; }\n+                    case (?rs) { ret rs; }\n                 }\n                 ret ures_ok(mk_var(cx.tcx, expected_id));\n             }"}]}