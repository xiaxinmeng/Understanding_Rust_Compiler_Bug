{"sha": "200d001784e62c85d0e938637ce4043162aa94fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMGQwMDE3ODRlNjJjODVkMGU5Mzg2MzdjZTQwNDMxNjJhYTk0ZmQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-24T09:09:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:50Z"}, "message": "trans: Pass fat pointers as two arguments even for FFI.", "tree": {"sha": "e562430c719acbb04c004aef9a29bd7c200e7527", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e562430c719acbb04c004aef9a29bd7c200e7527"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/200d001784e62c85d0e938637ce4043162aa94fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/200d001784e62c85d0e938637ce4043162aa94fd", "html_url": "https://github.com/rust-lang/rust/commit/200d001784e62c85d0e938637ce4043162aa94fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/200d001784e62c85d0e938637ce4043162aa94fd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3342da41135a63ba6d20c3f3e90fb40419164706", "url": "https://api.github.com/repos/rust-lang/rust/commits/3342da41135a63ba6d20c3f3e90fb40419164706", "html_url": "https://github.com/rust-lang/rust/commit/3342da41135a63ba6d20c3f3e90fb40419164706"}], "stats": {"total": 110, "additions": 68, "deletions": 42}, "files": [{"sha": "a73f5ff90d96b908e5ce3434f21412287a1efb94", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/200d001784e62c85d0e938637ce4043162aa94fd/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200d001784e62c85d0e938637ce4043162aa94fd/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=200d001784e62c85d0e938637ce4043162aa94fd", "patch": "@@ -12,7 +12,7 @@ pub use self::ArgKind::*;\n \n use llvm::{self, AttrHelper, ValueRef};\n use trans::attributes;\n-use trans::common::return_type_is_void;\n+use trans::common::{return_type_is_void, type_is_fat_ptr};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n use trans::cabi_x86_64;\n@@ -184,10 +184,20 @@ impl FnType {\n             _ => Type::void(ccx)\n         };\n \n+        let mut args = Vec::with_capacity(sig.inputs.len() + extra_args.len());\n+        for ty in sig.inputs.iter().chain(extra_args.iter()) {\n+            let llty = c_type_of(ccx, ty);\n+            if type_is_fat_ptr(ccx.tcx(), ty) {\n+                args.extend(llty.field_types().into_iter().map(|llty| {\n+                    ArgType::direct(llty, None, None, None)\n+                }));\n+            } else {\n+                args.push(ArgType::direct(llty, None, None, None));\n+            }\n+        }\n+\n         let mut fty = FnType {\n-            args: sig.inputs.iter().chain(extra_args.iter()).map(|&ty| {\n-                ArgType::direct(c_type_of(ccx, ty), None, None, None)\n-            }).collect(),\n+            args: args,\n             ret: ArgType::direct(rty, None, None, None),\n             variadic: sig.variadic,\n             cconv: cconv"}, {"sha": "46eb8006272a5c0ab92f7c9708186622bb846837", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/200d001784e62c85d0e938637ce4043162aa94fd/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/200d001784e62c85d0e938637ce4043162aa94fd/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=200d001784e62c85d0e938637ce4043162aa94fd", "patch": "@@ -13,19 +13,17 @@ use back::link;\n use llvm::{ValueRef, get_param};\n use llvm;\n use middle::weak_lang_items;\n-use trans::abi::{self, Abi, FnType};\n+use trans::abi::{Abi, FnType};\n use trans::attributes;\n use trans::base::{llvm_linkage_by_name, push_ctxt};\n use trans::base;\n use trans::build::*;\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n-use trans::expr;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n-use trans::type_of::*;\n use trans::type_of;\n use trans::value::Value;\n use middle::infer;\n@@ -167,17 +165,40 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let mut offset = 0;\n-    for (i, arg_ty) in fn_type.args.iter().enumerate() {\n-        let mut llarg_rust = llargs_rust[i + offset];\n+    let mut i = 0;\n+    for &passed_arg_ty in &passed_arg_tys {\n+        let arg_ty = fn_type.args[i];\n \n         if arg_ty.is_ignore() {\n+            i += 1;\n+            continue;\n+        }\n+\n+        if type_is_fat_ptr(ccx.tcx(), passed_arg_ty) {\n+            // Fat pointers are one pointer and one integer or pointer.\n+            let (a, b) = (fn_type.args[i], fn_type.args[i + 1]);\n+            assert_eq!((a.cast, b.cast), (None, None));\n+            assert!(!a.is_indirect() && !b.is_indirect());\n+\n+            if let Some(ty) = a.pad {\n+                llargs_foreign.push(C_undef(ty));\n+            }\n+            llargs_foreign.push(llargs_rust[i]);\n+            i += 1;\n+\n+            if let Some(ty) = b.pad {\n+                llargs_foreign.push(C_undef(ty));\n+            }\n+            llargs_foreign.push(llargs_rust[i]);\n+            i += 1;\n             continue;\n         }\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n+        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_ty);\n \n+        let mut llarg_rust = llargs_rust[i];\n+        i += 1;\n         debug!(\"argument {}, llarg_rust={:?}, rust_indirect={}, arg_ty={:?}\",\n                i,\n                Value(llarg_rust),\n@@ -187,24 +208,17 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n         if !rust_indirect {\n-            let scratch = base::alloc_ty(bcx, passed_arg_tys[i], \"__arg\");\n-            if type_is_fat_ptr(ccx.tcx(), passed_arg_tys[i]) {\n-                Store(bcx, llargs_rust[i + offset], expr::get_dataptr(bcx, scratch));\n-                Store(bcx, llargs_rust[i + offset + 1], expr::get_meta(bcx, scratch));\n-                offset += 1;\n-            } else {\n-                base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n-            }\n+            let scratch = base::alloc_ty(bcx, passed_arg_ty, \"__arg\");\n+            base::store_ty(bcx, llarg_rust, scratch, passed_arg_ty);\n             llarg_rust = scratch;\n         }\n \n         debug!(\"llarg_rust={:?} (after indirection)\",\n                Value(llarg_rust));\n \n         // Check whether we need to do any casting\n-        match arg_ty.cast {\n-            Some(ty) => llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to()),\n-            None => ()\n+        if let Some(ty) = arg_ty.cast {\n+            llarg_rust = BitCast(bcx, llarg_rust, ty.ptr_to());\n         }\n \n         debug!(\"llarg_rust={:?} (after casting)\",\n@@ -214,22 +228,19 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let foreign_indirect = arg_ty.is_indirect();\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n+        } else if passed_arg_ty.is_bool() {\n+            let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n+            Trunc(bcx, val, Type::i1(bcx.ccx()))\n         } else {\n-            if passed_arg_tys[i].is_bool() {\n-                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n-                Trunc(bcx, val, Type::i1(bcx.ccx()))\n-            } else {\n-                Load(bcx, llarg_rust)\n-            }\n+            Load(bcx, llarg_rust)\n         };\n \n         debug!(\"argument {}, llarg_foreign={:?}\",\n                i, Value(llarg_foreign));\n \n         // fill padding with undef value\n-        match arg_ty.pad {\n-            Some(ty) => llargs_foreign.push(C_undef(ty)),\n-            None => ()\n+        if let Some(ty) = arg_ty.pad {\n+            llargs_foreign.push(C_undef(ty));\n         }\n         llargs_foreign.push(llarg_foreign);\n     }\n@@ -552,16 +563,16 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n+        let mut tys = fn_ty.args.iter().zip(rust_param_tys);\n         for i in 0..fn_sig.inputs.len() {\n             let rust_ty = fn_sig.inputs[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n+            let (llforeign_arg_ty, llty) = tys.next().expect(\"Not enough parameter types!\");\n             let llrust_ty = if rust_indirect {\n                 llty.element_type()\n             } else {\n                 llty\n             };\n-            let llforeign_arg_ty = fn_ty.args[i];\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             if llforeign_arg_ty.is_ignore() {\n@@ -574,6 +585,19 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n             let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n \n+            if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n+                // Fat pointers are one pointer and one integer or pointer.\n+                let a = llforeign_arg_ty;\n+                let (b, _) = tys.next().expect(\"Not enough parameter types!\");\n+                assert_eq!((a.cast, b.cast), (None, None));\n+                assert!(!a.is_indirect() && !b.is_indirect());\n+\n+                llrust_args.push(llforeign_arg);\n+                let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n+                llrust_args.push(get_param(llwrapfn, foreign_index));\n+                continue;\n+            }\n+\n             debug!(\"llforeign_arg {}{}: {:?}\", \"#\",\n                    i, Value(llforeign_arg));\n             debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n@@ -624,15 +648,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             debug!(\"llrust_arg {}{}: {:?}\", \"#\",\n                    i, Value(llrust_arg));\n-            if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n-                let next_llrust_ty = rust_param_tys.next().expect(\"Not enough parameter types!\");\n-                llrust_args.push(builder.load(builder.bitcast(builder.struct_gep(\n-                                llrust_arg, abi::FAT_PTR_ADDR), llrust_ty.ptr_to())));\n-                llrust_args.push(builder.load(builder.bitcast(builder.struct_gep(\n-                                llrust_arg, abi::FAT_PTR_EXTRA), next_llrust_ty.ptr_to())));\n-            } else {\n-                llrust_args.push(llrust_arg);\n-            }\n+            llrust_args.push(llrust_arg);\n         }\n \n         // Perform the call itself"}]}