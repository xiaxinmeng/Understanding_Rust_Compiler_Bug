{"sha": "9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "node_id": "C_kwDOAAsO6NoAKDlmMjJiMzdmN2I1MDBlZTY5ZDg1MWQxNDBhOWZlYjgzYmNmYjFkMDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T09:58:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T09:58:58Z"}, "message": "Auto merge of #2856 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "3c707a5636019429cda38c5bed8266bd35e8d8ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c707a5636019429cda38c5bed8266bd35e8d8ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "html_url": "https://github.com/rust-lang/rust/commit/9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb65219df487fc23a2901fba25ad472b0b257219", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb65219df487fc23a2901fba25ad472b0b257219", "html_url": "https://github.com/rust-lang/rust/commit/bb65219df487fc23a2901fba25ad472b0b257219"}, {"sha": "b3ab1f63742a6f11aa6b2b6fb88caf21543c0573", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ab1f63742a6f11aa6b2b6fb88caf21543c0573", "html_url": "https://github.com/rust-lang/rust/commit/b3ab1f63742a6f11aa6b2b6fb88caf21543c0573"}], "stats": {"total": 311, "additions": 289, "deletions": 22}, "files": [{"sha": "c0561119a90d1d246a0ba9fa897a447925683349", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -1 +1 @@\n-f65615f02d22b85e9205f2716ab36182d34bab2b\n+70540d51275086ce1a4cb12e9d96a97134df792e"}, {"sha": "13306b4809c33eca5183f69c4f8910df9706dd72", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -48,7 +48,7 @@ use std::{\n \n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n use rustc_middle::mir;\n use rustc_span::Span;\n use rustc_target::abi::{Align, Size};"}, {"sha": "1f57e8b2b0abd5b40dfc41e84acf73abcd8db7ff", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -1,7 +1,7 @@\n use std::collections::VecDeque;\n use std::num::NonZeroU32;\n \n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n \n use super::sync::EvalContextExtPriv as _;\n use super::thread::MachineCallback;"}, {"sha": "f37a2fd2cd5b6d12638c730983de94de229f7eeb", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -5,7 +5,7 @@ use std::ops::Not;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n \n use super::init_once::InitOnce;\n use super::vector_clock::VClock;"}, {"sha": "e9bbae4d50488ef0312f45502a41f11a628411db", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -10,7 +10,7 @@ use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::Span;\n@@ -603,10 +603,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // this allows us to have a deterministic scheduler.\n         for thread in self.threads.indices() {\n             match self.timeout_callbacks.entry(thread) {\n-                Entry::Occupied(entry) =>\n+                Entry::Occupied(entry) => {\n                     if entry.get().call_time.get_wait_time(clock) == Duration::new(0, 0) {\n                         return Some((thread, entry.remove().callback));\n-                    },\n+                    }\n+                }\n                 Entry::Vacant(_) => {}\n             }\n         }"}, {"sha": "a6e67ef8699df42f41c1a809eb9186514e02f67e", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n use rustc_span::{Span, SpanData, DUMMY_SP};\n use smallvec::SmallVec;\n use std::{"}, {"sha": "4daf06c777e9a990b7c258e48b96889200221307", "filename": "src/tools/miri/tests/pass/tree-borrows/read-only-from-mut.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb65219df487fc23a2901fba25ad472b0b257219/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb65219df487fc23a2901fba25ad472b0b257219/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs?ref=bb65219df487fc23a2901fba25ad472b0b257219", "patch": "@@ -1,14 +0,0 @@\n-//@compile-flags: -Zmiri-tree-borrows\n-\n-// Tree Borrows has no issue with several mutable references existing\n-// at the same time, as long as they are used only immutably.\n-// I.e. multiple Reserved can coexist.\n-pub fn main() {\n-    unsafe {\n-        let base = &mut 42u64;\n-        let r1 = &mut *(base as *mut u64);\n-        let r2 = &mut *(base as *mut u64);\n-        let _l = *r1;\n-        let _l = *r2;\n-    }\n-}"}, {"sha": "aa6f7078890e966345ad99b00b8221639b72ed95", "filename": "src/tools/miri/tests/pass/tree-borrows/tree-borrows.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22b37f7b500ee69d851d140a9feb83bcfb1d00/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs?ref=9f22b37f7b500ee69d851d140a9feb83bcfb1d00", "patch": "@@ -0,0 +1,280 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+#![feature(allocator_api)]\n+\n+use std::mem;\n+use std::ptr;\n+\n+fn main() {\n+    aliasing_read_only_mutable_refs();\n+    string_as_mut_ptr();\n+\n+    // Stacked Borrows tests\n+    read_does_not_invalidate1();\n+    read_does_not_invalidate2();\n+    mut_raw_then_mut_shr();\n+    mut_shr_then_mut_raw();\n+    mut_raw_mut();\n+    partially_invalidate_mut();\n+    drop_after_sharing();\n+    direct_mut_to_const_raw();\n+    two_raw();\n+    shr_and_raw();\n+    disjoint_mutable_subborrows();\n+    raw_ref_to_part();\n+    array_casts();\n+    mut_below_shr();\n+    wide_raw_ptr_in_tuple();\n+    not_unpin_not_protected();\n+}\n+\n+// Tree Borrows has no issue with several mutable references existing\n+// at the same time, as long as they are used only immutably.\n+// I.e. multiple Reserved can coexist.\n+pub fn aliasing_read_only_mutable_refs() {\n+    unsafe {\n+        let base = &mut 42u64;\n+        let r1 = &mut *(base as *mut u64);\n+        let r2 = &mut *(base as *mut u64);\n+        let _l = *r1;\n+        let _l = *r2;\n+    }\n+}\n+\n+pub fn string_as_mut_ptr() {\n+    // This errors in Stacked Borrows since as_mut_ptr restricts the provenance,\n+    // but with Tree Borrows it should work.\n+    unsafe {\n+        let mut s = String::from(\"hello\");\n+        s.reserve(1); // make the `str` that `s` derefs to not cover the entire `s`.\n+\n+        // Prevent automatically dropping the String's data\n+        let mut s = mem::ManuallyDrop::new(s);\n+\n+        let ptr = s.as_mut_ptr();\n+        let len = s.len();\n+        let capacity = s.capacity();\n+\n+        let s = String::from_raw_parts(ptr, len, capacity);\n+\n+        assert_eq!(String::from(\"hello\"), s);\n+    }\n+}\n+\n+// ----- The tests below were taken from Stacked Borrows ----\n+\n+// Make sure that reading from an `&mut` does, like reborrowing to `&`,\n+// NOT invalidate other reborrows.\n+fn read_does_not_invalidate1() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let ret = unsafe { &(*xraw).1 };\n+        let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n+        ret\n+    }\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+// Same as above, but this time we first create a raw, then read from `&mut`\n+// and then freeze from the raw.\n+fn read_does_not_invalidate2() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let _val = x.1; // we just read, this does NOT invalidate the raw reborrow.\n+        let ret = unsafe { &(*xraw).1 };\n+        ret\n+    }\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+\n+// Escape a mut to raw, then share the same mut and use the share, then the raw.\n+// That should work.\n+fn mut_raw_then_mut_shr() {\n+    let mut x = 2;\n+    let xref = &mut x;\n+    let xraw = &mut *xref as *mut _;\n+    let xshr = &*xref;\n+    assert_eq!(*xshr, 2);\n+    unsafe {\n+        *xraw = 4;\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+// Create first a shared reference and then a raw pointer from a `&mut`\n+// should permit mutation through that raw pointer.\n+fn mut_shr_then_mut_raw() {\n+    let xref = &mut 2;\n+    let _xshr = &*xref;\n+    let xraw = xref as *mut _;\n+    unsafe {\n+        *xraw = 3;\n+    }\n+    assert_eq!(*xref, 3);\n+}\n+\n+// Ensure that if we derive from a mut a raw, and then from that a mut,\n+// and then read through the original mut, that does not invalidate the raw.\n+// This shows that the read-exception for `&mut` applies even if the `Shr` item\n+// on the stack is not at the top.\n+fn mut_raw_mut() {\n+    let mut x = 2;\n+    {\n+        let xref1 = &mut x;\n+        let xraw = xref1 as *mut _;\n+        let _xref2 = unsafe { &mut *xraw };\n+        let _val = *xref1;\n+        unsafe {\n+            *xraw = 4;\n+        }\n+        // we can now use both xraw and xref1, for reading\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        // we cannot use xref2; see `compile-fail/stacked-borrows/illegal_read4.rs`\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+fn partially_invalidate_mut() {\n+    let data = &mut (0u8, 0u8);\n+    let reborrow = &mut *data as *mut (u8, u8);\n+    let shard = unsafe { &mut (*reborrow).0 };\n+    data.1 += 1; // the deref overlaps with `shard`, but that is ok; the access does not overlap.\n+    *shard += 1; // so we can still use `shard`.\n+    assert_eq!(*data, (1, 1));\n+}\n+\n+// Make sure that we can handle the situation where a location is frozen when being dropped.\n+fn drop_after_sharing() {\n+    let x = String::from(\"hello!\");\n+    let _len = x.len();\n+}\n+\n+// Make sure that coercing &mut T to *const T produces a writeable pointer.\n+fn direct_mut_to_const_raw() {\n+    // TODO: This is currently disabled, waiting on a decision on <https://github.com/rust-lang/rust/issues/56604>\n+    /*let x = &mut 0;\n+    let y: *const i32 = x;\n+    unsafe { *(y as *mut i32) = 1; }\n+    assert_eq!(*x, 1);\n+    */\n+}\n+\n+// Make sure that we can create two raw pointers from a mutable reference and use them both.\n+fn two_raw() {\n+    unsafe {\n+        let x = &mut 0;\n+        let y1 = x as *mut _;\n+        let y2 = x as *mut _;\n+        *y1 += 2;\n+        *y2 += 1;\n+    }\n+}\n+\n+// Make sure that creating a *mut does not invalidate existing shared references.\n+fn shr_and_raw() {\n+    unsafe {\n+        let x = &mut 0;\n+        let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+        let y2 = x as *mut _;\n+        let _val = *y1;\n+        *y2 += 1;\n+    }\n+}\n+\n+fn disjoint_mutable_subborrows() {\n+    struct Foo {\n+        a: String,\n+        b: Vec<u32>,\n+    }\n+\n+    unsafe fn borrow_field_a<'a>(this: *mut Foo) -> &'a mut String {\n+        &mut (*this).a\n+    }\n+\n+    unsafe fn borrow_field_b<'a>(this: *mut Foo) -> &'a mut Vec<u32> {\n+        &mut (*this).b\n+    }\n+\n+    let mut foo = Foo { a: \"hello\".into(), b: vec![0, 1, 2] };\n+\n+    let ptr = &mut foo as *mut Foo;\n+\n+    let a = unsafe { borrow_field_a(ptr) };\n+    let b = unsafe { borrow_field_b(ptr) };\n+    b.push(4);\n+    a.push_str(\" world\");\n+    assert_eq!(format!(\"{:?} {:?}\", a, b), r#\"\"hello world\" [0, 1, 2, 4]\"#);\n+}\n+\n+fn raw_ref_to_part() {\n+    struct Part {\n+        _lame: i32,\n+    }\n+\n+    #[repr(C)]\n+    struct Whole {\n+        part: Part,\n+        extra: i32,\n+    }\n+\n+    let it = Box::new(Whole { part: Part { _lame: 0 }, extra: 42 });\n+    let whole = ptr::addr_of_mut!(*Box::leak(it));\n+    let part = unsafe { ptr::addr_of_mut!((*whole).part) };\n+    let typed = unsafe { &mut *(part as *mut Whole) };\n+    assert!(typed.extra == 42);\n+    drop(unsafe { Box::from_raw(whole) });\n+}\n+\n+/// When casting an array reference to a raw element ptr, that should cover the whole array.\n+fn array_casts() {\n+    let mut x: [usize; 2] = [0, 0];\n+    let p = &mut x as *mut usize;\n+    unsafe {\n+        *p.add(1) = 1;\n+    }\n+\n+    let x: [usize; 2] = [0, 1];\n+    let p = &x as *const usize;\n+    assert_eq!(unsafe { *p.add(1) }, 1);\n+}\n+\n+/// Transmuting &&i32 to &&mut i32 is fine.\n+fn mut_below_shr() {\n+    let x = 0;\n+    let y = &x;\n+    let p = unsafe { core::mem::transmute::<&&i32, &&mut i32>(&y) };\n+    let r = &**p;\n+    let _val = *r;\n+}\n+\n+fn wide_raw_ptr_in_tuple() {\n+    let mut x: Box<dyn std::any::Any> = Box::new(\"ouch\");\n+    let r = &mut *x as *mut dyn std::any::Any;\n+    // This triggers the visitor-based recursive retagging. It is *not* supposed to retag raw\n+    // pointers, but then the visitor might recurse into the \"fields\" of a wide raw pointer and\n+    // finds a reference (to a vtable) there that it wants to retag... and that would be Wrong.\n+    let pair = (r, &0);\n+    let r = unsafe { &mut *pair.0 };\n+    // Make sure the fn ptr part of the vtable is still fine.\n+    r.type_id();\n+}\n+\n+fn not_unpin_not_protected() {\n+    // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n+    // don't add protectors. (We could, but until we have a better idea for where we want to go with\n+    // the self-referential-generator situation, it does not seem worth the potential trouble.)\n+    use std::marker::PhantomPinned;\n+\n+    pub struct NotUnpin(i32, PhantomPinned);\n+\n+    fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n+        // `f` may mutate, but it may not deallocate!\n+        f(x)\n+    }\n+\n+    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}]}