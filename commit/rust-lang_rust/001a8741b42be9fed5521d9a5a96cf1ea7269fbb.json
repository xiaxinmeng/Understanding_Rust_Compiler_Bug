{"sha": "001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMWE4NzQxYjQyYmU5ZmVkNTUyMWQ5YTVhOTZjZjFlYTcyNjlmYmI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T05:20:39Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "Handle fallout in iter, option, result, and sync::arc\n\nAPI changes:\n\n- UnsafeArc::newN() returns Vec<UnsafeArc<T>>", "tree": {"sha": "f969ff3b70aef214613be2c5b9a448b9bcf547eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f969ff3b70aef214613be2c5b9a448b9bcf547eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "html_url": "https://github.com/rust-lang/rust/commit/001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11613fc1c048f5bec4cf792397a15bdd17dfd797", "url": "https://api.github.com/repos/rust-lang/rust/commits/11613fc1c048f5bec4cf792397a15bdd17dfd797", "html_url": "https://github.com/rust-lang/rust/commit/11613fc1c048f5bec4cf792397a15bdd17dfd797"}], "stats": {"total": 107, "additions": 54, "deletions": 53}, "files": [{"sha": "d47e12de239289420b4d2bcf61c6ef0878227e44", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "patch": "@@ -2340,8 +2340,8 @@ mod tests {\n     #[test]\n     fn test_counter_from_iter() {\n         let it = count(0, 5).take(10);\n-        let xs: ~[int] = FromIterator::from_iter(it);\n-        assert_eq!(xs, box [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+        let xs: Vec<int> = FromIterator::from_iter(it);\n+        assert_eq!(xs, vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n \n     #[test]\n@@ -2371,7 +2371,7 @@ mod tests {\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert_eq!(it.collect::<~[uint]>(), box [0*0, 2*2, 4*4, 6*6, 8*8]);\n+        assert_eq!(it.collect::<Vec<uint>>(), vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n@@ -2493,7 +2493,7 @@ mod tests {\n         let ys = xs.iter()\n                    .map(|&x| x)\n                    .inspect(|_| n += 1)\n-                   .collect::<~[uint]>();\n+                   .collect::<Vec<uint>>();\n \n         assert_eq!(n, xs.len());\n         assert_eq!(xs.as_slice(), ys.as_slice());\n@@ -2628,8 +2628,8 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let a = box [1, 2, 3, 4, 5];\n-        let b: ~[int] = a.iter().map(|&x| x).collect();\n+        let a = vec![1, 2, 3, 4, 5];\n+        let b: Vec<int> = a.iter().map(|&x| x).collect();\n         assert_eq!(a, b);\n     }\n \n@@ -2702,7 +2702,7 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.rev().map(|&x| x).collect::<~[int]>(), box [16, 14, 12, 10, 8, 6]);\n+        assert_eq!(it.rev().map(|&x| x).collect::<Vec<int>>(), vec![16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2940,12 +2940,12 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).rev().collect::<~[int]>(), box [13i, 12, 11]);\n+        assert_eq!(range(11i, 14).rev().collect::<Vec<int>>(), vec![13i, 12, 11]);\n         for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).rev().collect::<~[uint]>(), box [13u, 12, 11]);\n+        assert_eq!(range(11u, 14).rev().collect::<Vec<uint>>(), vec![13u, 12, 11]);\n         for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n@@ -2997,13 +2997,14 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(range(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4]);\n-        assert_eq!(range(-10i, -1).collect::<~[int]>(), box [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).rev().collect::<~[int]>(), box [4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).collect::<~[int]>(), box []);\n-        assert_eq!(range(200, -5).rev().collect::<~[int]>(), box []);\n-        assert_eq!(range(200, 200).collect::<~[int]>(), box []);\n-        assert_eq!(range(200, 200).rev().collect::<~[int]>(), box []);\n+        assert_eq!(range(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4]);\n+        assert_eq!(range(-10i, -1).collect::<Vec<int>>(),\n+                   vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+        assert_eq!(range(0i, 5).rev().collect::<Vec<int>>(), vec![4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, -5).rev().collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, 200).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range(200, 200).rev().collect::<Vec<int>>(), vec![]);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3014,32 +3015,32 @@ mod tests {\n \n     #[test]\n     fn test_range_inclusive() {\n-        assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).rev().collect::<~[int]>(), box [5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), box []);\n-        assert_eq!(range_inclusive(200, -5).rev().collect::<~[int]>(), box []);\n-        assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), box [200]);\n-        assert_eq!(range_inclusive(200, 200).rev().collect::<~[int]>(), box [200]);\n+        assert_eq!(range_inclusive(0i, 5).collect::<Vec<int>>(), vec![0i, 1, 2, 3, 4, 5]);\n+        assert_eq!(range_inclusive(0i, 5).rev().collect::<Vec<int>>(), vec![5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_inclusive(200, -5).rev().collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), vec![200]);\n+        assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), vec![200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n-        assert_eq!(range_step(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15]);\n-        assert_eq!(range_step(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5]);\n-        assert_eq!(range_step(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n-        assert_eq!(range_step(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n-        assert_eq!(range_step(200, -5, 1).collect::<~[int]>(), box []);\n-        assert_eq!(range_step(200, 200, 1).collect::<~[int]>(), box []);\n+        assert_eq!(range_step(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15]);\n+        assert_eq!(range_step(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5]);\n+        assert_eq!(range_step(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n+        assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n+        assert_eq!(range_step(200, -5, 1).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_step(200, 200, 1).collect::<Vec<int>>(), vec![]);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n-        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15, 20]);\n-        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5, 0]);\n-        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n-        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n-        assert_eq!(range_step_inclusive(200, -5, 1).collect::<~[int]>(), box []);\n-        assert_eq!(range_step_inclusive(200, 200, 1).collect::<~[int]>(), box [200]);\n+        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>(), vec![0, 5, 10, 15, 20]);\n+        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>(), vec![20, 15, 10, 5, 0]);\n+        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>(), vec![20, 14, 8, 2]);\n+        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), vec![200u8, 250]);\n+        assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), vec![]);\n+        assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), vec![200]);\n     }\n \n     #[test]"}, {"sha": "2f8457e93f671b31725370c3a520c308481ff724", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "patch": "@@ -844,22 +844,22 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Option<~[int]> = collect(range(0, 0)\n-                                        .map(|_| Some(0)));\n-        assert_eq!(v, Some(box []));\n+        let v: Option<Vec<int>> = collect(range(0, 0)\n+                                          .map(|_| Some(0)));\n+        assert_eq!(v, Some(vec![]));\n \n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| Some(x)));\n-        assert_eq!(v, Some(box [0, 1, 2]));\n+        let v: Option<Vec<int>> = collect(range(0, 3)\n+                                          .map(|x| Some(x)));\n+        assert_eq!(v, Some(vec![0, 1, 2]));\n \n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| if x > 1 { None } else { Some(x) }));\n+        let v: Option<Vec<int>> = collect(range(0, 3)\n+                                          .map(|x| if x > 1 { None } else { Some(x) }));\n         assert_eq!(v, None);\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Some(()), || None, || fail!()];\n \n-        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n+        let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n \n         assert_eq!(v, None);\n     }"}, {"sha": "27ae2ad9946f5718ae2852e5ee3a69029b9152fe", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "patch": "@@ -653,20 +653,20 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(box []));\n+        let v: Result<Vec<int>, ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n+        assert_eq!(v, Ok(vec![]));\n \n-        let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(box [0, 1, 2]));\n+        let v: Result<Vec<int>, ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n+        assert_eq!(v, Ok(vec![0, 1, 2]));\n \n-        let v: Result<~[int], int> = collect(range(0, 3)\n-                                             .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+        let v: Result<Vec<int>, int> = collect(range(0, 3)\n+                                               .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n         assert_eq!(v, Err(2));\n \n         // test that it does not take more elements than it needs\n         let mut functions = [|| Ok(()), || Err(1), || fail!()];\n \n-        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n+        let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n         assert_eq!(v, Err(1));\n     }\n "}, {"sha": "676c836c459d72458a6abd468ea213dda1ad628c", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a8741b42be9fed5521d9a5a96cf1ea7269fbb/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=001a8741b42be9fed5521d9a5a96cf1ea7269fbb", "patch": "@@ -69,14 +69,14 @@ impl<T: Send> UnsafeArc<T> {\n \n     /// As new(), but returns a vector of as many pre-cloned handles as\n     /// requested.\n-    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n+    pub fn newN(data: T, num_handles: uint) -> Vec<UnsafeArc<T>> {\n         unsafe {\n             if num_handles == 0 {\n-                box [] // need to free data here\n+                vec![] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n                 let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });\n-                v.move_iter().collect()\n+                v\n             }\n         }\n     }"}]}