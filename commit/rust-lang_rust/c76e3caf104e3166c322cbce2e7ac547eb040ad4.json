{"sha": "c76e3caf104e3166c322cbce2e7ac547eb040ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NmUzY2FmMTA0ZTMxNjZjMzIyY2JjZTJlN2FjNTQ3ZWIwNDBhZDQ=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-05T13:08:30Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-06T17:58:34Z"}, "message": "fix sized deallocation for TypedArena<T>", "tree": {"sha": "e70d0d6bcc8d9738898de616708ee1349c217032", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e70d0d6bcc8d9738898de616708ee1349c217032"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76e3caf104e3166c322cbce2e7ac547eb040ad4", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76e3caf104e3166c322cbce2e7ac547eb040ad4", "html_url": "https://github.com/rust-lang/rust/commit/c76e3caf104e3166c322cbce2e7ac547eb040ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76e3caf104e3166c322cbce2e7ac547eb040ad4/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fdad65a057d9b6cd159623ebeba131ec32f69dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fdad65a057d9b6cd159623ebeba131ec32f69dd", "html_url": "https://github.com/rust-lang/rust/commit/2fdad65a057d9b6cd159623ebeba131ec32f69dd"}], "stats": {"total": 97, "additions": 50, "deletions": 47}, "files": [{"sha": "e91898548533c0a98034a97488af0f92153e1006", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c76e3caf104e3166c322cbce2e7ac547eb040ad4/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76e3caf104e3166c322cbce2e7ac547eb040ad4/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c76e3caf104e3166c322cbce2e7ac547eb040ad4", "patch": "@@ -39,17 +39,18 @@ use std::mem;\n use std::num;\n use std::ptr;\n use std::rc::Rc;\n-use std::rt::heap::allocate;\n+use std::rt::heap::{allocate, deallocate};\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n #[deriving(Clone, PartialEq)]\n struct Chunk {\n-    data: Rc<RefCell<Vec<u8> >>,\n+    data: Rc<RefCell<Vec<u8>>>,\n     fill: Cell<uint>,\n     is_copy: Cell<bool>,\n }\n+\n impl Chunk {\n     fn capacity(&self) -> uint {\n         self.data.borrow().capacity()\n@@ -357,38 +358,37 @@ pub struct TypedArena<T> {\n     end: Cell<*const T>,\n \n     /// A pointer to the first arena segment.\n-    first: RefCell<TypedArenaChunkRef<T>>,\n+    first: RefCell<*mut TypedArenaChunk<T>>,\n }\n-type TypedArenaChunkRef<T> = Option<Box<TypedArenaChunk<T>>>;\n \n struct TypedArenaChunk<T> {\n     /// Pointer to the next arena segment.\n-    next: TypedArenaChunkRef<T>,\n+    next: *mut TypedArenaChunk<T>,\n \n     /// The number of elements that this chunk can hold.\n     capacity: uint,\n \n     // Objects follow here, suitably aligned.\n }\n \n+fn calculate_size<T>(capacity: uint) -> uint {\n+    let mut size = mem::size_of::<TypedArenaChunk<T>>();\n+    size = round_up(size, mem::min_align_of::<T>());\n+    let elem_size = mem::size_of::<T>();\n+    let elems_size = elem_size.checked_mul(&capacity).unwrap();\n+    size = size.checked_add(&elems_size).unwrap();\n+    size\n+}\n+\n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    fn new(next: Option<Box<TypedArenaChunk<T>>>, capacity: uint)\n-           -> Box<TypedArenaChunk<T>> {\n-        let mut size = mem::size_of::<TypedArenaChunk<T>>();\n-        size = round_up(size, mem::min_align_of::<T>());\n-        let elem_size = mem::size_of::<T>();\n-        let elems_size = elem_size.checked_mul(&capacity).unwrap();\n-        size = size.checked_add(&elems_size).unwrap();\n-\n-        let mut chunk = unsafe {\n-            let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>());\n-            let mut chunk: Box<TypedArenaChunk<T>> = mem::transmute(chunk);\n-            ptr::write(&mut chunk.next, next);\n-            chunk\n-        };\n-\n-        chunk.capacity = capacity;\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: uint)\n+           -> *mut TypedArenaChunk<T> {\n+        let size = calculate_size::<T>(capacity);\n+        let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n+                    as *mut TypedArenaChunk<T>;\n+        (*chunk).next = next;\n+        (*chunk).capacity = capacity;\n         chunk\n     }\n \n@@ -406,14 +406,13 @@ impl<T> TypedArenaChunk<T> {\n         }\n \n         // Destroy the next chunk.\n-        let next_opt = mem::replace(&mut self.next, None);\n-        match next_opt {\n-            None => {}\n-            Some(mut next) => {\n-                // We assume that the next chunk is completely filled.\n-                let capacity = next.capacity;\n-                next.destroy(capacity)\n-            }\n+        let next = self.next;\n+        let size = calculate_size::<T>(self.capacity);\n+        deallocate(self as *mut TypedArenaChunk<T> as *mut u8, size,\n+                   mem::min_align_of::<TypedArenaChunk<T>>());\n+        if next.is_not_null() {\n+            let capacity = (*next).capacity;\n+            (*next).destroy(capacity);\n         }\n     }\n \n@@ -448,11 +447,13 @@ impl<T> TypedArena<T> {\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n-        let chunk = TypedArenaChunk::<T>::new(None, capacity);\n-        TypedArena {\n-            ptr: Cell::new(chunk.start() as *const T),\n-            end: Cell::new(chunk.end() as *const T),\n-            first: RefCell::new(Some(chunk)),\n+        unsafe {\n+            let chunk = TypedArenaChunk::<T>::new(ptr::mut_null(), capacity);\n+            TypedArena {\n+                ptr: Cell::new((*chunk).start() as *const T),\n+                end: Cell::new((*chunk).end() as *const T),\n+                first: RefCell::new(chunk),\n+            }\n         }\n     }\n \n@@ -476,26 +477,28 @@ impl<T> TypedArena<T> {\n     /// Grows the arena.\n     #[inline(never)]\n     fn grow(&self) {\n-        let chunk = self.first.borrow_mut().take().unwrap();\n-        let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n-        let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n-        self.ptr.set(chunk.start() as *const T);\n-        self.end.set(chunk.end() as *const T);\n-        *self.first.borrow_mut() = Some(chunk)\n+        unsafe {\n+            let chunk = *self.first.borrow_mut();\n+            let new_capacity = (*chunk).capacity.checked_mul(&2).unwrap();\n+            let chunk = TypedArenaChunk::<T>::new(chunk, new_capacity);\n+            self.ptr.set((*chunk).start() as *const T);\n+            self.end.set((*chunk).end() as *const T);\n+            *self.first.borrow_mut() = chunk\n+        }\n     }\n }\n \n #[unsafe_destructor]\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n-        // Determine how much was filled.\n-        let start = self.first.borrow().as_ref().unwrap().start() as uint;\n-        let end = self.ptr.get() as uint;\n-        let diff = (end - start) / mem::size_of::<T>();\n-\n-        // Pass that to the `destroy` method.\n         unsafe {\n-            self.first.borrow_mut().as_mut().unwrap().destroy(diff)\n+            // Determine how much was filled.\n+            let start = self.first.borrow().as_ref().unwrap().start() as uint;\n+            let end = self.ptr.get() as uint;\n+            let diff = (end - start) / mem::size_of::<T>();\n+\n+            // Pass that to the `destroy` method.\n+            (**self.first.borrow_mut()).destroy(diff)\n         }\n     }\n }"}]}