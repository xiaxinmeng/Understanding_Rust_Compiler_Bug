{"sha": "1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "node_id": "C_kwDOAAsO6NoAKDFhYWJkOGE0YTZlMTg3MWYxNGU4MDQzMDJiZDYwZGZjYmZmZDU3NjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T09:40:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-25T09:40:54Z"}, "message": "Auto merge of #93700 - rossmacarthur:ft/iter-next-chunk, r=m-ou-se\n\nAdd `Iterator::next_chunk`\n\nSee also https://github.com/rust-lang/rust/pull/92393\n\n### Prior art\n\n-  [`Itertools::next_tuple()`](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.next_tuple)\n\n### Unresolved questions\n\n- Should we also add `next_chunk_back` to `DoubleEndedIterator`?\n- Should we rather call this `next_array()` or `next_array_chunk`?", "tree": {"sha": "12bcc9025a321d57a1007b5ed053bd4811724a29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12bcc9025a321d57a1007b5ed053bd4811724a29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "html_url": "https://github.com/rust-lang/rust/commit/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02d645110ae14f4a7f04d6bd5b05f2842488dda", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02d645110ae14f4a7f04d6bd5b05f2842488dda", "html_url": "https://github.com/rust-lang/rust/commit/e02d645110ae14f4a7f04d6bd5b05f2842488dda"}, {"sha": "bbdff1fff49a6f816aa35d9b84c79b2603f0961b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbdff1fff49a6f816aa35d9b84c79b2603f0961b", "html_url": "https://github.com/rust-lang/rust/commit/bbdff1fff49a6f816aa35d9b84c79b2603f0961b"}], "stats": {"total": 131, "additions": 100, "deletions": 31}, "files": [{"sha": "c9823a136bc4214dd6d918dab330497c0537c735", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "patch": "@@ -780,24 +780,27 @@ where\n }\n \n /// Pulls `N` items from `iter` and returns them as an array. If the iterator\n-/// yields fewer than `N` items, `None` is returned and all already yielded\n-/// items are dropped.\n+/// yields fewer than `N` items, `Err` is returned containing an iterator over\n+/// the already yielded items.\n ///\n /// Since the iterator is passed as a mutable reference and this function calls\n /// `next` at most `N` times, the iterator can still be used afterwards to\n /// retrieve the remaining items.\n ///\n /// If `iter.next()` panicks, all items already yielded by the iterator are\n /// dropped.\n-fn try_collect_into_array<I, T, R, const N: usize>(iter: &mut I) -> Option<R::TryType>\n+#[inline]\n+fn try_collect_into_array<I, T, R, const N: usize>(\n+    iter: &mut I,\n+) -> Result<R::TryType, IntoIter<T, N>>\n where\n     I: Iterator,\n     I::Item: Try<Output = T, Residual = R>,\n     R: Residual<[T; N]>,\n {\n     if N == 0 {\n         // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return unsafe { Some(Try::from_output(mem::zeroed())) };\n+        return Ok(Try::from_output(unsafe { mem::zeroed() }));\n     }\n \n     struct Guard<'a, T, const N: usize> {\n@@ -821,35 +824,49 @@ where\n     let mut array = MaybeUninit::uninit_array::<N>();\n     let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n \n-    while let Some(item_rslt) = iter.next() {\n-        let item = match item_rslt.branch() {\n-            ControlFlow::Break(r) => {\n-                return Some(FromResidual::from_residual(r));\n+    for _ in 0..N {\n+        match iter.next() {\n+            Some(item_rslt) => {\n+                let item = match item_rslt.branch() {\n+                    ControlFlow::Break(r) => {\n+                        return Ok(FromResidual::from_residual(r));\n+                    }\n+                    ControlFlow::Continue(elem) => elem,\n+                };\n+\n+                // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n+                // loop and the loop is aborted once it reaches N (which is\n+                // `array.len()`).\n+                unsafe {\n+                    guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n+                }\n+                guard.initialized += 1;\n+            }\n+            None => {\n+                let alive = 0..guard.initialized;\n+                mem::forget(guard);\n+                // SAFETY: `array` was initialized with exactly `initialized`\n+                // number of elements.\n+                return Err(unsafe { IntoIter::new_unchecked(array, alive) });\n             }\n-            ControlFlow::Continue(elem) => elem,\n-        };\n-\n-        // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n-        // loop and the loop is aborted once it reaches N (which is\n-        // `array.len()`).\n-        unsafe {\n-            guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n-        }\n-        guard.initialized += 1;\n-\n-        // Check if the whole array was initialized.\n-        if guard.initialized == N {\n-            mem::forget(guard);\n-\n-            // SAFETY: the condition above asserts that all elements are\n-            // initialized.\n-            let out = unsafe { MaybeUninit::array_assume_init(array) };\n-            return Some(Try::from_output(out));\n         }\n     }\n \n-    // This is only reached if the iterator is exhausted before\n-    // `guard.initialized` reaches `N`. Also note that `guard` is dropped here,\n-    // dropping all already initialized elements.\n-    None\n+    mem::forget(guard);\n+    // SAFETY: All elements of the array were populated in the loop above.\n+    let output = unsafe { MaybeUninit::array_assume_init(array) };\n+    Ok(Try::from_output(output))\n+}\n+\n+/// Returns the next chunk of `N` items from the iterator or errors with an\n+/// iterator over the remainder. Used for `Iterator::next_chunk`.\n+#[inline]\n+pub(crate) fn iter_next_chunk<I, const N: usize>(\n+    iter: &mut I,\n+) -> Result<[I::Item; N], IntoIter<I::Item, N>>\n+where\n+    I: Iterator,\n+{\n+    let mut map = iter.map(NeverShortCircuit);\n+    try_collect_into_array(&mut map).map(|NeverShortCircuit(arr)| arr)\n }"}, {"sha": "326b98ec947d20756b9a4b61aa1c27888575e701", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "patch": "@@ -1,3 +1,4 @@\n+use crate::array;\n use crate::cmp::{self, Ordering};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n@@ -102,6 +103,47 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n+    /// Advances the iterator and returns an array containing the next `N` values.\n+    ///\n+    /// If there are not enough elements to fill the array then `Err` is returned\n+    /// containing an iterator over the remaining elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_next_chunk)]\n+    ///\n+    /// let mut iter = \"lorem\".chars();\n+    ///\n+    /// assert_eq!(iter.next_chunk().unwrap(), ['l', 'o']);              // N is inferred as 2\n+    /// assert_eq!(iter.next_chunk().unwrap(), ['r', 'e', 'm']);         // N is inferred as 3\n+    /// assert_eq!(iter.next_chunk::<4>().unwrap_err().as_slice(), &[]); // N is explicitly 4\n+    /// ```\n+    ///\n+    /// Split a string and get the first three items.\n+    ///\n+    /// ```\n+    /// #![feature(iter_next_chunk)]\n+    ///\n+    /// let quote = \"not all those who wander are lost\";\n+    /// let [first, second, third] = quote.split_whitespace().next_chunk().unwrap();\n+    /// assert_eq!(first, \"not\");\n+    /// assert_eq!(second, \"all\");\n+    /// assert_eq!(third, \"those\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_next_chunk\", reason = \"recently added\", issue = \"98326\")]\n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>>\n+    where\n+        Self: Sized,\n+    {\n+        array::iter_next_chunk(self)\n+    }\n+\n     /// Returns the bounds on the remaining length of the iterator.\n     ///\n     /// Specifically, `size_hint()` returns a tuple where the first element"}, {"sha": "37345c1d3814218d101c4773ffb90720051d09b7", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "patch": "@@ -575,6 +575,15 @@ fn iter_try_collect_uses_try_fold_not_next() {\n     // validation is just that it didn't panic.\n }\n \n+#[test]\n+fn test_next_chunk() {\n+    let mut it = 0..12;\n+    assert_eq!(it.next_chunk().unwrap(), [0, 1, 2, 3]);\n+    assert_eq!(it.next_chunk().unwrap(), []);\n+    assert_eq!(it.next_chunk().unwrap(), [4, 5, 6, 7, 8, 9]);\n+    assert_eq!(it.next_chunk::<4>().unwrap_err().as_slice(), &[10, 11]);\n+}\n+\n // just tests by whether or not this compiles\n fn _empty_impl_all_auto_traits<T>() {\n     use std::panic::{RefUnwindSafe, UnwindSafe};"}, {"sha": "9611e197a41c487c2a84cdecf0cb331d2ff55372", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aabd8a4a6e1871f14e804302bd60dfcbffd5761/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "patch": "@@ -67,6 +67,7 @@\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]\n+#![feature(iter_next_chunk)]\n #![feature(iter_order_by)]\n #![feature(iterator_try_collect)]\n #![feature(iterator_try_reduce)]"}]}