{"sha": "6ad6d8c25c399cdc001ca65801017e8c5c51e9e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDZkOGMyNWMzOTljZGMwMDFjYTY1ODAxMDE3ZThjNWM1MWU5ZTI=", "commit": {"author": {"name": "Dan Cross", "email": "dcross@google.com", "date": "2020-08-15T00:29:04Z"}, "committer": {"name": "Dan Cross", "email": "dcross@google.com", "date": "2020-08-17T17:23:29Z"}, "message": "librustc_metadata::locator: Properly detect file type.\n\nMake sure to test for file types against the non-canonicalized name\nto avoid detecting the wrong type.  Some systems save build artifacts\ninto associative file stores that do not preserve extensions, and\nthen link to those using conventionally-named symbolic links that\nare the arguments to `rustc` et al.  If we canonicalize before\ntesting the type, we resolve the symlink, the extension is lost and\nwe might treat rlibs and rmetas as dylibs.\n\nThe fix is to introduce a temporary to hold the canonicalized name,\ncompare against the non-canonical name, and add a comment\nexplaining what's going on for the would-be maintainer who sees a\npotential cleanup.\n\nSigned-off-by: Dan Cross <dcross@google.com>", "tree": {"sha": "08919bb4238e6ce83a1ea1c8e949445bbdbd3c79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08919bb4238e6ce83a1ea1c8e949445bbdbd3c79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2", "html_url": "https://github.com/rust-lang/rust/commit/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2/comments", "author": null, "committer": null, "parents": [{"sha": "e8df0b893235aa06c6362d1a8646296310f79f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8df0b893235aa06c6362d1a8646296310f79f81", "html_url": "https://github.com/rust-lang/rust/commit/e8df0b893235aa06c6362d1a8646296310f79f81"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "8fa14a44f527e48fa6fef3071314e03cfad4a840", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad6d8c25c399cdc001ca65801017e8c5c51e9e2/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=6ad6d8c25c399cdc001ca65801017e8c5c51e9e2", "patch": "@@ -685,13 +685,19 @@ impl<'a> CrateLocator<'a> {\n                     && file.ends_with(&self.target.options.dll_suffix)\n             {\n                 // Make sure there's at most one rlib and at most one dylib.\n-                let loc = fs::canonicalize(&loc).unwrap_or_else(|_| loc.clone());\n+                // Note to take care and match against the non-canonicalized name:\n+                // some systems save build artifacts into content-addressed stores\n+                // that do not preserve extensions, and then link to them using\n+                // e.g. symbolic links. If we canonicalize too early, we resolve\n+                // the symlink, the file type is lost and we might treat rlibs and\n+                // rmetas as dylibs.\n+                let loc_canon = fs::canonicalize(&loc).unwrap_or_else(|_| loc.clone());\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(loc, PathKind::ExternFlag);\n+                    rlibs.insert(loc_canon, PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n-                    rmetas.insert(loc, PathKind::ExternFlag);\n+                    rmetas.insert(loc_canon, PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(loc, PathKind::ExternFlag);\n+                    dylibs.insert(loc_canon, PathKind::ExternFlag);\n                 }\n             } else {\n                 self.rejected_via_filename"}]}