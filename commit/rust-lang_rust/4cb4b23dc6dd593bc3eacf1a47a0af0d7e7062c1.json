{"sha": "4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYjRiMjNkYzZkZDU5M2JjM2VhY2YxYTQ3YTBhZjBkN2U3MDYyYzE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-31T17:12:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-31T17:12:01Z"}, "message": "Merge #9084 #9087\n\n9084: fix: avoid panics in match case diagnostic r=matklad a=matklad\n\nbors r+\r\n\ud83e\udd16\r\n\r\ncloses #8809\n\n9087: fix: fix shell injection in task spawning r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a6202420f5e88f645f4bd9f49a13e4c8451d5dfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6202420f5e88f645f4bd9f49a13e4c8451d5dfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgtRjhCRBK7hj4Ov3rIwAAVDMIAFwm4cC3AtobROZ7Yh+mSQAo\nlOpXcx/qHP7inZuUCLKlN/EU+h8vhZhe5TT1a9IdGBGE1TCdH0XNd0GyLmXcE/7A\nRrV4EmRiKOUEeYUvRRErXcaBBMrM1kcZeFqiyNkzO5eRr/0Mttf3JpsoqP41KRn0\nsMIi/ranWMSXv1OO1WTn/2vCYd2N92Vnjg7Yp4Er19uDq8xQKEI22dx70+skNxOm\nzEt39Cp5xNHSYEtidRLVys4zaAFH7LaRodsqUJYQs4Ae1betGaWyPRsQzT6WwH2K\n02XywJjgjFV4IzdXNbgUYJsQ56sLT0LKc0Xhg8VgPuRKDRuA81F4MUpWHw4JaEY=\n=d4e8\n-----END PGP SIGNATURE-----\n", "payload": "tree a6202420f5e88f645f4bd9f49a13e4c8451d5dfc\nparent 020610f4539f5d553179e0b4dae46cae9db93e41\nparent 159922de93bd0437093f9ca07eda4673ba285b89\nparent ee995dbfd441e20bba21306c41aec0049c1d7da4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622481121 +0000\ncommitter GitHub <noreply@github.com> 1622481121 +0000\n\nMerge #9084 #9087\n\n9084: fix: avoid panics in match case diagnostic r=matklad a=matklad\n\nbors r+\r\n\ud83e\udd16\r\n\r\ncloses #8809\n\n9087: fix: fix shell injection in task spawning r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "html_url": "https://github.com/rust-lang/rust/commit/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "020610f4539f5d553179e0b4dae46cae9db93e41", "url": "https://api.github.com/repos/rust-lang/rust/commits/020610f4539f5d553179e0b4dae46cae9db93e41", "html_url": "https://github.com/rust-lang/rust/commit/020610f4539f5d553179e0b4dae46cae9db93e41"}, {"sha": "159922de93bd0437093f9ca07eda4673ba285b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/159922de93bd0437093f9ca07eda4673ba285b89", "html_url": "https://github.com/rust-lang/rust/commit/159922de93bd0437093f9ca07eda4673ba285b89"}, {"sha": "ee995dbfd441e20bba21306c41aec0049c1d7da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee995dbfd441e20bba21306c41aec0049c1d7da4", "html_url": "https://github.com/rust-lang/rust/commit/ee995dbfd441e20bba21306c41aec0049c1d7da4"}], "stats": {"total": 161, "additions": 43, "deletions": 118}, "files": [{"sha": "283894704473bfa9093f08e7ac0b400064a8633f", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "patch": "@@ -349,11 +349,11 @@ impl fmt::Display for CaseType {\n \n #[derive(Debug)]\n pub enum IdentType {\n-    Argument,\n     Constant,\n     Enum,\n     Field,\n     Function,\n+    Parameter,\n     StaticVariable,\n     Structure,\n     Variable,\n@@ -363,11 +363,11 @@ pub enum IdentType {\n impl fmt::Display for IdentType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let repr = match self {\n-            IdentType::Argument => \"Argument\",\n             IdentType::Constant => \"Constant\",\n             IdentType::Enum => \"Enum\",\n             IdentType::Field => \"Field\",\n             IdentType::Function => \"Function\",\n+            IdentType::Parameter => \"Parameter\",\n             IdentType::StaticVariable => \"Static variable\",\n             IdentType::Structure => \"Structure\",\n             IdentType::Variable => \"Variable\","}, {"sha": "cfb5d73200f59a7ce402cf5335b9bca1c9a6ca80", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 35, "deletions": 110, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "patch": "@@ -150,29 +150,11 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             expected_case: CaseType::LowerSnakeCase,\n         });\n \n-        // Check the param names.\n-        let fn_param_replacements = body\n-            .params\n-            .iter()\n-            .filter_map(|&id| match &body[id] {\n-                Pat::Bind { name, .. } => Some(name),\n-                _ => None,\n-            })\n-            .filter_map(|param_name| {\n-                Some(Replacement {\n-                    current_name: param_name.clone(),\n-                    suggested_text: to_lower_snake_case(&param_name.to_string())?,\n-                    expected_case: CaseType::LowerSnakeCase,\n-                })\n-            })\n-            .collect();\n-\n         // Check the patterns inside the function body.\n+        // This includes function parameters.\n         let pats_replacements = body\n             .pats\n             .iter()\n-            // We aren't interested in function parameters, we've processed them above.\n-            .filter(|(pat_idx, _)| !body.params.contains(&pat_idx))\n             .filter_map(|(id, pat)| match pat {\n                 Pat::Bind { name, .. } => Some((id, name)),\n                 _ => None,\n@@ -190,11 +172,10 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n             .collect();\n \n         // If there is at least one element to spawn a warning on, go to the source map and generate a warning.\n-        self.create_incorrect_case_diagnostic_for_func(\n-            func,\n-            fn_name_replacement,\n-            fn_param_replacements,\n-        );\n+        if let Some(fn_name_replacement) = fn_name_replacement {\n+            self.create_incorrect_case_diagnostic_for_func(func, fn_name_replacement);\n+        }\n+\n         self.create_incorrect_case_diagnostic_for_variables(func, pats_replacements);\n     }\n \n@@ -203,100 +184,34 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n     fn create_incorrect_case_diagnostic_for_func(\n         &mut self,\n         func: FunctionId,\n-        fn_name_replacement: Option<Replacement>,\n-        fn_param_replacements: Vec<Replacement>,\n+        fn_name_replacement: Replacement,\n     ) {\n-        // XXX: only look at sources if we do have incorrect names\n-        if fn_name_replacement.is_none() && fn_param_replacements.is_empty() {\n-            return;\n-        }\n-\n         let fn_loc = func.lookup(self.db.upcast());\n         let fn_src = fn_loc.source(self.db.upcast());\n \n         // Diagnostic for function name.\n-        if let Some(replacement) = fn_name_replacement {\n-            let ast_ptr = match fn_src.value.name() {\n-                Some(name) => name,\n-                None => {\n-                    never!(\n-                        \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n-                        replacement,\n-                        fn_src\n-                    );\n-                    return;\n-                }\n-            };\n-\n-            let diagnostic = IncorrectCase {\n-                file: fn_src.file_id,\n-                ident_type: IdentType::Function,\n-                ident: AstPtr::new(&ast_ptr),\n-                expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n-                suggested_text: replacement.suggested_text,\n-            };\n-\n-            self.sink.push(diagnostic);\n-        }\n-\n-        // Diagnostics for function params.\n-        let fn_params_list = match fn_src.value.param_list() {\n-            Some(params) => params,\n+        let ast_ptr = match fn_src.value.name() {\n+            Some(name) => name,\n             None => {\n-                always!(\n-                    fn_param_replacements.is_empty(),\n-                    \"Replacements ({:?}) were generated for a function parameters which had no parameters list: {:?}\",\n-                    fn_param_replacements,\n+                never!(\n+                    \"Replacement ({:?}) was generated for a function without a name: {:?}\",\n+                    fn_name_replacement,\n                     fn_src\n                 );\n                 return;\n             }\n         };\n-        let mut fn_params_iter = fn_params_list.params();\n-        for param_to_rename in fn_param_replacements {\n-            // We assume that parameters in replacement are in the same order as in the\n-            // actual params list, but just some of them (ones that named correctly) are skipped.\n-            let ast_ptr: ast::Name = loop {\n-                match fn_params_iter.next() {\n-                    Some(element) => {\n-                        if let Some(ast::Pat::IdentPat(pat)) = element.pat() {\n-                            if pat.to_string() == param_to_rename.current_name.to_string() {\n-                                if let Some(name) = pat.name() {\n-                                    break name;\n-                                }\n-                                // This is critical. If we consider this parameter the expected one,\n-                                // it **must** have a name.\n-                                never!(\n-                                    \"Pattern {:?} equals to expected replacement {:?}, but has no name\",\n-                                    element,\n-                                    param_to_rename\n-                                );\n-                                return;\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        never!(\n-                            \"Replacement ({:?}) was generated for a function parameter which was not found: {:?}\",\n-                            param_to_rename, fn_src\n-                        );\n-                        return;\n-                    }\n-                }\n-            };\n \n-            let diagnostic = IncorrectCase {\n-                file: fn_src.file_id,\n-                ident_type: IdentType::Argument,\n-                ident: AstPtr::new(&ast_ptr),\n-                expected_case: param_to_rename.expected_case,\n-                ident_text: param_to_rename.current_name.to_string(),\n-                suggested_text: param_to_rename.suggested_text,\n-            };\n+        let diagnostic = IncorrectCase {\n+            file: fn_src.file_id,\n+            ident_type: IdentType::Function,\n+            ident: AstPtr::new(&ast_ptr),\n+            expected_case: fn_name_replacement.expected_case,\n+            ident_text: fn_name_replacement.current_name.to_string(),\n+            suggested_text: fn_name_replacement.suggested_text,\n+        };\n \n-            self.sink.push(diagnostic);\n-        }\n+        self.sink.push(diagnostic);\n     }\n \n     /// Given the information about incorrect variable names, looks up into the source code\n@@ -327,20 +242,25 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n                             None => continue,\n                         };\n \n+                        let is_param = ast::Param::can_cast(parent.kind());\n+\n                         // We have to check that it's either `let var = ...` or `var @ Variant(_)` statement,\n                         // because e.g. match arms are patterns as well.\n                         // In other words, we check that it's a named variable binding.\n                         let is_binding = ast::LetStmt::can_cast(parent.kind())\n                             || (ast::MatchArm::can_cast(parent.kind())\n                                 && ident_pat.at_token().is_some());\n-                        if !is_binding {\n+                        if !(is_param || is_binding) {\n                             // This pattern is not an actual variable declaration, e.g. `Some(val) => {..}` match arm.\n                             continue;\n                         }\n \n+                        let ident_type =\n+                            if is_param { IdentType::Parameter } else { IdentType::Variable };\n+\n                         let diagnostic = IncorrectCase {\n                             file: source_ptr.file_id,\n-                            ident_type: IdentType::Variable,\n+                            ident_type,\n                             ident: AstPtr::new(&name_ast),\n                             expected_case: replacement.expected_case,\n                             ident_text: replacement.current_name.to_string(),\n@@ -408,7 +328,7 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         struct_name_replacement: Option<Replacement>,\n         struct_fields_replacements: Vec<Replacement>,\n     ) {\n-        // XXX: only look at sources if we do have incorrect names\n+        // XXX: Only look at sources if we do have incorrect names.\n         if struct_name_replacement.is_none() && struct_fields_replacements.is_empty() {\n             return;\n         }\n@@ -723,10 +643,10 @@ fn NonSnakeCaseName() {}\n         check_diagnostics(\n             r#\"\n fn foo(SomeParam: u8) {}\n-    // ^^^^^^^^^ Argument `SomeParam` should have snake_case name, e.g. `some_param`\n+    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n \n fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n-                     // ^^^^^^^^^^ Argument `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n+                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n \"#,\n         );\n     }\n@@ -1037,4 +957,9 @@ fn qualify() {\n             \"#,\n         )\n     }\n+\n+    #[test] // Issue #8809.\n+    fn parenthesized_parameter() {\n+        check_diagnostics(r#\"fn f((O): _) {}\"#)\n+    }\n }"}, {"sha": "947b3f2e46e7b4332d4e55e87110ee787690e313", "filename": "editors/code/src/tasks.ts", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/editors%2Fcode%2Fsrc%2Ftasks.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1/editors%2Fcode%2Fsrc%2Ftasks.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftasks.ts?ref=4cb4b23dc6dd593bc3eacf1a47a0af0d7e7062c1", "patch": "@@ -80,7 +80,7 @@ export async function buildCargoTask(\n     throwOnError: boolean = false\n ): Promise<vscode.Task> {\n \n-    let exec: vscode.ShellExecution | undefined = undefined;\n+    let exec: vscode.ProcessExecution | vscode.ShellExecution | undefined = undefined;\n \n     if (customRunner) {\n         const runnerCommand = `${customRunner}.buildShellExecution`;\n@@ -105,13 +105,13 @@ export async function buildCargoTask(\n \n     if (!exec) {\n         // Check whether we must use a user-defined substitute for cargo.\n-        const cargoCommand = definition.overrideCargo ? definition.overrideCargo : toolchain.cargoPath();\n+        // Split on spaces to allow overrides like \"wrapper cargo\".\n+        const overrideCargo = definition.overrideCargo ?? definition.overrideCargo;\n+        const cargoCommand = overrideCargo?.split(\" \") ?? [toolchain.cargoPath()];\n \n-        // Prepare the whole command as one line. It is required if user has provided override command which contains spaces,\n-        // for example \"wrapper cargo\". Without manual preparation the overridden command will be quoted and fail to execute.\n-        const fullCommand = [cargoCommand, ...args].join(\" \");\n+        const fullCommand = [...cargoCommand, ...args];\n \n-        exec = new vscode.ShellExecution(fullCommand, definition);\n+        exec = new vscode.ProcessExecution(fullCommand[0], fullCommand.slice(1), definition);\n     }\n \n     return new vscode.Task("}]}