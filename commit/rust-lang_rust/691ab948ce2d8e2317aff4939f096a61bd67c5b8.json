{"sha": "691ab948ce2d8e2317aff4939f096a61bd67c5b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MWFiOTQ4Y2UyZDhlMjMxN2FmZjQ5MzlmMDk2YTYxYmQ2N2M1Yjg=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-10-24T22:41:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-24T22:41:29Z"}, "message": "Rollup merge of #37336 - michaelwoerister:debuginfo-type-ids, r=eddyb\n\ndebuginfo: Use TypeIdHasher for generating global debuginfo type IDs.\n\nThe only requirement for debuginfo type IDs is that they are globally unique. The `TypeIdHasher` (which is used for `std::intrinsic::type_id()` provides that, so we can get rid of some redundancy by re-using it for debuginfo. Values produced by the `TypeIdHasher` are also more stable than the current `UniqueTypeId` generation algorithm produces -- these incorporate the `NodeId`s, which is not good for incremental compilation.\n\n@alexcrichton @eddyb : Could you take a look at the endianess adaptations that I made to the `TypeIdHasher`?\n\nAlso, are we sure that a 64 bit hash is wide enough for something that is supposed to be globally unique? For debuginfo I'm using 160 bits to make sure that we don't run into conflicts there.", "tree": {"sha": "41110215380d872afe20dddc61e86b52a475e433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41110215380d872afe20dddc61e86b52a475e433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/691ab948ce2d8e2317aff4939f096a61bd67c5b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/691ab948ce2d8e2317aff4939f096a61bd67c5b8", "html_url": "https://github.com/rust-lang/rust/commit/691ab948ce2d8e2317aff4939f096a61bd67c5b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/691ab948ce2d8e2317aff4939f096a61bd67c5b8/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7da61975f168ff91c55233f489923fa1acd47e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7da61975f168ff91c55233f489923fa1acd47e9", "html_url": "https://github.com/rust-lang/rust/commit/e7da61975f168ff91c55233f489923fa1acd47e9"}, {"sha": "025b27d6c8ba291aececc72eb8b0e5b8232d939d", "url": "https://api.github.com/repos/rust-lang/rust/commits/025b27d6c8ba291aececc72eb8b0e5b8232d939d", "html_url": "https://github.com/rust-lang/rust/commit/025b27d6c8ba291aececc72eb8b0e5b8232d939d"}], "stats": {"total": 305, "additions": 79, "deletions": 226}, "files": [{"sha": "bb36fa1487eeea578bc2dcf062ce9b1ea48db5c3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/691ab948ce2d8e2317aff4939f096a61bd67c5b8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691ab948ce2d8e2317aff4939f096a61bd67c5b8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=691ab948ce2d8e2317aff4939f096a61bd67c5b8", "patch": "@@ -392,27 +392,30 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-// When hashing a type this ends up affecting properties like symbol names. We\n-// want these symbol names to be calculated independent of other factors like\n-// what architecture you're compiling *from*.\n-//\n-// The hashing just uses the standard `Hash` trait, but the implementations of\n-// `Hash` for the `usize` and `isize` types are *not* architecture independent\n-// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n-// `isize` completely when hashing. To ensure that these don't leak in we use a\n-// custom hasher implementation here which inflates the size of these to a `u64`\n-// and `i64`.\n-struct WidenUsizeHasher<H> {\n+/// When hashing a type this ends up affecting properties like symbol names. We\n+/// want these symbol names to be calculated independent of other factors like\n+/// what architecture you're compiling *from*.\n+///\n+/// The hashing just uses the standard `Hash` trait, but the implementations of\n+/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+/// `isize` completely when hashing. To ensure that these don't leak in we use a\n+/// custom hasher implementation here which inflates the size of these to a `u64`\n+/// and `i64`.\n+///\n+/// The same goes for endianess: We always convert multi-byte integers to little\n+/// endian before hashing.\n+pub struct ArchIndependentHasher<H> {\n     inner: H,\n }\n \n-impl<H> WidenUsizeHasher<H> {\n-    fn new(inner: H) -> WidenUsizeHasher<H> {\n-        WidenUsizeHasher { inner: inner }\n+impl<H> ArchIndependentHasher<H> {\n+    pub fn new(inner: H) -> ArchIndependentHasher<H> {\n+        ArchIndependentHasher { inner: inner }\n     }\n }\n \n-impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n+impl<H: Hasher> Hasher for ArchIndependentHasher<H> {\n     fn write(&mut self, bytes: &[u8]) {\n         self.inner.write(bytes)\n     }\n@@ -425,44 +428,44 @@ impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n         self.inner.write_u8(i)\n     }\n     fn write_u16(&mut self, i: u16) {\n-        self.inner.write_u16(i)\n+        self.inner.write_u16(i.to_le())\n     }\n     fn write_u32(&mut self, i: u32) {\n-        self.inner.write_u32(i)\n+        self.inner.write_u32(i.to_le())\n     }\n     fn write_u64(&mut self, i: u64) {\n-        self.inner.write_u64(i)\n+        self.inner.write_u64(i.to_le())\n     }\n     fn write_usize(&mut self, i: usize) {\n-        self.inner.write_u64(i as u64)\n+        self.inner.write_u64((i as u64).to_le())\n     }\n     fn write_i8(&mut self, i: i8) {\n         self.inner.write_i8(i)\n     }\n     fn write_i16(&mut self, i: i16) {\n-        self.inner.write_i16(i)\n+        self.inner.write_i16(i.to_le())\n     }\n     fn write_i32(&mut self, i: i32) {\n-        self.inner.write_i32(i)\n+        self.inner.write_i32(i.to_le())\n     }\n     fn write_i64(&mut self, i: i64) {\n-        self.inner.write_i64(i)\n+        self.inner.write_i64(i.to_le())\n     }\n     fn write_isize(&mut self, i: isize) {\n-        self.inner.write_i64(i as i64)\n+        self.inner.write_i64((i as i64).to_le())\n     }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: WidenUsizeHasher<H>,\n+    state: ArchIndependentHasher<H>,\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n         TypeIdHasher {\n             tcx: tcx,\n-            state: WidenUsizeHasher::new(state),\n+            state: ArchIndependentHasher::new(state),\n         }\n     }\n \n@@ -493,6 +496,10 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n         def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n+\n+    pub fn into_inner(self) -> H {\n+        self.state.inner\n+    }\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {"}, {"sha": "2804e3ffe37ddd2ca30f06b3da7009146e0704d9", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 47, "deletions": 201, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/691ab948ce2d8e2317aff4939f096a61bd67c5b8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/691ab948ce2d8e2317aff4939f096a61bd67c5b8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=691ab948ce2d8e2317aff4939f096a61bd67c5b8", "patch": "@@ -16,7 +16,7 @@ use self::EnumDiscriminantInfo::*;\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                    get_namespace_and_span_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n-use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n+use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use context::SharedCrateContext;\n use session::Session;\n@@ -26,8 +26,11 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DI\n \n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::DefId;\n+use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n+use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n+use rustc_data_structures::blake2b;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -38,6 +41,7 @@ use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n+use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n@@ -46,6 +50,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax_pos::{self, Span};\n \n+\n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n const DW_LANG_RUST: c_uint = 0x1c;\n@@ -138,219 +143,58 @@ impl<'tcx> TypeMap<'tcx> {\n     // ID will be generated and stored for later lookup.\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n-\n-        // basic type             -> {:name of the type:}\n-        // tuple                  -> {tuple_(:param-uid:)*}\n-        // struct                 -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                   -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant           -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)          -> {& :pointee-uid:}\n-        // mut reference (&mut)   -> {&mut :pointee-uid:}\n-        // ptr (*)                -> {* :pointee-uid:}\n-        // mut ptr (*mut)         -> {*mut :pointee-uid:}\n-        // unique ptr (box)       -> {box :pointee-uid:}\n-        // @-ptr (@)              -> {@ :pointee-uid:}\n-        // sized vec ([T; x])     -> {[:size:] :element-uid:}\n-        // unsized vec ([T])      -> {[] :element-uid:}\n-        // trait (T)              -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure                -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n-        //                             :return-type-uid: : (:bounds:)*}\n-        // function               -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n-        //                             :return-type-uid:}\n-\n+        // Let's see if we already have something in the cache\n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n \n-        let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push('{');\n-\n-        match type_.sty {\n-            ty::TyNever    |\n-            ty::TyBool     |\n-            ty::TyChar     |\n-            ty::TyStr      |\n-            ty::TyInt(_)   |\n-            ty::TyUint(_)  |\n-            ty::TyFloat(_) => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyAdt(def, substs) => {\n-                unique_type_id.push_str(&(String::from(def.descr()) + \" \"));\n-                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            }\n-            ty::TyTuple(component_types) if component_types.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyTuple(component_types) => {\n-                unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types {\n-                    let component_type_id =\n-                        self.get_unique_type_id_of_type(cx, component_type);\n-                    let component_type_id =\n-                        self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[..]);\n-                }\n-            },\n-            ty::TyBox(inner_type) => {\n-                unique_type_id.push_str(\"box \");\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push('*');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-                unique_type_id.push('&');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyArray(inner_type, len) => {\n-                unique_type_id.push_str(&format!(\"[{}]\", len));\n+        let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n+                                                   DebugInfoTypeIdHasher::new());\n+        type_id_hasher.visit_ty(type_);\n+        let hash = type_id_hasher.into_inner().into_hash();\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TySlice(inner_type) => {\n-                unique_type_id.push_str(\"[]\");\n+        let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyTrait(ref trait_data) => {\n-                unique_type_id.push_str(\"trait \");\n-\n-                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n-                    &trait_data.principal);\n-\n-                from_def_id_and_substs(self,\n-                                       cx,\n-                                       principal.def_id,\n-                                       principal.substs,\n-                                       &mut unique_type_id);\n-            },\n-            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-                if unsafety == hir::Unsafety::Unsafe {\n-                    unique_type_id.push_str(\"unsafe \");\n-                }\n+        for byte in hash.into_iter() {\n+            write!(&mut unique_type_id, \"{:x}\", byte).unwrap();\n+        }\n \n-                unique_type_id.push_str(abi.name());\n+        let key = self.unique_id_interner.intern(&unique_type_id);\n+        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-                unique_type_id.push_str(\" fn(\");\n+        return UniqueTypeId(key);\n \n-                let sig = cx.tcx().erase_late_bound_regions_and_normalize(sig);\n+        // The hasher we are using to generate the UniqueTypeId. We want\n+        // something that provides more than the 64 bits of the DefaultHasher.\n+        const TYPE_ID_HASH_LENGTH: usize = 20;\n \n-                for &parameter_type in &sig.inputs {\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[..]);\n-                    unique_type_id.push(',');\n-                }\n-\n-                if sig.variadic {\n-                    unique_type_id.push_str(\"...\");\n-                }\n+        struct DebugInfoTypeIdHasher {\n+            state: blake2b::Blake2bCtx\n+        }\n \n-                unique_type_id.push_str(\")->\");\n-                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[..]);\n-            },\n-            ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyClosure(_, substs) => {\n-                unique_type_id.push_str(\"closure \");\n-                for upvar_type in substs.upvar_tys {\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_of_type(cx, upvar_type);\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_as_string(upvar_type_id);\n-                    unique_type_id.push_str(&upvar_type_id[..]);\n-                }\n-            },\n-            _ => {\n-                bug!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n-                     type_)\n+        impl ::std::hash::Hasher for DebugInfoTypeIdHasher {\n+            fn finish(&self) -> u64 {\n+                unimplemented!()\n             }\n-        };\n-\n-        unique_type_id.push('}');\n-\n-        // Trim to size before storing permanently\n-        unique_type_id.shrink_to_fit();\n-\n-        let key = self.unique_id_interner.intern(&unique_type_id);\n-        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-        return UniqueTypeId(key);\n-\n-        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n-                                            cx: &CrateContext<'a, 'tcx>,\n-                                            def_id: DefId,\n-                                            substs: &Substs<'tcx>,\n-                                            output: &mut String) {\n-            // First, find out the 'real' def_id of the type. Items inlined from\n-            // other crates have to be mapped back to their source.\n-            let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                if cx.tcx().map.is_inlined_node_id(node_id) {\n-                    // The given def_id identifies the inlined copy of a\n-                    // type definition, let's take the source of the copy.\n-                    cx.defid_for_inlined_node(node_id).unwrap()\n-                } else {\n-                    def_id\n-                }\n-            } else {\n-                def_id\n-            };\n+            #[inline]\n+            fn write(&mut self, bytes: &[u8]) {\n+                blake2b::blake2b_update(&mut self.state, bytes);\n+            }\n+        }\n \n-            // Get the crate name/disambiguator as first part of the identifier.\n-            let crate_name = if def_id.is_local() {\n-                cx.tcx().crate_name.clone()\n-            } else {\n-                cx.sess().cstore.original_crate_name(def_id.krate)\n-            };\n-            let crate_disambiguator = cx.tcx().crate_disambiguator(def_id.krate);\n-\n-            output.push_str(&crate_name[..]);\n-            output.push_str(\"/\");\n-            output.push_str(&crate_disambiguator[..]);\n-            output.push_str(\"/\");\n-            // Add the def-index as the second part\n-            output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n-\n-            if substs.types().next().is_some() {\n-                output.push('<');\n-\n-                for type_parameter in substs.types() {\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[..]);\n-                    output.push(',');\n+        impl DebugInfoTypeIdHasher {\n+            fn new() -> DebugInfoTypeIdHasher {\n+                DebugInfoTypeIdHasher {\n+                    state: blake2b::blake2b_new(TYPE_ID_HASH_LENGTH, &[])\n                 }\n+            }\n \n-                output.push('>');\n+            fn into_hash(self) -> [u8; TYPE_ID_HASH_LENGTH] {\n+                let mut hash = [0u8; TYPE_ID_HASH_LENGTH];\n+                blake2b::blake2b_final(self.state, &mut hash);\n+                hash\n             }\n         }\n     }\n@@ -1927,15 +1771,17 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n+    let tcx = cx.tcx();\n+\n     // Don't create debuginfo for globals inlined from other crates. The other\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.tcx().map.is_inlined_node_id(node_id) {\n+    if tcx.map.is_inlined_node_id(node_id) {\n         return;\n     }\n \n-    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let node_def_id = tcx.map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n@@ -1946,9 +1792,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = cx.tcx().node_id_to_type(node_id);\n+    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = cx.tcx().item_name(node_def_id).to_string();\n+    let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");\n \n     let var_name = CString::new(var_name).unwrap();"}]}