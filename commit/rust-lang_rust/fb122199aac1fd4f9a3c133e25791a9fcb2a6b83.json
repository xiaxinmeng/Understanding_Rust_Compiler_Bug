{"sha": "fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMTIyMTk5YWFjMWZkNGY5YTNjMTMzZTI1NzkxYTlmY2IyYTZiODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-20T16:36:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-20T16:36:25Z"}, "message": "Auto merge of #37896 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\n- Successful merges: #37835, #37840, #37841, #37848, #37876, #37880, #37881, #37882\n- Failed merges:", "tree": {"sha": "3c1c658739c3d2da3bf266791c3294b483a77a94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c1c658739c3d2da3bf266791c3294b483a77a94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "html_url": "https://github.com/rust-lang/rust/commit/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f8944e21a3ff506897d4aaa9ca292fec209cff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8944e21a3ff506897d4aaa9ca292fec209cff2", "html_url": "https://github.com/rust-lang/rust/commit/8f8944e21a3ff506897d4aaa9ca292fec209cff2"}, {"sha": "b0354fe8738d9302174dc0236847178712ded9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0354fe8738d9302174dc0236847178712ded9c3", "html_url": "https://github.com/rust-lang/rust/commit/b0354fe8738d9302174dc0236847178712ded9c3"}], "stats": {"total": 1207, "additions": 1183, "deletions": 24}, "files": [{"sha": "140e27d19248ce3a936d5570740b7d537e13338b", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -352,7 +352,7 @@ to it.\n Rust supports powerful local type inference in the bodies of functions but not in their item signatures. \n It's forbidden to allow reasoning about types based on the item signature alone. \n However, for ergonomic reasons, a very restricted secondary inference algorithm called \n-\u201clifetime elision\u201d does apply when judging lifetimes. Lifetime elision is concerned solely to infer \n+\u201clifetime elision\u201d does apply when judging lifetimes. Lifetime elision is concerned solely with inferring \n lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision \n acts as a shorthand for writing an item signature, while not hiding\n away the actual types involved as full local inference would if applied to it."}, {"sha": "4fbe518396760dbd66cc32f26edf514cab2ce776", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -2474,18 +2474,19 @@ The currently implemented features of the reference compiler are:\n                               internally without imposing on callers\n                               (i.e. making them behave like function calls in\n                               terms of encapsulation).\n-* - `default_type_parameter_fallback` - Allows type parameter defaults to\n-                                        influence type inference.\n \n-* - `stmt_expr_attributes` - Allows attributes on expressions.\n+* `default_type_parameter_fallback` - Allows type parameter defaults to\n+                                      influence type inference.\n \n-* - `type_ascription` - Allows type ascription expressions `expr: Type`.\n+* `stmt_expr_attributes` - Allows attributes on expressions.\n \n-* - `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n-                             (e.g. `extern \"vectorcall\" func fn_();`)\n+* `type_ascription` - Allows type ascription expressions `expr: Type`.\n \n-* - `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n-                             (e.g. `extern \"sysv64\" func fn_();`)\n+* `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n+                     (e.g. `extern \"vectorcall\" func fn_();`)\n+\n+* `abi_sysv64` - Allows the usage of the system V AMD64 calling convention\n+                 (e.g. `extern \"sysv64\" func fn_();`)\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled"}, {"sha": "ebbfbefc21b66709d532fa0d03d8ddf2b4e1571e", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -814,6 +814,14 @@ fn test_iterator_clone() {\n     assert!(it.clone().zip(it).all(|(x,y)| x == y));\n }\n \n+#[test]\n+fn test_iterator_last() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut it = s.chars();\n+    it.next();\n+    assert_eq!(it.last(), Some('m'));\n+}\n+\n #[test]\n fn test_bytesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -911,6 +919,14 @@ fn test_char_indices_revator() {\n     assert_eq!(pos, p.len());\n }\n \n+#[test]\n+fn test_char_indices_last() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let mut it = s.char_indices();\n+    it.next();\n+    assert_eq!(it.last(), Some((27, 'm')));\n+}\n+\n #[test]\n fn test_splitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "1bd6188f4875a9bce726f13dd2f9c6fd5b4eefe7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -432,6 +432,12 @@ impl<'a> Iterator for Chars<'a> {\n         // `isize::MAX` (that's well below `usize::MAX`).\n         ((len + 3) / 4, Some(len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -505,6 +511,12 @@ impl<'a> Iterator for CharIndices<'a> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(usize, char)> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e2d3a4f453749aafb0822d4224f20f8d3b759b33", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -344,7 +344,7 @@ impl<'tcx, K, V> UnificationTable<K>\n     }\n \n     pub fn probe(&mut self, a_id: K) -> Option<V> {\n-        self.get(a_id).value.clone()\n+        self.get(a_id).value\n     }\n \n     pub fn unsolved_variables(&mut self) -> Vec<K> {"}, {"sha": "093a023291ac43a11dc56cc333d305223efd4088", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -4436,19 +4436,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n         if lifetimes.len() > lifetime_defs.len() {\n             let span = lifetimes[lifetime_defs.len()].span;\n-            span_err!(self.tcx.sess, span, E0088,\n-                      \"too many lifetime parameters provided: \\\n-                       expected {}, found {}\",\n-                      count(lifetime_defs.len()),\n-                      count(lifetimes.len()));\n-        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n-            span_err!(self.tcx.sess, span, E0090,\n-                      \"too few lifetime parameters provided: \\\n-                       expected {}, found {}\",\n-                      count(lifetime_defs.len()),\n-                      count(lifetimes.len()));\n+            struct_span_err!(self.tcx.sess, span, E0088,\n+                             \"too many lifetime parameters provided: \\\n+                              expected {}, found {}\",\n+                              count(lifetime_defs.len()),\n+                              count(lifetimes.len()))\n+                .span_label(span, &format!(\"unexpected lifetime parameter{}\",\n+                                           match lifetimes.len() { 1 => \"\", _ => \"s\" }))\n+                .emit();\n         }\n \n+        // The case where there is not enough lifetime parameters is not checked,\n+        // because this is not possible - a function never takes lifetime parameters.\n+        // See discussion for Pull Request 36208.\n+\n         // Check provided type parameters.\n         let type_defs = segment.map_or(&[][..], |(_, generics)| {\n             if generics.parent.is_none() {"}, {"sha": "31fbcb5059f82188f25ee6f370e788a8fa3ec827", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -2437,7 +2437,6 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         write!(w, \"}}\")?;\n     }\n     write!(w, \"</pre>\")?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n@@ -3053,7 +3052,6 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                                                      Some(\"macro\"),\n                                                      None,\n                                                      None))?;\n-    render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }\n "}, {"sha": "1c016015b7928c9b9da3343bc6fb81b9a7e901b4", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -31,7 +31,7 @@ pub enum SocketAddr {\n     /// An IPv4 socket address which is a (ip, port) combination.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n-    /// An IPv6 socket address\n+    /// An IPv6 socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n }\n@@ -48,6 +48,16 @@ pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n \n impl SocketAddr {\n     /// Creates a new socket address from the (ip, port) pair.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n         match ip {\n@@ -57,6 +67,15 @@ impl SocketAddr {\n     }\n \n     /// Returns the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n+    /// ```\n     #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n     pub fn ip(&self) -> IpAddr {\n         match *self {\n@@ -66,6 +85,16 @@ impl SocketAddr {\n     }\n \n     /// Change the IP address associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n+    /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_ip(&mut self, new_ip: IpAddr) {\n         // `match (*self, new_ip)` would have us mutate a copy of self only to throw it away.\n@@ -77,6 +106,15 @@ impl SocketAddr {\n     }\n \n     /// Returns the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.port(), 8080);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n         match *self {\n@@ -86,6 +124,16 @@ impl SocketAddr {\n     }\n \n     /// Change the port number associated with this socket address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// socket.set_port(1025);\n+    /// assert_eq!(socket.port(), 1025);\n+    /// ```\n     #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n     pub fn set_port(&mut self, new_port: u16) {\n         match *self {\n@@ -96,6 +144,20 @@ impl SocketAddr {\n \n     /// Returns true if the IP in this `SocketAddr` is a valid IPv4 address,\n     /// false if it's a valid IPv6 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(sockaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    ///\n+    /// fn main() {\n+    ///     let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    ///     assert_eq!(socket.is_ipv4(), true);\n+    ///     assert_eq!(socket.is_ipv6(), false);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n@@ -106,6 +168,21 @@ impl SocketAddr {\n \n     /// Returns true if the IP in this `SocketAddr` is a valid IPv6 address,\n     /// false if it's a valid IPv4 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(sockaddr_checker)]\n+    ///\n+    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n+    ///\n+    /// fn main() {\n+    ///     let socket = SocketAddr::new(\n+    ///                      IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    ///     assert_eq!(socket.is_ipv4(), false);\n+    ///     assert_eq!(socket.is_ipv6(), true);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {"}, {"sha": "9ec09603224107bf298f2e2e282c852cfff6f5d7", "filename": "src/test/compile-fail/E0088.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fcompile-fail%2FE0088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fcompile-fail%2FE0088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0088.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -9,7 +9,12 @@\n // except according to those terms.\n \n fn f() {}\n+fn g<'a>() {}\n \n fn main() {\n     f::<'static>(); //~ ERROR E0088\n+    //~^ unexpected lifetime parameter\n+\n+    g::<'static, 'static>(); //~ ERROR E0088\n+    //~^ unexpected lifetime parameters\n }"}, {"sha": "7a8502f7caab188498da846377ff91dc3f1e8909", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `for` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iteration variable name ----------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iteration_variable_name() {\n+    let mut _x = 0;\n+    for _i in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iteration_variable_name() {\n+    let mut _x = 0;\n+    for _a in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iteration variable pattern -------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iteration_variable_pattern() {\n+    let mut _x = 0;\n+    for _i in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iteration_variable_pattern() {\n+    let mut _x = 0;\n+    for &_i in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change iterable -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_iterable() {\n+    let mut _x = 0;\n+    for _ in &[0, 1, 2] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_iterable() {\n+    let mut _x = 0;\n+    for _ in &[0, 1, 3] {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: for _ in 0..1 {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: for _ in 0..1 {\n+        'inner: for _ in 0..1 {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    for _ in 0..1 {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "eaa5f68b98c4bcc8fa256ee0a5e60b4e9b0e446c", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `loop` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: loop {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: loop {\n+        'inner: loop {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    loop {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "405645bd1b842311fe4c4c923710ef36d5490e9e", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `while let` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while let Some(1u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while let Some(0u32) = None {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while let Some(0u32) = None {\n+        'inner: while let Some(0u32) = None {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while let Some(0u32) = None {\n+        _x = 1;\n+        break;\n+    }\n+}"}, {"sha": "f16611ee463e0f9d0c99d72bd65f315d9db4e99b", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `while` loops.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_body() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 2;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Change loop body ------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_loop_condition() {\n+    let mut _x = 0;\n+    while false {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add break -------------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label --------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+\n+\n+// Add loop label to break -----------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_break() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        break 'label;\n+    }\n+}\n+\n+\n+\n+// Change break label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            break 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_break_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            break 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Add loop label to continue --------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_loop_label_to_continue() {\n+    let mut _x = 0;\n+    'label: while true {\n+        _x = 1;\n+        continue 'label;\n+    }\n+}\n+\n+\n+\n+// Change continue label ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            continue 'inner;\n+        }\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_label() {\n+    let mut _x = 0;\n+    'outer: while true {\n+        'inner: while true {\n+            _x = 1;\n+            continue 'outer;\n+        }\n+    }\n+}\n+\n+\n+\n+// Change continue to break ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        continue;\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_continue_to_break() {\n+    let mut _x = 0;\n+    while true {\n+        _x = 1;\n+        break;\n+    }\n+}"}]}