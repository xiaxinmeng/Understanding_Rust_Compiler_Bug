{"sha": "43253c508d990cf9d65a1c68cf5dbec8206db164", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMjUzYzUwOGQ5OTBjZjlkNjVhMWM2OGNmNWRiZWM4MjA2ZGIxNjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-30T22:06:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-30T22:06:16Z"}, "message": "Merge #6102\n\n6102: Fix MergingBehaviour::Last creating unintuitive import trees r=jonas-schievink a=Veykril\n\nThe way this behaviour currently works is actually a bit weird. Imagine the following three imports get requested for insertion in the given order:\r\n- `winapi::um::d3d11::ID3D11Device`\r\n- `winapi::shared::dxgiformat::DXGI_FORMAT`\r\n- `winapi::um::d3d11::D3D11_FILTER`\r\n\r\nAfter the first two you will have the following tree:\r\n```rust\r\nuse winapi::{shared::dxgiformat::DXGI_FORMAT, um::d3d11::ID3D11Device};\r\n```\r\nwhich is to be expected as they arent nested this kind of merging is allowed, but now importing the third one will result in:\r\n```rust\r\nuse winapi::{shared::dxgiformat::DXGI_FORMAT, um::d3d11::ID3D11Device, um::d3d11::D3D11_FILTER};\r\n```\r\nwhich is still fine according to the rules, but it looks weird(at least in my eyes) due to the long paths that are quite similar. The changes in this PR will change the criteria for when to reject `Last` merging, it still disallows multiple nesting but it also only allows single segment paths inside of the `UseTreeList`. With this change you get the following tree after the first two imports:\r\n```rust\r\nuse winapi::um::d3d11::ID3D11Device;\r\nuse winapi::shared::dxgiformat::DXGI_FORMAT;\r\n```\r\nand after the third:\r\n```rust\r\nuse winapi::shared::dxgiformat::DXGI_FORMAT;\r\nuse winapi::um::d3d11::{ID3D11Device, D3D11_FILTER};\r\n```\r\nWhich I believe looks more like what you would expect.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "5355f982aa2c2386672e21824d38227d74d4dfb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5355f982aa2c2386672e21824d38227d74d4dfb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43253c508d990cf9d65a1c68cf5dbec8206db164", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdQFYCRBK7hj4Ov3rIwAAdHIIACy0Na8icpekgF2ITwlTvDQg\nV+MDGXzKJtQQBzfxLE5bzuj5zoDC3tXbCakN32WzX8/gnELU5FJFmYOJaNLDNwpa\ngjpluyxB7TTuZDSJUlNi2b85cqtOWMhEM5GvJKv8K/8zQepVg7QhaaI/ITAniJ0q\nA/7wZCofsm5zkCr2je55c90I2WMdRPUfOrglJQODARYMSYD0MNtHaBYAuhvDRigv\nBepGp0WBHJfgb/jTjJJ0836Q9GCg46JO/+DUP88Rrxv81bvLL7P00oqtUtJJwAZQ\nXjV7hyaGKVYworp+wKkPFsDW+6c+y+EUeijWmsXSdyF6+jRlz5VQouD5u42Dm8k=\n=F7a2\n-----END PGP SIGNATURE-----\n", "payload": "tree 5355f982aa2c2386672e21824d38227d74d4dfb4\nparent 7c9ae771bca39d511a0ea7395da2b4b91b44ee12\nparent 0671bf2d734c6d579896a8f976a2c65e5a7f405e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601503576 +0000\ncommitter GitHub <noreply@github.com> 1601503576 +0000\n\nMerge #6102\n\n6102: Fix MergingBehaviour::Last creating unintuitive import trees r=jonas-schievink a=Veykril\n\nThe way this behaviour currently works is actually a bit weird. Imagine the following three imports get requested for insertion in the given order:\r\n- `winapi::um::d3d11::ID3D11Device`\r\n- `winapi::shared::dxgiformat::DXGI_FORMAT`\r\n- `winapi::um::d3d11::D3D11_FILTER`\r\n\r\nAfter the first two you will have the following tree:\r\n```rust\r\nuse winapi::{shared::dxgiformat::DXGI_FORMAT, um::d3d11::ID3D11Device};\r\n```\r\nwhich is to be expected as they arent nested this kind of merging is allowed, but now importing the third one will result in:\r\n```rust\r\nuse winapi::{shared::dxgiformat::DXGI_FORMAT, um::d3d11::ID3D11Device, um::d3d11::D3D11_FILTER};\r\n```\r\nwhich is still fine according to the rules, but it looks weird(at least in my eyes) due to the long paths that are quite similar. The changes in this PR will change the criteria for when to reject `Last` merging, it still disallows multiple nesting but it also only allows single segment paths inside of the `UseTreeList`. With this change you get the following tree after the first two imports:\r\n```rust\r\nuse winapi::um::d3d11::ID3D11Device;\r\nuse winapi::shared::dxgiformat::DXGI_FORMAT;\r\n```\r\nand after the third:\r\n```rust\r\nuse winapi::shared::dxgiformat::DXGI_FORMAT;\r\nuse winapi::um::d3d11::{ID3D11Device, D3D11_FILTER};\r\n```\r\nWhich I believe looks more like what you would expect.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43253c508d990cf9d65a1c68cf5dbec8206db164", "html_url": "https://github.com/rust-lang/rust/commit/43253c508d990cf9d65a1c68cf5dbec8206db164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43253c508d990cf9d65a1c68cf5dbec8206db164/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c9ae771bca39d511a0ea7395da2b4b91b44ee12", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9ae771bca39d511a0ea7395da2b4b91b44ee12", "html_url": "https://github.com/rust-lang/rust/commit/7c9ae771bca39d511a0ea7395da2b4b91b44ee12"}, {"sha": "0671bf2d734c6d579896a8f976a2c65e5a7f405e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0671bf2d734c6d579896a8f976a2c65e5a7f405e", "html_url": "https://github.com/rust-lang/rust/commit/0671bf2d734c6d579896a8f976a2c65e5a7f405e"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "8dd4fe607490d708387afc03fc9e2f2a42f57795", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/43253c508d990cf9d65a1c68cf5dbec8206db164/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43253c508d990cf9d65a1c68cf5dbec8206db164/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=43253c508d990cf9d65a1c68cf5dbec8206db164", "patch": "@@ -174,28 +174,30 @@ pub(crate) fn try_merge_trees(\n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n     let lhs = lhs.split_prefix(&lhs_prefix);\n     let rhs = rhs.split_prefix(&rhs_prefix);\n-    recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n+    recursive_merge(&lhs, &rhs, merge)\n }\n \n /// Recursively \"zips\" together lhs and rhs.\n fn recursive_merge(\n     lhs: &ast::UseTree,\n     rhs: &ast::UseTree,\n     merge: MergeBehaviour,\n-) -> Option<(ast::UseTree, bool)> {\n+) -> Option<ast::UseTree> {\n     let mut use_trees = lhs\n         .use_tree_list()\n         .into_iter()\n         .flat_map(|list| list.use_trees())\n-        // check if any of the use trees are nested, if they are and the behaviour is `last` we are not allowed to merge this\n-        // so early exit the iterator by using Option's Intoiterator impl\n-        .map(|tree| match merge == MergeBehaviour::Last && tree.use_tree_list().is_some() {\n-            true => None,\n-            false => Some(tree),\n+        // we use Option here to early return from this function(this is not the same as a `filter` op)\n+        .map(|tree| match merge.is_tree_allowed(&tree) {\n+            true => Some(tree),\n+            false => None,\n         })\n         .collect::<Option<Vec<_>>>()?;\n     use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n+        if !merge.is_tree_allowed(&rhs_t) {\n+            return None;\n+        }\n         let rhs_path = rhs_t.path();\n         match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n             Ok(idx) => {\n@@ -239,17 +241,9 @@ fn recursive_merge(\n                 }\n                 let lhs = lhs_t.split_prefix(&lhs_prefix);\n                 let rhs = rhs_t.split_prefix(&rhs_prefix);\n-                let this_has_children = use_trees.len() > 0;\n                 match recursive_merge(&lhs, &rhs, merge) {\n-                    Some((_, has_multiple_children))\n-                        if merge == MergeBehaviour::Last\n-                            && this_has_children\n-                            && has_multiple_children =>\n-                    {\n-                        return None\n-                    }\n-                    Some((use_tree, _)) => use_trees[idx] = use_tree,\n-                    None => use_trees.insert(idx, rhs_t),\n+                    Some(use_tree) => use_trees[idx] = use_tree,\n+                    None => return None,\n                 }\n             }\n             Err(_)\n@@ -264,8 +258,7 @@ fn recursive_merge(\n             }\n         }\n     }\n-    let has_multiple_children = use_trees.len() > 1;\n-    Some((lhs.with_use_tree_list(make::use_tree_list(use_trees)), has_multiple_children))\n+    Some(lhs.with_use_tree_list(make::use_tree_list(use_trees)))\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -308,6 +301,10 @@ fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Cl\n     successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n }\n \n+fn path_len(path: ast::Path) -> usize {\n+    segment_iter(&path).count()\n+}\n+\n /// Orders paths in the following way:\n /// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n // FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n@@ -352,6 +349,19 @@ pub enum MergeBehaviour {\n     Last,\n }\n \n+impl MergeBehaviour {\n+    #[inline]\n+    fn is_tree_allowed(&self, tree: &ast::UseTree) -> bool {\n+        match self {\n+            MergeBehaviour::Full => true,\n+            // only simple single segment paths are allowed\n+            MergeBehaviour::Last => {\n+                tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Eq, PartialEq, PartialOrd, Ord)]\n enum ImportGroup {\n     // the order here defines the order of new group inserts\n@@ -675,6 +685,11 @@ use std::io;\",\n         )\n     }\n \n+    #[test]\n+    fn merge_last_into_self() {\n+        check_last(\"foo::bar::baz\", r\"use foo::bar;\", r\"use foo::bar::{self, baz};\");\n+    }\n+\n     #[test]\n     fn merge_groups_full() {\n         check_full(\n@@ -819,8 +834,24 @@ use std::io;\",\n     }\n \n     #[test]\n-    fn merge_last_too_long() {\n-        check_last(\"foo::bar\", r\"use foo::bar::baz::Qux;\", r\"use foo::bar::{self, baz::Qux};\");\n+    fn skip_merge_last_too_long() {\n+        check_last(\n+            \"foo::bar\",\n+            r\"use foo::bar::baz::Qux;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore] // FIXME: Order changes when switching lhs and rhs\n+    fn skip_merge_last_too_long2() {\n+        check_last(\n+            \"foo::bar::baz::Qux\",\n+            r\"use foo::bar;\",\n+            r\"use foo::bar;\n+use foo::bar::baz::Qux;\",\n+        );\n     }\n \n     #[test]"}]}