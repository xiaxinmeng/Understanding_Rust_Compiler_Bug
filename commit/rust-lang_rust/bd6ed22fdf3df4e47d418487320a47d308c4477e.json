{"sha": "bd6ed22fdf3df4e47d418487320a47d308c4477e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNmVkMjJmZGYzZGY0ZTQ3ZDQxODQ4NzMyMGE0N2QzMDhjNDQ3N2U=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-08T03:36:36Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-03-10T06:24:34Z"}, "message": "Switch derive(Debug) to use the debug builders", "tree": {"sha": "429b2d1e40f2470141a1e956bb89a39935d8b546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/429b2d1e40f2470141a1e956bb89a39935d8b546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd6ed22fdf3df4e47d418487320a47d308c4477e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd6ed22fdf3df4e47d418487320a47d308c4477e", "html_url": "https://github.com/rust-lang/rust/commit/bd6ed22fdf3df4e47d418487320a47d308c4477e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd6ed22fdf3df4e47d418487320a47d308c4477e/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8121cf077c68fa1d18a1a538deb5acdf79c5e732", "url": "https://api.github.com/repos/rust-lang/rust/commits/8121cf077c68fa1d18a1a538deb5acdf79c5e732", "html_url": "https://github.com/rust-lang/rust/commit/8121cf077c68fa1d18a1a538deb5acdf79c5e732"}], "stats": {"total": 138, "additions": 74, "deletions": 64}, "files": [{"sha": "37165cdc5ede3cb595ef04ec1ca52109aff69e0a", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=bd6ed22fdf3df4e47d418487320a47d308c4477e", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use prelude::*;\n use fmt::{self, Write, FlagV1};\n \n@@ -69,6 +79,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n         self\n     }\n \n+    #[inline(never)]\n     fn field_inner(&mut self, name: &str, value: &fmt::Debug) {\n         self.result = self.result.and_then(|_| {\n             let prefix = if self.has_fields {\n@@ -97,6 +108,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n         self.result\n     }\n \n+    #[inline(never)]\n     fn finish_inner(&mut self) {\n         if self.has_fields {\n             self.result = self.result.and_then(|_| {\n@@ -142,6 +154,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n         self\n     }\n \n+    #[inline(never)]\n     fn field_inner(&mut self, value: &fmt::Debug) {\n         self.result = self.result.and_then(|_| {\n             let (prefix, space) = if self.has_fields {\n@@ -170,6 +183,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n         self.result\n     }\n \n+    #[inline(never)]\n     fn finish_inner(&mut self) {\n         if self.has_fields {\n             self.result = self.result.and_then(|_| {\n@@ -215,6 +229,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n         self\n     }\n \n+    #[inline(never)]\n     fn entry_inner(&mut self, entry: &fmt::Debug) {\n         self.result = self.result.and_then(|_| {\n             let prefix = if self.has_fields {\n@@ -243,6 +258,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n         self.result\n     }\n \n+    #[inline(never)]\n     fn finish_inner(&mut self) {\n         self.result = self.result.and_then(|_| {\n             let end = match (self.has_fields, self.is_pretty()) {\n@@ -287,6 +303,7 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n         self\n     }\n \n+    #[inline(never)]\n     fn entry_inner(&mut self, key: &fmt::Debug, value: &fmt::Debug) {\n         self.result = self.result.and_then(|_| {\n             let prefix = if self.has_fields {\n@@ -315,6 +332,7 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n         self.result\n     }\n \n+    #[inline(never)]\n     fn finish_inner(&mut self) {\n         self.result = self.result.and_then(|_| {\n             let end = match (self.has_fields, self.is_pretty()) {"}, {"sha": "741cf7b47fa1e10236b031425a6926bc96c81b25", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=bd6ed22fdf3df4e47d418487320a47d308c4477e", "patch": "@@ -644,6 +644,7 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n     /// ```\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n     pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n         builders::debug_struct_new(self, name)\n     }\n@@ -671,6 +672,7 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n     pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n         builders::debug_tuple_new(self, name)\n     }\n@@ -699,6 +701,7 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n     pub fn debug_set<'b>(&'b mut self, name: &str) -> DebugSet<'b, 'a> {\n         builders::debug_set_new(self, name)\n     }\n@@ -724,9 +727,10 @@ impl<'a> Formatter<'a> {\n     /// }\n     ///\n     /// // prints \"Foo { \"A\": 10, \"B\": 11 }\"\n-    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)));\n+    /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n+    #[inline]\n     pub fn debug_map<'b>(&'b mut self, name: &str) -> DebugMap<'b, 'a> {\n         builders::debug_map_new(self, name)\n     }"}, {"sha": "b2fbc90be591423ce50d5406fbf5f72e7f931914", "filename": "src/libcoretest/fmt/builders.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibcoretest%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fbuilders.rs?ref=bd6ed22fdf3df4e47d418487320a47d308c4477e", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n mod debug_struct {\n     use std::fmt;\n "}, {"sha": "ae9a402006095b3d08f42c13fa72ff1b03d6c860", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=bd6ed22fdf3df4e47d418487320a47d308c4477e", "patch": "@@ -11,16 +11,13 @@\n use ast;\n use ast::{MetaItem, Item, Expr,};\n use codemap::Span;\n-use ext::format;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-use std::collections::HashMap;\n-\n pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n@@ -56,14 +53,12 @@ pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-/// We construct a format string and then defer to std::fmt, since that\n-/// knows what's up with formatting and so on.\n+/// We use the debug builders to do the heavy lifting here\n fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                      substr: &Substructure) -> P<Expr> {\n-    // build `<name>`, `<name>({}, {}, ...)` or `<name> { <field>: {},\n-    // <field>: {}, ... }` based on the \"shape\".\n-    //\n-    // Easy start: they all start with the name.\n+    // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n+    // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n+    // based on the \"shape\".\n     let name = match *substr.fields {\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n@@ -72,70 +67,53 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = String::from_str(&token::get_ident(name));\n-    // the internal fields we're actually formatting\n-    let mut exprs = Vec::new();\n+    // We want to make sure we have the expn_id set so that we can use unstable methods\n+    let span = Span { expn_id: cx.backtrace(), .. span };\n+    let name = cx.expr_lit(span, ast::Lit_::LitStr(token::get_ident(name),\n+                                                   ast::StrStyle::CookedStr));\n+    let mut expr = substr.nonself_args[0].clone();\n \n-    // Getting harder... making the format string:\n     match *substr.fields {\n-        // unit struct/nullary variant: no work necessary!\n-        Struct(ref fields) if fields.len() == 0 => {}\n-        EnumMatching(_, _, ref fields) if fields.len() == 0 => {}\n-\n         Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n-            if fields[0].name.is_none() {\n+            if fields.is_empty() || fields[0].name.is_none() {\n                 // tuple struct/\"normal\" variant\n-\n-                format_string.push_str(\"(\");\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 { format_string.push_str(\", \"); }\n-\n-                    format_string.push_str(\"{:?}\");\n-\n-                    exprs.push(field.self_.clone());\n+                expr = cx.expr_method_call(span,\n+                                           expr,\n+                                           token::str_to_ident(\"debug_tuple\"),\n+                                           vec![name]);\n+\n+                for field in fields {\n+                    expr = cx.expr_method_call(span,\n+                                               expr,\n+                                               token::str_to_ident(\"field\"),\n+                                               vec![cx.expr_addr_of(field.span,\n+                                                                    field.self_.clone())]);\n                 }\n-\n-                format_string.push_str(\")\");\n             } else {\n                 // normal struct/struct variant\n-\n-                format_string.push_str(\" {{\");\n-\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 { format_string.push_str(\",\"); }\n-\n-                    let name = token::get_ident(field.name.unwrap());\n-                    format_string.push_str(\" \");\n-                    format_string.push_str(&name);\n-                    format_string.push_str(\": {:?}\");\n-\n-                    exprs.push(field.self_.clone());\n+                expr = cx.expr_method_call(span,\n+                                           expr,\n+                                           token::str_to_ident(\"debug_struct\"),\n+                                           vec![name]);\n+\n+                for field in fields {\n+                    let name = cx.expr_lit(field.span, ast::Lit_::LitStr(\n+                            token::get_ident(field.name.clone().unwrap()),\n+                            ast::StrStyle::CookedStr));\n+                    expr = cx.expr_method_call(span,\n+                                               expr,\n+                                               token::str_to_ident(\"field\"),\n+                                               vec![name,\n+                                                    cx.expr_addr_of(field.span,\n+                                                                    field.self_.clone())]);\n                 }\n-\n-                format_string.push_str(\" }}\");\n             }\n         }\n         _ => unreachable!()\n     }\n \n-    // AST construction!\n-    // we're basically calling\n-    //\n-    // format_arg_method!(fmt, write_fmt, \"<format_string>\", exprs...)\n-    //\n-    // but doing it directly via ext::format.\n-    let formatter = substr.nonself_args[0].clone();\n-\n-    let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(&format_string[..]);\n-    let format_string = cx.expr_str(span, s);\n-\n-    // phew, not our responsibility any more!\n-\n-    let args = vec![\n-        format::expand_preparsed_format_args(cx, span, format_string,\n-                                             exprs, vec![], HashMap::new())\n-    ];\n-    cx.expr_method_call(span, formatter, meth, args)\n+    cx.expr_method_call(span,\n+                        expr,\n+                        token::str_to_ident(\"finish\"),\n+                        vec![])\n }"}, {"sha": "6883395933ef17f151cac5ea73ac25be0be99906", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6ed22fdf3df4e47d418487320a47d308c4477e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bd6ed22fdf3df4e47d418487320a47d308c4477e", "patch": "@@ -1121,7 +1121,7 @@ fn expand_annotatable(a: Annotatable,\n                         callee: NameAndSpan {\n                             name: mname.to_string(),\n                             format: MacroAttribute,\n-                            span: None,\n+                            span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now.\n                             allow_internal_unstable: true,"}]}