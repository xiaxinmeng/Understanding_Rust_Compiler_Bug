{"sha": "c34e3f0f83660e02a7545ac52f4c8023044868c2", "node_id": "C_kwDOAAsO6NoAKGMzNGUzZjBmODM2NjBlMDJhNzU0NWFjNTJmNGM4MDIzMDQ0ODY4YzI", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-11-18T22:33:49Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-07T21:31:46Z"}, "message": "Update clippy for associated item changes", "tree": {"sha": "ea68f70d1813736a2ccea4d119d20a4426720a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea68f70d1813736a2ccea4d119d20a4426720a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c34e3f0f83660e02a7545ac52f4c8023044868c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c34e3f0f83660e02a7545ac52f4c8023044868c2", "html_url": "https://github.com/rust-lang/rust/commit/c34e3f0f83660e02a7545ac52f4c8023044868c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c34e3f0f83660e02a7545ac52f4c8023044868c2/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a60337fcee0c484405c3572f2139f39284e95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a60337fcee0c484405c3572f2139f39284e95b", "html_url": "https://github.com/rust-lang/rust/commit/d7a60337fcee0c484405c3572f2139f39284e95b"}], "stats": {"total": 30, "additions": 16, "deletions": 14}, "files": [{"sha": "64f6d62fbdcd80c12fac55ad62654d9054f75cee", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=c34e3f0f83660e02a7545ac52f4c8023044868c2", "patch": "@@ -214,14 +214,14 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        let is_empty = sym!(is_empty);\n \n         let is_empty_method_found = current_and_super_traits\n             .iter()\n-            .flat_map(|&i| cx.tcx.associated_items(i).in_definition_order())\n+            .flat_map(|&i| cx.tcx.associated_items(i).filter_by_name_unhygienic(is_empty))\n             .any(|i| {\n                 i.kind == ty::AssocKind::Fn\n                     && i.fn_has_self_parameter\n-                    && i.ident.name == sym!(is_empty)\n                     && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n@@ -458,7 +458,7 @@ fn is_empty_array(expr: &Expr<'_>) -> bool {\n fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_>, item: &ty::AssocItem) -> bool {\n-        if item.kind == ty::AssocKind::Fn && item.ident.name.as_str() == \"is_empty\" {\n+        if item.kind == ty::AssocKind::Fn {\n             let sig = cx.tcx.fn_sig(item.def_id);\n             let ty = sig.skip_binder();\n             ty.inputs().len() == 1\n@@ -469,20 +469,22 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n     /// Checks the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext<'_>, id: DefId) -> bool {\n+        let is_empty = sym!(is_empty);\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)\n-                .in_definition_order()\n+                .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         })\n     }\n \n     let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n     match ty.kind() {\n         ty::Dynamic(tt, ..) => tt.principal().map_or(false, |principal| {\n+            let is_empty = sym!(is_empty);\n             cx.tcx\n                 .associated_items(principal.def_id())\n-                .in_definition_order()\n+                .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),"}, {"sha": "7d2ff083b7e07f95b8c76971933638d3caf175f2", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=c34e3f0f83660e02a7545ac52f4c8023044868c2", "patch": "@@ -12,11 +12,10 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n-use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, AssocKind, Const, Ty};\n+use rustc_middle::ty::{self, Const, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -293,8 +292,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                         // Lint a trait impl item only when the definition is a generic type,\n                         // assuming an assoc const is not meant to be an interior mutable type.\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n-                        if let Some(of_assoc_item) = specialization_graph::Node::Trait(of_trait_def_id)\n-                            .item(cx.tcx, impl_item.ident, AssocKind::Const, of_trait_def_id);\n+                        if let Some(of_assoc_item) = cx\n+                            .tcx\n+                            .associated_item(impl_item.def_id)\n+                            .trait_item_def_id;\n                         if cx\n                             .tcx\n                             .layout_of(cx.tcx.param_env(of_trait_def_id).and(\n@@ -303,7 +304,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                                 // and, in that case, the definition is *not* generic.\n                                 cx.tcx.normalize_erasing_regions(\n                                     cx.tcx.param_env(of_trait_def_id),\n-                                    cx.tcx.type_of(of_assoc_item.def_id),\n+                                    cx.tcx.type_of(of_assoc_item),\n                                 ),\n                             ))\n                             .is_err();"}, {"sha": "a86db58741eb6ca0a052b2dbf21756dd0ee2d03f", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34e3f0f83660e02a7545ac52f4c8023044868c2/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=c34e3f0f83660e02a7545ac52f4c8023044868c2", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::AssocKind;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -143,10 +142,10 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // trait, not in the impl of the trait.\n                 let trait_method = cx\n                     .tcx\n-                    .associated_items(impl_trait_ref.def_id)\n-                    .find_by_name_and_kind(cx.tcx, impl_item.ident, AssocKind::Fn, impl_trait_ref.def_id)\n+                    .associated_item(impl_item.def_id)\n+                    .trait_item_def_id\n                     .expect(\"impl method matches a trait method\");\n-                let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n+                let trait_method_sig = cx.tcx.fn_sig(trait_method);\n                 let trait_method_sig = cx.tcx.erase_late_bound_regions(trait_method_sig);\n \n                 // `impl_inputs_outputs` is an iterator over the types (`hir::Ty`) declared in the"}]}