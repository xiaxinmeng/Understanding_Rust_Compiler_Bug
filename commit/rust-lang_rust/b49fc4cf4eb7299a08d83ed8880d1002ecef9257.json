{"sha": "b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OWZjNGNmNGViNzI5OWEwOGQ4M2VkODg4MGQxMDAyZWNlZjkyNTc=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-14T16:33:53Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:17:46Z"}, "message": "std: adding file::{stat,mkdir,rmdir}, FileInfo and FileReader/FileWriter\n\nadd ignores for win32 tests on previous file io stuff...", "tree": {"sha": "a958f857bd3750f8fba3bcedd6e3b6dc8ce5cad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a958f857bd3750f8fba3bcedd6e3b6dc8ce5cad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "html_url": "https://github.com/rust-lang/rust/commit/b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "055488df1a6a4500de565ac2531d7bc42dd02f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/055488df1a6a4500de565ac2531d7bc42dd02f83", "html_url": "https://github.com/rust-lang/rust/commit/055488df1a6a4500de565ac2531d7bc42dd02f83"}], "stats": {"total": 442, "additions": 290, "deletions": 152}, "files": [{"sha": "4968f3276026f5d45a079f1aae79706450e6796f", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 195, "deletions": 89, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -12,7 +12,7 @@ use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n-            Open, Read, Create, ReadWrite};\n+            Open, Read, Write, Create, ReadWrite};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n use rt::io::{io_error, read_error, EndOfFile,\n             FileMode, FileAccess, FileStat};\n@@ -57,26 +57,108 @@ pub fn unlink<P: PathLike>(path: &P) {\n     }\n }\n \n-/// Abstraction representing *positional* access to a file. In this case,\n-/// *positional* refers to it keeping an encounter *cursor* of where in the\n-/// file a subsequent `read` or `write` will begin from. Users of a `FileStream`\n-/// can `seek` to move the cursor to a given location *within the bounds of the\n-/// file* and can ask to have the `FileStream` `tell` them the location, in\n-/// bytes, of the cursor.\n-///\n-/// This abstraction is roughly modeled on the access workflow as represented\n-/// by `open(2)`, `read(2)`, `write(2)` and friends.\n+/// Create a new directory with default permissions (process user\n+/// has read/write privs)\n+pub fn mkdir<P: PathLike>(path: &P) {\n+    let mkdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_mkdir(path)\n+    };\n+    match mkdir_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n+}\n+/// Removes a directory\n+pub fn rmdir<P: PathLike>(path: &P) {\n+    let rmdir_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_rmdir(path)\n+    };\n+    match rmdir_result {\n+        Ok(_) => (),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+        }\n+    }\n+}\n+\n+/// Given a `rt::io::support::PathLike`, query the file system to get\n+/// information about a file, directory, etc.\n ///\n-/// The `open` and `unlink` static methods are provided to manage creation/removal\n-/// of files. All other methods operatin on an instance of `FileStream`.\n+/// Returns a `Some(PathInfo)` on success, and raises a `rt::io::IoError` condition\n+/// on failure and returns `None`.\n+pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n+    let open_result = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).fs_stat(path)\n+    };\n+    match open_result {\n+        Ok(p) => {\n+            Some(p)\n+        },\n+        Err(ioerr) => {\n+            read_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n+/// Read-only view of file\n+pub struct FileReader { priv stream: FileStream }\n+\n+impl Reader for FileReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        self.stream.read(buf)\n+    }\n+\n+    fn eof(&mut self) -> bool {\n+        self.stream.eof()\n+    }\n+}\n+\n+impl Seek for FileReader {\n+    fn tell(&self) -> u64 {\n+        self.stream.tell()\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        self.stream.seek(pos, style);\n+    }\n+}\n+\n+/// Write-only view of a file\n+pub struct FileWriter { priv stream: FileStream }\n+\n+impl Writer for FileWriter {\n+    fn write(&mut self, buf: &[u8]) {\n+        self.stream.write(buf);\n+    }\n+\n+    fn flush(&mut self) {\n+        self.stream.flush();\n+    }\n+}\n+\n+impl Seek for FileWriter {\n+    fn tell(&self) -> u64 {\n+        self.stream.tell()\n+    }\n+\n+    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+        self.stream.seek(pos, style);\n+    }\n+}\n+\n+/// Internal representation of a FileStream, used to consolidate functionality\n+/// exposed in the public API\n pub struct FileStream {\n     fd: ~RtioFileStream,\n     last_nread: int,\n }\n \n-impl FileStream {\n-}\n-\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {\n@@ -148,69 +230,85 @@ impl Seek for FileStream {\n     }\n }\n \n-pub struct FileInfo(Path);\n-\n-/// FIXME: DOCS\n-impl<'self> FileInfo {\n-    pub fn new<P: PathLike>(path: &P) -> FileInfo {\n-        do path.path_as_str |p| {\n-            FileInfo(Path(p))\n-        }\n-    }\n-    // FIXME #8873 can't put this in FileSystemInfo\n-    pub fn get_path(&'self self) -> &'self Path {\n-        &(**self)\n-    }\n-    pub fn stat(&self) -> Option<FileStat> {\n-        do io_error::cond.trap(|_| {\n+/// Represents passive information about a file (primarily exposed\n+/// via the `stat()` method. Also provides methods for opening\n+/// a file in various modes/permissions.\n+pub trait FileInfo<'self> {\n+    /// Get the filesystem path that this `FileInfo` points at,\n+    /// whether it is valid or not. This way, it can be used to\n+    /// to specify a file path of a non-existent file which it\n+    /// later create\n+    fn get_file_path(&'self self) -> &'self Path;\n+\n+    /// Ask the operating system for information about the file\n+    fn stat(&self) -> Option<FileStat> {\n+        use mod_stat = super::file::stat;\n+        do read_error::cond.trap(|_| {\n             // FIXME: can we do something more useful here?\n         }).inside {\n-            stat(self.get_path())\n+            mod_stat(self.get_file_path())\n         }\n     }\n-    pub fn exists(&self) -> bool {\n+\n+    /// returns `true` if the location pointed at by the enclosing\n+    /// exists on the filesystem\n+    fn file_exists(&self) -> bool {\n         match self.stat() {\n-            Some(s) => {\n-                match s.is_file {\n-                    true => {\n-                        true\n-                    },\n-                    false => {\n-                        // FIXME: raise condition?\n-                        false\n-                    }\n-                }\n-            },\n+            Some(_) => true,\n             None => false\n         }\n     }\n-    pub fn is_file(&self) -> bool {\n+\n+    /// Whether the underlying implemention (be it a file path\n+    /// or active file descriptor) is a \"regular file\". Will return\n+    /// false for paths to non-existent locations or directories or\n+    /// other non-regular files (named pipes, etc).\n+    fn is_file(&self) -> bool {\n         match self.stat() {\n             Some(s) => s.is_file,\n-            None => {\n-                // FIXME: raise condition\n-                false\n-            }\n+            None => false\n         }\n     }\n-    pub fn open(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n-        match self.is_file() {\n-            true => {\n-                open(self.get_path(), mode, access)\n+\n+    /// Attempts to open a regular file for reading/writing based\n+    /// on provided inputs\n+    fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n+        match self.stat() {\n+            Some(s) => match s.is_file {\n+                true => open(self.get_file_path(), mode, access),\n+                false => None // FIXME: raise condition, not a regular file..\n             },\n-            false => {\n-                // FIXME: raise condition\n-                None\n-            }\n+            None => open(self.get_file_path(), mode, access)\n+        }\n+    }\n+    /// Attempts to open a regular file for reading-only based\n+    /// on provided inputs\n+    fn open_reader(&self, mode: FileMode) -> Option<FileReader> {\n+        match self.open_stream(mode, Read) {\n+            Some(s) => Some(FileReader { stream: s}),\n+            None => None\n+        }\n+    }\n+\n+    /// Attempts to open a regular file for writing-only based\n+    /// on provided inputs\n+    fn open_writer(&self, mode: FileMode) -> Option<FileWriter> {\n+        match self.open_stream(mode, Write) {\n+            Some(s) => Some(FileWriter { stream: s}),\n+            None => None\n         }\n     }\n-    //fn open_read(&self) -> FileStream;\n-    //fn open_write(&self) -> FileStream;\n-    //fn create(&self) -> FileStream;\n-    //fn truncate(&self) -> FileStream;\n-    //fn open_or_create(&self) -> FileStream;\n-    //fn create_or_truncate(&self) -> FileStream;\n-    //fn unlink(&self);\n+\n+    /// Attempt to remove a file from the filesystem, pending the closing\n+    /// of any open file descriptors pointing to the file\n+    fn unlink(&self) {\n+        unlink(self.get_file_path());\n+    }\n+}\n+\n+/// `FileInfo` implementation for `Path`s \n+impl<'self> FileInfo<'self> for Path {\n+    fn get_file_path(&'self self) -> &'self Path { self }\n }\n \n /*\n@@ -244,27 +342,6 @@ impl DirectoryInfo<'self> {\n }\n */\n \n-/// Given a `rt::io::support::PathLike`, query the file system to get\n-/// information about a file, directory, etc.\n-///\n-/// Returns a `Some(PathInfo)` on success, and raises a `rt::io::IoError` condition\n-/// on failure and returns `None`.\n-pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n-    let open_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_stat(path)\n-    };\n-    match open_result {\n-        Ok(p) => {\n-            Some(p)\n-        },\n-        Err(ioerr) => {\n-            read_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n-}\n-\n fn file_test_smoke_test_impl() {\n     do run_in_mt_newsched_task {\n         let message = \"it's alright. have a good time\";\n@@ -412,7 +489,7 @@ fn file_test_io_seek_and_write_impl() {\n             read_stream.read(read_mem);\n         }\n         unlink(filename);\n-        let read_str = str::from_bytes(read_mem);\n+        let read_str = str::from_utf8(read_mem);\n         assert!(read_str == final_msg.to_owned());\n     }\n }\n@@ -463,8 +540,9 @@ fn file_test_io_seek_shakedown() {\n }\n \n #[test]\n+#[ignore(cfg(windows))] // FIXME #8810\n fn file_test_stat_is_correct_on_is_file() {\n-    do run_in_newsched_task {\n+    do run_in_mt_newsched_task {\n         let filename = &Path(\"./tmp/file_stat_correct_on_is_file.txt\");\n         {\n             let mut fs = open(filename, Create, ReadWrite).unwrap();\n@@ -476,20 +554,48 @@ fn file_test_stat_is_correct_on_is_file() {\n             None => fail!(\"shouldn't happen\")\n         };\n         assert!(stat_res.is_file);\n+        unlink(filename);\n     }\n }\n \n #[test]\n+#[ignore(cfg(windows))] // FIXME #8810\n fn file_test_stat_is_correct_on_is_dir() {\n-    //assert!(false);\n+    do run_in_mt_newsched_task {\n+        let filename = &Path(\"./tmp/file_stat_correct_on_is_dir\");\n+        mkdir(filename);\n+        let stat_res = match stat(filename) {\n+            Some(s) => s,\n+            None => fail!(\"shouldn't happen\")\n+        };\n+        assert!(stat_res.is_dir);\n+        rmdir(filename);\n+    }\n }\n \n #[test]\n+#[ignore(cfg(windows))] // FIXME #8810\n fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-    //assert!(false);\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/fileinfo_false_on_dir\");\n+        mkdir(dir);\n+        assert!(dir.is_file() == false);\n+        rmdir(dir);\n+    }\n }\n \n #[test]\n+#[ignore(cfg(windows))] // FIXME #8810\n fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-    //assert!(false);\n+    do run_in_mt_newsched_task {\n+        let file = &Path(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+        {\n+            let msg = \"foo\".as_bytes();\n+            let mut w = file.open_writer(Create);\n+            w.write(msg);\n+        }\n+        assert!(file.file_exists());\n+        file.unlink();\n+        assert!(!file.file_exists());\n+    }\n }"}, {"sha": "0abf81f62de2880532cd0dcb6b43953379e190af", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -76,6 +76,8 @@ pub trait IoFactory {\n     fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n     fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n     //fn fs_fstat(&mut self, fd: c_int) -> Result<FileStat, IoError>;\n+    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n+    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n }\n \n pub trait RtioStream {"}, {"sha": "34f87e3601e749061a3238700cf85808e80a29cf", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -183,9 +183,8 @@ impl FsRequest {\n     // accessors/utility funcs\n     fn sync_cleanup(self, result: c_int)\n           -> Result<c_int, UvError> {\n-        let loop_ = self.get_loop().native_handle();\n         self.cleanup_and_delete();\n-        match status_to_maybe_uv_error_with_loop(loop_,result as i32) {\n+        match status_to_maybe_uv_error(result as i32) {\n             Some(err) => Err(err),\n             None => Ok(result)\n         }\n@@ -261,6 +260,8 @@ fn sync_cleanup(result: int)\n     match status_to_maybe_uv_error(result as i32) {\n         Some(err) => Err(err),\n         None => Ok(result)\n+    }\n+}\n \n extern fn compl_cb(req: *uv_fs_t) {\n     let mut req: FsRequest = NativeHandle::from_native_handle(req);\n@@ -522,6 +523,7 @@ mod test {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat = req.get_stat();\n+                    naive_print(&loop_, fmt!(\"%?\", stat));\n                     assert!(stat.is_dir());\n                     let rmdir_req = FsRequest::new();\n                     do rmdir_req.rmdir(&loop_, &path) |req,uverr| {"}, {"sha": "88d168c85d21d6ea02c23465174adebd0b678867", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -35,7 +35,7 @@ use unstable::sync::Exclusive;\n use path::Path;\n use super::super::io::support::PathLike;\n use libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n-          S_IRUSR, S_IWUSR};\n+          S_IRUSR, S_IWUSR, S_IRWXU};\n use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n              CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n              FileStat};\n@@ -413,6 +413,36 @@ impl UvIoFactory {\n     }\n }\n \n+/// Helper for a variety of simple uv_fs_* functions that\n+/// have no ret val\n+fn uv_fs_helper<P: PathLike>(loop_: &mut Loop, path: &P,\n+                             cb: ~fn(&mut FsRequest, &mut Loop, &P,\n+                                     ~fn(&FsRequest, Option<UvError>)))\n+        -> Result<(), IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+    let path_cell = Cell::new(path);\n+    do task::unkillable { // FIXME(#8674)\n+        let scheduler: ~Scheduler = Local::take();\n+        let mut new_req = FsRequest::new();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let path = path_cell.take();\n+            do cb(&mut new_req, loop_, path) |_, err| {\n+                let res = match err {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            };\n+        }\n+    }\n+    assert!(!result_cell.is_empty());\n+    return result_cell.take();\n+}\n+\n impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n@@ -578,28 +608,11 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let unlink_req = FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                do unlink_req.unlink(self.uv_loop(), path) |_, err| {\n-                    let res = match err {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            }\n+        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n+            do unlink_req.unlink(l, p) |req, err| {\n+                cb(req, err)\n+            };\n         }\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n     fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError> {\n         use str::StrSlice;\n@@ -616,22 +629,22 @@ impl IoFactory for UvIoFactory {\n                 let path_str = path.path_as_str(|p| p.to_owned());\n                 do stat_req.stat(self.uv_loop(), path)\n                       |req,err| {\n-                    if err.is_none() {\n-                        let stat = req.get_stat();\n-                        let res = Ok(FileStat {\n-                            path: Path(path_str),\n-                            is_file: stat.is_file(),\n-                            is_dir: stat.is_dir()\n-                        });\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    } else {\n-                        let res = Err(uv_error_to_io_error(err.unwrap()));\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n+                    let res = match err {\n+                        None => {\n+                            let stat = req.get_stat();\n+                            Ok(FileStat {\n+                                path: Path(path_str),\n+                                is_file: stat.is_file(),\n+                                is_dir: stat.is_dir()\n+                            })\n+                        },\n+                        Some(e) => {\n+                            Err(uv_error_to_io_error(e))\n+                        }\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n                 };\n             };\n         };\n@@ -672,6 +685,21 @@ impl IoFactory for UvIoFactory {\n     //fn fs_fstat(&mut self, _fd: c_int) -> Result<FileStat, IoError> {\n     //    Ok(FileStat)\n     //}\n+    fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        let mode = S_IRWXU as int;\n+        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n+            do mkdir_req.mkdir(l, p, mode as int) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n+    fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n+            do rmdir_req.rmdir(l, p) |req, err| {\n+                cb(req, err)\n+            };\n+        }\n+    }\n }\n \n pub struct UvTcpListener {"}, {"sha": "a2d1c48c3e1a0481aa9c9b4320bde933610b6968", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -142,10 +142,10 @@ impl uv_stat_t {\n         }\n     }\n     pub fn is_file(&self) -> bool {\n-        ((self.st_mode as c_int) & libc::S_IFMT) == libc::S_IFREG\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFREG as libc::uint64_t\n     }\n     pub fn is_dir(&self) -> bool {\n-        ((self.st_mode as c_int) & libc::S_IFMT) == libc::S_IFDIR\n+        ((self.st_mode) & libc::S_IFMT as libc::uint64_t) == libc::S_IFDIR as libc::uint64_t\n     }\n }\n "}, {"sha": "ebc76c84ec9ffdba8d630a11d5a4451763531980", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b49fc4cf4eb7299a08d83ed8880d1002ecef9257/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b49fc4cf4eb7299a08d83ed8880d1002ecef9257", "patch": "@@ -562,27 +562,27 @@ rust_uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n }\n \n extern \"C\" void\n-rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_statbuf_t* stat_out) {\n-  stat_out->st_dev = ((uv_statbuf_t*)req_in->ptr)->st_dev;\n-  stat_out->st_mode = ((uv_statbuf_t*)req_in->ptr)->st_mode;\n-  stat_out->st_nlink = ((uv_statbuf_t*)req_in->ptr)->st_nlink;\n-  stat_out->st_uid = ((uv_statbuf_t*)req_in->ptr)->st_uid;\n-  stat_out->st_gid = ((uv_statbuf_t*)req_in->ptr)->st_gid;\n-  stat_out->st_rdev = ((uv_statbuf_t*)req_in->ptr)->st_rdev;\n-  stat_out->st_ino = ((uv_statbuf_t*)req_in->ptr)->st_ino;\n-  stat_out->st_size = ((uv_statbuf_t*)req_in->ptr)->st_size;\n-  stat_out->st_blksize = ((uv_statbuf_t*)req_in->ptr)->st_blksize;\n-  stat_out->st_blocks = ((uv_statbuf_t*)req_in->ptr)->st_blocks;\n-  //stat_out->st_flags = ((uv_statbuf_t*)req_in->ptr)->st_flags;\n-  //stat_out->st_gen = ((uv_statbuf_t*)req_in->ptr)->st_gen;\n-  stat_out->st_atim.tv_sec = ((uv_statbuf_t*)req_in->ptr)->st_atim.tv_sec;\n-  stat_out->st_atim.tv_nsec = ((uv_statbuf_t*)req_in->ptr)->st_atim.tv_nsec;\n-  stat_out->st_mtim.tv_sec = ((uv_statbuf_t*)req_in->ptr)->st_mtim.tv_sec;\n-  stat_out->st_mtim.tv_nsec = ((uv_statbuf_t*)req_in->ptr)->st_mtim.tv_nsec;\n-  stat_out->st_ctim.tv_sec = ((uv_statbuf_t*)req_in->ptr)->st_ctim.tv_sec;\n-  stat_out->st_ctim.tv_nsec = ((uv_statbuf_t*)req_in->ptr)->st_ctim.tv_nsec;\n-  //stat_out->st_birthtim.tv_sec = ((uv_statbuf_t*)req_in->ptr)->st_birthtim.tv_sec;\n-  //stat_out->st_birthtim.tv_nsec = ((uv_statbuf_t*)req_in->ptr)->st_birthtim.tv_nsec;\n+rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n+  stat_out->st_dev = req_in->statbuf.st_dev;\n+  stat_out->st_mode = req_in->statbuf.st_mode;\n+  stat_out->st_nlink = req_in->statbuf.st_nlink;\n+  stat_out->st_uid = req_in->statbuf.st_uid;\n+  stat_out->st_gid = req_in->statbuf.st_gid;\n+  stat_out->st_rdev = req_in->statbuf.st_rdev;\n+  stat_out->st_ino = req_in->statbuf.st_ino;\n+  stat_out->st_size = req_in->statbuf.st_size;\n+  stat_out->st_blksize = req_in->statbuf.st_blksize;\n+  stat_out->st_blocks = req_in->statbuf.st_blocks;\n+  stat_out->st_flags = req_in->statbuf.st_flags;\n+  stat_out->st_gen = req_in->statbuf.st_gen;\n+  stat_out->st_atim.tv_sec = req_in->statbuf.st_atim.tv_sec;\n+  stat_out->st_atim.tv_nsec = req_in->statbuf.st_atim.tv_nsec;\n+  stat_out->st_mtim.tv_sec = req_in->statbuf.st_mtim.tv_sec;\n+  stat_out->st_mtim.tv_nsec = req_in->statbuf.st_mtim.tv_nsec;\n+  stat_out->st_ctim.tv_sec = req_in->statbuf.st_ctim.tv_sec;\n+  stat_out->st_ctim.tv_nsec = req_in->statbuf.st_ctim.tv_nsec;\n+  stat_out->st_birthtim.tv_sec = req_in->statbuf.st_birthtim.tv_sec;\n+  stat_out->st_birthtim.tv_nsec = req_in->statbuf.st_birthtim.tv_nsec;\n }\n \n extern \"C\" int"}]}