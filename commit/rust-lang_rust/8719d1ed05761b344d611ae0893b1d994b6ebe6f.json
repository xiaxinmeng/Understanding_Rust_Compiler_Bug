{"sha": "8719d1ed05761b344d611ae0893b1d994b6ebe6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTlkMWVkMDU3NjFiMzQ0ZDYxMWFlMDg5M2IxZDk5NGI2ZWJlNmY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-18T00:53:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:46:26Z"}, "message": "Rename `PathSegment::identifier` to `ident`", "tree": {"sha": "6024d6763ef71a33fe0921d4f07dfd31da7a2ace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6024d6763ef71a33fe0921d4f07dfd31da7a2ace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8719d1ed05761b344d611ae0893b1d994b6ebe6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8719d1ed05761b344d611ae0893b1d994b6ebe6f", "html_url": "https://github.com/rust-lang/rust/commit/8719d1ed05761b344d611ae0893b1d994b6ebe6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8719d1ed05761b344d611ae0893b1d994b6ebe6f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baae274fb72c91dbee441e20622cffdc218bdcb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/baae274fb72c91dbee441e20622cffdc218bdcb5", "html_url": "https://github.com/rust-lang/rust/commit/baae274fb72c91dbee441e20622cffdc218bdcb5"}], "stats": {"total": 169, "additions": 67, "deletions": 102}, "files": [{"sha": "2ca386e287d83e07c2cefc632235c0e2a7394c3e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -1607,7 +1607,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment::new(\n-            self.lower_ident(segment.identifier),\n+            self.lower_ident(segment.ident),\n             parameters,\n             infer_types,\n         )\n@@ -2356,11 +2356,11 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().identifier.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {\n-                        *name = path.segments.last().unwrap().identifier.name;\n+                        *name = path.segments.last().unwrap().ident.name;\n                     }\n                 }\n "}, {"sha": "e3b0d2c9d2cc571628a867f84116c34c9358b27e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -211,7 +211,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n         style.hash_stable(hcx, hasher);\n         path.segments.len().hash_stable(hcx, hasher);\n         for segment in &path.segments {\n-            segment.identifier.name.hash_stable(hcx, hasher);\n+            segment.ident.name.hash_stable(hcx, hasher);\n         }\n         for tt in tokens.trees() {\n             tt.hash_stable(hcx, hasher);"}, {"sha": "3598fe1d66cc43d51ee7c0c5db7fd165233f76fe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -115,7 +115,7 @@ impl<'a> Resolver<'a> {\n \n         let mut module_path: Vec<_> = prefix.segments.iter()\n             .chain(path.segments.iter())\n-            .map(|seg| respan(seg.span, seg.identifier))\n+            .map(|seg| respan(seg.span, seg.ident))\n             .collect();\n \n         match use_tree.kind {\n@@ -196,11 +196,7 @@ impl<'a> Resolver<'a> {\n             ast::UseTreeKind::Nested(ref items) => {\n                 let prefix = ast::Path {\n                     segments: module_path.iter()\n-                        .map(|s| ast::PathSegment {\n-                            identifier: s.node,\n-                            span: s.span,\n-                            parameters: None,\n-                        })\n+                        .map(|s| ast::PathSegment::from_ident(s.node, s.span))\n                         .collect(),\n                     span: path.span,\n                 };"}, {"sha": "b6a43949ca3d0fe62b89d7c5b481be822fdfc557", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -2351,7 +2351,7 @@ impl<'a> Resolver<'a> {\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| respan(seg.span, seg.identifier))\n+                .map(|seg| respan(seg.span, seg.ident))\n                 .collect();\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n@@ -2786,7 +2786,7 @@ impl<'a> Resolver<'a> {\n                           source: PathSource)\n                           -> PathResolution {\n         let segments = &path.segments.iter()\n-            .map(|seg| respan(seg.span, seg.identifier))\n+            .map(|seg| respan(seg.span, seg.ident))\n             .collect::<Vec<_>>();\n         self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n     }\n@@ -2924,7 +2924,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         ExprKind::MethodCall(ref segment, ..) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}(...)`?\",\n-                                                                 path_str, segment.identifier));\n+                                                                 path_str, segment.ident));\n                             return (err, candidates);\n                         }\n                         _ => {}\n@@ -3750,7 +3750,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(segment.identifier, ValueNS);\n+                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -4222,7 +4222,7 @@ impl<'a> Resolver<'a> {\n             if attr.path.segments.len() > 1 {\n                 continue\n             }\n-            let ident = attr.path.segments[0].identifier;\n+            let ident = attr.path.segments[0].ident;\n             let result = self.resolve_lexical_macro_path_segment(ident,\n                                                                  MacroNS,\n                                                                  false,\n@@ -4267,7 +4267,7 @@ fn names_to_string(idents: &[SpannedIdent]) -> String {\n \n fn path_names_to_string(path: &Path) -> String {\n     names_to_string(&path.segments.iter()\n-                        .map(|seg| respan(seg.span, seg.identifier))\n+                        .map(|seg| respan(seg.span, seg.ident))\n                         .collect::<Vec<_>>())\n }\n "}, {"sha": "c65ee11e427fa65808af7147f3c07b95cf7a80ea", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -137,9 +137,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n-                let ident = path.segments[0].identifier;\n+                let ident = path.segments[0].ident;\n                 if ident.name == keywords::DollarCrate.name() {\n-                    path.segments[0].identifier.name = keywords::CrateRoot.name();\n+                    path.segments[0].ident.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_root(ident.span.ctxt(), true);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n@@ -249,7 +249,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     if traits[j].segments.len() > 1 {\n                         continue\n                     }\n-                    let trait_name = traits[j].segments[0].identifier.name;\n+                    let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n                     if !self.global_macros.contains_key(&legacy_name) {\n                         continue\n@@ -268,7 +268,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                                 if k > 0 {\n                                     tokens.push(TokenTree::Token(path.span, Token::ModSep).into());\n                                 }\n-                                let tok = Token::from_ast_ident(segment.identifier);\n+                                let tok = Token::from_ast_ident(segment.ident);\n                                 tokens.push(TokenTree::Token(path.span, tok).into());\n                             }\n                         }\n@@ -365,7 +365,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let attr_name = match path.segments.len() {\n-            1 => path.segments[0].identifier.name,\n+            1 => path.segments[0].ident.name,\n             _ => return Err(determinacy),\n         };\n         for path in traits {\n@@ -413,7 +413,7 @@ impl<'a> Resolver<'a> {\n                                   kind: MacroKind, force: bool)\n                                   -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.ident)).collect();\n         let invocation = self.invocations[&scope];\n         let module = invocation.module.get();\n         self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };"}, {"sha": "32b80924e568d30b2c108e75657c3e17bade36ba", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -1146,16 +1146,8 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment {\n-        identifier: ast::Ident::from_str(path_str),\n-        span: DUMMY_SP,\n-        parameters: None,\n-    };\n-    let path = ast::Path {\n-        span: DUMMY_SP,\n-        segments: vec![segment],\n-    };\n-\n+    let segment = ast::PathSegment::from_ident(ast::Ident::from_str(path_str), DUMMY_SP);\n+    let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();\n     let res = resolver"}, {"sha": "a3839a861c6c70c0f0caed00b6897d0ad0ad4190", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -82,7 +82,7 @@ pub struct Path {\n \n impl<'a> PartialEq<&'a str> for Path {\n     fn eq(&self, string: &&'a str) -> bool {\n-        self.segments.len() == 1 && self.segments[0].identifier.name == *string\n+        self.segments.len() == 1 && self.segments[0].ident.name == *string\n     }\n }\n \n@@ -101,17 +101,17 @@ impl fmt::Display for Path {\n impl Path {\n     // convert a span and an identifier to the corresponding\n     // 1-segment path\n-    pub fn from_ident(s: Span, identifier: Ident) -> Path {\n+    pub fn from_ident(s: Span, ident: Ident) -> Path {\n         Path {\n             span: s,\n-            segments: vec![PathSegment::from_ident(identifier, s)],\n+            segments: vec![PathSegment::from_ident(ident, s)],\n         }\n     }\n \n     // Make a \"crate root\" segment for this path unless it already has it\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n-        if let Some(ident) = self.segments.get(0).map(|seg| seg.identifier) {\n+        if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n             if ::parse::token::is_path_segment_keyword(ident) &&\n                ident.name != keywords::Crate.name() {\n                 return None;\n@@ -121,7 +121,7 @@ impl Path {\n     }\n \n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].identifier.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n     }\n }\n \n@@ -131,7 +131,7 @@ impl Path {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    pub identifier: Ident,\n+    pub ident: Ident,\n     /// Span of the segment identifier.\n     pub span: Span,\n \n@@ -146,14 +146,10 @@ pub struct PathSegment {\n \n impl PathSegment {\n     pub fn from_ident(ident: Ident, span: Span) -> Self {\n-        PathSegment { identifier: ident, span: span, parameters: None }\n+        PathSegment { ident, span, parameters: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n-        PathSegment {\n-            identifier: Ident::new(keywords::CrateRoot.name(), span),\n-            span,\n-            parameters: None,\n-        }\n+        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span), span)\n     }\n }\n "}, {"sha": "739679b71d5b1a48bfde853f82299f33e401ca4d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -215,7 +215,7 @@ impl Attribute {\n \n     pub fn name(&self) -> Option<Name> {\n         match self.path.segments.len() {\n-            1 => Some(self.path.segments[0].identifier.name),\n+            1 => Some(self.path.segments[0].ident.name),\n             _ => None,\n         }\n     }\n@@ -301,7 +301,7 @@ impl Attribute {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n             name: match self.path.segments.len() {\n-                1 => self.path.segments[0].identifier.name,\n+                1 => self.path.segments[0].ident.name,\n                 _ => return None,\n             },\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n@@ -353,7 +353,7 @@ impl Attribute {\n         }\n \n         Ok(MetaItem {\n-            name: self.path.segments.last().unwrap().identifier.name,\n+            name: self.path.segments.last().unwrap().ident.name,\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })"}, {"sha": "8dabc03c2f95b3b4506ece43251bd1926e19f216", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -319,7 +319,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n-        let last_identifier = idents.pop().unwrap();\n+        let last_ident = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = Vec::new();\n \n         segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, span)));\n@@ -328,7 +328,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n+        segments.push(ast::PathSegment { ident: last_ident, span, parameters });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -367,7 +367,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             None\n         };\n         path.segments.push(ast::PathSegment {\n-            identifier: ident.node,\n+            ident: ident.node,\n             span: ident.span,\n             parameters,\n         });"}, {"sha": "6bf166dfe950a84dc3559068d200e132ee4d26e3", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -54,7 +54,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n             pretty_name.push_str(\", \");\n         }\n         pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).identifier.name);\n+        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n     pretty_name.push(')');\n "}, {"sha": "f9a6ab49039ddf0c1437fbe8d13c1791ee52fb94", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -168,10 +168,10 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n             path_str.push_str(\"::\");\n         }\n \n-        if segment.identifier.name != keywords::CrateRoot.name() &&\n-            segment.identifier.name != keywords::DollarCrate.name()\n+        if segment.ident.name != keywords::CrateRoot.name() &&\n+            segment.ident.name != keywords::DollarCrate.name()\n         {\n-            path_str.push_str(&segment.identifier.name.as_str())\n+            path_str.push_str(&segment.ident.name.as_str())\n         }\n     }\n \n@@ -688,7 +688,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             opt_expanded\n         } else {\n             let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                              name = path.segments[0].identifier.name, kind = kind.name());\n+                              name = path.segments[0].ident.name, kind = kind.name());\n             self.cx.span_err(path.span, &msg);\n             self.cx.trace_macros_diag();\n             kind.dummy(span)"}, {"sha": "b412c2fbc7f7cac7abf74f66dbb266a469d0b263", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -239,7 +239,7 @@ pub mod rt {\n                     inner.push(TokenTree::Token(self.span, token::Colon).into());\n                 }\n                 inner.push(TokenTree::Token(\n-                    self.span, token::Token::from_ast_ident(segment.identifier)\n+                    self.span, token::Token::from_ast_ident(segment.ident)\n                 ).into());\n             }\n             inner.push(self.tokens.clone());"}, {"sha": "c2a0fcc9d2f7a787766845919bd0534e632eae67", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -1766,10 +1766,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_path(&mut self, path: &'a ast::Path, _id: NodeId) {\n         for segment in &path.segments {\n-            if segment.identifier.name == keywords::Crate.name() {\n+            if segment.ident.name == keywords::Crate.name() {\n                 gate_feature_post!(&self, crate_in_paths, segment.span,\n                                    \"`crate` in paths is experimental\");\n-            } else if segment.identifier.name == keywords::Extern.name() {\n+            } else if segment.ident.name == keywords::Extern.name() {\n                 gate_feature_post!(&self, extern_in_paths, segment.span,\n                                    \"`extern` in paths is experimental\");\n             }"}, {"sha": "2c757a0a88738a2162473d3a5d306ec3218b3f4f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -449,8 +449,8 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {identifier, span, parameters}| PathSegment {\n-            identifier: fld.fold_ident(identifier),\n+        segments: segments.move_map(|PathSegment {ident, span, parameters}| PathSegment {\n+            ident: fld.fold_ident(ident),\n             span: fld.new_span(span),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n@@ -1195,7 +1195,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::MethodCall(seg, args) => {\n                 ExprKind::MethodCall(\n                     PathSegment {\n-                        identifier: folder.fold_ident(seg.identifier),\n+                        ident: folder.fold_ident(seg.ident),\n                         span: folder.new_span(seg.span),\n                         parameters: seg.parameters.map(|ps| {\n                             ps.map(|ps| folder.fold_path_parameters(ps))"}, {"sha": "81f8428c2c77ac620c690b1cb639d359e400b644", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -2051,7 +2051,7 @@ impl<'a> Parser<'a> {\n                 ParenthesizedParameterData { inputs, output, span }.into()\n             };\n \n-            PathSegment { identifier: ident, span: ident_span, parameters }\n+            PathSegment { ident, span: ident_span, parameters }\n         } else {\n             // Generic arguments are not found.\n             PathSegment::from_ident(ident, ident_span)\n@@ -2592,7 +2592,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let span = lo.to(self.prev_span);\n-                let ident = respan(segment.span, segment.identifier);\n+                let ident = respan(segment.span, segment.ident);\n                 self.mk_expr(span, ExprKind::Field(self_arg, ident), ThinVec::new())\n             }\n         })"}, {"sha": "b7026529a5ee515ea949957d6c8127dd86aad59d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -739,11 +739,11 @@ pub trait PrintState<'a> {\n                     if i > 0 {\n                         self.writer().word(\"::\")?\n                     }\n-                    if segment.identifier.name != keywords::CrateRoot.name() &&\n-                       segment.identifier.name != keywords::DollarCrate.name() {\n-                        self.writer().word(&segment.identifier.name.as_str())?;\n-                    } else if segment.identifier.name == keywords::DollarCrate.name() {\n-                        self.print_dollar_crate(segment.identifier.span.ctxt())?;\n+                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                       segment.ident.name != keywords::DollarCrate.name() {\n+                        self.writer().word(&segment.ident.name.as_str())?;\n+                    } else if segment.ident.name == keywords::DollarCrate.name() {\n+                        self.print_dollar_crate(segment.ident.span.ctxt())?;\n                     }\n                 }\n                 self.writer().space()?;\n@@ -1981,7 +1981,7 @@ impl<'a> State<'a> {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n-        self.print_ident(segment.identifier)?;\n+        self.print_ident(segment.ident)?;\n         if let Some(ref parameters) = segment.parameters {\n             self.print_path_parameters(parameters, true)?;\n         }\n@@ -2417,14 +2417,14 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.identifier.name != keywords::CrateRoot.name() &&\n-           segment.identifier.name != keywords::DollarCrate.name() {\n-            self.print_ident(segment.identifier)?;\n+        if segment.ident.name != keywords::CrateRoot.name() &&\n+           segment.ident.name != keywords::DollarCrate.name() {\n+            self.print_ident(segment.ident)?;\n             if let Some(ref parameters) = segment.parameters {\n                 self.print_path_parameters(parameters, colons_before_params)?;\n             }\n-        } else if segment.identifier.name == keywords::DollarCrate.name() {\n-            self.print_dollar_crate(segment.identifier.span.ctxt())?;\n+        } else if segment.ident.name == keywords::DollarCrate.name() {\n+            self.print_dollar_crate(segment.ident.span.ctxt())?;\n         }\n         Ok(())\n     }\n@@ -2446,7 +2446,7 @@ impl<'a> State<'a> {\n         self.s.word(\">\")?;\n         self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n-        self.print_ident(item_segment.identifier)?;\n+        self.print_ident(item_segment.ident)?;\n         match item_segment.parameters {\n             Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n             None => Ok(()),"}, {"sha": "88fddb13686890db29b730890c1c618aaee0053b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -372,7 +372,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n-    visitor.visit_ident(path_span, segment.identifier);\n+    visitor.visit_ident(path_span, segment.ident);\n     if let Some(ref parameters) = segment.parameters {\n         visitor.visit_path_parameters(path_span, parameters);\n     }"}, {"sha": "c51f44cdeced25ada836399042a881305523562a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -367,7 +367,7 @@ fn find_type_parameters(ty: &ast::Ty,\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n             if let ast::TyKind::Path(_, ref path) = ty.node {\n                 if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.identifier.name) {\n+                    if self.ty_param_names.contains(&segment.ident.name) {\n                         self.types.push(P(ty.clone()));\n                     }\n                 }\n@@ -622,7 +622,7 @@ impl<'a> TraitDef<'a> {\n                         // if we have already handled this type, skip it\n                         if let ast::TyKind::Path(_, ref p) = ty.node {\n                             if p.segments.len() == 1 &&\n-                            ty_param_names.contains(&p.segments[0].identifier.name) ||\n+                            ty_param_names.contains(&p.segments[0].ident.name) ||\n                             processed_field_types.contains(&p.segments) {\n                                 continue;\n                             };"}, {"sha": "0406d2d22f435034ec0f75d9ca623f3e6e34e2cd", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8719d1ed05761b344d611ae0893b1d994b6ebe6f/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=8719d1ed05761b344d611ae0893b1d994b6ebe6f", "patch": "@@ -61,15 +61,8 @@ fn expr(kind: ExprKind) -> P<Expr> {\n }\n \n fn make_x() -> P<Expr> {\n-    let seg = PathSegment {\n-        identifier: Ident::from_str(\"x\"),\n-        span: DUMMY_SP,\n-        parameters: None,\n-    };\n-    let path = Path {\n-        span: DUMMY_SP,\n-        segments: vec![seg],\n-    };\n+    let seg = PathSegment::from_ident(Ident::from_str(\"x\"), DUMMY_SP);\n+    let path = Path { segments: vec![seg], span: DUMMY_SP };\n     expr(ExprKind::Path(None, path))\n }\n \n@@ -89,12 +82,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n             1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n             2 => {\n-                let seg = PathSegment {\n-                    identifier: Ident::from_str(\"x\"),\n-                    span: DUMMY_SP,\n-                    parameters: None,\n-                };\n-\n+                let seg = PathSegment::from_ident(Ident::from_str(\"x\"), DUMMY_SP);\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n                             seg.clone(), vec![e, make_x()])));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n@@ -163,15 +151,8 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n             },\n             14 => {\n-                let seg = PathSegment {\n-                    identifier: Ident::from_str(\"S\"),\n-                    span: DUMMY_SP,\n-                    parameters: None,\n-                };\n-                let path = Path {\n-                    span: DUMMY_SP,\n-                    segments: vec![seg],\n-                };\n+                let seg = PathSegment::new(Ident::from_str(\"S\"), DUMMY_SP);\n+                let path = Path { segments: vec![seg], span: DUMMY_SP };\n                 g(ExprKind::Struct(path, vec![], Some(make_x())));\n             },\n             15 => {"}]}