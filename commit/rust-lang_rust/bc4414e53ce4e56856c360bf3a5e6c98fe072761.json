{"sha": "bc4414e53ce4e56856c360bf3a5e6c98fe072761", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNDQxNGU1M2NlNGU1Njg1NmMzNjBiZjNhNWU2Yzk4ZmUwNzI3NjE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-10-15T20:01:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-15T20:01:40Z"}, "message": "Merge pull request #3101 from nrc/pair-newline\n\nSimplify multi-lining binop exprs", "tree": {"sha": "6345e839776d5970ce04c4700c47102a6ce86cb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6345e839776d5970ce04c4700c47102a6ce86cb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4414e53ce4e56856c360bf3a5e6c98fe072761", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbxPIkCRBK7hj4Ov3rIwAAdHIIAGZ+h1I3CkifFfG/hNwxPNxK\nGBvELF3x3R0zMbo+rTV5W+TobXLafToXSajH8i1XAxZ3FirnNEemANsgB5e5VMbb\nV0giwcYyjasxJgkl8mHY2ZuDXBqXdvOKfwcCtjP83EvT9g4A1A+KHpvD3gXYPVsG\n8ssxKupkTZHDXhttMm+xXZVJzWheZG49Bxx83Jbl4L3g6asCVp+hl0C5xib8MMWi\nhQp1SSrsuCDJnpbKhbLA496DPVyr/0jBOrd9z4R7mDtMiXDIDrtN4H9XP8KchD32\nCCJvvEpH3nBjvsKEqQRFVQwD32BmMdRbJtMnfubIZeGb6IOj8vwuBCKba3CZBDU=\n=zz4j\n-----END PGP SIGNATURE-----\n", "payload": "tree 6345e839776d5970ce04c4700c47102a6ce86cb1\nparent 075aa909cd2bcdc603f45e0b65119c6a7e3b2030\nparent 7be173eb8c9e043fbe814970c93dc7d98ddc8009\nauthor Nick Cameron <nrc@ncameron.org> 1539633700 +1300\ncommitter GitHub <noreply@github.com> 1539633700 +1300\n\nMerge pull request #3101 from nrc/pair-newline\n\nSimplify multi-lining binop exprs"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4414e53ce4e56856c360bf3a5e6c98fe072761", "html_url": "https://github.com/rust-lang/rust/commit/bc4414e53ce4e56856c360bf3a5e6c98fe072761", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4414e53ce4e56856c360bf3a5e6c98fe072761/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075aa909cd2bcdc603f45e0b65119c6a7e3b2030", "url": "https://api.github.com/repos/rust-lang/rust/commits/075aa909cd2bcdc603f45e0b65119c6a7e3b2030", "html_url": "https://github.com/rust-lang/rust/commit/075aa909cd2bcdc603f45e0b65119c6a7e3b2030"}, {"sha": "7be173eb8c9e043fbe814970c93dc7d98ddc8009", "url": "https://api.github.com/repos/rust-lang/rust/commits/7be173eb8c9e043fbe814970c93dc7d98ddc8009", "html_url": "https://github.com/rust-lang/rust/commit/7be173eb8c9e043fbe814970c93dc7d98ddc8009"}], "stats": {"total": 138, "additions": 70, "deletions": 68}, "files": [{"sha": "82d2a43ad072bd33ab1315e32c46288e0f71225d", "filename": "src/expr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -898,10 +898,11 @@ impl<'a> ControlFlow<'a> {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if let Some(cond_str) = trial {\n-                if cond_str.len() <= context\n-                    .config\n-                    .width_heuristics()\n-                    .single_line_if_else_max_width\n+                if cond_str.len()\n+                    <= context\n+                        .config\n+                        .width_heuristics()\n+                        .single_line_if_else_max_width\n                 {\n                     return Some((cond_str, 0));\n                 }"}, {"sha": "6005ae6fd259a429db2d41c8070da685655381b6", "filename": "src/lists.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -146,10 +146,12 @@ impl ListItem {\n     }\n \n     pub fn is_different_group(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some() || self\n-            .post_comment\n-            .as_ref()\n-            .map_or(false, |s| s.contains('\\n'))\n+        self.inner_as_ref().contains('\\n')\n+            || self.pre_comment.is_some()\n+            || self\n+                .post_comment\n+                .as_ref()\n+                .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn is_multiline(&self) -> bool {"}, {"sha": "49f4a03ee1db8a7afecdf7f05e8eb8186b6817df", "filename": "src/macros.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -1168,22 +1168,24 @@ fn indent_macro_snippet(\n         .min()?;\n \n     Some(\n-        first_line + \"\\n\" + &trimmed_lines\n-            .iter()\n-            .map(\n-                |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n-                    _ if !trimmed => line.to_owned(),\n-                    Some(original_indent_width) => {\n-                        let new_indent_width = indent.width() + original_indent_width\n-                            .saturating_sub(min_prefix_space_width);\n-                        let new_indent = Indent::from_width(context.config, new_indent_width);\n-                        format!(\"{}{}\", new_indent.to_string(context.config), line)\n-                    }\n-                    None => String::new(),\n-                },\n-            )\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\"),\n+        first_line\n+            + \"\\n\"\n+            + &trimmed_lines\n+                .iter()\n+                .map(\n+                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n+                        _ if !trimmed => line.to_owned(),\n+                        Some(original_indent_width) => {\n+                            let new_indent_width = indent.width()\n+                                + original_indent_width.saturating_sub(min_prefix_space_width);\n+                            let new_indent = Indent::from_width(context.config, new_indent_width);\n+                            format!(\"{}{}\", new_indent.to_string(context.config), line)\n+                        }\n+                        None => String::new(),\n+                    },\n+                )\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n     )\n }\n "}, {"sha": "79ae3081f1f8886dffbb11642e9c3b536f38d09f", "filename": "src/pairs.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn rewrite_all_pairs(\n     context: &RewriteContext,\n ) -> Option<String> {\n     // First we try formatting on one line.\n-    if let Some(list) = expr.flatten(context, false) {\n+    if let Some(list) = expr.flatten(false) {\n         if let Some(r) = rewrite_pairs_one_line(&list, shape, context) {\n             return Some(r);\n         }\n@@ -53,7 +53,7 @@ pub(crate) fn rewrite_all_pairs(\n     // to only flatten pairs with the same operator, that way we don't\n     // necessarily need one line per sub-expression, but we don't do anything\n     // too funny wrt precedence.\n-    expr.flatten(context, true)\n+    expr.flatten(true)\n         .and_then(|list| rewrite_pairs_multiline(list, shape, context))\n }\n \n@@ -83,33 +83,22 @@ fn rewrite_pairs_one_line<T: Rewrite>(\n         result.push(' ');\n     }\n \n+    let prefix_len = result.len();\n     let last = list.list.last().unwrap();\n     let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n-    let rewrite = last.rewrite(context, cur_shape)?;\n-    result.push_str(&rewrite);\n+    let last_rewrite = last.rewrite(context, cur_shape)?;\n+    result.push_str(&last_rewrite);\n \n     if first_line_width(&result) > shape.width {\n         return None;\n     }\n \n-    // Check the last expression in the list. We let this expression go over\n-    // multiple lines, but we check that if this is necessary, then we can't\n-    // do better using multi-line formatting.\n-    if !is_single_line(&result) {\n-        let multiline_shape = shape.offset_left(list.separators.last().unwrap().len() + 1)?;\n-        let multiline_list: PairList<T> = PairList {\n-            list: vec![last],\n-            separators: vec![],\n-            separator_place: list.separator_place,\n-        };\n-        // Format as if we were multi-line.\n-        if let Some(rewrite) = rewrite_pairs_multiline(multiline_list, multiline_shape, context) {\n-            // Also, don't let expressions surrounded by parens go multi-line,\n-            // this looks really bad.\n-            if rewrite.starts_with('(') || is_single_line(&rewrite) {\n-                return None;\n-            }\n-        }\n+    // Check the last expression in the list. We sometimes let this expression\n+    // go over multiple lines, but we check for some ugly conditions.\n+    if !(is_single_line(&result) || last_rewrite.starts_with('{'))\n+        && (last_rewrite.starts_with('(') || prefix_len > context.config.tab_spaces())\n+    {\n+        return None;\n     }\n \n     wrap_str(result, context.config.max_width(), shape)\n@@ -215,11 +204,12 @@ where\n         // If the length of the lhs is equal to or shorter than the tab width or\n         // the rhs looks like block expression, we put the rhs on the same\n         // line with the lhs even if the rhs is multi-lined.\n-        let allow_same_line = lhs_result.len() <= tab_spaces || rhs_result\n-            .lines()\n-            .next()\n-            .map(|first_line| first_line.ends_with('{'))\n-            .unwrap_or(false);\n+        let allow_same_line = lhs_result.len() <= tab_spaces\n+            || rhs_result\n+                .lines()\n+                .next()\n+                .map(|first_line| first_line.ends_with('{'))\n+                .unwrap_or(false);\n         if !rhs_result.contains('\\n') || allow_same_line {\n             let one_line_width = last_line_width(&lhs_result)\n                 + pp.infix.len()\n@@ -272,19 +262,18 @@ trait FlattenPair: Rewrite + Sized {\n     // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n     // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n     // `[a, b, c]`\n-    fn flatten(&self, _context: &RewriteContext, _same_op: bool) -> Option<PairList<Self>> {\n+    fn flatten(&self, _same_op: bool) -> Option<PairList<Self>> {\n         None\n     }\n }\n \n struct PairList<'a, 'b, T: Rewrite + 'b> {\n     list: Vec<&'b T>,\n     separators: Vec<&'a str>,\n-    separator_place: SeparatorPlace,\n }\n \n impl FlattenPair for ast::Expr {\n-    fn flatten(&self, context: &RewriteContext, same_op: bool) -> Option<PairList<ast::Expr>> {\n+    fn flatten(&self, same_op: bool) -> Option<PairList<ast::Expr>> {\n         let top_op = match self.node {\n             ast::ExprKind::Binary(op, _, _) => op.node,\n             _ => return None,\n@@ -320,11 +309,7 @@ impl FlattenPair for ast::Expr {\n         }\n \n         assert_eq!(list.len() - 1, separators.len());\n-        Some(PairList {\n-            list,\n-            separators,\n-            separator_place: context.config.binop_separator(),\n-        })\n+        Some(PairList { list, separators })\n     }\n }\n "}, {"sha": "f98c4189ea53735e1041ed12db7254c44f9e11c1", "filename": "src/string.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -291,11 +291,12 @@ fn break_string(max_chars: usize, trim_end: bool, line_end: &str, input: &[&str]\n         return break_at(max_chars - 1);\n     }\n     if let Some(url_index_end) = detect_url(input, max_chars) {\n-        let index_plus_ws = url_index_end + input[url_index_end..]\n-            .iter()\n-            .skip(1)\n-            .position(|grapheme| not_whitespace_except_line_feed(grapheme))\n-            .unwrap_or(0);\n+        let index_plus_ws = url_index_end\n+            + input[url_index_end..]\n+                .iter()\n+                .skip(1)\n+                .position(|grapheme| not_whitespace_except_line_feed(grapheme))\n+                .unwrap_or(0);\n         return if trim_end {\n             SnippetState::LineEnd(\n                 input[..=url_index_end].join(\"\").to_string(),"}, {"sha": "8cc1b974f48c281dbf1f9b779bedcc1dd40c9040", "filename": "src/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -326,10 +326,11 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n // Return true if the given span does not intersect with file lines.\n macro_rules! out_of_file_lines_range {\n     ($self:ident, $span:expr) => {\n-        !$self.config.file_lines().is_all() && !$self\n-            .config\n-            .file_lines()\n-            .intersects(&$self.source_map.lookup_line_range($span))\n+        !$self.config.file_lines().is_all()\n+            && !$self\n+                .config\n+                .file_lines()\n+                .intersects(&$self.source_map.lookup_line_range($span))\n     };\n }\n "}, {"sha": "c77f5bac4cb21b58316ef7b1ef462b6ad26880f4", "filename": "tests/source/chains.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -259,3 +259,8 @@ fn issue_2773() {\n             None\n         });\n }\n+\n+fn issue_3034() {\n+    disallowed_headers.iter().any(|header| *header == name) ||\n+        disallowed_header_prefixes.iter().any(|prefix| name.starts_with(prefix))\n+}"}, {"sha": "292da298195447a59a42531f4addbd4f0b5e8ac5", "filename": "tests/target/chains.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4414e53ce4e56856c360bf3a5e6c98fe072761/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4414e53ce4e56856c360bf3a5e6c98fe072761/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=bc4414e53ce4e56856c360bf3a5e6c98fe072761", "patch": "@@ -299,3 +299,8 @@ fn issue_2773() {\n         None\n     });\n }\n+\n+fn issue_3034() {\n+    disallowed_headers.iter().any(|header| *header == name)\n+        || disallowed_header_prefixes.iter().any(|prefix| name.starts_with(prefix))\n+}"}]}