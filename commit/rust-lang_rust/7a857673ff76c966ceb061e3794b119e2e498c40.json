{"sha": "7a857673ff76c966ceb061e3794b119e2e498c40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhODU3NjczZmY3NmM5NjZjZWIwNjFlMzc5NGIxMTllMmU0OThjNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-01T00:39:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-01T00:39:36Z"}, "message": "auto merge of #6103 : catamorphism/rust/nonfatal-errors, r=catamorphism\n\nr? @nikomatsakis typeck::check::_match wasn't suppressing derived errors properly.\r\nFixed it. (This will fix #5100)", "tree": {"sha": "fc892d62bbdcf12076f7c30e8a3c5e50e9979741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc892d62bbdcf12076f7c30e8a3c5e50e9979741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a857673ff76c966ceb061e3794b119e2e498c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a857673ff76c966ceb061e3794b119e2e498c40", "html_url": "https://github.com/rust-lang/rust/commit/7a857673ff76c966ceb061e3794b119e2e498c40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a857673ff76c966ceb061e3794b119e2e498c40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9329bd669d704fffeed90c1f6703518345e6c2fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9329bd669d704fffeed90c1f6703518345e6c2fd", "html_url": "https://github.com/rust-lang/rust/commit/9329bd669d704fffeed90c1f6703518345e6c2fd"}, {"sha": "4493cf49cdaeb7aea974b9155a678fb8c9e3e390", "url": "https://api.github.com/repos/rust-lang/rust/commits/4493cf49cdaeb7aea974b9155a678fb8c9e3e390", "html_url": "https://github.com/rust-lang/rust/commit/4493cf49cdaeb7aea974b9155a678fb8c9e3e390"}], "stats": {"total": 247, "additions": 166, "deletions": 81}, "files": [{"sha": "5ff7105712183443e421940dc1769e2adb89d0f7", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 104, "deletions": 70, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7a857673ff76c966ceb061e3794b119e2e498c40", "patch": "@@ -175,11 +175,18 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n             kind_name = \"structure\";\n         }\n         _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                fmt!(\"mismatched types: expected `%s` but found enum or \\\n-                      structure\",\n-                     fcx.infcx().ty_to_str(expected)));\n+            let resolved_expected =\n+                fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+            fcx.infcx().type_error_message_str(pat.span,\n+                                               |actual| {\n+                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                         resolved_expected, actual)},\n+                    ~\"an enum or structure pattern\",\n+                    None);\n+            fcx.write_error(pat.id);\n+            kind_name = \"[error]\";\n+            arg_types = (copy subpats).get_or_default(~[]).map(|_|\n+                                                               ty::mk_err());\n         }\n     }\n \n@@ -486,74 +493,44 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_tup(ref elts) => {\n         let s = structure_of(fcx, pat.span, expected);\n-        let ex_elts = match s {\n-          ty::ty_tup(ref elts) => elts,\n-          _ => {\n-            tcx.sess.span_fatal\n-                (pat.span,\n-                 fmt!(\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.infcx().ty_to_str(expected)));\n-          }\n-        };\n         let e_count = elts.len();\n-        if e_count != ex_elts.len() {\n-            tcx.sess.span_fatal\n-                (pat.span, fmt!(\"mismatched types: expected a tuple \\\n-                      with %u fields, found one with %u \\\n-                      fields\", ex_elts.len(), e_count));\n-        }\n-        let mut i = 0u;\n-        for elts.each |elt| {\n-            check_pat(pcx, *elt, ex_elts[i]);\n-            i += 1u;\n+        match s {\n+            ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n+                for elts.eachi |i, elt| {\n+                    check_pat(pcx, *elt, ex_elts[i]);\n+                }\n+                fcx.write_ty(pat.id, expected);\n+            }\n+            _ => {\n+                for elts.each |elt| {\n+                    check_pat(pcx, *elt, ty::mk_err());\n+                }\n+                let actual = ty::mk_tup(tcx, elts.map(|pat_var| {\n+                    fcx.node_ty(pat_var.id)\n+                }));\n+                // use terr_tuple_size if both types are tuples\n+                let type_error = match s {\n+                    ty::ty_tup(ref ex_elts) =>\n+                        ty::terr_tuple_size(ty::expected_found{expected: ex_elts.len(),\n+                                                           found: e_count}),\n+                    _ => ty::terr_mismatch\n+                };\n+                fcx.infcx().report_mismatched_types(pat.span,\n+                                                    expected,\n+                                                    actual,\n+                                                    &type_error);\n+                fcx.write_error(pat.id);\n+            }\n         }\n-\n-        fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_box(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_box(e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found box\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Managed, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_uniq(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_uniq(e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found uniq\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Owned, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_region(inner) => {\n-        match structure_of(fcx, pat.span, expected) {\n-          ty::ty_rptr(_, e_inner) => {\n-            check_pat(pcx, inner, e_inner.ty);\n-            fcx.write_ty(pat.id, expected);\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                ~\"mismatched types: expected `\" +\n-                fcx.infcx().ty_to_str(expected) +\n-                ~\"` found borrowed pointer\");\n-          }\n-        }\n+          check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         let default_region_var =\n@@ -577,11 +554,25 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             (mt, default_region_var)\n           },\n           _ => {\n-            tcx.sess.span_fatal(\n-                pat.span,\n-                fmt!(\"mismatched type: expected `%s` but found vector\",\n-                     fcx.infcx().ty_to_str(expected))\n-            );\n+              for before.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              for slice.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              for after.each |&elt| {\n+                  check_pat(pcx, elt, ty::mk_err());\n+              }\n+              let resolved_expected =\n+                  fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+              fcx.infcx().type_error_message_str(pat.span,\n+                  |actual| {\n+                      fmt!(\"mismatched types: expected `%s` but found %s\",\n+                           resolved_expected, actual)},\n+                                                 ~\"a vector pattern\",\n+                                                 None);\n+              fcx.write_error(pat.id);\n+              return;\n           }\n         };\n         for before.each |elt| {\n@@ -605,3 +596,46 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     }\n }\n \n+// Helper function to check @, ~ and & patterns\n+pub fn check_pointer_pat(pcx: &pat_ctxt,\n+                         pointer_kind: PointerKind,\n+                         inner: @ast::pat,\n+                         pat_id: ast::node_id,\n+                         span: span,\n+                         expected: ty::t) {\n+    let fcx = pcx.fcx;\n+    let check_inner: &fn(ty::mt) = |e_inner| {\n+        check_pat(pcx, inner, e_inner.ty);\n+        fcx.write_ty(pat_id, expected);\n+    };\n+    match structure_of(fcx, span, expected) {\n+        ty::ty_box(e_inner) if pointer_kind == Managed => {\n+            check_inner(e_inner);\n+        }\n+        ty::ty_uniq(e_inner) if pointer_kind == Owned => {\n+            check_inner(e_inner);\n+        }\n+        ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n+            check_inner(e_inner);\n+        }\n+        _ => {\n+            check_pat(pcx, inner, ty::mk_err());\n+            let resolved_expected =\n+                fcx.infcx().ty_to_str(fcx.infcx().resolve_type_vars_if_possible(expected));\n+            fcx.infcx().type_error_message_str(span, |actual| {\n+                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                         resolved_expected, actual)},\n+                                               fmt!(\"%s pattern\", match pointer_kind {\n+                                                   Managed => \"an @-box\",\n+                                                   Owned => \"a ~-box\",\n+                                                   Borrowed => \"an &-pointer\"\n+                                               }),\n+                    None);\n+            fcx.write_error(pat_id);\n+          }\n+    }\n+}\n+\n+#[deriving(Eq)]\n+enum PointerKind { Managed, Owned, Borrowed }\n+"}, {"sha": "8f709e7cd5af10e81f025bba0cfaac49dca88694", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=7a857673ff76c966ceb061e3794b119e2e498c40", "patch": "@@ -749,25 +749,32 @@ pub impl InferCtxt {\n         }\n     }\n \n-    fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n-                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n-        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n-        // Don't report an error if actual type is ty_err.\n-        if ty::type_is_error(actual_ty) {\n-            return;\n-        }\n+    fn type_error_message_str(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n+                          actual_ty: ~str, err: Option<&ty::type_err>) {\n         let error_str = err.map_default(~\"\", |t_err|\n                          fmt!(\" (%s)\",\n                               ty::type_err_to_str(self.tcx, *t_err)));\n         self.tcx.sess.span_err(sp,\n-           fmt!(\"%s%s\", mk_msg(self.ty_to_str(actual_ty)),\n-                error_str));\n+           fmt!(\"%s%s\", mk_msg(actual_ty), error_str));\n         for err.each |err| {\n             ty::note_and_explain_type_err(self.tcx, *err)\n         }\n     }\n \n+    fn type_error_message(@mut self, sp: span, mk_msg: &fn(~str) -> ~str,\n+                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+\n+        // Don't report an error if actual type is ty_err.\n+        if ty::type_is_error(actual_ty) {\n+            return;\n+        }\n+\n+        self.type_error_message_str(sp, mk_msg, self.ty_to_str(actual_ty),\n+                                    err);\n+    }\n+\n     fn report_mismatched_types(@mut self, sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n         let resolved_expected ="}, {"sha": "6ea0300cf1e7dff74a7560a6b84454ee02fa9634", "filename": "src/test/compile-fail/alt-vec-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs?ref=7a857673ff76c966ceb061e3794b119e2e498c40", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     match () {\n-        [()] => { } //~ ERROR mismatched type: expected `()` but found vector\n+        [()] => { } //~ ERROR mismatched types: expected `()` but found a vector pattern\n     }\n }"}, {"sha": "85ed8761ee935606d26936ecae7a072a228f08f2", "filename": "src/test/compile-fail/alt-vec-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs?ref=7a857673ff76c966ceb061e3794b119e2e498c40", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     match ~\"foo\" {\n-        ['f', 'o', .._] => { } //~ ERROR mismatched type: expected `~str` but found vector\n+        ['f', 'o', .._] => { } //~ ERROR mismatched types: expected `~str` but found a vector pattern\n         _ => { }\n     }\n }"}, {"sha": "dbfdb38f7211fd6a237d44da7895677a447581be", "filename": "src/test/compile-fail/issue-5100.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a857673ff76c966ceb061e3794b119e2e498c40/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=7a857673ff76c966ceb061e3794b119e2e498c40", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum A { B, C }\n+\n+fn main() {\n+    match (true, false) {\n+        B => (), //~ ERROR expected `(bool,bool)` but found an enum or structure pattern\n+        _ => ()\n+    }\n+\n+    match (true, false) {\n+        (true, false, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found `(bool,bool,bool)` (expected a tuple with 2 elements but found one with 3 elements)\n+    }\n+\n+    match (true, false) {\n+        @(true, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found an @-box pattern\n+    }\n+\n+    match (true, false) {\n+        ~(true, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found a ~-box pattern\n+    }\n+\n+    match (true, false) {\n+        &(true, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found an &-pointer pattern\n+    }\n+\n+\n+    let v = [('a', 'b')   //~ ERROR expected function but found `(char,char)`\n+             ('c', 'd'),\n+             ('e', 'f')];\n+\n+    for v.each |&(x,y)| {} // should be OK\n+\n+    // Make sure none of the errors above were fatal\n+    let x: char = true; //~ ERROR expected `char` but found `bool`\n+}"}]}