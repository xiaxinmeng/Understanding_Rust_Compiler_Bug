{"sha": "aa78c3d6f6b25a0e54f815cd8db765000763e48a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNzhjM2Q2ZjZiMjVhMGU1NGY4MTVjZDhkYjc2NTAwMDc2M2U0OGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-05T19:29:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Clean up the remaining chunks of uv", "tree": {"sha": "45f44d0574eaf91987954e811a02d4010d76c99c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f44d0574eaf91987954e811a02d4010d76c99c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa78c3d6f6b25a0e54f815cd8db765000763e48a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa78c3d6f6b25a0e54f815cd8db765000763e48a", "html_url": "https://github.com/rust-lang/rust/commit/aa78c3d6f6b25a0e54f815cd8db765000763e48a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa78c3d6f6b25a0e54f815cd8db765000763e48a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "584b3593485ef144de7217de19ac8a98766c0532", "url": "https://api.github.com/repos/rust-lang/rust/commits/584b3593485ef144de7217de19ac8a98766c0532", "html_url": "https://github.com/rust-lang/rust/commit/584b3593485ef144de7217de19ac8a98766c0532"}], "stats": {"total": 226, "additions": 105, "deletions": 121}, "files": [{"sha": "965e97893b6404303b4fbae7dc8340afef21fafb", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -17,7 +17,7 @@ use std::rt::local::Local;\n use std::rt::sched::Scheduler;\n \n use net;\n-use super::{Loop, UvError, NativeHandle, Request};\n+use super::{Loop, UvError, Request};\n use uvll;\n \n struct Addrinfo {\n@@ -79,7 +79,7 @@ impl GetAddrInfoRequest {\n         let req = Request::new(uvll::UV_GETADDRINFO);\n \n         return match unsafe {\n-            uvll::uv_getaddrinfo(loop_.native_handle(), req.handle,\n+            uvll::uv_getaddrinfo(loop_.handle, req.handle,\n                                  getaddrinfo_cb, c_node_ptr, c_service_ptr,\n                                  hint_ptr)\n         } {"}, {"sha": "f4c7f633ee264503c672f6928ca948e614c2fd20", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -35,7 +35,7 @@ impl AsyncWatcher {\n     pub fn new(loop_: &mut Loop, cb: ~Callback) -> AsyncWatcher {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n         assert_eq!(unsafe {\n-            uvll::uv_async_init(loop_.native_handle(), handle, async_cb)\n+            uvll::uv_async_init(loop_.handle, handle, async_cb)\n         }, 0);\n         let flag = Exclusive::new(false);\n         let payload = ~Payload { callback: cb, exit_flag: flag.clone() };"}, {"sha": "e042b7744be7a24a9db20c17f0e5bf92ff28a7b9", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -22,7 +22,7 @@ use std::rt::local::Local;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::vec;\n \n-use super::{NativeHandle, Loop, UvError, uv_error_to_io_error};\n+use super::{Loop, UvError, uv_error_to_io_error};\n use uvio::HomingIO;\n use uvll;\n \n@@ -43,7 +43,7 @@ impl FsRequest {\n         -> Result<FileWatcher, UvError>\n     {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_open(loop_.native_handle(),\n+            uvll::uv_fs_open(loop_.handle,\n                              req, path.with_ref(|p| p), flags as c_int,\n                              mode as c_int, cb)\n         }).map(|req|\n@@ -54,21 +54,21 @@ impl FsRequest {\n \n     pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_unlink(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_unlink(loop_.handle, req, path.with_ref(|p| p),\n                                cb)\n         })\n     }\n \n     pub fn lstat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_lstat(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_lstat(loop_.handle, req, path.with_ref(|p| p),\n                               cb)\n         }).map(|req| req.mkstat())\n     }\n \n     pub fn stat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_stat(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_stat(loop_.handle, req, path.with_ref(|p| p),\n                              cb)\n         }).map(|req| req.mkstat())\n     }\n@@ -77,7 +77,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_write(loop_.native_handle(), req,\n+            uvll::uv_fs_write(loop_.handle, req,\n                               fd, vec::raw::to_ptr(buf) as *c_void,\n                               buf.len() as c_uint, offset, cb)\n         })\n@@ -87,7 +87,7 @@ impl FsRequest {\n         -> Result<int, UvError>\n     {\n         do execute(|req, cb| unsafe {\n-            uvll::uv_fs_read(loop_.native_handle(), req,\n+            uvll::uv_fs_read(loop_.handle, req,\n                              fd, vec::raw::to_ptr(buf) as *c_void,\n                              buf.len() as c_uint, offset, cb)\n         }).map |req| {\n@@ -98,12 +98,12 @@ impl FsRequest {\n     pub fn close(loop_: &Loop, fd: c_int, sync: bool) -> Result<(), UvError> {\n         if sync {\n             execute_nop(|req, cb| unsafe {\n-                uvll::uv_fs_close(loop_.native_handle(), req, fd, cb)\n+                uvll::uv_fs_close(loop_.handle, req, fd, cb)\n             })\n         } else {\n             unsafe {\n                 let req = uvll::malloc_req(uvll::UV_FS);\n-                uvll::uv_fs_close(loop_.native_handle(), req, fd, close_cb);\n+                uvll::uv_fs_close(loop_.handle, req, fd, close_cb);\n                 return Ok(());\n             }\n \n@@ -120,14 +120,14 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_mkdir(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_mkdir(loop_.handle, req, path.with_ref(|p| p),\n                               mode, cb)\n         })\n     }\n \n     pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_rmdir(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_rmdir(loop_.handle, req, path.with_ref(|p| p),\n                               cb)\n         })\n     }\n@@ -136,7 +136,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_rename(loop_.native_handle(),\n+            uvll::uv_fs_rename(loop_.handle,\n                                req,\n                                path.with_ref(|p| p),\n                                to.with_ref(|p| p),\n@@ -148,7 +148,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_chmod(loop_.native_handle(), req, path.with_ref(|p| p),\n+            uvll::uv_fs_chmod(loop_.handle, req, path.with_ref(|p| p),\n                               mode, cb)\n         })\n     }\n@@ -157,7 +157,7 @@ impl FsRequest {\n         -> Result<~[Path], UvError>\n     {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_readdir(loop_.native_handle(),\n+            uvll::uv_fs_readdir(loop_.handle,\n                                 req, path.with_ref(|p| p), flags, cb)\n         }).map(|req| unsafe {\n             let mut paths = ~[];\n@@ -174,7 +174,7 @@ impl FsRequest {\n \n     pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> {\n         do execute(|req, cb| unsafe {\n-            uvll::uv_fs_readlink(loop_.native_handle(), req,\n+            uvll::uv_fs_readlink(loop_.handle, req,\n                                  path.with_ref(|p| p), cb)\n         }).map |req| {\n             Path::new(unsafe {\n@@ -187,7 +187,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_chown(loop_.native_handle(),\n+            uvll::uv_fs_chown(loop_.handle,\n                               req, path.with_ref(|p| p),\n                               uid as uvll::uv_uid_t,\n                               gid as uvll::uv_gid_t,\n@@ -199,15 +199,15 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_ftruncate(loop_.native_handle(), req, file, offset, cb)\n+            uvll::uv_fs_ftruncate(loop_.handle, req, file, offset, cb)\n         })\n     }\n \n     pub fn link(loop_: &Loop, src: &CString, dst: &CString)\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_link(loop_.native_handle(), req,\n+            uvll::uv_fs_link(loop_.handle, req,\n                              src.with_ref(|p| p),\n                              dst.with_ref(|p| p),\n                              cb)\n@@ -218,7 +218,7 @@ impl FsRequest {\n         -> Result<(), UvError>\n     {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_symlink(loop_.native_handle(), req,\n+            uvll::uv_fs_symlink(loop_.handle, req,\n                                 src.with_ref(|p| p),\n                                 dst.with_ref(|p| p),\n                                 0, cb)\n@@ -227,13 +227,13 @@ impl FsRequest {\n \n     pub fn fsync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_fsync(loop_.native_handle(), req, fd, cb)\n+            uvll::uv_fs_fsync(loop_.handle, req, fd, cb)\n         })\n     }\n \n     pub fn datasync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n         execute_nop(|req, cb| unsafe {\n-            uvll::uv_fs_fdatasync(loop_.native_handle(), req, fd, cb)\n+            uvll::uv_fs_fdatasync(loop_.handle, req, fd, cb)\n         })\n     }\n "}, {"sha": "f4072c7c6813b8a4280f738bae5b6c021c8bf3b3", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -26,7 +26,7 @@ impl IdleWatcher {\n     pub fn new(loop_: &mut Loop) -> ~IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         assert_eq!(unsafe {\n-            uvll::uv_idle_init(loop_.native_handle(), handle)\n+            uvll::uv_idle_init(loop_.handle, handle)\n         }, 0);\n         let me = ~IdleWatcher {\n             handle: handle,\n@@ -40,7 +40,7 @@ impl IdleWatcher {\n     pub fn onetime(loop_: &mut Loop, f: proc()) {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n-            assert_eq!(uvll::uv_idle_init(loop_.native_handle(), handle), 0);\n+            assert_eq!(uvll::uv_idle_init(loop_.handle, handle), 0);\n             let data: *c_void = cast::transmute(~f);\n             uvll::set_data_for_uv_handle(handle, data);\n             assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)"}, {"sha": "1afc9b1d0ea6775b9be4fe9fc10746a338919a9b", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -59,14 +59,14 @@ use std::rt::io::IoError;\n \n //#[cfg(test)] use unstable::run_in_bare_thread;\n \n+pub use self::async::AsyncWatcher;\n pub use self::file::{FsRequest, FileWatcher};\n-pub use self::net::{TcpWatcher, TcpListener, TcpAcceptor, UdpWatcher};\n pub use self::idle::IdleWatcher;\n-pub use self::timer::TimerWatcher;\n-pub use self::async::AsyncWatcher;\n-pub use self::process::Process;\n+pub use self::net::{TcpWatcher, TcpListener, TcpAcceptor, UdpWatcher};\n pub use self::pipe::{PipeWatcher, PipeListener, PipeAcceptor};\n+pub use self::process::Process;\n pub use self::signal::SignalWatcher;\n+pub use self::timer::TimerWatcher;\n pub use self::tty::TtyWatcher;\n \n mod macros;\n@@ -89,19 +89,6 @@ pub mod tty;\n pub mod signal;\n pub mod stream;\n \n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    priv handle: *uvll::uv_loop_t\n-}\n-\n-/// A type that wraps a native handle\n-pub trait NativeHandle<T> {\n-    fn from_native_handle(T) -> Self;\n-    fn native_handle(&self) -> T;\n-}\n-\n /// A type that wraps a uv handle\n pub trait UvHandle<T> {\n     fn uv_handle(&self) -> *T;\n@@ -185,28 +172,28 @@ impl Drop for Request {\n     }\n }\n \n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    priv handle: *uvll::uv_loop_t\n+}\n+\n impl Loop {\n     pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         assert!(handle.is_not_null());\n-        NativeHandle::from_native_handle(handle)\n+        Loop::wrap(handle)\n     }\n \n+    pub fn wrap(handle: *uvll::uv_loop_t) -> Loop { Loop { handle: handle } }\n+\n     pub fn run(&mut self) {\n-        unsafe { uvll::uv_run(self.native_handle(), uvll::RUN_DEFAULT) };\n+        unsafe { uvll::uv_run(self.handle, uvll::RUN_DEFAULT) };\n     }\n \n     pub fn close(&mut self) {\n-        unsafe { uvll::uv_loop_delete(self.native_handle()) };\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_loop_t> for Loop {\n-    fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n-        Loop { handle: handle }\n-    }\n-    fn native_handle(&self) -> *uvll::uv_loop_t {\n-        self.handle\n+        unsafe { uvll::uv_loop_delete(self.handle) };\n     }\n }\n "}, {"sha": "01847a19304f649d1f9484d5a7a774e6733b55e9", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -13,57 +13,55 @@ use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n use std::ptr;\n use std::rt::BlockedTask;\n use std::rt::io::IoError;\n-use std::rt::io::net::ip::{Ipv4Addr, Ipv6Addr};\n+use std::rt::io::net::ip::{Ipv4Addr, Ipv6Addr, SocketAddr, IpAddr};\n use std::rt::local::Local;\n-use std::rt::io::net::ip::{SocketAddr, IpAddr};\n use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::str;\n use std::vec;\n \n-use uvll;\n-use uvll::*;\n-use super::{\n-            Loop, Request, UvError, Buf, NativeHandle,\n-            status_to_io_result,\n+use stream::StreamWatcher;\n+use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf};\n use uvio::HomingIO;\n-use stream::StreamWatcher;\n+use uvll;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n pub enum UvSocketAddr {\n-    UvIpv4SocketAddr(*sockaddr_in),\n-    UvIpv6SocketAddr(*sockaddr_in6),\n+    UvIpv4SocketAddr(*uvll::sockaddr_in),\n+    UvIpv6SocketAddr(*uvll::sockaddr_in6),\n }\n \n pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n     unsafe {\n-        assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n-        assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n+        assert!((uvll::is_ip4_addr(addr) || uvll::is_ip6_addr(addr)));\n+        assert!(!(uvll::is_ip4_addr(addr) && uvll::is_ip6_addr(addr)));\n         match addr {\n-            _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n-            _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n+            _ if uvll::is_ip4_addr(addr) =>\n+                UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n+            _ if uvll::is_ip6_addr(addr) =>\n+                UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n             _ => fail!(),\n         }\n     }\n }\n \n fn socket_addr_as_uv_socket_addr<T>(addr: SocketAddr, f: &fn(UvSocketAddr) -> T) -> T {\n     let malloc = match addr.ip {\n-        Ipv4Addr(*) => malloc_ip4_addr,\n-        Ipv6Addr(*) => malloc_ip6_addr,\n+        Ipv4Addr(*) => uvll::malloc_ip4_addr,\n+        Ipv6Addr(*) => uvll::malloc_ip6_addr,\n     };\n     let wrap = match addr.ip {\n         Ipv4Addr(*) => UvIpv4SocketAddr,\n         Ipv6Addr(*) => UvIpv6SocketAddr,\n     };\n     let free = match addr.ip {\n-        Ipv4Addr(*) => free_ip4_addr,\n-        Ipv6Addr(*) => free_ip6_addr,\n+        Ipv4Addr(*) => uvll::free_ip4_addr,\n+        Ipv6Addr(*) => uvll::free_ip6_addr,\n     };\n \n     let addr = unsafe { malloc(addr.ip.to_str(), addr.port as int) };\n@@ -194,7 +192,7 @@ impl TcpWatcher {\n     pub fn new(loop_: &Loop) -> TcpWatcher {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.native_handle(), handle)\n+            uvll::uv_tcp_init(loop_.handle, handle)\n         }, 0);\n         TcpWatcher {\n             home: get_handle_to_current_scheduler!(),\n@@ -223,8 +221,9 @@ impl TcpWatcher {\n             };\n             match result {\n                 0 => {\n-                    req.defuse();\n                     let mut cx = Ctx { status: 0, task: None };\n+                    req.set_data(&cx);\n+                    req.defuse();\n                     let scheduler: ~Scheduler = Local::take();\n                     do scheduler.deschedule_running_task_and_then |_, task| {\n                         cx.task = Some(task);\n@@ -244,11 +243,9 @@ impl TcpWatcher {\n         };\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-            let _req = Request::wrap(req);\n+            let req = Request::wrap(req);\n             if status == uvll::ECANCELED { return }\n-            let cx: &mut Ctx = unsafe {\n-                cast::transmute(uvll::get_data_for_req(req))\n-            };\n+            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n             cx.status = status;\n             let scheduler: ~Scheduler = Local::take();\n             scheduler.resume_blocked_task_immediately(cx.task.take_unwrap());\n@@ -328,7 +325,7 @@ impl TcpListener {\n     {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.native_handle(), handle)\n+            uvll::uv_tcp_init(loop_.handle, handle)\n         }, 0);\n         let l = ~TcpListener {\n             home: get_handle_to_current_scheduler!(),\n@@ -385,7 +382,7 @@ impl rtio::RtioTcpListener for TcpListener {\n extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n     let msg = match status {\n         0 => {\n-            let loop_ = NativeHandle::from_native_handle(unsafe {\n+            let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n             let client = TcpWatcher::new(&loop_);\n@@ -471,7 +468,7 @@ impl UdpWatcher {\n             home: get_handle_to_current_scheduler!(),\n         };\n         assert_eq!(unsafe {\n-            uvll::uv_udp_init(loop_.native_handle(), udp.handle)\n+            uvll::uv_udp_init(loop_.handle, udp.handle)\n         }, 0);\n         let result = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n             match addr {"}, {"sha": "e1cb8464114c26a4a2db4abde8dcb3ff4bc44817", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -19,7 +19,7 @@ use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n \n use stream::StreamWatcher;\n-use super::{Loop, UvError, NativeHandle, uv_error_to_io_error, UvHandle, Request};\n+use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error};\n use uvio::HomingIO;\n use uvll;\n \n@@ -55,7 +55,7 @@ impl PipeWatcher {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n             assert!(!handle.is_null());\n             let ipc = ipc as libc::c_int;\n-            assert_eq!(uvll::uv_pipe_init(loop_.native_handle(), handle, ipc), 0);\n+            assert_eq!(uvll::uv_pipe_init(loop_.handle, handle, ipc), 0);\n             handle\n         }\n     }\n@@ -196,7 +196,7 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n     let msg = match status {\n         0 => {\n-            let loop_ = NativeHandle::from_native_handle(unsafe {\n+            let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n             let client = PipeWatcher::alloc(&loop_, false);"}, {"sha": "20af8e212216a25843388ec0a6eb31932aa51300", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -19,7 +19,7 @@ use std::rt::rtio::RtioProcess;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::vec;\n \n-use super::{Loop, NativeHandle, UvHandle, UvError, uv_error_to_io_error};\n+use super::{Loop, UvHandle, UvError, uv_error_to_io_error};\n use uvio::HomingIO;\n use uvll;\n use pipe::PipeWatcher;\n@@ -77,7 +77,7 @@ impl Process {\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n                 match unsafe {\n-                    uvll::uv_spawn(loop_.native_handle(), handle, options)\n+                    uvll::uv_spawn(loop_.handle, handle, options)\n                 } {\n                     0 => {\n                         let process = ~Process {"}, {"sha": "3c5efe63f96df3bd4e4906cc32b16bae3400748d", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -32,7 +32,8 @@ impl SignalWatcher {\n                channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n         let handle = UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL);\n         assert_eq!(unsafe {\n-            uvll::uv_signal_init(loop_.native_handle(), handle)\n+            uvll::uv_signal_init(loop_.handle, handle)\n+\n         }, 0);\n \n         match unsafe { uvll::uv_signal_start(handle, signal_cb, signum as c_int) } {"}, {"sha": "4958ca4838e7fb5e353864e446e1bef568b9a332", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -201,8 +201,8 @@ extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n     let req = Request::wrap(req);\n     let wcx: &mut WriteContext = unsafe { cast::transmute(req.get_data()) };\n     wcx.result = status;\n+    req.defuse();\n \n     let sched: ~Scheduler = Local::take();\n     sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n-    req.defuse();\n }"}, {"sha": "18b05073e8306e48c023a8769315eb8b763745fb", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -16,7 +16,7 @@ use std::rt::rtio::RtioTimer;\n use std::rt::sched::{Scheduler, SchedHandle};\n \n use uvll;\n-use super::{Loop, NativeHandle, UvHandle};\n+use super::{Loop, UvHandle};\n use uvio::HomingIO;\n \n pub struct TimerWatcher {\n@@ -35,7 +35,7 @@ impl TimerWatcher {\n     pub fn new(loop_: &mut Loop) -> ~TimerWatcher {\n         let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n         assert_eq!(unsafe {\n-            uvll::uv_timer_init(loop_.native_handle(), handle)\n+            uvll::uv_timer_init(loop_.handle, handle)\n         }, 0);\n         let me = ~TimerWatcher {\n             handle: handle,"}, {"sha": "9d84f785f25da8b88bdacfb368ddb68c7f34b821", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -33,7 +33,7 @@ impl TtyWatcher {\n         let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n \n         match unsafe {\n-            uvll::uv_tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n+            uvll::uv_tty_init(loop_.handle, handle, fd as libc::c_int,\n                               readable as libc::c_int)\n         } {\n             0 => {"}, {"sha": "740943c4de5d8c5f66bb48c8bbc8d1476ebbad31", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -12,18 +12,18 @@ use std::c_str::CString;\n use std::cast::transmute;\n use std::cast;\n use std::comm::{SharedChan, GenericChan};\n-use std::libc;\n use std::libc::c_int;\n-use std::str;\n-use std::rt::io;\n+use std::libc;\n+use std::path::Path;\n use std::rt::io::IoError;\n use std::rt::io::net::ip::SocketAddr;\n use std::rt::io::process::ProcessConfig;\n+use std::rt::io;\n use std::rt::local::Local;\n use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::task::Task;\n-use std::path::Path;\n+use std::str;\n use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n                 S_IRUSR, S_IWUSR};\n use std::rt::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n@@ -39,11 +39,8 @@ use ai = std::rt::io::net::addrinfo;\n #[cfg(test)] use std::rt::comm::oneshot;\n \n use super::*;\n-use idle::IdleWatcher;\n use addrinfo::GetAddrInfoRequest;\n \n-// XXX we should not be calling uvll functions in here.\n-\n pub trait HomingIO {\n \n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n@@ -238,7 +235,7 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,\n                       close: CloseBehavior) -> ~RtioFileStream {\n-        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n+        let loop_ = Loop::wrap(self.uv_loop().handle);\n         ~FileWatcher::new(loop_, fd, close) as ~RtioFileStream\n     }\n "}, {"sha": "1c464110ce0519e81abfd40447222ebc562ce0a8", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -107,14 +107,16 @@ pub fn log(_level: u32, args: &fmt::Arguments) {\n         let optional_task: Option<*mut Task> = Local::try_unsafe_borrow();\n         match optional_task {\n             Some(local) => {\n-                // Use the available logger\n-                (*local).logger.log(args);\n-            }\n-            None => {\n-                // There is no logger anywhere, just write to stderr\n-                let mut logger = StdErrLogger::new();\n-                logger.log(args);\n+                match (*local).logger {\n+                    // Use the available logger if we have one\n+                    Some(ref mut logger) => return logger.log(args),\n+                    None => {}\n+                }\n             }\n+            None => {}\n         }\n+        // There is no logger anywhere, just write to stderr\n+        let mut logger = StdErrLogger::new();\n+        logger.log(args);\n     }\n }"}, {"sha": "c37195a7b1553a8002387c5898c6524d17822b0c", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -172,20 +172,18 @@ pub trait Logger {\n /// This logger emits output to the stderr of the process, and contains a lazily\n /// initialized event-loop driven handle to the stream.\n pub struct StdErrLogger {\n-    priv handle: Option<LineBufferedWriter<StdWriter>>,\n+    priv handle: LineBufferedWriter<StdWriter>,\n }\n \n impl StdErrLogger {\n-    pub fn new() -> StdErrLogger { StdErrLogger { handle: None } }\n+    pub fn new() -> StdErrLogger {\n+        StdErrLogger { handle: LineBufferedWriter::new(io::stderr()) }\n+    }\n }\n \n impl Logger for StdErrLogger {\n     fn log(&mut self, args: &fmt::Arguments) {\n-        // First time logging? Get a handle to the stderr of this process.\n-        if self.handle.is_none() {\n-            self.handle = Some(LineBufferedWriter::new(io::stderr()));\n-        }\n-        fmt::writeln(self.handle.get_mut_ref() as &mut io::Writer, args);\n+        fmt::writeln(&mut self.handle as &mut io::Writer, args);\n     }\n }\n "}, {"sha": "2c89bfd8c764f7f16f56105cb9d11a9dc0e83b2a", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -34,15 +34,16 @@ macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n         if ::rt::util::ENFORCE_SANITY {\n             if !$arg {\n-                rtabort!(\"assertion failed: {}\", stringify!($arg));\n+                rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n )\n \n \n macro_rules! rtabort (\n-    ($($msg:tt)*) => ( {\n-        ::rt::util::abort(format!($($msg)*));\n+    ($msg:expr $($arg:tt)*) => ( {\n+        ::rt::util::abort(format!(concat!(file!(), \":\", line!(), \" \", $msg)\n+                                  $($arg)*));\n     } )\n )"}, {"sha": "7e374fc602138c832fe3347216c21fa4f224463d", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa78c3d6f6b25a0e54f815cd8db765000763e48a/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=aa78c3d6f6b25a0e54f815cd8db765000763e48a", "patch": "@@ -50,7 +50,7 @@ pub struct Task {\n     heap: LocalHeap,\n     priv gc: GarbageCollector,\n     storage: LocalStorage,\n-    logger: StdErrLogger,\n+    logger: Option<StdErrLogger>,\n     unwinder: Unwinder,\n     taskgroup: Option<Taskgroup>,\n     death: Death,\n@@ -180,7 +180,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger::new(),\n+            logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             death: Death::new(),\n@@ -215,7 +215,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger::new(),\n+            logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             death: Death::new(),\n@@ -238,7 +238,7 @@ impl Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(None),\n-            logger: StdErrLogger::new(),\n+            logger: None,\n             unwinder: Unwinder { unwinding: false, cause: None },\n             taskgroup: None,\n             // FIXME(#7544) make watching optional\n@@ -320,6 +320,7 @@ impl Task {\n                     }\n                     None => {}\n                 }\n+                self.logger.take();\n             }\n         }\n "}]}