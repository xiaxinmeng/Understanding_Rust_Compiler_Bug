{"sha": "ca79ecd6940e30d4b2466bf378632efcdf5745c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzllY2Q2OTQwZTMwZDRiMjQ2NmJmMzc4NjMyZWZjZGY1NzQ1Yzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T19:51:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-11T19:51:56Z"}, "message": "Auto merge of #55660 - alexcrichton:cleanup-alloc-system, r=dtolnay,SimonSapin\n\nRemove the `alloc_system` crate\n\nIn what's hopefully one of the final nails in the coffin of the \"old allocator story of yore\" this PR deletes the `alloc_system` crate and all traces of it from the compiler. The compiler no longer needs to inject allocator crates anywhere and the `alloc_system` crate has no real reason to exist outside the standard library.\n\nThe unstable `alloc_system` crate is folded directly into the standard library where its stable interface, the `System` type, remains the same. All unstable traces of `alloc_system` are removed, however.", "tree": {"sha": "e8d30ebe5389de5b10097945fb3e5647b205548e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8d30ebe5389de5b10097945fb3e5647b205548e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca79ecd6940e30d4b2466bf378632efcdf5745c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca79ecd6940e30d4b2466bf378632efcdf5745c7", "html_url": "https://github.com/rust-lang/rust/commit/ca79ecd6940e30d4b2466bf378632efcdf5745c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca79ecd6940e30d4b2466bf378632efcdf5745c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "html_url": "https://github.com/rust-lang/rust/commit/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac"}, {"sha": "cc7590341a6ac213909d0ef56a7ebc2834274c8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc7590341a6ac213909d0ef56a7ebc2834274c8b", "html_url": "https://github.com/rust-lang/rust/commit/cc7590341a6ac213909d0ef56a7ebc2834274c8b"}], "stats": {"total": 1146, "additions": 464, "deletions": 682}, "files": [{"sha": "32304c81182f16464301837615f71871247c279b", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,16 +15,6 @@ dependencies = [\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins 0.0.0\",\n- \"core 0.0.0\",\n- \"dlmalloc 0.0.0\",\n- \"libc 0.0.0\",\n-]\n-\n [[package]]\n name = \"ammonia\"\n version = \"1.1.0\"\n@@ -2104,7 +2094,6 @@ name = \"rustc_asan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2276,7 +2265,6 @@ name = \"rustc_lsan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2328,7 +2316,6 @@ name = \"rustc_msan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2440,7 +2427,6 @@ name = \"rustc_tsan\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n@@ -2679,11 +2665,11 @@ name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n+ \"dlmalloc 0.0.0\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\","}, {"sha": "0aab64465fd1c48ce6974392659cd60a1eca286a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -859,7 +859,6 @@ impl Step for Src {\n             \"src/build_helper\",\n             \"src/dlmalloc\",\n             \"src/liballoc\",\n-            \"src/liballoc_system\",\n             \"src/libbacktrace\",\n             \"src/libcompiler_builtins\",\n             \"src/libcore\","}, {"sha": "161f0c0062fa012d2685ef521403c960c50abae4", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\"}, {"sha": "bf256b23f9ac0eb459ad7a29a6be7eb6d239c64f", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc_system::System;\n-use std::alloc::{Global, Alloc, Layout};\n+use std::alloc::{Global, Alloc, Layout, System};\n \n /// https://github.com/rust-lang/rust/issues/45955\n #[test]"}, {"sha": "e514a8a69c020701ea4e42fb31425628901722e8", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![feature(allocator_api)]\n-#![feature(alloc_system)]\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n@@ -20,7 +19,6 @@\n #![feature(unboxed_closures)]\n #![feature(repeat_generic_slice)]\n \n-extern crate alloc_system;\n extern crate core;\n extern crate rand;\n "}, {"sha": "c34e2f203a8371267134c2cc1271fcb15e24f45f", "filename": "src/liballoc_system/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"alloc_system\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }\n-libc = { path = \"../rustc/libc_shim\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n-\n-# See comments in the source for what this dependency is\n-[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n-dlmalloc = { path = \"../rustc/dlmalloc_shim\" }"}, {"sha": "0e6887a508223331201cca2a0363240d99a312dd", "filename": "src/liballoc_system/lib.rs", "status": "removed", "additions": 0, "deletions": 411, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=5a2ca1a6f18aa93d3120761f614ec2d39b4cb1ac", "patch": "@@ -1,411 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n-\n-#![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n-#![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]\n-#![rustc_alloc_kind = \"lib\"]\n-\n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n-const MIN_ALIGN: usize = 16;\n-\n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n-use core::ptr::NonNull;\n-\n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-pub struct System;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl Alloc for System {\n-    #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<u8>,\n-                      layout: Layout,\n-                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n-    }\n-}\n-\n-#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n-mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use core::cmp;\n-    use core::ptr;\n-\n-    impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n-                                              new_size: usize) -> *mut u8 {\n-            // Docs for GlobalAlloc::realloc require this to be valid:\n-            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n-\n-            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n-            if !new_ptr.is_null() {\n-                let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                GlobalAlloc::dealloc(self, ptr, old_layout);\n-            }\n-            new_ptr\n-        }\n-    }\n-}\n-\n-#[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n-mod platform {\n-    extern crate libc;\n-\n-    use core::ptr;\n-\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n-            } else {\n-                #[cfg(target_os = \"macos\")]\n-                {\n-                    if layout.align() > (1 << 31) {\n-                        return ptr::null_mut()\n-                    }\n-                }\n-                aligned_malloc(&layout)\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut u8\n-            } else {\n-                let ptr = self.alloc(layout.clone());\n-                if !ptr.is_null() {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n-                }\n-                ptr\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-            libc::free(ptr as *mut libc::c_void)\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"hermit\",\n-              target_os = \"redox\",\n-              target_os = \"solaris\"))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        // On android we currently target API level 9 which unfortunately\n-        // doesn't have the `posix_memalign` API used below. Instead we use\n-        // `memalign`, but this unfortunately has the property on some systems\n-        // where the memory returned cannot be deallocated by `free`!\n-        //\n-        // Upon closer inspection, however, this appears to work just fine with\n-        // Android, so for this platform we should be fine to call `memalign`\n-        // (which is present in API level 9). Some helpful references could\n-        // possibly be chromium using memalign [1], attempts at documenting that\n-        // memalign + free is ok [2] [3], or the current source of chromium\n-        // which still uses memalign on android [4].\n-        //\n-        // [1]: https://codereview.chromium.org/10796020/\n-        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-        //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n-    }\n-\n-    #[cfg(not(any(target_os = \"android\",\n-                  target_os = \"hermit\",\n-                  target_os = \"redox\",\n-                  target_os = \"solaris\")))]\n-    #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-        let mut out = ptr::null_mut();\n-        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-        if ret != 0 {\n-            ptr::null_mut()\n-        } else {\n-            out as *mut u8\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[allow(nonstandard_style)]\n-mod platform {\n-    use MIN_ALIGN;\n-    use System;\n-    use core::alloc::{GlobalAlloc, Layout};\n-\n-    type LPVOID = *mut u8;\n-    type HANDLE = LPVOID;\n-    type SIZE_T = usize;\n-    type DWORD = u32;\n-    type BOOL = i32;\n-\n-    extern \"system\" {\n-        fn GetProcessHeap() -> HANDLE;\n-        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    #[repr(C)]\n-    struct Header(*mut u8);\n-\n-    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-\n-    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n-    }\n-\n-    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n-        *get_header(aligned) = Header(ptr);\n-        aligned\n-    }\n-\n-    #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n-        let ptr = if layout.align() <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), flags, layout.size())\n-        } else {\n-            let size = layout.size() + layout.align();\n-            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n-            if ptr.is_null() {\n-                ptr\n-            } else {\n-                align_ptr(ptr, layout.align())\n-            }\n-        };\n-        ptr as *mut u8\n-    }\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, 0)\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            if layout.align() <= MIN_ALIGN {\n-                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            } else {\n-                let header = get_header(ptr);\n-                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n-                              GetLastError());\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n-            } else {\n-                self.realloc_fallback(ptr, layout, new_size)\n-            }\n-        }\n-    }\n-}\n-\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-\n-        pub struct DropLock;\n-\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}"}, {"sha": "671f513d5b9331850caeb02550f4e08d06080785", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -63,7 +63,6 @@\n \n use hir::def_id::CrateNum;\n \n-use session;\n use session::config;\n use ty::TyCtxt;\n use middle::cstore::{self, DepKind};\n@@ -224,7 +223,6 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // quite yet, so do so here.\n     activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n-    activate_injected_allocator(sess, &mut ret);\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n@@ -303,7 +301,6 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // that here and activate them.\n     activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n                           &|cnum| tcx.is_panic_runtime(cnum));\n-    activate_injected_allocator(sess, &mut ret);\n \n     Some(ret)\n }\n@@ -336,18 +333,6 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n     }\n }\n \n-fn activate_injected_allocator(sess: &session::Session,\n-                               list: &mut DependencyList) {\n-    let cnum = match sess.injected_allocator.get() {\n-        Some(cnum) => cnum,\n-        None => return,\n-    };\n-    let idx = cnum.as_usize() - 1;\n-    if list[idx] == Linkage::NotLinked {\n-        list[idx] = Linkage::Static;\n-    }\n-}\n-\n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {"}, {"sha": "8cfbd27fc61631f4096e6ed0ddd59322344223e6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -112,7 +112,6 @@ pub struct Session {\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n-    pub injected_allocator: Once<Option<CrateNum>>,\n     pub allocator_kind: Once<Option<AllocatorKind>>,\n     pub injected_panic_runtime: Once<Option<CrateNum>>,\n \n@@ -1162,7 +1161,6 @@ pub fn build_session_(\n         type_length_limit: Once::new(),\n         const_eval_stack_frame_limit: 100,\n         next_node_id: OneThread::new(Cell::new(NodeId::new(1))),\n-        injected_allocator: Once::new(),\n         allocator_kind: Once::new(),\n         injected_panic_runtime: Once::new(),\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),"}, {"sha": "734564c2d856777ab450b935e26c2537199259fa", "filename": "src/librustc_asan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_asan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_asan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2FCargo.toml?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "2573825a5ff45775601bfa7f14a25265d3998eaf", "filename": "src/librustc_lsan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_lsan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_lsan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2FCargo.toml?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_lsan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_lsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_lsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "a14dd99eeb3b381653048d6e6dc871712397b625", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 23, "deletions": 107, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -16,7 +16,7 @@ use decoder::proc_macro_def_path_table;\n use schema::CrateRoot;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n@@ -864,28 +864,22 @@ impl<'a> CrateLoader<'a> {\n             needs_allocator = needs_allocator || data.root.needs_allocator;\n         });\n         if !needs_allocator {\n-            self.sess.injected_allocator.set(None);\n             self.sess.allocator_kind.set(None);\n             return\n         }\n \n         // At this point we've determined that we need an allocator. Let's see\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n-        let mut need_lib_alloc = false;\n-        let mut need_exe_alloc = false;\n-        for ct in self.sess.crate_types.borrow().iter() {\n-            match *ct {\n-                config::CrateType::Executable => need_exe_alloc = true,\n-                config::CrateType::Dylib |\n-                config::CrateType::ProcMacro |\n-                config::CrateType::Cdylib |\n-                config::CrateType::Staticlib => need_lib_alloc = true,\n-                config::CrateType::Rlib => {}\n-            }\n-        }\n-        if !need_lib_alloc && !need_exe_alloc {\n-            self.sess.injected_allocator.set(None);\n+        let all_rlib = self.sess.crate_types.borrow()\n+            .iter()\n+            .all(|ct| {\n+                match *ct {\n+                    config::CrateType::Rlib => true,\n+                    _ => false,\n+                }\n+            });\n+        if all_rlib {\n             self.sess.allocator_kind.set(None);\n             return\n         }\n@@ -924,103 +918,27 @@ impl<'a> CrateLoader<'a> {\n         });\n         if global_allocator.is_some() {\n             self.sess.allocator_kind.set(Some(AllocatorKind::Global));\n-            self.sess.injected_allocator.set(None);\n             return\n         }\n \n         // Ok we haven't found a global allocator but we still need an\n-        // allocator. At this point we'll either fall back to the \"library\n-        // allocator\" or the \"exe allocator\" depending on a few variables. Let's\n-        // figure out which one.\n-        //\n-        // Note that here we favor linking to the \"library allocator\" as much as\n-        // possible. If we're not creating rustc's version of libstd\n-        // (need_lib_alloc and prefer_dynamic) then we select `None`, and if the\n-        // exe allocation crate doesn't exist for this target then we also\n-        // select `None`.\n-        let exe_allocation_crate_data =\n-            if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n-                None\n-            } else {\n-                self.sess\n-                    .target\n-                    .target\n-                    .options\n-                    .exe_allocation_crate\n-                    .as_ref()\n-                    .map(|name| {\n-                        // We've determined that we're injecting an \"exe allocator\" which means\n-                        // that we're going to load up a whole new crate. An example of this is\n-                        // that we're producing a normal binary on Linux which means we need to\n-                        // load the `alloc_jemalloc` crate to link as an allocator.\n-                        let name = Symbol::intern(name);\n-                        let (cnum, data) = self.resolve_crate(&None,\n-                                                              name,\n-                                                              name,\n-                                                              None,\n-                                                              None,\n-                                                              DUMMY_SP,\n-                                                              PathKind::Crate,\n-                                                              DepKind::Implicit)\n-                            .unwrap_or_else(|err| err.report());\n-                        self.sess.injected_allocator.set(Some(cnum));\n-                        data\n-                    })\n-            };\n-\n-        let allocation_crate_data = exe_allocation_crate_data.or_else(|| {\n-            // No allocator was injected\n-            self.sess.injected_allocator.set(None);\n-\n-            if attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n-                // Prefer self as the allocator if there's a collision\n-                return None;\n+        // allocator. At this point our allocator request is typically fulfilled\n+        // by the standard library, denoted by the `#![default_lib_allocator]`\n+        // attribute.\n+        let mut has_default = attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n+        self.cstore.iter_crate_data(|_, data| {\n+            if data.root.has_default_lib_allocator {\n+                has_default = true;\n             }\n-            // We're not actually going to inject an allocator, we're going to\n-            // require that something in our crate graph is the default lib\n-            // allocator. This is typically libstd, so this'll rarely be an\n-            // error.\n-            let mut allocator = None;\n-            self.cstore.iter_crate_data(|_, data| {\n-                if allocator.is_none() && data.root.has_default_lib_allocator {\n-                    allocator = Some(data.clone());\n-                }\n-            });\n-            allocator\n         });\n \n-        match allocation_crate_data {\n-            Some(data) => {\n-                // We have an allocator. We detect separately what kind it is, to allow for some\n-                // flexibility in misconfiguration.\n-                let attrs = data.get_item_attrs(CRATE_DEF_INDEX, self.sess);\n-                let kind_interned = attr::first_attr_value_str_by_name(&attrs, \"rustc_alloc_kind\")\n-                    .map(Symbol::as_str);\n-                let kind_str = kind_interned\n-                    .as_ref()\n-                    .map(|s| s as &str);\n-                let alloc_kind = match kind_str {\n-                    None |\n-                    Some(\"lib\") => AllocatorKind::DefaultLib,\n-                    Some(\"exe\") => AllocatorKind::DefaultExe,\n-                    Some(other) => {\n-                        self.sess.err(&format!(\"Allocator kind {} not known\", other));\n-                        return;\n-                    }\n-                };\n-                self.sess.allocator_kind.set(Some(alloc_kind));\n-            },\n-            None => {\n-                if !attr::contains_name(&krate.attrs, \"default_lib_allocator\") {\n-                    self.sess.err(\"no global memory allocator found but one is \\\n-                                   required; link to std or \\\n-                                   add #[global_allocator] to a static item \\\n-                                   that implements the GlobalAlloc trait.\");\n-                    return;\n-                }\n-                self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-            }\n+        if !has_default {\n+            self.sess.err(\"no global memory allocator found but one is \\\n+                           required; link to std or \\\n+                           add #[global_allocator] to a static item \\\n+                           that implements the GlobalAlloc trait.\");\n         }\n+        self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n \n         fn has_global_allocator(krate: &ast::Crate) -> bool {\n             struct Finder(bool);\n@@ -1083,8 +1001,6 @@ impl<'a> CrateLoader<'a> {\n \n impl<'a> CrateLoader<'a> {\n     pub fn postprocess(&mut self, krate: &ast::Crate) {\n-        // inject the sanitizer runtime before the allocator runtime because all\n-        // sanitizers force the use of the `alloc_system` allocator\n         self.inject_sanitizer_runtime();\n         self.inject_profiler_runtime();\n         self.inject_allocator_crate(krate);"}, {"sha": "29165675a2ad7e346052ccad9cdab39cf7d406b4", "filename": "src/librustc_msan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_msan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_msan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2FCargo.toml?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_msan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_msan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_msan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "b120f57192bfb7b0bb0d3b68a2198cc70f64082a", "filename": "src/librustc_target/spec/aarch64_unknown_freebsd.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_freebsd.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -14,9 +14,6 @@ pub fn target() -> TargetResult {\n     let mut base = super::freebsd_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"aarch64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "af7ec6a1787f0853ae77fe5bb51b77c4656099b5", "filename": "src/librustc_target/spec/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -14,9 +14,6 @@ pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "e5ca91aabe56a46118933651d2b95403d03ce53d", "filename": "src/librustc_target/spec/aarch64_unknown_linux_musl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_linux_musl.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -14,9 +14,6 @@ pub fn target() -> TargetResult {\n     let mut base = super::linux_musl_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"aarch64-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "168eac685e4f3a4da8ce6eabf072fbe23d050494", "filename": "src/librustc_target/spec/hermit_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -21,7 +21,6 @@ pub fn opts() -> TargetOptions {\n     ]);\n \n     TargetOptions {\n-        exe_allocation_crate: None,\n         executables: true,\n         has_elf_tls: true,\n         linker_is_gnu: true,"}, {"sha": "7932adf3b1054077714b92de197ef4da3563180c", "filename": "src/librustc_target/spec/l4re_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fl4re_base.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -30,7 +30,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         executables: true,\n         has_elf_tls: false,\n-        exe_allocation_crate: None,\n         panic_strategy: PanicStrategy::Abort,\n         linker: Some(\"ld\".to_string()),\n         pre_link_args: args,"}, {"sha": "b80b6b561cd42554172e95cc4d21ae429e533510", "filename": "src/librustc_target/spec/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -28,9 +28,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips64r2\".to_string(),\n             max_atomic_width: Some(64),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "1c835af6e412b1e9ea6db09aa9638b242a28cc38", "filename": "src/librustc_target/spec/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -28,9 +28,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips64r2\".to_string(),\n             max_atomic_width: Some(64),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "6331031c9a2847176752ff2b7c8b12b02852afc5", "filename": "src/librustc_target/spec/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -27,9 +27,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips32r2,+fpxx,+nooddspreg\".to_string(),\n             max_atomic_width: Some(32),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "0b20765172a0250911ee289344bb425c329fd5a9", "filename": "src/librustc_target/spec/mips_unknown_linux_musl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_musl.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,8 +15,6 @@ pub fn target() -> TargetResult {\n     base.cpu = \"mips32r2\".to_string();\n     base.features = \"+mips32r2,+soft-float\".to_string();\n     base.max_atomic_width = Some(32);\n-    // see #36994\n-    base.exe_allocation_crate = None;\n     base.crt_static_default = false;\n     Ok(Target {\n         llvm_target: \"mips-unknown-linux-musl\".to_string(),"}, {"sha": "d3f614c982ae4903eae0f7c0dc22b5ed7a14e67e", "filename": "src/librustc_target/spec/mips_unknown_linux_uclibc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmips_unknown_linux_uclibc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -27,9 +27,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips32r2,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "79ebefa79a320065ff012d4590ef9547fb83a54e", "filename": "src/librustc_target/spec/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -28,9 +28,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips32r2,+fpxx,+nooddspreg\".to_string(),\n             max_atomic_width: Some(32),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "042e2b71c32565f98dedcf716bef3257686e6340", "filename": "src/librustc_target/spec/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_musl.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,8 +15,6 @@ pub fn target() -> TargetResult {\n     base.cpu = \"mips32r2\".to_string();\n     base.features = \"+mips32r2,+soft-float\".to_string();\n     base.max_atomic_width = Some(32);\n-    // see #36994\n-    base.exe_allocation_crate = None;\n     base.crt_static_default = false;\n     Ok(Target {\n         llvm_target: \"mipsel-unknown-linux-musl\".to_string(),"}, {"sha": "8cb5cd3f03a677f024841f1572563d916c361526", "filename": "src/librustc_target/spec/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_unknown_linux_uclibc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -28,9 +28,6 @@ pub fn target() -> TargetResult {\n             features: \"+mips32r2,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n \n-            // see #36994\n-            exe_allocation_crate: None,\n-\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "16dc2a91030f1723c0f937feb6788b9a1c3fb30f", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -596,9 +596,6 @@ pub struct TargetOptions {\n     /// `eh_unwind_resume` lang item.\n     pub custom_unwind_resume: bool,\n \n-    /// If necessary, a different crate to link exe allocators by default\n-    pub exe_allocation_crate: Option<String>,\n-\n     /// Flag indicating whether ELF TLS (e.g. #[thread_local]) is available for\n     /// this target.\n     pub has_elf_tls: bool,\n@@ -740,7 +737,6 @@ impl Default for TargetOptions {\n             link_env: Vec::new(),\n             archive_format: \"gnu\".to_string(),\n             custom_unwind_resume: false,\n-            exe_allocation_crate: None,\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n@@ -1025,7 +1021,6 @@ impl Target {\n         key!(archive_format);\n         key!(allow_asm, bool);\n         key!(custom_unwind_resume, bool);\n-        key!(exe_allocation_crate, optional);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n         key!(no_integrated_as, bool);\n@@ -1235,7 +1230,6 @@ impl ToJson for Target {\n         target_option_val!(archive_format);\n         target_option_val!(allow_asm);\n         target_option_val!(custom_unwind_resume);\n-        target_option_val!(exe_allocation_crate);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n         target_option_val!(no_integrated_as);"}, {"sha": "1d0afcd5e0c608b4721024d301fe2b5187ed25b9", "filename": "src/librustc_target/spec/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -20,9 +20,6 @@ pub fn target() -> TargetResult {\n     // for now. https://github.com/rust-lang/rust/pull/43170#issuecomment-315411474\n     base.relro_level = RelroLevel::Partial;\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "01811c5a0c32227e2fcc72e20379cd2ae20dbb9c", "filename": "src/librustc_target/spec/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -16,9 +16,6 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "590c5ba8d54b49fcba547674347ccbe4debe6d51", "filename": "src/librustc_target/spec/powerpc64le_unknown_linux_musl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64le_unknown_linux_musl.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -16,9 +16,6 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc64le-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "99d8d99fbb2b620c59a8c08b2b854fa9054ffd1b", "filename": "src/librustc_target/spec/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,9 +15,6 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.max_atomic_width = Some(32);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "9b15b0a5dc4b7b3c80c81b411535733b3423a6fd", "filename": "src/librustc_target/spec/powerpc_unknown_linux_gnuspe.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_gnuspe.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,9 +15,6 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n     base.max_atomic_width = Some(32);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc-unknown-linux-gnuspe\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "98625a63f52980adefeac771fe27a349f44af36b", "filename": "src/librustc_target/spec/powerpc_unknown_netbsd.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_netbsd.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,9 +15,6 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.max_atomic_width = Some(32);\n \n-    // see #36994\n-    base.exe_allocation_crate = None;\n-\n     Ok(Target {\n         llvm_target: \"powerpc-unknown-netbsd\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "bd8b7e435d340e1a0cc676b65d1d391423ff4524", "filename": "src/librustc_target/spec/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fs390x_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -19,8 +19,6 @@ pub fn target() -> TargetResult {\n     // Pass the -vector feature string to LLVM to respect this assumption.\n     base.features = \"-vector\".to_string();\n     base.max_atomic_width = Some(64);\n-    // see #36994\n-    base.exe_allocation_crate = None;\n     base.min_global_align = Some(16);\n \n     Ok(Target {"}, {"sha": "f2b99aa46d2d0cfc7f7fc72b39cce4a1856a3b37", "filename": "src/librustc_target/spec/sparc64_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fsparc64_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -14,7 +14,6 @@ pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);\n-    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"sparc64-unknown-linux-gnu\".to_string(),"}, {"sha": "81db39cd23f87d288915989613f2e5192391af51", "filename": "src/librustc_target/spec/sparc_unknown_linux_gnu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fsparc_unknown_linux_gnu.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,7 +15,6 @@ pub fn target() -> TargetResult {\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mv8plus\".to_string());\n-    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"sparc-unknown-linux-gnu\".to_string(),"}, {"sha": "5029e857eb5431378e8a83fb4cf8e55f0bac56f6", "filename": "src/librustc_target/spec/sparcv9_sun_solaris.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparcv9_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fsparcv9_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fsparcv9_sun_solaris.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -16,7 +16,6 @@ pub fn target() -> TargetResult {\n     // llvm calls this \"v9\"\n     base.cpu = \"v9\".to_string();\n     base.max_atomic_width = Some(64);\n-    base.exe_allocation_crate = None;\n \n     Ok(Target {\n         llvm_target: \"sparcv9-sun-solaris\".to_string(),"}, {"sha": "e7570cd2da6ec84fd4cfa9b19fbe0849e2ef7ab1", "filename": "src/librustc_target/spec/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -21,7 +21,6 @@ pub fn target() -> TargetResult {\n     base.has_rpath = false;\n     base.position_independent_executables = false;\n     base.disable_redzone = true;\n-    base.exe_allocation_crate = None;\n     base.stack_probes = true;\n \n     Ok(Target {"}, {"sha": "baadb64511ae1887aa50eff616ed18772919a77a", "filename": "src/librustc_tsan/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_tsan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_tsan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2FCargo.toml?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,6 +15,5 @@ cmake = \"0.1.18\"\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "47f917e40c1ff53a5b81e490e026a3bdaa54fc61", "filename": "src/librustc_tsan/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_tsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibrustc_tsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -9,18 +9,10 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(alloc_system)]\n #![feature(nll)]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\",\n             reason = \"internal implementation detail of sanitizers\",\n             issue = \"0\")]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static ALLOC: System = System;"}, {"sha": "2b1d515c83b75a4d0090bc519a4d5104f09a82fc", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -14,7 +14,6 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n-alloc_system = { path = \"../liballoc_system\" }\n panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }\n@@ -36,6 +35,9 @@ rustc_lsan = { path = \"../librustc_lsan\" }\n rustc_msan = { path = \"../librustc_msan\" }\n rustc_tsan = { path = \"../librustc_tsan\" }\n \n+[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+dlmalloc = { path = '../rustc/dlmalloc_shim' }\n+\n [build-dependencies]\n cc = \"1.0\"\n build_helper = { path = \"../build_helper\" }"}, {"sha": "485b2ffe1975ed5c5973066ceb1df9d6b9d8efac", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -73,15 +73,100 @@\n \n use core::sync::atomic::{AtomicPtr, Ordering};\n use core::{mem, ptr};\n+use core::ptr::NonNull;\n use sys_common::util::dumb_print;\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n pub use alloc_crate::alloc::*;\n \n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type implements the `GlobalAlloc` trait and Rust programs by deafult\n+/// work as if they had this definition:\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// You can also define your own wrapper around `System` if you'd like, such as\n+/// keeping track of the number of all bytes allocated:\n+///\n+/// ```rust\n+/// use std::alloc::{System, GlobalAlloc, Layout};\n+/// use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering::SeqCst};\n+///\n+/// struct Counter;\n+///\n+/// static ALLOCATED: AtomicUsize = ATOMIC_USIZE_INIT;\n+///\n+/// unsafe impl GlobalAlloc for Counter {\n+///     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+///         let ret = System.alloc(layout);\n+///         if !ret.is_null() {\n+///             ALLOCATED.fetch_add(layout.size(), SeqCst);\n+///         }\n+///         return ret\n+///     }\n+///\n+///     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+///         System.dealloc(ptr, layout);\n+///         ALLOCATED.fetch_sub(layout.size(), SeqCst);\n+///     }\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: Counter = Counter;\n+///\n+/// fn main() {\n+///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(SeqCst));\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory independently of whatever\n+/// global allocator has been selected for a Rust program. For example if a Rust\n+/// program opts in to using jemalloc as the global allocator, `System` will\n+/// still allocate memory using `malloc` and `HeapAlloc`.\n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-#[doc(inline)]\n-pub use alloc_system::System;\n+#[derive(Debug, Copy, Clone)]\n+pub struct System;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+unsafe impl Alloc for System {\n+    #[inline]\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&mut self,\n+                      ptr: NonNull<u8>,\n+                      layout: Layout,\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    }\n+}\n \n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n "}, {"sha": "f460d109c894a50b4f12ff30c27982c90a80891d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -235,7 +235,6 @@\n #![cfg_attr(test, feature(test, update_panic_count))]\n #![feature(alloc)]\n #![feature(alloc_error_handler)]\n-#![feature(alloc_system)]\n #![feature(allocator_api)]\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n@@ -316,7 +315,7 @@\n \n #[cfg(stage0)]\n #[global_allocator]\n-static ALLOC: alloc_system::System = alloc_system::System;\n+static ALLOC: alloc::System = alloc::System;\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n // to import the prelude implicitly when building crates that depend on std.\n@@ -337,7 +336,6 @@ pub use core::{unreachable, unimplemented, write, writeln, try};\n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]\n extern crate alloc as alloc_crate;\n-extern crate alloc_system;\n #[doc(masked)]\n extern crate libc;\n "}, {"sha": "dfb56472c6c83a90d1223339fd82a86443577c8a", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -12,6 +12,8 @@ use io;\n use libc;\n use mem;\n \n+#[path = \"../unix/alloc.rs\"]\n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "edb407ecd23ce6af9ce6497eb790e34c674659fc", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -15,6 +15,8 @@ use io::{self, ErrorKind};\n pub use libc::strlen;\n pub use self::rand::hashmap_random_keys;\n \n+#[path = \"../unix/alloc.rs\"]\n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "2a7f1934518e133bb0b1eb9ef80296ddc54904d1", "filename": "src/libstd/sys/unix/alloc.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ptr;\n+use libc;\n+use sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::malloc(layout.size()) as *mut u8\n+        } else {\n+            #[cfg(target_os = \"macos\")]\n+            {\n+                if layout.align() > (1 << 31) {\n+                    return ptr::null_mut()\n+                }\n+            }\n+            aligned_malloc(&layout)\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::calloc(layout.size(), 1) as *mut u8\n+        } else {\n+            let ptr = self.alloc(layout.clone());\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, layout.size());\n+            }\n+            ptr\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+        } else {\n+            realloc_fallback(self, ptr, layout, new_size)\n+        }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\",\n+          target_os = \"hermit\",\n+          target_os = \"redox\",\n+          target_os = \"solaris\"))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    // On android we currently target API level 9 which unfortunately\n+    // doesn't have the `posix_memalign` API used below. Instead we use\n+    // `memalign`, but this unfortunately has the property on some systems\n+    // where the memory returned cannot be deallocated by `free`!\n+    //\n+    // Upon closer inspection, however, this appears to work just fine with\n+    // Android, so for this platform we should be fine to call `memalign`\n+    // (which is present in API level 9). Some helpful references could\n+    // possibly be chromium using memalign [1], attempts at documenting that\n+    // memalign + free is ok [2] [3], or the current source of chromium\n+    // which still uses memalign on android [4].\n+    //\n+    // [1]: https://codereview.chromium.org/10796020/\n+    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+    //                                       /memory/aligned_memory.cc\n+    libc::memalign(layout.align(), layout.size()) as *mut u8\n+}\n+\n+#[cfg(not(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\")))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    let mut out = ptr::null_mut();\n+    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+    if ret != 0 {\n+        ptr::null_mut()\n+    } else {\n+        out as *mut u8\n+    }\n+}"}, {"sha": "e8101bd0bc96452a9efe395097509a24fb989f92", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -36,6 +36,7 @@ pub use libc::strlen;\n #[macro_use]\n pub mod weak;\n \n+pub mod alloc;\n pub mod args;\n pub mod android;\n #[cfg(feature = \"backtrace\")]"}, {"sha": "0faa3c9a740f191fe843aba5394bffdf887dab0d", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an implementation of a global allocator on the wasm32 platform when\n+//! emscripten is not in use. In that situation there's no actual runtime for us\n+//! to lean on for allocation, so instead we provide our own!\n+//!\n+//! The wasm32 instruction set has two instructions for getting the current\n+//! amount of memory and growing the amount of memory. These instructions are the\n+//! foundation on which we're able to build an allocator, so we do so! Note that\n+//! the instructions are also pretty \"global\" and this is the \"global\" allocator\n+//! after all!\n+//!\n+//! The current allocator here is the `dlmalloc` crate which we've got included\n+//! in the rust-lang/rust repository as a submodule. The crate is a port of\n+//! dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+//! for now which is currently technically required (can't link with C yet).\n+//!\n+//! The crate itself provides a global allocator which on wasm has no\n+//! synchronization as there are no threads!\n+\n+extern crate dlmalloc;\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.malloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.calloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        let _lock = lock::lock();\n+        DLMALLOC.free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        let _lock = lock::lock();\n+        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}\n+\n+#[cfg(target_feature = \"atomics\")]\n+mod lock {\n+    use arch::wasm32;\n+    use sync::atomic::{AtomicI32, Ordering::SeqCst};\n+\n+    static LOCKED: AtomicI32 = AtomicI32::new(0);\n+\n+    pub struct DropLock;\n+\n+    pub fn lock() -> DropLock {\n+        loop {\n+            if LOCKED.swap(1, SeqCst) == 0 {\n+                return DropLock\n+            }\n+            unsafe {\n+                let r = wasm32::atomic::wait_i32(\n+                    &LOCKED as *const AtomicI32 as *mut i32,\n+                    1,  // expected value\n+                    -1, // timeout\n+                );\n+                debug_assert!(r == 0 || r == 1);\n+            }\n+        }\n+    }\n+\n+    impl Drop for DropLock {\n+        fn drop(&mut self) {\n+            let r = LOCKED.swap(0, SeqCst);\n+            debug_assert_eq!(r, 1);\n+            unsafe {\n+                wasm32::atomic::wake(\n+                    &LOCKED as *const AtomicI32 as *mut i32,\n+                    1, // only one thread\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_feature = \"atomics\"))]\n+mod lock {\n+    #[inline]\n+    pub fn lock() {} // no atomics, no threads, that's easy!\n+}"}, {"sha": "e8f7e32ac9177253c30c0b4d2e47c07317fe1663", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -32,6 +32,7 @@ use sys_common::{AsInner, FromInner};\n use ffi::{OsString, OsStr};\n use time::Duration;\n \n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "e5de3e016c99b6d76535f0d4487915f971b5c1d8", "filename": "src/libstd/sys/windows/alloc.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Falloc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+use sys::c;\n+use sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+\n+#[repr(C)]\n+struct Header(*mut u8);\n+\n+unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+    &mut *(ptr as *mut Header).offset(-1)\n+}\n+\n+unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+    let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+    *get_header(aligned) = Header(ptr);\n+    aligned\n+}\n+\n+#[inline]\n+unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n+    if layout.align() <= MIN_ALIGN {\n+        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8\n+    }\n+\n+    let size = layout.size() + layout.align();\n+    let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n+    if ptr.is_null() {\n+        ptr as *mut u8\n+    } else {\n+        align_ptr(ptr as *mut u8, layout.align())\n+    }\n+}\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        allocate_with_flags(layout, 0)\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        allocate_with_flags(layout, c::HEAP_ZERO_MEMORY)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        if layout.align() <= MIN_ALIGN {\n+            let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                          c::GetLastError());\n+        } else {\n+            let header = get_header(ptr);\n+            let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                          c::GetLastError());\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN {\n+            c::HeapReAlloc(c::GetProcessHeap(), 0, ptr as c::LPVOID, new_size) as *mut u8\n+        } else {\n+            realloc_fallback(self, ptr, layout, new_size)\n+        }\n+    }\n+}"}, {"sha": "c84874a3e880f56dfcaa688903e9f1d75b6df379", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -309,6 +309,8 @@ pub const FD_SETSIZE: usize = 64;\n \n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n+pub const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -1277,6 +1279,11 @@ extern \"system\" {\n \n     #[link_name = \"SystemFunction036\"]\n     pub fn RtlGenRandom(RandomBuffer: *mut u8, RandomBufferLength: ULONG) -> BOOLEAN;\n+\n+    pub fn GetProcessHeap() -> HANDLE;\n+    pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+    pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+    pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n }\n \n // Functions that aren't available on every version of Windows that we support,"}, {"sha": "f880bc8c050be28a5aa8f4f8fd4b5b28e54c5ec4", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -22,6 +22,7 @@ pub use self::rand::hashmap_random_keys;\n \n #[macro_use] pub mod compat;\n \n+pub mod alloc;\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "439a9dfb3fdb58f73ebba28e3cd157597e324c9f", "filename": "src/libstd/sys_common/alloc.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys_common%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys_common%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Falloc.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+use cmp;\n+use ptr;\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\",\n+              target_arch = \"asmjs\",\n+              target_arch = \"wasm32\")))]\n+pub const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+pub const MIN_ALIGN: usize = 16;\n+\n+pub unsafe fn realloc_fallback(\n+    alloc: &System,\n+    ptr: *mut u8,\n+    old_layout: Layout,\n+    new_size: usize,\n+) -> *mut u8 {\n+    // Docs for GlobalAlloc::realloc require this to be valid:\n+    let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+\n+    let new_ptr = GlobalAlloc::alloc(alloc, new_layout);\n+    if !new_ptr.is_null() {\n+        let size = cmp::min(old_layout.size(), new_size);\n+        ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+        GlobalAlloc::dealloc(alloc, ptr, old_layout);\n+    }\n+    new_ptr\n+}"}, {"sha": "4b8cde3d1f486792fa0d788ab99db674c784949a", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -38,6 +38,7 @@ macro_rules! rtassert {\n     })\n }\n \n+pub mod alloc;\n pub mod at_exit_imp;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "12e9a54da52819939fcaccecb2fd1e549796ac7a", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca79ecd6940e30d4b2466bf378632efcdf5745c7/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=ca79ecd6940e30d4b2466bf378632efcdf5745c7", "patch": "@@ -27,7 +27,6 @@\n //!\n //! - core may not have platform-specific code\n //! - libcompiler_builtins may have platform-specific code\n-//! - liballoc_system may have platform-specific code\n //! - libpanic_abort may have platform-specific code\n //! - libpanic_unwind may have platform-specific code\n //! - libunwind may have platform-specific code\n@@ -51,7 +50,6 @@ use std::iter::Iterator;\n // Paths that may contain platform-specific code\n const EXCEPTION_PATHS: &[&str] = &[\n     // std crates\n-    \"src/liballoc_system\",\n     \"src/libcompiler_builtins\",\n     \"src/liblibc\",\n     \"src/libpanic_abort\","}]}