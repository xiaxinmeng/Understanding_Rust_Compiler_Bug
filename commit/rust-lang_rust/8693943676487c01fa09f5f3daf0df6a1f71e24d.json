{"sha": "8693943676487c01fa09f5f3daf0df6a1f71e24d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OTM5NDM2NzY0ODdjMDFmYTA5ZjVmM2RhZjBkZjZhMWY3MWUyNGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-08T18:38:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:47:57Z"}, "message": "librustc: Ensure that type parameters are in the right positions in paths.\n\nThis removes the stacking of type parameters that occurs when invoking\ntrait methods, and fixes all places in the standard library that were\nrelying on it. It is somewhat awkward in places; I think we'll probably\nwant something like the `Foo::<for T>::new()` syntax.", "tree": {"sha": "5aa978e4144d51f320d069d88fe0fad4ed40705e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aa978e4144d51f320d069d88fe0fad4ed40705e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8693943676487c01fa09f5f3daf0df6a1f71e24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8693943676487c01fa09f5f3daf0df6a1f71e24d", "html_url": "https://github.com/rust-lang/rust/commit/8693943676487c01fa09f5f3daf0df6a1f71e24d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8693943676487c01fa09f5f3daf0df6a1f71e24d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "html_url": "https://github.com/rust-lang/rust/commit/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062"}], "stats": {"total": 1654, "additions": 1128, "deletions": 526}, "files": [{"sha": "8e641073637853e103c1c08e29f0fa465a21cf04", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -661,7 +661,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = DList::new::<~int>();\n+        let mut m: DList<~int> = DList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -768,7 +768,7 @@ mod tests {\n \n     #[test]\n     fn test_rotate() {\n-        let mut n = DList::new::<int>();\n+        let mut n: DList<int> = DList::new();\n         n.rotate_backward(); check_links(&n);\n         assert_eq!(n.len(), 0);\n         n.rotate_forward(); check_links(&n);\n@@ -1033,7 +1033,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn fuzz_test(sz: int) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         let mut v = ~[];\n         for i in range(0, sz) {\n             check_links(&m);\n@@ -1078,23 +1078,23 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_front(0);\n         }\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_back(0);\n         }\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_back(0);\n             m.pop_back();\n@@ -1103,7 +1103,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         do b.iter {\n             m.push_front(0);\n             m.pop_front();\n@@ -1112,7 +1112,7 @@ mod tests {\n \n     #[bench]\n     fn bench_rotate_forward(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n         do b.iter {\n@@ -1122,7 +1122,7 @@ mod tests {\n \n     #[bench]\n     fn bench_rotate_backward(b: &mut test::BenchHarness) {\n-        let mut m = DList::new::<int>();\n+        let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n         do b.iter {"}, {"sha": "ed35f2b61794ef89a855428e0e26b2a90e808861", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -359,7 +359,7 @@ impl Integer for BigUint {\n \n         fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n-            let mut d = Zero::zero::<BigUint>();\n+            let mut d: BigUint = Zero::zero();\n             let mut n = 1;\n             while m >= b {\n                 let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n@@ -411,8 +411,9 @@ impl Integer for BigUint {\n             if shift == 0 {\n                 return (BigUint::new(d), One::one(), (*b).clone());\n             }\n+            let one: BigUint = One::one();\n             return (BigUint::from_slice(d).shl_unit(shift),\n-                    One::one::<BigUint>().shl_unit(shift),\n+                    one.shl_unit(shift),\n                     b.shl_unit(shift));\n         }\n     }\n@@ -1445,11 +1446,18 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        assert!(FromStr::from_str::<BigUint>(\"1\").unwrap().is_odd());\n-        assert!(FromStr::from_str::<BigUint>(\"2\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000000\").unwrap().is_even());\n-        assert!(FromStr::from_str::<BigUint>(\"1000000000000000000001\").unwrap().is_odd());\n+        let one: Option<BigUint> = FromStr::from_str(\"1\");\n+        let two: Option<BigUint> = FromStr::from_str(\"2\");\n+        let thousand: Option<BigUint> = FromStr::from_str(\"1000\");\n+        let big: Option<BigUint> =\n+            FromStr::from_str(\"1000000000000000000000\");\n+        let bigger: Option<BigUint> =\n+            FromStr::from_str(\"1000000000000000000001\");\n+        assert!(one.unwrap().is_odd());\n+        assert!(two.unwrap().is_even());\n+        assert!(thousand.unwrap().is_even());\n+        assert!(big.unwrap().is_even());\n+        assert!(bigger.unwrap().is_odd());\n         assert!((BigUint::from_uint(1) << 64).is_even());\n         assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n     }\n@@ -1534,15 +1542,19 @@ mod biguint_tests {\n             }\n         }\n \n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"Z\", 10), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"_\", 2), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"-1\", 10), None);\n+        let zed: Option<BigUint> = FromStrRadix::from_str_radix(\"Z\", 10);\n+        assert_eq!(zed, None);\n+        let blank: Option<BigUint> = FromStrRadix::from_str_radix(\"_\", 2);\n+        assert_eq!(blank, None);\n+        let minus_one: Option<BigUint> = FromStrRadix::from_str_radix(\"-1\",\n+                                                                      10);\n+        assert_eq!(minus_one, None);\n     }\n \n     #[test]\n     fn test_factor() {\n         fn factor(n: uint) -> BigUint {\n-            let mut f= One::one::<BigUint>();\n+            let mut f: BigUint = One::one();\n             for i in range(2, n + 1) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n                 // f *= BigUint::from_uint(i);\n@@ -1939,17 +1951,24 @@ mod bigint_tests {\n \n     #[test]\n     fn test_abs_sub() {\n-        assert_eq!((-One::one::<BigInt>()).abs_sub(&One::one()), Zero::zero());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&One::one()), Zero::zero());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&Zero::zero()), One::one());\n-        assert_eq!(One::one::<BigInt>().abs_sub(&-One::one::<BigInt>()),\n-                   IntConvertible::from_int(2));\n+        let zero: BigInt = Zero::zero();\n+        let one: BigInt = One::one();\n+        assert_eq!((-one).abs_sub(&one), zero);\n+        let one: BigInt = One::one();\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(one.abs_sub(&one), zero);\n+        let one: BigInt = One::one();\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(one.abs_sub(&zero), one);\n+        let one: BigInt = One::one();\n+        assert_eq!(one.abs_sub(&-one), IntConvertible::from_int(2));\n     }\n \n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert!(ans == IntConvertible::from_int::<BigInt>(n).to_str_radix(10));\n+            let n: BigInt = IntConvertible::from_int(n);\n+            assert!(ans == n.to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -1962,7 +1981,10 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map_move(|n| IntConvertible::from_int::<BigInt>(n));\n+            let ans = ans.map_move(|n| {\n+                let x: BigInt = IntConvertible::from_int(n);\n+                x\n+            });\n             assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n         }\n         check(\"10\", Some(10));\n@@ -1980,7 +2002,8 @@ mod bigint_tests {\n             BigInt::new(Minus, ~[1, 1, 1]));\n         assert!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n             BigInt::new(Plus,  ~[1, 1, 1]));\n-        assert_eq!(-Zero::zero::<BigInt>(), Zero::zero::<BigInt>());\n+        let zero: BigInt = Zero::zero();\n+        assert_eq!(-zero, zero);\n     }\n }\n "}, {"sha": "41e9a488bf8ae8fa74149502dbe2f35eface48b0", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -269,9 +269,13 @@ impl<T: FromStr + Clone + Integer + Ord>\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n         let split: ~[&str] = s.splitn_iter('/', 1).collect();\n-        if split.len() < 2 { return None; }\n-        do FromStr::from_str::<T>(split[0]).chain |a| {\n-            do FromStr::from_str::<T>(split[1]).chain |b| {\n+        if split.len() < 2 {\n+            return None\n+        }\n+        let a_option: Option<T> = FromStr::from_str(split[0]);\n+        do a_option.chain |a| {\n+            let b_option: Option<T> = FromStr::from_str(split[1]);\n+            do b_option.chain |b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n@@ -282,10 +286,15 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n         let split: ~[&str] = s.splitn_iter('/', 1).collect();\n-        if split.len() < 2 { None }\n-        else {\n-            do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {\n-                do FromStrRadix::from_str_radix::<T>(split[1], radix).chain |b| {\n+        if split.len() < 2 {\n+            None\n+        } else {\n+            let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n+                                                                   radix);\n+            do a_option.chain |a| {\n+                let b_option: Option<T> =\n+                    FromStrRadix::from_str_radix(split[1], radix);\n+                do b_option.chain |b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }\n@@ -496,7 +505,8 @@ mod test {\n     #[test]\n     fn test_from_str_fail() {\n         fn test(s: &str) {\n-            assert_eq!(FromStr::from_str::<Rational>(s), None);\n+            let rational: Option<Rational> = FromStr::from_str(s);\n+            assert_eq!(rational, None);\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n@@ -536,7 +546,8 @@ mod test {\n     #[test]\n     fn test_from_str_radix_fail() {\n         fn test(s: &str) {\n-            assert_eq!(FromStrRadix::from_str_radix::<Rational>(s, 3), None);\n+            let radix: Option<Rational> = FromStrRadix::from_str_radix(s, 3);\n+            assert_eq!(radix, None);\n         }\n \n         let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];"}, {"sha": "b085981aabba1cb6244130d3be44d1912f436452", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -338,27 +338,36 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_pop() { let mut heap = PriorityQueue::new::<int>(); heap.pop(); }\n+    fn test_empty_pop() {\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        heap.pop();\n+    }\n \n     #[test]\n     fn test_empty_maybe_pop() {\n-        let mut heap = PriorityQueue::new::<int>();\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n         assert!(heap.maybe_pop().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_top() { let empty = PriorityQueue::new::<int>(); empty.top(); }\n+    fn test_empty_top() {\n+        let empty: PriorityQueue<int> = PriorityQueue::new();\n+        empty.top();\n+    }\n \n     #[test]\n     fn test_empty_maybe_top() {\n-        let empty = PriorityQueue::new::<int>();\n+        let empty: PriorityQueue<int> = PriorityQueue::new();\n         assert!(empty.maybe_top().is_none());\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_empty_replace() { let mut heap = PriorityQueue::new(); heap.replace(5); }\n+    fn test_empty_replace() {\n+        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n+        heap.replace(5);\n+    }\n \n     #[test]\n     fn test_from_iter() {"}, {"sha": "4f2755374af02779354b9ea0a1ffd270e4a4999e", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -483,7 +483,7 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n         do b.iter {\n-            let _ = RingBuf::new::<u64>();\n+            let _: RingBuf<u64> = RingBuf::new();\n         }\n     }\n "}, {"sha": "307de43a067f0e5a1cccb5d363240af83a1cb0d9", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -879,7 +879,8 @@ mod test_treemap {\n \n     #[test]\n     fn find_empty() {\n-        let m = TreeMap::new::<int, int>(); assert!(m.find(&5) == None);\n+        let m: TreeMap<int,int> = TreeMap::new();\n+        assert!(m.find(&5) == None);\n     }\n \n     #[test]\n@@ -1006,7 +1007,7 @@ mod test_treemap {\n \n     #[test]\n     fn test_rand_int() {\n-        let mut map = TreeMap::new::<int, int>();\n+        let mut map: TreeMap<int,int> = TreeMap::new();\n         let mut ctrl = ~[];\n \n         check_equal(ctrl, &map);"}, {"sha": "a341db75393d3d1bf0ec6f08f5e098be300bd16d", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -387,7 +387,7 @@ fn path_node(ids: ~[ast::ident]) -> ast::Path {\n     ast::Path {\n         span: dummy_sp(),\n         global: false,\n-        segments: ids.consume_iter().transform(|identifier| ast::PathSegment {\n+        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n             lifetime: None,\n             types: opt_vec::Empty,\n@@ -399,7 +399,7 @@ fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n     ast::Path {\n         span: dummy_sp(),\n         global: true,\n-        segments: ids.consume_iter().transform(|identifier| ast::PathSegment {\n+        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n             lifetime: None,\n             types: opt_vec::Empty,"}, {"sha": "96249cc88ab2ea2d3525de58999985db13b8c7ef", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -335,15 +335,19 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::CrateNum)\n             let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n                 { ast::impure_fn };\n             // def_static_method carries an optional field of its enclosing\n-            // *trait*, but not an inclosing Impl (if this is an inherent\n-            // static method). So we need to detect whether this is in\n-            // a trait or not, which we do through the mildly hacky\n-            // way of checking whether there is a trait_method_sort.\n-            let trait_did_opt = if reader::maybe_get_doc(\n+            // trait or enclosing impl (if this is an inherent static method).\n+            // So we need to detect whether this is in a trait or not, which\n+            // we do through the mildly hacky way of checking whether there is\n+            // a trait_method_sort.\n+            let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_method_sort).is_some() {\n-                Some(item_reqd_and_translated_parent_item(cnum, item))\n-            } else { None };\n-            dl_def(ast::def_static_method(did, trait_did_opt, purity))\n+                ast::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                                                                    item))\n+            } else {\n+                ast::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                                                                   item))\n+            };\n+            dl_def(ast::def_static_method(did, provenance, purity))\n         }\n         Type | ForeignType => dl_def(ast::def_ty(did)),\n         Mod => dl_def(ast::def_mod(did)),"}, {"sha": "f5bad88b1ca66eb3a7df4927c3b25247ca7f1e31", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -141,7 +141,7 @@ fn parse_path(st: &mut PState) -> @ast::Path {\n                 return @ast::Path {\n                     span: dummy_sp(),\n                     global: false,\n-                    segments: idents.consume_iter().transform(|identifier| {\n+                    segments: idents.move_iter().map(|identifier| {\n                         ast::PathSegment {\n                             identifier: identifier,\n                             lifetime: None,"}, {"sha": "d6b22381192d26c676aabf5a61149cf8ada94fd8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -374,9 +374,16 @@ impl tr for ast::def {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n         match *self {\n           ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n-          ast::def_static_method(did, did2_opt, p) => {\n+          ast::def_static_method(did, wrapped_did2, p) => {\n             ast::def_static_method(did.tr(xcx),\n-                                   did2_opt.map(|did2| did2.tr(xcx)),\n+                                   match wrapped_did2 {\n+                                    ast::FromTrait(did2) => {\n+                                        ast::FromTrait(did2.tr(xcx))\n+                                    }\n+                                    ast::FromImpl(did2) => {\n+                                        ast::FromImpl(did2.tr(xcx))\n+                                    }\n+                                   },\n                                    p)\n           }\n           ast::def_method(did0, did1) => {"}, {"sha": "dbe5214e0eb50013cfc0873f239a4ccaabc18345", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -392,10 +392,12 @@ impl GatherLoanCtxt {\n                     }\n                     ty::AutoBorrowObj(r, m) => {\n                         let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        let loan_mutability =\n+                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             m,\n+                                             loan_mutability,\n                                              r)\n                     }\n                     ty::AutoUnsafe(_) => {}"}, {"sha": "8f95d1232886e1737e0d3d65184e78d747e3d5a6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// A pass that checks to make sure private fields and methods aren't used\n-// outside their scopes.\n-\n+//! A pass that checks to make sure private fields and methods aren't used\n+//! outside their scopes.\n \n use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};"}, {"sha": "cb987c69a5b317c094510e8c4fc6efa96259cdc4", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -55,6 +55,12 @@ pub type BindingMap = HashMap<ident,binding_info>;\n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[def_id]>;\n \n+// A summary of the generics on a trait.\n+struct TraitGenerics {\n+    has_lifetime: bool,\n+    type_parameter_count: uint,\n+}\n+\n // This is the replacement export map. It maps a module to all of the exports\n // within.\n pub type ExportMap2 = @mut HashMap<NodeId, ~[Export2]>;\n@@ -1321,9 +1327,12 @@ impl Resolver {\n                                                method.span);\n                             let def = match method.explicit_self.node {\n                                 sty_static => {\n-                                    // Static methods become `def_fn`s.\n-                                    def_fn(local_def(method.id),\n-                                           method.purity)\n+                                    // Static methods become\n+                                    // `def_static_method`s.\n+                                    def_static_method(local_def(method.id),\n+                                                      FromImpl(local_def(\n+                                                        item.id)),\n+                                                      method.purity)\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1373,7 +1382,7 @@ impl Resolver {\n                         sty_static => {\n                             // Static methods become `def_static_method`s.\n                             def_static_method(local_def(ty_m.id),\n-                                              Some(local_def(item.id)),\n+                                              FromTrait(local_def(item.id)),\n                                               ty_m.purity)\n                         }\n                         _ => {\n@@ -2115,7 +2124,7 @@ impl Resolver {\n     fn path_idents_to_str(@mut self, path: &Path) -> ~str {\n         let identifiers: ~[ast::ident] = path.segments\n                                              .iter()\n-                                             .transform(|seg| seg.identifier)\n+                                             .map(|seg| seg.identifier)\n                                              .collect();\n         self.idents_to_str(identifiers)\n     }\n@@ -4161,6 +4170,22 @@ impl Resolver {\n                         Some(&primitive_type) => {\n                             result_def =\n                                 Some(def_prim_ty(primitive_type));\n+\n+                            if path.segments\n+                                   .iter()\n+                                   .any(|s| s.lifetime.is_some()) {\n+                                self.session.span_err(path.span,\n+                                                      \"lifetime parameters \\\n+                                                       are not allowed on \\\n+                                                       this type\")\n+                            } else if path.segments\n+                                          .iter()\n+                                          .any(|s| s.types.len() > 0) {\n+                                self.session.span_err(path.span,\n+                                                      \"type parameters are \\\n+                                                       not allowed on this \\\n+                                                       type\")\n+                            }\n                         }\n                         None => {\n                             // Continue.\n@@ -4170,12 +4195,17 @@ impl Resolver {\n \n                 match result_def {\n                     None => {\n-                        match self.resolve_path(ty.id, path, TypeNS, true, visitor) {\n+                        match self.resolve_path(ty.id,\n+                                                path,\n+                                                TypeNS,\n+                                                true,\n+                                                visitor) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n-                                       self.session.str_of(\n-                                            path.segments.last().identifier),\n+                                       self.session.str_of(path.segments\n+                                                               .last()\n+                                                               .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -4184,9 +4214,7 @@ impl Resolver {\n                             }\n                         }\n                     }\n-                    Some(_) => {\n-                        // Continue.\n-                    }\n+                    Some(_) => {}   // Continue.\n                 }\n \n                 match result_def {\n@@ -4364,7 +4392,7 @@ impl Resolver {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map_(|seg| seg.types.iter()) {\n+                                  .flat_map(|seg| seg.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4399,7 +4427,7 @@ impl Resolver {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map_(|s| s.types.iter()) {\n+                                  .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4432,7 +4460,7 @@ impl Resolver {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map_(|s| s.types.iter()) {\n+                                  .flat_map(|s| s.types.iter()) {\n                         self.resolve_type(ty, visitor);\n                     }\n                 }\n@@ -4529,7 +4557,7 @@ impl Resolver {\n                         visitor: &mut ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n-        for ty in path.segments.iter().flat_map_(|s| s.types.iter()) {\n+        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n             self.resolve_type(ty, visitor);\n         }\n \n@@ -4553,11 +4581,13 @@ impl Resolver {\n             match (def, unqualified_def) {\n                 (Some(d), Some(ud)) if d == ud => {\n                     self.session.add_lint(unnecessary_qualification,\n-                                          id, path.span,\n+                                          id,\n+                                          path.span,\n                                           ~\"unnecessary qualification\");\n                 }\n                 _ => ()\n             }\n+\n             return def;\n         }\n "}, {"sha": "f1d98713124c0e99b42e61637cbd58b397ee46b5", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -117,10 +117,13 @@ pub fn trans(bcx: @mut Block, expr: @ast::expr) -> Callee {\n \n     fn trans_def(bcx: @mut Block, def: ast::def, ref_expr: @ast::expr) -> Callee {\n         match def {\n-            ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n+            ast::def_fn(did, _) |\n+            ast::def_static_method(did, ast::FromImpl(_), _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ref_expr.id))\n             }\n-            ast::def_static_method(impl_did, Some(trait_did), _) => {\n+            ast::def_static_method(impl_did,\n+                                   ast::FromTrait(trait_did),\n+                                   _) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, impl_did,\n                                                                 trait_did,\n                                                                 ref_expr.id))"}, {"sha": "57464fa4cc4b76e9c816be818c5dd16f82b56f8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -824,14 +824,17 @@ fn trans_def_datum_unadjusted(bcx: @mut Block,\n {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n-    let fn_data = match def {\n-        ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n+    match def {\n+        ast::def_fn(did, _) |\n+        ast::def_static_method(did, ast::FromImpl(_), _) => {\n             callee::trans_fn_ref(bcx, did, ref_expr.id)\n         }\n-        ast::def_static_method(impl_did, Some(trait_did), _) => {\n-            meth::trans_static_method_callee(bcx, impl_did,\n-                                             trait_did,\n-                                             ref_expr.id)\n+        ast::def_static_method(impl_did, ast::FromTrait(trait_did), _) => {\n+            let fn_data = meth::trans_static_method_callee(bcx,\n+                                                           impl_did,\n+                                                           trait_did,\n+                                                           ref_expr.id);\n+            return fn_data_to_datum(bcx, ref_expr, impl_did, fn_data);\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, fmt!("}, {"sha": "17b4716ad508e8927ab4c5953c0171dfa5db8a57", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -178,7 +178,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n \n     // Convert the type parameters supplied by the user.\n     let supplied_type_parameter_count =\n-        path.segments.iter().flat_map_(|s| s.types.iter()).len_();\n+        path.segments.iter().flat_map(|s| s.types.iter()).len();\n     if decl_generics.type_param_defs.len() != supplied_type_parameter_count {\n         this.tcx().sess.span_fatal(\n             path.span,\n@@ -188,8 +188,8 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Clone + 'static>(\n     }\n     let tps = path.segments\n                   .iter()\n-                  .flat_map_(|s| s.types.iter())\n-                  .transform(|a_t| ast_ty_to_ty(this, rscope, a_t))\n+                  .flat_map(|s| s.types.iter())\n+                  .map(|a_t| ast_ty_to_ty(this, rscope, a_t))\n                   .collect();\n \n     substs {"}, {"sha": "628ceccd61e7e70f39f22e2db1b2f694d9a24b74", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -128,7 +128,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                 Some((enm, var)) => {\n                     // Assign the pattern the type of the *enum*, not the variant.\n                     let enum_tpt = ty::lookup_item_type(tcx, enm);\n-                    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id);\n+                    instantiate_path(pcx.fcx,\n+                                     path,\n+                                     enum_tpt,\n+                                     v_def,\n+                                     pat.span,\n+                                     pat.id);\n \n                     // check that the type of the value being matched is a subtype\n                     // of the type of the pattern:\n@@ -185,7 +190,12 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n             } else {\n                 ctor_tpt\n             };\n-            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id);\n+            instantiate_path(pcx.fcx,\n+                             path,\n+                             struct_tpt,\n+                             s_def,\n+                             pat.span,\n+                             pat.id);\n \n             // Check that the type of the value being matched is a subtype of\n             // the type of the pattern."}, {"sha": "214fb1f2f0753cd967a4a5072208fb6eb744339b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 202, "deletions": 22, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -1132,8 +1132,160 @@ pub enum DerefArgs {\n     DoDerefArgs\n }\n \n-pub fn break_here() {\n-    debug!(\"break here!\");\n+// Given the provenance of a static method, returns the generics of the static\n+// method's container.\n+fn generics_of_static_method_container(type_context: ty::ctxt,\n+                                       provenance: ast::MethodProvenance)\n+                                       -> ty::Generics {\n+    match provenance {\n+        ast::FromTrait(trait_def_id) => {\n+            ty::lookup_trait_def(type_context, trait_def_id).generics\n+        }\n+        ast::FromImpl(impl_def_id) => {\n+            ty::lookup_item_type(type_context, impl_def_id).generics\n+        }\n+    }\n+}\n+\n+// Verifies that type parameters supplied in paths are in the right\n+// locations.\n+fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n+                                          path: &ast::Path,\n+                                          def: ast::def) {\n+    // We only care about checking the case in which the path has two or\n+    // more segments.\n+    if path.segments.len() < 2 {\n+        return\n+    }\n+\n+    // Verify that no lifetimes or type parameters are present anywhere\n+    // except the final two elements of the path.\n+    for i in range(0, path.segments.len() - 2) {\n+        match path.segments[i].lifetime {\n+            None => {}\n+            Some(lifetime) => {\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(lifetime.span,\n+                                          \"lifetime parameters may not \\\n+                                           appear here\")\n+            }\n+        }\n+\n+        for typ in path.segments[i].types.iter() {\n+            function_context.tcx()\n+                            .sess\n+                            .span_err(typ.span,\n+                                      \"type parameters may not appear here\")\n+        }\n+    }\n+\n+    // If there are no parameters at all, there is nothing more to do; the\n+    // rest of typechecking will (attempt to) infer everything.\n+    if path.segments\n+           .iter()\n+           .all(|s| s.lifetime.is_none() && s.types.is_empty()) {\n+        return\n+    }\n+\n+    match def {\n+        // If this is a static method of a trait or implementation, then\n+        // ensure that the segment of the path which names the trait or\n+        // implementation (the penultimate segment) is annotated with the\n+        // right number of type parameters.\n+        ast::def_static_method(_, provenance, _) => {\n+            let generics =\n+                generics_of_static_method_container(function_context.ccx.tcx,\n+                                                    provenance);\n+            let name = match provenance {\n+                ast::FromTrait(_) => \"trait\",\n+                ast::FromImpl(_) => \"impl\",\n+            };\n+\n+            let trait_segment = &path.segments[path.segments.len() - 2];\n+\n+            // Make sure lifetime parameterization agrees with the trait or\n+            // implementation type.\n+            match (generics.region_param, trait_segment.lifetime) {\n+                (Some(_), None) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(path.span,\n+                                              fmt!(\"this %s has a lifetime \\\n+                                                    parameter but no \\\n+                                                    lifetime was specified\",\n+                                                   name))\n+                }\n+                (None, Some(_)) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(path.span,\n+                                              fmt!(\"this %s has no lifetime \\\n+                                                    parameter but a lifetime \\\n+                                                    was specified\",\n+                                                   name))\n+                }\n+                (Some(_), Some(_)) | (None, None) => {}\n+            }\n+\n+            // Make sure the number of type parameters supplied on the trait\n+            // or implementation segment equals the number of type parameters\n+            // on the trait or implementation definition.\n+            let trait_type_parameter_count = generics.type_param_defs.len();\n+            let supplied_type_parameter_count = trait_segment.types.len();\n+            if trait_type_parameter_count != supplied_type_parameter_count {\n+                let trait_count_suffix = if trait_type_parameter_count == 1 {\n+                    \"\"\n+                } else {\n+                    \"s\"\n+                };\n+                let supplied_count_suffix =\n+                    if supplied_type_parameter_count == 1 {\n+                        \"\"\n+                    } else {\n+                        \"s\"\n+                    };\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(path.span,\n+                                          fmt!(\"the %s referenced by this \\\n+                                                path has %u type \\\n+                                                parameter%s, but %u type \\\n+                                                parameter%s were supplied\",\n+                                               name,\n+                                               trait_type_parameter_count,\n+                                               trait_count_suffix,\n+                                               supplied_type_parameter_count,\n+                                               supplied_count_suffix))\n+            }\n+        }\n+        _ => {\n+            // Verify that no lifetimes or type parameters are present on\n+            // the penultimate segment of the path.\n+            let segment = &path.segments[path.segments.len() - 2];\n+            match segment.lifetime {\n+                None => {}\n+                Some(lifetime) => {\n+                    function_context.tcx()\n+                                    .sess\n+                                    .span_err(lifetime.span,\n+                                              \"lifetime parameters may not\n+                                               appear here\")\n+                }\n+            }\n+            for typ in segment.types.iter() {\n+                function_context.tcx()\n+                                .sess\n+                                .span_err(typ.span,\n+                                          \"type parameters may not appear \\\n+                                           here\");\n+                function_context.tcx()\n+                                .sess\n+                                .span_note(typ.span,\n+                                           fmt!(\"this is a %?\", def));\n+            }\n+        }\n+    }\n }\n \n /// Invariant:\n@@ -2333,8 +2485,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_path(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n+        check_type_parameter_positions_in_path(fcx, pth, defn);\n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n-        instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n+        instantiate_path(fcx, pth, tpt, defn, expr.span, expr.id);\n       }\n       ast::expr_self => {\n         let definition = lookup_def(fcx, expr.span, id);\n@@ -3141,11 +3294,12 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n+                        def: ast::def,\n                         span: span,\n                         node_id: ast::NodeId) {\n     debug!(\">>> instantiate_path\");\n \n-    let ty_param_count = tpt.generics.type_param_defs.len();\n+    let mut ty_param_count = tpt.generics.type_param_defs.len();\n     let mut ty_substs_len = 0;\n     for segment in pth.segments.iter() {\n         ty_substs_len += segment.types.len()\n@@ -3180,6 +3334,21 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         }\n     };\n \n+    // Special case: If there is a self parameter, omit it from the list of\n+    // type parameters.\n+    //\n+    // Here we calculate the \"user type parameter count\", which is the number\n+    // of type parameters actually manifest in the AST. This will differ from\n+    // the internal type parameter count when there are self types involved.\n+    let (user_type_parameter_count, self_parameter_index) = match def {\n+        ast::def_static_method(_, provenance @ ast::FromTrait(_), _) => {\n+            let generics = generics_of_static_method_container(fcx.ccx.tcx,\n+                                                               provenance);\n+            (ty_param_count - 1, Some(generics.type_param_defs.len()))\n+        }\n+        _ => (ty_param_count, None),\n+    };\n+\n     // determine values for type parameters, using the values given by\n     // the user (if any) and otherwise using fresh type variables\n     let tps = if ty_substs_len == 0 {\n@@ -3188,33 +3357,44 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n         fcx.ccx.tcx.sess.span_err\n             (span, \"this item does not take type parameters\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n-    } else if ty_substs_len > ty_param_count {\n+    } else if ty_substs_len > user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n              fmt!(\"too many type parameters provided: expected %u, found %u\",\n-                  ty_param_count, ty_substs_len));\n+                  user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n-    } else if ty_substs_len < ty_param_count {\n-        let is_static_method = match fcx.ccx.tcx.def_map.find(&node_id) {\n-            Some(&ast::def_static_method(*)) => true,\n-            _ => false\n-        };\n+    } else if ty_substs_len < user_type_parameter_count {\n         fcx.ccx.tcx.sess.span_err\n             (span,\n              fmt!(\"not enough type parameters provided: expected %u, found %u\",\n-                  ty_param_count, ty_substs_len));\n-        if is_static_method {\n-            fcx.ccx.tcx.sess.span_note\n-                (span, \"Static methods have an extra implicit type parameter -- \\\n-                 did you omit the type parameter for the `Self` type?\");\n-        }\n+                  user_type_parameter_count, ty_substs_len));\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.segments\n-           .iter()\n-           .flat_map_(|s| s.types.iter())\n-           .transform(|aty| fcx.to_ty(aty))\n-           .collect()\n+        // Build up the list of type parameters, inserting the self parameter\n+        // at the appropriate position.\n+        let mut result = ~[];\n+        let mut pushed = false;\n+        for (i, ast_type) in pth.segments\n+                                .iter()\n+                                .flat_map(|segment| segment.types.iter())\n+                                .enumerate() {\n+            match self_parameter_index {\n+                Some(index) if index == i => {\n+                    result.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    pushed = true;\n+                }\n+                _ => {}\n+            }\n+            result.push(fcx.to_ty(ast_type))\n+        }\n+\n+        // If the self parameter goes at the end, insert it there.\n+        if !pushed && self_parameter_index.is_some() {\n+            result.push(fcx.infcx().next_ty_vars(1)[0])\n+        }\n+\n+        assert_eq!(result.len(), ty_param_count)\n+        result\n     };\n \n     let substs = substs {"}, {"sha": "c192803efffa94576f51e3805f6341f106db8bf2", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -276,7 +276,7 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            do Local::borrow::<Task, *()> |task| {\n+            do Local::borrow |task: &mut Task| {\n                 task.heap.realloc(ptr as *libc::c_void, size) as *()\n             }\n         }"}, {"sha": "a1459b780dfb3cd204d4d47bc8f1d04eb2da374e", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -100,7 +100,7 @@ fn test_basic() {\n #[test]\n #[should_fail]\n fn test_take_empty() {\n-    let value_cell = Cell::new_empty::<~int>();\n+    let value_cell: Cell<~int> = Cell::new_empty();\n     value_cell.take();\n }\n "}, {"sha": "6d85b968f2a3172ffe21a8a98b3075a1fe69db70", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -884,10 +884,17 @@ impl<T> Poly for T {\n     }\n }\n \n-// n.b. use 'const' to get an implementation for both '*mut' and '*' at the same\n-//      time.\n-impl<T> Pointer for *const T {\n-    fn fmt(t: &*const T, f: &mut Formatter) {\n+impl<T> Pointer for *T {\n+    fn fmt(t: &*T, f: &mut Formatter) {\n+        f.flags |= 1 << (parse::FlagAlternate as uint);\n+        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+            f.pad_integral(buf, \"0x\", true);\n+        }\n+    }\n+}\n+\n+impl<T> Pointer for *mut T {\n+    fn fmt(t: &*mut T, f: &mut Formatter) {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n         do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n             f.pad_integral(buf, \"0x\", true);"}, {"sha": "bcd658ece66532a52401a041b78537c404de14b8", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -869,21 +869,21 @@ mod test_map {\n \n     #[test]\n     fn test_find_or_insert() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.find_or_insert(1, 2), 2);\n         assert_eq!(*m.find_or_insert(1, 3), 2);\n     }\n \n     #[test]\n     fn test_find_or_insert_with() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n         assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n     }\n \n     #[test]\n     fn test_insert_or_update_with() {\n-        let mut m = HashMap::new::<int, int>();\n+        let mut m: HashMap<int,int> = HashMap::new();\n         assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 2);\n         assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 3);\n     }"}, {"sha": "4af7b3e242596476ec131209c13d1cdc6540a5f4", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -660,7 +660,10 @@ pub trait AdditiveIterator<A> {\n \n impl<A: Add<A, A> + Zero, T: Iterator<A>> AdditiveIterator<A> for T {\n     #[inline]\n-    fn sum(&mut self) -> A { self.fold(Zero::zero::<A>(), |s, x| s + x) }\n+    fn sum(&mut self) -> A {\n+        let zero: A = Zero::zero();\n+        self.fold(zero, |s, x| s + x)\n+    }\n }\n \n /// A trait for iterators over elements whose elements can be multiplied\n@@ -685,7 +688,10 @@ pub trait MultiplicativeIterator<A> {\n \n impl<A: Mul<A, A> + One, T: Iterator<A>> MultiplicativeIterator<A> for T {\n     #[inline]\n-    fn product(&mut self) -> A { self.fold(One::one::<A>(), |p, x| p * x) }\n+    fn product(&mut self) -> A {\n+        let one: A = One::one();\n+        self.fold(one, |p, x| p * x)\n+    }\n }\n \n /// A trait for iterators over elements which can be compared to one another."}, {"sha": "215067ea729197c99e71c7e56609bc3a7304d277", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -59,7 +59,8 @@ fn newsched_log_str(msg: ~str) {\n     use rt::local::Local;\n \n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let optional_task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match optional_task {\n             Some(local) => {\n                 // Use the available logger\n                 (*local).logger.log(Left(msg));"}, {"sha": "1c59eaf021969ea446b182f3723e5b8200409442", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 117, "deletions": 62, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -182,7 +182,7 @@ impl ApproxEq<f32> for f32 {\n \n     #[inline]\n     fn approx_eq(&self, other: &f32) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f32, f32>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -561,11 +561,14 @@ impl Real for f32 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Real::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+    fn to_radians(&self) -> f32 {\n+        let value: f32 = Real::pi();\n+        *self * (value / 180.0f32)\n+    }\n }\n \n impl Bounded for f32 {\n@@ -578,10 +581,10 @@ impl Bounded for f32 {\n \n impl Primitive for f32 {\n     #[inline]\n-    fn bits() -> uint { 32 }\n+    fn bits(_: Option<f32>) -> uint { 32 }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n+    fn bytes(_: Option<f32>) -> uint { Primitive::bits(Some(0f32)) / 8 }\n }\n \n impl Float for f32 {\n@@ -638,25 +641,25 @@ impl Float for f32 {\n     }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { 24 }\n+    fn mantissa_digits(_: Option<f32>) -> uint { 24 }\n \n     #[inline]\n-    fn digits() -> uint { 6 }\n+    fn digits(_: Option<f32>) -> uint { 6 }\n \n     #[inline]\n     fn epsilon() -> f32 { 1.19209290e-07 }\n \n     #[inline]\n-    fn min_exp() -> int { -125 }\n+    fn min_exp(_: Option<f32>) -> int { -125 }\n \n     #[inline]\n-    fn max_exp() -> int { 128 }\n+    fn max_exp(_: Option<f32>) -> int { 128 }\n \n     #[inline]\n-    fn min_10_exp() -> int { -37 }\n+    fn min_10_exp(_: Option<f32>) -> int { -37 }\n \n     #[inline]\n-    fn max_10_exp() -> int { 38 }\n+    fn max_10_exp(_: Option<f32>) -> int { 38 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n@@ -949,9 +952,11 @@ mod tests {\n         assert_eq!(1f32.clamp(&2f32, &4f32), 2f32);\n         assert_eq!(8f32.clamp(&2f32, &4f32), 4f32);\n         assert_eq!(3f32.clamp(&2f32, &4f32), 3f32);\n-        assert!(3f32.clamp(&Float::NaN::<f32>(), &4f32).is_NaN());\n-        assert!(3f32.clamp(&2f32, &Float::NaN::<f32>()).is_NaN());\n-        assert!(Float::NaN::<f32>().clamp(&2f32, &4f32).is_NaN());\n+\n+        let nan: f32 = Float::NaN();\n+        assert!(3f32.clamp(&nan, &4f32).is_NaN());\n+        assert!(3f32.clamp(&2f32, &nan).is_NaN());\n+        assert!(nan.clamp(&2f32, &4f32).is_NaN());\n     }\n \n     #[test]\n@@ -1028,9 +1033,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n         assert_eq!((-0.0f32).asinh(), -0.0f32);\n-        assert_eq!(Float::infinity::<f32>().asinh(), Float::infinity::<f32>());\n-        assert_eq!(Float::neg_infinity::<f32>().asinh(), Float::neg_infinity::<f32>());\n-        assert!(Float::NaN::<f32>().asinh().is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n     }\n@@ -1039,9 +1048,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n         assert!(0.999f32.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<f32>().acosh(), Float::infinity::<f32>());\n-        assert!(Float::neg_infinity::<f32>().acosh().is_NaN());\n-        assert!(Float::NaN::<f32>().acosh().is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n         assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n     }\n@@ -1050,34 +1063,61 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f32.atanh(), 0.0f32);\n         assert_eq!((-0.0f32).atanh(), -0.0f32);\n-        assert_eq!(1.0f32.atanh(), Float::infinity::<f32>());\n-        assert_eq!((-1.0f32).atanh(), Float::neg_infinity::<f32>());\n+\n+        let inf32: f32 = Float::infinity();\n+        let neg_inf32: f32 = Float::neg_infinity();\n+        assert_eq!(1.0f32.atanh(), inf32);\n+        assert_eq!((-1.0f32).atanh(), neg_inf32);\n+\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<f32>().atanh().is_NaN());\n+\n+        let inf64: f32 = Float::infinity();\n+        let neg_inf64: f32 = Float::neg_infinity();\n+        let nan32: f32 = Float::NaN();\n+        assert!(inf64.atanh().is_NaN());\n+        assert!(neg_inf64.atanh().is_NaN());\n+        assert!(nan32.atanh().is_NaN());\n+\n         assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n         assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n-        assert_approx_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n-        assert_approx_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n-        assert_approx_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n-        assert_approx_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n-        assert_approx_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n-        assert_approx_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n-        assert_approx_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n-        assert_approx_eq!(Real::ln_2::<f32>(), 2f32.ln());\n-        assert_approx_eq!(Real::ln_10::<f32>(), 10f32.ln());\n+        let pi: f32 = Real::pi();\n+        let two_pi: f32 = Real::two_pi();\n+        let frac_pi_2: f32 = Real::frac_pi_2();\n+        let frac_pi_3: f32 = Real::frac_pi_3();\n+        let frac_pi_4: f32 = Real::frac_pi_4();\n+        let frac_pi_6: f32 = Real::frac_pi_6();\n+        let frac_pi_8: f32 = Real::frac_pi_8();\n+        let frac_1_pi: f32 = Real::frac_1_pi();\n+        let frac_2_pi: f32 = Real::frac_2_pi();\n+        let frac_2_sqrtpi: f32 = Real::frac_2_sqrtpi();\n+        let sqrt2: f32 = Real::sqrt2();\n+        let frac_1_sqrt2: f32 = Real::frac_1_sqrt2();\n+        let e: f32 = Real::e();\n+        let log2_e: f32 = Real::log2_e();\n+        let log10_e: f32 = Real::log10_e();\n+        let ln_2: f32 = Real::ln_2();\n+        let ln_10: f32 = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2f32 * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f32);\n+        assert_approx_eq!(frac_pi_3, pi / 3f32);\n+        assert_approx_eq!(frac_pi_4, pi / 4f32);\n+        assert_approx_eq!(frac_pi_6, pi / 6f32);\n+        assert_approx_eq!(frac_pi_8, pi / 8f32);\n+        assert_approx_eq!(frac_1_pi, 1f32 / pi);\n+        assert_approx_eq!(frac_2_pi, 2f32 / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f32 / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f32.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f32 / 2f32.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f32.ln());\n+        assert_approx_eq!(ln_10, 10f32.ln());\n     }\n \n     #[test]\n@@ -1153,29 +1193,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<f32>(), sys::size_of::<f32>() * 8);\n-        assert_eq!(Primitive::bytes::<f32>(), sys::size_of::<f32>());\n+        let none: Option<f32> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<f32>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<f32>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<f32>().is_normal());\n-        assert!(!Float::infinity::<f32>().is_normal());\n-        assert!(!Float::neg_infinity::<f32>().is_normal());\n-        assert!(!Zero::zero::<f32>().is_normal());\n-        assert!(!Float::neg_zero::<f32>().is_normal());\n+        let nan: f32 = Float::NaN();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Zero::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f32.is_normal());\n         assert!(1e-37f32.is_normal());\n         assert!(!1e-38f32.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<f32>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<f32>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<f32>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<f32>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<f32>().classify(), FPZero);\n+        let nan: f32 = Float::NaN();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Zero::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1f32.classify(), FPNormal);\n         assert_eq!(1e-37f32.classify(), FPNormal);\n         assert_eq!(1e-38f32.classify(), FPSubnormal);\n@@ -1192,11 +1243,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f32, -123), 0f32);\n         assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n-        assert_eq!(Float::ldexp(Float::infinity::<f32>(), -123),\n-                   Float::infinity::<f32>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<f32>(), -123),\n-                   Float::neg_infinity::<f32>());\n-        assert!(Float::ldexp(Float::NaN::<f32>(), -123).is_NaN());\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1214,10 +1267,12 @@ mod tests {\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));\n-        assert_eq!(match Float::infinity::<f32>().frexp() { (x, _) => x },\n-                   Float::infinity::<f32>())\n-        assert_eq!(match Float::neg_infinity::<f32>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<f32>())\n-        assert!(match Float::NaN::<f32>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n }"}, {"sha": "8f5d6473aea2f4f3763de9c6f0790e9ed1ffb9fb", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 120, "deletions": 66, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -205,7 +205,7 @@ impl ApproxEq<f64> for f64 {\n \n     #[inline]\n     fn approx_eq(&self, other: &f64) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<f64, f64>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -578,11 +578,14 @@ impl Real for f64 {\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Real::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+    fn to_radians(&self) -> f64 {\n+        let value: f64 = Real::pi();\n+        *self * (value / 180.0)\n+    }\n }\n \n impl RealExt for f64 {\n@@ -625,10 +628,10 @@ impl Bounded for f64 {\n \n impl Primitive for f64 {\n     #[inline]\n-    fn bits() -> uint { 64 }\n+    fn bits(_: Option<f64>) -> uint { 64 }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n+    fn bytes(_: Option<f64>) -> uint { Primitive::bits(Some(0f64)) / 8 }\n }\n \n impl Float for f64 {\n@@ -685,25 +688,25 @@ impl Float for f64 {\n     }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { 53 }\n+    fn mantissa_digits(_: Option<f64>) -> uint { 53 }\n \n     #[inline]\n-    fn digits() -> uint { 15 }\n+    fn digits(_: Option<f64>) -> uint { 15 }\n \n     #[inline]\n     fn epsilon() -> f64 { 2.2204460492503131e-16 }\n \n     #[inline]\n-    fn min_exp() -> int { -1021 }\n+    fn min_exp(_: Option<f64>) -> int { -1021 }\n \n     #[inline]\n-    fn max_exp() -> int { 1024 }\n+    fn max_exp(_: Option<f64>) -> int { 1024 }\n \n     #[inline]\n-    fn min_10_exp() -> int { -307 }\n+    fn min_10_exp(_: Option<f64>) -> int { -307 }\n \n     #[inline]\n-    fn max_10_exp() -> int { 308 }\n+    fn max_10_exp(_: Option<f64>) -> int { 308 }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n@@ -983,26 +986,32 @@ mod tests {\n     fn test_min() {\n         assert_eq!(1f64.min(&2f64), 1f64);\n         assert_eq!(2f64.min(&1f64), 1f64);\n-        assert!(1f64.min(&Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().min(&1f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(1f64.min(&nan).is_NaN());\n+        assert!(nan.min(&1f64).is_NaN());\n     }\n \n     #[test]\n     fn test_max() {\n         assert_eq!(1f64.max(&2f64), 2f64);\n         assert_eq!(2f64.max(&1f64), 2f64);\n-        assert!(1f64.max(&Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().max(&1f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(1f64.max(&nan).is_NaN());\n+        assert!(nan.max(&1f64).is_NaN());\n     }\n \n     #[test]\n     fn test_clamp() {\n         assert_eq!(1f64.clamp(&2f64, &4f64), 2f64);\n         assert_eq!(8f64.clamp(&2f64, &4f64), 4f64);\n         assert_eq!(3f64.clamp(&2f64, &4f64), 3f64);\n-        assert!(3f64.clamp(&Float::NaN::<f64>(), &4f64).is_NaN());\n-        assert!(3f64.clamp(&2f64, &Float::NaN::<f64>()).is_NaN());\n-        assert!(Float::NaN::<f64>().clamp(&2f64, &4f64).is_NaN());\n+\n+        let nan: f64 = Float::NaN();\n+        assert!(3f64.clamp(&nan, &4f64).is_NaN());\n+        assert!(3f64.clamp(&2f64, &nan).is_NaN());\n+        assert!(nan.clamp(&2f64, &4f64).is_NaN());\n     }\n \n     #[test]\n@@ -1079,9 +1088,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n-        assert_eq!(Float::infinity::<f64>().asinh(), Float::infinity::<f64>());\n-        assert_eq!(Float::neg_infinity::<f64>().asinh(), Float::neg_infinity::<f64>());\n-        assert!(Float::NaN::<f64>().asinh().is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n     }\n@@ -1090,9 +1103,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<f64>().acosh(), Float::infinity::<f64>());\n-        assert!(Float::neg_infinity::<f64>().acosh().is_NaN());\n-        assert!(Float::NaN::<f64>().acosh().is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n         assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n     }\n@@ -1101,34 +1118,56 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n-        assert_eq!(1.0f64.atanh(), Float::infinity::<f64>());\n-        assert_eq!((-1.0f64).atanh(), Float::neg_infinity::<f64>());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(1.0f64.atanh(), inf);\n+        assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<f64>().atanh().is_NaN());\n+        assert!(inf.atanh().is_NaN());\n+        assert!(neg_inf.atanh().is_NaN());\n+        assert!(nan.atanh().is_NaN());\n         assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n         assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n-        assert_approx_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n-        assert_approx_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n-        assert_approx_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n-        assert_approx_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n-        assert_approx_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n-        assert_approx_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n-        assert_approx_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n-        assert_approx_eq!(Real::ln_2::<f64>(), 2f64.ln());\n-        assert_approx_eq!(Real::ln_10::<f64>(), 10f64.ln());\n+        let pi: f64 = Real::pi();\n+        let two_pi: f64 = Real::two_pi();\n+        let frac_pi_2: f64 = Real::frac_pi_2();\n+        let frac_pi_3: f64 = Real::frac_pi_3();\n+        let frac_pi_4: f64 = Real::frac_pi_4();\n+        let frac_pi_6: f64 = Real::frac_pi_6();\n+        let frac_pi_8: f64 = Real::frac_pi_8();\n+        let frac_1_pi: f64 = Real::frac_1_pi();\n+        let frac_2_pi: f64 = Real::frac_2_pi();\n+        let frac_2_sqrtpi: f64 = Real::frac_2_sqrtpi();\n+        let sqrt2: f64 = Real::sqrt2();\n+        let frac_1_sqrt2: f64 = Real::frac_1_sqrt2();\n+        let e: f64 = Real::e();\n+        let log2_e: f64 = Real::log2_e();\n+        let log10_e: f64 = Real::log10_e();\n+        let ln_2: f64 = Real::ln_2();\n+        let ln_10: f64 = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2.0 * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f64);\n+        assert_approx_eq!(frac_pi_3, pi / 3f64);\n+        assert_approx_eq!(frac_pi_4, pi / 4f64);\n+        assert_approx_eq!(frac_pi_6, pi / 6f64);\n+        assert_approx_eq!(frac_pi_8, pi / 8f64);\n+        assert_approx_eq!(frac_1_pi, 1f64 / pi);\n+        assert_approx_eq!(frac_2_pi, 2f64 / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f64 / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f64.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f64 / 2f64.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f64.ln());\n+        assert_approx_eq!(ln_10, 10f64.ln());\n     }\n \n     #[test]\n@@ -1204,29 +1243,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<f64>(), sys::size_of::<f64>() * 8);\n-        assert_eq!(Primitive::bytes::<f64>(), sys::size_of::<f64>());\n+        let none: Option<f64> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<f64>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<f64>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<f64>().is_normal());\n-        assert!(!Float::infinity::<f64>().is_normal());\n-        assert!(!Float::neg_infinity::<f64>().is_normal());\n-        assert!(!Zero::zero::<f64>().is_normal());\n-        assert!(!Float::neg_zero::<f64>().is_normal());\n+        let nan: f64 = Float::NaN();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Zero::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f64.is_normal());\n         assert!(1e-307f64.is_normal());\n         assert!(!1e-308f64.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<f64>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<f64>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<f64>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<f64>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<f64>().classify(), FPZero);\n+        let nan: f64 = Float::NaN();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Zero::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1e-307f64.classify(), FPNormal);\n         assert_eq!(1e-308f64.classify(), FPSubnormal);\n     }\n@@ -1242,11 +1292,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f64, -123), 0f64);\n         assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n-        assert_eq!(Float::ldexp(Float::infinity::<f64>(), -123),\n-                   Float::infinity::<f64>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<f64>(), -123),\n-                   Float::neg_infinity::<f64>());\n-        assert!(Float::ldexp(Float::NaN::<f64>(), -123).is_NaN());\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1264,10 +1316,12 @@ mod tests {\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));\n-        assert_eq!(match Float::infinity::<f64>().frexp() { (x, _) => x },\n-                   Float::infinity::<f64>())\n-        assert_eq!(match Float::neg_infinity::<f64>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<f64>())\n-        assert!(match Float::NaN::<f64>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n }"}, {"sha": "d019de2468bdfa568699d8c76a0d8412da0ebd37", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 156, "deletions": 68, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -342,7 +342,7 @@ impl ApproxEq<float> for float {\n \n     #[inline]\n     fn approx_eq(&self, other: &float) -> bool {\n-        self.approx_eq_eps(other, &ApproxEq::approx_epsilon::<float, float>())\n+        self.approx_eq_eps(other, &1.0e-6)\n     }\n \n     #[inline]\n@@ -783,32 +783,56 @@ impl Signed for float {\n \n impl Bounded for float {\n     #[inline]\n-    fn min_value() -> float { Bounded::min_value::<f64>() as float }\n+    fn min_value() -> float {\n+        let x: f64 = Bounded::min_value();\n+        x as float\n+    }\n \n     #[inline]\n-    fn max_value() -> float { Bounded::max_value::<f64>() as float }\n+    fn max_value() -> float {\n+        let x: f64 = Bounded::max_value();\n+        x as float\n+    }\n }\n \n impl Primitive for float {\n     #[inline]\n-    fn bits() -> uint { Primitive::bits::<f64>() }\n+    fn bits(_: Option<float>) -> uint {\n+        let bits: uint = Primitive::bits(Some(0f64));\n+        bits\n+    }\n \n     #[inline]\n-    fn bytes() -> uint { Primitive::bytes::<f64>() }\n+    fn bytes(_: Option<float>) -> uint {\n+        let bytes: uint = Primitive::bytes(Some(0f64));\n+        bytes\n+    }\n }\n \n impl Float for float {\n     #[inline]\n-    fn NaN() -> float { Float::NaN::<f64>() as float }\n+    fn NaN() -> float {\n+        let value: f64 = Float::NaN();\n+        value as float\n+    }\n \n     #[inline]\n-    fn infinity() -> float { Float::infinity::<f64>() as float }\n+    fn infinity() -> float {\n+        let value: f64 = Float::infinity();\n+        value as float\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> float { Float::neg_infinity::<f64>() as float }\n+    fn neg_infinity() -> float {\n+        let value: f64 = Float::neg_infinity();\n+        value as float\n+    }\n \n     #[inline]\n-    fn neg_zero() -> float { Float::neg_zero::<f64>() as float }\n+    fn neg_zero() -> float {\n+        let value: f64 = Float::neg_zero();\n+        value as float\n+    }\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n@@ -832,30 +856,46 @@ impl Float for float {\n     fn classify(&self) -> FPCategory { (*self as f64).classify() }\n \n     #[inline]\n-    fn mantissa_digits() -> uint { Float::mantissa_digits::<f64>() }\n+    fn mantissa_digits(_: Option<float>) -> uint {\n+        Float::mantissa_digits(Some(0f64))\n+    }\n \n     #[inline]\n-    fn digits() -> uint { Float::digits::<f64>() }\n+    fn digits(_: Option<float>) -> uint {\n+        Float::digits(Some(0f64))\n+    }\n \n     #[inline]\n-    fn epsilon() -> float { Float::epsilon::<f64>() as float }\n+    fn epsilon() -> float {\n+        let value: f64 = Float::epsilon();\n+        value as float\n+    }\n \n     #[inline]\n-    fn min_exp() -> int { Float::min_exp::<f64>() }\n+    fn min_exp(_: Option<float>) -> int {\n+        Float::min_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn max_exp() -> int { Float::max_exp::<f64>() }\n+    fn max_exp(_: Option<float>) -> int {\n+        Float::max_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn min_10_exp() -> int { Float::min_10_exp::<f64>() }\n+    fn min_10_exp(_: Option<float>) -> int {\n+        Float::min_10_exp(Some(0f64))\n+    }\n \n     #[inline]\n-    fn max_10_exp() -> int { Float::max_10_exp::<f64>() }\n+    fn max_10_exp(_: Option<float>) -> int {\n+        Float::max_10_exp(Some(0f64))\n+    }\n \n     /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n     #[inline]\n     fn ldexp(x: float, exp: int) -> float {\n-        Float::ldexp(x as f64, exp) as float\n+        let value: f64 = Float::ldexp(x as f64, exp);\n+        value as float\n     }\n \n     ///\n@@ -937,9 +977,10 @@ mod tests {\n         assert_eq!(1f.clamp(&2f, &4f), 2f);\n         assert_eq!(8f.clamp(&2f, &4f), 4f);\n         assert_eq!(3f.clamp(&2f, &4f), 3f);\n-        assert!(3f.clamp(&Float::NaN::<float>(), &4f).is_NaN());\n-        assert!(3f.clamp(&2f, &Float::NaN::<float>()).is_NaN());\n-        assert!(Float::NaN::<float>().clamp(&2f, &4f).is_NaN());\n+        let nan: float = Float::NaN();\n+        assert!(3f.clamp(&nan, &4f).is_NaN());\n+        assert!(3f.clamp(&2f, &nan).is_NaN());\n+        assert!(nan.clamp(&2f, &4f).is_NaN());\n     }\n \n     #[test]\n@@ -1016,9 +1057,13 @@ mod tests {\n     fn test_asinh() {\n         assert_eq!(0.0f.asinh(), 0.0f);\n         assert_eq!((-0.0f).asinh(), -0.0f);\n-        assert_eq!(Float::infinity::<float>().asinh(), Float::infinity::<float>());\n-        assert_eq!(Float::neg_infinity::<float>().asinh(), Float::neg_infinity::<float>());\n-        assert!(Float::NaN::<float>().asinh().is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(inf.asinh(), inf);\n+        assert_eq!(neg_inf.asinh(), neg_inf);\n+        assert!(nan.asinh().is_NaN());\n         assert_approx_eq!(2.0f.asinh(), 1.443635475178810342493276740273105f);\n         assert_approx_eq!((-2.0f).asinh(), -1.443635475178810342493276740273105f);\n     }\n@@ -1027,9 +1072,13 @@ mod tests {\n     fn test_acosh() {\n         assert_eq!(1.0f.acosh(), 0.0f);\n         assert!(0.999f.acosh().is_NaN());\n-        assert_eq!(Float::infinity::<float>().acosh(), Float::infinity::<float>());\n-        assert!(Float::neg_infinity::<float>().acosh().is_NaN());\n-        assert!(Float::NaN::<float>().acosh().is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(inf.acosh(), inf);\n+        assert!(neg_inf.acosh().is_NaN());\n+        assert!(nan.acosh().is_NaN());\n         assert_approx_eq!(2.0f.acosh(), 1.31695789692481670862504634730796844f);\n         assert_approx_eq!(3.0f.acosh(), 1.76274717403908605046521864995958461f);\n     }\n@@ -1038,34 +1087,58 @@ mod tests {\n     fn test_atanh() {\n         assert_eq!(0.0f.atanh(), 0.0f);\n         assert_eq!((-0.0f).atanh(), -0.0f);\n-        assert_eq!(1.0f.atanh(), Float::infinity::<float>());\n-        assert_eq!((-1.0f).atanh(), Float::neg_infinity::<float>());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let inf64: f64 = Float::infinity();\n+        let neg_inf64: f64 = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(1.0f.atanh(), inf);\n+        assert_eq!((-1.0f).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_NaN());\n         assert!((-2f64).atanh().atanh().is_NaN());\n-        assert!(Float::infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::neg_infinity::<f64>().atanh().is_NaN());\n-        assert!(Float::NaN::<float>().atanh().is_NaN());\n+        assert!(inf64.atanh().is_NaN());\n+        assert!(neg_inf64.atanh().is_NaN());\n+        assert!(nan.atanh().is_NaN());\n         assert_approx_eq!(0.5f.atanh(), 0.54930614433405484569762261846126285f);\n         assert_approx_eq!((-0.5f).atanh(), -0.54930614433405484569762261846126285f);\n     }\n \n     #[test]\n     fn test_real_consts() {\n-        assert_approx_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n-        assert_approx_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n-        assert_approx_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n-        assert_approx_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n-        assert_approx_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n-        assert_approx_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n-        assert_approx_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n-        assert_approx_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n-        assert_approx_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n-        assert_approx_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n-        assert_approx_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n-        assert_approx_eq!(Real::ln_2::<float>(), 2f.ln());\n-        assert_approx_eq!(Real::ln_10::<float>(), 10f.ln());\n+        let pi: float = Real::pi();\n+        let two_pi: float = Real::two_pi();\n+        let frac_pi_2: float = Real::frac_pi_2();\n+        let frac_pi_3: float = Real::frac_pi_3();\n+        let frac_pi_4: float = Real::frac_pi_4();\n+        let frac_pi_6: float = Real::frac_pi_6();\n+        let frac_pi_8: float = Real::frac_pi_8();\n+        let frac_1_pi: float = Real::frac_1_pi();\n+        let frac_2_pi: float = Real::frac_2_pi();\n+        let frac_2_sqrtpi: float = Real::frac_2_sqrtpi();\n+        let sqrt2: float = Real::sqrt2();\n+        let frac_1_sqrt2: float = Real::frac_1_sqrt2();\n+        let e: float = Real::e();\n+        let log2_e: float = Real::log2_e();\n+        let log10_e: float = Real::log10_e();\n+        let ln_2: float = Real::ln_2();\n+        let ln_10: float = Real::ln_10();\n+\n+        assert_approx_eq!(two_pi, 2f * pi);\n+        assert_approx_eq!(frac_pi_2, pi / 2f);\n+        assert_approx_eq!(frac_pi_3, pi / 3f);\n+        assert_approx_eq!(frac_pi_4, pi / 4f);\n+        assert_approx_eq!(frac_pi_6, pi / 6f);\n+        assert_approx_eq!(frac_pi_8, pi / 8f);\n+        assert_approx_eq!(frac_1_pi, 1f / pi);\n+        assert_approx_eq!(frac_2_pi, 2f / pi);\n+        assert_approx_eq!(frac_2_sqrtpi, 2f / pi.sqrt());\n+        assert_approx_eq!(sqrt2, 2f.sqrt());\n+        assert_approx_eq!(frac_1_sqrt2, 1f / 2f.sqrt());\n+        assert_approx_eq!(log2_e, e.log2());\n+        assert_approx_eq!(log10_e, e.log10());\n+        assert_approx_eq!(ln_2, 2f.ln());\n+        assert_approx_eq!(ln_10, 10f.ln());\n     }\n \n     #[test]\n@@ -1141,29 +1214,40 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<float>(), sys::size_of::<float>() * 8);\n-        assert_eq!(Primitive::bytes::<float>(), sys::size_of::<float>());\n+        let none: Option<float> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<float>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<float>());\n     }\n \n     #[test]\n     fn test_is_normal() {\n-        assert!(!Float::NaN::<float>().is_normal());\n-        assert!(!Float::infinity::<float>().is_normal());\n-        assert!(!Float::neg_infinity::<float>().is_normal());\n-        assert!(!Zero::zero::<float>().is_normal());\n-        assert!(!Float::neg_zero::<float>().is_normal());\n+        let nan: float = Float::NaN();\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let zero: float = Zero::zero();\n+        let neg_zero: float = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n         assert!(1f.is_normal());\n         assert!(1e-307f.is_normal());\n         assert!(!1e-308f.is_normal());\n     }\n \n     #[test]\n     fn test_classify() {\n-        assert_eq!(Float::NaN::<float>().classify(), FPNaN);\n-        assert_eq!(Float::infinity::<float>().classify(), FPInfinite);\n-        assert_eq!(Float::neg_infinity::<float>().classify(), FPInfinite);\n-        assert_eq!(Zero::zero::<float>().classify(), FPZero);\n-        assert_eq!(Float::neg_zero::<float>().classify(), FPZero);\n+        let nan: float = Float::NaN();\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let zero: float = Zero::zero();\n+        let neg_zero: float = Float::neg_zero();\n+        assert_eq!(nan.classify(), FPNaN);\n+        assert_eq!(inf.classify(), FPInfinite);\n+        assert_eq!(neg_inf.classify(), FPInfinite);\n+        assert_eq!(zero.classify(), FPZero);\n+        assert_eq!(neg_zero.classify(), FPZero);\n         assert_eq!(1f.classify(), FPNormal);\n         assert_eq!(1e-307f.classify(), FPNormal);\n         assert_eq!(1e-308f.classify(), FPSubnormal);\n@@ -1180,11 +1264,13 @@ mod tests {\n \n         assert_eq!(Float::ldexp(0f, -123), 0f);\n         assert_eq!(Float::ldexp(-0f, -123), -0f);\n-        assert_eq!(Float::ldexp(Float::infinity::<float>(), -123),\n-                   Float::infinity::<float>());\n-        assert_eq!(Float::ldexp(Float::neg_infinity::<float>(), -123),\n-                   Float::neg_infinity::<float>());\n-        assert!(Float::ldexp(Float::NaN::<float>(), -123).is_NaN());\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_NaN());\n     }\n \n     #[test]\n@@ -1202,11 +1288,13 @@ mod tests {\n \n         assert_eq!(0f.frexp(), (0f, 0));\n         assert_eq!((-0f).frexp(), (-0f, 0));\n-        assert_eq!(match Float::infinity::<float>().frexp() { (x, _) => x },\n-                   Float::infinity::<float>())\n-        assert_eq!(match Float::neg_infinity::<float>().frexp() { (x, _) => x },\n-                   Float::neg_infinity::<float>())\n-        assert!(match Float::NaN::<float>().frexp() { (x, _) => x.is_NaN() })\n+\n+        let inf: float = Float::infinity();\n+        let neg_inf: float = Float::neg_infinity();\n+        let nan: float = Float::NaN();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_NaN() })\n     }\n \n     #[test]"}, {"sha": "6054d557fa5cd7547b556d36bd0d7fb979be2cd2", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -466,10 +466,10 @@ impl Int for $T {}\n \n impl Primitive for $T {\n     #[inline]\n-    fn bits() -> uint { bits }\n+    fn bits(_: Option<$T>) -> uint { bits }\n \n     #[inline]\n-    fn bytes() -> uint { bits / 8 }\n+    fn bytes(_: Option<$T>) -> uint { bits / 8 }\n }\n \n // String conversion functions and impl str -> num\n@@ -754,8 +754,9 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n+        let none: Option<$T> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "80ab0caac670ccdc911cabd92b808d8ad6da32ad", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -272,8 +272,8 @@ pub trait Primitive: Num\n                    + Div<Self,Self>\n                    + Rem<Self,Self> {\n     // FIXME (#5527): These should be associated constants\n-    fn bits() -> uint;\n-    fn bytes() -> uint;\n+    fn bits(unused_self: Option<Self>) -> uint;\n+    fn bytes(unused_self: Option<Self>) -> uint;\n }\n \n /// A collection of traits relevant to primitive signed and unsigned integers\n@@ -314,13 +314,13 @@ pub trait Float: Real\n     fn is_normal(&self) -> bool;\n     fn classify(&self) -> FPCategory;\n \n-    fn mantissa_digits() -> uint;\n-    fn digits() -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> uint;\n     fn epsilon() -> Self;\n-    fn min_exp() -> int;\n-    fn max_exp() -> int;\n-    fn min_10_exp() -> int;\n-    fn max_10_exp() -> int;\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     fn ldexp(x: Self, exp: int) -> Self;\n     fn frexp(&self) -> (Self, int);\n@@ -484,9 +484,9 @@ impl<T: CheckedAdd+CheckedSub+Zero+Ord+Bounded> Saturating for T {\n         match self.checked_add(&v) {\n             Some(x) => x,\n             None => if v >= Zero::zero() {\n-                Bounded::max_value::<T>()\n+                Bounded::max_value()\n             } else {\n-                Bounded::min_value::<T>()\n+                Bounded::min_value()\n             }\n         }\n     }\n@@ -496,9 +496,9 @@ impl<T: CheckedAdd+CheckedSub+Zero+Ord+Bounded> Saturating for T {\n         match self.checked_sub(&v) {\n             Some(x) => x,\n             None => if v >= Zero::zero() {\n-                Bounded::min_value::<T>()\n+                Bounded::min_value()\n             } else {\n-                Bounded::max_value::<T>()\n+                Bounded::max_value()\n             }\n         }\n     }"}, {"sha": "8ffaed22d01afd1b339030f81b29dc0115511620", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -404,10 +404,10 @@ impl ToStrRadix for $T {\n \n impl Primitive for $T {\n     #[inline]\n-    fn bits() -> uint { bits }\n+    fn bits(_: Option<$T>) -> uint { bits }\n \n     #[inline]\n-    fn bytes() -> uint { bits / 8 }\n+    fn bytes(_: Option<$T>) -> uint { bits / 8 }\n }\n \n impl BitCount for $T {\n@@ -532,8 +532,9 @@ mod tests {\n \n     #[test]\n     fn test_primitive() {\n-        assert_eq!(Primitive::bits::<$T>(), sys::size_of::<$T>() * 8);\n-        assert_eq!(Primitive::bytes::<$T>(), sys::size_of::<$T>());\n+        let none: Option<$T> = None;\n+        assert_eq!(Primitive::bits(none), sys::size_of::<$T>() * 8);\n+        assert_eq!(Primitive::bytes(none), sys::size_of::<$T>());\n     }\n \n     #[test]"}, {"sha": "e03a61226ad2606b5a439fe872904e2366a98f05", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -13,7 +13,7 @@ use c_str::ToCStr;\n use cast::transmute;\n use io::{Writer, WriterUtil};\n use io;\n-use libc::{c_char, c_void, size_t, STDERR_FILENO};\n+use libc::{c_char, size_t, STDERR_FILENO};\n use option::{Option, None, Some};\n use ptr::RawPtr;\n use rt::env;"}, {"sha": "4b1881409f44f54e35f002342ee9bf23350e5411", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -159,7 +159,7 @@ impl<T> ChanOne<T> {\n                         };\n                     } else {\n                         let recvr = Cell::new(recvr);\n-                        do Local::borrow::<Scheduler, ()> |sched| {\n+                        do Local::borrow |sched: &mut Scheduler| {\n                             sched.enqueue_blocked_task(recvr.take());\n                         }\n                     }\n@@ -199,7 +199,7 @@ impl<T> PortOne<T> {\n         if !this.optimistic_check() {\n             // No data available yet.\n             // Switch to the scheduler to put the ~Task into the Packet state.\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 this.block_on(sched, task);\n             }\n@@ -221,7 +221,7 @@ impl<T> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = do Local::borrow::<Scheduler, bool> |sched| {\n+        let actually_check = do Local::borrow |sched: &mut Scheduler| {\n             Rand::rand(&mut sched.rng)\n         };\n         if actually_check {"}, {"sha": "d1d6b16e2eb3cd12cc368c38aba3cb1474f1d298", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -359,7 +359,7 @@ impl FromStr for SocketAddr {\n mod test {\n     use super::*;\n     use from_str::FromStr;\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n \n     #[test]\n     fn test_from_str_ipv4() {\n@@ -368,13 +368,17 @@ mod test {\n         assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n \n         // out of range\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"256.0.0.1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"256.0.0.1\");\n+        assert_eq!(None, none);\n         // too short\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0\");\n+        assert_eq!(None, none);\n         // too long\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0.1.2\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0.1.2\");\n+        assert_eq!(None, none);\n         // no number between dots\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0..1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"255.0..1\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -389,15 +393,20 @@ mod test {\n                 FromStr::from_str(\"2a02:6b8::11:11\"));\n \n         // too long group\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::00000\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"::00000\");\n+        assert_eq!(None, none);\n         // too short\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7\");\n+        assert_eq!(None, none);\n         // too long\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7:8:9\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7:8:9\");\n+        assert_eq!(None, none);\n         // triple colon\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:::6:7:8\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2:::6:7:8\");\n+        assert_eq!(None, none);\n         // two double colons\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2::6::8\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1:2::6::8\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -412,11 +421,15 @@ mod test {\n                 FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n \n         // colon after v4\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::127.0.0.1:\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n+        assert_eq!(None, none);\n         // not enought groups\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:127.0.0.1\"));\n+        let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n+        assert_eq!(None, none);\n         // too many groups\n-        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:6:7:127.0.0.1\"));\n+        let none: Option<IpAddr> =\n+            FromStr::from_str(\"1.2.3.4.5:6:7:127.0.0.1\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]\n@@ -429,13 +442,17 @@ mod test {\n                 FromStr::from_str(\"[::127.0.0.1]:22\"));\n \n         // without port\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1\");\n+        assert_eq!(None, none);\n         // without port\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:\");\n+        assert_eq!(None, none);\n         // wrong brackets around v4\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"[127.0.0.1]:22\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"[127.0.0.1]:22\");\n+        assert_eq!(None, none);\n         // port out of range\n-        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:123456\"));\n+        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:123456\");\n+        assert_eq!(None, none);\n     }\n \n     #[test]"}, {"sha": "9be5540de484a96357c83b4f0fcc5f8068e569fc", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -29,7 +29,7 @@ impl TcpStream {\n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n         let stream = unsafe {\n             rtdebug!(\"borrowing io to connect\");\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             rtdebug!(\"about to connect\");\n             (*io).tcp_connect(addr)\n         };\n@@ -100,7 +100,7 @@ pub struct TcpListener(~RtioTcpListenerObject);\n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n         let listener = unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             (*io).tcp_bind(addr)\n         };\n         match listener {"}, {"sha": "132ca064515c1c867ecf141ad405750124b35dd5", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -20,7 +20,10 @@ pub struct UdpSocket(~RtioUdpSocketObject);\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let socket = unsafe { (*Local::unsafe_borrow::<IoFactoryObject>()).udp_bind(addr) };\n+        let socket = unsafe {\n+            let factory: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*factory).udp_bind(addr)\n+        };\n         match socket {\n             Ok(s) => Some(UdpSocket(s)),\n             Err(ioerr) => {"}, {"sha": "7f2d88f994d8cc1fb891ecd438eb7f6e191a8014", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -22,7 +22,7 @@ impl Timer {\n     pub fn new() -> Option<Timer> {\n         let timer = unsafe {\n             rtdebug!(\"Timer::init: borrowing io to init timer\");\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             rtdebug!(\"about to init timer\");\n             (*io).timer_init()\n         };"}, {"sha": "072fb4edf057876048c392f984d386076546be65", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -19,7 +19,7 @@ use cell::Cell;\n pub trait Local {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n-    fn exists() -> bool;\n+    fn exists(unused_value: Option<Self>) -> bool;\n     fn borrow<T>(f: &fn(&mut Self) -> T) -> T;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n@@ -31,7 +31,7 @@ impl Local for Task {\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n-    fn exists() -> bool { local_ptr::exists() }\n+    fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n     fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n@@ -59,7 +59,7 @@ impl Local for Task {\n impl Local for Scheduler {\n     fn put(value: ~Scheduler) {\n         let value = Cell::new(value);\n-        do Local::borrow::<Task,()> |task| {\n+        do Local::borrow |task: &mut Task| {\n             let task = task;\n             task.sched = Some(value.take());\n         };\n@@ -68,20 +68,20 @@ impl Local for Scheduler {\n     fn take() -> ~Scheduler {\n         unsafe {\n             // XXX: Unsafe for speed\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow();\n             (*task).sched.take_unwrap()\n         }\n     }\n-    fn exists() -> bool {\n-        do Local::borrow::<Task,bool> |task| {\n+    fn exists(_: Option<Scheduler>) -> bool {\n+        do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(ref _task) => true,\n                 None => false\n             }\n         }\n     }\n     fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n-        do Local::borrow::<Task, T> |task| {\n+        do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {\n                     f(task)\n@@ -94,7 +94,8 @@ impl Local for Scheduler {\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n-        match (*Local::unsafe_borrow::<Task>()).sched {\n+        let task: *mut Task = Local::unsafe_borrow();\n+        match (*task).sched {\n             Some(~ref mut sched) => {\n                 let s: *mut Scheduler = &mut *sched;\n                 return s;\n@@ -105,6 +106,7 @@ impl Local for Scheduler {\n         }\n     }\n     unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> {\n+        let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n         match Local::try_unsafe_borrow::<Task>() {\n             Some(task) => {\n                 match (*task).sched {\n@@ -124,15 +126,17 @@ impl Local for Scheduler {\n impl Local for IoFactoryObject {\n     fn put(_value: ~IoFactoryObject) { rtabort!(\"unimpl\") }\n     fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    fn exists() -> bool { rtabort!(\"unimpl\") }\n+    fn exists(_: Option<IoFactoryObject>) -> bool { rtabort!(\"unimpl\") }\n     fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n-        let sched = Local::unsafe_borrow::<Scheduler>();\n+        let sched: *mut Scheduler = Local::unsafe_borrow();\n         let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n         return io;\n     }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> { rtabort!(\"unimpl\") }\n+    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> {\n+        rtabort!(\"unimpl\")\n+    }\n }\n \n \n@@ -198,7 +202,7 @@ mod test {\n             let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n             Local::put(task);\n \n-            let res = do Local::borrow::<Task,bool> |_task| {\n+            let res = do Local::borrow |_task: &mut Task| {\n                 true\n             };\n             assert!(res)"}, {"sha": "12ec19a1ecc67af345c332a072da5055da186c87", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -13,7 +13,7 @@\n use libc;\n use libc::{c_void, uintptr_t, size_t};\n use ops::Drop;\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use rt::local::Local;\n use rt::task::Task;\n use unstable::raw;\n@@ -89,7 +89,8 @@ impl Drop for LocalHeap {\n // A little compatibility function\n pub unsafe fn local_free(ptr: *libc::c_char) {\n     // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task_ptr {\n         Some(task) => {\n             (*task).heap.free(ptr as *libc::c_void);\n         }\n@@ -98,7 +99,7 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *raw::Box<()> {\n-    let region = do Local::borrow::<Task, *BoxedRegion> |task| {\n+    let region = do Local::borrow |task: &mut Task| {\n         task.heap.boxed_region\n     };\n "}, {"sha": "6dbeb8c0ea9271d091e60c282aeccfb8a706393c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -64,7 +64,7 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iterator::{Iterator, range};\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n@@ -408,7 +408,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n pub fn in_sched_context() -> bool {\n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task_ptr {\n             Some(task) => {\n                 match (*task).task_type {\n                     SchedTask => true,\n@@ -422,7 +423,8 @@ pub fn in_sched_context() -> bool {\n \n pub fn in_green_task_context() -> bool {\n     unsafe {\n-        match Local::try_unsafe_borrow::<Task>() {\n+        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task {\n             Some(task) => {\n                 match (*task).task_type {\n                     GreenTask(_) => true,"}, {"sha": "b1319321c19f921fa2a5d8a54280854d8ba44fe6", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -169,7 +169,7 @@ impl Scheduler {\n         // successfully run the input task. Start by running the\n         // scheduler. Grab it out of TLS - performing the scheduler\n         // action will have given it away.\n-        let sched = Local::take::<Scheduler>();\n+        let sched: ~Scheduler = Local::take();\n \n         rtdebug!(\"starting scheduler %u\", sched.sched_id());\n         sched.run();\n@@ -185,7 +185,7 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        let mut stask = Local::take::<Task>();\n+        let mut stask: ~Task = Local::take();\n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n@@ -212,7 +212,7 @@ impl Scheduler {\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             let self_sched = Cell::new(self_sched);\n-            do Local::borrow::<Task,()> |stask| {\n+            do Local::borrow |stask: &mut Task| {\n                 stask.sched = Some(self_sched.take());\n             };\n \n@@ -234,7 +234,7 @@ impl Scheduler {\n         // already have a scheduler stored in our local task, so we\n         // start off by taking it. This is the only path through the\n         // scheduler where we get the scheduler this way.\n-        let mut sched = Local::take::<Scheduler>();\n+        let mut sched: ~Scheduler = Local::take();\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n@@ -522,7 +522,7 @@ impl Scheduler {\n         // The current task is grabbed from TLS, not taken as an input.\n         // Doing an unsafe_take to avoid writing back a null pointer -\n         // We're going to call `put` later to do that.\n-        let current_task: ~Task = unsafe { Local::unsafe_take::<Task>() };\n+        let current_task: ~Task = unsafe { Local::unsafe_take() };\n \n         // Check that the task is not in an atomically() section (e.g.,\n         // holding a pthread mutex, which could deadlock the scheduler).\n@@ -581,7 +581,7 @@ impl Scheduler {\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n         unsafe {\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow::<Task>();\n             (*task).sched.get_mut_ref().run_cleanup_job();\n \n             // Must happen after running the cleanup job (of course).\n@@ -692,7 +692,7 @@ impl Scheduler {\n \n     pub fn run_task_later(next_task: ~Task) {\n         let next_task = Cell::new(next_task);\n-        do Local::borrow::<Scheduler,()> |sched| {\n+        do Local::borrow |sched: &mut Scheduler| {\n             sched.enqueue_task(next_task.take());\n         };\n     }\n@@ -1024,12 +1024,12 @@ mod test {\n         // exit before emptying the work queue\n         do run_in_newsched_task {\n             do spawntask {\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 do sched.deschedule_running_task_and_then |sched, task| {\n                     let task = Cell::new(task);\n                     do sched.event_loop.callback_ms(10) {\n                         rtdebug!(\"in callback\");\n-                        let mut sched = Local::take::<Scheduler>();\n+                        let mut sched: ~Scheduler = Local::take();\n                         sched.enqueue_blocked_task(task.take());\n                         Local::put(sched);\n                     }"}, {"sha": "6cde0a1f2169f5f6f47c38040d1dc15570e5f7f4", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -26,3 +26,4 @@ pub trait SelectInner {\n pub trait SelectPortInner<T> {\n     fn recv_ready(self) -> Option<T>;\n }\n+"}, {"sha": "b1ab7a6cd5d3eb0b96b9f91dbc6baa7dd36ad70c", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -93,7 +93,7 @@ impl Task {\n     pub fn build_homed_child(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow::<Task, ~Task> |running_task| {\n+        do Local::borrow |running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n                                                          stack_size,\n@@ -111,7 +111,7 @@ impl Task {\n     pub fn build_homed_root(stack_size: Option<uint>, f: ~fn(), home: SchedHome) -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow::<Task, ~Task> |running_task| {\n+        do Local::borrow |running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n                                                  stack_size,\n@@ -305,7 +305,7 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        do Local::borrow::<Task,bool> |task| {\n+        do Local::borrow |task: &mut Task| {\n             let sched_id = task.sched.get_ref().sched_id();\n             let sched_run_anything = task.sched.get_ref().run_anything;\n             match task.task_type {\n@@ -369,7 +369,7 @@ impl Coroutine {\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                do Local::borrow::<Scheduler,()> |sched| {\n+                do Local::borrow |sched: &mut Scheduler| {\n                     sched.run_cleanup_job();\n                 }\n \n@@ -378,7 +378,7 @@ impl Coroutine {\n                 // simply unsafe_borrow it to get this reference. We\n                 // need to still have the task in TLS though, so we\n                 // need to unsafe_borrow.\n-                let task = Local::unsafe_borrow::<Task>();\n+                let task: *mut Task = Local::unsafe_borrow();\n \n                 do (*task).run {\n                     // N.B. Removing `start` from the start wrapper\n@@ -397,7 +397,7 @@ impl Coroutine {\n             }\n \n             // We remove the sched from the Task in TLS right now.\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             // ... allowing us to give it away when performing a\n             // scheduling operation.\n             sched.terminate_current_task()"}, {"sha": "b8e535e4c7dfd3ac202427402039dcf6f58e39e2", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -51,7 +51,7 @@ impl<T> Tube<T> {\n                 // There's a waiting task. Wake it up\n                 rtdebug!(\"waking blocked tube\");\n                 let task = (*state).blocked_task.take_unwrap();\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 sched.resume_blocked_task_immediately(task);\n             }\n         }\n@@ -67,7 +67,7 @@ impl<T> Tube<T> {\n                 rtdebug!(\"blocking on tube recv\");\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n-                let sched = Local::take::<Scheduler>();\n+                let sched: ~Scheduler = Local::take();\n                 do sched.deschedule_running_task_and_then |_, task| {\n                     (*state).blocked_task = Some(task);\n                 }\n@@ -102,7 +102,7 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n@@ -119,7 +119,7 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 let tube_clone = Cell::new(tube_clone.take());\n                 do sched.event_loop.callback {\n@@ -143,15 +143,15 @@ mod test {\n             let mut tube: Tube<int> = Tube::new();\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n-            let sched = Local::take::<Scheduler>();\n+            let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n                     if i == 100 { return; }\n \n                     let tube = Cell::new(Cell::new(tube));\n-                    do Local::borrow::<Scheduler, ()> |sched| {\n+                    do Local::borrow |sched: &mut Scheduler| {\n                         let tube = tube.take();\n                         do sched.event_loop.callback {\n                             let mut tube = tube.take();"}, {"sha": "fac3de2be6552a934f33ea476241724d96ca70f2", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -375,7 +375,7 @@ mod test_remote {\n             let mut tube = Tube::new();\n             let tube_clone = tube.clone();\n             let remote_cell = Cell::new_empty();\n-            do Local::borrow::<Scheduler, ()>() |sched| {\n+            do Local::borrow |sched: &mut Scheduler| {\n                 let tube_clone = tube_clone.clone();\n                 let tube_clone_cell = Cell::new(tube_clone);\n                 let remote = do sched.event_loop.remote_callback {\n@@ -416,7 +416,7 @@ impl IoFactory for UvIoFactory {\n \n         // Block this task and take ownership, switch to scheduler context\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler = Local::take::<Scheduler>();\n+            let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n \n                 let mut tcp = TcpWatcher::new(self.uv_loop());\n@@ -434,7 +434,7 @@ impl IoFactory for UvIoFactory {\n                             unsafe { (*result_cell_ptr).put_back(res); }\n \n                             // Context switch\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                         Some(_) => {\n@@ -464,11 +464,11 @@ impl IoFactory for UvIoFactory {\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     do scheduler.deschedule_running_task_and_then |_, task| {\n                         let task_cell = Cell::new(task);\n                         do watcher.as_stream().close {\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                     }\n@@ -487,11 +487,11 @@ impl IoFactory for UvIoFactory {\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     do scheduler.deschedule_running_task_and_then |_, task| {\n                         let task_cell = Cell::new(task);\n                         do watcher.close {\n-                            let scheduler = Local::take::<Scheduler>();\n+                            let scheduler: ~Scheduler = Local::take();\n                             scheduler.resume_blocked_task_immediately(task_cell.take());\n                         }\n                     }\n@@ -625,7 +625,7 @@ impl Drop for UvTcpListener {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher().as_stream().close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -717,7 +717,7 @@ impl Drop for UvTcpStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.as_stream().close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -765,7 +765,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take::<Scheduler>();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -793,7 +793,7 @@ impl RtioTcpStream for UvTcpStream {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -876,7 +876,7 @@ impl Drop for UvUdpSocket {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -917,7 +917,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -944,7 +944,7 @@ impl RtioUdpSocket for UvUdpSocket {\n \n                     unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1094,7 +1094,7 @@ impl Drop for UvTimer {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.close {\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1110,7 +1110,7 @@ impl RtioTimer for UvTimer {\n                 let task_cell = Cell::new(task);\n                 do self_.watcher.start(msecs, 0) |_, status| {\n                     assert!(status.is_none());\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n                 }\n             }\n@@ -1254,7 +1254,7 @@ impl RtioFileStream for UvFileStream {\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let addr = next_test_ip4();\n             let maybe_chan = (*io).tcp_connect(addr);\n             assert!(maybe_chan.is_err());\n@@ -1266,7 +1266,7 @@ fn test_simple_io_no_connect() {\n fn test_simple_udp_io_bind_only() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let addr = next_test_ip4();\n             let maybe_socket = (*io).udp_bind(addr);\n             assert!(maybe_socket.is_ok());\n@@ -1430,7 +1430,7 @@ fn test_simple_tcp_server_and_client() {\n         // Start the server first so it's listening when we connect\n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n@@ -1445,7 +1445,7 @@ fn test_simple_tcp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n@@ -1540,7 +1540,7 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n@@ -1555,7 +1555,7 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n@@ -1569,7 +1569,7 @@ fn test_read_and_block() {\n         let addr = next_test_ip4();\n \n         do spawntask {\n-            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1588,7 +1588,7 @@ fn test_read_and_block() {\n                 reads += 1;\n \n                 do task::unkillable { // FIXME(#8674)\n-                    let scheduler = Local::take::<Scheduler>();\n+                    let scheduler: ~Scheduler = Local::take();\n                     // Yield to the other task in hopes that it\n                     // will trigger a read callback while we are\n                     // not ready for it\n@@ -1605,7 +1605,7 @@ fn test_read_and_block() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -1625,7 +1625,7 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n@@ -1639,7 +1639,7 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n@@ -1665,7 +1665,7 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client = (*io).udp_bind(client_addr).unwrap();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n@@ -1674,7 +1674,7 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n@@ -1702,7 +1702,7 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n                 let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n                 let msg = [1, .. 2048];\n@@ -1725,7 +1725,7 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io = Local::unsafe_borrow::<IoFactoryObject>();\n+                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n                 let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n                 let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n                 let mut total_bytes_recv = 0;\n@@ -1754,7 +1754,7 @@ fn test_udp_many_read() {\n fn test_timer_sleep_simple() {\n     do run_in_newsched_task {\n         unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n             let timer = (*io).timer_init();\n             do timer.map_move |mut t| { t.sleep(1) };\n         }"}, {"sha": "f121158d4c525cfe02254028531fb6bb0815bd9b", "filename": "src/libstd/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -60,7 +60,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n \n     do (|| {\n         let c = Cell::new(c.take());\n-        let sched = Local::take::<Scheduler>();\n+        let sched: ~Scheduler = Local::take();\n         do sched.deschedule_running_task_and_then |sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n "}, {"sha": "cb0753fb2e5dee4a45ea3a8d8bbbf871a3857a83", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -143,7 +143,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n         if in_green_task_context() {\n             // XXX: Logging doesn't work here - the check to call the log\n             // function never passes - so calling the log function directly.\n-            do Local::borrow::<Task, ()> |task| {\n+            do Local::borrow |task: &mut Task| {\n                 let msg = match task.name {\n                     Some(ref name) =>\n                     fmt!(\"task '%s' failed at '%s', %s:%i\",\n@@ -160,7 +160,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                      msg, file, line as int);\n         }\n \n-        let task = Local::unsafe_borrow::<Task>();\n+        let task: *mut Task = Local::unsafe_borrow();\n         if (*task).unwinder.unwinding {\n             rtabort!(\"unwinding again\");\n         }"}, {"sha": "2c2dfd8f689c2915cb59aa0a5a198273f27dd6a3", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -28,7 +28,7 @@ impl Handle {\n     pub fn new() -> Handle {\n         use rt::local::Local;\n         unsafe {\n-            let task = Local::unsafe_borrow::<Task>();\n+            let task: *mut Task = Local::unsafe_borrow();\n             NewHandle(&mut (*task).storage)\n         }\n     }"}, {"sha": "c0b331c52eeb0715412171f323aed79f7cda0cab", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -526,7 +526,7 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        do Local::borrow::<Task, U> |task| {\n+        do Local::borrow |task: &mut Task| {\n             match task.name {\n                 Some(ref name) => blk(Some(name.as_slice())),\n                 None => blk(None)\n@@ -545,7 +545,7 @@ pub fn deschedule() {\n \n     // FIXME #6842: What does yield really mean in newsched?\n     // FIXME(#7544): Optimize this, since we know we won't block.\n-    let sched = Local::take::<Scheduler>();\n+    let sched: ~Scheduler = Local::take();\n     do sched.deschedule_running_task_and_then |sched, task| {\n         sched.enqueue_blocked_task(task);\n     }\n@@ -556,7 +556,7 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    do Local::borrow::<Task, bool> |local| {\n+    do Local::borrow |local: &mut Task| {\n         local.unwinder.unwinding\n     }\n }\n@@ -582,7 +582,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n     unsafe {\n         if in_green_task_context() {\n             // The inhibits/allows might fail and need to borrow the task.\n-            let t = Local::unsafe_borrow::<Task>();\n+            let t: *mut Task = Local::unsafe_borrow();\n             do (|| {\n                 (*t).death.inhibit_kill((*t).unwinder.unwinding);\n                 f()\n@@ -616,7 +616,7 @@ pub fn rekillable<U>(f: &fn() -> U) -> U {\n \n     unsafe {\n         if in_green_task_context() {\n-            let t = Local::unsafe_borrow::<Task>();\n+            let t: *mut Task = Local::unsafe_borrow();\n             do (|| {\n                 (*t).death.allow_kill((*t).unwinder.unwinding);\n                 f()\n@@ -1032,7 +1032,7 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    do Local::borrow::<::rt::sched::Scheduler, int> |sched| {\n+    do Local::borrow |sched: &mut ::rt::sched::Scheduler| {\n         sched.sched_id() as int\n     }\n }"}, {"sha": "c3a3dc56ce2330de23a04374d359a7de753b0148", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -449,7 +449,7 @@ impl RuntimeGlue {\n     fn kill_task(mut handle: KillHandle) {\n         do handle.kill().map_move |killed_task| {\n             let killed_task = Cell::new(killed_task);\n-            do Local::borrow::<Scheduler, ()> |sched| {\n+            do Local::borrow |sched: &mut Scheduler| {\n                 sched.enqueue_task(killed_task.take());\n             }\n         };\n@@ -460,7 +460,7 @@ impl RuntimeGlue {\n         unsafe {\n             // Can't use safe borrow, because the taskgroup destructor needs to\n             // access the scheduler again to send kill signals to other tasks.\n-            let me = Local::unsafe_borrow::<Task>();\n+            let me: *mut Task = Local::unsafe_borrow();\n             blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n         }\n     }\n@@ -470,7 +470,7 @@ impl RuntimeGlue {\n         unsafe {\n             // Can't use safe borrow, because creating new hashmaps for the\n             // tasksets requires an rng, which needs to borrow the sched.\n-            let me = Local::unsafe_borrow::<Task>();\n+            let me: *mut Task = Local::unsafe_borrow();\n             blk(match (*me).taskgroup {\n                 None => {\n                     // First task in its (unlinked/unsupervised) taskgroup.\n@@ -574,7 +574,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n         // If child data is 'None', the enlist is vacuously successful.\n         let enlist_success = do child_data.take().map_move_default(true) |child_data| {\n             let child_data = Cell::new(child_data); // :(\n-            do Local::borrow::<Task, bool> |me| {\n+            do Local::borrow |me: &mut Task| {\n                 let (child_tg, ancestors) = child_data.take();\n                 let mut ancestors = ancestors;\n                 let handle = me.death.kill_handle.get_ref();\n@@ -608,7 +608,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     } else {\n         unsafe {\n             // Creating a 1:1 task:thread ...\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n+            let sched: *mut Scheduler = Local::unsafe_borrow();\n             let sched_handle = (*sched).make_handle();\n \n             // Since this is a 1:1 scheduler we create a queue not in"}, {"sha": "5d9ca6202e26293b47fef8cf4e0b26c6ec35a73c", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -176,7 +176,7 @@ macro_rules! tuple_impls {\n                 impl<$($T:Zero),+> Zero for ($($T,)+) {\n                     #[inline]\n                     fn zero() -> ($($T,)+) {\n-                        ($(Zero::zero::<$T>(),)+)\n+                        ($({ let x: $T = Zero::zero(); x},)+)\n                     }\n                     #[inline]\n                     fn is_zero(&self) -> bool {"}, {"sha": "f9380e7ad1241fd2f6bf7c3bc9c99d51218a2e9b", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -538,7 +538,8 @@ mod test {\n \n     #[test]\n     fn option_empty() {\n-        assert!(AtomicOption::empty::<()>().is_empty(SeqCst));\n+        let mut option: AtomicOption<()> = AtomicOption::empty();\n+        assert!(option.is_empty(SeqCst));\n     }\n \n     #[test]"}, {"sha": "1d839b55195be9c7bc436d1d001238b69f70bc54", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -13,7 +13,7 @@\n use c_str::ToCStr;\n use cast::transmute;\n use libc::{c_char, c_void, size_t, uintptr_t};\n-use option::{Some, None};\n+use option::{Option, None, Some};\n use sys;\n use rt::task::Task;\n use rt::local::Local;\n@@ -37,7 +37,8 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n #[lang=\"malloc\"]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     // XXX: Unsafe borrow for speed. Lame.\n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task {\n         Some(task) => {\n             (*task).heap.alloc(td as *c_void, size as uint) as *c_char\n         }"}, {"sha": "8d1545ea2b4506061f8c1d1c48c3bf2b3af34a3b", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -279,7 +279,8 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n-    match Local::try_unsafe_borrow::<Task>() {\n+    let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n+    match task_opt {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {"}, {"sha": "44015a8b443f092b899f7102beb53f48ffbca9f8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -174,12 +174,16 @@ impl Generics {\n     }\n }\n \n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+pub enum MethodProvenance {\n+    FromTrait(def_id),\n+    FromImpl(def_id),\n+}\n+\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum def {\n     def_fn(def_id, purity),\n-    def_static_method(/* method */ def_id,\n-                      /* trait */  Option<def_id>,\n-                      purity),\n+    def_static_method(/* method */ def_id, MethodProvenance, purity),\n     def_self(NodeId),\n     def_self_ty(/* trait id */ NodeId),\n     def_mod(def_id),\n@@ -716,7 +720,7 @@ impl ToStr for float_ty {\n }\n \n // NB Eq method appears below.\n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Ty {\n     id: NodeId,\n     node: ty_,"}, {"sha": "21d67493cbffb9049e9384782f89a0afc0d10c30", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -74,6 +74,13 @@ pub trait AstBuilder {\n     // statements\n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n     fn stmt_let(&self, sp: span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+    fn stmt_let_typed(&self,\n+                      sp: span,\n+                      mutbl: bool,\n+                      ident: ast::ident,\n+                      typ: ast::Ty,\n+                      ex: @ast::expr)\n+                      -> @ast::stmt;\n \n     // blocks\n     fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::Block;\n@@ -241,8 +248,8 @@ impl AstBuilder for @ExtCtxt {\n                 types: ~[ast::Ty])\n                 -> ast::Path {\n         let last_identifier = idents.pop();\n-        let mut segments: ~[ast::PathSegment] = idents.consume_iter()\n-                                                      .transform(|ident| {\n+        let mut segments: ~[ast::PathSegment] = idents.move_iter()\n+                                                      .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n                 lifetime: None,\n@@ -400,6 +407,26 @@ impl AstBuilder for @ExtCtxt {\n         @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n     }\n \n+    fn stmt_let_typed(&self,\n+                      sp: span,\n+                      mutbl: bool,\n+                      ident: ast::ident,\n+                      typ: ast::Ty,\n+                      ex: @ast::expr)\n+                      -> @ast::stmt {\n+        let pat = self.pat_ident(sp, ident);\n+        let local = @ast::Local {\n+            is_mutbl: mutbl,\n+            ty: typ,\n+            pat: pat,\n+            init: Some(ex),\n+            id: self.next_id(),\n+            span: sp,\n+        };\n+        let decl = respan(sp, ast::decl_local(local));\n+        @respan(sp, ast::stmt_decl(@decl, self.next_id()))\n+    }\n+\n     fn block(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@expr>) -> ast::Block {\n         self.block_all(span, ~[], stmts, expr)\n     }"}, {"sha": "9f86fe7d7f2c21cb60e70909a94e1f0e267ea9c9", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -76,24 +76,34 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n \n             let variant_count = cx.expr_uint(span, variants.len());\n \n-            // need to specify the uint-ness of the random number\n-            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n             let r_ty = cx.ty_ident(span, cx.ident_of(\"R\"));\n             let rand_name = cx.path_all(span,\n                                         true,\n                                         rand_ident.clone(),\n                                         None,\n-                                        ~[ uint_ty, r_ty ]);\n+                                        ~[]);\n             let rand_name = cx.expr_path(rand_name);\n \n-            // ::std::rand::Rand::rand::<uint>(rng)\n+            // ::std::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(span,\n                                        rand_name,\n                                        ~[ rng[0].duplicate(cx) ]);\n \n+            // need to specify the uint-ness of the random number\n+            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let value_ident = cx.ident_of(\"__value\");\n+            let let_statement = cx.stmt_let_typed(span,\n+                                                  false,\n+                                                  value_ident,\n+                                                  uint_ty,\n+                                                  rv_call);\n+\n             // rand() % variants.len()\n-            let rand_variant = cx.expr_binary(span, ast::rem,\n-                                              rv_call, variant_count);\n+            let value_ref = cx.expr_ident(span, value_ident);\n+            let rand_variant = cx.expr_binary(span,\n+                                              ast::rem,\n+                                              value_ref,\n+                                              variant_count);\n \n             let mut arms = do variants.iter().enumerate().map |(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n@@ -111,7 +121,10 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));\n \n-            cx.expr_match(span, rand_variant, arms)\n+            let match_expr = cx.expr_match(span, rand_variant, arms);\n+\n+            let block = cx.block(span, ~[ let_statement ], Some(match_expr));\n+            cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };"}, {"sha": "1a7fc558dcd29efe0cdeab4674890fb4ae9f6575", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -399,8 +399,8 @@ mod test {\n                                     types: ~[],\n                                 }\n                             ]\n-                        },\n-                        span: sp(0, 6))\n+                        }),\n+                    span: sp(0, 6)\n                    })\n     }\n "}, {"sha": "8ca858b7935eceedd2b818e4ee91469ea6e61bf6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -1374,7 +1374,7 @@ impl Parser {\n             _ => None,\n         };\n         match found {\n-            Some(INTERPOLATED(token::nt_path(path))) => {\n+            Some(INTERPOLATED(token::nt_path(~path))) => {\n                 return PathAndBounds {\n                     path: path,\n                     bounds: None,\n@@ -1483,7 +1483,7 @@ impl Parser {\n         let mut path_segments = ~[];\n         let mut bounds = None;\n         let last_segment_index = segments.len() - 1;\n-        for (i, segment_and_bounds) in segments.consume_iter().enumerate() {\n+        for (i, segment_and_bounds) in segments.move_iter().enumerate() {\n             let PathSegmentAndBoundSet {\n                 segment: segment,\n                 bound_set: bound_set\n@@ -4840,7 +4840,7 @@ impl Parser {\n             let path = ast::Path {\n                 span: mk_sp(lo, self.span.hi),\n                 global: false,\n-                segments: path.consume_iter().transform(|identifier| {\n+                segments: path.move_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n                         lifetime: None,\n@@ -4876,7 +4876,7 @@ impl Parser {\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n                         global: false,\n-                        segments: path.consume_iter().transform(|identifier| {\n+                        segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetime: None,\n@@ -4894,7 +4894,7 @@ impl Parser {\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n                         global: false,\n-                        segments: path.consume_iter().transform(|identifier| {\n+                        segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n                                 lifetime: None,\n@@ -4916,7 +4916,7 @@ impl Parser {\n         let path = ast::Path {\n             span: mk_sp(lo, self.span.hi),\n             global: false,\n-            segments: path.consume_iter().transform(|identifier| {\n+            segments: path.move_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n                     lifetime: None,"}, {"sha": "e5b7823ae44ecc9a5e1ae7335bd47b93829669a7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -320,7 +320,7 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n \n pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     for segment in path.segments.iter() {\n-        for typ in path.types.iter() {\n+        for typ in segment.types.iter() {\n             visitor.visit_ty(typ, env.clone())\n         }\n     }"}, {"sha": "e4833345d311c0c8e11b868704235dbbe78ff9a6", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -0,0 +1,37 @@\n+#[no_std];\n+\n+struct S<T> {\n+    contents: T,\n+}\n+\n+impl<T> S<T> {\n+    fn new<U>(x: T, _: U) -> S<T> {\n+        S {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+trait Trait<T> {\n+    fn new<U>(x: T, y: U) -> Self;\n+}\n+\n+struct S2 {\n+    contents: int,\n+}\n+\n+impl Trait<int> for S2 {\n+    fn new<U>(x: int, _: U) -> S2 {\n+        S2 {\n+            contents: x,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let _ = S::new::<int,float>(1, 1.0);    //~ ERROR the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _ = S::<'self,int>::new::<float>(1, 1.0);  //~ ERROR this impl has no lifetime parameter\n+    let _: S2 = Trait::new::<int,float>(1, 1.0);    //~ ERROR the trait referenced by this path has 1 type parameter, but 0 type parameters were supplied\n+    let _: S2 = Trait::<'self,int>::new::<float>(1, 1.0);   //~ ERROR this trait has no lifetime parameter\n+}\n+"}, {"sha": "3f1172b6de8f61c7e8244b8c8e823adbb94c63f7", "filename": "src/test/compile-fail/issue-4096.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b6314c39bfc13b5a41c53f13c3fafa7ad91e062/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4096.rs?ref=3b6314c39bfc13b5a41c53f13c3fafa7ad91e062", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub trait Nummy {\n-    fn from_inty<T>() -> Self;\n-}\n-\n-impl Nummy for float {\n-    fn from_inty<T>() -> float { 0.0 }\n-}\n-\n-fn main() {\n-    let _1:float = Nummy::from_inty::<int>();  //~ ERROR not enough type\n-    //~^ NOTE Static methods have an extra implicit type parameter\n-}"}, {"sha": "e60fbf4fc49a8c4904438b5eacd07be55db4943c", "filename": "src/test/compile-fail/prim-with-args.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -23,17 +23,17 @@ let x: u64<int>; //~ ERROR type parameters are not allowed on this type\n let x: float<int>; //~ ERROR type parameters are not allowed on this type\n let x: char<int>; //~ ERROR type parameters are not allowed on this type\n \n-let x: int<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i8<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i16<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i32<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: i64<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: uint<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u8<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u16<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u32<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: u64<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: float<'static>; //~ ERROR region parameters are not allowed on this type\n-let x: char<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: int<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: i64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: uint<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u8<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u16<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u32<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: u64<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: float<'static>; //~ ERROR lifetime parameters are not allowed on this type\n+let x: char<'static>; //~ ERROR lifetime parameters are not allowed on this type\n \n }"}, {"sha": "ab365c1bf6fb38ced9cd18e02a886fd21b69bf96", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -25,8 +25,4 @@ fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     //~^ ERROR cannot infer an appropriate lifetime\n }\n \n-fn a_fn4<'a,'b>() {\n-    let _: int<'a> = 1; //~ ERROR region parameters are not allowed on this type\n-}\n-\n fn main() { }"}, {"sha": "b637037f60e8f6167e9a3a8c415d36cf4bd6cfc0", "filename": "src/test/compile-fail/static-method-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -6,5 +6,5 @@ mod a {\n }\n \n fn main() {\n-    let _ = a::S::new();    //~ ERROR function `new` is private\n+    let _ = a::S::new();    //~ ERROR method `new` is private\n }"}, {"sha": "f320de39c8c3b2fb762e648e1d5cd6ba7707d129", "filename": "src/test/run-pass/borrowck-pat-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-pat-enum.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -1,3 +1,5 @@\n+// xfail-pretty\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "aba23e53282c788e7a4902ca5b3c54fc5a644e87", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -36,5 +36,6 @@ struct Lots {\n }\n \n fn main() {\n-    assert!(Zero::zero::<Lots>().is_zero());\n+    let lots: Lots = Zero::zero();\n+    assert!(lots.is_zero());\n }"}, {"sha": "d59b8c77d006701d7348f48e467ace828521c629", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -13,11 +13,12 @@ extern mod extra;\n use std::num::Float;\n \n pub fn main() {\n-  let nan = Float::NaN::<float>();\n+  let nan: float = Float::NaN();\n   assert!((nan).is_NaN());\n \n-  let inf = Float::infinity::<float>();\n-  assert_eq!(-inf, Float::neg_infinity::<float>());\n+  let inf: float = Float::infinity();\n+  let neg_inf: float = Float::neg_infinity();\n+  assert_eq!(-inf, neg_inf);\n \n   assert!( nan !=  nan);\n   assert!( nan != -nan);"}, {"sha": "1bc37a035e046d98ffd8353b28a7f0a55119db6f", "filename": "src/test/run-pass/mid-path-type-params.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmid-path-type-params.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -10,7 +10,24 @@ impl<T> S<T> {\n     }\n }\n \n+trait Trait<T> {\n+    fn new<U>(x: T, y: U) -> Self;\n+}\n+\n+struct S2 {\n+    contents: int,\n+}\n+\n+impl Trait<int> for S2 {\n+    fn new<U>(x: int, _: U) -> S2 {\n+        S2 {\n+            contents: x,\n+        }\n+    }\n+}\n+\n fn main() {\n     let _ = S::<int>::new::<float>(1, 1.0);\n+    let _: S2 = Trait::<int>::new::<float>(1, 1.0);\n }\n "}, {"sha": "baf4cf45b3ce8aa1f996ed7d1842990f9fbd215d", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -59,7 +59,7 @@ fn main () {\n \n     assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n     assert_eq!(B::staticthing(&0i, 3.14, 1), (3.14, 1));\n-    assert_eq!(B::staticthing::<float, int, int>(&0i, 3.14, 1), (3.14, 1));\n+    assert_eq!(B::<float>::staticthing::<int>(&0i, 3.14, 1), (3.14, 1));\n \n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));"}, {"sha": "5ac26e65d888010bb94b9e5f9eb4e98b2ad283a4", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8693943676487c01fa09f5f3daf0df6a1f71e24d/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=8693943676487c01fa09f5f3daf0df6a1f71e24d", "patch": "@@ -14,7 +14,7 @@ mod base {\n     use std::io;\n \n     pub trait HasNew<T> {\n-        fn new() -> T;\n+        fn new() -> Self;\n     }\n \n     pub struct Foo {\n@@ -41,6 +41,6 @@ mod base {\n }\n \n pub fn main() {\n-    let _f: base::Foo = base::HasNew::new::<base::Foo, base::Foo>();\n-    let _b: base::Bar = base::HasNew::new::<base::Bar, base::Bar>();\n+    let _f: base::Foo = base::HasNew::<base::Foo>::new();\n+    let _b: base::Bar = base::HasNew::<base::Bar>::new();\n }"}]}