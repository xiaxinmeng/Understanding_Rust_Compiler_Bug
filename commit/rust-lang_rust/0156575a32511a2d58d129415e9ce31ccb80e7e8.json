{"sha": "0156575a32511a2d58d129415e9ce31ccb80e7e8", "node_id": "C_kwDOAAsO6NoAKDAxNTY1NzVhMzI1MTFhMmQ1OGQxMjk0MTVlOWNlMzFjY2I4MGU3ZTg", "commit": {"author": {"name": "Yacin Tmimi", "email": "yacintmimi@gmail.com", "date": "2022-06-22T17:36:01Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2022-06-22T22:45:42Z"}, "message": "Revert \"Memoize format_expr\"\n\nFixes 5399\n\nMemoizing expressions lead to cases where rustfmt's stability guarantees\nwere violated.\n\nThis reverts commit a37d3ab0e1c7c05f1a6410fb7ddf5539f0d030f8.", "tree": {"sha": "00fefc5bff84e87666eddce9bc8a7b5f75c8cc8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00fefc5bff84e87666eddce9bc8a7b5f75c8cc8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0156575a32511a2d58d129415e9ce31ccb80e7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0156575a32511a2d58d129415e9ce31ccb80e7e8", "html_url": "https://github.com/rust-lang/rust/commit/0156575a32511a2d58d129415e9ce31ccb80e7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0156575a32511a2d58d129415e9ce31ccb80e7e8/comments", "author": {"login": "ytmimi", "id": 29028348, "node_id": "MDQ6VXNlcjI5MDI4MzQ4", "avatar_url": "https://avatars.githubusercontent.com/u/29028348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ytmimi", "html_url": "https://github.com/ytmimi", "followers_url": "https://api.github.com/users/ytmimi/followers", "following_url": "https://api.github.com/users/ytmimi/following{/other_user}", "gists_url": "https://api.github.com/users/ytmimi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ytmimi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ytmimi/subscriptions", "organizations_url": "https://api.github.com/users/ytmimi/orgs", "repos_url": "https://api.github.com/users/ytmimi/repos", "events_url": "https://api.github.com/users/ytmimi/events{/privacy}", "received_events_url": "https://api.github.com/users/ytmimi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c8b3bef2bb5d708e047afc4d0dadf0a85528470", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8b3bef2bb5d708e047afc4d0dadf0a85528470", "html_url": "https://github.com/rust-lang/rust/commit/2c8b3bef2bb5d708e047afc4d0dadf0a85528470"}], "stats": {"total": 11458, "additions": 4, "deletions": 11454}, "files": [{"sha": "e4cc93026f10bb552b89514ce87d5098d87352ed", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0156575a32511a2d58d129415e9ce31ccb80e7e8", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::cmp::min;\n-use std::collections::HashMap;\n \n use itertools::Itertools;\n use rustc_ast::token::{Delimiter, LitKind};\n@@ -23,7 +22,7 @@ use crate::macros::{rewrite_macro, MacroPosition};\n use crate::matches::rewrite_match;\n use crate::overflow::{self, IntoOverflowableItem, OverflowableItem};\n use crate::pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n-use crate::rewrite::{QueryId, Rewrite, RewriteContext};\n+use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n@@ -54,54 +53,6 @@ pub(crate) fn format_expr(\n     expr_type: ExprType,\n     context: &RewriteContext<'_>,\n     shape: Shape,\n-) -> Option<String> {\n-    // when max_width is tight, we should check all possible formattings, in order to find\n-    // if we can fit expression in the limit. Doing it recursively takes exponential time\n-    // relative to input size, and people hit it with rustfmt takes minutes in #4476 #4867 #5128\n-    // By memoization of format_expr function, we format each pair of expression and shape\n-    // only once, so worst case execution time becomes O(n*max_width^3).\n-    if context.inside_macro() || context.is_macro_def {\n-        // span ids are not unique in macros, so we don't memoize result of them.\n-        return format_expr_inner(expr, expr_type, context, shape);\n-    }\n-    let clean;\n-    let query_id = QueryId {\n-        shape,\n-        span: expr.span,\n-    };\n-    if let Some(map) = context.memoize.take() {\n-        if let Some(r) = map.get(&query_id) {\n-            let r = r.clone();\n-            context.memoize.set(Some(map)); // restore map in the memoize cell for other users\n-            return r;\n-        }\n-        context.memoize.set(Some(map));\n-        clean = false;\n-    } else {\n-        context.memoize.set(Some(HashMap::default()));\n-        clean = true; // We got None, so we are the top level called function. When\n-        // this function finishes, no one is interested in what is in the map, because\n-        // all of them are sub expressions of this top level expression, and this is\n-        // done. So we should clean up memoize map to save some memory.\n-    }\n-\n-    let r = format_expr_inner(expr, expr_type, context, shape);\n-    if clean {\n-        context.memoize.set(None);\n-    } else {\n-        if let Some(mut map) = context.memoize.take() {\n-            map.insert(query_id, r.clone()); // insert the result in the memoize map\n-            context.memoize.set(Some(map)); // so it won't be computed again\n-        }\n-    }\n-    r\n-}\n-\n-fn format_expr_inner(\n-    expr: &ast::Expr,\n-    expr_type: ExprType,\n-    context: &RewriteContext<'_>,\n-    shape: Shape,\n ) -> Option<String> {\n     skip_out_of_file_lines_range!(context, expr.span);\n "}, {"sha": "1dfd8a514f0bcc0994cc590cbf45a0c1f9064019", "filename": "src/formatting.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=0156575a32511a2d58d129415e9ce31ccb80e7e8", "patch": "@@ -2,7 +2,6 @@\n \n use std::collections::HashMap;\n use std::io::{self, Write};\n-use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n@@ -203,7 +202,6 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             self.config,\n             &snippet_provider,\n             self.report.clone(),\n-            Rc::default(),\n         );\n         visitor.skip_context.update_with_attrs(&self.krate.attrs);\n         visitor.is_macro_def = is_macro_def;"}, {"sha": "4a3bd129d16f5ad62b017f0ba277c87c8a80968d", "filename": "src/rewrite.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=0156575a32511a2d58d129415e9ce31ccb80e7e8", "patch": "@@ -12,7 +12,6 @@ use crate::shape::Shape;\n use crate::skip::SkipContext;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n-use rustc_data_structures::stable_map::FxHashMap;\n \n pub(crate) trait Rewrite {\n     /// Rewrite self into shape.\n@@ -25,22 +24,10 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct QueryId {\n-    pub(crate) shape: Shape,\n-    pub(crate) span: Span,\n-}\n-\n-// We use Option<HashMap> instead of HashMap, because in case of `None`\n-// the function clean the memoize map, but it doesn't clean when\n-// there is `Some(empty)`, so they are different.\n-pub(crate) type Memoize = Rc<Cell<Option<FxHashMap<QueryId, Option<String>>>>>;\n-\n #[derive(Clone)]\n pub(crate) struct RewriteContext<'a> {\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) config: &'a Config,\n-    pub(crate) memoize: Memoize,\n     pub(crate) inside_macro: Rc<Cell<bool>>,\n     // Force block indent style even if we are using visual indent style.\n     pub(crate) use_block: Cell<bool>,"}, {"sha": "4376fd12b526005706f526bcc3252446f8cf74c0", "filename": "src/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=0156575a32511a2d58d129415e9ce31ccb80e7e8", "patch": "@@ -4,7 +4,7 @@ use std::ops::{Add, Sub};\n \n use crate::Config;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n     // Config::tab_spaces.\n@@ -139,7 +139,7 @@ impl Sub<usize> for Indent {\n // 8096 is close enough to infinite for rustfmt.\n const INFINITE_SHAPE_WIDTH: usize = 8096;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) struct Shape {\n     pub(crate) width: usize,\n     // The current indentation of code."}, {"sha": "9a0e0752c12f5ed3ec755a389ac1cd696a647fd5", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0156575a32511a2d58d129415e9ce31ccb80e7e8/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=0156575a32511a2d58d129415e9ce31ccb80e7e8", "patch": "@@ -17,7 +17,7 @@ use crate::items::{\n use crate::macros::{macro_style, rewrite_macro, rewrite_macro_def, MacroPosition};\n use crate::modules::Module;\n use crate::parse::session::ParseSess;\n-use crate::rewrite::{Memoize, Rewrite, RewriteContext};\n+use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n@@ -71,7 +71,6 @@ impl SnippetProvider {\n \n pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n-    pub(crate) memoize: Memoize,\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) buffer: String,\n     pub(crate) last_pos: BytePos,\n@@ -759,7 +758,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ctx.config,\n             ctx.snippet_provider,\n             ctx.report.clone(),\n-            ctx.memoize.clone(),\n         );\n         visitor.skip_context.update(ctx.skip_context.clone());\n         visitor.set_parent_context(ctx);\n@@ -771,12 +769,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         config: &'a Config,\n         snippet_provider: &'a SnippetProvider,\n         report: FormatReport,\n-        memoize: Memoize,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parent_context: None,\n             parse_sess: parse_session,\n-            memoize,\n             buffer: String::with_capacity(snippet_provider.big_snippet.len() * 2),\n             last_pos: BytePos(0),\n             block_indent: Indent::empty(),\n@@ -999,7 +995,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         RewriteContext {\n             parse_sess: self.parse_sess,\n             config: self.config,\n-            memoize: self.memoize.clone(),\n             inside_macro: Rc::new(Cell::new(false)),\n             use_block: Cell::new(false),\n             is_if_else_block: Cell::new(false),"}, {"sha": "8da3f19b62d6004b3faf6439f65dec1bc07a0b7d", "filename": "tests/source/performance/issue-4476.rs", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Fsource%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Fsource%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fperformance%2Fissue-4476.rs?ref=2c8b3bef2bb5d708e047afc4d0dadf0a85528470", "patch": "@@ -1,638 +0,0 @@\n-use super::SemverParser;\n-\n-#[allow(dead_code, non_camel_case_types)]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Rule {\n-  EOI,\n-  range_set,\n-  logical_or,\n-  range,\n-  empty,\n-  hyphen,\n-  simple,\n-  primitive,\n-  primitive_op,\n-  partial,\n-  xr,\n-  xr_op,\n-  nr,\n-  tilde,\n-  caret,\n-  qualifier,\n-  parts,\n-  part,\n-  space,\n-}\n-#[allow(clippy::all)]\n-impl ::pest::Parser<Rule> for SemverParser {\n-  fn parse<'i>(\n-    rule: Rule,\n-    input: &'i str,\n-  ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n-    mod rules {\n-      pub mod hidden {\n-        use super::super::Rule;\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn skip(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          Ok(state)\n-        }\n-      }\n-      pub mod visible {\n-        use super::super::Rule;\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn range_set(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::range_set, |state| {\n-            state.sequence(|state| {\n-              self::SOI(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::range(state))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      state\n-                        .sequence(|state| {\n-                          self::logical_or(state)\n-                            .and_then(|state| super::hidden::skip(state))\n-                            .and_then(|state| self::range(state))\n-                        })\n-                        .and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state).and_then(|state| {\n-                                state.sequence(|state| {\n-                                  self::logical_or(state)\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| self::range(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::EOI(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn logical_or(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::logical_or, |state| {\n-            state.sequence(|state| {\n-              state\n-                .sequence(|state| {\n-                  state.optional(|state| {\n-                    self::space(state).and_then(|state| {\n-                      state.repeat(|state| {\n-                        state.sequence(|state| {\n-                          super::hidden::skip(state).and_then(|state| self::space(state))\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| state.match_string(\"||\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn range(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::range, |state| {\n-            self::hyphen(state)\n-              .or_else(|state| {\n-                state.sequence(|state| {\n-                  self::simple(state)\n-                    .and_then(|state| super::hidden::skip(state))\n-                    .and_then(|state| {\n-                      state.sequence(|state| {\n-                        state.optional(|state| {\n-                          state\n-                            .sequence(|state| {\n-                              state\n-                                .optional(|state| state.match_string(\",\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                  state.sequence(|state| {\n-                                    self::space(state)\n-                                      .and_then(|state| super::hidden::skip(state))\n-                                      .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                          state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                              state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                  super::hidden::skip(state)\n-                                                    .and_then(|state| self::space(state))\n-                                                })\n-                                              })\n-                                            })\n-                                          })\n-                                        })\n-                                      })\n-                                  })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::simple(state))\n-                            })\n-                            .and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| {\n-                                    state.sequence(|state| {\n-                                      state\n-                                        .optional(|state| state.match_string(\",\"))\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                          state.sequence(|state| {\n-                                            self::space(state)\n-                                              .and_then(|state| super::hidden::skip(state))\n-                                              .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                  state.optional(|state| {\n-                                                    self::space(state).and_then(|state| {\n-                                                      state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                          super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                        })\n-                                                      })\n-                                                    })\n-                                                  })\n-                                                })\n-                                              })\n-                                          })\n-                                        })\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| self::simple(state))\n-                                    })\n-                                  })\n-                                })\n-                              })\n-                            })\n-                        })\n-                      })\n-                    })\n-                })\n-              })\n-              .or_else(|state| self::empty(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn empty(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::empty, |state| state.match_string(\"\"))\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn hyphen(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::hyphen, |state| {\n-            state.sequence(|state| {\n-              self::partial(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    self::space(state)\n-                      .and_then(|state| super::hidden::skip(state))\n-                      .and_then(|state| {\n-                        state.sequence(|state| {\n-                          state.optional(|state| {\n-                            self::space(state).and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| self::space(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                      })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| state.match_string(\"-\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    self::space(state)\n-                      .and_then(|state| super::hidden::skip(state))\n-                      .and_then(|state| {\n-                        state.sequence(|state| {\n-                          state.optional(|state| {\n-                            self::space(state).and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| self::space(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                      })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn simple(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::simple, |state| {\n-            self::primitive(state)\n-              .or_else(|state| self::partial(state))\n-              .or_else(|state| self::tilde(state))\n-              .or_else(|state| self::caret(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn primitive(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::primitive, |state| {\n-            state.sequence(|state| {\n-              self::primitive_op(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn primitive_op(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::primitive_op, |state| {\n-            state\n-              .match_string(\"<=\")\n-              .or_else(|state| state.match_string(\">=\"))\n-              .or_else(|state| state.match_string(\">\"))\n-              .or_else(|state| state.match_string(\"<\"))\n-              .or_else(|state| state.match_string(\"=\"))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn partial(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::partial, |state| {\n-            state.sequence(|state| {\n-              self::xr(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.optional(|state| {\n-                    state.sequence(|state| {\n-                      state\n-                        .match_string(\".\")\n-                        .and_then(|state| super::hidden::skip(state))\n-                        .and_then(|state| self::xr(state))\n-                        .and_then(|state| super::hidden::skip(state))\n-                        .and_then(|state| {\n-                          state.optional(|state| {\n-                            state.sequence(|state| {\n-                              state\n-                                .match_string(\".\")\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::xr(state))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn xr(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::xr, |state| {\n-            self::xr_op(state).or_else(|state| self::nr(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn xr_op(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::xr_op, |state| {\n-            state\n-              .match_string(\"x\")\n-              .or_else(|state| state.match_string(\"X\"))\n-              .or_else(|state| state.match_string(\"*\"))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn nr(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::nr, |state| {\n-            state.match_string(\"0\").or_else(|state| {\n-              state.sequence(|state| {\n-                state\n-                  .match_range('1'..'9')\n-                  .and_then(|state| super::hidden::skip(state))\n-                  .and_then(|state| {\n-                    state.sequence(|state| {\n-                      state.optional(|state| {\n-                        state.match_range('0'..'9').and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state)\n-                                .and_then(|state| state.match_range('0'..'9'))\n-                            })\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-              })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn tilde(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::tilde, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"~>\")\n-                .or_else(|state| state.match_string(\"~\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn caret(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::caret, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"^\")\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn qualifier(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::qualifier, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"-\")\n-                .or_else(|state| state.match_string(\"+\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::parts(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn parts(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::parts, |state| {\n-            state.sequence(|state| {\n-              self::part(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      state\n-                        .sequence(|state| {\n-                          state\n-                            .match_string(\".\")\n-                            .and_then(|state| super::hidden::skip(state))\n-                            .and_then(|state| self::part(state))\n-                        })\n-                        .and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state).and_then(|state| {\n-                                state.sequence(|state| {\n-                                  state\n-                                    .match_string(\".\")\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| self::part(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn part(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::part, |state| {\n-            self::nr(state).or_else(|state| {\n-              state.sequence(|state| {\n-                state\n-                  .match_string(\"-\")\n-                  .or_else(|state| state.match_range('0'..'9'))\n-                  .or_else(|state| state.match_range('A'..'Z'))\n-                  .or_else(|state| state.match_range('a'..'z'))\n-                  .and_then(|state| super::hidden::skip(state))\n-                  .and_then(|state| {\n-                    state.sequence(|state| {\n-                      state.optional(|state| {\n-                        state\n-                          .match_string(\"-\")\n-                          .or_else(|state| state.match_range('0'..'9'))\n-                          .or_else(|state| state.match_range('A'..'Z'))\n-                          .or_else(|state| state.match_range('a'..'z'))\n-                          .and_then(|state| {\n-                            state.repeat(|state| {\n-                              state.sequence(|state| {\n-                                super::hidden::skip(state).and_then(|state| {\n-                                  state\n-                                    .match_string(\"-\")\n-                                    .or_else(|state| state.match_range('0'..'9'))\n-                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                    .or_else(|state| state.match_range('a'..'z'))\n-                                })\n-                              })\n-                            })\n-                          })\n-                      })\n-                    })\n-                  })\n-              })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn space(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state\n-            .match_string(\" \")\n-            .or_else(|state| state.match_string(\"\\t\"))\n-        }\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn EOI(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::EOI, |state| state.end_of_input())\n-        }\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn SOI(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.start_of_input()\n-        }\n-      }\n-      pub use self::visible::*;\n-    }\n-    ::pest::state(input, |state| match rule {\n-      Rule::range_set => rules::range_set(state),\n-      Rule::logical_or => rules::logical_or(state),\n-      Rule::range => rules::range(state),\n-      Rule::empty => rules::empty(state),\n-      Rule::hyphen => rules::hyphen(state),\n-      Rule::simple => rules::simple(state),\n-      Rule::primitive => rules::primitive(state),\n-      Rule::primitive_op => rules::primitive_op(state),\n-      Rule::partial => rules::partial(state),\n-      Rule::xr => rules::xr(state),\n-      Rule::xr_op => rules::xr_op(state),\n-      Rule::nr => rules::nr(state),\n-      Rule::tilde => rules::tilde(state),\n-      Rule::caret => rules::caret(state),\n-      Rule::qualifier => rules::qualifier(state),\n-      Rule::parts => rules::parts(state),\n-      Rule::part => rules::part(state),\n-      Rule::space => rules::space(state),\n-      Rule::EOI => rules::EOI(state),\n-    })\n-  }\n-}\n\\ No newline at end of file"}, {"sha": "3adce49601c0ca0805daed8cba5dc8e7edcf118e", "filename": "tests/source/performance/issue-5128.rs", "status": "removed", "additions": 0, "deletions": 5127, "changes": 5127, "blob_url": "https://github.com/rust-lang/rust/blob/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Fsource%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Fsource%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fperformance%2Fissue-5128.rs?ref=2c8b3bef2bb5d708e047afc4d0dadf0a85528470"}, {"sha": "30567f2644b749bb019da54f7b36f938c8fcd78e", "filename": "tests/target/performance/issue-4476.rs", "status": "removed", "additions": 0, "deletions": 705, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-4476.rs?ref=2c8b3bef2bb5d708e047afc4d0dadf0a85528470", "patch": "@@ -1,705 +0,0 @@\n-use super::SemverParser;\n-\n-#[allow(dead_code, non_camel_case_types)]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Rule {\n-    EOI,\n-    range_set,\n-    logical_or,\n-    range,\n-    empty,\n-    hyphen,\n-    simple,\n-    primitive,\n-    primitive_op,\n-    partial,\n-    xr,\n-    xr_op,\n-    nr,\n-    tilde,\n-    caret,\n-    qualifier,\n-    parts,\n-    part,\n-    space,\n-}\n-#[allow(clippy::all)]\n-impl ::pest::Parser<Rule> for SemverParser {\n-    fn parse<'i>(\n-        rule: Rule,\n-        input: &'i str,\n-    ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n-        mod rules {\n-            pub mod hidden {\n-                use super::super::Rule;\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn skip(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    Ok(state)\n-                }\n-            }\n-            pub mod visible {\n-                use super::super::Rule;\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn range_set(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::range_set, |state| {\n-                        state.sequence(|state| {\n-                            self::SOI(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::range(state))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            state\n-                                                .sequence(|state| {\n-                                                    self::logical_or(state)\n-                                                        .and_then(|state| {\n-                                                            super::hidden::skip(state)\n-                                                        })\n-                                                        .and_then(|state| self::range(state))\n-                                                })\n-                                                .and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| {\n-                                                                    state.sequence(|state| {\n-                                                                        self::logical_or(state)\n-                                                                            .and_then(|state| {\n-                                                                                super::hidden::skip(\n-                                                                                    state,\n-                                                                                )\n-                                                                            })\n-                                                                            .and_then(|state| {\n-                                                                                self::range(state)\n-                                                                            })\n-                                                                    })\n-                                                                },\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::EOI(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn logical_or(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::logical_or, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .sequence(|state| {\n-                                    state.optional(|state| {\n-                                        self::space(state).and_then(|state| {\n-                                            state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                    super::hidden::skip(state)\n-                                                        .and_then(|state| self::space(state))\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.match_string(\"||\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn range(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::range, |state| {\n-                        self::hyphen(state)\n-                            .or_else(|state| {\n-                                state.sequence(|state| {\n-                                    self::simple(state)\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                            state.sequence(|state| {\n-                                                state.optional(|state| {\n-                                                    state\n-                                                        .sequence(|state| {\n-                                                            state\n-                                                                .optional(|state| {\n-                                                                    state.match_string(\",\")\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    state.sequence(|state| {\n-                                                                        self::space(state)\n-                                      .and_then(|state| super::hidden::skip(state))\n-                                      .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                          state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                              state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                  super::hidden::skip(state)\n-                                                    .and_then(|state| self::space(state))\n-                                                })\n-                                              })\n-                                            })\n-                                          })\n-                                        })\n-                                      })\n-                                                                    })\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    self::simple(state)\n-                                                                })\n-                                                        })\n-                                                        .and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            state.sequence(\n-                                                                                |state| {\n-                                                                                    state\n-                                        .optional(|state| state.match_string(\",\"))\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                          state.sequence(|state| {\n-                                            self::space(state)\n-                                              .and_then(|state| super::hidden::skip(state))\n-                                              .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                  state.optional(|state| {\n-                                                    self::space(state).and_then(|state| {\n-                                                      state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                          super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                        })\n-                                                      })\n-                                                    })\n-                                                  })\n-                                                })\n-                                              })\n-                                          })\n-                                        })\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| self::simple(state))\n-                                                                                },\n-                                                                            )\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                })\n-                                            })\n-                                        })\n-                                })\n-                            })\n-                            .or_else(|state| self::empty(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn empty(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::empty, |state| state.match_string(\"\"))\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn hyphen(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::hyphen, |state| {\n-                        state.sequence(|state| {\n-                            self::partial(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        self::space(state)\n-                                            .and_then(|state| super::hidden::skip(state))\n-                                            .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                    state.optional(|state| {\n-                                                        self::space(state).and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            self::space(state)\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.match_string(\"-\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        self::space(state)\n-                                            .and_then(|state| super::hidden::skip(state))\n-                                            .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                    state.optional(|state| {\n-                                                        self::space(state).and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            self::space(state)\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn simple(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::simple, |state| {\n-                        self::primitive(state)\n-                            .or_else(|state| self::partial(state))\n-                            .or_else(|state| self::tilde(state))\n-                            .or_else(|state| self::caret(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn primitive(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::primitive, |state| {\n-                        state.sequence(|state| {\n-                            self::primitive_op(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn primitive_op(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::primitive_op, |state| {\n-                        state\n-                            .match_string(\"<=\")\n-                            .or_else(|state| state.match_string(\">=\"))\n-                            .or_else(|state| state.match_string(\">\"))\n-                            .or_else(|state| state.match_string(\"<\"))\n-                            .or_else(|state| state.match_string(\"=\"))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn partial(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::partial, |state| {\n-                        state.sequence(|state| {\n-                            self::xr(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.optional(|state| {\n-                                        state.sequence(|state| {\n-                                            state\n-                                                .match_string(\".\")\n-                                                .and_then(|state| super::hidden::skip(state))\n-                                                .and_then(|state| self::xr(state))\n-                                                .and_then(|state| super::hidden::skip(state))\n-                                                .and_then(|state| {\n-                                                    state.optional(|state| {\n-                                                        state.sequence(|state| {\n-                                                            state\n-                                                                .match_string(\".\")\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| self::xr(state))\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    state.optional(|state| {\n-                                                                        self::qualifier(state)\n-                                                                    })\n-                                                                })\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn xr(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::xr, |state| {\n-                        self::xr_op(state).or_else(|state| self::nr(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn xr_op(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::xr_op, |state| {\n-                        state\n-                            .match_string(\"x\")\n-                            .or_else(|state| state.match_string(\"X\"))\n-                            .or_else(|state| state.match_string(\"*\"))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn nr(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::nr, |state| {\n-                        state.match_string(\"0\").or_else(|state| {\n-                            state.sequence(|state| {\n-                                state\n-                                    .match_range('1'..'9')\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                            state.optional(|state| {\n-                                                state.match_range('0'..'9').and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| state.match_range('0'..'9'),\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                            })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn tilde(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::tilde, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"~>\")\n-                                .or_else(|state| state.match_string(\"~\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn caret(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::caret, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"^\")\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn qualifier(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::qualifier, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"-\")\n-                                .or_else(|state| state.match_string(\"+\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::parts(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn parts(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::parts, |state| {\n-                        state.sequence(|state| {\n-                            self::part(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            state\n-                                                .sequence(|state| {\n-                                                    state\n-                                                        .match_string(\".\")\n-                                                        .and_then(|state| {\n-                                                            super::hidden::skip(state)\n-                                                        })\n-                                                        .and_then(|state| self::part(state))\n-                                                })\n-                                                .and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| {\n-                                                                    state.sequence(|state| {\n-                                                                        state\n-                                                                            .match_string(\".\")\n-                                                                            .and_then(|state| {\n-                                                                                super::hidden::skip(\n-                                                                                    state,\n-                                                                                )\n-                                                                            })\n-                                                                            .and_then(|state| {\n-                                                                                self::part(state)\n-                                                                            })\n-                                                                    })\n-                                                                },\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn part(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::part, |state| {\n-                        self::nr(state).or_else(|state| {\n-                            state.sequence(|state| {\n-                                state\n-                                    .match_string(\"-\")\n-                                    .or_else(|state| state.match_range('0'..'9'))\n-                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                    .or_else(|state| state.match_range('a'..'z'))\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                            state.optional(|state| {\n-                                                state\n-                                                    .match_string(\"-\")\n-                                                    .or_else(|state| state.match_range('0'..'9'))\n-                                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                                    .or_else(|state| state.match_range('a'..'z'))\n-                                                    .and_then(|state| {\n-                                                        state.repeat(|state| {\n-                                                            state.sequence(|state| {\n-                                                                super::hidden::skip(state).and_then(\n-                                                                    |state| {\n-                                                                        state\n-                                                                            .match_string(\"-\")\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    '0'..'9',\n-                                                                                )\n-                                                                            })\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    'A'..'Z',\n-                                                                                )\n-                                                                            })\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    'a'..'z',\n-                                                                                )\n-                                                                            })\n-                                                                    },\n-                                                                )\n-                                                            })\n-                                                        })\n-                                                    })\n-                                            })\n-                                        })\n-                                    })\n-                            })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn space(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state\n-                        .match_string(\" \")\n-                        .or_else(|state| state.match_string(\"\\t\"))\n-                }\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn EOI(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::EOI, |state| state.end_of_input())\n-                }\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn SOI(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.start_of_input()\n-                }\n-            }\n-            pub use self::visible::*;\n-        }\n-        ::pest::state(input, |state| match rule {\n-            Rule::range_set => rules::range_set(state),\n-            Rule::logical_or => rules::logical_or(state),\n-            Rule::range => rules::range(state),\n-            Rule::empty => rules::empty(state),\n-            Rule::hyphen => rules::hyphen(state),\n-            Rule::simple => rules::simple(state),\n-            Rule::primitive => rules::primitive(state),\n-            Rule::primitive_op => rules::primitive_op(state),\n-            Rule::partial => rules::partial(state),\n-            Rule::xr => rules::xr(state),\n-            Rule::xr_op => rules::xr_op(state),\n-            Rule::nr => rules::nr(state),\n-            Rule::tilde => rules::tilde(state),\n-            Rule::caret => rules::caret(state),\n-            Rule::qualifier => rules::qualifier(state),\n-            Rule::parts => rules::parts(state),\n-            Rule::part => rules::part(state),\n-            Rule::space => rules::space(state),\n-            Rule::EOI => rules::EOI(state),\n-        })\n-    }\n-}"}, {"sha": "336dae1b64ab804be11155e53d1da099877e277b", "filename": "tests/target/performance/issue-4867.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-4867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-4867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-4867.rs?ref=2c8b3bef2bb5d708e047afc4d0dadf0a85528470", "patch": "@@ -1,13 +0,0 @@\n-mod modA {\n-    mod modB {\n-        mod modC {\n-            mod modD {\n-                mod modE {\n-                    fn func() {\n-                        state . rule (Rule :: myrule , | state | { state . sequence (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) }) }) }) }) }) }) }) }) });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "ba9ebfc6243f21f225639c0b0b7c32e9a3566a4a", "filename": "tests/target/performance/issue-5128.rs", "status": "removed", "additions": 0, "deletions": 4898, "changes": 4898, "blob_url": "https://github.com/rust-lang/rust/blob/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8b3bef2bb5d708e047afc4d0dadf0a85528470/tests%2Ftarget%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-5128.rs?ref=2c8b3bef2bb5d708e047afc4d0dadf0a85528470"}]}