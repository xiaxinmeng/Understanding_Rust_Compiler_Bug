{"sha": "0084195dee22d498291d92603d18f2f79946671f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwODQxOTVkZWUyMmQ0OTgyOTFkOTI2MDNkMThmMmY3OTk0NjY3MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-09T13:34:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-09T13:34:42Z"}, "message": "Auto merge of #7506 - HKalbasi:add-xor-swap, r=camsteffen\n\nAdd xor case to `manual swap` lint\n\nContinue of #7153\ncloses #6598\n\nchangelog: Add \"xor swap\" case to [`manual_swap`]", "tree": {"sha": "3711908560999d7f772eb88a18b098176a9dd93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3711908560999d7f772eb88a18b098176a9dd93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0084195dee22d498291d92603d18f2f79946671f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0084195dee22d498291d92603d18f2f79946671f", "html_url": "https://github.com/rust-lang/rust/commit/0084195dee22d498291d92603d18f2f79946671f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0084195dee22d498291d92603d18f2f79946671f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "176df7ca9a30d97e22a3b6ea5e5c6599ef931086", "url": "https://api.github.com/repos/rust-lang/rust/commits/176df7ca9a30d97e22a3b6ea5e5c6599ef931086", "html_url": "https://github.com/rust-lang/rust/commit/176df7ca9a30d97e22a3b6ea5e5c6599ef931086"}, {"sha": "6d36d1a835370a01cbee58aba038ea0bd712c82b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d36d1a835370a01cbee58aba038ea0bd712c82b", "html_url": "https://github.com/rust-lang/rust/commit/6d36d1a835370a01cbee58aba038ea0bd712c82b"}], "stats": {"total": 445, "additions": 307, "deletions": 138}, "files": [{"sha": "f126908e84b037716fcca1dfca70d532c6734e4c", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 101, "deletions": 115, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/0084195dee22d498291d92603d18f2f79946671f/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084195dee22d498291d92603d18f2f79946671f/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=0084195dee22d498291d92603d18f2f79946671f", "patch": "@@ -1,15 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, eq_expr_value};\n+use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, StmtKind};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -70,9 +71,67 @@ impl<'tcx> LateLintPass<'tcx> for Swap {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n+        check_xor_swap(cx, block);\n     }\n }\n \n+fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, span: Span, is_xor_based: bool) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    if !can_mut_borrow_both(cx, e1, e2) {\n+        if let ExprKind::Index(lhs1, idx1) = e1.kind {\n+            if let ExprKind::Index(lhs2, idx2) = e2.kind {\n+                if eq_expr_value(cx, lhs1, lhs2) {\n+                    let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n+\n+                    if matches!(ty.kind(), ty::Slice(_))\n+                        || matches!(ty.kind(), ty::Array(_, _))\n+                        || is_type_diagnostic_item(cx, ty, sym::vec_type)\n+                        || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+                    {\n+                        let slice = Sugg::hir_with_applicability(cx, lhs1, \"<slice>\", &mut applicability);\n+                        span_lint_and_sugg(\n+                            cx,\n+                            MANUAL_SWAP,\n+                            span,\n+                            &format!(\"this looks like you are swapping elements of `{}` manually\", slice),\n+                            \"try\",\n+                            format!(\n+                                \"{}.swap({}, {})\",\n+                                slice.maybe_par(),\n+                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    let first = Sugg::hir_with_applicability(cx, e1, \"..\", &mut applicability);\n+    let second = Sugg::hir_with_applicability(cx, e2, \"..\", &mut applicability);\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_SWAP,\n+        span,\n+        &format!(\"this looks like you are swapping `{}` and `{}` manually\", first, second),\n+        |diag| {\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                applicability,\n+            );\n+            if !is_xor_based {\n+                diag.note(\"or maybe you should use `std::mem::replace`?\");\n+            }\n+        },\n+    );\n+}\n+\n /// Implementation of the `MANUAL_SWAP` lint.\n fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n@@ -96,121 +155,11 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {\n-                if let ExprKind::Field(lhs1, _) = lhs1.kind {\n-                    if let ExprKind::Field(lhs2, _) = lhs2.kind {\n-                        if lhs1.hir_id.owner == lhs2.hir_id.owner {\n-                            return;\n-                        }\n-                    }\n-                }\n-\n-                let mut applicability = Applicability::MachineApplicable;\n-\n-                let slice = check_for_slice(cx, lhs1, lhs2);\n-                let (replace, what, sugg) = if let Slice::NotSwappable = slice {\n-                    return;\n-                } else if let Slice::Swappable(slice, idx1, idx2) = slice {\n-                    if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                        (\n-                            false,\n-                            format!(\" elements of `{}`\", slice),\n-                            format!(\n-                                \"{}.swap({}, {})\",\n-                                slice.maybe_par(),\n-                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n-                            ),\n-                        )\n-                    } else {\n-                        (false, String::new(), String::new())\n-                    }\n-                } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (\n-                        true,\n-                        format!(\" `{}` and `{}`\", first, second),\n-                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n-                    )\n-                } else {\n-                    (true, String::new(), String::new())\n-                };\n-\n                 let span = w[0].span.to(second.span);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_SWAP,\n-                    span,\n-                    &format!(\"this looks like you are swapping{} manually\", what),\n-                    |diag| {\n-                        if !sugg.is_empty() {\n-                            diag.span_suggestion(\n-                                span,\n-                                \"try\",\n-                                sugg,\n-                                applicability,\n-                            );\n-\n-                            if replace {\n-                                diag.note(\"or maybe you should use `std::mem::replace`?\");\n-                            }\n-                        }\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-enum Slice<'a> {\n-    /// `slice.swap(idx1, idx2)` can be used\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = vec![0, 1];\n-    /// let t = a[1];\n-    /// a[1] = a[0];\n-    /// a[0] = t;\n-    /// // can be written as\n-    /// a.swap(0, 1);\n-    /// ```\n-    Swappable(&'a Expr<'a>, &'a Expr<'a>, &'a Expr<'a>),\n-    /// The `swap` function cannot be used.\n-    ///\n-    /// ## Example\n-    ///\n-    /// ```rust\n-    /// # let mut a = [vec![1, 2], vec![3, 4]];\n-    /// let t = a[0][1];\n-    /// a[0][1] = a[1][0];\n-    /// a[1][0] = t;\n-    /// ```\n-    NotSwappable,\n-    /// Not a slice\n-    None,\n-}\n-\n-/// Checks if both expressions are index operations into \"slice-like\" types.\n-fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n-    if let ExprKind::Index(lhs1, idx1) = lhs1.kind {\n-        if let ExprKind::Index(lhs2, idx2) = lhs2.kind {\n-            if eq_expr_value(cx, lhs1, lhs2) {\n-                let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n-\n-                if matches!(ty.kind(), ty::Slice(_))\n-                    || matches!(ty.kind(), ty::Array(_, _))\n-                    || is_type_diagnostic_item(cx, ty, sym::vec_type)\n-                    || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n-                {\n-                    return Slice::Swappable(lhs1, idx1, idx2);\n-                }\n-            } else {\n-                return Slice::NotSwappable;\n+                generate_swap_warning(cx, lhs1, lhs2, span, false);\n             }\n         }\n     }\n-\n-    Slice::None\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n@@ -262,3 +211,40 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n         }\n     }\n }\n+\n+/// Implementation of the xor case for `MANUAL_SWAP` lint.\n+fn check_xor_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n+    for window in block.stmts.windows(3) {\n+        if_chain! {\n+            if let Some((lhs0, rhs0)) = extract_sides_of_xor_assign(&window[0]);\n+            if let Some((lhs1, rhs1)) = extract_sides_of_xor_assign(&window[1]);\n+            if let Some((lhs2, rhs2)) = extract_sides_of_xor_assign(&window[2]);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs2, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n+            if eq_expr_value(cx, lhs1, rhs2);\n+            then {\n+                let span = window[0].span.to(window[2].span);\n+                generate_swap_warning(cx, lhs0, rhs0, span, true);\n+            }\n+        };\n+    }\n+}\n+\n+/// Returns the lhs and rhs of an xor assignment statement.  \n+fn extract_sides_of_xor_assign<'a, 'hir>(stmt: &'a Stmt<'hir>) -> Option<(&'a Expr<'hir>, &'a Expr<'hir>)> {\n+    if let StmtKind::Semi(expr) = stmt.kind {\n+        if let ExprKind::AssignOp(\n+            Spanned {\n+                node: BinOpKind::BitXor,\n+                ..\n+            },\n+            lhs,\n+            rhs,\n+        ) = expr.kind\n+        {\n+            return Some((lhs, rhs));\n+        }\n+    }\n+    None\n+}"}, {"sha": "e930338270cb74c6620e52903ca0a71879a24e1b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0084195dee22d498291d92603d18f2f79946671f/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084195dee22d498291d92603d18f2f79946671f/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=0084195dee22d498291d92603d18f2f79946671f", "patch": "@@ -558,6 +558,54 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     None\n }\n \n+/// This method will return tuple of projection stack and root of the expression,\n+/// used in `can_mut_borrow_both`.\n+///\n+/// For example, if `e` represents the `v[0].a.b[x]`\n+/// this method will return a tuple, composed of a `Vec`\n+/// containing the `Expr`s for `v[0], v[0].a, v[0].a.b, v[0].a.b[x]`\n+/// and a `Expr` for root of them, `v`\n+fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'a Expr<'hir>) {\n+    let mut result = vec![];\n+    let root = loop {\n+        match e.kind {\n+            ExprKind::Index(ep, _) | ExprKind::Field(ep, _) => {\n+                result.push(e);\n+                e = ep;\n+            },\n+            _ => break e,\n+        };\n+    };\n+    result.reverse();\n+    (result, root)\n+}\n+\n+/// Checks if two expressions can be mutably borrowed simultaneously\n+/// and they aren't dependent on borrowing same thing twice\n+pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -> bool {\n+    let (s1, r1) = projection_stack(e1);\n+    let (s2, r2) = projection_stack(e2);\n+    if !eq_expr_value(cx, r1, r2) {\n+        return true;\n+    }\n+    for (x1, x2) in s1.iter().zip(s2.iter()) {\n+        match (&x1.kind, &x2.kind) {\n+            (ExprKind::Field(_, i1), ExprKind::Field(_, i2)) => {\n+                if i1 != i2 {\n+                    return true;\n+                }\n+            },\n+            (ExprKind::Index(_, i1), ExprKind::Index(_, i2)) => {\n+                if !eq_expr_value(cx, i1, i2) {\n+                    return false;\n+                }\n+            },\n+            _ => return false,\n+        }\n+    }\n+    false\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n     match expr.kind {"}, {"sha": "ef518359ec5f373614727442c65526c05a5c1899", "filename": "tests/ui/swap.fixed", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.fixed?ref=0084195dee22d498291d92603d18f2f79946671f", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -20,9 +21,7 @@ struct Bar {\n fn field() {\n     let mut bar = Bar { a: 1, b: 2 };\n \n-    let temp = bar.a;\n-    bar.a = bar.b;\n-    bar.b = temp;\n+    std::mem::swap(&mut bar.a, &mut bar.b);\n \n     let mut baz = vec![bar.clone(), bar.clone()];\n     let temp = baz[0].a;\n@@ -51,6 +50,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -60,13 +60,54 @@ fn vec() {\n     foo.swap(0, 1);\n }\n \n+fn xor_swap_locals() {\n+    // This is an xor-based swap of local variables.\n+    let mut a = 0;\n+    let mut b = 1;\n+    std::mem::swap(&mut a, &mut b)\n+}\n+\n+fn xor_field_swap() {\n+    // This is an xor-based swap of fields in a struct.\n+    let mut bar = Bar { a: 0, b: 1 };\n+    std::mem::swap(&mut bar.a, &mut bar.b)\n+}\n+\n+fn xor_slice_swap() {\n+    // This is an xor-based swap of a slice\n+    let foo = &mut [1, 2];\n+    foo.swap(0, 1)\n+}\n+\n+fn xor_no_swap() {\n+    // This is a sequence of xor-assignment statements that doesn't result in a swap.\n+    let mut a = 0;\n+    let mut b = 1;\n+    let mut c = 2;\n+    a ^= b;\n+    b ^= c;\n+    a ^= c;\n+    c ^= a;\n+}\n+\n+fn xor_unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    foo[0][1] ^= foo[1][0];\n+    foo[1][0] ^= foo[0][0];\n+    foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    std::mem::swap(&mut foo[0][1], &mut bar[1][0]);\n+}\n+\n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "8518659ccf316dbbf41ce2e9941b3874c5878092", "filename": "tests/ui/swap.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.rs?ref=0084195dee22d498291d92603d18f2f79946671f", "patch": "@@ -6,6 +6,7 @@\n     clippy::no_effect,\n     clippy::redundant_clone,\n     redundant_semicolons,\n+    dead_code,\n     unused_assignments\n )]\n \n@@ -55,6 +56,7 @@ fn unswappable_slice() {\n     foo[1][0] = temp;\n \n     // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n }\n \n fn vec() {\n@@ -66,13 +68,62 @@ fn vec() {\n     foo.swap(0, 1);\n }\n \n+fn xor_swap_locals() {\n+    // This is an xor-based swap of local variables.\n+    let mut a = 0;\n+    let mut b = 1;\n+    a ^= b;\n+    b ^= a;\n+    a ^= b;\n+}\n+\n+fn xor_field_swap() {\n+    // This is an xor-based swap of fields in a struct.\n+    let mut bar = Bar { a: 0, b: 1 };\n+    bar.a ^= bar.b;\n+    bar.b ^= bar.a;\n+    bar.a ^= bar.b;\n+}\n+\n+fn xor_slice_swap() {\n+    // This is an xor-based swap of a slice\n+    let foo = &mut [1, 2];\n+    foo[0] ^= foo[1];\n+    foo[1] ^= foo[0];\n+    foo[0] ^= foo[1];\n+}\n+\n+fn xor_no_swap() {\n+    // This is a sequence of xor-assignment statements that doesn't result in a swap.\n+    let mut a = 0;\n+    let mut b = 1;\n+    let mut c = 2;\n+    a ^= b;\n+    b ^= c;\n+    a ^= c;\n+    c ^= a;\n+}\n+\n+fn xor_unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    foo[0][1] ^= foo[1][0];\n+    foo[1][0] ^= foo[0][0];\n+    foo[0][1] ^= foo[1][0];\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+    // this could use split_at_mut and mem::swap, but that is not much simpler.\n+}\n+\n+fn distinct_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let bar = &mut [vec![1, 2], vec![3, 4]];\n+    let temp = foo[0][1];\n+    foo[0][1] = bar[1][0];\n+    bar[1][0] = temp;\n+}\n+\n #[rustfmt::skip]\n fn main() {\n-    field();\n-    array();\n-    slice();\n-    unswappable_slice();\n-    vec();\n \n     let mut a = 42;\n     let mut b = 1337;"}, {"sha": "614d16ced40f1b5fd02cf899f86f5a0f38a9b6a5", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0084195dee22d498291d92603d18f2f79946671f/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=0084195dee22d498291d92603d18f2f79946671f", "patch": "@@ -1,31 +1,74 @@\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:24:5\n+   |\n+LL | /     let temp = bar.a;\n+LL | |     bar.a = bar.b;\n+LL | |     bar.b = temp;\n+   | |________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+   |\n+   = note: `-D clippy::manual-swap` implied by `-D warnings`\n+   = note: or maybe you should use `std::mem::replace`?\n+\n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:35:5\n+  --> $DIR/swap.rs:36:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n-   |\n-   = note: `-D clippy::manual-swap` implied by `-D warnings`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:44:5\n+  --> $DIR/swap.rs:45:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:62:5\n+  --> $DIR/swap.rs:64:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping `a` and `b` manually\n-  --> $DIR/swap.rs:83:7\n+  --> $DIR/swap.rs:75:5\n+   |\n+LL | /     a ^= b;\n+LL | |     b ^= a;\n+LL | |     a ^= b;\n+   | |___________^ help: try: `std::mem::swap(&mut a, &mut b)`\n+\n+error: this looks like you are swapping `bar.a` and `bar.b` manually\n+  --> $DIR/swap.rs:83:5\n+   |\n+LL | /     bar.a ^= bar.b;\n+LL | |     bar.b ^= bar.a;\n+LL | |     bar.a ^= bar.b;\n+   | |___________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+\n+error: this looks like you are swapping elements of `foo` manually\n+  --> $DIR/swap.rs:91:5\n+   |\n+LL | /     foo[0] ^= foo[1];\n+LL | |     foo[1] ^= foo[0];\n+LL | |     foo[0] ^= foo[1];\n+   | |_____________________^ help: try: `foo.swap(0, 1)`\n+\n+error: this looks like you are swapping `foo[0][1]` and `bar[1][0]` manually\n+  --> $DIR/swap.rs:120:5\n+   |\n+LL | /     let temp = foo[0][1];\n+LL | |     foo[0][1] = bar[1][0];\n+LL | |     bar[1][0] = temp;\n+   | |____________________^ help: try: `std::mem::swap(&mut foo[0][1], &mut bar[1][0])`\n+   |\n+   = note: or maybe you should use `std::mem::replace`?\n+\n+error: this looks like you are swapping `a` and `b` manually\n+  --> $DIR/swap.rs:134:7\n    |\n LL |       ; let t = a;\n    |  _______^\n@@ -36,7 +79,7 @@ LL | |     b = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are swapping `c.0` and `a` manually\n-  --> $DIR/swap.rs:92:7\n+  --> $DIR/swap.rs:143:7\n    |\n LL |       ; let t = c.0;\n    |  _______^\n@@ -47,7 +90,7 @@ LL | |     a = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `a` and `b`\n-  --> $DIR/swap.rs:80:5\n+  --> $DIR/swap.rs:131:5\n    |\n LL | /     a = b;\n LL | |     b = a;\n@@ -57,13 +100,13 @@ LL | |     b = a;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `c.0` and `a`\n-  --> $DIR/swap.rs:89:5\n+  --> $DIR/swap.rs:140:5\n    |\n LL | /     c.0 = a;\n LL | |     a = c.0;\n    | |___________^ help: try: `std::mem::swap(&mut c.0, &mut a)`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 12 previous errors\n "}]}