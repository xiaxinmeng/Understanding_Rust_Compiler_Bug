{"sha": "f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYTgwYWI5ZDJmNmNlNjFjNGI3NTAwZmIyM2Y0YzZmNTkxNzU3NzA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-05T13:48:13Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-06T12:21:27Z"}, "message": "Apply stability attributes to core::num::{Int, SignedInt, UnsignedInt}.", "tree": {"sha": "f6b1a31cdbbc5a5873b0b7d549f4842ddf888a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b1a31cdbbc5a5873b0b7d549f4842ddf888a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "html_url": "https://github.com/rust-lang/rust/commit/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49feb0c4310bbb7c290237b5b133cdbdda5ce228", "url": "https://api.github.com/repos/rust-lang/rust/commits/49feb0c4310bbb7c290237b5b133cdbdda5ce228", "html_url": "https://github.com/rust-lang/rust/commit/49feb0c4310bbb7c290237b5b133cdbdda5ce228"}], "stats": {"total": 51, "additions": 40, "deletions": 11}, "files": [{"sha": "192d6063f6bbc520b72256c601523b98230bcd59", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "patch": "@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -50,18 +50,22 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn max_value() -> Self;\n \n     /// Returns the number of ones in the binary representation of `self`.\n@@ -75,6 +79,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn count_ones(self) -> uint;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n@@ -88,6 +93,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     #[inline]\n     fn count_zeros(self) -> uint {\n         (!self).count_ones()\n@@ -105,6 +111,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n@@ -119,6 +126,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn trailing_zeros(self) -> uint;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n@@ -134,6 +142,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn rotate_left(self, n: uint) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n@@ -149,6 +158,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn rotate_right(self, n: uint) -> Self;\n \n     /// Reverses the byte order of the integer.\n@@ -163,6 +173,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n+    #[stable]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -182,6 +193,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -204,6 +216,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -226,6 +239,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -248,6 +262,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -264,6 +279,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n+    #[stable]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -277,6 +293,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n+    #[stable]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -290,6 +307,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n+    #[stable]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -304,11 +322,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[inline]\n+    #[stable]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n+    #[stable]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -320,6 +339,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n+    #[stable]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -338,6 +358,7 @@ pub trait Int\n     ///\n     /// assert_eq!(2i.pow(4), 16);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n         let mut base = self;\n@@ -369,7 +390,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[unstable = \"trait is unstable\"]\n+        #[stable]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -500,7 +521,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[unstable = \"trait is unstable\"]\n+        #[stable]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -593,33 +614,38 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n+    #[unstable = \"overflow in debug builds?\"]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n     ///\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n+    #[stable]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n+    #[stable]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n+    #[stable]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n+        #[stable]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -651,16 +677,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n+    #[stable]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n+    #[stable]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -671,6 +699,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n+    #[stable]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -681,19 +710,19 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for uint {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u8 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u16 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u32 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number."}]}