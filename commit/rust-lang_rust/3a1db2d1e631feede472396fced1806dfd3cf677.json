{"sha": "3a1db2d1e631feede472396fced1806dfd3cf677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMWRiMmQxZTYzMWZlZWRlNDcyMzk2ZmNlZDE4MDZkZmQzY2Y2Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T14:28:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T14:28:36Z"}, "message": "auto merge of #7886 : msullivan/rust/default-methods, r=pcwalton\n\nThis does a bunch of cleanup on the data structures for the trait system. (Unfortunately it doesn't remove `provided_method_sources`. Maybe later.)\r\n\r\nIt also changes how cross crate methods are handled, so that information about them is exported in metadata, instead of having the methods regenerated by every crate that imports an impl.\r\n\r\nr? @nikomatsakis, maybe?", "tree": {"sha": "22cdb1e335e8b20c45ebdb994e43260cdb0bec1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22cdb1e335e8b20c45ebdb994e43260cdb0bec1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a1db2d1e631feede472396fced1806dfd3cf677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db2d1e631feede472396fced1806dfd3cf677", "html_url": "https://github.com/rust-lang/rust/commit/3a1db2d1e631feede472396fced1806dfd3cf677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db2d1e631feede472396fced1806dfd3cf677/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec53efa64dcd449c78381b680a7184d9876d4f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec53efa64dcd449c78381b680a7184d9876d4f29", "html_url": "https://github.com/rust-lang/rust/commit/ec53efa64dcd449c78381b680a7184d9876d4f29"}, {"sha": "002bfd796648547839d0f3740308995b4a926f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/002bfd796648547839d0f3740308995b4a926f50", "html_url": "https://github.com/rust-lang/rust/commit/002bfd796648547839d0f3740308995b4a926f50"}], "stats": {"total": 998, "additions": 383, "deletions": 615}, "files": [{"sha": "645188ce5a4d997f9f5990a84211ad49874c96ee", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -179,6 +179,8 @@ pub static tag_mod_child: uint = 0x7e;\n pub static tag_misc_info: uint = 0x7f;\n pub static tag_misc_info_crate_items: uint = 0x80;\n \n+pub static tag_item_method_provided_source: uint = 0x81;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "993649492a4630ff3896d6de132ef95902d1ce4d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -15,7 +15,7 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata;\n-use middle::{ty, resolve};\n+use middle::ty;\n \n use std::vec;\n use reader = extra::ebml::reader;\n@@ -97,10 +97,10 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(cstore: @mut cstore::CStore, impl_def_id: ast::def_id)\n-                -> resolve::Impl {\n-    let cdata = cstore::get_crate_data(cstore, impl_def_id.crate);\n-    decoder::get_impl(cstore.intr, cdata, impl_def_id.node)\n+pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::def_id)\n+                -> ty::Impl {\n+    let cdata = cstore::get_crate_data(tcx.cstore, impl_def_id.crate);\n+    decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {"}, {"sha": "a77c6c6ab5223bbe855902ec08805ee7ca93a969", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -20,7 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n-use middle::{ty, resolve};\n+use middle::ty;\n \n use std::hash::HashUtil;\n use std::int;\n@@ -174,14 +174,6 @@ fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n     None\n }\n \n-fn translated_parent_item_opt(cnum: ast::crate_num, d: ebml::Doc) ->\n-        Option<ast::def_id> {\n-    let trait_did_opt = item_parent_item(d);\n-    do trait_did_opt.map |trait_did| {\n-        ast::def_id { crate: cnum, node: trait_did.node }\n-    }\n-}\n-\n fn item_reqd_and_translated_parent_item(cnum: ast::crate_num,\n                                         d: ebml::Doc) -> ast::def_id {\n     let trait_did = item_parent_item(d).expect(\"item without parent\");\n@@ -193,6 +185,12 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n     return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n }\n \n+fn get_provided_source(d: ebml::Doc, cdata: cmd) -> Option<ast::def_id> {\n+    do reader::maybe_get_doc(d, tag_item_method_provided_source).map |doc| {\n+        translate_def_id(cdata, reader::with_doc_data(*doc, parse_def_id))\n+    }\n+}\n+\n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n@@ -323,13 +321,19 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n         UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n         Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n         ForeignFn => dl_def(ast::def_fn(did, ast::extern_fn)),\n-        UnsafeStaticMethod => {\n-            let trait_did_opt = translated_parent_item_opt(cnum, item);\n-            dl_def(ast::def_static_method(did, trait_did_opt, ast::unsafe_fn))\n-        }\n-        StaticMethod => {\n-            let trait_did_opt = translated_parent_item_opt(cnum, item);\n-            dl_def(ast::def_static_method(did, trait_did_opt, ast::impure_fn))\n+        StaticMethod | UnsafeStaticMethod => {\n+            let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n+                { ast::impure_fn };\n+            // def_static_method carries an optional field of its enclosing\n+            // *trait*, but not an inclosing Impl (if this is an inherent\n+            // static method). So we need to detect whether this is in\n+            // a trait or not, which we do through the mildly hacky\n+            // way of checking whether there is a trait_method_sort.\n+            let trait_did_opt = if reader::maybe_get_doc(\n+                  item, tag_item_trait_method_sort).is_some() {\n+                Some(item_reqd_and_translated_parent_item(cnum, item))\n+            } else { None };\n+            dl_def(ast::def_static_method(did, trait_did_opt, purity))\n         }\n         Type | ForeignType => dl_def(ast::def_ty(did)),\n         Mod => dl_def(ast::def_mod(did)),\n@@ -795,34 +799,29 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n }\n \n fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n-                     base_tps: uint) -> ~[@resolve::MethodInfo] {\n+                     tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n-        let mth_item = lookup_item(m_did.node, cdata.data);\n-        let explicit_self = get_explicit_self(mth_item);\n-        rslt.push(@resolve::MethodInfo {\n-                    did: translate_def_id(cdata, m_did),\n-                    n_tps: item_ty_param_count(mth_item) - base_tps,\n-                    ident: item_name(intr, mth_item),\n-                    explicit_self: explicit_self});\n+        rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n     }\n+\n     rslt\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id)\n-                -> resolve::Impl {\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id,\n+               tcx: ty::ctxt)\n+                -> ty::Impl {\n     let data = cdata.data;\n     let impl_item = lookup_item(impl_id, data);\n-    let base_tps = item_ty_param_count(impl_item);\n-    resolve::Impl {\n+    ty::Impl {\n         did: ast::def_id {\n             crate: cdata.cnum,\n             node: impl_id,\n         },\n         ident: item_name(intr, impl_item),\n-        methods: item_impl_methods(intr, cdata, impl_item, base_tps),\n+        methods: item_impl_methods(intr, cdata, impl_item, tcx),\n     }\n }\n \n@@ -842,13 +841,16 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let def_id = item_def_id(method_doc, cdata);\n+    let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n+                                                            method_doc);\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n+    let provided_source = get_provided_source(method_doc, cdata);\n \n     ty::Method::new(\n         name,\n@@ -860,7 +862,9 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         fty,\n         explicit_self,\n         vis,\n-        def_id\n+        def_id,\n+        container_id,\n+        provided_source\n     )\n }\n "}, {"sha": "2ef00a2167f0154dee09801d4049fc218f806936", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 106, "deletions": 127, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -15,10 +15,9 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::ty::node_id_to_type;\n+use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::ty;\n use middle;\n-use util::ppaux::ty_to_str;\n \n use std::hash::HashUtil;\n use std::hashmap::{HashMap, HashSet};\n@@ -37,8 +36,6 @@ use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n use syntax::{ast_util, visit};\n use syntax::parse::token;\n@@ -192,13 +189,12 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: &mut writer::Encoder,\n-                            ecx: &EncodeContext,\n-                            params: &OptVec<TyParam>) {\n-    let ty_param_defs =\n-        @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n-    encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n+fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n+                          ecx: &EncodeContext,\n+                          tpt: &ty::ty_param_bounds_and_ty) {\n+    encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n+    encode_type(ecx, ebml_w, tpt.ty);\n }\n \n fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: def_id) {\n@@ -321,15 +317,14 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let vi = ty::enum_variants(ecx.tcx,\n                                ast::def_id { crate: local_crate, node: id });\n     for variants.iter().advance |variant| {\n+        let def_id = local_def(variant.node.id);\n         index.push(entry {val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(variant.node.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'v');\n         encode_name(ecx, ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n-        encode_type(ecx, ebml_w,\n-                    node_id_to_type(ecx.tcx, variant.node.id));\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {\n@@ -342,7 +337,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n+        encode_bounds_and_type(ebml_w, ecx,\n+                               &lookup_item_type(ecx.tcx, def_id));\n         encode_path(ecx, ebml_w, path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n@@ -396,13 +392,13 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut writer::Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n-    match ecx.tcx.base_impls.find(&exp.def_id) {\n+    match ecx.tcx.inherent_impls.find(&exp.def_id) {\n         Some(implementations) => {\n             for implementations.iter().advance |&base_impl| {\n                 for base_impl.methods.iter().advance |&m| {\n                     if m.explicit_self == ast::sty_static {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n-                                                        m.did, m.ident);\n+                                                        m.def_id, m.ident);\n                     }\n                 }\n             }\n@@ -654,6 +650,16 @@ fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n     ebml_w.end_tag();\n }\n \n+fn encode_provided_source(ebml_w: &mut writer::Encoder,\n+                          source_opt: Option<def_id>) {\n+    for source_opt.iter().advance |source| {\n+        ebml_w.start_tag(tag_item_method_provided_source);\n+        let s = def_to_str(*source);\n+        ebml_w.writer.write(s.as_bytes());\n+        ebml_w.end_tag();\n+    }\n+}\n+\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n@@ -689,36 +695,6 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n     index\n }\n \n-// This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: &EncodeContext,\n-                        ebml_w: &mut writer::Encoder,\n-                        id: node_id,\n-                        ident: ident,\n-                        path: &[ast_map::path_elt],\n-                        item: Option<inlined_item>,\n-                        generics: &ast::Generics) {\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_name(ecx, ebml_w, ident);\n-        encode_def_id(ebml_w, local_def(id));\n-        encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let its_ty = node_id_to_type(ecx.tcx, id);\n-        debug!(\"fn name = %s ty = %s its node id = %d\",\n-               ecx.tcx.sess.str_of(ident),\n-               ty_to_str(ecx.tcx, its_ty), id);\n-        encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n-        match item {\n-           Some(it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n-           }\n-           None => {\n-             encode_symbol(ecx, ebml_w, id);\n-           }\n-        }\n-        ebml_w.end_tag();\n-}\n-\n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n@@ -753,52 +729,47 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_method_fty(ecx, ebml_w, &method_ty.fty);\n     encode_visibility(ebml_w, method_ty.vis);\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n+    let purity = method_ty.fty.purity;\n+    match method_ty.explicit_self {\n+        ast::sty_static => {\n+            encode_family(ebml_w, purity_static_method_family(purity));\n+        }\n+        _ => encode_family(ebml_w, purity_fn_family(purity))\n+    }\n+    encode_provided_source(ebml_w, method_ty.provided_source);\n }\n \n fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n+                          m: &ty::Method,\n                           impl_path: &[ast_map::path_elt],\n-                          should_inline: bool,\n+                          is_default_impl: bool,\n                           parent_id: node_id,\n-                          m: @method,\n-                          owner_generics: &ast::Generics,\n-                          method_generics: &ast::Generics) {\n-    debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           ecx.tcx.sess.str_of(m.ident),\n-           owner_generics.ty_params.len(),\n-           method_generics.ty_params.len());\n+                          ast_method_opt: Option<@method>) {\n+\n+    debug!(\"encode_info_for_method: %? %s\", m.def_id,\n+           ecx.tcx.sess.str_of(m.ident));\n     ebml_w.start_tag(tag_items_data_item);\n \n-    let method_def_id = local_def(m.id);\n-    let method_ty = ty::method(ecx.tcx, method_def_id);\n-    encode_method_ty_fields(ecx, ebml_w, method_ty);\n+    encode_method_ty_fields(ecx, ebml_w, m);\n+    encode_parent_item(ebml_w, local_def(parent_id));\n \n-    match m.explicit_self.node {\n-        ast::sty_static => {\n-            encode_family(ebml_w, purity_static_method_family(m.purity));\n-        }\n-        _ => encode_family(ebml_w, purity_fn_family(m.purity))\n-    }\n-\n-    let mut combined_ty_params = opt_vec::Empty;\n-    for owner_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push((*x).clone())\n-    }\n-    for method_generics.ty_params.iter().advance |x| {\n-        combined_ty_params.push((*x).clone())\n-    }\n-    let len = combined_ty_params.len();\n-    encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n+    // The type for methods gets encoded twice, which is unfortunate.\n+    let tpt = lookup_item_type(ecx.tcx, m.def_id);\n+    encode_bounds_and_type(ebml_w, ecx, &tpt);\n \n-    encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n \n-    if len > 0u || should_inline {\n-        (ecx.encode_inlined_item)(\n-           ecx, ebml_w, impl_path,\n-           ii_method(local_def(parent_id), false, m));\n-    } else {\n-        encode_symbol(ecx, ebml_w, m.id);\n+    for ast_method_opt.iter().advance |ast_method| {\n+        let num_params = tpt.generics.type_param_defs.len();\n+        if num_params > 0u || is_default_impl\n+            || should_inline(ast_method.attrs) {\n+            (ecx.encode_inlined_item)(\n+                ecx, ebml_w, impl_path,\n+                ii_method(local_def(parent_id), false, *ast_method));\n+        } else {\n+            encode_symbol(ecx, ebml_w, m.def_id.node);\n+        }\n     }\n \n     ebml_w.end_tag();\n@@ -844,11 +815,12 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     debug!(\"encoding info for item at %s\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n+    let def_id = local_def(item.id);\n     match item.node {\n       item_static(_, m, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         if m == ast::m_mutbl {\n             encode_family(ebml_w, 'b');\n         } else {\n@@ -864,11 +836,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       item_fn(_, purity, _, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, purity_fn_family(purity));\n         let tps_len = generics.ty_params.len();\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n@@ -892,7 +863,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       item_foreign_mod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -906,13 +877,12 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         ebml_w.end_tag();\n       }\n-      item_ty(_, ref generics) => {\n+      item_ty(*) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n@@ -922,10 +892,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         add_to_index();\n \n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 't');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         for (*enum_definition).variants.iter().advance |v| {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -943,7 +912,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index,\n                                  generics);\n       }\n-      item_struct(struct_def, ref generics) => {\n+      item_struct(struct_def, _) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -956,10 +925,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'S');\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n \n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1008,14 +976,17 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n+      item_impl(_, ref opt_trait, ref ty, ref ast_methods) => {\n+        // We need to encode information about the default methods we\n+        // have inherited, so we drive this based on the impl structure.\n+        let imp = tcx.impls.get(&def_id);\n+\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n@@ -1026,15 +997,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             _ => {}\n         }\n-        for methods.iter().advance |m| {\n+        for imp.methods.iter().advance |method| {\n             ebml_w.start_tag(tag_item_impl_method);\n-            let method_def_id = local_def(m.id);\n-            let s = def_to_str(method_def_id);\n+            let s = def_to_str(method.def_id);\n             ebml_w.writer.write(s.as_bytes());\n             ebml_w.end_tag();\n         }\n         for opt_trait.iter().advance |ast_trait_ref| {\n-            let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n+            let trait_ref = ty::node_id_to_trait_ref(\n+                tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -1044,30 +1015,40 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let mut impl_path = vec::append(~[], path);\n         impl_path.push(ast_map::path_name(item.ident));\n \n-        for methods.iter().advance |m| {\n-            index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n+        // Iterate down the methods, emitting them. We rely on the\n+        // assumption that all of the actually implemented methods\n+        // appear first in the impl structure, in the same order they do\n+        // in the ast. This is a little sketchy.\n+        let num_implemented_methods = ast_methods.len();\n+        for imp.methods.iter().enumerate().advance |(i, m)| {\n+            let ast_method = if i < num_implemented_methods {\n+                Some(ast_methods[i])\n+            } else { None };\n+\n+            index.push(entry {val: m.def_id.node, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx,\n                                    ebml_w,\n+                                   *m,\n                                    impl_path,\n-                                   should_inline(m.attrs),\n+                                   false,\n                                    item.id,\n-                                   *m,\n-                                   generics,\n-                                   &m.generics);\n+                                   ast_method)\n         }\n       }\n-      item_trait(ref generics, ref super_traits, ref ms) => {\n+      item_trait(_, ref super_traits, ref ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n+        encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        let trait_def = ty::lookup_trait_def(tcx, local_def(item.id));\n+        let trait_def = ty::lookup_trait_def(tcx, def_id);\n+        encode_ty_type_param_defs(ebml_w, ecx,\n+                                  trait_def.generics.type_param_defs,\n+                                  tag_items_data_item_ty_param_bounds);\n         encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).iter().advance |&method_def_id| {\n+        for ty::trait_method_def_ids(tcx, def_id).iter().advance |&method_def_id| {\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n@@ -1084,7 +1065,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n-        let r = ty::trait_method_def_ids(tcx, local_def(item.id));\n+        let r = ty::trait_method_def_ids(tcx, def_id);\n         for r.iter().enumerate().advance |(i, &method_def_id)| {\n             assert_eq!(method_def_id.crate, ast::local_crate);\n \n@@ -1096,7 +1077,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_method_ty_fields(ecx, ebml_w, method_ty);\n \n-            encode_parent_item(ebml_w, local_def(item.id));\n+            encode_parent_item(ebml_w, def_id);\n \n             let mut trait_path = vec::append(~[], path);\n             trait_path.push(ast_map::path_name(item.ident));\n@@ -1109,10 +1090,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                       method_ty.fty.purity));\n \n                     let tpt = ty::lookup_item_type(tcx, method_def_id);\n-                    encode_ty_type_param_defs(ebml_w, ecx,\n-                                              tpt.generics.type_param_defs,\n-                                              tag_items_data_item_ty_param_bounds);\n-                    encode_type(ecx, ebml_w, tpt.ty);\n+                    encode_bounds_and_type(ebml_w, ecx, &tpt);\n                 }\n \n                 _ => {\n@@ -1131,13 +1109,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     // If this is a static method, we've already encoded\n                     // this.\n                     if method_ty.explicit_self != sty_static {\n-                        encode_type_param_bounds(ebml_w, ecx,\n-                                                 &m.generics.ty_params);\n+                        // XXX: I feel like there is something funny going on.\n+                        let tpt = ty::lookup_item_type(tcx, method_def_id);\n+                        encode_bounds_and_type(ebml_w, ecx, &tpt);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     (ecx.encode_inlined_item)(\n                         ecx, ebml_w, path,\n-                        ii_method(local_def(item.id), true, m));\n+                        ii_method(def_id, true, m));\n                 }\n             }\n \n@@ -1158,11 +1137,11 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n-      foreign_item_fn(_, purity, ref generics) => {\n+      foreign_item_fn(_, purity, _) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(purity));\n-        encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n-        encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_bounds_and_type(ebml_w, ecx,\n+                               &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign(nitem));"}, {"sha": "c602a14325307b5a80007f6ba3c040aeadf8931d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -106,29 +106,6 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         }\n     };\n \n-    // Returns the ID of the container (impl or trait) that a crate-local\n-    // method belongs to.\n-    let local_method_container_id:\n-            @fn(span: span, method_id: node_id) -> def_id =\n-            |span, method_id| {\n-        match tcx.items.find(&method_id) {\n-            Some(&node_method(_, impl_id, _)) => impl_id,\n-            Some(&node_trait_method(_, trait_id, _)) => trait_id,\n-            Some(_) => {\n-                tcx.sess.span_bug(span,\n-                                  fmt!(\"method was a %s?!\",\n-                                       ast_map::node_id_to_str(\n-                                            tcx.items,\n-                                            method_id,\n-                                           token::get_ident_interner())));\n-            }\n-            None => {\n-                tcx.sess.span_bug(span, \"method not found in \\\n-                                         AST map?!\");\n-            }\n-        }\n-    };\n-\n     // Returns true if a crate-local method is private and false otherwise.\n     let method_is_private: @fn(span: span, method_id: node_id) -> bool =\n             |span, method_id| {\n@@ -248,15 +225,12 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n-        let method_id = match tcx.provided_method_sources.find(&method_id) {\n-            None => method_id,\n-            Some(source) => source.method_id\n-        };\n+        let method_id = ty::method(tcx, method_id).provided_source\n+            .get_or_default(method_id);\n \n         if method_id.crate == local_crate {\n             let is_private = method_is_private(span, method_id.node);\n-            let container_id = local_method_container_id(span,\n-                                                         method_id.node);\n+            let container_id = ty::method(tcx, method_id).container_id;\n             if is_private &&\n                     (container_id.crate != local_crate ||\n                      !privileged_items.iter().any(|x| x == &(container_id.node))) {"}, {"sha": "6d457b46d4f3d762471ad84eb4dea423b0a4b502", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -55,24 +55,6 @@ pub struct binding_info {\n // Map from the name in a pattern to its binding mode.\n pub type BindingMap = HashMap<ident,binding_info>;\n \n-// Implementation resolution\n-//\n-// FIXME #4946: This kind of duplicates information kept in\n-// ty::method. Maybe it should go away.\n-\n-pub struct MethodInfo {\n-    did: def_id,\n-    n_tps: uint,\n-    ident: ident,\n-    explicit_self: explicit_self_\n-}\n-\n-pub struct Impl {\n-    did: def_id,\n-    ident: ident,\n-    methods: ~[@MethodInfo]\n-}\n-\n // Trait method resolution\n pub type TraitMap = HashMap<node_id,@mut ~[def_id]>;\n "}, {"sha": "6741637ae9ab37d2623ce480f392d1d9a05c5b78", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -524,7 +524,6 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                                     &tsubsts,\n                                                     None,\n                                                     None,\n-                                                    None,\n                                                     None);\n \n         val"}, {"sha": "f03a2a62e0c16b1c905a19fe8469e7f89ded7cc3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -296,10 +296,10 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (def_id, opt_impl_did, substs, self_vtable, vtables) =\n-        match tcx.provided_method_sources.find(&def_id) {\n-        None => (def_id, None, substs, None, vtables),\n-        Some(source) => {\n+    let (is_default, def_id, substs, self_vtable, vtables) =\n+        match ty::provided_source(tcx, def_id) {\n+        None => (false, def_id, substs, None, vtables),\n+        Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n             // the type parameters of the impl we are using and the\n@@ -313,10 +313,11 @@ pub fn trans_fn_ref_with_vtables(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let trait_ref = ty::impl_trait_ref(tcx, source.impl_id)\n+            let impl_id = ty::method(tcx, def_id).container_id;\n+            let method = ty::method(tcx, source_id);\n+            let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n                 .expect(\"could not find trait_ref for impl with \\\n                          default methods\");\n-            let method = ty::method(tcx, source.method_id);\n \n             // Get all of the type params for the receiver\n             let param_defs = method.generics.type_param_defs;\n@@ -330,18 +331,18 @@ pub fn trans_fn_ref_with_vtables(\n             };\n \n             let self_vtable =\n-                typeck::vtable_static(source.impl_id, receiver_substs,\n+                typeck::vtable_static(impl_id, receiver_substs,\n                                       receiver_vtables);\n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n-                tcx, source.impl_id, trait_ref, method);\n+                tcx, impl_id, trait_ref, method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n \n \n             let vtables =\n-                resolve_default_method_vtables(bcx, source.impl_id,\n+                resolve_default_method_vtables(bcx, impl_id,\n                                                method, &new_substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n@@ -352,7 +353,7 @@ pub fn trans_fn_ref_with_vtables(\n                    first_subst.repr(tcx), new_substs.repr(tcx),\n                    self_vtable.repr(tcx), vtables.repr(tcx));\n \n-            (source.method_id, Some(source.impl_id),\n+            (true, source_id,\n              new_substs, Some(self_vtable), Some(vtables))\n         }\n     };\n@@ -372,7 +373,7 @@ pub fn trans_fn_ref_with_vtables(\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n     let must_monomorphise;\n-    if type_params.len() > 0 || opt_impl_did.is_some() {\n+    if type_params.len() > 0 || is_default {\n         must_monomorphise = true;\n     } else if def_id.crate == ast::local_crate {\n         let map_node = session::expect(\n@@ -400,7 +401,7 @@ pub fn trans_fn_ref_with_vtables(\n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, self_vtable,\n-                                         opt_impl_did, Some(ref_id));\n+                                         Some(ref_id));\n         let mut val = val;\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params"}, {"sha": "d90614ebc021c4306dc5fa5cd1433c1aeafe51af", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -938,8 +938,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n #[deriving(Eq,IterBytes)]\n pub struct mono_id_ {\n     def: ast::def_id,\n-    params: ~[mono_param_id],\n-    impl_did_opt: Option<ast::def_id>\n+    params: ~[mono_param_id]\n }\n \n pub type mono_id = @mono_id_;"}, {"sha": "bcf3aa6ad50bff0f0ac4235ae55974bc0cacbf62", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 65, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -162,7 +162,7 @@ pub fn trans_method_callee(bcx: block,\n             let self_ty = node_id_type(bcx, this.id);\n             // <impl_id> is the ID of the implementation of\n             // trait <trait_id> for type <self_ty>\n-            let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n+            let impl_id = ty::bogus_get_impl_id_from_ty(tcx, trait_id, self_ty);\n             // Get the supertrait's methods\n             let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n             // Make sure to fail with a readable error message if\n@@ -177,9 +177,7 @@ pub fn trans_method_callee(bcx: block,\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n             origin = typeck::method_static(\n-                method_with_name_or_default(bcx.ccx(),\n-                                            impl_id,\n-                                            method_name));\n+                method_with_name(bcx.ccx(), impl_id, method_name));\n         }\n         typeck::method_self(*) |\n         typeck::method_static(*) | typeck::method_param(*) |\n@@ -308,12 +306,10 @@ pub fn trans_static_method_callee(bcx: block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name_or_default(bcx.ccx(),\n-                                                     impl_did,\n-                                                     mname);\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, impl_did, callee_id,\n+                    bcx, mth_id, callee_id,\n                     *rcvr_substs, rcvr_origins);\n \n             let FnData {llfn: lval} =\n@@ -334,58 +330,22 @@ pub fn trans_static_method_callee(bcx: block,\n     }\n }\n \n-pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n-    -> Option<ast::def_id> {\n-    ms.iter().find_(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n-}\n-\n-pub fn method_with_name_or_default(ccx: &mut CrateContext,\n-                                   impl_id: ast::def_id,\n-                                   name: ast::ident) -> ast::def_id {\n-    let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n-    match imp {\n+pub fn method_with_name(ccx: &mut CrateContext,\n+                        impl_id: ast::def_id,\n+                        name: ast::ident) -> ast::def_id {\n+    let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n+    match meth_id_opt {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    // None of this feels like it should be the best way to do this.\n-    let mut did = if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get_copy(&impl_id.node) {\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref ms), _\n-            }, _) => { method_from_methods(*ms, name) },\n-            _ => fail!(\"method_with_name\")\n-        }\n-    } else {\n-        csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n-    };\n-\n-    if did.is_none() {\n-        // Look for a default method\n-        let pmm = ccx.tcx.provided_methods;\n-        match pmm.find(&impl_id) {\n-            Some(pmis) => {\n-                for pmis.iter().advance |pmi| {\n-                    if pmi.method_info.ident == name {\n-                        debug!(\"pmi.method_info.did = %?\",\n-                               pmi.method_info.did);\n-                        did = Some(pmi.method_info.did);\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    let imp = did.expect(\"could not find method while translating\");\n-    ccx.impl_method_cache.insert((impl_id, name), imp);\n-    imp\n-}\n+    let imp = ccx.tcx.impls.find(&impl_id)\n+        .expect(\"could not find impl while translating\");\n+    let meth = imp.methods.iter().find_(|m| m.ident == name)\n+        .expect(\"could not find method while translating\");\n \n-pub fn method_ty_param_count(ccx: &CrateContext, m_id: ast::def_id,\n-                             i_id: ast::def_id) -> uint {\n-    debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n-    ty::method(ccx.tcx, m_id).generics.type_param_defs.len()\n+    ccx.impl_method_cache.insert((impl_id, name), meth.def_id);\n+    meth.def_id\n }\n \n pub fn trans_monomorphized_callee(bcx: block,\n@@ -401,8 +361,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n-          let mth_id = method_with_name_or_default(\n-              bcx.ccx(), impl_did, mname);\n+          let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n \n           // obtain the `self` value:\n           let mut temp_cleanups = ~[];\n@@ -413,7 +372,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id, impl_did, callee_id,\n+                  bcx, mth_id, callee_id,\n                   *rcvr_substs, rcvr_origins);\n \n           // translate the function\n@@ -452,7 +411,6 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n pub fn combine_impl_and_methods_tps(bcx: block,\n                                     mth_did: ast::def_id,\n-                                    impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n                                     rcvr_substs: &[ty::t],\n                                     rcvr_origins: typeck::vtable_res)\n@@ -475,15 +433,16 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     * mapped to. */\n \n     let ccx = bcx.ccx();\n-    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n+    let method = ty::method(ccx.tcx, mth_did);\n+    let n_m_tps = method.generics.type_param_defs.len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"rcvr_substs=%?\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n-    debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"node_substs=%?\", node_substs.repr(ccx.tcx));\n+    debug!(\"ty_substs=%?\", ty_substs.repr(ccx.tcx));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -658,7 +617,6 @@ pub fn vtable_id(ccx: @mut CrateContext,\n             monomorphize::make_mono_id(\n                 ccx,\n                 impl_id,\n-                None,\n                 &psubsts,\n                 None)\n         }\n@@ -744,7 +702,7 @@ pub fn make_impl_vtable(bcx: block,\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    tcx.sess.str_of(im.ident));\n-            let m_id = method_with_name_or_default(ccx, impl_id, im.ident);\n+            let m_id = method_with_name(ccx, impl_id, im.ident);\n \n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn"}, {"sha": "789532abc611f1a75d808ae267deb36c6f2f2e96", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -42,7 +42,6 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n                       self_vtable: Option<typeck::vtable_origin>,\n-                      impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>)\n     -> (ValueRef, bool)\n {\n@@ -51,13 +50,11 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             real_substs=%s, \\\n             vtables=%s, \\\n             self_vtable=%s, \\\n-            impl_did_opt=%s, \\\n             ref_id=%?)\",\n            fn_id.repr(ccx.tcx),\n            real_substs.repr(ccx.tcx),\n            vtables.repr(ccx.tcx),\n            self_vtable.repr(ccx.tcx),\n-           impl_did_opt.repr(ccx.tcx),\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n@@ -83,9 +80,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, psubsts.tys.len());\n \n \n-    let hash_id = make_mono_id(ccx, fn_id, impl_did_opt,\n-                               &*psubsts,\n-                               Some(param_uses));\n+    let hash_id = make_mono_id(ccx, fn_id, &*psubsts, Some(param_uses));\n     if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n@@ -367,7 +362,6 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n \n pub fn make_mono_id(ccx: @mut CrateContext,\n                     item: ast::def_id,\n-                    impl_did_opt: Option<ast::def_id>,\n                     substs: &param_substs,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get\n@@ -442,5 +436,5 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n           }).collect()\n       }\n     };\n-    @mono_id_ {def: item, params: param_ids, impl_did_opt: impl_did_opt}\n+    @mono_id_ {def: item, params: param_ids}\n }"}, {"sha": "53c290ec0290daa9e48644402efd2d17d44e2bf0", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -90,7 +90,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     // used.  This is imprecise, but simple. Getting it right is\n     // tricky because the substs on the call and the substs on the\n     // default method differ, because of substs on the trait/impl.\n-    let is_default = ccx.tcx.provided_method_sources.contains_key(&fn_id_loc);\n+    let is_default = ty::provided_source(ccx.tcx, fn_id_loc).is_some();\n     // We also mark all of the params as used if it is an extern thing\n     // that we haven't been able to inline yet.\n     if is_default || fn_id_loc.crate != local_crate {"}, {"sha": "b63117d25bb77f829fcc2fe9d43113da0bd9a908", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -16,7 +16,6 @@ use middle::const_eval;\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::lang_items::OpaqueStructLangItem;\n use middle::freevars;\n-use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty;\n use middle::subst::Subst;\n@@ -65,7 +64,11 @@ pub struct Method {\n     fty: BareFnTy,\n     explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n-    def_id: ast::def_id\n+    def_id: ast::def_id,\n+    container_id: ast::def_id,\n+\n+    // If this method is provided, we need to know where it came from\n+    provided_source: Option<ast::def_id>\n }\n \n impl Method {\n@@ -75,7 +78,9 @@ impl Method {\n                fty: BareFnTy,\n                explicit_self: ast::explicit_self_,\n                vis: ast::visibility,\n-               def_id: ast::def_id)\n+               def_id: ast::def_id,\n+               container_id: ast::def_id,\n+               provided_source: Option<ast::def_id>)\n                -> Method {\n         // Check the invariants.\n         if explicit_self == ast::sty_static {\n@@ -91,11 +96,19 @@ impl Method {\n             fty: fty,\n             explicit_self: explicit_self,\n             vis: vis,\n-            def_id: def_id\n+            def_id: def_id,\n+            container_id: container_id,\n+            provided_source: provided_source\n         }\n     }\n }\n \n+pub struct Impl {\n+    did: def_id,\n+    ident: ident,\n+    methods: ~[@Method]\n+}\n+\n #[deriving(Clone, Eq, IterBytes)]\n pub struct mt {\n     ty: t,\n@@ -214,26 +227,6 @@ pub enum AutoRef {\n     AutoUnsafe(ast::mutability)\n }\n \n-// Stores information about provided methods (a.k.a. default methods) in\n-// implementations.\n-//\n-// This is a map from ID of each implementation to the method info and trait\n-// method ID of each of the default methods belonging to the trait that\n-// implementation implements.\n-pub type ProvidedMethodsMap = @mut HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n-\n-// Stores the method info and definition ID of the associated trait method for\n-// each instantiation of each provided method.\n-pub struct ProvidedMethodInfo {\n-    method_info: @MethodInfo,\n-    trait_method_def_id: def_id\n-}\n-\n-pub struct ProvidedMethodSource {\n-    method_id: ast::def_id,\n-    impl_id: ast::def_id\n-}\n-\n pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n@@ -287,11 +280,8 @@ struct ctxt_ {\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n-    // A mapping from an implementation ID to the method info and trait\n-    // method ID of the provided (a.k.a. default) methods in the traits that\n-    // that implementation implements.\n-    provided_methods: ProvidedMethodsMap,\n-    provided_method_sources: @mut HashMap<ast::def_id, ProvidedMethodSource>,\n+    // A mapping of fake provided method def_ids to the default implementation\n+    provided_method_sources: @mut HashMap<ast::def_id, ast::def_id>,\n     supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n@@ -303,11 +293,19 @@ struct ctxt_ {\n     // A method will be in this list if and only if it is a destructor.\n     destructors: @mut HashSet<ast::def_id>,\n \n-    // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n+    // Maps a trait onto a list of impls of that trait.\n+    trait_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n \n-    // Maps a base type to its impl\n-    base_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+    // Maps a def_id of a type to a list of its inherent impls.\n+    // Contains implementations of methods that are inherent to a type.\n+    // Methods in these implementations don't need to be exported.\n+    inherent_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+\n+    // Maps a def_id of an impl to an Impl structure.\n+    // Note that this contains all of the impls that we know about,\n+    // including ones in other crates. It's not clear that this is the best\n+    // way to do it.\n+    impls: @mut HashMap<ast::def_id, @Impl>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n@@ -902,13 +900,13 @@ pub fn mk_ctxt(s: session::Session,\n         adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n-        provided_methods: @mut HashMap::new(),\n         provided_method_sources: @mut HashMap::new(),\n         supertraits: @mut HashMap::new(),\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n-        base_impls:  @mut HashMap::new(),\n+        inherent_impls:  @mut HashMap::new(),\n+        impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n      }\n@@ -3516,6 +3514,11 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n+pub fn provided_source(cx: ctxt, id: ast::def_id)\n+    -> Option<ast::def_id> {\n+    cx.provided_method_sources.find(&id).map(|x| **x)\n+}\n+\n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[@Method] {\n     if is_local(id) {\n         match cx.items.find(&id.node) {\n@@ -3596,20 +3599,6 @@ pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n }\n \n \n-pub fn add_base_impl(cx: ctxt, base_def_id: def_id, implementation: @Impl) {\n-    let implementations;\n-    match cx.base_impls.find(&base_def_id) {\n-        None => {\n-            implementations = @mut ~[];\n-            cx.base_impls.insert(base_def_id, implementations);\n-        }\n-        Some(&existing) => {\n-            implementations = existing;\n-        }\n-    }\n-    implementations.push(implementation);\n-}\n-\n pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,\n@@ -4375,16 +4364,25 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n-// Given a trait and a type, returns the impl of that type\n-pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n+// Given a trait and a type, returns the impl of that type.\n+// This is broken, of course, by parametric impls. This used to use\n+// a table specifically for this mapping, but I removed that table.\n+// This is only used when calling a supertrait method from a default method,\n+// and should go away once I fix how that works. -sully\n+pub fn bogus_get_impl_id_from_ty(tcx: ctxt,\n+                                 trait_id: def_id, self_ty: t) -> def_id {\n     match tcx.trait_impls.find(&trait_id) {\n-        Some(ty_to_impl) => match ty_to_impl.find(&self_ty) {\n-            Some(the_impl) => the_impl.did,\n-            None => // try autoderef!\n-                match deref(tcx, self_ty, false) {\n-                    Some(some_ty) => get_impl_id(tcx, trait_id, some_ty.ty),\n-                    None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n-                                          this type\")\n+        Some(ty_to_impl) => {\n+            for ty_to_impl.iter().advance |imp| {\n+                let impl_ty = tcx.tcache.get_copy(&imp.did);\n+                if impl_ty.ty == self_ty { return imp.did; }\n+            }\n+            // try autoderef!\n+            match deref(tcx, self_ty, false) {\n+                Some(some_ty) =>\n+                  bogus_get_impl_id_from_ty(tcx, trait_id, some_ty.ty),\n+                None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n+                                      this type\")\n             }\n         },\n         None => tcx.sess.bug(\"get_impl_id: trait isn't in trait_impls\")"}, {"sha": "4a32e8bf952c1d70b0530e7bbfc154f176ba24ae", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -330,8 +330,7 @@ impl<'self> LookupContext<'self> {\n         for opt_applicable_traits.iter().advance |applicable_traits| {\n             for applicable_traits.iter().advance |trait_did| {\n                 // Look for explicit implementations.\n-                let opt_impl_infos =\n-                    self.fcx.ccx.coherence_info.extension_methods.find(trait_did);\n+                let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n                 for opt_impl_infos.iter().advance |impl_infos| {\n                     for impl_infos.iter().advance |impl_info| {\n                         self.push_candidates_from_impl(\n@@ -517,8 +516,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n-        let opt_impl_infos =\n-            self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n+        let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for opt_impl_infos.iter().advance |impl_infos| {\n             for impl_infos.iter().advance |impl_info| {\n                 self.push_candidates_from_impl(\n@@ -529,7 +527,7 @@ impl<'self> LookupContext<'self> {\n \n     pub fn push_candidates_from_impl(&self,\n                                      candidates: &mut ~[Candidate],\n-                                     impl_info: &resolve::Impl) {\n+                                     impl_info: &ty::Impl) {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n@@ -545,7 +543,7 @@ impl<'self> LookupContext<'self> {\n             }\n         };\n \n-        let method = ty::method(self.tcx(), impl_info.methods[idx].did);\n+        let method = ty::method(self.tcx(), impl_info.methods[idx].def_id);\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:"}, {"sha": "6af0be48e47d8cd48ef57ab0f9539c6dfd8d305f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -260,7 +260,7 @@ fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashSet::new();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(&trait_ref.def_id) {\n+            match tcx.trait_impls.find(&trait_ref.def_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }"}, {"sha": "c822536586453ed12eabfc415f4d1300293f6909", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 79, "deletions": 245, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -17,10 +17,9 @@\n \n use metadata::csearch::{each_path, get_impl_trait};\n use metadata::csearch;\n-use metadata::cstore::{CStore, iter_crate_data};\n+use metadata::cstore::iter_crate_data;\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n-use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, get};\n+use middle::ty::get;\n use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n@@ -31,14 +30,15 @@ use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n use middle::ty::{type_is_ty_var};\n use middle::subst::Subst;\n use middle::ty;\n+use middle::ty::{Impl, Method};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use syntax::ast::{crate, def_id, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n-use syntax::ast::{local_crate, method, trait_ref, ty_path};\n+use syntax::ast::{local_crate, trait_ref, ty_path};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n@@ -149,33 +149,6 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n     }\n }\n \n-\n-pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n-    @MethodInfo {\n-        did: local_def(ast_method.id),\n-        n_tps: ast_method.generics.ty_params.len(),\n-        ident: ast_method.ident,\n-        explicit_self: ast_method.explicit_self.node\n-    }\n-}\n-\n-pub struct CoherenceInfo {\n-    // Contains implementations of methods that are inherent to a type.\n-    // Methods in these implementations don't need to be exported.\n-    inherent_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n-\n-    // Contains implementations of methods associated with a trait. For these,\n-    // the associated trait must be imported at the call site.\n-    extension_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n-}\n-\n-pub fn CoherenceInfo() -> CoherenceInfo {\n-    CoherenceInfo {\n-        inherent_methods: @mut HashMap::new(),\n-        extension_methods: @mut HashMap::new(),\n-    }\n-}\n-\n pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n@@ -267,27 +240,16 @@ impl CoherenceChecker {\n             }\n         }\n \n-        // We only want to generate one Impl structure. When we generate one,\n-        // we store it here so that we don't recreate it.\n-        let mut implementation_opt = None;\n+        let implementation = self.create_impl_from_item(item);\n+\n         for associated_traits.iter().advance |associated_trait| {\n-            let trait_ref =\n-                ty::node_id_to_trait_ref(\n-                    self.crate_context.tcx,\n-                    associated_trait.ref_id);\n+            let trait_ref = ty::node_id_to_trait_ref(\n+                self.crate_context.tcx, associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n-            self.instantiate_default_methods(local_def(item.id), trait_ref);\n-\n-            let implementation;\n-            if implementation_opt.is_none() {\n-                implementation = self.create_impl_from_item(item);\n-                implementation_opt = Some(implementation);\n-            }\n-\n-            self.add_trait_method(trait_ref.def_id, implementation_opt.get());\n+            self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -302,33 +264,24 @@ impl CoherenceChecker {\n             Some(base_type_def_id) => {\n                 // XXX: Gather up default methods?\n                 if associated_traits.len() == 0 {\n-                    let implementation;\n-                    match implementation_opt {\n-                        None => {\n-                            implementation =\n-                                self.create_impl_from_item(item);\n-                        }\n-                        Some(existing_implementation) => {\n-                            implementation = existing_implementation;\n-                        }\n-                    }\n-\n-                    self.add_inherent_method(base_type_def_id,\n-                                             implementation);\n+                    self.add_inherent_impl(base_type_def_id, implementation);\n                 }\n \n                 self.base_type_def_ids.insert(local_def(item.id),\n                                               base_type_def_id);\n             }\n         }\n+\n+        tcx.impls.insert(implementation.did, implementation);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     pub fn instantiate_default_methods(&self,\n                                        impl_id: ast::def_id,\n-                                       trait_ref: &ty::TraitRef) {\n+                                       trait_ref: &ty::TraitRef,\n+                                       all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n                impl_id, trait_ref.repr(tcx));\n@@ -350,9 +303,11 @@ impl CoherenceChecker {\n                     impl_id,\n                     trait_ref,\n                     new_did,\n-                    *trait_method);\n+                    *trait_method,\n+                    Some(trait_method.def_id));\n \n             debug!(\"new_method_ty=%s\", new_method_ty.repr(tcx));\n+            all_methods.push(new_method_ty);\n \n             // construct the polytype for the method based on the method_ty\n             let new_generics = ty::Generics {\n@@ -374,79 +329,38 @@ impl CoherenceChecker {\n \n             // Pair the new synthesized ID up with the\n             // ID of the method.\n-            let source = ProvidedMethodSource {\n-                method_id: trait_method.def_id,\n-                impl_id: impl_id\n-            };\n-\n-            self.crate_context.tcx.provided_method_sources.insert(new_did,\n-                                                                  source);\n-\n-            let provided_method_info =\n-                @ProvidedMethodInfo {\n-                    method_info: @MethodInfo {\n-                        did: new_did,\n-                        n_tps: trait_method.generics.type_param_defs.len(),\n-                        ident: trait_method.ident,\n-                        explicit_self: trait_method.explicit_self\n-                    },\n-                    trait_method_def_id: trait_method.def_id\n-                };\n-\n-            let pmm = self.crate_context.tcx.provided_methods;\n-            match pmm.find(&impl_id) {\n-                Some(&mis) => {\n-                    // If the trait already has an entry in the\n-                    // provided_methods_map, we just need to add this\n-                    // method to that entry.\n-                    debug!(\"(checking implementation) adding method `%s` \\\n-                            to entry for existing trait\",\n-                            self.crate_context.tcx.sess.str_of(\n-                                provided_method_info.method_info.ident));\n-                    mis.push(provided_method_info);\n-                }\n-                None => {\n-                    // If the trait doesn't have an entry yet, create one.\n-                    debug!(\"(checking implementation) creating new entry \\\n-                            for method `%s`\",\n-                            self.crate_context.tcx.sess.str_of(\n-                                provided_method_info.method_info.ident));\n-                    pmm.insert(impl_id,\n-                               @mut ~[provided_method_info]);\n-                }\n-            }\n+            self.crate_context.tcx.provided_method_sources\n+                .insert(new_did, trait_method.def_id);\n         }\n     }\n \n-    pub fn add_inherent_method(&self,\n-                               base_def_id: def_id,\n-                               implementation: @Impl) {\n+    pub fn add_inherent_impl(&self,\n+                             base_def_id: def_id,\n+                             implementation: @Impl) {\n+        let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match self.crate_context.coherence_info.inherent_methods\n-                  .find(&base_def_id) {\n+        match tcx.inherent_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @mut ~[];\n-                self.crate_context.coherence_info.inherent_methods\n-                    .insert(base_def_id, implementation_list);\n+                tcx.inherent_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n         implementation_list.push(implementation);\n-\n-        ty::add_base_impl(self.crate_context.tcx, base_def_id, implementation);\n     }\n \n-    pub fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {\n+    pub fn add_trait_impl(&self,\n+                          base_def_id: def_id,\n+                          implementation: @Impl) {\n+        let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match self.crate_context.coherence_info.extension_methods\n-                  .find(&trait_id) {\n+        match tcx.trait_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @mut ~[];\n-                self.crate_context.coherence_info.extension_methods\n-                    .insert(trait_id, implementation_list);\n+                tcx.trait_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n@@ -457,8 +371,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        let coherence_info = &self.crate_context.coherence_info;\n-        for coherence_info.extension_methods.each_key |&trait_id| {\n+        for self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -472,8 +385,6 @@ impl CoherenceChecker {\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n             // and that impl is <implementation_a>\"\n-            self.add_impl_for_trait(trait_def_id, polytype_a.ty,\n-                                    implementation_a);\n             do self.iter_impls_of_trait(trait_def_id) |b| {\n                 let implementation_b = b;\n \n@@ -494,32 +405,8 @@ impl CoherenceChecker {\n         }\n     }\n \n-    // Adds an impl of trait trait_t for self type self_t; that impl\n-    // is the_impl\n-    pub fn add_impl_for_trait(&self,\n-                              trait_t: def_id,\n-                              self_t: t,\n-                              the_impl: @Impl) {\n-        debug!(\"Adding impl %? of %? for %s\",\n-               the_impl.did, trait_t,\n-               ty_to_str(self.crate_context.tcx, self_t));\n-        match self.crate_context.tcx.trait_impls.find(&trait_t) {\n-            None => {\n-                let m = @mut HashMap::new();\n-                m.insert(self_t, the_impl);\n-                self.crate_context.tcx.trait_impls.insert(trait_t, m);\n-            }\n-            Some(&m) => {\n-                m.insert(self_t, the_impl);\n-            }\n-        }\n-    }\n-\n     pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n-        let coherence_info = &self.crate_context.coherence_info;\n-        let extension_methods = &*coherence_info.extension_methods;\n-\n-        match extension_methods.find(&trait_def_id) {\n+        match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n                 for impls.iter().advance |&im| {\n                     f(im);\n@@ -653,13 +540,11 @@ impl CoherenceChecker {\n \n     // This check doesn't really have anything to do with coherence. It's\n     // here for historical reasons\n-    pub fn please_check_that_trait_methods_are_implemented(&self,\n-                                                           all_methods:\n-                                                           &mut\n-                                                           ~[@MethodInfo],\n-                                                           trait_did: def_id,\n-                                                           trait_ref_span:\n-                                                           span) {\n+    pub fn check_trait_methods_are_implemented(\n+        &self,\n+        all_methods: &mut ~[@Method],\n+        trait_did: def_id,\n+        trait_ref_span: span) {\n \n         let tcx = self.crate_context.tcx;\n \n@@ -668,12 +553,6 @@ impl CoherenceChecker {\n         for uint::range(0, all_methods.len()) |i| {\n             provided_names.insert(all_methods[i].ident);\n         }\n-        // Default methods\n-        let r = ty::provided_trait_methods(tcx, trait_did);\n-        for r.iter().advance |method| {\n-            debug!(\"inserting provided method %s\", method.ident.repr(tcx));\n-            provided_names.insert(method.ident);\n-        }\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for r.iter().advance |method| {\n@@ -726,70 +605,33 @@ impl CoherenceChecker {\n         }\n     }\n \n-    fn add_provided_methods_to_impl(\n-        &self,\n-        all_methods: &mut ~[@MethodInfo],\n-        trait_did: &ast::def_id,\n-        impl_id: &ast::def_id) {\n-\n-\n-        match self.crate_context.tcx\n-            .provided_methods\n-            .find(impl_id) {\n-                None => {\n-                    debug!(\"(creating impl) trait with node_id `%d` \\\n-                            has no provided methods\", trait_did.node);\n-                    /* fall through */\n-                }\n-                Some(&all_provided_methods) => {\n-                    debug!(\"(creating impl) trait with node_id `%d` \\\n-                            has provided methods\", trait_did.node);\n-                    // Add all provided methods.\n-                    for all_provided_methods.iter().advance |provided_method| {\n-                        debug!(\n-                            \"(creating impl) adding provided method \\\n-                             `%s` to impl\",\n-                            provided_method.method_info\n-                            .ident.repr(self.crate_context.tcx));\n-                        all_methods.push(provided_method.method_info);\n-                    }\n-                }\n-            }\n-\n-\n-    }\n-\n     // Converts an implementation in the AST to an Impl structure.\n     pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n+        let tcx = self.crate_context.tcx;\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n                 for ast_methods.iter().advance |ast_method| {\n-                    methods.push(method_to_MethodInfo(*ast_method));\n+                    methods.push(ty::method(tcx, local_def(ast_method.id)));\n                 }\n \n-                // Check that we have implementations of every trait method\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did =\n-                        self.trait_ref_to_trait_def_id(trait_ref);\n-                    self.please_check_that_trait_methods_are_implemented(\n+                    let ty_trait_ref = ty::node_id_to_trait_ref(\n+                        self.crate_context.tcx,\n+                        trait_ref.ref_id);\n+                    let trait_did = ty_trait_ref.def_id;\n+\n+                    self.instantiate_default_methods(local_def(item.id),\n+                                                     ty_trait_ref,\n+                                                     &mut methods);\n+\n+                    // Check that we have implementations of every trait method\n+                    self.check_trait_methods_are_implemented(\n                         &mut methods,\n                         trait_did,\n                         trait_ref.path.span);\n                 }\n \n-                // For each trait that the impl implements, see which\n-                // methods are provided.  For each of those methods,\n-                // if a method of that name is not inherent to the\n-                // impl, use the provided definition in the trait.\n-                for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n-                    self.add_provided_methods_to_impl(\n-                        &mut methods,\n-                        &trait_did,\n-                        &local_def(item.id));\n-                }\n-\n                 return @Impl {\n                     did: local_def(item.id),\n                     ident: item.ident,\n@@ -820,12 +662,12 @@ impl CoherenceChecker {\n \n     pub fn add_external_impl(&self,\n                              impls_seen: &mut HashSet<def_id>,\n-                             crate_store: @mut CStore,\n                              impl_def_id: def_id) {\n-        let implementation = csearch::get_impl(crate_store, impl_def_id);\n+        let tcx = self.crate_context.tcx;\n+        let implementation = @csearch::get_impl(tcx, impl_def_id);\n \n         debug!(\"coherence: adding impl from external crate: %s\",\n-               ty::item_path_str(self.crate_context.tcx, implementation.did));\n+               ty::item_path_str(tcx, implementation.did));\n \n         // Make sure we don't visit the same implementation multiple times.\n         if !impls_seen.insert(implementation.did) {\n@@ -834,9 +676,8 @@ impl CoherenceChecker {\n         }\n         // Good. Continue.\n \n-        let self_type = lookup_item_type(self.crate_context.tcx,\n-                                         implementation.did);\n-        let associated_traits = get_impl_trait(self.crate_context.tcx,\n+        let self_type = lookup_item_type(tcx, implementation.did);\n+        let associated_traits = get_impl_trait(tcx,\n                                                implementation.did);\n \n         // Do a sanity check to make sure that inherent methods have base\n@@ -846,35 +687,26 @@ impl CoherenceChecker {\n                                        dummy_sp(),\n                                        self_type.ty) {\n                 None => {\n-                    let session = self.crate_context.tcx.sess;\n-                    session.bug(fmt!(\"no base type for external impl with no \\\n+                    tcx.sess.bug(fmt!(\"no base type for external impl with no \\\n                                       trait: %s (type %s)!\",\n-                                     session.str_of(implementation.ident),\n-                                     ty_to_str(self.crate_context.tcx,\n-                                               self_type.ty)));\n+                                     tcx.sess.str_of(implementation.ident),\n+                                     ty_to_str(tcx, self_type.ty)));\n                 }\n                 Some(_) => {} // Nothing to do.\n             }\n         }\n \n         // Record all the trait methods.\n-        let mut implementation = @implementation;\n         for associated_traits.iter().advance |trait_ref| {\n-            self.instantiate_default_methods(implementation.did,\n-                                             *trait_ref);\n-\n-            // XXX(sully): We could probably avoid this copy if there are no\n-            // default methods.\n-            let mut methods = implementation.methods.clone();\n-            self.add_provided_methods_to_impl(&mut methods,\n-                                              &trait_ref.def_id,\n-                                              &implementation.did);\n-            implementation = @Impl {\n-                methods: methods,\n-                ..*implementation\n-            };\n+              self.add_trait_impl(trait_ref.def_id, implementation);\n+        }\n \n-            self.add_trait_method(trait_ref.def_id, implementation);\n+        // For any methods that use a default implementation, add them to\n+        // the map. This is a bit unfortunate.\n+        for implementation.methods.iter().advance |method| {\n+            for method.provided_source.iter().advance |source| {\n+                tcx.provided_method_sources.insert(method.def_id, *source);\n+            }\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -887,14 +719,16 @@ impl CoherenceChecker {\n                 // inherent methods apply to `impl Type` but not\n                 // `impl Trait for Type`:\n                 if associated_traits.is_none() {\n-                    self.add_inherent_method(base_type_def_id,\n-                                             implementation);\n+                    self.add_inherent_impl(base_type_def_id,\n+                                           implementation);\n                 }\n \n                 self.base_type_def_ids.insert(implementation.did,\n                                               base_type_def_id);\n             }\n         }\n+\n+        tcx.impls.insert(implementation.did, implementation);\n     }\n \n     // Adds implementations and traits from external crates to the coherence\n@@ -907,9 +741,7 @@ impl CoherenceChecker {\n             for each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n                     dl_impl(def_id) => {\n-                        self.add_external_impl(&mut impls_seen,\n-                                               crate_store,\n-                                               def_id)\n+                        self.add_external_impl(&mut impls_seen, def_id)\n                     }\n                     dl_def(_) | dl_field => loop,   // Skip this.\n                 }\n@@ -922,12 +754,11 @@ impl CoherenceChecker {\n     //\n \n     pub fn populate_destructor_table(&self) {\n-        let coherence_info = &self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n-        let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n+        let impls_opt = tcx.trait_impls.find(&drop_trait);\n \n         let impls;\n         match impls_opt {\n@@ -940,7 +771,7 @@ impl CoherenceChecker {\n                 // We'll error out later. For now, just don't ICE.\n                 loop;\n             }\n-            let method_def_id = impl_info.methods[0].did;\n+            let method_def_id = impl_info.methods[0].def_id;\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n@@ -1024,7 +855,8 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n                                      impl_id: ast::def_id,\n                                      trait_ref: &ty::TraitRef,\n                                      new_def_id: ast::def_id,\n-                                     method: &ty::Method)\n+                                     method: &ty::Method,\n+                                     provided_source: Option<ast::def_id>)\n                                      -> ty::Method {\n \n     let combined_substs = make_substs_for_receiver_types(\n@@ -1044,7 +876,9 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n \n         method.explicit_self,\n         method.vis,\n-        new_def_id\n+        new_def_id,\n+        impl_id,\n+        provided_source\n     )\n }\n "}, {"sha": "1941317ede5fe900022bd10b388afa35ab59add6", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -376,7 +376,9 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n             ast::public,\n-            local_def(*m_id)\n+            local_def(*m_id),\n+            local_def(trait_id),\n+            None\n         )\n     }\n }\n@@ -720,6 +722,7 @@ pub struct ConvertedMethod {\n }\n \n pub fn convert_methods(ccx: &CrateCtxt,\n+                       container_id: ast::node_id,\n                        ms: &[@ast::method],\n                        untransformed_rcvr_ty: ty::t,\n                        rcvr_ty_generics: &ty::Generics,\n@@ -734,7 +737,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n                         num_rcvr_ty_params);\n         let mty =\n-            @ty_of_method(ccx, *m, rcvr_ty_generics.region_param,\n+            @ty_of_method(ccx, container_id, *m, rcvr_ty_generics.region_param,\n                           untransformed_rcvr_ty,\n                           rcvr_ast_generics, rcvr_visibility,\n                           &m.generics);\n@@ -760,6 +763,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n     }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n+                    container_id: ast::node_id,\n                     m: &ast::method,\n                     rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n@@ -790,7 +794,9 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             fty,\n             m.explicit_self.node,\n             method_vis,\n-            local_def(m.id)\n+            local_def(m.id),\n+            local_def(container_id),\n+            None\n         )\n     }\n }\n@@ -849,7 +855,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx, *ms, selfty,\n+        let cms = convert_methods(ccx, it.id, *ms, selfty,\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n         for opt_trait_ref.iter().advance |t| {\n@@ -867,7 +873,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n           let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n                                                 Some(untransformed_rcvr_ty));\n-          let _ = convert_methods(ccx, provided_methods,\n+          let _ = convert_methods(ccx, it.id, provided_methods,\n                                   untransformed_rcvr_ty,\n                                   &ty_generics, generics,\n                                   it.vis);"}, {"sha": "bfbebd0a52e9d0abe008104ed599d746fb8c7867", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -192,7 +192,6 @@ pub struct CrateCtxt {\n     trait_map: resolve::TraitMap,\n     method_map: method_map,\n     vtable_map: vtable_map,\n-    coherence_info: coherence::CoherenceInfo,\n     tcx: ty::ctxt\n }\n \n@@ -415,7 +414,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         trait_map: trait_map,\n         method_map: @mut HashMap::new(),\n         vtable_map: @mut HashMap::new(),\n-        coherence_info: coherence::CoherenceInfo(),\n         tcx: tcx\n     };\n "}, {"sha": "2d4f539f82bbdd40faeca00314a101081328beab", "filename": "src/test/auxiliary/trait_default_method_xc_aux_2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux_2.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:trait_default_method_xc_aux.rs\n+\n+extern mod aux(name = \"trait_default_method_xc_aux\");\n+use aux::A;\n+\n+pub struct a_struct { x: int }\n+\n+impl A for a_struct {\n+    fn f(&self) -> int { 10 }\n+}\n+\n+// This function will need to get inlined, and badness may result.\n+pub fn welp<A>(x: A) -> A {\n+    let a = a_struct { x: 0 };\n+    a.g();\n+    x\n+}"}, {"sha": "1dad5d23b8823205c269dfc376b89d05a1e8717d", "filename": "src/test/run-pass/trait-default-method-xc-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a1db2d1e631feede472396fced1806dfd3cf677/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc-2.rs?ref=3a1db2d1e631feede472396fced1806dfd3cf677", "patch": "@@ -0,0 +1,25 @@\n+// xfail-fast\n+// aux-build:trait_default_method_xc_aux.rs\n+// aux-build:trait_default_method_xc_aux_2.rs\n+\n+\n+extern mod aux(name = \"trait_default_method_xc_aux\");\n+extern mod aux2(name = \"trait_default_method_xc_aux_2\");\n+use aux::A;\n+use aux2::{a_struct, welp};\n+\n+\n+fn main () {\n+\n+    let a = a_struct { x: 0 };\n+    let b = a_struct { x: 1 };\n+\n+    assert_eq!(0i.g(), 10);\n+    assert_eq!(a.g(), 10);\n+    assert_eq!(a.h(), 11);\n+    assert_eq!(b.g(), 10);\n+    assert_eq!(b.h(), 11);\n+    assert_eq!(A::lurr(&a, &b), 21);\n+\n+    welp(&0);\n+}"}]}