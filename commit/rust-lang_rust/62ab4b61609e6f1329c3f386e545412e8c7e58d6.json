{"sha": "62ab4b61609e6f1329c3f386e545412e8c7e58d6", "node_id": "C_kwDOAAsO6NoAKDYyYWI0YjYxNjA5ZTZmMTMyOWMzZjM4NmU1NDU0MTJlOGM3ZTU4ZDY", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-07-03T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2022-07-08T07:23:35Z"}, "message": "Fix unreachable coverage generation for inlined functions\n\nTo generate a function coverage we need at least one coverage counter,\nso a coverage from unreachable blocks is retained only when some live\ncounters remain.\n\nThe previous implementation incorrectly retained unreachable coverage,\nbecause it didn't account for the fact that those live counters can\nbelong to another function due to inlining.", "tree": {"sha": "b2626b00ad57a7e75fe61b89609a3d04ec04054f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2626b00ad57a7e75fe61b89609a3d04ec04054f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62ab4b61609e6f1329c3f386e545412e8c7e58d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62ab4b61609e6f1329c3f386e545412e8c7e58d6", "html_url": "https://github.com/rust-lang/rust/commit/62ab4b61609e6f1329c3f386e545412e8c7e58d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62ab4b61609e6f1329c3f386e545412e8c7e58d6/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fadae872fabd317020eeefbb118d8e07e5e43994", "url": "https://api.github.com/repos/rust-lang/rust/commits/fadae872fabd317020eeefbb118d8e07e5e43994", "html_url": "https://github.com/rust-lang/rust/commit/fadae872fabd317020eeefbb118d8e07e5e43994"}], "stats": {"total": 125, "additions": 90, "deletions": 35}, "files": [{"sha": "59c38b87b5cb243bfcdcf17fdb5e06100e66311d", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/62ab4b61609e6f1329c3f386e545412e8c7e58d6/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ab4b61609e6f1329c3f386e545412e8c7e58d6/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=62ab4b61609e6f1329c3f386e545412e8c7e58d6", "patch": "@@ -28,6 +28,7 @@\n //! return.\n \n use crate::MirPass;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -267,7 +268,8 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         return;\n     }\n \n-    let basic_blocks = body.basic_blocks_mut();\n+    let basic_blocks = body.basic_blocks.as_mut();\n+    let source_scopes = &body.source_scopes;\n     let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n     let mut used_blocks = 0;\n     for alive_index in reachable.iter() {\n@@ -282,7 +284,7 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     }\n \n     if tcx.sess.instrument_coverage() {\n-        save_unreachable_coverage(basic_blocks, used_blocks);\n+        save_unreachable_coverage(basic_blocks, source_scopes, used_blocks);\n     }\n \n     basic_blocks.raw.truncate(used_blocks);\n@@ -311,48 +313,54 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n /// `Unreachable` coverage statements. These are non-executable statements whose\n /// code regions are still recorded in the coverage map, representing regions\n /// with `0` executions.\n+///\n+/// If there are no live `Counter` `Coverage` statements remaining, we remove\n+/// dead `Coverage` statements along with the dead blocks. Since at least one\n+/// counter per function is required by LLVM (and necessary, to add the\n+/// `function_hash` to the counter's call to the LLVM intrinsic\n+/// `instrprof.increment()`).\n+///\n+/// The `generator::StateTransform` MIR pass and MIR inlining can create\n+/// atypical conditions, where all live `Counter`s are dropped from the MIR.\n+///\n+/// With MIR inlining we can have coverage counters belonging to different\n+/// instances in a single body, so the strategy described above is applied to\n+/// coverage counters from each instance individually.\n fn save_unreachable_coverage(\n     basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n     first_dead_block: usize,\n ) {\n-    let has_live_counters = basic_blocks.raw[0..first_dead_block].iter().any(|live_block| {\n-        live_block.statements.iter().any(|statement| {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                matches!(coverage.kind, CoverageKind::Counter { .. })\n-            } else {\n-                false\n-            }\n-        })\n-    });\n-    if !has_live_counters {\n-        // If there are no live `Counter` `Coverage` statements anymore, don't\n-        // move dead coverage to the `START_BLOCK`. Just allow the dead\n-        // `Coverage` statements to be dropped with the dead blocks.\n-        //\n-        // The `generator::StateTransform` MIR pass can create atypical\n-        // conditions, where all live `Counter`s are dropped from the MIR.\n-        //\n-        // At least one Counter per function is required by LLVM (and necessary,\n-        // to add the `function_hash` to the counter's call to the LLVM\n-        // intrinsic `instrprof.increment()`).\n+    // Identify instances that still have some live coverage counters left.\n+    let mut live = FxHashSet::default();\n+    for basic_block in &basic_blocks.raw[0..first_dead_block] {\n+        for statement in &basic_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let CoverageKind::Counter { .. } = coverage.kind else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            live.insert(instance);\n+        }\n+    }\n+\n+    if live.is_empty() {\n         return;\n     }\n \n-    // Retain coverage info for dead blocks, so coverage reports will still\n-    // report `0` executions for the uncovered code regions.\n-    let mut dropped_coverage = Vec::new();\n-    for dead_block in basic_blocks.raw[first_dead_block..].iter() {\n-        for statement in dead_block.statements.iter() {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                if let Some(code_region) = &coverage.code_region {\n-                    dropped_coverage.push((statement.source_info, code_region.clone()));\n-                }\n+    // Retain coverage for instances that still have some live counters left.\n+    let mut retained_coverage = Vec::new();\n+    for dead_block in &basic_blocks.raw[first_dead_block..] {\n+        for statement in &dead_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let Some(code_region) = &coverage.code_region else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            if live.contains(&instance) {\n+                retained_coverage.push((statement.source_info, code_region.clone()));\n             }\n         }\n     }\n \n     let start_block = &mut basic_blocks[START_BLOCK];\n-    start_block.statements.extend(dropped_coverage.into_iter().map(\n+    start_block.statements.extend(retained_coverage.into_iter().map(\n         |(source_info, code_region)| Statement {\n             source_info,\n             kind: StatementKind::Coverage(Box::new(Coverage {"}, {"sha": "a1061dbf67fbd3bb7772ef64372dd0e5237668e9", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62ab4b61609e6f1329c3f386e545412e8c7e58d6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ab4b61609e6f1329c3f386e545412e8c7e58d6/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=62ab4b61609e6f1329c3f386e545412e8c7e58d6", "patch": "@@ -98,6 +98,7 @@ mod merging;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n use rustc_hir::def_id::DefIdSet;\n+use rustc_middle::mir;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -479,9 +480,14 @@ fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSe\n                 if !visited.insert(did) {\n                     continue;\n                 }\n-                for scope in &tcx.instance_mir(instance.def).source_scopes {\n-                    if let Some((ref inlined, _)) = scope.inlined {\n-                        result.insert(inlined.def_id());\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d102d9ecf7d14f53b4cc970cc03903dfa4c830e1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline-dead.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62ab4b61609e6f1329c3f386e545412e8c7e58d6/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "raw_url": "https://github.com/rust-lang/rust/raw/62ab4b61609e6f1329c3f386e545412e8c7e58d6/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt?ref=62ab4b61609e6f1329c3f386e545412e8c7e58d6", "patch": "@@ -0,0 +1,21 @@\n+    1|       |// Regression test for issue #98833.\n+    2|       |// compile-flags: -Zinline-mir\n+    3|       |\n+    4|      1|fn main() {\n+    5|      1|    println!(\"{}\", live::<false>());\n+    6|      1|}\n+    7|       |\n+    8|       |#[inline]\n+    9|      1|fn live<const B: bool>() -> u32 {\n+   10|      1|    if B {\n+   11|      0|        dead()\n+   12|       |    } else {\n+   13|      1|        0\n+   14|       |    }\n+   15|      1|}\n+   16|       |\n+   17|       |#[inline]\n+   18|      0|fn dead() -> u32 {\n+   19|      0|    42\n+   20|      0|}\n+"}, {"sha": "cd1ae911a5f7e44dc8037a818862907dfb4e2277", "filename": "src/test/run-make-fulldeps/coverage/inline-dead.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62ab4b61609e6f1329c3f386e545412e8c7e58d6/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ab4b61609e6f1329c3f386e545412e8c7e58d6/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs?ref=62ab4b61609e6f1329c3f386e545412e8c7e58d6", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for issue #98833.\n+// compile-flags: -Zinline-mir\n+\n+fn main() {\n+    println!(\"{}\", live::<false>());\n+}\n+\n+#[inline]\n+fn live<const B: bool>() -> u32 {\n+    if B {\n+        dead()\n+    } else {\n+        0\n+    }\n+}\n+\n+#[inline]\n+fn dead() -> u32 {\n+    42\n+}"}]}