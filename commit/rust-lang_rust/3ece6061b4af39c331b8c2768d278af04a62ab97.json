{"sha": "3ece6061b4af39c331b8c2768d278af04a62ab97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlY2U2MDYxYjRhZjM5YzMzMWI4YzI3NjhkMjc4YWYwNGE2MmFiOTc=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-18T22:04:59Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-18T22:04:59Z"}, "message": "DRAFT: coverage of async function bodies should match non-async\n\nThe initial commit demonstrates the issue, but the fix is not yet\nimplemented.\n\nOnce corrected...\n\nFixes: #83985", "tree": {"sha": "49efbf034f21399239af793c3319481dea4861a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49efbf034f21399239af793c3319481dea4861a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ece6061b4af39c331b8c2768d278af04a62ab97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ece6061b4af39c331b8c2768d278af04a62ab97", "html_url": "https://github.com/rust-lang/rust/commit/3ece6061b4af39c331b8c2768d278af04a62ab97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ece6061b4af39c331b8c2768d278af04a62ab97/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83ca4b7e600241850e61be48dee859f1604de50d", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ca4b7e600241850e61be48dee859f1604de50d", "html_url": "https://github.com/rust-lang/rust/commit/83ca4b7e600241850e61be48dee859f1604de50d"}], "stats": {"total": 206, "additions": 204, "deletions": 2}, "files": [{"sha": "ae9487473d0ca9bbf761601ffa6c7fbde242ab59", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt?ref=3ece6061b4af39c331b8c2768d278af04a62ab97", "patch": "@@ -1,6 +1,6 @@\n     1|       |#![allow(unused_assignments, dead_code)]\n     2|       |\n-    3|       |// compile-flags: --edition=2018 -C opt-level=1 # fix in rustc_mir/monomorphize/partitioning/mod.rs\n+    3|       |// compile-flags: --edition=2018 -C opt-level=1\n     4|       |\n     5|      1|async fn c(x: u8) -> u8 {\n     6|      1|    if x == 8 {"}, {"sha": "d1adabe8ebc6d2a35c4663b56cb9121abe2bb0d9", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=3ece6061b4af39c331b8c2768d278af04a62ab97", "patch": "@@ -0,0 +1,124 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |\n+    3|       |use core::{\n+    4|       |    future::Future,\n+    5|       |    marker::Send,\n+    6|       |    pin::Pin,\n+    7|       |};\n+    8|       |\n+    9|      1|fn non_async_func() {\n+   10|      1|    println!(\"non_async_func was covered\");\n+   11|      1|    let b = true;\n+   12|      1|    if b {\n+   13|      1|        println!(\"non_async_func println in block\");\n+   14|      1|    }\n+   15|      1|}\n+   16|       |\n+   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include\n+   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n+   19|       |// non-async function above, unless the `println!()` is inside a covered block.\n+   20|      1|async fn async_func() {\n+   21|       |    println!(\"async_func was covered\");\n+   22|       |    let b = true;\n+   23|      1|    if b {\n+   24|      1|        println!(\"async_func println in block\");\n+   25|      1|    }\n+                   ^0\n+   26|      1|}\n+   27|       |\n+   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n+   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n+   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n+   31|      1|async fn async_func_just_println() {\n+   32|       |    println!(\"async_func_just_println was covered\");\n+   33|       |}\n+   34|       |\n+   35|      1|fn main() {\n+   36|      1|    println!(\"codecovsample::main\");\n+   37|      1|\n+   38|      1|    non_async_func();\n+   39|      1|\n+   40|      1|    executor::block_on(async_func());\n+   41|      1|    executor::block_on(async_func_just_println());\n+   42|      1|\n+   43|      1|    // let mut future = Box::pin(async_func());\n+   44|      1|    // executor::block_on(future.as_mut());\n+   45|      1|\n+   46|      1|    // let mut future = Box::pin(async_func());\n+   47|      1|    // executor::block_on(future.as_mut());\n+   48|      1|\n+   49|      1|    // let mut future = Box::pin(async_func_just_println());\n+   50|      1|    // executor::block_on(future.as_mut());\n+   51|      1|}\n+   52|       |\n+   53|       |mod executor {\n+   54|       |    use core::{\n+   55|       |        future::Future,\n+   56|       |        pin::Pin,\n+   57|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+   58|       |    };\n+   59|       |\n+   60|      2|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+   61|      2|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+   62|      2|        use std::hint::unreachable_unchecked;\n+   63|      2|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+   64|      2|            |_| unsafe { unreachable_unchecked() }, // clone\n+                              ^0\n+   65|      2|            |_| unsafe { unreachable_unchecked() }, // wake\n+                              ^0\n+   66|      2|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+                              ^0\n+   67|      2|            |_| (),\n+   68|      2|        );\n+   69|      2|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+   70|      2|        let mut context = Context::from_waker(&waker);\n+   71|       |\n+   72|       |        loop {\n+   73|      2|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+   74|      2|                break val;\n+   75|      0|            }\n+   76|       |        }\n+   77|      2|    }\n+  ------------------\n+  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func::{closure#0}>>:\n+  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   62|      1|        use std::hint::unreachable_unchecked;\n+  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   67|      1|            |_| (),\n+  |   68|      1|        );\n+  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   70|      1|        let mut context = Context::from_waker(&waker);\n+  |   71|       |\n+  |   72|       |        loop {\n+  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   74|      1|                break val;\n+  |   75|      0|            }\n+  |   76|       |        }\n+  |   77|      1|    }\n+  ------------------\n+  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func_just_println::{closure#0}>>:\n+  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   62|      1|        use std::hint::unreachable_unchecked;\n+  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   67|      1|            |_| (),\n+  |   68|      1|        );\n+  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   70|      1|        let mut context = Context::from_waker(&waker);\n+  |   71|       |\n+  |   72|       |        loop {\n+  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   74|      1|                break val;\n+  |   75|      0|            }\n+  |   76|       |        }\n+  |   77|      1|    }\n+  ------------------\n+   78|       |}\n+"}, {"sha": "a6e387747068abedd73e2360cdcad9d4e6e598ec", "filename": "src/test/run-make-fulldeps/coverage/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs?ref=3ece6061b4af39c331b8c2768d278af04a62ab97", "patch": "@@ -1,6 +1,6 @@\n #![allow(unused_assignments, dead_code)]\n \n-// compile-flags: --edition=2018 -C opt-level=1 # fix in rustc_mir/monomorphize/partitioning/mod.rs\n+// compile-flags: --edition=2018 -C opt-level=1\n \n async fn c(x: u8) -> u8 {\n     if x == 8 {"}, {"sha": "0ba7872b35b531d0509c5ee78b5e45c3a68eee3f", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ece6061b4af39c331b8c2768d278af04a62ab97/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=3ece6061b4af39c331b8c2768d278af04a62ab97", "patch": "@@ -0,0 +1,78 @@\n+// compile-flags: --edition=2018\n+\n+use core::{\n+    future::Future,\n+    marker::Send,\n+    pin::Pin,\n+};\n+\n+fn non_async_func() {\n+    println!(\"non_async_func was covered\");\n+    let b = true;\n+    if b {\n+        println!(\"non_async_func println in block\");\n+    }\n+}\n+\n+// FIXME(#83985): The auto-generated closure in an async function is failing to include\n+// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n+// non-async function above, unless the `println!()` is inside a covered block.\n+async fn async_func() {\n+    println!(\"async_func was covered\");\n+    let b = true;\n+    if b {\n+        println!(\"async_func println in block\");\n+    }\n+}\n+\n+// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n+// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n+// It's only certain kinds of lines and/or their context that results in missing coverage.\n+async fn async_func_just_println() {\n+    println!(\"async_func_just_println was covered\");\n+}\n+\n+fn main() {\n+    println!(\"codecovsample::main\");\n+\n+    non_async_func();\n+\n+    executor::block_on(async_func());\n+    executor::block_on(async_func_just_println());\n+\n+    // let mut future = Box::pin(async_func());\n+    // executor::block_on(future.as_mut());\n+\n+    // let mut future = Box::pin(async_func());\n+    // executor::block_on(future.as_mut());\n+\n+    // let mut future = Box::pin(async_func_just_println());\n+    // executor::block_on(future.as_mut());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+        use std::hint::unreachable_unchecked;\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unsafe { unreachable_unchecked() }, // clone\n+            |_| unsafe { unreachable_unchecked() }, // wake\n+            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}]}