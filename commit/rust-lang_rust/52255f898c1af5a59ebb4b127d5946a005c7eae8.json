{"sha": "52255f898c1af5a59ebb4b127d5946a005c7eae8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMjU1Zjg5OGMxYWY1YTU5ZWJiNGIxMjdkNTk0NmEwMDVjN2VhZTg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T23:45:17Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T23:45:48Z"}, "message": "Enable condvars on ARCs", "tree": {"sha": "635944e9cc0f4fe42ac9d62150e58648f15f1d01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635944e9cc0f4fe42ac9d62150e58648f15f1d01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52255f898c1af5a59ebb4b127d5946a005c7eae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52255f898c1af5a59ebb4b127d5946a005c7eae8", "html_url": "https://github.com/rust-lang/rust/commit/52255f898c1af5a59ebb4b127d5946a005c7eae8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52255f898c1af5a59ebb4b127d5946a005c7eae8/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a403e36d38bae5a65b0ab8a87895ff135414f07", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a403e36d38bae5a65b0ab8a87895ff135414f07", "html_url": "https://github.com/rust-lang/rust/commit/3a403e36d38bae5a65b0ab8a87895ff135414f07"}], "stats": {"total": 128, "additions": 104, "deletions": 24}, "files": [{"sha": "4b01e77b22ae1a32da592f4c8ed0d5a03550ce92", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/52255f898c1af5a59ebb4b127d5946a005c7eae8/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52255f898c1af5a59ebb4b127d5946a005c7eae8/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=52255f898c1af5a59ebb4b127d5946a005c7eae8", "patch": "@@ -5,10 +5,34 @@\n \n import unsafe::{shared_mutable_state, clone_shared_mutable_state,\n                 get_shared_mutable_state, get_shared_immutable_state};\n-import sync::{condvar, mutex, rwlock};\n+import sync;\n+import sync::{mutex, rwlock};\n \n export arc, clone, get;\n-export mutex_arc, rw_arc;\n+export condvar, mutex_arc, rw_arc;\n+\n+/// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n+struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::condvar; }\n+\n+impl &condvar {\n+    /// Atomically exit the associated ARC and block until a signal is sent.\n+    fn wait() {\n+        assert !*self.failed;\n+        self.cond.wait();\n+        // This is why we need to wrap sync::condvar.\n+        check_poison(self.is_mutex, *self.failed);\n+    }\n+    /// Wake up a blocked task. Returns false if there was no blocked task.\n+    fn signal() -> bool {\n+        assert !*self.failed;\n+        self.cond.signal()\n+    }\n+    /// Wake up all blocked tasks. Returns the number of tasks woken.\n+    fn broadcast() -> uint {\n+        assert !*self.failed;\n+        self.cond.broadcast()\n+    }\n+}\n \n /****************************************************************************\n  * Immutable ARC\n@@ -95,26 +119,28 @@ impl<T: send> &mutex_arc<T> {\n         // unsafe. See borrow_rwlock, far below.\n         do (&state.lock).lock {\n             check_poison(true, state.failed);\n-            state.failed = true;\n-            let result = blk(&mut state.data);\n-            state.failed = false;\n-            result\n+            let _z = poison_on_fail(&mut state.failed);\n+            blk(&mut state.data)\n         }\n     }\n-/* FIXME(#3145): Make this compile; borrowck doesn't like it..?\n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n-    unsafe fn access_cond<U>(blk: fn(x: &mut T, condvar) -> U) -> U {\n+    unsafe fn access_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do (&state.lock).lock_cond |cond| {\n             check_poison(true, state.failed);\n-            state.failed = true;\n-            let result = blk(&mut state.data, cond);\n-            state.failed = false;\n-            result\n+            let _z = poison_on_fail(&mut state.failed);\n+            /*\n+            blk(&mut state.data,\n+                &condvar { is_mutex: true, failed: &mut state.failed,\n+                           cond: cond })\n+            */\n+            // XXX: Working around two seeming region bugs here\n+            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            let cvar = condvar { is_mutex: true, failed: fref, cond: cond };\n+            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n         }\n     }\n-*/\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n@@ -129,6 +155,15 @@ fn check_poison(is_mutex: bool, failed: bool) {\n     }\n }\n \n+struct poison_on_fail {\n+    failed: &mut bool;\n+    new(failed: &mut bool) { self.failed = failed; }\n+    drop {\n+        /* assert !*self.failed; -- might be false in case of cond.wait() */\n+        if task::failing() { *self.failed = true; }\n+    }\n+}\n+\n /****************************************************************************\n  * R/W lock protected ARC\n  ****************************************************************************/\n@@ -175,26 +210,28 @@ impl<T: const send> &rw_arc<T> {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write {\n             check_poison(false, state.failed);\n-            state.failed = true;\n-            let result = blk(&mut state.data);\n-            state.failed = false;\n-            result\n+            let _z = poison_on_fail(&mut state.failed);\n+            blk(&mut state.data)\n         }\n     }\n-/* FIXME(#3145): Make this compile; borrowck doesn't like it..?\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(blk: fn(x: &mut T, condvar) -> U) -> U {\n+    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write_cond |cond| {\n             check_poison(false, state.failed);\n-            state.failed = true;\n-            let result = blk(&mut state.data, cond);\n-            state.failed = false;\n-            result\n+            let _z = poison_on_fail(&mut state.failed);\n+            /*\n+            blk(&mut state.data,\n+                &condvar { is_mutex: false, failed: &mut state.failed,\n+                           cond: cond })\n+            */\n+            // XXX: Working around two seeming region bugs here\n+            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            let cvar = condvar { is_mutex: false, failed: fref, cond: cond };\n+            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n         }\n     }\n-*/\n     /**\n      * Access the underlying data immutably. May run concurrently with other\n      * reading tasks.\n@@ -254,6 +291,49 @@ mod tests {\n         log(info, arc_v);\n     }\n \n+    #[test]\n+    fn test_mutex_arc_condvar() {\n+        let arc = ~mutex_arc(false);\n+        let arc2 = ~arc.clone();\n+        let (c,p) = pipes::oneshot();\n+        let (c,p) = (~mut some(c), ~mut some(p));\n+        do task::spawn {\n+            // wait until parent gets in\n+            pipes::recv_one(option::swap_unwrap(p));\n+            do arc2.access_cond |state, cond| {\n+                *state = true;\n+                cond.signal();\n+            }\n+        }\n+        do arc.access_cond |state, cond| {\n+            pipes::send_one(option::swap_unwrap(c), ());\n+            assert !*state;\n+            while !*state {\n+                cond.wait();\n+            }\n+        }\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_arc_condvar_poison() {\n+        let arc = ~mutex_arc(1);\n+        let arc2 = ~arc.clone();\n+        let (c,p) = pipes::stream();\n+\n+        do task::spawn_unlinked {\n+            let _ = p.recv();\n+            do arc2.access_cond |one, cond| {\n+                cond.signal();\n+                assert *one == 0; // Parent should fail when it wakes up.\n+            }\n+        }\n+\n+        do arc.access_cond |one, cond| {\n+            c.send(());\n+            while *one == 1 {\n+                cond.wait();\n+            }\n+        }\n+    }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_mutex_arc_poison() {\n         let arc = ~mutex_arc(1);"}]}