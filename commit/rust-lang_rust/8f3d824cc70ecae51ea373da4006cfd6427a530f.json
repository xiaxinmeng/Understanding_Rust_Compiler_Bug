{"sha": "8f3d824cc70ecae51ea373da4006cfd6427a530f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmM2Q4MjRjYzcwZWNhZTUxZWEzNzNkYTQwMDZjZmQ2NDI3YTUzMGY=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-12T05:19:39Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:46Z"}, "message": "Remove common::Block.", "tree": {"sha": "e04dd01d09163316a2b9755f1c635f7906852efc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e04dd01d09163316a2b9755f1c635f7906852efc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f3d824cc70ecae51ea373da4006cfd6427a530f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f3d824cc70ecae51ea373da4006cfd6427a530f", "html_url": "https://github.com/rust-lang/rust/commit/8f3d824cc70ecae51ea373da4006cfd6427a530f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f3d824cc70ecae51ea373da4006cfd6427a530f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dbd141b8c8d9e132709ad4453785a02bc642ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbd141b8c8d9e132709ad4453785a02bc642ecb", "html_url": "https://github.com/rust-lang/rust/commit/3dbd141b8c8d9e132709ad4453785a02bc642ecb"}], "stats": {"total": 531, "additions": 201, "deletions": 330}, "files": [{"sha": "57c0c11ced0f11d0095d05bd76ee976629284f90", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -575,8 +575,8 @@ pub fn with_cond<'blk, 'tcx, F>(\n     }\n \n     let fcx = bcx.fcx();\n-    let next_cx = fcx.new_block(\"next\").build();\n-    let cond_cx = fcx.new_block(\"cond\").build();\n+    let next_cx = fcx.build_new_block(\"next\");\n+    let cond_cx = fcx.build_new_block(\"cond\");\n     bcx.cond_br(val, cond_cx.llbb(), next_cx.llbb());\n     let after_cx = f(cond_cx);\n     after_cx.br(next_cx.llbb());\n@@ -619,17 +619,6 @@ impl Lifetime {\n     }\n }\n \n-// Generates code for resumption of unwind at the end of a landing pad.\n-pub fn trans_unwind_resume(bcx: &BlockAndBuilder, lpval: ValueRef) {\n-    if !bcx.sess().target.target.options.custom_unwind_resume {\n-        bcx.resume(lpval);\n-    } else {\n-        let exc_ptr = bcx.extract_value(lpval, 0);\n-        bcx.call(bcx.fcx().eh_unwind_resume().reify(bcx.ccx()), &[exc_ptr],\n-            bcx.lpad().and_then(|b| b.bundle()));\n-    }\n-}\n-\n pub fn call_memcpy<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n                                dst: ValueRef,\n                                src: ValueRef,\n@@ -727,8 +716,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n                llfndecl: ValueRef,\n                fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n-               block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n+               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>)\n+               //block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n                -> FunctionContext<'blk, 'tcx> {\n         let (param_substs, def_id) = match definition {\n             Some((instance, ..)) => {\n@@ -772,7 +761,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n             span: None,\n-            block_arena: block_arena,\n+            //block_arena: block_arena,\n             lpad_arena: TypedArena::new(),\n             ccx: ccx,\n             debug_context: debug_context,\n@@ -783,7 +772,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// Performs setup on a newly created function, creating the entry\n     /// scope block and allocating space for the return pointer.\n     pub fn init(&'blk self, skip_retptr: bool) -> BlockAndBuilder<'blk, 'tcx> {\n-        let entry_bcx = self.new_block(\"entry-block\").build();\n+        let entry_bcx = self.build_new_block(\"entry-block\");\n \n         // Use a dummy instruction as the insertion point for all allocas.\n         // This is later removed in FunctionContext::cleanup.\n@@ -924,13 +913,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx,\n-                               lldecl,\n-                               fn_ty,\n-                               Some((instance, &sig, abi)),\n-                               &arena);\n+    let fcx = FunctionContext::new(ccx, lldecl, fn_ty, Some((instance, &sig, abi)));\n \n     if fcx.mir.is_none() {\n         bug!(\"attempted translation of `{}` w/o MIR\", instance);\n@@ -953,9 +936,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, &arena);\n+    let fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None);\n     let bcx = fcx.init(false);\n \n     if !fcx.fn_ty.ret.is_ignore() {"}, {"sha": "a7200cf7538f72218e3a79a18e6054726f94ce18", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -16,7 +16,6 @@\n \n pub use self::CalleeData::*;\n \n-use arena::TypedArena;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -26,7 +25,7 @@ use attributes;\n use base;\n use base::*;\n use common::{\n-    self, Block, BlockAndBuilder, CrateContext, FunctionContext, SharedCrateContext\n+    self, BlockAndBuilder, CrateContext, FunctionContext, SharedCrateContext\n };\n use consts;\n use declare;\n@@ -71,25 +70,8 @@ impl<'tcx> Callee<'tcx> {\n         }\n     }\n \n-    /// Trait or impl method call.\n-    pub fn method_call<'blk>(bcx: Block<'blk, 'tcx>,\n-                             method_call: ty::MethodCall)\n-                             -> Callee<'tcx> {\n-        let method = bcx.tcx().tables().method_map[&method_call];\n-        Callee::method(bcx, method)\n-    }\n-\n-    /// Trait or impl method.\n-    pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n-                        method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n-        let substs = bcx.fcx.monomorphize(&method.substs);\n-        Callee::def(bcx.ccx(), method.def_id, substs)\n-    }\n-\n     /// Function or method definition.\n-    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                   def_id: DefId,\n-                   substs: &'tcx Substs<'tcx>)\n+    pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n@@ -367,9 +349,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, &block_arena);\n+    let fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None);\n     let bcx = fcx.init(false);\n \n     // the first argument (`self`) will be the (by value) closure env.\n@@ -518,9 +498,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n     let bcx = fcx.init(false);\n \n     let llargs = get_params(fcx.llfn);\n@@ -723,17 +701,11 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         for &llarg in &llargs {\n             debug!(\"arg: {:?}\", Value(llarg));\n         }\n-        let normal_bcx = bcx.fcx().new_block(\"normal-return\");\n+        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n         let landing_pad = bcx.fcx().get_landing_pad();\n \n-        let llresult = bcx.invoke(\n-            llfn,\n-            &llargs[..],\n-            normal_bcx.llbb,\n-            landing_pad,\n-            lpad,\n-        );\n-        (llresult, normal_bcx.build())\n+        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, lpad);\n+        (llresult, normal_bcx)\n     } else {\n         debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb());\n         for &llarg in &llargs {"}, {"sha": "f761b3bd967fee164fcb43075ed3f65cbb638600", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -416,14 +416,22 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                     UnwindExit(val) => {\n                         // Generate a block that will resume unwinding to the\n                         // calling function\n-                        let bcx = self.new_block(\"resume\").build();\n+                        let bcx = self.build_new_block(\"resume\");\n                         match val {\n                             UnwindKind::LandingPad => {\n                                 let addr = self.landingpad_alloca.get()\n                                                .unwrap();\n                                 let lp = bcx.load(addr);\n                                 Lifetime::End.call(&bcx, addr);\n-                                base::trans_unwind_resume(&bcx, lp);\n+                                if !bcx.sess().target.target.options.custom_unwind_resume {\n+                                    bcx.resume(lp);\n+                                } else {\n+                                    let exc_ptr = bcx.extract_value(lp, 0);\n+                                    bcx.call(\n+                                        bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n+                                        &[exc_ptr],\n+                                        bcx.lpad().and_then(|b| b.bundle()));\n+                                }\n                             }\n                             UnwindKind::CleanupPad(_) => {\n                                 let pad = bcx.cleanup_pad(None, &[]);\n@@ -481,7 +489,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n \n-                let bcx_in = self.new_block(&name[..]).build();\n+                let bcx_in = self.build_new_block(&name[..]);\n                 let exit_label = label.start(&bcx_in);\n                 let next_llbb = bcx_in.llbb();\n                 let mut bcx_out = bcx_in;\n@@ -525,7 +533,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 Some(llbb) => return llbb,\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(&name[..]).build();\n+                    pad_bcx = self.build_new_block(&name[..]);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n                 }\n             }\n@@ -682,16 +690,17 @@ pub struct DropValue<'tcx> {\n \n impl<'tcx> DropValue<'tcx> {\n     fn trans<'blk>(&self, bcx: BlockAndBuilder<'blk, 'tcx>) -> BlockAndBuilder<'blk, 'tcx> {\n-        let skip_dtor = self.skip_dtor;\n-        let _icx = if skip_dtor {\n-            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=true\")\n-        } else {\n-            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=false\")\n-        };\n         if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty, self.skip_dtor)\n+            let vp = base::alloc_ty(&bcx, self.ty, \"\");\n+            Lifetime::Start.call(&bcx, vp);\n+            base::store_ty(&bcx, self.val, vp, self.ty);\n+            let lpad = bcx.lpad();\n+            let bcx = glue::call_drop_glue(bcx, vp, self.ty, self.skip_dtor, lpad);\n+            Lifetime::End.call(&bcx, vp);\n+            bcx\n         } else {\n-            glue::drop_ty_core(bcx, self.val, self.ty, self.skip_dtor)\n+            let lpad = bcx.lpad();\n+            glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, lpad)\n         }\n     }\n }"}, {"sha": "4f800bb2bf27e5370e391ba146472fd860521b34", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 43, "deletions": 127, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -305,7 +305,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     pub span: Option<Span>,\n \n     // The arena that blocks are allocated from.\n-    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n+    //pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n     // The arena that landing pads are allocated from.\n     pub lpad_arena: TypedArena<LandingPad>,\n@@ -333,18 +333,21 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn new_block(&'a self,\n-                     name: &str)\n-                     -> Block<'a, 'tcx> {\n+    pub fn new_block(&'a self, name: &str) -> BasicBlockRef {\n         unsafe {\n             let name = CString::new(name).unwrap();\n-            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                           self.llfn,\n-                                                           name.as_ptr());\n-            BlockS::new(llbb, self)\n+            llvm::LLVMAppendBasicBlockInContext(\n+                self.ccx.llcx(),\n+                self.llfn,\n+                name.as_ptr()\n+            )\n         }\n     }\n \n+    pub fn build_new_block(&'a self, name: &str) -> BlockAndBuilder<'a, 'tcx> {\n+        BlockAndBuilder::new(self.new_block(name), self)\n+    }\n+\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n@@ -441,94 +444,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n }\n \n-// Basic block context.  We create a block context for each basic block\n-// (single-entry, single-exit sequence of instructions) we generate from Rust\n-// code.  Each basic block we generate is attached to a function, typically\n-// with many basic blocks per function.  All the basic blocks attached to a\n-// function are organized as a directed graph.\n-#[must_use]\n-pub struct BlockS<'blk, 'tcx: 'blk> {\n-    // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-    // block to the function pointed to by llfn.  We insert\n-    // instructions into that block by way of this block context.\n-    // The block pointing to this one in the function's digraph.\n-    pub llbb: BasicBlockRef,\n-\n-    // If this block part of a landing pad, then this is `Some` indicating what\n-    // kind of landing pad its in, otherwise this is none.\n-    pub lpad: Cell<Option<&'blk LandingPad>>,\n-\n-    // The function context for the function to which this block is\n-    // attached.\n-    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n-}\n-\n-pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n-\n-impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef,\n-               fcx: &'blk FunctionContext<'blk, 'tcx>)\n-               -> Block<'blk, 'tcx> {\n-        fcx.block_arena.alloc(BlockS {\n-            llbb: llbb,\n-            lpad: Cell::new(None),\n-            fcx: fcx\n-        })\n-    }\n-\n-    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-        self.fcx.ccx\n-    }\n-    pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n-        self.fcx\n-    }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n-        self.fcx.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n-\n-    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n-        self.lpad.get()\n-    }\n-\n-    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n-        // FIXME: use an IVar?\n-        self.lpad.set(lpad);\n-    }\n-\n-    pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n-    }\n-\n-    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.fcx.mir()\n-    }\n-\n-    pub fn name(&self, name: ast::Name) -> String {\n-        name.to_string()\n-    }\n-\n-    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n-        self.tcx().map.node_to_string(id).to_string()\n-    }\n-\n-    pub fn to_str(&self) -> String {\n-        format!(\"[block {:p}]\", self)\n-    }\n-\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        monomorphize::apply_param_substs(self.fcx.ccx.shared(),\n-                                         self.fcx.param_substs,\n-                                         value)\n-    }\n-\n-    pub fn build(&'blk self) -> BlockAndBuilder<'blk, 'tcx> {\n-        BlockAndBuilder::new(self, OwnedBuilder::new_with_ccx(self.ccx()))\n-    }\n-}\n \n pub struct OwnedBuilder<'blk, 'tcx: 'blk> {\n     builder: Builder<'blk, 'tcx>\n@@ -559,77 +474,78 @@ impl<'blk, 'tcx> Drop for OwnedBuilder<'blk, 'tcx> {\n \n #[must_use]\n pub struct BlockAndBuilder<'blk, 'tcx: 'blk> {\n-    bcx: Block<'blk, 'tcx>,\n+    // The BasicBlockRef returned from a call to\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n+    // block to the function pointed to by llfn.  We insert\n+    // instructions into that block by way of this block context.\n+    // The block pointing to this one in the function's digraph.\n+    llbb: BasicBlockRef,\n+\n+    // If this block part of a landing pad, then this is `Some` indicating what\n+    // kind of landing pad its in, otherwise this is none.\n+    lpad: Cell<Option<&'blk LandingPad>>,\n+\n+    // The function context for the function to which this block is\n+    // attached.\n+    fcx: &'blk FunctionContext<'blk, 'tcx>,\n+\n     owned_builder: OwnedBuilder<'blk, 'tcx>,\n }\n \n impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n-    pub fn new(bcx: Block<'blk, 'tcx>, owned_builder: OwnedBuilder<'blk, 'tcx>) -> Self {\n+    pub fn new(llbb: BasicBlockRef, fcx: &'blk FunctionContext<'blk, 'tcx>) -> Self {\n+        let owned_builder = OwnedBuilder::new_with_ccx(fcx.ccx);\n         // Set the builder's position to this block's end.\n-        owned_builder.builder.position_at_end(bcx.llbb);\n+        owned_builder.builder.position_at_end(llbb);\n         BlockAndBuilder {\n-            bcx: bcx,\n+            llbb: llbb,\n+            lpad: Cell::new(None),\n+            fcx: fcx,\n             owned_builder: owned_builder,\n         }\n     }\n \n-    pub fn with_block<F, R>(&self, f: F) -> R\n-        where F: FnOnce(Block<'blk, 'tcx>) -> R\n-    {\n-        let result = f(self.bcx);\n-        self.position_at_end(self.bcx.llbb);\n-        result\n-    }\n-\n     pub fn at_start<F, R>(&self, f: F) -> R\n         where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>) -> R\n     {\n-        self.position_at_start(self.bcx.llbb);\n+        self.position_at_start(self.llbb);\n         let r = f(self);\n-        self.position_at_end(self.bcx.llbb);\n+        self.position_at_end(self.llbb);\n         r\n     }\n \n-    // Methods delegated to bcx\n-\n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-        self.bcx.ccx()\n+        self.fcx.ccx\n     }\n     pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n-        self.bcx.fcx()\n+        self.fcx\n     }\n     pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n-        self.bcx.tcx()\n+        self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session {\n-        self.bcx.sess()\n+        self.fcx.ccx.sess()\n     }\n \n     pub fn llbb(&self) -> BasicBlockRef {\n-        self.bcx.llbb\n+        self.llbb\n     }\n \n     pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.bcx.mir()\n-    }\n-\n-    pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx>\n-    {\n-        self.bcx.monomorphize(value)\n+        self.fcx.mir()\n     }\n \n     pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.bcx.set_lpad(lpad)\n+        self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n     }\n \n     pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n         // FIXME: use an IVar?\n-        self.bcx.set_lpad_ref(lpad);\n+        self.lpad.set(lpad);\n     }\n \n     pub fn lpad(&self) -> Option<&'blk LandingPad> {\n-        self.bcx.lpad()\n+        self.lpad.get()\n     }\n }\n "}, {"sha": "44c580b07400d4efebf12dbd45fef236dd4bffee", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -33,7 +33,6 @@ use type_::Type;\n use value::Value;\n use Disr;\n \n-use arena::TypedArena;\n use syntax_pos::DUMMY_SP;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n@@ -121,19 +120,23 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn drop_ty<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n-                           v: ValueRef,\n-                           t: Ty<'tcx>) -> BlockAndBuilder<'blk, 'tcx> {\n-    drop_ty_core(bcx, v, t, false)\n+fn drop_ty<'blk, 'tcx>(\n+    bcx: BlockAndBuilder<'blk, 'tcx>,\n+    v: ValueRef,\n+    t: Ty<'tcx>,\n+) -> BlockAndBuilder<'blk, 'tcx> {\n+    call_drop_glue(bcx, v, t, false, None)\n }\n \n-pub fn drop_ty_core<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n-                                v: ValueRef,\n-                                t: Ty<'tcx>,\n-                                skip_dtor: bool)\n-                                -> BlockAndBuilder<'blk, 'tcx> {\n+pub fn call_drop_glue<'blk, 'tcx>(\n+    bcx: BlockAndBuilder<'blk, 'tcx>,\n+    v: ValueRef,\n+    t: Ty<'tcx>,\n+    skip_dtor: bool,\n+    lpad: Option<&'blk LandingPad>,\n+) -> BlockAndBuilder<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n+    debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx().type_needs_drop(t) {\n         let ccx = bcx.ccx();\n@@ -151,25 +154,11 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         };\n \n         // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[ptr], bcx.lpad().and_then(|b| b.bundle()));\n+        bcx.call(glue, &[ptr], lpad.and_then(|b| b.bundle()));\n     }\n     bcx\n }\n \n-pub fn drop_ty_immediate<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n-                                     v: ValueRef,\n-                                     t: Ty<'tcx>,\n-                                     skip_dtor: bool)\n-                                     -> BlockAndBuilder<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"drop_ty_immediate\");\n-    let vp = alloc_ty(&bcx, t, \"\");\n-    Lifetime::Start.call(&bcx, vp);\n-    store_ty(&bcx, v, vp, t);\n-    let bcx = drop_ty_core(bcx, vp, t, skip_dtor);\n-    Lifetime::End.call(&bcx, vp);\n-    bcx\n-}\n-\n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n     get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n }\n@@ -221,9 +210,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n     let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let (arena, fcx): (TypedArena<_>, FunctionContext);\n-    arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &arena);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n \n     let bcx = fcx.init(false);\n \n@@ -588,15 +575,15 @@ fn drop_structural_ty<'blk, 'tcx>(cx: BlockAndBuilder<'blk, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\").build();\n+                        let ret_void_cx = fcx.build_new_block(\"enum-iter-ret-void\");\n                         ret_void_cx.ret_void();\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = fcx.new_block(\"enum-iter-next\").build();\n+                        let next_cx = fcx.build_new_block(\"enum-iter-next\");\n \n                         for variant in &adt.variants {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n-                            let variant_cx = fcx.new_block(&variant_cx_name).build();\n+                            let variant_cx = fcx.build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             let variant_cx = iter_variant(variant_cx, t, value, variant, substs);"}, {"sha": "94a57d9568ef245f1e7bc4c0f3db06fc0db01141", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -10,7 +10,6 @@\n \n #![allow(non_upper_case_globals)]\n \n-use arena::TypedArena;\n use intrinsics::{self, Intrinsic};\n use libc;\n use llvm;\n@@ -812,10 +811,10 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n         bcx.set_personality_fn(bcx.fcx().eh_personality());\n \n-        let normal = bcx.fcx().new_block(\"normal\").build();\n-        let catchswitch = bcx.fcx().new_block(\"catchswitch\").build();\n-        let catchpad = bcx.fcx().new_block(\"catchpad\").build();\n-        let caught = bcx.fcx().new_block(\"caught\").build();\n+        let normal = bcx.fcx().build_new_block(\"normal\");\n+        let catchswitch = bcx.fcx().build_new_block(\"catchswitch\");\n+        let catchpad = bcx.fcx().build_new_block(\"catchpad\");\n+        let caught = bcx.fcx().build_new_block(\"caught\");\n \n         let func = llvm::get_param(bcx.fcx().llfn, 0);\n         let data = llvm::get_param(bcx.fcx().llfn, 1);\n@@ -930,8 +929,8 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.fcx().new_block(\"then\").build();\n-        let catch = bcx.fcx().new_block(\"catch\").build();\n+        let then = bcx.fcx().build_new_block(\"then\");\n+        let catch = bcx.fcx().build_new_block(\"catch\");\n \n         let func = llvm::get_param(bcx.fcx().llfn, 0);\n         let data = llvm::get_param(bcx.fcx().llfn, 1);\n@@ -978,9 +977,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let (fcx, block_arena);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n     trans(fcx.init(true));\n     fcx.cleanup();\n     llfn"}, {"sha": "66eb27ae11f7851acdd92ce104ffd3d00febb76e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use attributes;\n-use arena::TypedArena;\n use llvm::{ValueRef, get_params};\n use rustc::traits;\n use abi::FnType;\n@@ -84,9 +83,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n-    block_arena = TypedArena::new();\n-    fcx = FunctionContext::new(ccx, llfn, fn_ty, None, &block_arena);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n     let mut bcx = fcx.init(false);\n \n     let dest = fcx.llretslotptr.get();"}, {"sha": "4b6998d0505dc49685da4ed26b0b971720bb56b9", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -16,19 +16,18 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n-use common::{self, Block, BlockAndBuilder};\n+use common::{self, BlockAndBuilder};\n use glue;\n use super::rvalue;\n \n-pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n+pub fn lvalue_locals<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx,'tcx>,\n                                  mir: &mir::Mir<'tcx>) -> BitVector {\n-    let bcx = bcx.build();\n     let mut analyzer = LocalAnalyzer::new(mir, &bcx);\n \n     analyzer.visit_mir(mir);\n \n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n-        let ty = bcx.monomorphize(&ty);\n+        let ty = bcx.fcx().monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n         if ty.is_scalar() ||\n             ty.is_unique() ||\n@@ -142,7 +141,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n             if let mir::Lvalue::Local(_) = proj.base {\n                 let ty = proj.base.ty(self.mir, self.bcx.tcx());\n \n-                let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n+                let ty = self.bcx.fcx().monomorphize(&ty.to_ty(self.bcx.tcx()));\n                 if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n                         if let LvalueContext::Consume = context {\n@@ -172,7 +171,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n \n                 LvalueContext::Drop => {\n                     let ty = lvalue.ty(self.mir, self.bcx.tcx());\n-                    let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n+                    let ty = self.bcx.fcx().monomorphize(&ty.to_ty(self.bcx.tcx()));\n \n                     // Only need the lvalue if we're actually dropping it.\n                     if glue::type_needs_drop(self.bcx.tcx(), ty) {\n@@ -200,10 +199,7 @@ pub enum CleanupKind {\n     Internal { funclet: mir::BasicBlock }\n }\n \n-pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n-                                mir: &mir::Mir<'tcx>)\n-                                -> IndexVec<mir::BasicBlock, CleanupKind>\n-{\n+pub fn cleanup_kinds<'bcx,'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Mir<'tcx>) {\n         for (bb, data) in mir.basic_blocks().iter_enumerated() {"}, {"sha": "151d1f018208d6ae6f60812ff6cc1bd124de8fba", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef};\n+use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n use rustc::ty::{self, layout};\n@@ -17,7 +17,7 @@ use abi::{Abi, FnType, ArgType};\n use adt;\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, Block, BlockAndBuilder, LandingPad};\n+use common::{self, BlockAndBuilder, LandingPad};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use debuginfo::DebugLoc;\n@@ -28,6 +28,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::symbol::Symbol;\n \n@@ -42,18 +43,24 @@ use std::cell::Ref as CellRef;\n use std::ptr;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n-        let mut bcx = self.bcx(bb);\n+    pub fn trans_block(&mut self, bb: mir::BasicBlock,\n+        lpads: &IndexVec<mir::BasicBlock, Option<LandingPad>>) {\n+        let mut bcx = self.build_block(bb);\n         let data = &CellRef::clone(&self.mir)[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n+        let lpad = match self.cleanup_kinds[bb] {\n+            CleanupKind::Internal { funclet } => lpads[funclet].as_ref(),\n+            _ => lpads[bb].as_ref(),\n+        };\n+\n         // Create the cleanup bundle, if needed.\n-        let cleanup_pad = bcx.lpad().and_then(|lp| lp.cleanuppad());\n-        let cleanup_bundle = bcx.lpad().and_then(|l| l.bundle());\n+        let cleanup_pad = lpad.and_then(|lp| lp.cleanuppad());\n+        let cleanup_bundle = lpad.and_then(|l| l.bundle());\n \n         let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n-            let lltarget = this.blocks[bb].llbb;\n+            let lltarget = this.blocks[bb];\n             if let Some(cp) = cleanup_pad {\n                 match this.cleanup_kinds[bb] {\n                     CleanupKind::Funclet => {\n@@ -70,7 +77,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         };\n \n         let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target].llbb;\n+            let lltarget = this.blocks[target];\n \n             if let Some(cp) = cleanup_pad {\n                 match this.cleanup_kinds[target] {\n@@ -79,7 +86,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.fcx.new_block(name).build();\n+                        let trampoline = this.fcx.build_new_block(name);\n                         trampoline.set_personality_fn(this.fcx.eh_personality());\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n@@ -93,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (this.cleanup_kinds[bb], this.cleanup_kinds[target])\n                 {\n                     // jump *into* cleanup - need a landing pad if GNU\n-                    this.landing_pad_to(target).llbb\n+                    this.landing_pad_to(target)\n                 } else {\n                     lltarget\n                 }\n@@ -122,7 +129,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let ps = self.get_personality_slot(&bcx);\n                     let lp = bcx.load(ps);\n                     Lifetime::End.call(&bcx, ps);\n-                    base::trans_unwind_resume(&bcx, lp);\n+                    if !bcx.sess().target.target.options.custom_unwind_resume {\n+                        bcx.resume(lp);\n+                    } else {\n+                        let exc_ptr = bcx.extract_value(lp, 0);\n+                        bcx.call(\n+                            bcx.fcx().eh_unwind_resume().reify(bcx.ccx()),\n+                            &[exc_ptr],\n+                            cleanup_bundle,\n+                        );\n+                    }\n                 }\n             }\n \n@@ -158,7 +174,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // We're generating an exhaustive switch, so the else branch\n                     // can't be hit.  Branching to an unreachable instruction\n                     // lets LLVM know this\n-                    _ => (None, self.unreachable_block().llbb)\n+                    _ => (None, self.unreachable_block())\n                 };\n                 let switch = bcx.switch(discr, default_blk, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n@@ -228,7 +244,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n-                let ty = bcx.monomorphize(&ty);\n+                let ty = bcx.fcx().monomorphize(&ty);\n \n                 // Double check for necessity to drop\n                 if !glue::type_needs_drop(bcx.tcx(), ty) {\n@@ -263,7 +279,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n-                               self.blocks[target].llbb,\n+                               self.blocks[target],\n                                llblock(self, unwind),\n                                cleanup_bundle);\n                 } else {\n@@ -304,15 +320,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n-                let panic_block = self.fcx.new_block(\"panic\");\n+                let panic_block = self.fcx.build_new_block(\"panic\");\n                 if expected {\n-                    bcx.cond_br(cond, lltarget, panic_block.llbb);\n+                    bcx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n-                    bcx.cond_br(cond, panic_block.llbb, lltarget);\n+                    bcx.cond_br(cond, panic_block.llbb(), lltarget);\n                 }\n \n                 // After this point, bcx is the block for the call to panic.\n-                bcx = panic_block.build();\n+                bcx = panic_block;\n                 debug_loc.apply_to_bcx(&bcx);\n \n                 // Get the location information.\n@@ -385,7 +401,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(unwind) = cleanup {\n                     bcx.invoke(llfn,\n                                &args,\n-                               self.unreachable_block().llbb,\n+                               self.unreachable_block(),\n                                llblock(self, unwind),\n                                cleanup_bundle);\n                 } else {\n@@ -485,7 +501,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if let Some(unwind) = *cleanup {\n                         bcx.invoke(drop_fn,\n                             &[llvalue],\n-                            self.blocks[target].llbb,\n+                            self.blocks[target],\n                             llblock(self, unwind),\n                             cleanup_bundle);\n                     } else {\n@@ -508,7 +524,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n-                    bcx.monomorphize(&op_ty)\n+                    bcx.fcx().monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);\n \n@@ -621,13 +637,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     };\n                     let invokeret = bcx.invoke(fn_ptr,\n                                                &llargs,\n-                                               ret_bcx.llbb,\n+                                               ret_bcx,\n                                                llblock(self, cleanup),\n                                                cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n-                    if destination.is_some() {\n-                        let ret_bcx = ret_bcx.build();\n+                    if let Some((_, target)) = *destination {\n+                        let ret_bcx = self.build_block(target);\n                         ret_bcx.at_start(|ret_bcx| {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n@@ -824,8 +840,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Block<'bcx, 'tcx>\n-    {\n+    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> BasicBlockRef {\n         if let Some(block) = self.landing_pads[target_bb] {\n             return block;\n         }\n@@ -834,12 +849,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             return self.blocks[target_bb];\n         }\n \n-        let target = self.bcx(target_bb);\n+        let target = self.build_block(target_bb);\n \n-        let block = self.fcx.new_block(\"cleanup\");\n-        self.landing_pads[target_bb] = Some(block);\n+        let bcx = self.fcx.build_new_block(\"cleanup\");\n+        self.landing_pads[target_bb] = Some(bcx.llbb());\n \n-        let bcx = block.build();\n         let ccx = bcx.ccx();\n         let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n@@ -848,46 +862,47 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot);\n         bcx.br(target.llbb());\n-        block\n+        bcx.llbb()\n     }\n \n-    pub fn init_cpad(&mut self, bb: mir::BasicBlock) {\n-        let bcx = self.bcx(bb);\n+    pub fn init_cpad(&mut self, bb: mir::BasicBlock,\n+        lpads: &mut IndexVec<mir::BasicBlock, Option<LandingPad>>) {\n+        let bcx = self.build_block(bb);\n         let data = &self.mir[bb];\n         debug!(\"init_cpad({:?})\", data);\n \n         match self.cleanup_kinds[bb] {\n             CleanupKind::NotCleanup => {\n-                bcx.set_lpad(None)\n+                lpads[bb] = None;\n             }\n             _ if !base::wants_msvc_seh(bcx.sess()) => {\n-                bcx.set_lpad(Some(LandingPad::gnu()))\n+                lpads[bb] = Some(LandingPad::gnu());\n             }\n-            CleanupKind::Internal { funclet } => {\n+            CleanupKind::Internal { funclet: _ } => {\n                 // FIXME: is this needed?\n                 bcx.set_personality_fn(self.fcx.eh_personality());\n-                bcx.set_lpad_ref(self.bcx(funclet).lpad());\n+                lpads[bb] = None;\n             }\n             CleanupKind::Funclet => {\n                 bcx.set_personality_fn(self.fcx.eh_personality());\n                 DebugLoc::None.apply_to_bcx(&bcx);\n                 let cleanup_pad = bcx.cleanup_pad(None, &[]);\n-                bcx.set_lpad(Some(LandingPad::msvc(cleanup_pad)));\n+                lpads[bb] = Some(LandingPad::msvc(cleanup_pad));\n             }\n         };\n     }\n \n-    fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n+    fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.new_block(\"unreachable\");\n-            bl.build().unreachable();\n-            self.unreachable_block = Some(bl);\n-            bl\n+            let bl = self.fcx.build_new_block(\"unreachable\");\n+            bl.unreachable();\n+            self.unreachable_block = Some(bl.llbb());\n+            bl.llbb()\n         })\n     }\n \n-    fn bcx(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n-        self.blocks[bb].build()\n+    fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'bcx, 'tcx> {\n+        BlockAndBuilder::new(self.blocks[bb], self.fcx)\n     }\n \n     fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,"}, {"sha": "8143190a58defff5bed8995ba9a3997d6903aad7", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -952,7 +952,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           -> Const<'tcx>\n     {\n         debug!(\"trans_constant({:?})\", constant);\n-        let ty = bcx.monomorphize(&constant.ty);\n+        let ty = bcx.fcx().monomorphize(&constant.ty);\n         let result = match constant.literal.clone() {\n             mir::Literal::Item { def_id, substs } => {\n                 // Shortcut for zero-sized types, including function item\n@@ -962,7 +962,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     return Const::new(C_null(llty), ty);\n                 }\n \n-                let substs = bcx.monomorphize(&substs);\n+                let substs = bcx.fcx().monomorphize(&substs);\n                 let instance = Instance::new(def_id, substs);\n                 MirConstContext::trans_def(bcx.ccx(), instance, IndexVec::new())\n             }"}, {"sha": "c6be7eaa77562be41ef63ce8e7e51cf40434bf0b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -103,7 +103,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let ptr = self.trans_consume(bcx, base);\n                 let projected_ty = LvalueTy::from_ty(ptr.ty)\n                     .projection_ty(tcx, &mir::ProjectionElem::Deref);\n-                let projected_ty = bcx.monomorphize(&projected_ty);\n+                let projected_ty = bcx.fcx().monomorphize(&projected_ty);\n                 let (llptr, llextra) = match ptr.val {\n                     OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n                     OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n@@ -118,7 +118,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                let projected_ty = bcx.monomorphize(&projected_ty);\n+                let projected_ty = bcx.fcx().monomorphize(&projected_ty);\n \n                 let project_index = |llindex| {\n                     let element = if let ty::TySlice(_) = tr_base.ty.to_ty(tcx).sty {"}, {"sha": "33014af0f88eda206cb67bf9960007469016abce", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use libc::c_uint;\n-use llvm::{self, ValueRef};\n-use rustc::ty::{self, layout};\n+use llvm::{self, ValueRef, BasicBlockRef};\n+use rustc::ty;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n-use common::{self, Block, BlockAndBuilder, CrateContext, FunctionContext, C_null};\n+use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, LandingPad};\n use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind, FunctionDebugContext};\n use type_of;\n \n@@ -54,17 +54,17 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     llpersonalityslot: Option<ValueRef>,\n \n     /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, Block<'bcx, 'tcx>>,\n+    blocks: IndexVec<mir::BasicBlock, BasicBlockRef>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n-    landing_pads: IndexVec<mir::BasicBlock, Option<Block<'bcx, 'tcx>>>,\n+    landing_pads: IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n \n     /// Cached unreachable block\n-    unreachable_block: Option<Block<'bcx, 'tcx>>,\n+    unreachable_block: Option<BasicBlockRef>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `LvalueRef` representing an alloca, but not always:\n@@ -186,13 +186,11 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let (lvalue_locals, cleanup_kinds) = bcx.with_block(|bcx| {\n-        (analyze::lvalue_locals(bcx, &mir),\n-         analyze::cleanup_kinds(bcx, &mir))\n-    });\n+    let lvalue_locals = analyze::lvalue_locals(&bcx, &mir);\n+    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n \n     // Allocate a `Block` for every basic block\n-    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n+    let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK {\n                 fcx.new_block(\"start\")\n@@ -222,7 +220,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let ty = bcx.monomorphize(&decl.ty);\n+            let ty = bcx.fcx().monomorphize(&decl.ty);\n \n             if let Some(name) = decl.name {\n                 // User variable\n@@ -276,7 +274,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Branch to the START block\n     let start_bcx = mircx.blocks[mir::START_BLOCK];\n-    bcx.br(start_bcx.llbb);\n+    bcx.br(start_bcx);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n@@ -287,23 +285,26 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     let mut rpo = traversal::reverse_postorder(&mir);\n \n+    let mut lpads: IndexVec<mir::BasicBlock, Option<LandingPad>> =\n+        IndexVec::from_elem(None, mir.basic_blocks());\n+\n     // Prepare each block for translation.\n     for (bb, _) in rpo.by_ref() {\n-        mircx.init_cpad(bb);\n+        mircx.init_cpad(bb, &mut lpads);\n     }\n     rpo.reset();\n \n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        mircx.trans_block(bb);\n+        mircx.trans_block(bb, &lpads);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n     // predecessors.\n     for bb in mir.basic_blocks().indices() {\n         let block = mircx.blocks[bb];\n-        let block = BasicBlock(block.llbb);\n+        let block = BasicBlock(block);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n             debug!(\"trans_mir: block {:?} was not visited\", bb);\n@@ -338,7 +339,7 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n-        let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+        let arg_ty = bcx.fcx().monomorphize(&arg_decl.ty);\n \n         if Some(local) == mir.spread_arg {\n             // This argument (e.g. the last argument in the \"rust-call\" ABI)"}, {"sha": "3c737fd6ad7d8e92b9df15da2f3865402fd412f2", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -197,7 +197,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             let llval = [a, b][f.index()];\n                             let op = OperandRef {\n                                 val: OperandValue::Immediate(llval),\n-                                ty: bcx.monomorphize(&ty)\n+                                ty: bcx.fcx().monomorphize(&ty)\n                             };\n \n                             // Handle nested pairs."}, {"sha": "e71449938e9b5908ba1947466fe95df6c65f687a", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -52,7 +52,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n            }\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, cast_ty) => {\n-                let cast_ty = bcx.monomorphize(&cast_ty);\n+                let cast_ty = bcx.fcx().monomorphize(&cast_ty);\n \n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n@@ -187,7 +187,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n                 let operand = self.trans_operand(&bcx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast_ty = bcx.monomorphize(&cast_ty);\n+                let cast_ty = bcx.fcx().monomorphize(&cast_ty);\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n@@ -444,7 +444,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Rvalue::Box(content_ty) => {\n-                let content_ty: Ty<'tcx> = bcx.monomorphize(&content_ty);\n+                let content_ty: Ty<'tcx> = bcx.fcx().monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx(), content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx(), llty);\n                 let align = type_of::align_of(bcx.ccx(), content_ty);"}, {"sha": "b90c66f531c46e93df44979555691c6bc1a9c4e0", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f3d824cc70ecae51ea373da4006cfd6427a530f/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=8f3d824cc70ecae51ea373da4006cfd6427a530f", "patch": "@@ -35,9 +35,9 @@ pub fn slice_for_each<'blk, 'tcx, F>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         bcx.inbounds_gep(a, &[b])\n     };\n \n-    let body_bcx = fcx.new_block(\"slice_loop_body\").build();\n-    let next_bcx = fcx.new_block(\"slice_loop_next\").build();\n-    let header_bcx = fcx.new_block(\"slice_loop_header\").build();\n+    let body_bcx = fcx.build_new_block(\"slice_loop_body\");\n+    let next_bcx = fcx.build_new_block(\"slice_loop_next\");\n+    let header_bcx = fcx.build_new_block(\"slice_loop_header\");\n \n     let start = if zst {\n         C_uint(bcx.ccx(), 0usize)"}]}