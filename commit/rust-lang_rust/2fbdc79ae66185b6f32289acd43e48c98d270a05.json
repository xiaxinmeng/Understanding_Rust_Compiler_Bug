{"sha": "2fbdc79ae66185b6f32289acd43e48c98d270a05", "node_id": "C_kwDOAAsO6NoAKDJmYmRjNzlhZTY2MTg1YjZmMzIyODlhY2Q0M2U0OGM5OGQyNzBhMDU", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T21:23:18Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T21:58:45Z"}, "message": "Remove a Clean impl for a tuple (1)\n\nThis commit removes the first of nine Clean impls on tuples, converting\nit to a function instead.\n\nThe fact that these are impls causes several problems:\n\n  1. They are nameless, so it's unclear what they do.\n\n  2. It's hard to find where they're used apart from removing them and\n     seeing what errors occur (this applies to all Clean impls, not just\n     the tuple ones).\n\n  3. Rustc doesn't currently warn when impls are unused, so dead code\n     can accumulate easily (all Clean impls).\n\n  4. Their bodies often use tuple field indexing syntax (e.g., `self.1`)\n     to refer to their \"arguments\", which makes reading the code more\n     difficult.\n\nAs I noted, some of these problems apply to all Clean impls, but even\nthose problems are exacerbated by the tuple impls since they make\ngeneral understanding of the code harder.\n\nConverting the impls to functions solves all four of these problems.", "tree": {"sha": "d0988f54a7b5d09177e3792fdbf90a496c4d6dc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0988f54a7b5d09177e3792fdbf90a496c4d6dc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fbdc79ae66185b6f32289acd43e48c98d270a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbdc79ae66185b6f32289acd43e48c98d270a05", "html_url": "https://github.com/rust-lang/rust/commit/2fbdc79ae66185b6f32289acd43e48c98d270a05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fbdc79ae66185b6f32289acd43e48c98d270a05/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2ecfc7e2e4ef3c54363f8f939249932bbb352d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ecfc7e2e4ef3c54363f8f939249932bbb352d4", "html_url": "https://github.com/rust-lang/rust/commit/f2ecfc7e2e4ef3c54363f8f939249932bbb352d4"}], "stats": {"total": 43, "additions": 18, "deletions": 25}, "files": [{"sha": "95724cfd00513ece971e800ac602ede9692c7918", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2fbdc79ae66185b6f32289acd43e48c98d270a05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fbdc79ae66185b6f32289acd43e48c98d270a05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2fbdc79ae66185b6f32289acd43e48c98d270a05", "patch": "@@ -102,11 +102,9 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n                     _ => bug!(\"clean: parenthesized `GenericBound::LangItemTrait`\"),\n                 };\n \n+                let trait_ = clean_trait_ref_with_bindings(cx, trait_ref, &bindings);\n                 GenericBound::TraitBound(\n-                    PolyTrait {\n-                        trait_: (trait_ref, &bindings[..]).clean(cx),\n-                        generic_params: vec![],\n-                    },\n+                    PolyTrait { trait_, generic_params: vec![] },\n                     hir::TraitBoundModifier::None,\n                 )\n             }\n@@ -117,29 +115,26 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl Clean<Path> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        let (trait_ref, bindings) = *self;\n-        let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n-        if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n-            span_bug!(\n-                cx.tcx.def_span(trait_ref.def_id),\n-                \"`TraitRef` had unexpected kind {:?}\",\n-                kind\n-            );\n-        }\n-        inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n-        let path = external_path(cx, trait_ref.def_id, true, bindings.to_vec(), trait_ref.substs);\n+fn clean_trait_ref_with_bindings(\n+    cx: &mut DocContext<'_>,\n+    trait_ref: ty::TraitRef<'_>,\n+    bindings: &[TypeBinding],\n+) -> Path {\n+    let kind = cx.tcx.def_kind(trait_ref.def_id).into();\n+    if !matches!(kind, ItemType::Trait | ItemType::TraitAlias) {\n+        span_bug!(cx.tcx.def_span(trait_ref.def_id), \"`TraitRef` had unexpected kind {:?}\", kind);\n+    }\n+    inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n+    let path = external_path(cx, trait_ref.def_id, true, bindings.to_vec(), trait_ref.substs);\n \n-        debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n+    debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n-        path\n-    }\n+    path\n }\n \n impl Clean<Path> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n-        (*self, &[][..]).clean(cx)\n+        clean_trait_ref_with_bindings(cx, *self, &[])\n     }\n }\n \n@@ -162,11 +157,9 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n             })\n             .collect();\n \n+        let trait_ = clean_trait_ref_with_bindings(cx, poly_trait_ref.skip_binder(), bindings);\n         GenericBound::TraitBound(\n-            PolyTrait {\n-                trait_: (poly_trait_ref.skip_binder(), bindings).clean(cx),\n-                generic_params: late_bound_regions,\n-            },\n+            PolyTrait { trait_, generic_params: late_bound_regions },\n             hir::TraitBoundModifier::None,\n         )\n     }"}]}