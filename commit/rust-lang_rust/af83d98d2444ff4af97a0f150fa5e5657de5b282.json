{"sha": "af83d98d2444ff4af97a0f150fa5e5657de5b282", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmODNkOThkMjQ0NGZmNGFmOTdhMGYxNTBmYTVlNTY1N2RlNWIyODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T02:19:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T02:19:09Z"}, "message": "Auto merge of #28001 - arielb1:dtor-fixes, r=pnkfelix\n\nr? @pnkfelix", "tree": {"sha": "441e0f6d0a8dc973e0002181e8a334e9b39420cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441e0f6d0a8dc973e0002181e8a334e9b39420cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af83d98d2444ff4af97a0f150fa5e5657de5b282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af83d98d2444ff4af97a0f150fa5e5657de5b282", "html_url": "https://github.com/rust-lang/rust/commit/af83d98d2444ff4af97a0f150fa5e5657de5b282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af83d98d2444ff4af97a0f150fa5e5657de5b282/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "html_url": "https://github.com/rust-lang/rust/commit/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3"}, {"sha": "277eeb95c33ce33090409549b184c9977bf535e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/277eeb95c33ce33090409549b184c9977bf535e5", "html_url": "https://github.com/rust-lang/rust/commit/277eeb95c33ce33090409549b184c9977bf535e5"}], "stats": {"total": 506, "additions": 256, "deletions": 250}, "files": [{"sha": "9153fd6484e2e9632b920f116d6e8eea9549023c", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -548,7 +548,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(def, _) |\n-        ty::TyEnum(def, _) if def.has_dtor(v.tcx) => {\n+        ty::TyEnum(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,"}, {"sha": "d8f3ff3d9cb26c0115038d1ac3861a779509b364", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -239,8 +239,9 @@ impl OverloadedCallType {\n // mem_categorization, it requires a TYPER, which is a type that\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n-\n-pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d> {\n+//\n+// FIXME(stage0): the :'t here is probably only important for stage0\n+pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d+'t> {\n     typer: &'t infer::InferCtxt<'a, 'tcx>,\n     mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n     delegate: &'d mut (Delegate<'tcx>+'d),"}, {"sha": "0c539a5d0e0c2816b0772bed88318929619595f8", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -14,7 +14,6 @@\n use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::CombineFields;\n \n-use middle::subst;\n use middle::ty::{self, TypeError, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n@@ -455,63 +454,6 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     }\n }\n \n-/// Constructs and returns a substitution that, for a given type\n-/// scheme parameterized by `generics`, will replace every generic\n-/// parameter in the type with a skolemized type/region (which one can\n-/// think of as a \"fresh constant\", except at the type/region level of\n-/// reasoning).\n-///\n-/// Since we currently represent bound/free type parameters in the\n-/// same way, this only has an effect on regions.\n-///\n-/// (Note that unlike a substitution from `ty::construct_free_substs`,\n-/// this inserts skolemized regions rather than free regions; this\n-/// allows one to use `fn leak_check` to catch attmepts to unify the\n-/// skolemized regions with e.g. the `'static` lifetime)\n-pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                            generics: &ty::Generics<'tcx>,\n-                                            snapshot: &CombinedSnapshot)\n-                                            -> (subst::Substs<'tcx>, SkolemizationMap)\n-{\n-    let mut map = FnvHashMap();\n-\n-    // map T => T\n-    let mut types = subst::VecPerParamSpace::empty();\n-    push_types_from_defs(infcx.tcx, &mut types, generics.types.as_slice());\n-\n-    // map early- or late-bound 'a => fresh 'a\n-    let mut regions = subst::VecPerParamSpace::empty();\n-    push_region_params(infcx, &mut map, &mut regions, generics.regions.as_slice(), snapshot);\n-\n-    let substs = subst::Substs { types: types,\n-                                 regions: subst::NonerasedRegions(regions) };\n-    return (substs, map);\n-\n-    fn push_region_params<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                   map: &mut SkolemizationMap,\n-                                   regions: &mut subst::VecPerParamSpace<ty::Region>,\n-                                   region_params: &[ty::RegionParameterDef],\n-                                   snapshot: &CombinedSnapshot)\n-    {\n-        for r in region_params {\n-            let br = r.to_bound_region();\n-            let skol_var = infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot);\n-            let sanity_check = map.insert(br, skol_var);\n-            assert!(sanity_check.is_none());\n-            regions.push(r.space, skol_var);\n-        }\n-    }\n-\n-    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n-                                  defs: &[ty::TypeParameterDef<'tcx>]) {\n-        for def in defs {\n-            let ty = tcx.mk_param_from_def(def);\n-            types.push(def.space, ty);\n-        }\n-    }\n-}\n-\n pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)"}, {"sha": "158ef745de33f84543d8dac2b780142e34ca82c2", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -948,15 +948,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn construct_skolemized_subst(&self,\n-                                      generics: &ty::Generics<'tcx>,\n-                                      snapshot: &CombinedSnapshot)\n-                                      -> (subst::Substs<'tcx>, SkolemizationMap) {\n-        /*! See `higher_ranked::construct_skolemized_subst` */\n-\n-        higher_ranked::construct_skolemized_substs(self, generics, snapshot)\n-    }\n-\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)"}, {"sha": "d81f8e0ae9093e55d7f1fa97d23900a56a260212", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        ReSkolemized(sc, br)\n+        ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n     }\n \n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {"}, {"sha": "4eef000169668aa82e1b41ee66cebcfe6fbc246e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -355,9 +355,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {\n-        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().iter() {\n-            if destructor_def_id.is_local() {\n-                self.reachable_symbols.insert(destructor_def_id.node);\n+        for adt in self.tcx.adt_defs() {\n+            if let Some(destructor_def_id) = adt.destructor() {\n+                if destructor_def_id.is_local() {\n+                    self.reachable_symbols.insert(destructor_def_id.node);\n+                }\n             }\n         }\n     }"}, {"sha": "e9be9010d4a8ca815b7005245e4af3d8c3f4b687", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 102, "deletions": 29, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -112,7 +112,7 @@ pub struct CrateAnalysis {\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n-    TraitDtor(DefId, bool)\n+    TraitDtor(bool)\n }\n \n impl DtorKind {\n@@ -126,7 +126,7 @@ impl DtorKind {\n     pub fn has_drop_flag(&self) -> bool {\n         match self {\n             &NoDtor => false,\n-            &TraitDtor(_, flag) => flag\n+            &TraitDtor(flag) => flag\n         }\n     }\n }\n@@ -797,12 +797,6 @@ pub struct ctxt<'tcx> {\n     /// True if the variance has been computed yet; false otherwise.\n     pub variance_computed: Cell<bool>,\n \n-    /// A mapping from the def ID of an enum or struct type to the def ID\n-    /// of the method that implements its destructor. If the type is not\n-    /// present in this map, it does not have a destructor. This map is\n-    /// populated during the coherence phase of typechecking.\n-    pub destructor_for_type: RefCell<DefIdMap<DefId>>,\n-\n     /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n@@ -1502,7 +1496,62 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n-/// Representation of regions:\n+/// Representation of regions.\n+///\n+/// Unlike types, most region variants are \"fictitious\", not concrete,\n+/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n+/// ones representing concrete regions.\n+///\n+/// ## Bound Regions\n+///\n+/// These are regions that are stored behind a binder and must be substituted\n+/// with some concrete region before being used. There are 2 kind of\n+/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// and are substituted by a Substs,  and late-bound, which are part of\n+/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// the likes of `liberate_late_bound_regions`. The distinction exists\n+/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n+///\n+/// Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\"\n+/// outside their binder, e.g. in types passed to type inference, and\n+/// should first be substituted (by skolemized regions, free regions,\n+/// or region variables).\n+///\n+/// ## Skolemized and Free Regions\n+///\n+/// One often wants to work with bound regions without knowing their precise\n+/// identity. For example, when checking a function, the lifetime of a borrow\n+/// can end up being assigned to some region parameter. In these cases,\n+/// it must be ensured that bounds on the region can't be accidentally\n+/// assumed without being checked.\n+///\n+/// The process of doing that is called \"skolemization\". The bound regions\n+/// are replaced by skolemized markers, which don't satisfy any relation\n+/// not explicity provided.\n+///\n+/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n+/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// to be used. These also support explicit bounds: both the internally-stored\n+/// *scope*, which the region is assumed to outlive, as well as other\n+/// relations stored in the `FreeRegionMap`. Note that these relations\n+/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// `resolve_regions_and_report_errors`.\n+///\n+/// When working with higher-ranked types, some region relations aren't\n+/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n+/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// there's also the risk that some inference variable laying around will\n+/// get unified with your skolemized region: if you want to check whether\n+/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n+/// with a skolemized region `'%a`, the variable `'_` would just be\n+/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// the inference variable is supposed to satisfy the relation\n+/// *for every value of the skolemized region*. To ensure that doesn't\n+/// happen, you can use `leak_check`. This is more clearly explained\n+/// by infer/higher_ranked/README.md.\n+///\n+/// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n@@ -1532,7 +1581,7 @@ pub enum Region {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(u32, BoundRegion),\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -2168,6 +2217,11 @@ pub struct RegionVid {\n     pub index: u32\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n@@ -2997,7 +3051,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             _ => return Err(TypeIsStructural),\n         };\n \n-        if adt.has_dtor(tcx) {\n+        if adt.has_dtor() {\n             return Err(TypeHasDestructor)\n         }\n \n@@ -3202,6 +3256,7 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 3,\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n+        const IS_NO_DROP_FLAG     = 1 << 6,\n     }\n }\n \n@@ -3252,6 +3307,7 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n pub struct AdtDefData<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n     pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n }\n \n@@ -3287,6 +3343,9 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n+        if attr::contains_name(&attrs, \"unsafe_no_drop_flag\") {\n+            flags = flags | AdtFlags::IS_NO_DROP_FLAG;\n+        }\n         if tcx.lookup_simd(did) {\n             flags = flags | AdtFlags::IS_SIMD;\n         }\n@@ -3300,6 +3359,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n+            destructor: Cell::new(None)\n         }\n     }\n \n@@ -3350,8 +3410,11 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     }\n \n     /// Returns whether this type has a destructor.\n-    pub fn has_dtor(&self, tcx: &ctxt<'tcx>) -> bool {\n-        tcx.destructor_for_type.borrow().contains_key(&self.did)\n+    pub fn has_dtor(&self) -> bool {\n+        match self.dtor_kind() {\n+            NoDtor => false,\n+            TraitDtor(..) => true\n+        }\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -3413,6 +3476,24 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             _ => panic!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n+\n+    pub fn destructor(&self) -> Option<DefId> {\n+        self.destructor.get()\n+    }\n+\n+    pub fn set_destructor(&self, dtor: DefId) {\n+        assert!(self.destructor.get().is_none());\n+        self.destructor.set(Some(dtor));\n+    }\n+\n+    pub fn dtor_kind(&self) -> DtorKind {\n+        match self.destructor.get() {\n+            Some(_) => {\n+                TraitDtor(!self.flags.get().intersects(AdtFlags::IS_NO_DROP_FLAG))\n+            }\n+            None => NoDtor,\n+        }\n+    }\n }\n \n impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n@@ -3796,7 +3877,6 @@ impl<'tcx> ctxt<'tcx> {\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             provided_method_sources: RefCell::new(DefIdMap()),\n-            destructor_for_type: RefCell::new(DefIdMap()),\n             destructors: RefCell::new(DefIdSet()),\n             inherent_impls: RefCell::new(DefIdMap()),\n             impl_items: RefCell::new(DefIdMap()),\n@@ -4619,7 +4699,7 @@ impl<'tcx> TyS<'tcx> {\n                             })\n                         });\n \n-                    if def.has_dtor(cx) {\n+                    if def.has_dtor() {\n                         res = res | TC::OwnsDtor;\n                     }\n \n@@ -5957,18 +6037,6 @@ impl<'tcx> ctxt<'tcx> {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n \n-    /* If struct_id names a struct with a dtor. */\n-    pub fn ty_dtor(&self, struct_id: DefId) -> DtorKind {\n-        match self.destructor_for_type.borrow().get(&struct_id) {\n-            Some(&method_def_id) => {\n-                let flag = !self.has_attr(struct_id, \"unsafe_no_drop_flag\");\n-\n-                TraitDtor(method_def_id, flag)\n-            }\n-            None => NoDtor,\n-        }\n-    }\n-\n     pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n@@ -6053,6 +6121,11 @@ impl<'tcx> ctxt<'tcx> {\n         self.lookup_adt_def_master(did)\n     }\n \n+    /// Return the list of all interned ADT definitions\n+    pub fn adt_defs(&self) -> Vec<AdtDef<'tcx>> {\n+        self.adt_defs.borrow().values().cloned().collect()\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n@@ -6700,8 +6773,8 @@ impl<'tcx> ctxt<'tcx> {\n     /// Returns true if this ADT is a dtorck type, i.e. whether it being\n     /// safe for destruction requires it to be alive\n     fn is_adt_dtorck(&self, adt: AdtDef<'tcx>) -> bool {\n-        let dtor_method = match self.destructor_for_type.borrow().get(&adt.did) {\n-            Some(dtor) => *dtor,\n+        let dtor_method = match adt.destructor() {\n+            Some(dtor) => dtor,\n             None => return false\n         };\n         let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {"}, {"sha": "ac51f46a7e94354daec181af74c57a6b39f84704", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -418,7 +418,7 @@ impl fmt::Debug for ty::Region {\n             }\n \n             ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id, bound_region)\n+                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n             }\n \n             ty::ReEmpty => write!(f, \"ReEmpty\")"}, {"sha": "7f9128228a576629402505e5c61506ae44a6099c", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -747,7 +747,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor(self.tcx()) => {\n+                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "2d08183ba6ecaf89546d32f4ee1b3910227815de", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -180,7 +180,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n-                    if def.has_dtor(bccx.tcx) {\n+                    if def.has_dtor() {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "465fffe33851f5acdc5d18d11fa2fafd34b5948e", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -137,7 +137,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n-                ty::TyEnum(def, _) if def.has_dtor(bccx.tcx) => {\n+                ty::TyEnum(def, _) if def.has_dtor() => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "e582b9266cd94d36e4d07ba8f4385ac7be3e7440", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -1952,26 +1952,26 @@ impl LintPass for MissingCopyImplementations {\n         if !cx.exported_items.contains(&item.id) {\n             return;\n         }\n-        if cx.tcx.destructor_for_type.borrow().contains_key(&DefId::local(item.id)) {\n-            return;\n-        }\n-        let ty = match item.node {\n+        let (def, ty) = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_struct(cx.tcx.lookup_adt_def(DefId::local(item.id)),\n-                                 cx.tcx.mk_substs(Substs::empty()))\n+                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                (def, cx.tcx.mk_struct(def,\n+                                       cx.tcx.mk_substs(Substs::empty())))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_enum(cx.tcx.lookup_adt_def(DefId::local(item.id)),\n-                               cx.tcx.mk_substs(Substs::empty()))\n+                let def = cx.tcx.lookup_adt_def(DefId::local(item.id));\n+                (def, cx.tcx.mk_enum(def,\n+                                     cx.tcx.mk_substs(Substs::empty())))\n             }\n             _ => return,\n         };\n+        if def.has_dtor() { return; }\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n         // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n         // method\n@@ -2583,7 +2583,7 @@ impl LintPass for DropWithReprExtern {\n                     let self_type_did = self_type_def.did;\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n-                        ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {\n+                        self_type_def.dtor_kind().has_drop_flag() {\n                         let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n                                                                      codemap::DUMMY_SP);\n                         let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,"}, {"sha": "e425ffcaebf647ac242c238b0d7e625e9462516e", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -250,7 +250,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n-            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n+            let dtor = def.dtor_kind().has_drop_flag();\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -265,7 +265,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n+            let dtor = def.dtor_kind().has_drop_flag();\n \n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit"}, {"sha": "64c146e3825b09f439c3bf7bde06477e17833ef8", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -1267,7 +1267,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::TyStruct(def, _) if def.has_dtor(bcx.tcx()) => {\n+                ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }"}, {"sha": "b72f6bbb451bc99a6d2a7b31ae096e6c2ab1572d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 45, "deletions": 70, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -16,11 +16,9 @@\n use back::link::*;\n use llvm;\n use llvm::{ValueRef, get_param};\n-use metadata::csearch;\n-use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::ExchangeFreeFnLangItem;\n-use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n+use middle::traits;\n use middle::ty::{self, Ty};\n use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n@@ -33,16 +31,15 @@ use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n-use trans::foreign;\n-use trans::inline;\n use trans::machine::*;\n use trans::monomorphize;\n-use trans::type_of::{type_of, type_of_dtor, sizing_type_of, align_of};\n+use trans::type_of::{type_of, sizing_type_of, align_of};\n use trans::type_::Type;\n \n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n \n pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n@@ -287,10 +284,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       t: Ty<'tcx>,\n-                                      struct_data: ValueRef,\n-                                      dtor_did: DefId,\n-                                      class_did: DefId,\n-                                      substs: &subst::Substs<'tcx>)\n+                                      struct_data: ValueRef)\n                                       -> Block<'blk, 'tcx> {\n     assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n \n@@ -318,59 +312,19 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n     with_cond(bcx, drop_flag_dtor_needed, |cx| {\n-        trans_struct_drop(cx, t, struct_data, dtor_did, class_did, substs)\n+        trans_struct_drop(cx, t, struct_data)\n     })\n }\n-\n-pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              did: DefId,\n-                              parent_id: DefId,\n-                              substs: &Substs<'tcx>)\n-                              -> ValueRef {\n-    let _icx = push_ctxt(\"trans_res_dtor\");\n-    let did = inline::maybe_instantiate_inline(ccx, did);\n-\n-    if !substs.types.is_empty() {\n-        assert_eq!(did.krate, LOCAL_CRATE);\n-\n-        // Since we're in trans we don't care for any region parameters\n-        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n-\n-        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n-\n-        val\n-    } else if did.is_local() {\n-        get_item_val(ccx, did.node)\n-    } else {\n-        let tcx = ccx.tcx();\n-        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n-        let class_ty = tcx.lookup_item_type(parent_id).ty.subst(tcx, substs);\n-        let llty = type_of_dtor(ccx, class_ty);\n-        foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n-                               llty, ccx.tcx().mk_nil())\n-    }\n-}\n-\n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n-                                 v0: ValueRef,\n-                                 dtor_did: DefId,\n-                                 class_did: DefId,\n-                                 substs: &subst::Substs<'tcx>)\n+                                 v0: ValueRef)\n                                  -> Block<'blk, 'tcx>\n {\n     debug!(\"trans_struct_drop t: {}\", t);\n+    let tcx = bcx.tcx();\n+    let mut bcx = bcx;\n \n-    // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, class_did, substs);\n-\n-    // Class dtors have no explicit args, so the params should\n-    // just consist of the environment (self).\n-    let params = unsafe {\n-        let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n-        ty.element_type().func_params()\n-    };\n-    assert_eq!(params.len(), if type_is_sized(bcx.tcx(), t) { 1 } else { 2 });\n+    let def = t.ty_adt_def().unwrap();\n \n     // Be sure to put the contents into a scope so we can use an invoke\n     // instruction to call the user destructor but still call the field\n@@ -384,15 +338,37 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // discriminant (if any) in case of variant swap in drop code.\n     bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n-    let glue_type = get_drop_glue_type(bcx.ccx(), t);\n-    let dtor_ty = bcx.tcx().mk_ctor_fn(class_did, &[glue_type], bcx.tcx().mk_nil());\n-    let (_, bcx) = if type_is_sized(bcx.tcx(), t) {\n-        invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None)\n+    let (sized_args, unsized_args);\n+    let args: &[ValueRef] = if type_is_sized(tcx, t) {\n+        sized_args = [v0];\n+        &sized_args\n     } else {\n-        let args = [Load(bcx, expr::get_dataptr(bcx, v0)), Load(bcx, expr::get_meta(bcx, v0))];\n-        invoke(bcx, dtor_addr, &args, dtor_ty, DebugLoc::None)\n+        unsized_args = [Load(bcx, expr::get_dataptr(bcx, v0)), Load(bcx, expr::get_meta(bcx, v0))];\n+        &unsized_args\n     };\n \n+    bcx = callee::trans_call_inner(bcx, DebugLoc::None, |bcx, _| {\n+        let trait_ref = ty::Binder(ty::TraitRef {\n+            def_id: tcx.lang_items.drop_trait().unwrap(),\n+            substs: tcx.mk_substs(Substs::trans_empty().with_self_ty(t))\n+        });\n+        let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(data) => data,\n+            _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+        };\n+        let dtor_did = def.destructor().unwrap();\n+        let datum = callee::trans_fn_ref_with_substs(bcx.ccx(),\n+                                                     dtor_did,\n+                                                     ExprId(0),\n+                                                     bcx.fcx.param_substs,\n+                                                     vtbl.substs);\n+        callee::Callee {\n+            bcx: bcx,\n+            data: callee::Fn(datum.val),\n+            ty: datum.ty\n+        }\n+    }, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n@@ -557,27 +533,26 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 })\n             }\n         }\n-        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n-            let tcx = bcx.tcx();\n-            match (tcx.ty_dtor(def.did), skip_dtor) {\n-                (ty::TraitDtor(dtor, true), false) => {\n+        ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+            match (def.dtor_kind(), skip_dtor) {\n+                (ty::TraitDtor(true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n                     if type_is_sized(bcx.tcx(), t) {\n-                        trans_struct_drop_flag(bcx, t, v0, dtor, def.did, substs)\n+                        trans_struct_drop_flag(bcx, t, v0)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\", t));\n-                        trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n+                        trans_struct_drop(bcx, t, v0)\n                     }\n                 }\n-                (ty::TraitDtor(dtor, false), false) => {\n-                    trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n+                (ty::TraitDtor(false), false) => {\n+                    trans_struct_drop(bcx, t, v0)\n                 }\n                 (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case"}, {"sha": "171d6961470bf48c9a3a9fb2f4ef7a42ba01fe65", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -487,11 +487,3 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         format!(\"{}.{}\", did.krate, tstr)\n     }\n }\n-\n-pub fn type_of_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, self_ty: Ty<'tcx>) -> Type {\n-    if type_is_sized(ccx.tcx(), self_ty) {\n-        Type::func(&[type_of(ccx, self_ty).ptr_to()], &Type::void(ccx))\n-    } else {\n-        Type::func(&type_of(ccx, self_ty).field_types(), &Type::void(ccx))\n-    }\n-}"}, {"sha": "a8c77f863b7008175a9df4d2a601aebf1f55d5ed", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -11,9 +11,11 @@\n use check::regionck::{self, Rcx};\n \n use middle::def_id::{DefId, LOCAL_CRATE};\n+use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n+use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::FnvHashSet;\n \n@@ -75,61 +77,41 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: &ty::Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n-    // New strategy based on review suggestion from nikomatsakis.\n-    //\n-    // (In the text and code below, \"named\" denotes \"struct/enum\", and\n-    // \"generic params\" denotes \"type and region params\")\n-    //\n-    // 1. Create fresh skolemized type/region \"constants\" for each of\n-    //    the named type's generic params.  Instantiate the named type\n-    //    with the fresh constants, yielding `named_skolem`.\n-    //\n-    // 2. Create unification variables for each of the Drop impl's\n-    //    generic params.  Instantiate the impl's Self's type with the\n-    //    unification-vars, yielding `drop_unifier`.\n-    //\n-    // 3. Attempt to unify Self_unif with Type_skolem.  If unification\n-    //    succeeds, continue (i.e. with the predicate checks).\n-\n-    let ty::TypeScheme { generics: ref named_type_generics,\n-                         ty: named_type } =\n-        tcx.lookup_item_type(self_type_did);\n-\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-\n-    infcx.commit_if_ok(|snapshot| {\n-        let (named_type_to_skolem, skol_map) =\n-            infcx.construct_skolemized_subst(named_type_generics, snapshot);\n-        let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);\n-\n-        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n-        let drop_to_unifier =\n-            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n-        let drop_unifier = drop_impl_ty.subst(tcx, &drop_to_unifier);\n-\n-        if let Ok(()) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n-                                       named_type_skolem, drop_unifier) {\n-            // Even if we did manage to equate the types, the process\n-            // may have just gathered unsolvable region constraints\n-            // like `R == 'static` (represented as a pair of subregion\n-            // constraints) for some skolemization constant R.\n-            //\n-            // However, the leak_check method allows us to confirm\n-            // that no skolemized regions escaped (i.e. were related\n-            // to other regions in the constraint graph).\n-            if let Ok(()) = infcx.leak_check(&skol_map, snapshot) {\n-                return Ok(())\n-            }\n-        }\n+    assert!(drop_impl_did.is_local() && self_type_did.is_local());\n+\n+    // check that the impl type can be made to match the trait type.\n+\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_did.node);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n+\n+    let named_type = tcx.lookup_item_type(self_type_did).ty;\n+    let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+    let fresh_impl_substs =\n+        infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+    let fresh_impl_self_ty = drop_impl_ty.subst(tcx, &fresh_impl_substs);\n+\n+    if let Err(_) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                   named_type, fresh_impl_self_ty) {\n         span_err!(tcx.sess, drop_impl_span, E0366,\n                   \"Implementations of Drop cannot be specialized\");\n         let item_span = tcx.map.span(self_type_did.node);\n         tcx.sess.span_note(item_span,\n                            \"Use same sequence of generic type and region \\\n                             parameters that is on the struct/enum definition\");\n         return Err(());\n-    })\n+    }\n+\n+    if let Err(ref errors) = infcx.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+        // this could be reached when we get lazy normalization\n+        traits::report_fulfillment_errors(&infcx, errors);\n+        return Err(());\n+    }\n+\n+    let free_regions = FreeRegionMap::new();\n+    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_did.node);\n+    Ok(())\n }\n \n /// Confirms that every predicate imposed by dtor_predicates is"}, {"sha": "f8778fbc42d2de12953e5dad8f38b917de0172a7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -311,9 +311,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::TyEnum(type_def, _) |\n                 ty::TyStruct(type_def, _) => {\n-                    tcx.destructor_for_type\n-                       .borrow_mut()\n-                       .insert(type_def.did, method_def_id.def_id());\n+                    type_def.set_destructor(method_def_id.def_id());\n                     tcx.destructors\n                        .borrow_mut()\n                        .insert(method_def_id.def_id());"}, {"sha": "b12e26fddf6d20a86175441a6aaab8bb8428040f", "filename": "src/test/compile-fail/reject-specialized-drops-8142.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -37,7 +37,9 @@ impl<'al,'adds_bnd>     Drop for L<'al,'adds_bnd> where 'adds_bnd:'al {    // RE\n impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // ACCEPT\n \n impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n-//~^ ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR mismatched types\n+//~| expected `N<'n>`\n+//~|    found `N<'static>`\n \n impl<Cok_nobound> Drop for O<Cok_nobound> { fn drop(&mut self) { } } // ACCEPT\n \n@@ -57,9 +59,9 @@ impl<'t,Bt:'t>    Drop for T<'t,Bt>       { fn drop(&mut self) { } } // ACCEPT\n impl              Drop for U              { fn drop(&mut self) { } } // ACCEPT\n \n impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n-//~^ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR Implementations of Drop cannot be specialized\n \n impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n-//~^ERROR Implementations of Drop cannot be specialized\n+//~^ ERROR cannot infer an appropriate lifetime\n \n pub fn main() { }"}, {"sha": "cd81f68969377d60d8a794a3866d208e5565daca", "filename": "src/test/run-pass/issue-27997.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af83d98d2444ff4af97a0f150fa5e5657de5b282/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27997.rs?ref=af83d98d2444ff4af97a0f150fa5e5657de5b282", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+use std::sync::atomic::{Ordering, AtomicUsize};\n+\n+use std::mem;\n+struct S<U,V> {\n+    _u: U,\n+    size_of_u: usize,\n+    _v: V,\n+    size_of_v: usize\n+}\n+\n+impl<U, V> S<U, V> {\n+    fn new(u: U, v: V) -> Self {\n+        S {\n+            _u: u,\n+            size_of_u: mem::size_of::<U>(),\n+            _v: v,\n+            size_of_v: mem::size_of::<V>()\n+        }\n+    }\n+}\n+\n+static COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+impl<V, U> Drop for S<U, V> {\n+    fn drop(&mut self) {\n+        assert_eq!(mem::size_of::<U>(), self.size_of_u);\n+        assert_eq!(mem::size_of::<V>(), self.size_of_v);\n+        COUNT.store(COUNT.load(Ordering::SeqCst)+1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(COUNT.load(Ordering::SeqCst), 0);\n+    { S::new(0u8, 1u16); }\n+    assert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}"}]}