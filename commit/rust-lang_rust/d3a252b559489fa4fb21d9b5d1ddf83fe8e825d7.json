{"sha": "d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYTI1MmI1NTk0ODlmYTRmYjIxZDliNWQxZGRmODNmZThlODI1ZDc=", "commit": {"author": {"name": "Wilco Kusee", "email": "wilcokusee@gmail.com", "date": "2019-03-02T19:20:26Z"}, "committer": {"name": "Wilco Kusee", "email": "wilcokusee@gmail.com", "date": "2019-03-02T19:30:13Z"}, "message": "Replace option with result in mbe", "tree": {"sha": "80323490e7c0b963d15694bb9600e5b889098630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80323490e7c0b963d15694bb9600e5b889098630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "html_url": "https://github.com/rust-lang/rust/commit/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/comments", "author": {"login": "detrumi", "id": 5758008, "node_id": "MDQ6VXNlcjU3NTgwMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5758008?v=4", "gravatar_id": "", "url": "https://api.github.com/users/detrumi", "html_url": "https://github.com/detrumi", "followers_url": "https://api.github.com/users/detrumi/followers", "following_url": "https://api.github.com/users/detrumi/following{/other_user}", "gists_url": "https://api.github.com/users/detrumi/gists{/gist_id}", "starred_url": "https://api.github.com/users/detrumi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/detrumi/subscriptions", "organizations_url": "https://api.github.com/users/detrumi/orgs", "repos_url": "https://api.github.com/users/detrumi/repos", "events_url": "https://api.github.com/users/detrumi/events{/privacy}", "received_events_url": "https://api.github.com/users/detrumi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "detrumi", "id": 5758008, "node_id": "MDQ6VXNlcjU3NTgwMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5758008?v=4", "gravatar_id": "", "url": "https://api.github.com/users/detrumi", "html_url": "https://github.com/detrumi", "followers_url": "https://api.github.com/users/detrumi/followers", "following_url": "https://api.github.com/users/detrumi/following{/other_user}", "gists_url": "https://api.github.com/users/detrumi/gists{/gist_id}", "starred_url": "https://api.github.com/users/detrumi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/detrumi/subscriptions", "organizations_url": "https://api.github.com/users/detrumi/orgs", "repos_url": "https://api.github.com/users/detrumi/repos", "events_url": "https://api.github.com/users/detrumi/events{/privacy}", "received_events_url": "https://api.github.com/users/detrumi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "592b906604d60a86af74c5dbb3bf40b2ddcf8061", "url": "https://api.github.com/repos/rust-lang/rust/commits/592b906604d60a86af74c5dbb3bf40b2ddcf8061", "html_url": "https://github.com/rust-lang/rust/commit/592b906604d60a86af74c5dbb3bf40b2ddcf8061"}], "stats": {"total": 167, "additions": 93, "deletions": 74}, "files": [{"sha": "8a2d6ff6351adc076caebe55af260ba043e5e043", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "patch": "@@ -24,6 +24,15 @@ use ra_syntax::SmolStr;\n \n pub use tt::{Delimiter, Punct};\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub enum MacroRulesError {\n+    NoMatchingRule,\n+    UnexpectedToken,\n+    BindingError(String),\n+    ParseError,\n+}\n+\n+pub type Result<T> = ::std::result::Result<T, MacroRulesError>;\n pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list};\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n@@ -36,11 +45,11 @@ pub struct MacroRules {\n }\n \n impl MacroRules {\n-    pub fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n+    pub fn parse(tt: &tt::Subtree) -> Result<MacroRules> {\n         mbe_parser::parse(tt)\n     }\n-    pub fn expand(&self, tt: &tt::Subtree) -> Option<tt::Subtree> {\n-        mbe_expander::exapnd(self, tt)\n+    pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree> {\n+        mbe_expander::expand(self, tt)\n     }\n }\n "}, {"sha": "c393d8487f21caeb103a5b973691f48707d8f52d", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "patch": "@@ -5,17 +5,19 @@ use rustc_hash::FxHashMap;\n use ra_syntax::SmolStr;\n use tt::TokenId;\n \n+use crate::{MacroRulesError, Result};\n use crate::tt_cursor::TtCursor;\n \n-pub(crate) fn exapnd(rules: &crate::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n-    rules.rules.iter().find_map(|it| expand_rule(it, input))\n+pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> Result<tt::Subtree> {\n+    rules.rules.iter().find_map(|it| expand_rule(it, input).ok())\n+        .ok_or(MacroRulesError::NoMatchingRule)\n }\n \n-fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n+fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree> {\n     let mut input = TtCursor::new(input);\n     let bindings = match_lhs(&rule.lhs, &mut input)?;\n     if !input.is_eof() {\n-        return None;\n+        return Err(MacroRulesError::UnexpectedToken);\n     }\n     expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n }\n@@ -77,40 +79,47 @@ enum Binding {\n }\n \n impl Bindings {\n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Option<&tt::TokenTree> {\n-        let mut b = self.inner.get(name)?;\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&tt::TokenTree> {\n+        let mut b = self.inner.get(name).ok_or(MacroRulesError::BindingError(\n+            format!(\"could not find binding {}\", name)\n+        ))?;\n         for &idx in nesting.iter() {\n             b = match b {\n                 Binding::Simple(_) => break,\n-                Binding::Nested(bs) => bs.get(idx)?,\n+                Binding::Nested(bs) => bs.get(idx).ok_or(MacroRulesError::BindingError(\n+                    format!(\"could not find nested binding {}\", name))\n+                )?,\n             };\n         }\n         match b {\n-            Binding::Simple(it) => Some(it),\n-            Binding::Nested(_) => None,\n+            Binding::Simple(it) => Ok(it),\n+            Binding::Nested(_) => Err(MacroRulesError::BindingError(\n+                    format!(\"expected simple binding, found nested binding {}\", name))),\n         }\n     }\n-    fn push_nested(&mut self, nested: Bindings) -> Option<()> {\n+\n+    fn push_nested(&mut self, nested: Bindings) -> Result<()> {\n         for (key, value) in nested.inner {\n             if !self.inner.contains_key(&key) {\n                 self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n             }\n             match self.inner.get_mut(&key) {\n                 Some(Binding::Nested(it)) => it.push(value),\n-                _ => return None,\n+                _ => return Err(MacroRulesError::BindingError(\n+                    format!(\"nested binding for {} not found\", key))),\n             }\n         }\n-        Some(())\n+        Ok(())\n     }\n }\n \n-fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n+fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings> {\n     let mut res = Bindings::default();\n     for pat in pattern.token_trees.iter() {\n         match pat {\n             crate::TokenTree::Leaf(leaf) => match leaf {\n                 crate::Leaf::Var(crate::Var { text, kind }) => {\n-                    let kind = kind.clone()?;\n+                    let kind = kind.clone().ok_or(MacroRulesError::ParseError)?;\n                     match kind.as_str() {\n                         \"ident\" => {\n                             let ident = input.eat_ident()?.clone();\n@@ -119,28 +128,28 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings>\n                                 Binding::Simple(tt::Leaf::from(ident).into()),\n                             );\n                         }\n-                        _ => return None,\n+                        _ => return Err(MacroRulesError::UnexpectedToken),\n                     }\n                 }\n                 crate::Leaf::Punct(punct) => {\n                     if input.eat_punct()? != punct {\n-                        return None;\n+                        return Err(MacroRulesError::UnexpectedToken);\n                     }\n                 }\n                 crate::Leaf::Ident(ident) => {\n                     if input.eat_ident()?.text != ident.text {\n-                        return None;\n+                        return Err(MacroRulesError::UnexpectedToken);\n                     }\n                 }\n-                _ => return None,\n+                _ => return Err(MacroRulesError::UnexpectedToken),\n             },\n             crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n-                while let Some(nested) = match_lhs(subtree, input) {\n+                while let Ok(nested) = match_lhs(subtree, input) {\n                     res.push_nested(nested)?;\n                     if let Some(separator) = *separator {\n                         if !input.is_eof() {\n                             if input.eat_punct()?.char != separator {\n-                                return None;\n+                                return Err(MacroRulesError::UnexpectedToken);\n                             }\n                         }\n                     }\n@@ -149,34 +158,34 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings>\n             _ => {}\n         }\n     }\n-    Some(res)\n+    Ok(res)\n }\n \n fn expand_subtree(\n     template: &crate::Subtree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n-) -> Option<tt::Subtree> {\n+) -> Result<tt::Subtree> {\n     let token_trees = template\n         .token_trees\n         .iter()\n         .map(|it| expand_tt(it, bindings, nesting))\n-        .collect::<Option<Vec<_>>>()?;\n+        .collect::<Result<Vec<_>>>()?;\n \n-    Some(tt::Subtree { token_trees, delimiter: template.delimiter })\n+    Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n }\n \n fn expand_tt(\n     template: &crate::TokenTree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n-) -> Option<tt::TokenTree> {\n+) -> Result<tt::TokenTree> {\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees = Vec::new();\n             nesting.push(0);\n-            while let Some(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+            while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n                 let idx = nesting.pop().unwrap();\n                 nesting.push(idx + 1);\n                 token_trees.push(t.into())\n@@ -194,5 +203,5 @@ fn expand_tt(\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };\n-    Some(res)\n+    Ok(res)\n }"}, {"sha": "ee1b11091700f4422f3eba4bfb6d44fb4329c27a", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "patch": "@@ -1,40 +1,41 @@\n /// This module parses a raw `tt::TokenStream` into macro-by-example token\n /// stream. This is a *mostly* identify function, expect for handling of\n /// `$var:tt_kind` and `$(repeat),*` constructs.\n+use crate::{MacroRulesError, Result};\n use crate::tt_cursor::TtCursor;\n \n-pub(crate) fn parse(tt: &tt::Subtree) -> Option<crate::MacroRules> {\n+pub(crate) fn parse(tt: &tt::Subtree) -> Result<crate::MacroRules> {\n     let mut parser = TtCursor::new(tt);\n     let mut rules = Vec::new();\n     while !parser.is_eof() {\n         rules.push(parse_rule(&mut parser)?);\n-        if parser.expect_char(';') == None {\n+        if let Err(e) = parser.expect_char(';') {\n             if !parser.is_eof() {\n-                return None;\n+                return Err(e);\n             }\n             break;\n         }\n     }\n-    Some(crate::MacroRules { rules })\n+    Ok(crate::MacroRules { rules })\n }\n \n-fn parse_rule(p: &mut TtCursor) -> Option<crate::Rule> {\n+fn parse_rule(p: &mut TtCursor) -> Result<crate::Rule> {\n     let lhs = parse_subtree(p.eat_subtree()?)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n     let mut rhs = parse_subtree(p.eat_subtree()?)?;\n     rhs.delimiter = crate::Delimiter::None;\n-    Some(crate::Rule { lhs, rhs })\n+    Ok(crate::Rule { lhs, rhs })\n }\n \n-fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n+fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree> {\n     let mut token_trees = Vec::new();\n     let mut p = TtCursor::new(tt);\n-    while let Some(tt) = p.eat() {\n+    while let Ok(tt) = p.eat() {\n         let child: crate::TokenTree = match tt {\n             tt::TokenTree::Leaf(leaf) => match leaf {\n                 tt::Leaf::Punct(tt::Punct { char: '$', .. }) => {\n-                    if p.at_ident().is_some() {\n+                    if p.at_ident().is_ok() {\n                         crate::Leaf::from(parse_var(&mut p)?).into()\n                     } else {\n                         parse_repeat(&mut p)?.into()\n@@ -52,15 +53,15 @@ fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n         };\n         token_trees.push(child);\n     }\n-    Some(crate::Subtree { token_trees, delimiter: tt.delimiter })\n+    Ok(crate::Subtree { token_trees, delimiter: tt.delimiter })\n }\n \n-fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n+fn parse_var(p: &mut TtCursor) -> Result<crate::Var> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n     let kind = if p.at_char(':') {\n         p.bump();\n-        if let Some(ident) = p.eat_ident() {\n+        if let Ok(ident) = p.eat_ident() {\n             Some(ident.text.clone())\n         } else {\n             p.rev_bump();\n@@ -69,10 +70,10 @@ fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n     } else {\n         None\n     };\n-    Some(crate::Var { text, kind })\n+    Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor) -> Option<crate::Repeat> {\n+fn parse_repeat(p: &mut TtCursor) -> Result<crate::Repeat> {\n     let subtree = p.eat_subtree().unwrap();\n     let mut subtree = parse_subtree(subtree)?;\n     subtree.delimiter = crate::Delimiter::None;\n@@ -86,8 +87,8 @@ fn parse_repeat(p: &mut TtCursor) -> Option<crate::Repeat> {\n         '*' => crate::RepeatKind::ZeroOrMore,\n         '+' => crate::RepeatKind::OneOrMore,\n         '?' => crate::RepeatKind::ZeroOrOne,\n-        _ => return None,\n+        _ => return Err(MacroRulesError::ParseError),\n     };\n     p.bump();\n-    Some(crate::Repeat { subtree, kind, separator })\n+    Ok(crate::Repeat { subtree, kind, separator })\n }"}, {"sha": "1174718416d09e450c7358f50d6192a6065cf2bb", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=d3a252b559489fa4fb21d9b5d1ddf83fe8e825d7", "patch": "@@ -1,3 +1,5 @@\n+use crate::{MacroRulesError, Result};\n+\n #[derive(Clone)]\n pub(crate) struct TtCursor<'a> {\n     subtree: &'a tt::Subtree,\n@@ -17,24 +19,24 @@ impl<'a> TtCursor<'a> {\n         self.subtree.token_trees.get(self.pos)\n     }\n \n-    pub(crate) fn at_punct(&self) -> Option<&'a tt::Punct> {\n+    pub(crate) fn at_punct(&self) -> Result<&'a tt::Punct> {\n         match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n-            _ => None,\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Ok(it),\n+            _ => Err(MacroRulesError::ParseError),\n         }\n     }\n \n     pub(crate) fn at_char(&self, char: char) -> bool {\n         match self.at_punct() {\n-            Some(tt::Punct { char: c, .. }) if *c == char => true,\n+            Ok(tt::Punct { char: c, .. }) if *c == char => true,\n             _ => false,\n         }\n     }\n \n-    pub(crate) fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n+    pub(crate) fn at_ident(&mut self) -> Result<&'a tt::Ident> {\n         match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n-            _ => None,\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Ok(i),\n+            _ => Err(MacroRulesError::ParseError),\n         }\n     }\n \n@@ -45,47 +47,45 @@ impl<'a> TtCursor<'a> {\n         self.pos -= 1;\n     }\n \n-    pub(crate) fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n+    pub(crate) fn eat(&mut self) -> Result<&'a tt::TokenTree> {\n         match self.current() {\n             Some(it) => {\n                 self.bump();\n-                Some(it)\n+                Ok(it)\n             }\n-            None => None,\n+            None => Err(MacroRulesError::ParseError),\n         }\n     }\n \n-    pub(crate) fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n-        match self.current()? {\n-            tt::TokenTree::Subtree(sub) => {\n+    pub(crate) fn eat_subtree(&mut self) -> Result<&'a tt::Subtree> {\n+        match self.current() {\n+            Some(tt::TokenTree::Subtree(sub)) => {\n                 self.bump();\n-                Some(sub)\n+                Ok(sub)\n             }\n-            _ => return None,\n+            _ => Err(MacroRulesError::ParseError),\n         }\n     }\n \n-    pub(crate) fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n-        if let Some(it) = self.at_punct() {\n+    pub(crate) fn eat_punct(&mut self) -> Result<&'a tt::Punct> {\n+        self.at_punct().map(|it| {\n             self.bump();\n-            return Some(it);\n-        }\n-        None\n+            it\n+        })\n     }\n \n-    pub(crate) fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n-        if let Some(i) = self.at_ident() {\n+    pub(crate) fn eat_ident(&mut self) -> Result<&'a tt::Ident> {\n+        self.at_ident().map(|i| {\n             self.bump();\n-            return Some(i);\n-        }\n-        None\n+            i\n+        })\n     }\n \n-    pub(crate) fn expect_char(&mut self, char: char) -> Option<()> {\n+    pub(crate) fn expect_char(&mut self, char: char) -> Result<()> {\n         if self.at_char(char) {\n             self.bump();\n-            return Some(());\n+            return Ok(());\n         }\n-        None\n+        Err(MacroRulesError::ParseError)\n     }\n }"}]}