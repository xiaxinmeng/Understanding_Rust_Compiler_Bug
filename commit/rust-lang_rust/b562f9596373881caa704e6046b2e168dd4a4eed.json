{"sha": "b562f9596373881caa704e6046b2e168dd4a4eed", "node_id": "C_kwDOAAsO6NoAKGI1NjJmOTU5NjM3Mzg4MWNhYTcwNGU2MDQ2YjJlMTY4ZGQ0YTRlZWQ", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-22T18:25:56Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-22T18:34:06Z"}, "message": "Refactor part of codegen_call_terminator", "tree": {"sha": "1866cd11ad50cd5a9932249f4729b05086c5bcbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1866cd11ad50cd5a9932249f4729b05086c5bcbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b562f9596373881caa704e6046b2e168dd4a4eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b562f9596373881caa704e6046b2e168dd4a4eed", "html_url": "https://github.com/rust-lang/rust/commit/b562f9596373881caa704e6046b2e168dd4a4eed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b562f9596373881caa704e6046b2e168dd4a4eed/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0dc8d78019ca924203fe153ff0af7f64f68cb5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0dc8d78019ca924203fe153ff0af7f64f68cb5d", "html_url": "https://github.com/rust-lang/rust/commit/e0dc8d78019ca924203fe153ff0af7f64f68cb5d"}], "stats": {"total": 91, "additions": 44, "deletions": 47}, "files": [{"sha": "47a40be5d8c5b9df7f478a89c55b45cdac8969d8", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b562f9596373881caa704e6046b2e168dd4a4eed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b562f9596373881caa704e6046b2e168dd4a4eed/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=b562f9596373881caa704e6046b2e168dd4a4eed", "patch": "@@ -798,58 +798,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                if let Pair(..) = op.val {\n-                    // In the case of Rc<Self>, we need to explicitly pass a\n-                    // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n-                    // that is understood elsewhere in the compiler as a method on\n-                    // `dyn Trait`.\n-                    // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                    // we get a value of a built-in pointer type\n-                    'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                        && !op.layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..op.layout.fields.count() {\n-                            let field = op.extract_field(&mut bx, i);\n-                            if !field.layout.is_zst() {\n-                                // we found the one non-zero-sized field that is allowed\n-                                // now find *its* non-zero-sized field, or stop if it's a\n-                                // pointer\n-                                op = field;\n-                                continue 'descend_newtypes;\n+                match op.val {\n+                    Pair(data_ptr, meta) => {\n+                        // In the case of Rc<Self>, we need to explicitly pass a\n+                        // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                        // that is understood elsewhere in the compiler as a method on\n+                        // `dyn Trait`.\n+                        // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                        // we get a value of a built-in pointer type\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(&mut bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n                             }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n                         }\n \n-                        span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                        // data pointer and vtable. Look up the method in the vtable, and pass\n+                        // the data pointer as the first argument\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue 'make_args;\n                     }\n-\n-                    // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n-                    // data pointer and vtable. Look up the method in the vtable, and pass\n-                    // the data pointer as the first argument\n-                    match op.val {\n-                        Pair(data_ptr, meta) => {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                                &mut bx,\n-                                meta,\n-                                op.layout.ty,\n-                                &fn_abi,\n-                            ));\n-                            llargs.push(data_ptr);\n-                            continue 'make_args;\n-                        }\n-                        other => bug!(\"expected a Pair, got {:?}\", other),\n+                    Ref(data_ptr, Some(meta), _) => {\n+                        // by-value dynamic dispatch\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue;\n                     }\n-                } else if let Ref(data_ptr, Some(meta), _) = op.val {\n-                    // by-value dynamic dispatch\n-                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                        &mut bx,\n-                        meta,\n-                        op.layout.ty,\n-                        &fn_abi,\n-                    ));\n-                    llargs.push(data_ptr);\n-                    continue;\n-                } else {\n-                    span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n+                    _ => span_bug!(span, \"can't codegen a virtual call on {:?}\", op),\n                 }\n             }\n "}]}