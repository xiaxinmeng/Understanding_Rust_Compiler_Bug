{"sha": "b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "node_id": "C_kwDOAAsO6NoAKGIwZWMzZTA5YTk5NmYyY2IzNWJlNzcxMGZkMTAwM2MzYzM4ZjE2Njc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T20:34:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T20:34:18Z"}, "message": "Auto merge of #91948 - nnethercote:rustdoc-more-Symbols, r=GuillaumeGomez\n\nrustdoc: avoid many `Symbol` to `String` conversions.\n\nParticularly when constructing file paths and fully qualified paths.\nThis avoids a lot of allocations, speeding things up on almost all\nexamples.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "d16992ea23c034bc46d776ef9aec8fd04172bfdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d16992ea23c034bc46d776ef9aec8fd04172bfdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "html_url": "https://github.com/rust-lang/rust/commit/b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad46af24713115e7b9b258346e66b9b2d14eacfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad46af24713115e7b9b258346e66b9b2d14eacfc", "html_url": "https://github.com/rust-lang/rust/commit/ad46af24713115e7b9b258346e66b9b2d14eacfc"}, {"sha": "c7147e4e1acd49ea01e6d67a85c270946554783a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7147e4e1acd49ea01e6d67a85c270946554783a", "html_url": "https://github.com/rust-lang/rust/commit/c7147e4e1acd49ea01e6d67a85c270946554783a"}], "stats": {"total": 425, "additions": 256, "deletions": 169}, "files": [{"sha": "5134d916320ad7094cc8c4d0ee070a68433750e2", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -567,6 +567,7 @@ symbols! {\n         doc_spotlight,\n         doctest,\n         document_private_items,\n+        dotdot: \"..\",\n         dotdot_in_tuple_patterns,\n         dotdoteq_in_patterns,\n         dreg,"}, {"sha": "a2e612955b3498cecb506dc756b9d2735af0e0e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -9,7 +9,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n use rustc_hir::Mutability;\n use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -164,12 +163,10 @@ crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n-    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n+    let crate_name = cx.tcx.crate_name(did.krate);\n \n-    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // Filter out extern blocks\n-        (elem.data != DefPathData::ForeignMod).then(|| elem.data.to_string())\n-    });\n+    let relative =\n+        cx.tcx.def_path(did).data.into_iter().filter_map(|elem| elem.data.get_opt_name());\n     let fqn = if let ItemType::Macro = kind {\n         // Check to see if it is a macro 2.0 or built-in macro\n         if matches!("}, {"sha": "a8fef4a317802c7fd39ca71513d559977c69ed94", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -4,13 +4,14 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use crate::clean::{self, types::ExternalLocation, ExternalCrate, ItemId, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n+use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n@@ -39,11 +40,11 @@ crate struct Cache {\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    crate paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    crate external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -55,7 +56,7 @@ crate struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -92,7 +93,7 @@ crate struct Cache {\n     crate masked_crates: FxHashSet<CrateNum>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n-    stack: Vec<String>,\n+    stack: Vec<Symbol>,\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     stripped_mod: bool,\n@@ -155,7 +156,7 @@ impl Cache {\n             let dst = &render_options.output;\n             let location = e.location(extern_url, extern_url_takes_precedence, dst, tcx);\n             cx.cache.extern_locations.insert(e.crate_num, location);\n-            cx.cache.external_paths.insert(e.def_id(), (vec![name.to_string()], ItemType::Module));\n+            cx.cache.external_paths.insert(e.def_id(), (vec![name], ItemType::Module));\n         }\n \n         // FIXME: avoid this clone (requires implementing Default manually)\n@@ -164,10 +165,9 @@ impl Cache {\n             let crate_name = tcx.crate_name(def_id.krate);\n             // Recall that we only allow primitive modules to be at the root-level of the crate.\n             // If that restriction is ever lifted, this will have to include the relative paths instead.\n-            cx.cache.external_paths.insert(\n-                def_id,\n-                (vec![crate_name.to_string(), prim.as_sym().to_string()], ItemType::Primitive),\n-            );\n+            cx.cache\n+                .external_paths\n+                .insert(def_id, (vec![crate_name, prim.as_sym()], ItemType::Primitive));\n         }\n \n         krate = CacheBuilder { tcx, cache: &mut cx.cache }.fold_crate(krate);\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n-                            path: path.join(\"::\"),\n+                            path: join_with_double_colon(path),\n                             desc,\n                             parent,\n                             parent_idx: None,\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Keep track of the fully qualified path for this item.\n         let pushed = match item.name {\n             Some(n) if !n.is_empty() => {\n-                self.cache.stack.push(n.to_string());\n+                self.cache.stack.push(n);\n                 true\n             }\n             _ => false,"}, {"sha": "8571a6a137f5101687d769642177c6a60df46c59", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n+use rustc_span::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{\n@@ -29,6 +30,7 @@ use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::Context;\n \n+use super::url_parts_builder::estimate_item_path_byte_length;\n use super::url_parts_builder::UrlPartsBuilder;\n \n crate trait Print {\n@@ -502,11 +504,22 @@ crate enum HrefError {\n     NotInExternalCache,\n }\n \n+// Panics if `syms` is empty.\n+crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n+    let mut s = String::with_capacity(estimate_item_path_byte_length(syms.len()));\n+    s.push_str(&syms[0].as_str());\n+    for sym in &syms[1..] {\n+        s.push_str(\"::\");\n+        s.push_str(&sym.as_str());\n+    }\n+    s\n+}\n+\n crate fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n     root_path: Option<&str>,\n-) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     let tcx = cx.tcx();\n     let def_kind = tcx.def_kind(did);\n     let did = match def_kind {\n@@ -518,7 +531,7 @@ crate fn href_with_root_path(\n     };\n     let cache = cx.cache();\n     let relative_to = &cx.current;\n-    fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n+    fn to_module_fqp(shortty: ItemType, fqp: &[Symbol]) -> &[Symbol] {\n         if shortty == ItemType::Module { fqp } else { &fqp[..fqp.len() - 1] }\n     }\n \n@@ -533,9 +546,9 @@ crate fn href_with_root_path(\n     let mut is_remote = false;\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n-            let module_fqp = to_module_fqp(shortty, fqp);\n+            let module_fqp = to_module_fqp(shortty, fqp.as_slice());\n             debug!(?fqp, ?shortty, ?module_fqp);\n-            href_relative_parts(module_fqp, relative_to)\n+            href_relative_parts(module_fqp, relative_to).collect()\n         }),\n         None => {\n             if let Some(&(ref fqp, shortty)) = cache.external_paths.get(&did) {\n@@ -548,10 +561,12 @@ crate fn href_with_root_path(\n                             is_remote = true;\n                             let s = s.trim_end_matches('/');\n                             let mut builder = UrlPartsBuilder::singleton(s);\n-                            builder.extend(module_fqp.iter().map(String::as_str));\n+                            builder.extend(module_fqp.iter().copied());\n                             builder\n                         }\n-                        ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n+                        ExternalLocation::Local => {\n+                            href_relative_parts(module_fqp, relative_to).collect()\n+                        }\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n                     },\n                 )\n@@ -567,45 +582,50 @@ crate fn href_with_root_path(\n         }\n     }\n     debug!(?url_parts);\n-    let last = &fqp.last().unwrap()[..];\n     match shortty {\n         ItemType::Module => {\n             url_parts.push(\"index.html\");\n         }\n         _ => {\n-            let filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n-            url_parts.push(&filename);\n+            let prefix = shortty.as_str();\n+            let last = fqp.last().unwrap();\n+            url_parts.push_fmt(format_args!(\"{}.{}.html\", prefix, last));\n         }\n     }\n     Ok((url_parts.finish(), shortty, fqp.to_vec()))\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     href_with_root_path(did, cx, None)\n }\n \n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n-crate fn href_relative_parts(fqp: &[String], relative_to_fqp: &[String]) -> UrlPartsBuilder {\n+crate fn href_relative_parts<'fqp>(\n+    fqp: &'fqp [Symbol],\n+    relative_to_fqp: &[Symbol],\n+) -> Box<dyn Iterator<Item = Symbol> + 'fqp> {\n     for (i, (f, r)) in fqp.iter().zip(relative_to_fqp.iter()).enumerate() {\n         // e.g. linking to std::iter from std::vec (`dissimilar_part_count` will be 1)\n         if f != r {\n             let dissimilar_part_count = relative_to_fqp.len() - i;\n-            let fqp_module = fqp[i..fqp.len()].iter().map(String::as_str);\n-            return iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n+            let fqp_module = &fqp[i..fqp.len()];\n+            return box iter::repeat(sym::dotdot)\n+                .take(dissimilar_part_count)\n+                .chain(fqp_module.iter().copied());\n         }\n     }\n     // e.g. linking to std::sync::atomic from std::sync\n     if relative_to_fqp.len() < fqp.len() {\n-        fqp[relative_to_fqp.len()..fqp.len()].iter().map(String::as_str).collect()\n+        box fqp[relative_to_fqp.len()..fqp.len()].iter().copied()\n     // e.g. linking to std::sync from std::sync::atomic\n     } else if fqp.len() < relative_to_fqp.len() {\n         let dissimilar_part_count = relative_to_fqp.len() - fqp.len();\n-        iter::repeat(\"..\").take(dissimilar_part_count).collect()\n+        box iter::repeat(sym::dotdot).take(dissimilar_part_count)\n     // linking to the same module\n     } else {\n-        UrlPartsBuilder::new()\n+        box iter::empty()\n     }\n }\n \n@@ -632,14 +652,14 @@ fn resolved_path<'cx>(\n             if let Ok((_, _, fqp)) = href(did, cx) {\n                 format!(\n                     \"{}::{}\",\n-                    fqp[..fqp.len() - 1].join(\"::\"),\n-                    anchor(did, fqp.last().unwrap(), cx)\n+                    join_with_double_colon(&fqp[..fqp.len() - 1]),\n+                    anchor(did, *fqp.last().unwrap(), cx)\n                 )\n             } else {\n                 last.name.to_string()\n             }\n         } else {\n-            anchor(did, last.name.as_str(), cx).to_string()\n+            anchor(did, last.name, cx).to_string()\n         };\n         write!(w, \"{}{}\", path, last.args.print(cx))?;\n     }\n@@ -668,30 +688,31 @@ fn primitive_link(\n                 needs_termination = true;\n             }\n             Some(&def_id) => {\n-                let cname_sym;\n                 let loc = match m.extern_locations[&def_id.krate] {\n                     ExternalLocation::Remote(ref s) => {\n-                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n-                        Some(vec![s.trim_end_matches('/'), cname_sym.as_str()])\n+                        let cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        let builder: UrlPartsBuilder =\n+                            [s.as_str().trim_end_matches('/'), cname_sym.as_str()]\n+                                .into_iter()\n+                                .collect();\n+                        Some(builder)\n                     }\n                     ExternalLocation::Local => {\n-                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n-                        Some(if cx.current.first().map(|x| &x[..]) == Some(cname_sym.as_str()) {\n-                            iter::repeat(\"..\").take(cx.current.len() - 1).collect()\n+                        let cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        Some(if cx.current.first() == Some(&cname_sym) {\n+                            iter::repeat(sym::dotdot).take(cx.current.len() - 1).collect()\n                         } else {\n-                            let cname = iter::once(cname_sym.as_str());\n-                            iter::repeat(\"..\").take(cx.current.len()).chain(cname).collect()\n+                            iter::repeat(sym::dotdot)\n+                                .take(cx.current.len())\n+                                .chain(iter::once(cname_sym))\n+                                .collect()\n                         })\n                     }\n                     ExternalLocation::Unknown => None,\n                 };\n-                if let Some(loc) = loc {\n-                    write!(\n-                        f,\n-                        \"<a class=\\\"primitive\\\" href=\\\"{}/primitive.{}.html\\\">\",\n-                        loc.join(\"/\"),\n-                        prim.as_sym()\n-                    )?;\n+                if let Some(mut loc) = loc {\n+                    loc.push_fmt(format_args!(\"primitive.{}.html\", prim.as_sym()));\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}\\\">\", loc.finish())?;\n                     needs_termination = true;\n                 }\n             }\n@@ -730,7 +751,7 @@ fn tybounds<'a, 'tcx: 'a>(\n \n crate fn anchor<'a, 'cx: 'a>(\n     did: DefId,\n-    text: &'a str,\n+    text: Symbol,\n     cx: &'cx Context<'_>,\n ) -> impl fmt::Display + 'a {\n     let parts = href(did, cx);\n@@ -742,8 +763,8 @@ crate fn anchor<'a, 'cx: 'a>(\n                 short_ty,\n                 url,\n                 short_ty,\n-                fqp.join(\"::\"),\n-                text\n+                join_with_double_colon(&fqp),\n+                text.as_str()\n             )\n         } else {\n             write!(f, \"{}\", text)\n@@ -960,7 +981,7 @@ fn fmt_type<'cx>(\n                         url = url,\n                         shortty = ItemType::AssocType,\n                         name = name,\n-                        path = path.join(\"::\")\n+                        path = join_with_double_colon(path),\n                     )?;\n                 }\n                 _ => write!(f, \"{}\", name)?,\n@@ -1270,7 +1291,7 @@ impl clean::Visibility {\n                     debug!(\"path={:?}\", path);\n                     // modified from `resolved_path()` to work with `DefPathData`\n                     let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, last_name.as_str(), cx).to_string();\n+                    let anchor = anchor(vis_did, last_name, cx).to_string();\n \n                     let mut s = \"pub(in \".to_owned();\n                     for seg in &path.data[..path.data.len() - 1] {"}, {"sha": "865e14f694dccbcc752b7adfc19547e93a93b1d3", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use super::print_item::{full_path, item_path, print_item};\n use super::search_index::build_index;\n@@ -29,7 +29,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::formats::FormatRenderer;\n use crate::html::escape::Escape;\n-use crate::html::format::Buffer;\n+use crate::html::format::{join_with_double_colon, Buffer};\n use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n use crate::html::{layout, sources};\n use crate::scrape_examples::AllCallLocations;\n@@ -45,7 +45,7 @@ use crate::try_err;\n crate struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub(crate) current: Vec<String>,\n+    pub(crate) current: Vec<Symbol>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     crate dst: PathBuf,\n@@ -176,7 +176,7 @@ impl<'tcx> Context<'tcx> {\n                 title.push_str(\" in \");\n             }\n             // No need to include the namespace for primitive types and keywords\n-            title.push_str(&self.current.join(\"::\"));\n+            title.push_str(&join_with_double_colon(&self.current));\n         };\n         title.push_str(\" - Rust\");\n         let tyname = it.type_();\n@@ -225,18 +225,18 @@ impl<'tcx> Context<'tcx> {\n             if let Some(&(ref names, ty)) = self.cache().paths.get(&it.def_id.expect_def_id()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n-                    path.push_str(name);\n+                    path.push_str(&name.as_str());\n                     path.push('/');\n                 }\n-                path.push_str(&item_path(ty, names.last().unwrap()));\n+                path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n                 match self.shared.redirections {\n                     Some(ref redirections) => {\n                         let mut current_path = String::new();\n                         for name in &self.current {\n-                            current_path.push_str(name);\n+                            current_path.push_str(&name.as_str());\n                             current_path.push('/');\n                         }\n-                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n+                        current_path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n                         redirections.borrow_mut().insert(current_path, path);\n                     }\n                     None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n@@ -634,8 +634,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             self.render_redirect_pages = item.is_stripped();\n         }\n         let scx = &self.shared;\n-        let item_name = item.name.as_ref().unwrap().to_string();\n-        self.dst.push(&item_name);\n+        let item_name = item.name.unwrap();\n+        self.dst.push(&*item_name.as_str());\n         self.current.push(item_name);\n \n         info!(\"Recursing into {}\", self.dst.display());"}, {"sha": "8ba9a6dccacf051d87ded706a29b33031af8f48c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -69,8 +69,9 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    href, print_abi_with_space, print_constness_with_space, print_default_space,\n-    print_generic_bounds, print_where_clause, Buffer, HrefError, PrintWithSpace,\n+    href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    print_default_space, print_generic_bounds, print_where_clause, Buffer, HrefError,\n+    PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n@@ -2515,7 +2516,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n         let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n \n         if let Some(path) = fqp {\n-            out.push(path.join(\"::\"));\n+            out.push(join_with_double_colon(&path));\n         }\n     };\n "}, {"sha": "eda637acfc5b9e74bcd7037a1f44127ebb9f21f7", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -26,11 +26,13 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    print_abi_with_space, print_constness_with_space, print_where_clause, Buffer, PrintWithSpace,\n+    join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n+    Buffer, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::layout::Page;\n use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};\n+use crate::html::url_parts_builder::UrlPartsBuilder;\n \n use askama::Template;\n \n@@ -40,9 +42,9 @@ const ITEM_TABLE_ROW_OPEN: &str = \"<div class=\\\"item-row\\\">\";\n const ITEM_TABLE_ROW_CLOSE: &str = \"</div>\";\n \n // A component in a `use` path, like `string` in std::string::ToString\n-struct PathComponent<'a> {\n+struct PathComponent {\n     path: String,\n-    name: &'a str,\n+    name: Symbol,\n }\n \n #[derive(Template)]\n@@ -53,7 +55,7 @@ struct ItemVars<'a> {\n     typ: &'a str,\n     name: &'a str,\n     item_type: &'a str,\n-    path_components: Vec<PathComponent<'a>>,\n+    path_components: Vec<PathComponent>,\n     stability_since_raw: &'a str,\n     src_href: Option<&'a str>,\n }\n@@ -121,7 +123,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n             .take(amt)\n             .map(|(i, component)| PathComponent {\n                 path: \"../\".repeat(cur.len() - i - 1),\n-                name: component,\n+                name: *component,\n             })\n             .collect()\n     };\n@@ -262,7 +264,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     indices.dedup_by_key(|i| {\n         (\n             items[*i].def_id,\n-            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n+            if items[*i].name.is_some() { Some(full_path(cx, &items[*i])) } else { None },\n             items[*i].type_(),\n             if items[*i].is_import() { *i } else { 0 },\n         )\n@@ -304,22 +306,18 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n                 w.write_str(ITEM_TABLE_ROW_OPEN);\n                 match *src {\n-                    Some(ref src) => write!(\n+                    Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), src.as_str(), cx),\n-                        myitem.name.as_ref().unwrap(),\n+                        anchor(myitem.def_id.expect_def_id(), src, cx),\n+                        myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(\n-                            myitem.def_id.expect_def_id(),\n-                            myitem.name.as_ref().unwrap().as_str(),\n-                            cx\n-                        ),\n+                        anchor(myitem.def_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></div>\");\n@@ -391,7 +389,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                              {stab_tags}\\\n                      </div>\\\n                      <div class=\\\"item-right docblock-short\\\">{docs}</div>\",\n-                    name = *myitem.name.as_ref().unwrap(),\n+                    name = myitem.name.unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n                     docs = MarkdownSummaryLine(&doc_value, &myitem.links(cx)).into_string(),\n                     class = myitem.type_(),\n@@ -463,7 +461,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n     let asyncness = f.header.asyncness.print_with_space();\n     let unsafety = f.header.unsafety.print_with_space();\n     let abi = print_abi_with_space(f.header.abi).to_string();\n-    let name = it.name.as_ref().unwrap();\n+    let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n     let header_len = \"fn \".len()\n@@ -519,7 +517,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                 it.visibility.print_with_space(it.def_id, cx),\n                 t.unsafety.print_with_space(),\n                 if t.is_auto { \"auto \" } else { \"\" },\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 bounds\n             );\n@@ -660,7 +658,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n-        let name = m.name.as_ref().unwrap();\n+        let name = m.name.unwrap();\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n@@ -857,20 +855,21 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n     }\n \n+    let mut js_src_path: UrlPartsBuilder = std::iter::repeat(\"..\")\n+        .take(cx.current.len())\n+        .chain(std::iter::once(\"implementors\"))\n+        .collect();\n+    if it.def_id.is_local() {\n+        js_src_path.extend(cx.current.iter().copied());\n+    } else {\n+        let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n+        js_src_path.extend(path[..path.len() - 1].iter().copied());\n+    }\n+    js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), it.name.unwrap()));\n     write!(\n         w,\n-        \"<script type=\\\"text/javascript\\\" \\\n-                 src=\\\"{root_path}/implementors/{path}/{ty}.{name}.js\\\" async>\\\n-         </script>\",\n-        root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n-        path = if it.def_id.is_local() {\n-            cx.current.join(\"/\")\n-        } else {\n-            let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n-            path[..path.len() - 1].join(\"/\")\n-        },\n-        ty = it.type_(),\n-        name = *it.name.as_ref().unwrap()\n+        \"<script type=\\\"text/javascript\\\" src=\\\"{src}\\\" async></script>\",\n+        src = js_src_path.finish(),\n     );\n }\n \n@@ -881,7 +880,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n             write!(\n                 w,\n                 \"trait {}{}{} = {};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 print_where_clause(&t.generics, cx, 0, true),\n                 bounds(&t.bounds, true, cx)\n@@ -905,7 +904,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = impl {bounds};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, true),\n                 bounds = bounds(&t.bounds, false, cx),\n@@ -944,7 +943,7 @@ fn item_typedef(\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, true),\n                 type_ = t.type_.print(cx),\n@@ -997,7 +996,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                    Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n         );\n         for (field, ty) in fields {\n-            let name = field.name.as_ref().expect(\"union field name\");\n+            let name = field.name.expect(\"union field name\");\n             let id = format!(\"{}.{}\", ItemType::StructField, name);\n             write!(\n                 w,\n@@ -1042,7 +1041,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 w,\n                 \"{}enum {}{}{}\",\n                 it.visibility.print_with_space(it.def_id, cx),\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 e.generics.print(cx),\n                 print_where_clause(&e.generics, cx, 0, true),\n             );\n@@ -1057,7 +1056,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 }\n                 for v in &e.variants {\n                     w.write_str(\"    \");\n-                    let name = v.name.as_ref().unwrap();\n+                    let name = v.name.unwrap();\n                     match *v.kind {\n                         clean::VariantItem(ref var) => match var {\n                             clean::Variant::CLike => write!(w, \"{}\", name),\n@@ -1106,15 +1105,14 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         );\n         document_non_exhaustive(w, it);\n         for variant in &e.variants {\n-            let id =\n-                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n+            let id = cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.unwrap()));\n             write!(\n                 w,\n                 \"<h3 id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                     <code>{name}\",\n                 id = id,\n-                name = variant.name.as_ref().unwrap()\n+                name = variant.name.unwrap()\n             );\n             if let clean::VariantItem(clean::Variant::Tuple(ref s)) = *variant.kind {\n                 w.write_str(\"(\");\n@@ -1140,11 +1138,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             };\n \n             if let Some((heading, fields)) = heading_and_fields {\n-                let variant_id = cx.derive_id(format!(\n-                    \"{}.{}.fields\",\n-                    ItemType::Variant,\n-                    variant.name.as_ref().unwrap()\n-                ));\n+                let variant_id =\n+                    cx.derive_id(format!(\"{}.{}.fields\", ItemType::Variant, variant.name.unwrap()));\n                 write!(w, \"<div class=\\\"sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n                 write!(w, \"<h4>{heading}</h4>\", heading = heading);\n                 document_non_exhaustive(w, variant);\n@@ -1154,8 +1149,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                         clean::StructFieldItem(ref ty) => {\n                             let id = cx.derive_id(format!(\n                                 \"variant.{}.field.{}\",\n-                                variant.name.as_ref().unwrap(),\n-                                field.name.as_ref().unwrap()\n+                                variant.name.unwrap(),\n+                                field.name.unwrap()\n                             ));\n                             write!(\n                                 w,\n@@ -1165,7 +1160,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                     <code>{f}:&nbsp;{t}</code>\\\n                                 </span>\",\n                                 id = id,\n-                                f = field.name.as_ref().unwrap(),\n+                                f = field.name.unwrap(),\n                                 t = ty.print(cx)\n                             );\n                             document(w, cx, field, Some(variant), HeadingOffset::H5);\n@@ -1204,7 +1199,7 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n \n fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n     wrap_into_docblock(w, |w| {\n-        let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+        let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n             MacroKind::Bang => {\n                 wrap_item(w, \"macro\", |w| {\n@@ -1248,7 +1243,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n                 w,\n                 \"{vis}const {name}: {typ}\",\n                 vis = it.visibility.print_with_space(it.def_id, cx),\n-                name = it.name.as_ref().unwrap(),\n+                name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n \n@@ -1341,7 +1336,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n                 \"{vis}static {mutability}{name}: {typ}\",\n                 vis = it.visibility.print_with_space(it.def_id, cx),\n                 mutability = s.mutability.print_with_space(),\n-                name = it.name.as_ref().unwrap(),\n+                name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n             );\n         });\n@@ -1358,7 +1353,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n                 w,\n                 \"    {}type {};\\n}}\",\n                 it.visibility.print_with_space(it.def_id, cx),\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n             );\n         });\n     });\n@@ -1410,7 +1405,7 @@ crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n }\n \n pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n-    let mut s = cx.current.join(\"::\");\n+    let mut s = join_with_double_colon(&cx.current);\n     s.push_str(\"::\");\n     s.push_str(item.name.unwrap().as_str());\n     s\n@@ -1526,12 +1521,7 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(\n-        w,\n-        \"{}union {}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n-        it.name.as_ref().unwrap()\n-    );\n+    write!(w, \"{}union {}\", it.visibility.print_with_space(it.def_id, cx), it.name.unwrap());\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx));\n         write!(w, \"{}\", print_where_clause(g, cx, 0, true));\n@@ -1551,7 +1541,7 @@ fn render_union(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n                 field.visibility.print_with_space(field.def_id, cx),\n-                field.name.as_ref().unwrap(),\n+                field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n             );\n@@ -1582,7 +1572,7 @@ fn render_struct(\n         \"{}{}{}\",\n         it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n-        it.name.as_ref().unwrap()\n+        it.name.unwrap()\n     );\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx))\n@@ -1607,7 +1597,7 @@ fn render_struct(\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n                         field.visibility.print_with_space(field.def_id, cx),\n-                        field.name.as_ref().unwrap(),\n+                        field.name.unwrap(),\n                         ty.print(cx),\n                     );\n                 }"}, {"sha": "87138b9571c2a0e36515203263dfe060e730a508", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -10,6 +10,7 @@ use crate::clean;\n use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n+use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n@@ -28,7 +29,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n-                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n@@ -102,7 +103,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     struct CrateData<'a> {\n         doc: String,\n         items: Vec<&'a IndexItem>,\n-        paths: Vec<(ItemType, String)>,\n+        paths: Vec<(ItemType, Symbol)>,\n         // The String is alias name and the vec is the list of the elements with this alias.\n         //\n         // To be noted: the `usize` elements are indexes to `items`.\n@@ -154,7 +155,10 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 \"f\",\n                 &self.items.iter().map(|item| &item.search_type).collect::<Vec<_>>(),\n             )?;\n-            crate_data.serialize_field(\"p\", &self.paths)?;\n+            crate_data.serialize_field(\n+                \"p\",\n+                &self.paths.iter().map(|(it, s)| (it, s.to_string())).collect::<Vec<_>>(),\n+            )?;\n             if has_aliases {\n                 crate_data.serialize_field(\"a\", &self.aliases)?;\n             }"}, {"sha": "3fa16c6c3b88067287439c3eb2267e59827655e9", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -562,7 +562,7 @@ pub(super) fn write_shared(\n \n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n-            mydst.push(part);\n+            mydst.push(part.to_string());\n         }\n         cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));"}, {"sha": "437d3995e29fca356eb31f085d9f10437496507a", "filename": "src/librustdoc/html/tests.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftests.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -1,44 +1,50 @@\n use crate::html::format::href_relative_parts;\n+use rustc_span::{sym, Symbol};\n \n-fn assert_relative_path(expected: &str, relative_to_fqp: &[&str], fqp: &[&str]) {\n-    let relative_to_fqp: Vec<String> = relative_to_fqp.iter().copied().map(String::from).collect();\n-    let fqp: Vec<String> = fqp.iter().copied().map(String::from).collect();\n-    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp).finish());\n+fn assert_relative_path(expected: &[Symbol], relative_to_fqp: &[Symbol], fqp: &[Symbol]) {\n+    // No `create_default_session_globals_then` call is needed here because all\n+    // the symbols used are static, and no `Symbol::intern` calls occur.\n+    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp).collect::<Vec<_>>());\n }\n \n #[test]\n fn href_relative_parts_basic() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\", \"iter\"];\n-    assert_relative_path(\"../iter\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std, sym::iter];\n+    assert_relative_path(&[sym::dotdot, sym::iter], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_parent_module() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\"];\n-    assert_relative_path(\"..\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std];\n+    assert_relative_path(&[sym::dotdot], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_different_crate() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"core\", \"iter\"];\n-    assert_relative_path(\"../../core/iter\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::core, sym::iter];\n+    assert_relative_path(&[sym::dotdot, sym::dotdot, sym::core, sym::iter], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_same_module() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(\"\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std, sym::vec];\n+    assert_relative_path(&[], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_child_module() {\n-    let relative_to_fqp = &[\"std\"];\n-    let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(\"vec\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std];\n+    let fqp = &[sym::std, sym::vec];\n+    assert_relative_path(&[sym::vec], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_root() {\n     let relative_to_fqp = &[];\n-    let fqp = &[\"std\"];\n-    assert_relative_path(\"std\", relative_to_fqp, fqp);\n+    let fqp = &[sym::std];\n+    assert_relative_path(&[sym::std], relative_to_fqp, fqp);\n }"}, {"sha": "2bb78aa7dc9c074310397db957e2ad7b4c2bf7c3", "filename": "src/librustdoc/html/url_parts_builder.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -1,3 +1,7 @@\n+use std::fmt::{self, Write};\n+\n+use rustc_span::Symbol;\n+\n /// A builder that allows efficiently and easily constructing the part of a URL\n /// after the domain: `nightly/core/str/struct.Bytes.html`.\n ///\n@@ -10,6 +14,7 @@ crate struct UrlPartsBuilder {\n \n impl UrlPartsBuilder {\n     /// Create an empty buffer.\n+    #[allow(dead_code)]\n     crate fn new() -> Self {\n         Self { buf: String::new() }\n     }\n@@ -62,6 +67,26 @@ impl UrlPartsBuilder {\n         self.buf.push_str(part);\n     }\n \n+    /// Push a component onto the buffer, using [`format!`]'s formatting syntax.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage (equivalent to the example for [`UrlPartsBuilder::push`]):\n+    ///\n+    /// ```ignore (private-type)\n+    /// let mut builder = UrlPartsBuilder::new();\n+    /// builder.push(\"core\");\n+    /// builder.push(\"str\");\n+    /// builder.push_fmt(format_args!(\"{}.{}.html\", \"struct\", \"Bytes\"));\n+    /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n+    /// ```\n+    crate fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n+        if !self.buf.is_empty() {\n+            self.buf.push('/');\n+        }\n+        self.buf.write_fmt(args).unwrap()\n+    }\n+\n     /// Push a component onto the front of the buffer.\n     ///\n     /// # Examples\n@@ -93,10 +118,25 @@ impl UrlPartsBuilder {\n \n /// This is just a guess at the average length of a URL part,\n /// used for [`String::with_capacity`] calls in the [`FromIterator`]\n-/// and [`Extend`] impls.\n+/// and [`Extend`] impls, and for [estimating item path lengths].\n ///\n-/// This is intentionally on the lower end to avoid overallocating.\n-const AVG_PART_LENGTH: usize = 5;\n+/// The value `8` was chosen for two main reasons:\n+///\n+/// * It seems like a good guess for the average part length.\n+/// * jemalloc's size classes are all multiples of eight,\n+///   which means that the amount of memory it allocates will often match\n+///   the amount requested, avoiding wasted bytes.\n+///\n+/// [estimating item path lengths]: estimate_item_path_byte_length\n+const AVG_PART_LENGTH: usize = 8;\n+\n+/// Estimate the number of bytes in an item's path, based on how many segments it has.\n+///\n+/// **Note:** This is only to be used with, e.g., [`String::with_capacity()`];\n+/// the return value is just a rough estimate.\n+crate const fn estimate_item_path_byte_length(segment_count: usize) -> usize {\n+    AVG_PART_LENGTH * segment_count\n+}\n \n impl<'a> FromIterator<&'a str> for UrlPartsBuilder {\n     fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {\n@@ -115,5 +155,26 @@ impl<'a> Extend<&'a str> for UrlPartsBuilder {\n     }\n }\n \n+impl FromIterator<Symbol> for UrlPartsBuilder {\n+    fn from_iter<T: IntoIterator<Item = Symbol>>(iter: T) -> Self {\n+        // This code has to be duplicated from the `&str` impl because of\n+        // `Symbol::as_str`'s lifetimes.\n+        let iter = iter.into_iter();\n+        let mut builder = Self::with_capacity_bytes(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| builder.push(part.as_str()));\n+        builder\n+    }\n+}\n+\n+impl Extend<Symbol> for UrlPartsBuilder {\n+    fn extend<T: IntoIterator<Item = Symbol>>(&mut self, iter: T) {\n+        // This code has to be duplicated from the `&str` impl because of\n+        // `Symbol::as_str`'s lifetimes.\n+        let iter = iter.into_iter();\n+        self.buf.reserve(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| self.push(part.as_str()));\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "636e1ab55279f995644b8f49e619503eb8218c3e", "filename": "src/librustdoc/html/url_parts_builder/tests.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder%2Ftests.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -40,6 +40,16 @@ fn push_front_non_empty() {\n     t(builder, \"nightly/core/str/struct.Bytes.html\");\n }\n \n+#[test]\n+fn push_fmt() {\n+    let mut builder = UrlPartsBuilder::new();\n+    builder.push_fmt(format_args!(\"{}\", \"core\"));\n+    builder.push(\"str\");\n+    builder.push_front(\"nightly\");\n+    builder.push_fmt(format_args!(\"{}.{}.html\", \"struct\", \"Bytes\"));\n+    t(builder, \"nightly/core/str/struct.Bytes.html\");\n+}\n+\n #[test]\n fn collect() {\n     t([\"core\", \"str\"].into_iter().collect(), \"core/str\");"}, {"sha": "81fbfd9fdbd166da4619f6c7277671343076e531", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                                 })\n                                 .0\n                                 .last()\n-                                .map(Clone::clone),\n+                                .map(|s| s.to_string()),\n                             visibility: types::Visibility::Public,\n                             inner: types::ItemEnum::Trait(trait_item.clone().into_tcx(self.tcx)),\n                             span: None,\n@@ -230,7 +230,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                         from_item_id(k.into()),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n-                            path,\n+                            path: path.iter().map(|s| s.to_string()).collect(),\n                             kind: kind.into_tcx(self.tcx),\n                         },\n                     )"}, {"sha": "90cb5d586c2114a18dd2cccfd33e5e35f6d15a9d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ec3e09a996f2cb35be7710fd1003c3c38f1667/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b0ec3e09a996f2cb35be7710fd1003c3c38f1667", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n@@ -43,12 +42,9 @@ impl Module<'_> {\n }\n \n // FIXME: Should this be replaced with tcx.def_path_str?\n-fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<String> {\n-    let crate_name = tcx.crate_name(did.krate).to_string();\n-    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // Filter out extern blocks\n-        (elem.data != DefPathData::ForeignMod).then(|| elem.data.to_string())\n-    });\n+fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n+    let crate_name = tcx.crate_name(did.krate);\n+    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| elem.data.get_opt_name());\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n@@ -71,7 +67,7 @@ crate struct RustdocVisitor<'a, 'tcx> {\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n-    exact_paths: FxHashMap<DefId, Vec<String>>,\n+    exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {"}]}