{"sha": "f6f9d5e73d5524b6281c10a5c89b7db35c330634", "node_id": "C_kwDOAAsO6NoAKGY2ZjlkNWU3M2Q1NTI0YjYyODFjMTBhNWM4OWI3ZGIzNWMzMzA2MzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T21:03:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-04T21:03:48Z"}, "message": "Auto merge of #100151 - matthiaskrgr:rollup-irqwvj2, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98796 (Do not exclusively suggest `;` when `,` is also a choice)\n - #99772 (Re-enable submodule archive downloads.)\n - #100058 (Suggest a positional formatting argument instead of a captured argument)\n - #100093 (Enable unused_parens for match arms)\n - #100095 (More EarlyBinder cleanups)\n - #100138 (Remove more Clean trait implementations)\n - #100148 (RustWrapper: update for TypedPointerType in LLVM)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a3af49ccf1294aaed6508bbb1b9d57b4c0aaa722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3af49ccf1294aaed6508bbb1b9d57b4c0aaa722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f9d5e73d5524b6281c10a5c89b7db35c330634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f9d5e73d5524b6281c10a5c89b7db35c330634", "html_url": "https://github.com/rust-lang/rust/commit/f6f9d5e73d5524b6281c10a5c89b7db35c330634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f9d5e73d5524b6281c10a5c89b7db35c330634/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3830ecaa8db798d2727cbdfa4ddf314ff938f268", "url": "https://api.github.com/repos/rust-lang/rust/commits/3830ecaa8db798d2727cbdfa4ddf314ff938f268", "html_url": "https://github.com/rust-lang/rust/commit/3830ecaa8db798d2727cbdfa4ddf314ff938f268"}, {"sha": "c2d7321a2dc898bc23c37a9322c5318c767c35db", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d7321a2dc898bc23c37a9322c5318c767c35db", "html_url": "https://github.com/rust-lang/rust/commit/c2d7321a2dc898bc23c37a9322c5318c767c35db"}], "stats": {"total": 502, "additions": 381, "deletions": 121}, "files": [{"sha": "5eb7bf6347f7bb5a6b13e85294fd1b29f5d20e36", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -377,7 +377,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_string(&mut self, st: &str, style: ast::StrStyle) {\n         let st = match style {\n-            ast::StrStyle::Cooked => (format!(\"\\\"{}\\\"\", st.escape_debug())),\n+            ast::StrStyle::Cooked => format!(\"\\\"{}\\\"\", st.escape_debug()),\n             ast::StrStyle::Raw(n) => {\n                 format!(\"r{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = st)\n             }"}, {"sha": "8bc8964bbd7cc1d6955256e1e25dce438d32bcc3", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -16,9 +16,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{\n-    self, subst::Subst, suggest_constraining_type_params, EarlyBinder, PredicateKind, Ty,\n-};\n+use rustc_middle::ty::{self, subst::Subst, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n@@ -461,35 +459,37 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         // Find out if the predicates show that the type is a Fn or FnMut\n-        let find_fn_kind_from_did = |predicates: &[(ty::Predicate<'tcx>, Span)], substs| {\n-            predicates.iter().find_map(|(pred, _)| {\n-                let pred = if let Some(substs) = substs {\n-                    EarlyBinder(*pred).subst(tcx, substs).kind().skip_binder()\n-                } else {\n-                    pred.kind().skip_binder()\n-                };\n-                if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n+        let find_fn_kind_from_did =\n+            |predicates: ty::EarlyBinder<&[(ty::Predicate<'tcx>, Span)]>, substs| {\n+                predicates.0.iter().find_map(|(pred, _)| {\n+                    let pred = if let Some(substs) = substs {\n+                        predicates.rebind(*pred).subst(tcx, substs).kind().skip_binder()\n+                    } else {\n+                        pred.kind().skip_binder()\n+                    };\n+                    if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n                     if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n                         return Some(hir::Mutability::Not);\n                     } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n                         return Some(hir::Mutability::Mut);\n                     }\n                 }\n-                None\n-            })\n-        };\n+                    None\n+                })\n+            };\n \n         // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n         // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n         // These types seem reasonably opaque enough that they could be substituted with their\n         // borrowed variants in a function body when we see a move error.\n         let borrow_level = match ty.kind() {\n             ty::Param(_) => find_fn_kind_from_did(\n-                tcx.explicit_predicates_of(self.mir_def_id().to_def_id()).predicates,\n+                tcx.bound_explicit_predicates_of(self.mir_def_id().to_def_id())\n+                    .map_bound(|p| p.predicates),\n                 None,\n             ),\n             ty::Opaque(did, substs) => {\n-                find_fn_kind_from_did(tcx.explicit_item_bounds(*did), Some(*substs))\n+                find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*did), Some(*substs))\n             }\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => Some(hir::Mutability::Not),"}, {"sha": "a87e8bd5ba16fc276183bc1366a121107141dd94", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -839,7 +839,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(&hir::Closure { fn_decl_span, .. }),\n                 ..\n-            }) => (tcx.sess.source_map().end_point(fn_decl_span)),\n+            }) => tcx.sess.source_map().end_point(fn_decl_span),\n             _ => self.body.span,\n         };\n "}, {"sha": "9eb96ec76800c8634355aae052d55bc7eca4450f", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -280,6 +280,11 @@ struct Context<'a, 'b> {\n     unused_names_lint: PositionalNamedArgsLint,\n }\n \n+pub struct FormatArg {\n+    expr: P<ast::Expr>,\n+    named: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -293,8 +298,8 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, (usize, Span)>)> {\n-    let mut args = Vec::<P<ast::Expr>>::new();\n+) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, (usize, Span)>)> {\n+    let mut args = Vec::<FormatArg>::new();\n     let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -362,7 +367,7 @@ fn parse_args<'a>(\n                 let e = p.parse_expr()?;\n                 if let Some((prev, _)) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[*prev].span, \"previously here\")\n+                        .span_label(args[*prev].expr.span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n                         .emit();\n                     continue;\n@@ -374,7 +379,7 @@ fn parse_args<'a>(\n                 // args. And remember the names.\n                 let slot = args.len();\n                 names.insert(ident.name, (slot, ident.span));\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: true });\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -385,11 +390,11 @@ fn parse_args<'a>(\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n                     for pos in names.values() {\n-                        err.span_label(args[pos.0].span, \"named argument\");\n+                        err.span_label(args[pos.0].expr.span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n-                args.push(e);\n+                args.push(FormatArg { expr: e, named: false });\n             }\n         }\n     }\n@@ -1214,7 +1219,7 @@ pub fn expand_preparsed_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     sp: Span,\n     efmt: P<ast::Expr>,\n-    args: Vec<P<ast::Expr>>,\n+    args: Vec<FormatArg>,\n     names: FxHashMap<Symbol, (usize, Span)>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n@@ -1304,6 +1309,25 @@ pub fn expand_preparsed_format_args(\n                 e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n             }\n         }\n+        if err.should_be_replaced_with_positional_argument {\n+            let captured_arg_span =\n+                fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n+            let positional_args = args.iter().filter(|arg| !arg.named).collect::<Vec<_>>();\n+            if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n+                let span = match positional_args.last() {\n+                    Some(arg) => arg.expr.span,\n+                    None => fmt_sp,\n+                };\n+                e.multipart_suggestion_verbose(\n+                    \"consider using a positional formatting argument instead\",\n+                    vec![\n+                        (captured_arg_span, positional_args.len().to_string()),\n+                        (span.shrink_to_hi(), format!(\", {}\", arg)),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n@@ -1318,7 +1342,7 @@ pub fn expand_preparsed_format_args(\n \n     let mut cx = Context {\n         ecx,\n-        args,\n+        args: args.into_iter().map(|arg| arg.expr).collect(),\n         num_captured_args: 0,\n         arg_types,\n         arg_unique_types,"}, {"sha": "936044fbe24b260455760eeb9ea52f26eac5dbae", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::pretty::display_allocation;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, subst::Subst, EarlyBinder, TyCtxt};\n+use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n use std::borrow::Cow;\n@@ -45,7 +45,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         \"Unexpected DefKind: {:?}\",\n         ecx.tcx.def_kind(cid.instance.def_id())\n     );\n-    let layout = ecx.layout_of(EarlyBinder(body.return_ty()).subst(tcx, cid.instance.substs))?;\n+    let layout = ecx.layout_of(body.bound_return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n "}, {"sha": "b6cf182916cb930c81f74c36eff47c1983d45aec", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -396,6 +396,7 @@ enum UnusedDelimsCtx {\n     LetScrutineeExpr,\n     ArrayLenExpr,\n     AnonConst,\n+    MatchArmExpr,\n }\n \n impl From<UnusedDelimsCtx> for &'static str {\n@@ -414,6 +415,7 @@ impl From<UnusedDelimsCtx> for &'static str {\n             UnusedDelimsCtx::BlockRetValue => \"block return value\",\n             UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n             UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n+            UnusedDelimsCtx::MatchArmExpr => \"match arm expression\",\n         }\n     }\n }\n@@ -805,6 +807,18 @@ impl EarlyLintPass for UnusedParens {\n                 }\n                 return;\n             }\n+            ExprKind::Match(ref _expr, ref arm) => {\n+                for a in arm {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &a.body,\n+                        UnusedDelimsCtx::MatchArmExpr,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n+            }\n             _ => {}\n         }\n "}, {"sha": "5f5b5de790e430e4e2823c491c0536325638c793", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -1311,10 +1311,15 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n     return LLVMBFloatTypeKind;\n   case Type::X86_AMXTyID:\n     return LLVMX86_AMXTypeKind;\n-#if LLVM_VERSION_GE(15, 0)\n+#if LLVM_VERSION_GE(15, 0) && LLVM_VERSION_LT(16, 0)\n   case Type::DXILPointerTyID:\n     report_fatal_error(\"Rust does not support DirectX typed pointers.\");\n     break;\n+#endif\n+#if LLVM_VERSION_GE(16, 0)\n+  case Type::TypedPointerTyID:\n+    report_fatal_error(\"Rust does not support typed pointers.\");\n+    break;\n #endif\n   }\n   report_fatal_error(\"Unhandled TypeID.\");"}, {"sha": "7ab71f9009d04a3320c5ea642c00512ac890a01a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -431,6 +431,12 @@ impl<'tcx> Body<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n+    /// Returns the return type; it always return first element from `local_decls` array.\n+    #[inline]\n+    pub fn bound_return_ty(&self) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.local_decls[RETURN_PLACE].ty)\n+    }\n+\n     /// Gets the location of the terminator for the given block.\n     #[inline]\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {"}, {"sha": "2e596b275276e3bb86478e64552b3adf03dc66d6", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -563,7 +563,7 @@ impl<'tcx> AdtDef<'tcx> {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n-        tcx.adt_sized_constraint(self.did()).0\n+    pub fn sized_constraint(self, tcx: TyCtxt<'tcx>) -> ty::EarlyBinder<&'tcx [Ty<'tcx>]> {\n+        ty::EarlyBinder(tcx.adt_sized_constraint(self.did()).0)\n     }\n }"}, {"sha": "52c3a38861e6531984603dc86497ea220e98bab1", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -2191,7 +2191,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Tuple(tys) => tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n \n-            ty::Adt(def, _substs) => def.sized_constraint(tcx).is_empty(),\n+            ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n "}, {"sha": "591bb7831b5b6375ab98b17f28ecfb389dc26e5a", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -680,6 +680,24 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn bound_const_param_default(self, def_id: DefId) -> ty::EarlyBinder<ty::Const<'tcx>> {\n         ty::EarlyBinder(self.const_param_default(def_id))\n     }\n+\n+    pub fn bound_predicates_of(\n+        self,\n+        def_id: DefId,\n+    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n+        ty::EarlyBinder(self.predicates_of(def_id))\n+    }\n+\n+    pub fn bound_explicit_predicates_of(\n+        self,\n+        def_id: DefId,\n+    ) -> ty::EarlyBinder<ty::generics::GenericPredicates<'tcx>> {\n+        ty::EarlyBinder(self.explicit_predicates_of(def_id))\n+    }\n+\n+    pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n+        ty::EarlyBinder(self.impl_subject(def_id))\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}, {"sha": "8d6f8efb6003f9fd7745b02e331859f14cc3ab77", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -617,7 +617,7 @@ impl SplitVarLenSlice {\n             // The only admissible fixed-length slice is one of the array size. Whether `max_slice`\n             // is fixed-length or variable-length, it will be the only relevant slice to output\n             // here.\n-            Some(_) => (0..0), // empty range\n+            Some(_) => 0..0, // empty range\n             // We cover all arities in the range `(self.arity..infinity)`. We split that range into\n             // two: lengths smaller than `max_slice.arity()` are treated independently as\n             // fixed-lengths slices, and lengths above are captured by `max_slice`."}, {"sha": "fbc0a767f0766a494bba2746c91dfb84c3f079a9", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -18,9 +18,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{\n-    self, ConstKind, EarlyBinder, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{self, HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi as CallAbi;\n@@ -387,7 +385,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         );\n \n         let ret_layout = ecx\n-            .layout_of(EarlyBinder(body.return_ty()).subst(tcx, substs))\n+            .layout_of(body.bound_return_ty().subst(tcx, substs))\n             .ok()\n             // Don't bother allocating memory for large values.\n             // I don't know how return types can seem to be unsized but this happens in the"}, {"sha": "c2ea55af48a1e781e0ea83a6dab425a5d68d764d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -23,8 +23,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{\n-    self, ConstInt, ConstKind, EarlyBinder, Instance, ParamEnv, ScalarInt, Ty, TyCtxt,\n-    TypeVisitable,\n+    self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::lint;\n use rustc_span::Span;\n@@ -196,7 +195,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         );\n \n         let ret_layout = ecx\n-            .layout_of(EarlyBinder(body.return_ty()).subst(tcx, substs))\n+            .layout_of(body.bound_return_ty().subst(tcx, substs))\n             .ok()\n             // Don't bother allocating memory for large values.\n             // I don't know how return types can seem to be unsized but this happens in the"}, {"sha": "a2155ac1d1ad43ae8c64535149d813941afe1a7b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -560,7 +560,8 @@ impl<'a> Parser<'a> {\n                     || (sm.is_multiline(\n                         self.prev_token.span.shrink_to_hi().until(self.token.span.shrink_to_lo())\n                     ) && t == &token::Pound)\n-            }) {\n+            }) && !expected.contains(&TokenType::Token(token::Comma))\n+            {\n                 // Missing semicolon typo. This is triggered if the next token could either start a\n                 // new statement or is a block close. For example:\n                 //"}, {"sha": "4890fade50faf8ef6ec57c673d82fd3ab3f80762", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -175,6 +175,7 @@ pub struct ParseError {\n     pub label: string::String,\n     pub span: InnerSpan,\n     pub secondary_label: Option<(string::String, InnerSpan)>,\n+    pub should_be_replaced_with_positional_argument: bool,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -236,6 +237,8 @@ impl<'a> Iterator for Parser<'a> {\n                                     lbrace_inner_offset.to(InnerOffset(rbrace_inner_offset.0 + 1)),\n                                 );\n                             }\n+                        } else {\n+                            self.suggest_positional_arg_instead_of_captured_arg(arg);\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -313,6 +316,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -336,6 +340,7 @@ impl<'a> Parser<'a> {\n             label: label.into(),\n             span,\n             secondary_label: None,\n+            should_be_replaced_with_positional_argument: false,\n         });\n     }\n \n@@ -407,6 +412,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n                 None\n             }\n@@ -434,6 +440,7 @@ impl<'a> Parser<'a> {\n                     label,\n                     span: pos.to(pos),\n                     secondary_label,\n+                    should_be_replaced_with_positional_argument: false,\n                 });\n             } else {\n                 self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n@@ -750,6 +757,34 @@ impl<'a> Parser<'a> {\n         }\n         if found { Some(cur) } else { None }\n     }\n+\n+    fn suggest_positional_arg_instead_of_captured_arg(&mut self, arg: Argument<'a>) {\n+        if let Some(end) = self.consume_pos('.') {\n+            let byte_pos = self.to_span_index(end);\n+            let start = InnerOffset(byte_pos.0 + 1);\n+            let field = self.argument(start);\n+            // We can only parse `foo.bar` field access, any deeper nesting,\n+            // or another type of expression, like method calls, are not supported\n+            if !self.consume('}') {\n+                return;\n+            }\n+            if let ArgumentNamed(_) = arg.position {\n+                if let ArgumentNamed(_) = field.position {\n+                    self.errors.insert(\n+                        0,\n+                        ParseError {\n+                            description: \"field access isn't supported\".to_string(),\n+                            note: None,\n+                            label: \"not supported\".to_string(),\n+                            span: InnerSpan::new(arg.position_span.start, field.position_span.end),\n+                            secondary_label: None,\n+                            should_be_replaced_with_positional_argument: true,\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Finds the indices of all characters that have been processed and differ between the actual"}, {"sha": "adf47ece69d99aa37d981c504bdf4058832712ce", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::visit::{MaxUniverse, TypeVisitable};\n-use rustc_middle::ty::{self, EarlyBinder, Term, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Term, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n use std::collections::BTreeMap;\n@@ -2005,16 +2005,16 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n     let substs =\n         translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n-    let ty = tcx.type_of(assoc_ty.item.def_id);\n+    let ty = tcx.bound_type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n-    let term: ty::Term<'tcx> = if is_const {\n+    let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n         let identity_substs =\n             crate::traits::InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n         let kind = ty::ConstKind::Unevaluated(ty::Unevaluated::new(did, identity_substs));\n-        tcx.mk_const(ty::ConstS { ty, kind }).into()\n+        ty.map_bound(|ty| tcx.mk_const(ty::ConstS { ty, kind }).into())\n     } else {\n-        ty.into()\n+        ty.map_bound(|ty| ty.into())\n     };\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         let err = tcx.ty_error_with_message(\n@@ -2024,7 +2024,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         Progress { term: err.into(), obligations: nested }\n     } else {\n         assoc_ty_own_obligations(selcx, obligation, &mut nested);\n-        Progress { term: EarlyBinder(term).subst(tcx, substs), obligations: nested }\n+        Progress { term: term.subst(tcx, substs), obligations: nested }\n     }\n }\n "}, {"sha": "c01ac197991069e8b6c9a5d2309d0d99e6186ceb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -1886,7 +1886,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(obligation.predicate.rebind({\n-                    sized_crit.iter().map(|ty| EarlyBinder(*ty).subst(self.tcx(), substs)).collect()\n+                    sized_crit\n+                        .0\n+                        .iter()\n+                        .map(|ty| sized_crit.rebind(*ty).subst(self.tcx(), substs))\n+                        .collect()\n                 }))\n             }\n \n@@ -2357,11 +2361,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // obligation will normalize to `<$0 as Iterator>::Item = $1` and\n         // `$1: Copy`, so we must ensure the obligations are emitted in\n         // that order.\n-        let predicates = tcx.predicates_of(def_id);\n+        let predicates = tcx.bound_predicates_of(def_id);\n         debug!(?predicates);\n-        assert_eq!(predicates.parent, None);\n-        let mut obligations = Vec::with_capacity(predicates.predicates.len());\n-        for (predicate, span) in predicates.predicates {\n+        assert_eq!(predicates.0.parent, None);\n+        let mut obligations = Vec::with_capacity(predicates.0.predicates.len());\n+        for (predicate, span) in predicates.0.predicates {\n             let span = *span;\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n@@ -2375,7 +2379,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 param_env,\n                 cause.clone(),\n                 recursion_depth,\n-                EarlyBinder(*predicate).subst(tcx, substs),\n+                predicates.rebind(*predicate).subst(tcx, substs),\n                 &mut obligations,\n             );\n             obligations.push(Obligation { cause, recursion_depth, param_env, predicate });"}, {"sha": "d25006016629c907bf0d0f60d489900610ac3dd8", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -6,7 +6,7 @@ use smallvec::SmallVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, EarlyBinder, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitable};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n pub use rustc_infer::traits::{self, util::*};\n@@ -200,8 +200,8 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n-    let subject = selcx.tcx().impl_subject(impl_def_id);\n-    let subject = EarlyBinder(subject).subst(selcx.tcx(), impl_substs);\n+    let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n+    let subject = subject.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: subject, obligations: normalization_obligations1 } =\n         super::normalize(selcx, param_env, ObligationCause::dummy(), subject);\n "}, {"sha": "ff5ca0cbcb7b134bf8a7e3aa73d82d9223089ca5", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -51,11 +51,11 @@ impl<'tcx> RustIrDatabase<'tcx> {\n     where\n         ty::Predicate<'tcx>: LowerInto<'tcx, std::option::Option<T>>,\n     {\n-        self.interner\n-            .tcx\n-            .explicit_item_bounds(def_id)\n+        let bounds = self.interner.tcx.bound_explicit_item_bounds(def_id);\n+        bounds\n+            .0\n             .iter()\n-            .map(|(bound, _)| EarlyBinder(*bound).subst(self.interner.tcx, &bound_vars))\n+            .map(|(bound, _)| bounds.rebind(*bound).subst(self.interner.tcx, &bound_vars))\n             .filter_map(|bound| LowerInto::<Option<_>>::lower_into(bound, self.interner))\n             .collect()\n     }\n@@ -268,21 +268,20 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n-        let sig = self.interner.tcx.fn_sig(def_id);\n+        let sig = self.interner.tcx.bound_fn_sig(def_id);\n         let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n             self.interner,\n             self.interner.tcx,\n-            EarlyBinder(sig.inputs_and_output()).subst(self.interner.tcx, bound_vars),\n+            sig.map_bound(|s| s.inputs_and_output()).subst(self.interner.tcx, bound_vars),\n         );\n \n         let argument_types = inputs_and_output[..inputs_and_output.len() - 1]\n             .iter()\n-            .map(|t| {\n-                EarlyBinder(*t).subst(self.interner.tcx, &bound_vars).lower_into(self.interner)\n-            })\n+            .map(|t| sig.rebind(*t).subst(self.interner.tcx, &bound_vars).lower_into(self.interner))\n             .collect();\n \n-        let return_type = EarlyBinder(inputs_and_output[inputs_and_output.len() - 1])\n+        let return_type = sig\n+            .rebind(inputs_and_output[inputs_and_output.len() - 1])\n             .subst(self.interner.tcx, &bound_vars)\n             .lower_into(self.interner);\n \n@@ -295,7 +294,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         };\n         Arc::new(chalk_solve::rust_ir::FnDefDatum {\n             id: fn_def_id,\n-            sig: sig.lower_into(self.interner),\n+            sig: sig.0.lower_into(self.interner),\n             binders: chalk_ir::Binders::new(binders, bound),\n         })\n     }\n@@ -503,12 +502,14 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let identity_substs = InternalSubsts::identity_for_item(self.interner.tcx, opaque_ty_id.0);\n \n+        let explicit_item_bounds = self.interner.tcx.bound_explicit_item_bounds(opaque_ty_id.0);\n         let bounds =\n-            self.interner\n-                .tcx\n-                .explicit_item_bounds(opaque_ty_id.0)\n+            explicit_item_bounds\n+                .0\n                 .iter()\n-                .map(|(bound, _)| EarlyBinder(*bound).subst(self.interner.tcx, &bound_vars))\n+                .map(|(bound, _)| {\n+                    explicit_item_bounds.rebind(*bound).subst(self.interner.tcx, &bound_vars)\n+                })\n                 .map(|bound| {\n                     bound.fold_with(&mut ReplaceOpaqueTyFolder {\n                         tcx: self.interner.tcx,"}, {"sha": "db0d45b86fc03dacfb09fb51fdf0e15327b6fb94", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -2,9 +2,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{\n-    self, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n-};\n+use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -33,8 +31,9 @@ fn sized_constraint_for_ty<'tcx>(\n             let adt_tys = adt.sized_constraint(tcx);\n             debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n             adt_tys\n+                .0\n                 .iter()\n-                .map(|ty| EarlyBinder(*ty).subst(tcx, substs))\n+                .map(|ty| adt_tys.rebind(*ty).subst(tcx, substs))\n                 .flat_map(|ty| sized_constraint_for_ty(tcx, adtdef, ty))\n                 .collect()\n         }"}, {"sha": "d0334cd0df7bbf97f1818038469215160b5c4a3a", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -15,8 +15,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, EarlyBinder, GenericParamDefKind, ToPredicate, Ty, TyCtxt,\n-    TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, AdtKind, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable,\n+    TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -1295,7 +1295,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n     let infcx = wfcx.infcx;\n     let tcx = wfcx.tcx();\n \n-    let predicates = tcx.predicates_of(def_id);\n+    let predicates = tcx.bound_predicates_of(def_id.to_def_id());\n     let generics = tcx.generics_of(def_id);\n \n     let is_our_default = |def: &ty::GenericParamDef| match def.kind {\n@@ -1392,6 +1392,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n \n     // Now we build the substituted predicates.\n     let default_obligations = predicates\n+        .0\n         .predicates\n         .iter()\n         .flat_map(|&(pred, sp)| {\n@@ -1422,15 +1423,15 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = EarlyBinder(pred).subst(tcx, substs);\n+            let substituted_pred = predicates.rebind(pred).subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_param_types_or_consts()\n                 || param_count.params.len() > 1\n                 || has_region\n             {\n                 None\n-            } else if predicates.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n+            } else if predicates.0.predicates.iter().any(|&(p, _)| p == substituted_pred) {\n                 // Avoid duplication of predicates that contain no parameters, for example.\n                 None\n             } else {\n@@ -1456,7 +1457,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             traits::Obligation::new(cause, wfcx.param_env, pred)\n         });\n \n-    let predicates = predicates.instantiate_identity(tcx);\n+    let predicates = predicates.0.instantiate_identity(tcx);\n \n     let predicates = wfcx.normalize(span, None, predicates);\n "}, {"sha": "f6cb8f8a6da65727873f872fb9c46c44a86a61c9", "filename": "src/ci/scripts/checkout-submodules.sh", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Fci%2Fscripts%2Fcheckout-submodules.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Fci%2Fscripts%2Fcheckout-submodules.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fcheckout-submodules.sh?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -36,10 +36,7 @@ function fetch_github_commit_archive {\n     rm $cached\n }\n \n-# Archive downloads are temporarily disabled due to sudden 504\n-# gateway timeout errors.\n-# included=\"src/llvm-project src/doc/book src/doc/rust-by-example\"\n-included=\"\"\n+included=\"src/llvm-project src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n modules=($modules)\n use_git=\"\"\n@@ -63,9 +60,9 @@ done\n retry sh -c \"git submodule deinit -f $use_git && \\\n     git submodule sync && \\\n     git submodule update -j 16 --init --recursive --depth 1 $use_git\"\n-# STATUS=0\n-# for pid in ${bg_pids[*]}\n-# do\n-#     wait $pid || STATUS=1\n-# done\n-# exit ${STATUS}\n+STATUS=0\n+for pid in ${bg_pids[*]}\n+do\n+    wait $pid || STATUS=1\n+done\n+exit ${STATUS}"}, {"sha": "790727c918a1fd7eaaa2ff44ba2ccf27bae3e05d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -956,7 +956,11 @@ fn clean_fn_decl_with_args<'tcx>(\n     decl: &hir::FnDecl<'tcx>,\n     args: Arguments,\n ) -> FnDecl {\n-    FnDecl { inputs: args, output: decl.output.clean(cx), c_variadic: decl.c_variadic }\n+    let output = match decl.output {\n+        hir::FnRetTy::Return(typ) => Return(clean_ty(typ, cx)),\n+        hir::FnRetTy::DefaultReturn(..) => DefaultReturn,\n+    };\n+    FnDecl { inputs: args, output, c_variadic: decl.c_variadic }\n }\n \n fn clean_fn_decl_from_did_and_sig<'tcx>(\n@@ -991,27 +995,16 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n-        match *self {\n-            Self::Return(typ) => Return(clean_ty(typ, cx)),\n-            Self::DefaultReturn(..) => DefaultReturn,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, Path> for hir::TraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n-        let path = clean_path(self.path, cx);\n-        register_res(cx, path.res);\n-        path\n-    }\n+fn clean_trait_ref<'tcx>(trait_ref: &hir::TraitRef<'tcx>, cx: &mut DocContext<'tcx>) -> Path {\n+    let path = clean_path(trait_ref.path, cx);\n+    register_res(cx, path.res);\n+    path\n }\n \n impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n         PolyTrait {\n-            trait_: self.trait_ref.clean(cx),\n+            trait_: clean_trait_ref(&self.trait_ref, cx),\n             generic_params: self\n                 .bound_generic_params\n                 .iter()\n@@ -2000,7 +1993,7 @@ fn clean_impl<'tcx>(\n ) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n-    let trait_ = impl_.of_trait.as_ref().map(|t| t.clean(cx));\n+    let trait_ = impl_.of_trait.as_ref().map(|t| clean_trait_ref(t, cx));\n     let items =\n         impl_.items.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n     let def_id = tcx.hir().local_def_id(hir_id);"}, {"sha": "f7244f6744f3a5a0ba657805966052f558d80e4a", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.fixed?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{0}\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {bar}\", \"aa\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:?} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:#?} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{1:.3} {} {baz}\", \"aa\", foo.field, baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "ab5f2552bd323c38a90555547ebd1f2822fc38ad", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#[derive(Debug)]\n+struct Foo {\n+    field: usize,\n+}\n+\n+fn main() {\n+    let foo = Foo { field: 0 };\n+    let bar = 3;\n+    format!(\"{foo.field}\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {bar}\", \"aa\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\"); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:?} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:#?} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+    format!(\"{foo.field:.3} {} {baz}\", \"aa\", baz = 3); //~ ERROR invalid format string: field access isn't supported\n+}"}, {"sha": "7ea8b4068f27283ddcb35d69d1f01676a8f7395f", "filename": "src/test/ui/fmt/struct-field-as-captured-argument.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fstruct-field-as-captured-argument.stderr?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,79 @@\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:11:15\n+   |\n+LL |     format!(\"{foo.field}\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{0}\", foo.field);\n+   |               ~  +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:12:15\n+   |\n+LL |     format!(\"{foo.field} {} {bar}\", \"aa\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {bar}\", \"aa\", foo.field);\n+   |               ~                 +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:13:15\n+   |\n+LL |     format!(\"{foo.field} {} {1} {bar}\", \"aa\", \"bb\");\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{2} {} {1} {bar}\", \"aa\", \"bb\", foo.field);\n+   |               ~                           +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:14:15\n+   |\n+LL |     format!(\"{foo.field} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                 +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:15:15\n+   |\n+LL |     format!(\"{foo.field:?} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:?} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                   +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:16:15\n+   |\n+LL |     format!(\"{foo.field:#?} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:#?} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                    +++++++++++\n+\n+error: invalid format string: field access isn't supported\n+  --> $DIR/struct-field-as-captured-argument.rs:17:15\n+   |\n+LL |     format!(\"{foo.field:.3} {} {baz}\", \"aa\", baz = 3);\n+   |               ^^^^^^^^^ not supported in format string\n+   |\n+help: consider using a positional formatting argument instead\n+   |\n+LL |     format!(\"{1:.3} {} {baz}\", \"aa\", foo.field, baz = 3);\n+   |               ~                    +++++++++++\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "2fb292736d1368cc949e18b742bb3f53ffa47d45", "filename": "src/test/ui/lint/unused/issue-92751.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,9 @@\n+#[deny(unused)]\n+pub fn broken(x: Option<()>) -> i32 {\n+    match x {\n+        Some(()) => (1), //~ ERROR unnecessary parentheses around match arm expression\n+        None => (2), //~ ERROR unnecessary parentheses around match arm expression\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "0a8d8e6729cf5c2c309e5c8c8d76fc3cdf40a267", "filename": "src/test/ui/lint/unused/issue-92751.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-92751.stderr?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,32 @@\n+error: unnecessary parentheses around match arm expression\n+  --> $DIR/issue-92751.rs:4:21\n+   |\n+LL |         Some(()) => (1),\n+   |                     ^ ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-92751.rs:1:8\n+   |\n+LL | #[deny(unused)]\n+   |        ^^^^^^\n+   = note: `#[deny(unused_parens)]` implied by `#[deny(unused)]`\n+help: remove these parentheses\n+   |\n+LL -         Some(()) => (1),\n+LL +         Some(()) => 1,\n+   |\n+\n+error: unnecessary parentheses around match arm expression\n+  --> $DIR/issue-92751.rs:5:17\n+   |\n+LL |         None => (2),\n+   |                 ^ ^\n+   |\n+help: remove these parentheses\n+   |\n+LL -         None => (2),\n+LL +         None => 2,\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "bb69951c7b4eaca0f13ac0c095d914498b6ce385", "filename": "src/test/ui/parser/issues/issue-88770.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -3,7 +3,7 @@\n // error-pattern:this file contains an unclosed delimiter\n // error-pattern:expected one of\n // error-pattern:missing `in` in `for` loop\n-// error-pattern:expected `;`, found `e`\n+// error-pattern:expected one of `!`, `)`, `,`, `.`, `::`, `;`, `?`, `{`, or an operator, found `e`\n \n fn m(){print!(\"\",(c for&g\n u"}, {"sha": "4e3a21613ec7869010b106e6d3a018f14595c448", "filename": "src/test/ui/parser/issues/issue-88770.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-88770.stderr?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -48,19 +48,13 @@ error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found\n LL | fn m(){print!(\"\",(c for&g\n    |                     ^^^ expected one of 8 possible tokens\n \n-error: expected `;`, found `e`\n-  --> $DIR/issue-88770.rs:10:2\n+error: expected one of `!`, `)`, `,`, `.`, `::`, `;`, `?`, `{`, or an operator, found `e`\n+  --> $DIR/issue-88770.rs:11:1\n    |\n LL | e\n-   |  ^ help: add `;` here\n+   |  - expected one of 9 possible tokens\n LL | e\n-   | - unexpected token\n+   | ^ unexpected token\n \n-error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found `)`\n-  --> $DIR/issue-88770.rs:11:3\n-   |\n-LL | e\n-   |   ^ expected one of 7 possible tokens\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "9ce2e59e53ba612a16a1570ec95caa9e5a286d76", "filename": "src/test/ui/parser/suggest-semi-in-array.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.rs?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let v = [1\n+    2];\n+    //~^ ERROR expected one of `,`, `.`, `;`, `?`, `]`, or an operator, found `2`\n+}"}, {"sha": "d7cd6efae41d3314235781dbf867bcc657a40d50", "filename": "src/test/ui/parser/suggest-semi-in-array.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6f9d5e73d5524b6281c10a5c89b7db35c330634/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fsuggest-semi-in-array.stderr?ref=f6f9d5e73d5524b6281c10a5c89b7db35c330634", "patch": "@@ -0,0 +1,10 @@\n+error: expected one of `,`, `.`, `;`, `?`, `]`, or an operator, found `2`\n+  --> $DIR/suggest-semi-in-array.rs:3:5\n+   |\n+LL |     let v = [1\n+   |               - expected one of `,`, `.`, `;`, `?`, `]`, or an operator\n+LL |     2];\n+   |     ^ unexpected token\n+\n+error: aborting due to previous error\n+"}]}