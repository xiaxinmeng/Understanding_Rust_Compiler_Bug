{"sha": "4838c78ba4ef784379ae6ec5617479de2a32d3f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MzhjNzhiYTRlZjc4NDM3OWFlNmVjNTYxNzQ3OWRlMmEzMmQzZjY=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-01T22:39:56Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-14T23:49:45Z"}, "message": "Improve `manual_map` and `map_entry`\nLocals which can be partially moved created within the to-be-created closure shouldn't block the use of a closure", "tree": {"sha": "b5940a333778bd497fb48289c443f15b1132fb99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5940a333778bd497fb48289c443f15b1132fb99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4838c78ba4ef784379ae6ec5617479de2a32d3f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEYVqMACgkQ2lnoZDo37QYzagD9GAjQpmyTHyO4odYSoFYy9KDP\nTK6wQaVi4oQcGySvzckBALPXayjWNDdFJ0QkgnovEzWG7iOwnRUUsytAhfHUs8sP\n=dKvr\n-----END PGP SIGNATURE-----", "payload": "tree b5940a333778bd497fb48289c443f15b1132fb99\nparent 7c5487dc62d569d4bc32cbe51951668406242137\nauthor Jason Newcomb <jsnewcomb@pm.me> 1627857596 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1628984985 -0400\n\nImprove `manual_map` and `map_entry`\nLocals which can be partially moved created within the to-be-created closure shouldn't block the use of a closure\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4838c78ba4ef784379ae6ec5617479de2a32d3f6", "html_url": "https://github.com/rust-lang/rust/commit/4838c78ba4ef784379ae6ec5617479de2a32d3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4838c78ba4ef784379ae6ec5617479de2a32d3f6/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c5487dc62d569d4bc32cbe51951668406242137", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c5487dc62d569d4bc32cbe51951668406242137", "html_url": "https://github.com/rust-lang/rust/commit/7c5487dc62d569d4bc32cbe51951668406242137"}], "stats": {"total": 218, "additions": 181, "deletions": 37}, "files": [{"sha": "7fb8e4276600f898a50ed6db0c85cc42ffc40389", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -7,8 +7,9 @@ use clippy_utils::{\n };\n use rustc_errors::Applicability;\n use rustc_hir::{\n+    hir_id::HirIdSet,\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-    Block, Expr, ExprKind, Guard, HirId, Local, Stmt, StmtKind, UnOp,\n+    Block, Expr, ExprKind, Guard, HirId, Pat, Stmt, StmtKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -336,6 +337,8 @@ struct InsertSearcher<'cx, 'tcx> {\n     edits: Vec<Edit<'tcx>>,\n     /// A stack of loops the visitor is currently in.\n     loops: Vec<HirId>,\n+    /// Local variables created in the expression. These don't need to be captured.\n+    locals: HirIdSet,\n }\n impl<'tcx> InsertSearcher<'_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n@@ -383,13 +386,16 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 }\n             },\n             StmtKind::Expr(e) => self.visit_expr(e),\n-            StmtKind::Local(Local { init: Some(e), .. }) => {\n-                self.allow_insert_closure &= !self.in_tail_pos;\n-                self.in_tail_pos = false;\n-                self.is_single_insert = false;\n-                self.visit_expr(e);\n+            StmtKind::Local(l) => {\n+                self.visit_pat(l.pat);\n+                if let Some(e) = l.init {\n+                    self.allow_insert_closure &= !self.in_tail_pos;\n+                    self.in_tail_pos = false;\n+                    self.is_single_insert = false;\n+                    self.visit_expr(e);\n+                }\n             },\n-            _ => {\n+            StmtKind::Item(_) => {\n                 self.allow_insert_closure &= !self.in_tail_pos;\n                 self.is_single_insert = false;\n             },\n@@ -471,6 +477,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     // Each branch may contain it's own insert expression.\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n+                        self.visit_pat(arm.pat);\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n                             self.visit_non_tail_expr(guard);\n                         }\n@@ -496,7 +503,8 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                 },\n                 _ => {\n                     self.allow_insert_closure &= !self.in_tail_pos;\n-                    self.allow_insert_closure &= can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops);\n+                    self.allow_insert_closure &=\n+                        can_move_expr_to_closure_no_visit(self.cx, expr, &self.loops, &self.locals);\n                     // Sub expressions are no longer in the tail position.\n                     self.is_single_insert = false;\n                     self.in_tail_pos = false;\n@@ -505,6 +513,12 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n             },\n         }\n     }\n+\n+    fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+        p.each_binding_or_first(&mut |_, id, _, _| {\n+            self.locals.insert(id);\n+        });\n+    }\n }\n \n struct InsertSearchResults<'tcx> {\n@@ -630,6 +644,7 @@ fn find_insert_calls(\n         in_tail_pos: true,\n         is_single_insert: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n     };\n     s.visit_expr(expr);\n     let allow_insert_closure = s.allow_insert_closure;"}, {"sha": "aee9f791b039d9a7c2ac4f07a346a812012a2703", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -67,6 +67,7 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n@@ -626,7 +627,12 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n }\n \n /// Checks if the top level expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, jump_targets: &[HirId]) -> bool {\n+pub fn can_move_expr_to_closure_no_visit(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    jump_targets: &[HirId],\n+    ignore_locals: &HirIdSet,\n+) -> bool {\n     match expr.kind {\n         ExprKind::Break(Destination { target_id: Ok(id), .. }, _)\n         | ExprKind::Continue(Destination { target_id: Ok(id), .. })\n@@ -642,15 +648,24 @@ pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Exp\n         | ExprKind::LlvmInlineAsm(_) => false,\n         // Accessing a field of a local value can only be done if the type isn't\n         // partially moved.\n-        ExprKind::Field(base_expr, _)\n-            if matches!(\n-                base_expr.kind,\n-                ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n-            ) && can_partially_move_ty(cx, cx.typeck_results().expr_ty(base_expr)) =>\n-        {\n+        ExprKind::Field(\n+            &Expr {\n+                hir_id,\n+                kind:\n+                    ExprKind::Path(QPath::Resolved(\n+                        _,\n+                        Path {\n+                            res: Res::Local(local_id),\n+                            ..\n+                        },\n+                    )),\n+                ..\n+            },\n+            _,\n+        ) if !ignore_locals.contains(local_id) && can_partially_move_ty(cx, cx.typeck_results().node_type(hir_id)) => {\n             // TODO: check if the local has been partially moved. Assume it has for now.\n             false\n-        }\n+        },\n         _ => true,\n     }\n }\n@@ -659,7 +674,11 @@ pub fn can_move_expr_to_closure_no_visit(cx: &LateContext<'tcx>, expr: &'tcx Exp\n pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n+        // Stack of potential break targets contained in the expression.\n         loops: Vec<HirId>,\n+        /// Local variables created in the expression. These don't need to be captured.\n+        locals: HirIdSet,\n+        /// Whether this expression can be turned into a closure.\n         allow_closure: bool,\n     }\n     impl Visitor<'tcx> for V<'_, 'tcx> {\n@@ -677,16 +696,23 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n                 self.visit_block(b);\n                 self.loops.pop();\n             } else {\n-                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops);\n+                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n                 walk_expr(self, e);\n             }\n         }\n+\n+        fn visit_pat(&mut self, p: &'tcx Pat<'tcx>) {\n+            p.each_binding_or_first(&mut |_, id, _, _| {\n+                self.locals.insert(id);\n+            });\n+        }\n     }\n \n     let mut v = V {\n         cx,\n         allow_closure: true,\n         loops: Vec::new(),\n+        locals: HirIdSet::default(),\n     };\n     v.visit_expr(expr);\n     v.allow_closure"}, {"sha": "8a36ec833d76d3aa331b120d356507efe46168e1", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -142,14 +142,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n-    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-        e.insert(v);\n-        foo();\n-    }\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n+    m.entry(k).or_insert_with(|| {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n+        v\n+    });\n }\n \n fn main() {}"}, {"sha": "d972a201ad76460e401c6a0ff613eab5e4f53af9", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -4,7 +4,7 @@\n #![warn(clippy::map_entry)]\n #![feature(asm)]\n \n-use std::collections::{BTreeMap, HashMap};\n+use std::collections::HashMap;\n use std::hash::Hash;\n \n macro_rules! m {\n@@ -146,13 +146,12 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMa\n     if !m.contains_key(&k) {\n         insert!(m, k, v);\n     }\n-}\n \n-fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n-    // insert then do something, use if let\n+    // or_insert_with. Partial move of a local declared in the closure is ok.\n     if !m.contains_key(&k) {\n+        let x = (String::new(), String::new());\n+        let _ = x.0;\n         m.insert(k, v);\n-        foo();\n     }\n }\n "}, {"sha": "1076500498d32fe321a2de82c68e91514cae9ac8", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -165,21 +165,23 @@ LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n-error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:153:5\n+error: usage of `contains_key` followed by `insert` on a `HashMap`\n+  --> $DIR/entry.rs:151:5\n    |\n LL | /     if !m.contains_key(&k) {\n+LL | |         let x = (String::new(), String::new());\n+LL | |         let _ = x.0;\n LL | |         m.insert(k, v);\n-LL | |         foo();\n LL | |     }\n    | |_____^\n    |\n help: try this\n    |\n-LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n-LL +         e.insert(v);\n-LL +         foo();\n-LL +     }\n+LL ~     m.entry(k).or_insert_with(|| {\n+LL +         let x = (String::new(), String::new());\n+LL +         let _ = x.0;\n+LL +         v\n+LL +     });\n    |\n \n error: aborting due to 10 previous errors"}, {"sha": "94979104556bc882267d230b41c535319d712bd8", "filename": "tests/ui/entry_btree.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.fixed?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+        e.insert(v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "080c1d959e89425d326ae8c05e8053128a347425", "filename": "tests/ui/entry_btree.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.rs?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::map_entry)]\n+#![allow(dead_code)]\n+\n+use std::collections::BTreeMap;\n+\n+fn foo() {}\n+\n+fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    // insert then do something, use if let\n+    if !m.contains_key(&k) {\n+        m.insert(k, v);\n+        foo();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5c6fcdf1a28c01f1ba0cbdd646bfb48453cde0e3", "filename": "tests/ui/entry_btree.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fentry_btree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_btree.stderr?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,20 @@\n+error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n+  --> $DIR/entry_btree.rs:12:5\n+   |\n+LL | /     if !m.contains_key(&k) {\n+LL | |         m.insert(k, v);\n+LL | |         foo();\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::map-entry` implied by `-D warnings`\n+help: try this\n+   |\n+LL ~     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n+LL +         e.insert(v);\n+LL +         foo();\n+LL +     }\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "147a0c49e6a068fc754a2ccda46c21e8d4fd56e6", "filename": "tests/ui/manual_map_option_2.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+\n+fn main() {\n+    let _ = Some(0).map(|x| {\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        });\n+}"}, {"sha": "cc612dcc601da9550518c7b1f2e34db50e575ff4", "filename": "tests/ui/manual_map_option_2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+\n+fn main() {\n+    let _ = match Some(0) {\n+        Some(x) => Some({\n+            let y = (String::new(), String::new());\n+            (x, y.0)\n+        }),\n+        None => None,\n+    };\n+}"}, {"sha": "745737079f37795abc1e541c571a0a4d3a301bf2", "filename": "tests/ui/manual_map_option_2.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4838c78ba4ef784379ae6ec5617479de2a32d3f6/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=4838c78ba4ef784379ae6ec5617479de2a32d3f6", "patch": "@@ -0,0 +1,24 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:6:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => Some({\n+LL | |             let y = (String::new(), String::new());\n+LL | |             (x, y.0)\n+LL | |         }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     let _ = Some(0).map(|x| {\n+LL |             let y = (String::new(), String::new());\n+LL |             (x, y.0)\n+LL |         });\n+   |\n+\n+error: aborting due to previous error\n+"}]}