{"sha": "108739f533efd1a4faca62db1afb611f22c5f5f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwODczOWY1MzNlZmQxYTRmYWNhNjJkYjFhZmI2MTFmMjJjNWY1ZjI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-20T02:06:50Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-26T22:14:43Z"}, "message": "Looser restrictions on what can be captured in unbounded traits.", "tree": {"sha": "85601d195be1282d20119ea98add770634b661a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85601d195be1282d20119ea98add770634b661a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108739f533efd1a4faca62db1afb611f22c5f5f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108739f533efd1a4faca62db1afb611f22c5f5f2", "html_url": "https://github.com/rust-lang/rust/commit/108739f533efd1a4faca62db1afb611f22c5f5f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108739f533efd1a4faca62db1afb611f22c5f5f2/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b968783d79301af2305c0b1052092f9d31fd622", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b968783d79301af2305c0b1052092f9d31fd622", "html_url": "https://github.com/rust-lang/rust/commit/7b968783d79301af2305c0b1052092f9d31fd622"}], "stats": {"total": 58, "additions": 35, "deletions": 23}, "files": [{"sha": "ee0d3649467bf6b47669129e8cd553d3d0046fd6", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=108739f533efd1a4faca62db1afb611f22c5f5f2", "patch": "@@ -423,7 +423,7 @@ type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: @fn(e: TestEvent)) {\n+             callback: &fn(e: TestEvent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| copy t.desc);"}, {"sha": "4dde982c34ca238b032c9a38caa1e1200a2bf6f3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=108739f533efd1a4faca62db1afb611f22c5f5f2", "patch": "@@ -293,9 +293,9 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n         expr_cast(source, _) => {\n             check_cast_for_escaping_regions(cx, source, e);\n             match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n-                ty::ty_trait(_, _, store, _, bounds) => {\n+                ty::ty_trait(_, _, _, _, bounds) => {\n                     let source_ty = ty::expr_ty(cx.tcx, source);\n-                    check_trait_cast_bounds(cx, e.span, source_ty, bounds, store)\n+                    check_trait_cast_bounds(cx, e.span, source_ty, bounds)\n                 }\n                 _ => { }\n             }\n@@ -391,19 +391,14 @@ pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n }\n \n pub fn check_trait_cast_bounds(cx: Context, sp: span, ty: ty::t,\n-                               bounds: ty::BuiltinBounds, store: ty::TraitStore) {\n+                               bounds: ty::BuiltinBounds) {\n     do check_builtin_bounds(cx, ty, bounds) |missing| {\n         cx.tcx.sess.span_err(sp,\n             fmt!(\"cannot pack type `%s`, which does not fulfill \\\n                   `%s`, as a trait bounded by %s\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n     }\n-    // FIXME(#3569): Remove this check when the corresponding restriction\n-    // is made with type contents.\n-    if store == ty::UniqTraitStore && !ty::type_is_owned(cx.tcx, ty) {\n-        cx.tcx.sess.span_err(sp, \"uniquely-owned trait objects must be sendable\");\n-    }\n }\n \n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {"}, {"sha": "9e6d9e167cd6a388c6b1ef59152b83cfeacceb74", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108739f533efd1a4faca62db1afb611f22c5f5f2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=108739f533efd1a4faca62db1afb611f22c5f5f2", "patch": "@@ -2063,20 +2063,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n             }\n \n-            ty_trait(_, _, UniqTraitStore, _, _bounds) => {\n-                // FIXME(#3569): Make this conditional on the trait's bounds.\n-                TC_NONCOPY_TRAIT + TC_OWNED_POINTER\n-            }\n-\n-            ty_trait(_, _, BoxTraitStore, mutbl, _bounds) => {\n-                match mutbl {\n-                    ast::m_mutbl => TC_MANAGED + TC_MUTABLE,\n-                    _ => TC_MANAGED\n-                }\n-            }\n-\n-            ty_trait(_, _, RegionTraitStore(r), mutbl, _bounds) => {\n-                borrowed_contents(r, mutbl)\n+            ty_trait(_, _, store, mutbl, bounds) => {\n+                trait_contents(store, mutbl, bounds)\n             }\n \n             ty_rptr(r, mt) => {\n@@ -2278,6 +2266,35 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st + rt + ot\n     }\n \n+    fn trait_contents(store: TraitStore, mutbl: ast::mutability,\n+                      bounds: BuiltinBounds) -> TypeContents {\n+        let st = match store {\n+            UniqTraitStore      => TC_OWNED_POINTER,\n+            BoxTraitStore       => TC_MANAGED,\n+            RegionTraitStore(r) => borrowed_contents(r, mutbl),\n+        };\n+        let mt = match mutbl { ast::m_mutbl => TC_MUTABLE, _ => TC_NONE };\n+        // We get additional \"special type contents\" for each bound that *isn't*\n+        // on the trait. So iterate over the inverse of the bounds that are set.\n+        // This is like with typarams below, but less \"pessimistic\" and also\n+        // dependent on the trait store.\n+        let mut bt = TC_NONE;\n+        for (AllBuiltinBounds() - bounds).each |bound| {\n+            bt = bt + match bound {\n+                BoundCopy if store == UniqTraitStore\n+                            => TC_NONCOPY_TRAIT,\n+                BoundCopy   => TC_NONE, // @Trait/&Trait are copyable either way\n+                BoundStatic if bounds.contains_elem(BoundOwned)\n+                            => TC_NONE, // Owned bound implies static bound.\n+                BoundStatic => TC_BORROWED_POINTER, // Useful for \"@Trait:'static\"\n+                BoundOwned  => TC_NON_OWNED,\n+                BoundConst  => TC_MUTABLE,\n+                BoundSized  => TC_NONE, // don't care if interior is sized\n+            };\n+        }\n+        st + mt + bt\n+    }\n+\n     fn type_param_def_to_contents(cx: ctxt,\n                                   type_param_def: &TypeParameterDef) -> TypeContents\n     {"}]}