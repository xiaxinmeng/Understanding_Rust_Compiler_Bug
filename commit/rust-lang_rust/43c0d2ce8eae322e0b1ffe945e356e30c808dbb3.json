{"sha": "43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYzBkMmNlOGVhZTMyMmUwYjFmZmU5NDVlMzU2ZTMwYzgwOGRiYjM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:53:12Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:53:12Z"}, "message": "Redefine `NodeIndex` as a `newtype_index!`.\n\nThis commit removes the custom index implementation of `NodeIndex`,\nwhich probably predates `newtype_index!`.\n\nAs well as eliminating code, it improves the debugging experience,\nbecause the custom implementation had the property of being incremented\nby 1 (so it could use `NonZeroU32`), which was incredibly confusing if\nyou didn't expect it.\n\nFor some reason, I also had to remove an `unsafe` block marker from\n`from_u32_unchecked()` that the compiler said was now unnecessary.", "tree": {"sha": "2137d29d9f4e87b827fd5ea458c47c774b4195e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2137d29d9f4e87b827fd5ea458c47c774b4195e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "html_url": "https://github.com/rust-lang/rust/commit/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b1111ae8dd97f3cf558654015b8101d270c634", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b1111ae8dd97f3cf558654015b8101d270c634", "html_url": "https://github.com/rust-lang/rust/commit/04b1111ae8dd97f3cf558654015b8101d270c634"}], "stats": {"total": 77, "additions": 35, "deletions": 42}, "files": [{"sha": "6e80b48a6856016dadab3a7eb46bb2add06f0d6c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "patch": "@@ -149,7 +149,7 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                unsafe { $type { private: value } }\n+                $type { private: value }\n             }\n \n             /// Extracts the value of this index as an integer."}, {"sha": "b2120b182fa7b72eb08acf7ebb179bfc91b88c07", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "patch": "@@ -74,9 +74,9 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter().map(|p| p.get())\n-                    .chain(node.dependents.iter().map(|p| p.get()))\n-                    .map(move |p| (p, i))\n+                node.parent.iter()\n+                    .chain(node.dependents.iter())\n+                    .map(move |p| (p.index(), i))\n             })\n             .collect()\n     }"}, {"sha": "cfc3b8194a65c75aae02d88070dee9e6f7972cc9", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c0d2ce8eae322e0b1ffe945e356e30c808dbb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=43c0d2ce8eae322e0b1ffe945e356e30c808dbb3", "patch": "@@ -81,21 +81,24 @@\n //! nodes, which aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n+use crate::indexed_vec::Idx;\n+use crate::newtype_index;\n \n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n use std::marker::PhantomData;\n \n-mod node_index;\n-use self::node_index::NodeIndex;\n-\n mod graphviz;\n \n #[cfg(test)]\n mod tests;\n \n+newtype_index! {\n+    pub struct NodeIndex { .. }\n+}\n+\n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;\n \n@@ -151,6 +154,10 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At all times we maintain the invariant that every node appears\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n+    ///\n+    /// Ideally, this would be an `IndexVec<NodeIndex, Node<O>>`. But that is\n+    /// slower, because this vector is accessed so often that the\n+    /// `u32`-to-`usize` conversions required for accesses are significant.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n@@ -178,13 +185,19 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of\n-    /// which it is a subobligation. Except for error reporting,\n-    /// it is just like any member of `dependents`.\n+    /// The parent of a node - the original obligation of which it is a\n+    /// subobligation. Except for error reporting, it is just like any member\n+    /// of `dependents`.\n+    ///\n+    /// Unlike `ObligationForest::nodes`, this uses `NodeIndex` rather than\n+    /// `usize` for the index, because keeping the size down is more important\n+    /// than the cost of converting to a `usize` for indexing.\n     parent: Option<NodeIndex>,\n \n-    /// Obligations that depend on this obligation for their\n-    /// completion. They must all be in a non-pending state.\n+    /// Obligations that depend on this obligation for their completion. They\n+    /// must all be in a non-pending state.\n+    ///\n+    /// This uses `NodeIndex` for the same reason as `parent`.\n     dependents: Vec<NodeIndex>,\n \n     /// Identifier of the obligation tree to which this node belongs.\n@@ -294,7 +307,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().get()];\n+                let node = &mut self.nodes[o.get().index()];\n                 if let Some(parent_index) = parent {\n                     // If the node is already in `waiting_cache`, it's already\n                     // been marked with a parent. (It's possible that parent\n@@ -318,7 +331,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n                 let obligation_tree_id = match parent {\n                     Some(parent_index) => {\n-                        self.nodes[parent_index.get()].obligation_tree_id\n+                        self.nodes[parent_index.index()].obligation_tree_id\n                     }\n                     None => self.obligation_tree_id_generator.next().unwrap()\n                 };\n@@ -506,7 +519,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 node.state.set(NodeState::OnDfsStack);\n                 stack.push(i);\n                 for index in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, index.get());\n+                    self.find_cycles_from_node(stack, processor, index.index());\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n@@ -531,11 +544,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n             let node = &self.nodes[i];\n             node.state.set(NodeState::Error);\n             trace.push(node.obligation.clone());\n-            error_stack.extend(node.dependents.iter().map(|index| index.get()));\n+            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n \n             // Loop to the parent.\n             match node.parent {\n-                Some(parent_index) => i = parent_index.get(),\n+                Some(parent_index) => i = parent_index.index(),\n                 None => break\n             }\n         }\n@@ -548,7 +561,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n \n             error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|index| index.get())\n+                node.parent.iter().chain(node.dependents.iter()).map(|index| index.index())\n             );\n         }\n \n@@ -560,7 +573,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n         for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+            self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n         }\n     }\n \n@@ -686,7 +699,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             if let Some(index) = node.parent {\n-                let new_i = node_rewrites[index.get()];\n+                let new_i = node_rewrites[index.index()];\n                 if new_i >= nodes_len {\n                     // parent dead due to error\n                     node.parent = None;\n@@ -697,7 +710,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n             let mut i = 0;\n             while i < node.dependents.len() {\n-                let new_i = node_rewrites[node.dependents[i].get()];\n+                let new_i = node_rewrites[node.dependents[i].index()];\n                 if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n                 } else {\n@@ -709,7 +722,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         let mut kill_list = vec![];\n         for (predicate, index) in &mut self.waiting_cache {\n-            let new_i = node_rewrites[index.get()];\n+            let new_i = node_rewrites[index.index()];\n             if new_i >= nodes_len {\n                 kill_list.push(predicate.clone());\n             } else {"}, {"sha": "69ea473e054618dabe8dc437e23c649f42517b5f", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04b1111ae8dd97f3cf558654015b8101d270c634/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b1111ae8dd97f3cf558654015b8101d270c634/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=04b1111ae8dd97f3cf558654015b8101d270c634", "patch": "@@ -1,20 +0,0 @@\n-use std::num::NonZeroU32;\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct NodeIndex {\n-    index: NonZeroU32,\n-}\n-\n-impl NodeIndex {\n-    #[inline]\n-    pub fn new(value: usize) -> NodeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        NodeIndex { index: NonZeroU32::new((value as u32) + 1).unwrap() }\n-    }\n-\n-    #[inline]\n-    pub fn get(self) -> usize {\n-        (self.index.get() - 1) as usize\n-    }\n-}"}]}