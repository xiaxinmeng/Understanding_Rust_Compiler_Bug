{"sha": "efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYzQ1NzU4ZmQyYTdjZTRhYzU2ZDZkODljZWQ4NjM0ZTFkY2ZhZWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-12-27T20:09:33Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-12-27T22:52:37Z"}, "message": "rewrite the method-receiver matching code\n\nthe old code was *so terrible*.", "tree": {"sha": "30636a1cfef5f683b75d5707e8bad131a67203a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30636a1cfef5f683b75d5707e8bad131a67203a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "html_url": "https://github.com/rust-lang/rust/commit/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/comments", "author": null, "committer": null, "parents": [{"sha": "2ced1499254008e89166432a59470d7809871ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ced1499254008e89166432a59470d7809871ad8", "html_url": "https://github.com/rust-lang/rust/commit/2ced1499254008e89166432a59470d7809871ad8"}], "stats": {"total": 523, "additions": 164, "deletions": 359}, "files": [{"sha": "50c9a1a31f2208b047638d239f2fe4f6a586d646", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -633,7 +633,6 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n             name: self.name,"}, {"sha": "6f72d3df07e37774ac248854c648f2368a4cda78", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -695,7 +695,6 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,"}, {"sha": "0b362be215dfef40e6b9bc83158bb7430523436a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -462,8 +462,7 @@ impl fmt::Debug for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({:?}, {:?}, {}, {})\",\n-                       data.def_id,\n+                write!(f, \"ReEarlyBound({:?}, {}, {})\",\n                        data.space,\n                        data.index,\n                        data.name)"}, {"sha": "50a672a4b69e700414629c453f10dd460010a89b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -289,7 +289,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                           -> ty::Region {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: self.infcx.tcx.map.local_def_id(ast::DUMMY_NODE_ID),\n             space: space,\n             index: index,\n             name: name,"}, {"sha": "b99431d265618a4c02438b6417615927415dbd42", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -192,14 +192,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                let def_id = self.parse_def();\n                 let space = self.parse_param_space();\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    def_id: def_id,\n                     space: space,\n                     index: index,\n                     name: name"}, {"sha": "6d42871201b8e792610a568fcdf57e3fa451c7e4", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -253,8 +253,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n             mywrite!(w, \"]\");\n         }\n         ty::ReEarlyBound(ref data) => {\n-            mywrite!(w, \"B[{}|{}|{}|{}]\",\n-                     (cx.ds)(data.def_id),\n+            mywrite!(w, \"B[{}|{}|{}]\",\n                      data.space.to_uint(),\n                      data.index,\n                      data.name);"}, {"sha": "95d85964044da7be0ef5175ed104128ecf6d213a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 69, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -57,7 +57,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, Ty, ToPredicate, HasTypeFlags};\n+use middle::ty::{self, Ty, ToPredicate, HasTypeFlags};\n use middle::ty::wf::object_region_bounds;\n use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n@@ -169,10 +169,8 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n             ty::ReLateBound(debruijn, ty::BrNamed(tcx.map.local_def_id(id), lifetime.name))\n         }\n \n-        Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n-            let def_id = tcx.map.local_def_id(id);\n+        Some(&rl::DefEarlyBoundRegion(space, index, _)) => {\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: lifetime.name\n@@ -1797,75 +1795,31 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     // lifetime elision, we can determine it in two ways. First (determined\n     // here), if self is by-reference, then the implied output region is the\n     // region of the self parameter.\n-    let mut explicit_self_category_result = None;\n-    let (self_ty, implied_output_region) = match opt_self_info {\n+    let (self_ty, explicit_self_category) = match opt_self_info {\n         None => (None, None),\n-        Some(self_info) => {\n-            // This type comes from an impl or trait; no late-bound\n-            // regions should be present.\n-            assert!(!self_info.untransformed_self_ty.has_escaping_regions());\n-\n-            // Figure out and record the explicit self category.\n-            let explicit_self_category =\n-                determine_explicit_self_category(this, &rb, &self_info);\n-            explicit_self_category_result = Some(explicit_self_category);\n-            match explicit_self_category {\n-                ty::StaticExplicitSelfCategory => {\n-                    (None, None)\n-                }\n-                ty::ByValueExplicitSelfCategory => {\n-                    (Some(self_info.untransformed_self_ty), None)\n-                }\n-                ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n-                    (Some(this.tcx().mk_ref(\n-                                      this.tcx().mk_region(region),\n-                                      ty::TypeAndMut {\n-                                        ty: self_info.untransformed_self_ty,\n-                                        mutbl: mutability\n-                                      })),\n-                     Some(region))\n-                }\n-                ty::ByBoxExplicitSelfCategory => {\n-                    (Some(this.tcx().mk_box(self_info.untransformed_self_ty)), None)\n-                }\n-            }\n-        }\n+        Some(self_info) => determine_self_type(this, &rb, self_info)\n     };\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n-    let input_params = if self_ty.is_some() {\n+    let arg_params = if self_ty.is_some() {\n         &decl.inputs[1..]\n     } else {\n         &decl.inputs[..]\n     };\n-    let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n-    let input_pats: Vec<String> = input_params.iter()\n-                                              .map(|a| pprust::pat_to_string(&*a.pat))\n-                                              .collect();\n-    let self_and_input_tys: Vec<Ty> =\n-        self_ty.into_iter().chain(input_tys).collect();\n-\n+    let arg_tys: Vec<Ty> =\n+        arg_params.iter().map(|a| ty_of_arg(this, &rb, a, None)).collect();\n+    let arg_pats: Vec<String> =\n+        arg_params.iter().map(|a| pprust::pat_to_string(&*a.pat)).collect();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n-    let implied_output_region = match implied_output_region {\n-        Some(r) => Ok(r),\n-        None => {\n-            let input_tys = if self_ty.is_some() {\n-                // Skip the first argument if `self` is present.\n-                &self_and_input_tys[1..]\n-            } else {\n-                &self_and_input_tys[..]\n-            };\n-\n-            find_implied_output_region(this.tcx(), input_tys, input_pats)\n-        }\n+    let implied_output_region = match explicit_self_category {\n+        Some(ty::ByReferenceExplicitSelfCategory(region, _)) => Ok(region),\n+        _ => find_implied_output_region(this.tcx(), &arg_tys, arg_pats)\n     };\n \n     let output_ty = match decl.output {\n-        hir::Return(ref output) if output.node == hir::TyInfer =>\n-            ty::FnConverging(this.ty_infer(None, None, None, output.span)),\n         hir::Return(ref output) =>\n             ty::FnConverging(convert_ty_with_lifetime_elision(this,\n                                                               implied_output_region,\n@@ -1878,28 +1832,37 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n         unsafety: unsafety,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {\n-            inputs: self_and_input_tys,\n+            inputs: self_ty.into_iter().chain(arg_tys).collect(),\n             output: output_ty,\n             variadic: decl.variadic\n         }),\n-    }, explicit_self_category_result)\n+    }, explicit_self_category)\n }\n \n-fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n-                                              rscope: &RegionScope,\n-                                              self_info: &SelfInfo<'a, 'tcx>)\n-                                              -> ty::ExplicitSelfCategory\n+fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,\n+                                 rscope: &RegionScope,\n+                                 self_info: SelfInfo<'a, 'tcx>)\n+                                 -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n {\n+    let self_ty = self_info.untransformed_self_ty;\n     return match self_info.explicit_self.node {\n-        hir::SelfStatic => ty::StaticExplicitSelfCategory,\n-        hir::SelfValue(_) => ty::ByValueExplicitSelfCategory,\n+        hir::SelfStatic => (None, Some(ty::StaticExplicitSelfCategory)),\n+        hir::SelfValue(_) => {\n+            (Some(self_ty), Some(ty::ByValueExplicitSelfCategory))\n+        }\n         hir::SelfRegion(ref lifetime, mutability, _) => {\n             let region =\n                 opt_ast_region_to_region(this,\n                                          rscope,\n                                          self_info.explicit_self.span,\n                                          lifetime);\n-            ty::ByReferenceExplicitSelfCategory(region, mutability)\n+            (Some(this.tcx().mk_ref(\n+                this.tcx().mk_region(region),\n+                ty::TypeAndMut {\n+                    ty: self_ty,\n+                    mutbl: mutability\n+                })),\n+             Some(ty::ByReferenceExplicitSelfCategory(region, mutability)))\n         }\n         hir::SelfExplicit(ref ast_type, _) => {\n             let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n@@ -1944,15 +1907,17 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n                    impl_modifiers,\n                    method_modifiers);\n \n-            if impl_modifiers >= method_modifiers {\n+            let category = if impl_modifiers >= method_modifiers {\n                 ty::ByValueExplicitSelfCategory\n             } else {\n                 match explicit_type.sty {\n                     ty::TyRef(r, mt) => ty::ByReferenceExplicitSelfCategory(*r, mt.mutbl),\n                     ty::TyBox(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n                 }\n-            }\n+            };\n+\n+            (Some(explicit_type), Some(category))\n         }\n     };\n "}, {"sha": "230422b7044cd5d366463efc59d885daf57eec84", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -136,9 +136,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             let item = fcx.tcx().impl_or_trait_item(fcx.tcx().map.local_def_id(item_id));\n \n-            let mut implied_bounds = match item.container() {\n-                ty::TraitContainer(_) => vec![],\n-                ty::ImplContainer(def_id) => impl_implied_bounds(fcx, def_id, span)\n+            let (mut implied_bounds, self_ty) = match item.container() {\n+                ty::TraitContainer(_) => (vec![], fcx.tcx().mk_self_type()),\n+                ty::ImplContainer(def_id) => (impl_implied_bounds(fcx, def_id, span),\n+                                              fcx.tcx().lookup_item_type(def_id).ty)\n             };\n \n             match item {\n@@ -152,6 +153,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n                     this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n+                    this.check_method_receiver(fcx, span, &method,\n+                                               free_id_outlive, self_ty);\n                 }\n                 ty::TypeTraitItem(assoc_type) => {\n                     if let Some(ref ty) = assoc_type.ty {\n@@ -377,6 +380,47 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.check_where_clauses(fcx, span, predicates);\n     }\n \n+    fn check_method_receiver<'fcx>(&mut self,\n+                                   fcx: &FnCtxt<'fcx,'tcx>,\n+                                   span: Span,\n+                                   method: &ty::Method<'tcx>,\n+                                   free_id_outlive: CodeExtent,\n+                                   self_ty: ty::Ty<'tcx>)\n+    {\n+        // check that the type of the method's receiver matches the\n+        // method's first parameter.\n+\n+        let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n+        let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+\n+        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?},sig={:?})\",\n+               method.name, method.explicit_self, self_ty, sig);\n+\n+        let rcvr_ty = match method.explicit_self {\n+            ty::StaticExplicitSelfCategory => return,\n+            ty::ByValueExplicitSelfCategory => self_ty,\n+            ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n+                fcx.tcx().mk_ref(fcx.tcx().mk_region(region), ty::TypeAndMut {\n+                    ty: self_ty,\n+                    mutbl: mutability\n+                })\n+            }\n+            ty::ByBoxExplicitSelfCategory => fcx.tcx().mk_box(self_ty)\n+        };\n+        let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n+        let rcvr_ty = fcx.tcx().liberate_late_bound_regions(free_id_outlive,\n+                                                            &ty::Binder(rcvr_ty));\n+\n+        debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n+\n+        let _ = ::require_same_types(\n+            fcx.tcx(), Some(fcx.infcx()), false, span,\n+            sig.inputs[0], rcvr_ty,\n+            || \"mismatched method receiver\".to_owned()\n+        );\n+    }\n+\n     fn check_variances_for_type_defn(&self,\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)"}, {"sha": "b7ce91d331723a572220c211d2ac8e70ca9dae5b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 63, "deletions": 259, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -69,18 +69,15 @@ use middle::def;\n use middle::def_id::DefId;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n-use middle::free_region::FreeRegionMap;\n-use middle::region;\n use middle::resolve_lifetime;\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n+use middle::ty::{self, ToPolyTraitRef, Ty, TypeScheme};\n use middle::ty::{VariantKind};\n-use middle::ty::fold::{TypeFolder, TypeFoldable};\n+use middle::ty::fold::{TypeFolder};\n use middle::ty::util::IntTypeExt;\n-use middle::infer;\n use rscope::*;\n use rustc::front::map as hir_map;\n use util::common::{ErrorReported, memoized};\n@@ -195,16 +192,6 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         ItemCtxt { ccx: self, param_bounds: param_bounds }\n     }\n \n-    fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n-        let def_id = self.tcx.map.local_def_id(method_id);\n-        match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n-            ty::MethodTraitItem(ref mty) => mty.clone(),\n-            _ => {\n-                self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n-            }\n-        }\n-    }\n-\n     fn cycle_check<F,R>(&self,\n                         span: Span,\n                         request: AstConvRequest,\n@@ -573,10 +560,10 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n-                            sig: &hir::MethodSig,\n-                            id: ast::NodeId,\n                             name: ast::Name,\n+                            id: ast::NodeId,\n                             vis: hir::Visibility,\n+                            sig: &hir::MethodSig,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_generics: &ty::Generics<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n@@ -681,33 +668,6 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n        .insert(ccx.tcx.map.local_def_id(id), ty::TypeTraitItem(associated_type));\n }\n \n-fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 container: ImplOrTraitItemContainer,\n-                                 methods: I,\n-                                 untransformed_rcvr_ty: Ty<'tcx>,\n-                                 rcvr_ty_generics: &ty::Generics<'tcx>,\n-                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n-    where I: Iterator<Item=(&'i hir::MethodSig, ast::NodeId, ast::Name, hir::Visibility, Span)>\n-{\n-    debug!(\"convert_methods(untransformed_rcvr_ty={:?}, rcvr_ty_generics={:?}, \\\n-                            rcvr_ty_predicates={:?})\",\n-           untransformed_rcvr_ty,\n-           rcvr_ty_generics,\n-           rcvr_ty_predicates);\n-\n-    for (sig, id, name, vis, _span) in methods {\n-        convert_method(ccx,\n-                       container,\n-                       sig,\n-                       id,\n-                       name,\n-                       vis,\n-                       untransformed_rcvr_ty,\n-                       rcvr_ty_generics,\n-                       rcvr_ty_predicates);\n-    }\n-}\n-\n fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: Span,\n                                  generics: &hir::Generics,\n@@ -867,149 +827,98 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n             }\n \n-            let methods = impl_items.iter().filter_map(|ii| {\n-                if let hir::ImplItemKind::Method(ref sig, _) = ii.node {\n+            for impl_item in impl_items {\n+                if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                     // if the method specifies a visibility, use that, otherwise\n                     // inherit the visibility from the impl (so `foo` in `pub impl\n                     // { fn foo(); }` is public, but private in `impl { fn\n                     // foo(); }`).\n-                    let method_vis = ii.vis.inherit_from(parent_visibility);\n-                    Some((sig, ii.id, ii.name, method_vis, ii.span))\n-                } else {\n-                    None\n-                }\n-            });\n-            convert_methods(ccx,\n-                            ImplContainer(def_id),\n-                            methods,\n-                            selfty,\n-                            &ty_generics,\n-                            &ty_predicates);\n+                    let method_vis = impl_item.vis.inherit_from(parent_visibility);\n \n-            for impl_item in impl_items {\n-                if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                    let body_id = body.id;\n-                    let body_scope = ccx.tcx.region_maps.call_site_extent(impl_item.id, body_id);\n-                    check_method_self_type(ccx,\n-                                           &BindingRscope::new(),\n-                                           ccx.method_ty(impl_item.id),\n-                                           selfty,\n-                                           &sig.explicit_self,\n-                                           body_scope,\n-                                           body_id);\n+                    convert_method(ccx, ImplContainer(def_id),\n+                                   impl_item.name, impl_item.id, method_vis,\n+                                   sig, selfty, &ty_generics, &ty_predicates);\n                 }\n             }\n \n             enforce_impl_lifetimes_are_constrained(tcx, generics, def_id, impl_items);\n         },\n         hir::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n+            let def_id = trait_def.trait_ref.def_id;\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ccx.ensure_super_predicates(it.span, ccx.tcx.map.local_def_id(it.id));\n+                ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = tcx.lookup_predicates(ccx.tcx.map.local_def_id(it.id));\n+            let trait_predicates = tcx.lookup_predicates(def_id);\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n-            // Convert all the associated types.\n+            // FIXME: is the ordering here important? I think it is.\n+            let container = TraitContainer(def_id);\n+\n+            // Convert all the associated constants.\n             for trait_item in trait_items {\n-                match trait_item.node {\n-                    hir::ConstTraitItem(ref ty, ref default) => {\n-                        let ty = ccx.icx(&trait_predicates)\n-                                    .to_ty(&ExplicitRscope, ty);\n-                        tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n-                                               TypeScheme {\n-                                                   generics: trait_def.generics.clone(),\n-                                                   ty: ty,\n-                                               });\n-                        convert_associated_const(ccx,\n-                                                 TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n-                                                 trait_item.name,\n-                                                 trait_item.id,\n-                                                 hir::Public,\n-                                                 ty,\n-                                                 default.is_some())\n-                    }\n-                    _ => {}\n+                if let hir::ConstTraitItem(ref ty, ref default) = trait_item.node {\n+                    let ty = ccx.icx(&trait_predicates)\n+                        .to_ty(&ExplicitRscope, ty);\n+                    tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n+                                           TypeScheme {\n+                                               generics: trait_def.generics.clone(),\n+                                               ty: ty,\n+                                           });\n+                    convert_associated_const(ccx,\n+                                             container,\n+                                             trait_item.name,\n+                                             trait_item.id,\n+                                             hir::Public,\n+                                             ty,\n+                                             default.is_some())\n                 }\n-            };\n+            }\n \n             // Convert all the associated types.\n             for trait_item in trait_items {\n-                match trait_item.node {\n-                    hir::TypeTraitItem(_, ref opt_ty) => {\n-                        let typ = opt_ty.as_ref().map({\n-                            |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n-                        });\n-\n-                        convert_associated_type(ccx,\n-                                                TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n-                                                trait_item.name,\n-                                                trait_item.id,\n-                                                hir::Public,\n-                                                typ);\n-                    }\n-                    _ => {}\n+                if let hir::TypeTraitItem(_, ref opt_ty) = trait_item.node {\n+                    let typ = opt_ty.as_ref().map({\n+                        |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+                    });\n+\n+                    convert_associated_type(ccx,\n+                                            container,\n+                                            trait_item.name,\n+                                            trait_item.id,\n+                                            hir::Public,\n+                                            typ);\n                 }\n-            };\n+            }\n \n-            let methods = trait_items.iter().filter_map(|ti| {\n-                let sig = match ti.node {\n-                    hir::MethodTraitItem(ref sig, _) => sig,\n-                    _ => return None,\n-                };\n-                Some((sig, ti.id, ti.name, hir::Inherited, ti.span))\n-            });\n+            // Convert all the methods\n+            for trait_item in trait_items {\n+                if let hir::MethodTraitItem(ref sig, _) = trait_item.node {\n+                    convert_method(ccx,\n+                                   container,\n+                                   trait_item.name,\n+                                   trait_item.id,\n+                                   hir::Inherited,\n+                                   sig,\n+                                   tcx.mk_self_type(),\n+                                   &trait_def.generics,\n+                                   &trait_predicates);\n \n-            // Run convert_methods on the trait methods.\n-            convert_methods(ccx,\n-                            TraitContainer(ccx.tcx.map.local_def_id(it.id)),\n-                            methods,\n-                            tcx.mk_self_type(),\n-                            &trait_def.generics,\n-                            &trait_predicates);\n+                }\n+            }\n \n             // Add an entry mapping\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n                 let def_id = ccx.tcx.map.local_def_id(trait_item.id);\n                 match trait_item.node {\n-                    hir::ConstTraitItem(..) => {\n-                        ty::ConstTraitItemId(def_id)\n-                    }\n-                    hir::MethodTraitItem(..) => {\n-                        ty::MethodTraitItemId(def_id)\n-                    }\n-                    hir::TypeTraitItem(..) => {\n-                        ty::TypeTraitItemId(def_id)\n-                    }\n+                    hir::ConstTraitItem(..) => ty::ConstTraitItemId(def_id),\n+                    hir::MethodTraitItem(..) => ty::MethodTraitItemId(def_id),\n+                    hir::TypeTraitItem(..) => ty::TypeTraitItemId(def_id)\n                 }\n             }).collect());\n             tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                        trait_item_def_ids);\n-\n-            // This must be done after `collect_trait_methods` so that\n-            // we have a method type stored for every method.\n-            for trait_item in trait_items {\n-                let (sig, the_scope, the_id) = match trait_item.node {\n-                    hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                        let body_scope =\n-                            ccx.tcx.region_maps.call_site_extent(trait_item.id, body.id);\n-                        (sig, body_scope, body.id)\n-                    }\n-                    hir::MethodTraitItem(ref sig, None) => {\n-                        let item_scope = ccx.tcx.region_maps.item_extent(trait_item.id);\n-                        (sig, item_scope, it.id)\n-                    }\n-                    _ => continue\n-                };\n-                check_method_self_type(ccx,\n-                                       &BindingRscope::new(),\n-                                       ccx.method_ty(trait_item.id),\n-                                       tcx.mk_self_type(),\n-                                       &sig.explicit_self,\n-                                       the_scope,\n-                                       the_id)\n-            }\n         },\n         hir::ItemStruct(ref struct_def, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n@@ -1395,7 +1304,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: tcx.map.local_def_id(def.lifetime.id),\n                         space: TypeSpace,\n                         index: i as u32,\n                         name: def.lifetime.name\n@@ -1870,10 +1778,8 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n     for (index, param) in early_lifetimes.iter().enumerate() {\n         let index = index as u32;\n-        let def_id = tcx.map.local_def_id(param.lifetime.id);\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: param.lifetime.name\n@@ -2281,106 +2187,6 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Substs::new(types, regions)\n }\n \n-/// Verifies that the explicit self type of a method matches the impl\n-/// or trait. This is a bit weird but basically because right now we\n-/// don't handle the general case, but instead map it to one of\n-/// several pre-defined options using various heuristics, this method\n-/// comes back to check after the fact that explicit type the user\n-/// wrote actually matches what the pre-defined option said.\n-fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n-    rs: &RS,\n-    method_type: Rc<ty::Method<'tcx>>,\n-    required_type: Ty<'tcx>,\n-    explicit_self: &hir::ExplicitSelf,\n-    body_scope: region::CodeExtent,\n-    body_id: ast::NodeId)\n-{\n-    let tcx = ccx.tcx;\n-    if let hir::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = ccx.icx(&method_type.predicates).to_ty(rs, &**ast_type);\n-        let base_type = match typ.sty {\n-            ty::TyRef(_, tm) => tm.ty,\n-            ty::TyBox(typ) => typ,\n-            _ => typ,\n-        };\n-\n-        // \"Required type\" comes from the trait definition. It may\n-        // contain late-bound regions from the method, but not the\n-        // trait (since traits only have early-bound region\n-        // parameters).\n-        assert!(!base_type.has_regions_escaping_depth(1));\n-        let required_type_free =\n-            liberate_early_bound_regions(\n-                tcx, body_scope,\n-                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(required_type)));\n-\n-        // The \"base type\" comes from the impl. It too may have late-bound\n-        // regions from the method.\n-        assert!(!base_type.has_regions_escaping_depth(1));\n-        let base_type_free =\n-            liberate_early_bound_regions(\n-                tcx, body_scope,\n-                &tcx.liberate_late_bound_regions(body_scope, &ty::Binder(base_type)));\n-\n-        debug!(\"required_type={:?} required_type_free={:?} \\\n-                base_type={:?} base_type_free={:?}\",\n-               required_type,\n-               required_type_free,\n-               base_type,\n-               base_type_free);\n-\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-        drop(::require_same_types(tcx,\n-                                  Some(&infcx),\n-                                  false,\n-                                  explicit_self.span,\n-                                  base_type_free,\n-                                  required_type_free,\n-                                  || {\n-                format!(\"mismatched self type: expected `{}`\",\n-                         required_type)\n-        }));\n-\n-        // We could conceviably add more free-region relations here,\n-        // but since this code is just concerned with checking that\n-        // the `&Self` types etc match up, it's not really necessary.\n-        // It would just allow people to be more approximate in some\n-        // cases. In any case, we can do it later as we feel the need;\n-        // I'd like this function to go away eventually.\n-        let free_regions = FreeRegionMap::new();\n-\n-        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n-    }\n-\n-    fn liberate_early_bound_regions<'tcx,T>(\n-        tcx: &ty::ctxt<'tcx>,\n-        scope: region::CodeExtent,\n-        value: &T)\n-        -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        /*!\n-         * Convert early-bound regions into free regions; normally this is done by\n-         * applying the `free_substs` from the `ParameterEnvironment`, but this particular\n-         * method-self-type check is kind of hacky and done very early in the process,\n-         * before we really have a `ParameterEnvironment` to check.\n-         */\n-\n-        tcx.fold_regions(value, &mut false, |region, _| {\n-            match region {\n-                ty::ReEarlyBound(data) => {\n-                    ty::ReFree(ty::FreeRegion {\n-                        scope: scope,\n-                        bound_region: ty::BrNamed(data.def_id, data.name)\n-                    })\n-                }\n-                _ => region\n-            }\n-        })\n-    }\n-}\n-\n /// Checks that all the type parameters on an impl\n fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                              ast_generics: &hir::Generics,\n@@ -2450,9 +2256,7 @@ fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   .collect();\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n-        let def_id = tcx.map.local_def_id(lifetime_def.lifetime.id);\n-        let region = ty::EarlyBoundRegion { def_id: def_id,\n-                                            space: TypeSpace,\n+        let region = ty::EarlyBoundRegion { space: TypeSpace,\n                                             index: index as u32,\n                                             name: lifetime_def.lifetime.name };\n         if"}, {"sha": "8c7967c7078073d424112c38b759b3d1f6445364", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -1002,12 +1002,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n-                                   _generics: &ty::Generics<'tcx>,\n+                                   generics: &ty::Generics<'tcx>,\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                let node_id = self.tcx().map.as_local_node_id(data.def_id).unwrap();\n+                let def_id =\n+                    generics.regions.get(data.space, data.index as usize).def_id;\n+                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);\n                     self.add_constraint(index, variance);"}, {"sha": "4381bf22e2acee44f667826dd86fdd94cd92725b", "filename": "src/test/compile-fail/issue-17740.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -15,12 +15,12 @@ struct Foo<'a> {\n impl <'a> Foo<'a>{\n     fn bar(self: &mut Foo) {\n     //~^ mismatched types\n-    //~| expected `Foo<'a>`\n-    //~| found `Foo<'_>`\n+    //~| expected `&mut Foo<'a>`\n+    //~| found `&mut Foo<'_>`\n     //~| lifetime mismatch\n     //~| mismatched types\n-    //~| expected `Foo<'a>`\n-    //~| found `Foo<'_>`\n+    //~| expected `&mut Foo<'a>`\n+    //~| found `&mut Foo<'_>`\n     //~| lifetime mismatch\n     }\n }"}, {"sha": "f11d482ea16db55a42a9ad695a80a1c01f5c192b", "filename": "src/test/compile-fail/issue-17905.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -16,10 +16,6 @@ impl Pair<\n     isize\n > {\n     fn say(self: &Pair<&str, isize>) {\n-//~^ ERROR mismatched types\n-//~| expected `Pair<&'static str, isize>`\n-//~| found `Pair<&str, isize>`\n-//~| lifetime mismatch\n         println!(\"{}\", self);\n     }\n }"}, {"sha": "ef91188c5d166bd1d8de2e11c18a3a82517627f2", "filename": "src/test/compile-fail/issue-26194.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26194.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -12,7 +12,7 @@ struct S(String);\n \n impl S {\n     fn f(self: *mut S) -> String { self.0 }\n-    //~^ ERROR mismatched self type\n+    //~^ ERROR mismatched method receiver\n }\n \n fn main() { S(\"\".to_owned()).f(); }"}, {"sha": "e54a7623cb0c3c4a5b7c5787e94d0d1545425f7b", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=efc45758fd2a7ce4ac56d6d89ced8634e1dcfaea", "patch": "@@ -15,7 +15,7 @@ struct Foo {\n }\n \n impl Foo {\n-    fn foo(self: isize, x: isize) -> isize {  //~ ERROR mismatched self type\n+    fn foo(self: isize, x: isize) -> isize {  //~ ERROR mismatched method receiver\n         self.f + x\n     }\n }\n@@ -25,10 +25,10 @@ struct Bar<T> {\n }\n \n impl<T> Bar<T> {\n-    fn foo(self: Bar<isize>, x: isize) -> isize { //~ ERROR mismatched self type\n+    fn foo(self: Bar<isize>, x: isize) -> isize { //~ ERROR mismatched method receiver\n         x\n     }\n-    fn bar(self: &Bar<usize>, x: isize) -> isize {   //~ ERROR mismatched self type\n+    fn bar(self: &Bar<usize>, x: isize) -> isize {   //~ ERROR mismatched method receiver\n         x\n     }\n }\n@@ -41,15 +41,16 @@ trait SomeTrait {\n \n impl<'a, T> SomeTrait for &'a Bar<T> {\n     fn dummy1(self: &&'a Bar<T>) { }\n-    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched self type\n+    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched types\n+    //~^ ERROR mismatched types\n     fn dummy3(self: &&Bar<T>) {}\n     //~^ ERROR mismatched types\n-    //~| expected `&'a Bar<T>`\n-    //~| found `&Bar<T>`\n+    //~| expected `&&'a Bar<T>`\n+    //~| found `&&Bar<T>`\n     //~| lifetime mismatch\n     //~| ERROR mismatched types\n-    //~| expected `&'a Bar<T>`\n-    //~| found `&Bar<T>`\n+    //~| expected `&&'a Bar<T>`\n+    //~| found `&&Bar<T>`\n     //~| lifetime mismatch\n }\n "}]}