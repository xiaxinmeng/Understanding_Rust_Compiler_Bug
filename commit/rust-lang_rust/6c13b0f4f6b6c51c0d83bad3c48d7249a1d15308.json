{"sha": "6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTNiMGY0ZjZiNmM1MWMwZDgzYmFkM2M0OGQ3MjQ5YTFkMTUzMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-04T21:20:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-04T21:20:46Z"}, "message": "auto merge of #8935 : blake2-ppc/rust/reader-bytes, r=brson\n\nAn iterator that simply calls `.read_bytes()` each iteration.\r\n\r\nI think choosing to own the Reader value and implementing Decorator to\r\nallow extracting it is the most generically useful. The Reader type\r\nvariable can of course be some kind of reference type that implements\r\nReader.\r\n\r\nIn the generic form the `Bytes` iterator is well behaved itself and does not read ahead.\r\nIt performs abysmally on top of a FileStream, and much better if a buffering reader is inserted inbetween.", "tree": {"sha": "714ab799479708bea445685a7f972ad5726151f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/714ab799479708bea445685a7f972ad5726151f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308", "html_url": "https://github.com/rust-lang/rust/commit/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60fba4d7d677ec098e6a43014132fe99f7547363", "url": "https://api.github.com/repos/rust-lang/rust/commits/60fba4d7d677ec098e6a43014132fe99f7547363", "html_url": "https://github.com/rust-lang/rust/commit/60fba4d7d677ec098e6a43014132fe99f7547363"}, {"sha": "913d1b48ad4e2dd909009aab93837cd596a235b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/913d1b48ad4e2dd909009aab93837cd596a235b2", "html_url": "https://github.com/rust-lang/rust/commit/913d1b48ad4e2dd909009aab93837cd596a235b2"}], "stats": {"total": 90, "additions": 89, "deletions": 1}, "files": [{"sha": "15ac6544dee0e9ae18b293b9f0ef73b2c587c01b", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=6c13b0f4f6b6c51c0d83bad3c48d7249a1d15308", "patch": "@@ -15,8 +15,9 @@\n \n use uint;\n use int;\n+use iterator::Iterator;\n use vec;\n-use rt::io::{Reader, Writer};\n+use rt::io::{Reader, Writer, Decorator};\n use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n@@ -62,6 +63,16 @@ pub trait ReaderUtil {\n     /// Raises the same conditions as the `read` method.\n     fn read_to_end(&mut self) -> ~[u8];\n \n+    /// Create an iterator that reads a single byte on\n+    /// each iteration, until EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method, for\n+    /// each call to its `.next()` method.\n+    /// Ends the iteration if the condition is handled.\n+    fn bytes(self) -> ByteIterator<Self>;\n+\n }\n \n pub trait ReaderByteConversions {\n@@ -337,6 +348,41 @@ impl<T: Reader> ReaderUtil for T {\n         }\n         return buf;\n     }\n+\n+    fn bytes(self) -> ByteIterator<T> {\n+        ByteIterator{reader: self}\n+    }\n+}\n+\n+/// An iterator that reads a single byte on each iteration,\n+/// until `.read_byte()` returns `None`.\n+///\n+/// # Notes about the Iteration Protocol\n+///\n+/// The `ByteIterator` may yield `None` and thus terminate\n+/// an iteration, but continue to yield elements if iteration\n+/// is attempted again.\n+///\n+/// # Failure\n+///\n+/// Raises the same conditions as the `read` method, for\n+/// each call to its `.next()` method.\n+/// Yields `None` if the condition is handled.\n+pub struct ByteIterator<T> {\n+    priv reader: T,\n+}\n+\n+impl<R> Decorator<R> for ByteIterator<R> {\n+    fn inner(self) -> R { self.reader }\n+    fn inner_ref<'a>(&'a self) -> &'a R { &self.reader }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.reader }\n+}\n+\n+impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.reader.read_byte()\n+    }\n }\n \n impl<T: Reader> ReaderByteConversions for T {\n@@ -646,6 +692,48 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn bytes_0_bytes() {\n+        let mut reader = MockReader::new();\n+        let count = Cell::new(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    Some(0)\n+                } else {\n+                    buf[0] = 10;\n+                    Some(1)\n+                }\n+            }\n+        };\n+        let byte = reader.bytes().next();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn bytes_eof() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| None;\n+        let byte = reader.bytes().next();\n+        assert!(byte == None);\n+    }\n+\n+    #[test]\n+    fn bytes_error() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| {\n+            read_error::cond.raise(placeholder_error());\n+            None\n+        };\n+        let mut it = reader.bytes();\n+        do read_error::cond.trap(|_| ()).inside {\n+            let byte = it.next();\n+            assert!(byte == None);\n+        }\n+    }\n+\n+\n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);"}]}