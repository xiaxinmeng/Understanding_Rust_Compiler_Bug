{"sha": "efea6f016eacf258e7b6bdaa960a39b3e7f91fa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZWE2ZjAxNmVhY2YyNThlN2I2YmRhYTk2MGEzOWIzZTdmOTFmYTU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-07T17:41:48Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-07T17:41:48Z"}, "message": "Reindent some match exprs to agree with rust-mode.el", "tree": {"sha": "877c65171458941db49cc137ae981927e651b1f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/877c65171458941db49cc137ae981927e651b1f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5", "html_url": "https://github.com/rust-lang/rust/commit/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e656261ee7ff7cfd301c0d7c31cdc969e3bdbfeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e656261ee7ff7cfd301c0d7c31cdc969e3bdbfeb", "html_url": "https://github.com/rust-lang/rust/commit/e656261ee7ff7cfd301c0d7c31cdc969e3bdbfeb"}], "stats": {"total": 134, "additions": 67, "deletions": 67}, "files": [{"sha": "905f1f1013749885bb28bf1b86942c4de7f24096", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efea6f016eacf258e7b6bdaa960a39b3e7f91fa5/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=efea6f016eacf258e7b6bdaa960a39b3e7f91fa5", "patch": "@@ -25,20 +25,20 @@ fn transform_self_type_for_method(fcx: @fn_ctxt,\n                                   method_info: MethodInfo)\n                                -> ty::t {\n     match method_info.self_type {\n-        sty_by_ref | sty_value => {\n-            impl_ty\n-        }\n-        sty_region(r, mutability) => {\n-            // XXX: dummy_sp is unfortunate here.\n-            let region = ast_region_to_region(fcx, fcx, dummy_sp(), r);\n-            mk_rptr(fcx.ccx.tcx, region, { ty: impl_ty, mutbl: mutability })\n-        }\n-        sty_box(mutability) => {\n-            mk_box(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n-        }\n-        sty_uniq(mutability) => {\n-            mk_uniq(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n-        }\n+      sty_by_ref | sty_value => {\n+        impl_ty\n+      }\n+      sty_region(r, mutability) => {\n+        // XXX: dummy_sp is unfortunate here.\n+        let region = ast_region_to_region(fcx, fcx, dummy_sp(), r);\n+        mk_rptr(fcx.ccx.tcx, region, { ty: impl_ty, mutbl: mutability })\n+      }\n+      sty_box(mutability) => {\n+        mk_box(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+      }\n+      sty_uniq(mutability) => {\n+        mk_uniq(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+      }\n     }\n }\n \n@@ -96,21 +96,21 @@ class lookup {\n         match get_base_type_def_id(self.fcx.infcx,\n                                  self.self_expr.span,\n                                  self.self_ty) {\n-            none => {\n-                optional_inherent_methods = none;\n-            }\n-            some(base_type_def_id) => {\n-                debug!{\"(checking method) found base type\"};\n-                optional_inherent_methods =\n-                    self.fcx.ccx.coherence_info.inherent_methods.find\n-                        (base_type_def_id);\n-\n-                if optional_inherent_methods.is_none() {\n-                    debug!{\"(checking method) ... no inherent methods found\"};\n-                } else {\n-                    debug!{\"(checking method) ... inherent methods found\"};\n-                }\n+          none => {\n+            optional_inherent_methods = none;\n+          }\n+          some(base_type_def_id) => {\n+            debug!{\"(checking method) found base type\"};\n+            optional_inherent_methods =\n+                self.fcx.ccx.coherence_info.inherent_methods.find\n+                (base_type_def_id);\n+\n+            if optional_inherent_methods.is_none() {\n+                debug!{\"(checking method) ... no inherent methods found\"};\n+            } else {\n+                debug!{\"(checking method) ... inherent methods found\"};\n             }\n+          }\n         }\n \n         loop {\n@@ -462,52 +462,52 @@ class lookup {\n \n         // Add inherent methods.\n         match optional_inherent_methods {\n-            none => {\n-                // Continue.\n-            }\n-            some(inherent_methods) => {\n-                debug!{\"(adding inherent and extension candidates) adding \\\n-                        inherent candidates\"};\n-                for inherent_methods.each |implementation| {\n-                    debug!{\"(adding inherent and extension candidates) \\\n-                            adding candidates from impl: %s\",\n-                           node_id_to_str(self.tcx().items,\n-                                          implementation.did.node)};\n-                    self.add_candidates_from_impl(implementation,\n-                                                  use_assignability);\n-                }\n+          none => {\n+            // Continue.\n+          }\n+          some(inherent_methods) => {\n+            debug!{\"(adding inherent and extension candidates) adding \\\n+                    inherent candidates\"};\n+            for inherent_methods.each |implementation| {\n+                debug!{\"(adding inherent and extension candidates) \\\n+                        adding candidates from impl: %s\",\n+                        node_id_to_str(self.tcx().items,\n+                                       implementation.did.node)};\n+                self.add_candidates_from_impl(implementation,\n+                                              use_assignability);\n             }\n+          }\n         }\n \n         // Add trait methods.\n         match self.fcx.ccx.trait_map.find(self.expr.id) {\n-            none => {\n-                // Should only happen for placement new right now.\n-            }\n-            some(trait_ids) => {\n-                for (*trait_ids).each |trait_id| {\n-                    debug!{\"(adding inherent and extension candidates) \\\n-                            trying trait: %s\",\n-                           self.def_id_to_str(trait_id)};\n-\n-                    let coherence_info = self.fcx.ccx.coherence_info;\n-                    match coherence_info.extension_methods.find(trait_id) {\n-                        none => {\n-                            // Do nothing.\n-                        }\n-                        some(extension_methods) => {\n-                            for extension_methods.each |implementation| {\n-                                debug!{\"(adding inherent and extension \\\n-                                         candidates) adding impl %s\",\n-                                       self.def_id_to_str\n-                                        (implementation.did)};\n-                                self.add_candidates_from_impl\n-                                    (implementation, use_assignability);\n-                            }\n-                        }\n+          none => {\n+            // Should only happen for placement new right now.\n+          }\n+          some(trait_ids) => {\n+            for (*trait_ids).each |trait_id| {\n+                debug!{\"(adding inherent and extension candidates) \\\n+                        trying trait: %s\",\n+                        self.def_id_to_str(trait_id)};\n+\n+                let coherence_info = self.fcx.ccx.coherence_info;\n+                match coherence_info.extension_methods.find(trait_id) {\n+                  none => {\n+                    // Do nothing.\n+                  }\n+                  some(extension_methods) => {\n+                    for extension_methods.each |implementation| {\n+                        debug!{\"(adding inherent and extension \\\n+                                candidates) adding impl %s\",\n+                                self.def_id_to_str\n+                                (implementation.did)};\n+                        self.add_candidates_from_impl\n+                            (implementation, use_assignability);\n                     }\n+                  }\n                 }\n             }\n+          }\n         }\n     }\n \n@@ -531,7 +531,7 @@ class lookup {\n         // required receiver type (cand.rcvr_ty).  If this method is not\n         // from an impl, this'll basically be a no-nop.\n         match self.fcx.mk_assignty(self.self_expr, self.borrow_lb,\n-                                 cand.self_ty, cand.rcvr_ty) {\n+                                   cand.self_ty, cand.rcvr_ty) {\n           result::ok(_) => (),\n           result::err(_) => {\n             self.tcx().sess.span_bug("}]}