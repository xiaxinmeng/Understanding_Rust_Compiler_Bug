{"sha": "703c82e5319c15929df38bb8611755b3eda5bd8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwM2M4MmU1MzE5YzE1OTI5ZGYzOGJiODYxMTc1NWIzZWRhNWJkOGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T16:14:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T16:14:47Z"}, "message": "Auto merge of #62359 - euclio:remove-serialize, r=Dylan-DPC\n\nreplace serialize with serde in rustdoc\n\nThis is a slightly less aggressive version of #61028.\n\nr? @GuillaumeGomez", "tree": {"sha": "365cbfe1b2b88c7c1dc9bdc27026a6744bd28ced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/365cbfe1b2b88c7c1dc9bdc27026a6744bd28ced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/703c82e5319c15929df38bb8611755b3eda5bd8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/703c82e5319c15929df38bb8611755b3eda5bd8e", "html_url": "https://github.com/rust-lang/rust/commit/703c82e5319c15929df38bb8611755b3eda5bd8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/703c82e5319c15929df38bb8611755b3eda5bd8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3964a55ba59bb6c3d4badcbddc49f6929ef76862", "url": "https://api.github.com/repos/rust-lang/rust/commits/3964a55ba59bb6c3d4badcbddc49f6929ef76862", "html_url": "https://github.com/rust-lang/rust/commit/3964a55ba59bb6c3d4badcbddc49f6929ef76862"}, {"sha": "94630d4c8bbf4c7c7e680210cd5d5f848c53aeaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/94630d4c8bbf4c7c7e680210cd5d5f848c53aeaa", "html_url": "https://github.com/rust-lang/rust/commit/94630d4c8bbf4c7c7e680210cd5d5f848c53aeaa"}], "stats": {"total": 194, "additions": 125, "deletions": 69}, "files": [{"sha": "1af0442dde7fc85fdd9d432a3f0df77d51791afd", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -3946,6 +3946,8 @@ dependencies = [\n  \"minifier\",\n  \"pulldown-cmark 0.5.3\",\n  \"rustc-rayon\",\n+ \"serde\",\n+ \"serde_json\",\n  \"tempfile\",\n ]\n "}, {"sha": "f2822916d3cdfc3530de0cf469b8ea08fce1fcc2", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -12,4 +12,6 @@ path = \"lib.rs\"\n pulldown-cmark = { version = \"0.5.3\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\"\n tempfile = \"3\""}, {"sha": "85f132378b1ddfe171545abcea78defac828502e", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -1,7 +1,11 @@\n //! Item types.\n \n use std::fmt;\n+\n+use serde::{Serialize, Serializer};\n+\n use syntax_pos::hygiene::MacroKind;\n+\n use crate::clean;\n \n /// Item type. Corresponds to `clean::ItemEnum` variants.\n@@ -45,6 +49,14 @@ pub enum ItemType {\n     TraitAlias      = 25,\n }\n \n+impl Serialize for ItemType {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (*self as u8).serialize(serializer)\n+    }\n+}\n \n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {"}, {"sha": "e764b7ee5276b9546e0239273c29904c314b783b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -31,7 +31,8 @@ use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n use std::error;\n-use std::fmt::{self, Formatter, Write as FmtWrite};\n+\n+use std::fmt::{self, Formatter, Write};\n use std::ffi::OsStr;\n use std::fs::{self, File};\n use std::io::prelude::*;\n@@ -42,7 +43,8 @@ use std::sync::Arc;\n use std::rc::Rc;\n \n use errors;\n-use serialize::json::{ToJson, Json, as_json};\n+use serde::{Serialize, Serializer};\n+use serde::ser::SerializeSeq;\n use syntax::ast;\n use syntax::edition::Edition;\n use syntax::print::pprust;\n@@ -303,19 +305,22 @@ struct IndexItem {\n     search_type: Option<IndexItemFunctionType>,\n }\n \n-impl ToJson for IndexItem {\n-    fn to_json(&self) -> Json {\n+impl Serialize for IndexItem {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n         assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n \n-        let mut data = Vec::with_capacity(6);\n-        data.push((self.ty as usize).to_json());\n-        data.push(self.name.to_json());\n-        data.push(self.path.to_json());\n-        data.push(self.desc.to_json());\n-        data.push(self.parent_idx.to_json());\n-        data.push(self.search_type.to_json());\n-\n-        Json::Array(data)\n+        (\n+            self.ty,\n+            &self.name,\n+            &self.path,\n+            &self.desc,\n+            self.parent_idx,\n+            &self.search_type,\n+        )\n+            .serialize(serializer)\n     }\n }\n \n@@ -326,18 +331,20 @@ struct Type {\n     generics: Option<Vec<String>>,\n }\n \n-impl ToJson for Type {\n-    fn to_json(&self) -> Json {\n-        match self.name {\n-            Some(ref name) => {\n-                let mut data = Vec::with_capacity(2);\n-                data.push(name.to_json());\n-                if let Some(ref generics) = self.generics {\n-                    data.push(generics.to_json());\n-                }\n-                Json::Array(data)\n+impl Serialize for Type {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        if let Some(name) = &self.name {\n+            let mut seq = serializer.serialize_seq(None)?;\n+            seq.serialize_element(&name)?;\n+            if let Some(generics) = &self.generics {\n+                seq.serialize_element(&generics)?;\n             }\n-            None => Json::Null,\n+            seq.end()\n+        } else {\n+            serializer.serialize_none()\n         }\n     }\n }\n@@ -349,26 +356,29 @@ struct IndexItemFunctionType {\n     output: Option<Vec<Type>>,\n }\n \n-impl ToJson for IndexItemFunctionType {\n-    fn to_json(&self) -> Json {\n+impl Serialize for IndexItemFunctionType {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n         // If we couldn't figure out a type, just write `null`.\n         let mut iter = self.inputs.iter();\n         if match self.output {\n             Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n             None => iter.any(|ref i| i.name.is_none()),\n         } {\n-            Json::Null\n+            serializer.serialize_none()\n         } else {\n-            let mut data = Vec::with_capacity(2);\n-            data.push(self.inputs.to_json());\n-            if let Some(ref output) = self.output {\n+            let mut seq = serializer.serialize_seq(None)?;\n+            seq.serialize_element(&self.inputs)?;\n+            if let Some(output) = &self.output {\n                 if output.len() > 1 {\n-                    data.push(output.to_json());\n+                    seq.serialize_element(&output)?;\n                 } else {\n-                    data.push(output[0].to_json());\n+                    seq.serialize_element(&output[0])?;\n                 }\n             }\n-            Json::Array(data)\n+            seq.end()\n         }\n     }\n }\n@@ -596,7 +606,7 @@ fn write_shared(\n     // To avoid theme switch latencies as much as possible, we put everything theme related\n     // at the beginning of the html files into another js file.\n     let theme_js = format!(\n-r#\"var themes = document.getElementById(\"theme-choices\");\n+        r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n function showThemeButtonState() {{\n@@ -642,8 +652,8 @@ themePicker.onblur = handleThemeButtonsBlur;\n     }};\n     but.onblur = handleThemeButtonsBlur;\n     themes.appendChild(but);\n-}});\"#,\n-                 as_json(&themes));\n+}});\"#, serde_json::to_string(&themes).unwrap());\n+\n     write_minify(&cx.shared.fs, cx.path(\"theme.js\"),\n                  &theme_js,\n                  options.enable_minification)?;\n@@ -932,32 +942,48 @@ themePicker.onblur = handleThemeButtonsBlur;\n             }\n         };\n \n-        let mut have_impls = false;\n-        let mut implementors = format!(r#\"implementors[\"{}\"] = [\"#, krate.name);\n-        for imp in imps {\n-            // If the trait and implementation are in the same crate, then\n-            // there's no need to emit information about it (there's inlining\n-            // going on). If they're in different crates then the crate defining\n-            // the trait will be interested in our implementation.\n-            if imp.impl_item.def_id.krate == did.krate { continue }\n-            // If the implementation is from another crate then that crate\n-            // should add it.\n-            if !imp.impl_item.def_id.is_local() { continue }\n-            have_impls = true;\n-            write!(implementors, \"{{text:{},synthetic:{},types:{}}},\",\n-                   as_json(&imp.inner_impl().print().to_string()),\n-                   imp.inner_impl().synthetic,\n-                   as_json(&collect_paths_for_type(imp.inner_impl().for_.clone()))).unwrap();\n+        #[derive(Serialize)]\n+        struct Implementor {\n+            text: String,\n+            synthetic: bool,\n+            types: Vec<String>,\n         }\n-        implementors.push_str(\"];\");\n+\n+        let implementors = imps\n+            .iter()\n+            .filter_map(|imp| {\n+                // If the trait and implementation are in the same crate, then\n+                // there's no need to emit information about it (there's inlining\n+                // going on). If they're in different crates then the crate defining\n+                // the trait will be interested in our implementation.\n+                //\n+                // If the implementation is from another crate then that crate\n+                // should add it.\n+                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n+                    None\n+                } else {\n+                    Some(Implementor {\n+                        text: imp.inner_impl().print().to_string(),\n+                        synthetic: imp.inner_impl().synthetic,\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone()),\n+                    })\n+                }\n+            })\n+            .collect::<Vec<_>>();\n \n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if !have_impls && !cx.cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n             continue;\n         }\n \n+        let implementors = format!(\n+            r#\"implementors[\"{}\"] = {};\"#,\n+            krate.name,\n+            serde_json::to_string(&implementors).unwrap()\n+        );\n+\n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n@@ -1456,7 +1482,7 @@ impl Context {\n             if !self.render_redirect_pages {\n                 let items = self.build_sidebar_items(&m);\n                 let js_dst = self.dst.join(\"sidebar-items.js\");\n-                let v = format!(\"initSidebarItems({});\", as_json(&items));\n+                let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n                 scx.fs.write(&js_dst, &v)?;\n             }\n \n@@ -2558,8 +2584,11 @@ fn item_trait(\n             write_loading_content(w, \"</div>\");\n         }\n     }\n-    write!(w, r#\"<script type=\"text/javascript\">window.inlined_types=new Set({});</script>\"#,\n-           as_json(&synthetic_types));\n+    write!(\n+        w,\n+        r#\"<script type=\"text/javascript\">window.inlined_types=new Set({});</script>\"#,\n+        serde_json::to_string(&synthetic_types).unwrap(),\n+    );\n \n     write!(w, r#\"<script type=\"text/javascript\" async\n                          src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">"}, {"sha": "d80facf4704a4be2a6f9eda375f96e1926e697bc", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -8,7 +8,8 @@ use std::path::{Path, PathBuf};\n use std::collections::BTreeMap;\n use syntax::source_map::FileName;\n use syntax::symbol::sym;\n-use serialize::json::{ToJson, Json, as_json};\n+\n+use serde::Serialize;\n \n use super::{ItemType, IndexItem, IndexItemFunctionType, Impl, shorten, plain_summary_line};\n use super::{Type, RenderInfo};\n@@ -544,7 +545,7 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut nodeid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n-    let mut crate_paths = Vec::<Json>::new();\n+    let mut crate_paths = vec![];\n \n     let Cache { ref mut search_index,\n                 ref orphan_impl_items,\n@@ -581,7 +582,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 lastpathid += 1;\n \n                 let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n-                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                crate_paths.push((short, fqp.last().unwrap().clone()));\n                 pathid\n             }\n         });\n@@ -592,22 +593,33 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n         } else {\n             lastpath = item.path.clone();\n         }\n-        crate_items.push(item.to_json());\n+        crate_items.push(&*item);\n     }\n \n     let crate_doc = krate.module.as_ref().map(|module| {\n         shorten(plain_summary_line(module.doc_value()))\n     }).unwrap_or(String::new());\n \n-    let mut crate_data = BTreeMap::new();\n-    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n-    crate_data.insert(\"i\".to_owned(), Json::Array(crate_items));\n-    crate_data.insert(\"p\".to_owned(), Json::Array(crate_paths));\n+    #[derive(Serialize)]\n+    struct CrateData<'a> {\n+        doc: String,\n+        #[serde(rename = \"i\")]\n+        items: Vec<&'a IndexItem>,\n+        #[serde(rename = \"p\")]\n+        paths: Vec<(ItemType, String)>,\n+    }\n \n     // Collect the index into a string\n-    format!(\"searchIndex[{}] = {};\",\n-            as_json(&krate.name),\n-            Json::Object(crate_data))\n+    format!(\n+        r#\"searchIndex[\"{}\"] = {};\"#,\n+        krate.name,\n+        serde_json::to_string(&CrateData {\n+            doc: crate_doc,\n+            items: crate_items,\n+            paths: crate_paths,\n+        })\n+        .unwrap()\n+    )\n }\n \n fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {"}, {"sha": "a7ef428bc851339cc5cc40e686f6d201583eaaaa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703c82e5319c15929df38bb8611755b3eda5bd8e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=703c82e5319c15929df38bb8611755b3eda5bd8e", "patch": "@@ -35,7 +35,6 @@ extern crate rustc_parse;\n extern crate rustc_target;\n extern crate rustc_typeck;\n extern crate rustc_lexer;\n-extern crate serialize;\n extern crate syntax;\n extern crate syntax_expand;\n extern crate syntax_pos;"}]}