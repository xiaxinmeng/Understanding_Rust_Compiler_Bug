{"sha": "5f295f22a752f42de421e2d5e1545908f15df9d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMjk1ZjIyYTc1MmY0MmRlNDIxZTJkNWUxNTQ1OTA4ZjE1ZGY5ZDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-20T21:03:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-20T21:03:47Z"}, "message": "rustc: Fix again order-dependence in extern crate\n\nOriginally fixed in #29961 the bug was unfortunately still present in the face\nof crates using `#[macro_use]`. This commit refactors for the two code paths to\nshare common logic to ensure that they both pick up the same bug fix.\n\nCloses #33762", "tree": {"sha": "7de671e6a3e40917b67da6eb76aa16f3e57be599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7de671e6a3e40917b67da6eb76aa16f3e57be599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f295f22a752f42de421e2d5e1545908f15df9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f295f22a752f42de421e2d5e1545908f15df9d9", "html_url": "https://github.com/rust-lang/rust/commit/5f295f22a752f42de421e2d5e1545908f15df9d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f295f22a752f42de421e2d5e1545908f15df9d9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4e4ec7e6dedf61b86ae321cb93457d09a81c9fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e4ec7e6dedf61b86ae321cb93457d09a81c9fe", "html_url": "https://github.com/rust-lang/rust/commit/f4e4ec7e6dedf61b86ae321cb93457d09a81c9fe"}], "stats": {"total": 192, "additions": 143, "deletions": 49}, "files": [{"sha": "af4a92221941c9334f9bd8706cf6c9ac36545fdf", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5f295f22a752f42de421e2d5e1545908f15df9d9", "patch": "@@ -143,6 +143,11 @@ impl PMDSource {\n     }\n }\n \n+enum LoadResult {\n+    Previous(ast::CrateNum),\n+    Loaded(loader::Library),\n+}\n+\n impl<'a> CrateReader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n@@ -358,12 +363,8 @@ impl<'a> CrateReader<'a> {\n                      kind: PathKind,\n                      explicitly_linked: bool)\n                      -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n-        enum LookupResult {\n-            Previous(ast::CrateNum),\n-            Loaded(loader::Library),\n-        }\n         let result = match self.existing_match(name, hash, kind) {\n-            Some(cnum) => LookupResult::Previous(cnum),\n+            Some(cnum) => LoadResult::Previous(cnum),\n             None => {\n                 let mut load_ctxt = loader::Context {\n                     sess: self.sess,\n@@ -380,40 +381,59 @@ impl<'a> CrateReader<'a> {\n                     rejected_via_kind: vec!(),\n                     should_match_name: true,\n                 };\n-                let library = load_ctxt.load_library_crate();\n-\n-                // In the case that we're loading a crate, but not matching\n-                // against a hash, we could load a crate which has the same hash\n-                // as an already loaded crate. If this is the case prevent\n-                // duplicates by just using the first crate.\n-                let meta_hash = decoder::get_crate_hash(library.metadata\n-                                                               .as_slice());\n-                let mut result = LookupResult::Loaded(library);\n-                self.cstore.iter_crate_data(|cnum, data| {\n-                    if data.name() == name && meta_hash == data.hash() {\n-                        assert!(hash.is_none());\n-                        result = LookupResult::Previous(cnum);\n-                    }\n-                });\n-                result\n+                match self.load(&mut load_ctxt) {\n+                    Some(result) => result,\n+                    None => load_ctxt.report_load_errs(),\n+                }\n             }\n         };\n \n         match result {\n-            LookupResult::Previous(cnum) => {\n+            LoadResult::Previous(cnum) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if explicitly_linked && !data.explicitly_linked.get() {\n                     data.explicitly_linked.set(explicitly_linked);\n                 }\n                 (cnum, data, self.cstore.used_crate_source(cnum))\n             }\n-            LookupResult::Loaded(library) => {\n+            LoadResult::Loaded(library) => {\n                 self.register_crate(root, ident, name, span, library,\n                                     explicitly_linked)\n             }\n         }\n     }\n \n+    fn load(&mut self, loader: &mut loader::Context) -> Option<LoadResult> {\n+        let library = match loader.maybe_load_library_crate() {\n+            Some(lib) => lib,\n+            None => return None,\n+        };\n+\n+        // In the case that we're loading a crate, but not matching\n+        // against a hash, we could load a crate which has the same hash\n+        // as an already loaded crate. If this is the case prevent\n+        // duplicates by just using the first crate.\n+        //\n+        // Note that we only do this for target triple crates, though, as we\n+        // don't want to match a host crate against an equivalent target one\n+        // already loaded.\n+        if loader.triple == self.sess.opts.target_triple {\n+            let meta_hash = decoder::get_crate_hash(library.metadata.as_slice());\n+            let meta_name = decoder::get_crate_name(library.metadata.as_slice())\n+                                    .to_string();\n+            let mut result = LoadResult::Loaded(library);\n+            self.cstore.iter_crate_data(|cnum, data| {\n+                if data.name() == meta_name && meta_hash == data.hash() {\n+                    assert!(loader.hash.is_none());\n+                    result = LoadResult::Previous(cnum);\n+                }\n+            });\n+            Some(result)\n+        } else {\n+            Some(LoadResult::Loaded(library))\n+        }\n+    }\n+\n     fn update_extern_crate(&mut self,\n                            cnum: ast::CrateNum,\n                            mut extern_crate: ExternCrate)\n@@ -488,35 +508,46 @@ impl<'a> CrateReader<'a> {\n             rejected_via_kind: vec!(),\n             should_match_name: true,\n         };\n-        let library = match load_ctxt.maybe_load_library_crate() {\n-            Some(l) => l,\n-            None if is_cross => {\n-                // Try loading from target crates. This will abort later if we\n-                // try to load a plugin registrar function,\n-                target_only = true;\n-                should_link = info.should_link;\n-\n-                load_ctxt.target = &self.sess.target.target;\n-                load_ctxt.triple = target_triple;\n-                load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n-                load_ctxt.load_library_crate()\n+        let library = self.load(&mut load_ctxt).or_else(|| {\n+            if !is_cross {\n+                return None\n             }\n-            None => { load_ctxt.report_load_errs(); },\n+            // Try loading from target crates. This will abort later if we\n+            // try to load a plugin registrar function,\n+            target_only = true;\n+            should_link = info.should_link;\n+\n+            load_ctxt.target = &self.sess.target.target;\n+            load_ctxt.triple = target_triple;\n+            load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n+\n+            self.load(&mut load_ctxt)\n+        });\n+        let library = match library {\n+            Some(l) => l,\n+            None => load_ctxt.report_load_errs(),\n         };\n \n-        let dylib = library.dylib.clone();\n-        let register = should_link && self.existing_match(&info.name,\n-                                                          None,\n-                                                          PathKind::Crate).is_none();\n-        let metadata = if register {\n-            // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, &info.ident,\n-                                                  &info.name, span, library,\n-                                                  true);\n-            PMDSource::Registered(cmd)\n-        } else {\n-            // Not registering the crate; just hold on to the metadata\n-            PMDSource::Owned(library.metadata)\n+        let (dylib, metadata) = match library {\n+            LoadResult::Previous(cnum) => {\n+                let dylib = self.cstore.opt_used_crate_source(cnum).unwrap().dylib;\n+                let data = self.cstore.get_crate_data(cnum);\n+                (dylib, PMDSource::Registered(data))\n+            }\n+            LoadResult::Loaded(library) => {\n+                let dylib = library.dylib.clone();\n+                let metadata = if should_link {\n+                    // Register crate now to avoid double-reading metadata\n+                    let (_, cmd, _) = self.register_crate(&None, &info.ident,\n+                                                          &info.name, span,\n+                                                          library, true);\n+                    PMDSource::Registered(cmd)\n+                } else {\n+                    // Not registering the crate; just hold on to the metadata\n+                    PMDSource::Owned(library.metadata)\n+                };\n+                (dylib, metadata)\n+            }\n         };\n \n         ExtensionCrate {"}, {"sha": "567d7e78a57a47793c600263e2dd8c5adc1ed488", "filename": "src/test/run-make/extern-multiple-copies2/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2FMakefile?ref=5f295f22a752f42de421e2d5e1545908f15df9d9", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo1.rs\n+\t$(RUSTC) foo2.rs\n+\tmkdir $(TMPDIR)/foo\n+\tcp $(TMPDIR)/libfoo1.rlib $(TMPDIR)/foo/libfoo1.rlib\n+\t$(RUSTC) bar.rs \\\n+\t\t--extern foo1=$(TMPDIR)/foo/libfoo1.rlib \\\n+\t\t--extern foo2=$(TMPDIR)/libfoo2.rlib"}, {"sha": "b8ac34aa53e3099bc0efebcf6f4cb51551166bc2", "filename": "src/test/run-make/extern-multiple-copies2/bar.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Fbar.rs?ref=5f295f22a752f42de421e2d5e1545908f15df9d9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate foo2; // foo2 first to exhibit the bug\n+#[macro_use]\n+extern crate foo1;\n+\n+fn main() {\n+    foo2::foo2(foo1::A);\n+}"}, {"sha": "1787772053ba455f4c035d99d6aec11e3042e79a", "filename": "src/test/run-make/extern-multiple-copies2/foo1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo1.rs?ref=5f295f22a752f42de421e2d5e1545908f15df9d9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+pub struct A;\n+\n+pub fn foo1(a: A) {\n+    drop(a);\n+}"}, {"sha": "bad1030438779165a962beaab1639d7d44fc84b4", "filename": "src/test/run-make/extern-multiple-copies2/foo2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f295f22a752f42de421e2d5e1545908f15df9d9/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-multiple-copies2%2Ffoo2.rs?ref=5f295f22a752f42de421e2d5e1545908f15df9d9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+#[macro_use]\n+extern crate foo1;\n+\n+pub fn foo2(a: foo1::A) {\n+    foo1::foo1(a);\n+}"}]}