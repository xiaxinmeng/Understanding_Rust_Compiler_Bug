{"sha": "f0ef4ef81b26388261ae56fdb019982ed3141668", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZWY0ZWY4MWIyNjM4ODI2MWFlNTZmZGIwMTk5ODJlZDMxNDE2Njg=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-05T23:07:53Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:40Z"}, "message": "You can have any protocol you want, provided it's pingpong.\n\nThis integrates the pipe compiler into the proto syntax extension.", "tree": {"sha": "e9f9f41893e5e1c9eebe59bc624f9c44bf387111", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9f9f41893e5e1c9eebe59bc624f9c44bf387111"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0ef4ef81b26388261ae56fdb019982ed3141668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ef4ef81b26388261ae56fdb019982ed3141668", "html_url": "https://github.com/rust-lang/rust/commit/f0ef4ef81b26388261ae56fdb019982ed3141668", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0ef4ef81b26388261ae56fdb019982ed3141668/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05cdda3a2c147fdc8caef4e6c662f518ec325e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/05cdda3a2c147fdc8caef4e6c662f518ec325e0a", "html_url": "https://github.com/rust-lang/rust/commit/05cdda3a2c147fdc8caef4e6c662f518ec325e0a"}], "stats": {"total": 634, "additions": 627, "deletions": 7}, "files": [{"sha": "5a84d764b9f1f60f1459efef84f10a24b5fb7545", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=f0ef4ef81b26388261ae56fdb019982ed3141668", "patch": "@@ -2,9 +2,16 @@\n import codemap::span;\n import ext::base::ext_ctxt;\n \n+import pipes::pipec::*;\n+\n fn expand_proto(cx: ext_ctxt, span: span, id: ast::ident, tt: ast::token_tree)\n     -> @ast::item\n {\n-    cx.span_unimpl(span,\n-                   \"Protocol compiler\")\n+    let proto = protocol(id);\n+    let ping = proto.add_state(@\"ping\", send);\n+    let pong = proto.add_state(@\"pong\", recv);\n+\n+    ping.add_message(@\"ping\", []/~, pong, ~[]);\n+    pong.add_message(@\"pong\", []/~, ping, ~[]);\n+    proto.compile(cx)\n }\n\\ No newline at end of file"}, {"sha": "b23e707f4eb2cff6e878554bc000d0ab6d5c4c66", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=f0ef4ef81b26388261ae56fdb019982ed3141668", "patch": "@@ -0,0 +1,182 @@\n+// Functions for building ASTs, without having to fuss with spans.\n+//\n+// To start with, it will be use dummy spans, but it might someday do\n+// something smarter.\n+\n+import ast::{ident, node_id};\n+import codemap::span;\n+import ext::base::mk_ctxt;\n+\n+fn ident(s: str) -> ast::ident {\n+    @(copy s)\n+}\n+\n+fn empty_span() -> span {\n+    {lo: 0, hi: 0, expn_info: none}\n+}\n+\n+fn span<T>(+x: T) -> ast::spanned<T> {\n+    {node: x,\n+     span: empty_span()}\n+}\n+\n+fn path(id: ident) -> @ast::path {\n+    @{span: empty_span(),\n+      global: false,\n+      idents: ~[id],\n+      rp: none,\n+      types: ~[]}\n+}\n+\n+impl methods for ident {\n+    fn +(id: ident) -> @ast::path {\n+        path(self) + id\n+    }\n+}\n+\n+impl methods for @ast::path {\n+    fn +(id: ident) -> @ast::path {\n+        @{idents: vec::append_one(self.idents, id)\n+          with *self}\n+    }\n+\n+    fn add_ty(ty: @ast::ty) -> @ast::path {\n+        @{types: vec::append_one(self.types, ty)\n+          with *self}\n+    }\n+\n+    fn add_tys(+tys: ~[@ast::ty]) -> @ast::path {\n+        @{types: vec::append(self.types, tys)\n+          with *self}\n+    }\n+}\n+\n+impl ast_builder for ext_ctxt {\n+    fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n+        -> ast::ty_param\n+    {\n+        {ident: id, id: self.next_id(), bounds: @bounds}\n+    }\n+\n+    fn arg(name: ident, ty: @ast::ty) -> ast::arg {\n+        {mode: ast::infer(self.next_id()),\n+         ty: ty,\n+         ident: name,\n+         // TODO: should this be the same as the infer id?\n+         id: self.next_id()}\n+    }\n+\n+    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg {\n+        {mode: ast::expl(mode),\n+         ty: ty,\n+         ident: name,\n+         id: self.next_id()}\n+    }\n+\n+    fn expr_block(e: @ast::expr) -> ast::blk {\n+        let blk = {view_items: ~[],\n+                   stmts: ~[],\n+                   expr: some(e),\n+                   id: self.next_id(),\n+                   rules: ast::default_blk};\n+\n+        {node: blk,\n+         span: empty_span()}\n+    }\n+\n+    fn fn_decl(+inputs: ~[ast::arg],\n+               output: @ast::ty) -> ast::fn_decl {\n+        {inputs: inputs,\n+         output: output,\n+         purity: ast::impure_fn,\n+         cf: ast::return_val,\n+         // TODO: we'll probably want a variant that does constrained\n+         // types.\n+         constraints: ~[]}\n+    }\n+\n+    fn item(name: ident,\n+            +node: ast::item_) -> @ast::item {\n+        @{ident: name,\n+         attrs: ~[],\n+         id: self.next_id(),\n+         node: node,\n+         vis: ast::public,\n+         span: empty_span()}\n+    }\n+\n+    fn item_fn_poly(name: ident,\n+                    +inputs: ~[ast::arg],\n+                    output: @ast::ty,\n+                    +ty_params: ~[ast::ty_param],\n+                    +body: ast::blk) -> @ast::item {\n+        self.item(name,\n+                  ast::item_fn(self.fn_decl(inputs, output),\n+                               ty_params,\n+                               body))\n+    }\n+\n+    fn item_fn(name: ident,\n+               +inputs: ~[ast::arg],\n+               output: @ast::ty,\n+               +body: ast::blk) -> @ast::item {\n+        self.item_fn_poly(name, inputs, output, ~[], body)\n+    }\n+\n+    fn item_enum_poly(name: ident,\n+                      +variants: ~[ast::variant],\n+                      +ty_params: ~[ast::ty_param]) -> @ast::item {\n+        self.item(name,\n+                  ast::item_enum(variants,\n+                                 ty_params,\n+                                 ast::rp_none))\n+    }\n+\n+    fn item_enum(name: ident,\n+                 +variants: ~[ast::variant]) -> @ast::item {\n+        self.item_enum_poly(name, variants, ~[])\n+    }\n+\n+    fn variant(name: ident,\n+               +tys: ~[@ast::ty]) -> ast::variant {\n+        let args = tys.map(|ty| {ty: ty, id: self.next_id()});\n+\n+        span({name: name,\n+              attrs: ~[],\n+              args: args,\n+              id: self.next_id(),\n+              disr_expr: none,\n+              vis: ast::public})\n+    }\n+\n+    fn item_mod(name: ident,\n+                +items: ~[@ast::item]) -> @ast::item {\n+        self.item(name,\n+                  ast::item_mod({\n+                      view_items: ~[],\n+                      items: items}))\n+    }\n+\n+    fn ty_path(path: @ast::path) -> @ast::ty {\n+        // TODO: make sure the node ids are legal.\n+        @{id: self.next_id(),\n+          node: ast::ty_path(path, self.next_id()),\n+          span: empty_span()}\n+    }\n+\n+    fn item_ty_poly(name: ident,\n+                    ty: @ast::ty,\n+                    +params: ~[ast::ty_param]) -> @ast::item {\n+        self.item(name,\n+                  ast::item_ty(ty, params, ast::rp_none))\n+    }\n+\n+    fn item_ty(name: ident,\n+               ty: @ast::ty) -> @ast::item {\n+        self.item_ty_poly(name, ty, ~[])\n+    }\n+\n+    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty] {\n+        ty_params.map(|p| self.ty_path(path(p.ident)))\n+    }\n+}"}, {"sha": "0ff4ba92b366350a20a0877f451f73c38f32ac81", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f0ef4ef81b26388261ae56fdb019982ed3141668", "patch": "@@ -0,0 +1,392 @@\n+// A protocol compiler for Rust.\n+\n+import to_str::to_str;\n+\n+import dvec::dvec;\n+import dvec::extensions;\n+\n+import ast::ident;\n+import util::interner;\n+import interner::{intern, get};\n+import print::pprust;\n+import pprust::{item_to_str, ty_to_str};\n+import ext::base::{mk_ctxt, ext_ctxt};\n+import parse;\n+import parse::{parse_item_from_source_str};\n+\n+import ast_builder::ast_builder;\n+import ast_builder::methods;\n+import ast_builder::path;\n+\n+enum direction {\n+    send, recv\n+}\n+\n+impl of to_str for direction {\n+    fn to_str() -> str {\n+        alt self {\n+          send { \"send\" }\n+          recv { \"recv\" }\n+        }\n+    }\n+}\n+\n+impl methods for direction {\n+    fn reverse() -> direction {\n+        alt self {\n+          send { recv }\n+          recv { send }\n+        }\n+    }\n+}\n+\n+enum message {\n+    // name, data, current state, next state, next tys\n+    message(ident, ~[@ast::ty], state, state, ~[@ast::ty])\n+}\n+\n+impl methods for message {\n+    fn name() -> ident {\n+        alt self {\n+          message(id, _, _, _, _) {\n+            id\n+          }\n+        }\n+    }\n+\n+    // Return the type parameters actually used by this message\n+    fn get_params() -> ~[ast::ty_param] {\n+        let mut used = ~[];\n+        alt self {\n+          message(_, tys, this, _, next_tys) {\n+            let parms = this.ty_params;\n+            for vec::append(tys, next_tys).each |ty| {\n+                alt ty.node {\n+                  ast::ty_path(path, _) {\n+                    if path.idents.len() == 1 {\n+                        let id = path.idents[0];\n+\n+                        let found = parms.find(|p| id == p.ident);\n+\n+                        alt found {\n+                          some(p) {\n+                            if !used.contains(p) {\n+                                vec::push(used, p);\n+                            }\n+                          }\n+                          none { }\n+                        }\n+                    }\n+                  }\n+                  _ { }\n+                }\n+            }\n+          }\n+        }\n+        used\n+    }\n+\n+    fn gen_send(cx: ext_ctxt) -> @ast::item {\n+        alt self {\n+          message(id, tys, this, next, next_tys) {\n+            let arg_names = tys.mapi(|i, _ty| @(\"x_\" + i.to_str()));\n+\n+            let args = (arg_names, tys).map(|n, t|\n+                                            *n + \": \" + t.to_source());\n+\n+            let args_ast = (arg_names, tys).map(\n+                |n, t| cx.arg_mode(n, t, ast::by_copy)\n+            );\n+\n+            let args_ast = vec::append(\n+                ~[cx.arg_mode(@\"pipe\",\n+                              cx.ty_path(path(this.data_name())\n+                                        .add_tys(cx.ty_vars(this.ty_params))),\n+                              ast::by_copy)],\n+                args_ast);\n+\n+            let args = [#fmt(\"-pipe: %s\", *this.data_name())]/~ + args;\n+\n+            let pat = alt (this.dir, next.dir) {\n+              (send, send) { \"(c, s)\" }\n+              (send, recv) { \"(s, c)\" }\n+              (recv, send) { \"(s, c)\" }\n+              (recv, recv) { \"(c, s)\" }\n+            };\n+\n+            let mut body = #fmt(\"{ let %s = pipes::entangle();\\n\", pat);\n+            body += #fmt(\"let message = %s::%s(%s);\\n\",\n+                         *this.proto.name,\n+                         *self.name(),\n+                         str::connect(vec::append_one(arg_names, @\"s\")\n+                                      .map(|x| *x),\n+                                      \", \"));\n+            body += #fmt(\"pipes::send(pipe, message);\\n\");\n+            body += \"c }\";\n+\n+            let body = cx.parse_expr(body);\n+\n+            cx.item_fn_poly(self.name(),\n+                            args_ast,\n+                            cx.ty_path(path(next.data_name())\n+                                      .add_tys(next_tys)),\n+                            self.get_params(),\n+                            cx.expr_block(body))\n+          }\n+        }\n+    }\n+}\n+\n+enum state {\n+    state_(@{\n+        name: ident,\n+        dir: direction,\n+        ty_params: ~[ast::ty_param],\n+        messages: dvec<message>,\n+        proto: protocol,\n+    }),\n+}\n+\n+impl methods for state {\n+    fn add_message(name: ident, +data: ~[@ast::ty], next: state,\n+                   +next_tys: ~[@ast::ty]) {\n+        assert next_tys.len() == next.ty_params.len();\n+        self.messages.push(message(name, data, self, next, next_tys));\n+    }\n+\n+    fn filename() -> str {\n+        (*self).proto.filename()\n+    }\n+\n+    fn data_name() -> ident {\n+        self.name\n+    }\n+\n+    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n+        cx.ty_path(path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n+    }\n+\n+    fn to_type_decls(cx: ext_ctxt) -> [@ast::item]/~ {\n+        // This compiles into two different type declarations. Say the\n+        // state is called ping. This will generate both `ping` and\n+        // `ping_message`. The first contains data that the user cares\n+        // about. The second is the same thing, but extended with a\n+        // next packet pointer, which is used under the covers.\n+\n+        let name = self.data_name();\n+\n+        let mut items_msg = []/~;\n+\n+        for self.messages.each |m| {\n+            let message(_, tys, this, next, next_tys) = m;\n+\n+            let name = m.name();\n+            let next_name = next.data_name();\n+\n+            let dir = alt this.dir {\n+              send { @\"server\" }\n+              recv { @\"client\" }\n+            };\n+\n+            let v = cx.variant(name,\n+                               vec::append_one(\n+                                   tys,\n+                                   cx.ty_path((dir + next_name)\n+                                              .add_tys(next_tys))));\n+\n+            vec::push(items_msg, v);\n+        }\n+\n+        ~[cx.item_enum_poly(name, items_msg, self.ty_params)]\n+    }\n+\n+    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> [@ast::item]/~ {\n+        let dir = alt dir {\n+          send { (*self).dir }\n+          recv { (*self).dir.reverse() }\n+        };\n+        let mut items = ~[];\n+        for self.messages.each |m| {\n+            if dir == send {\n+                vec::push(items, m.gen_send(cx))\n+            }\n+        }\n+\n+        vec::push(items,\n+                  cx.item_ty_poly(\n+                      self.data_name(),\n+                      cx.ty_path(\n+                          (@\"pipes\" + @(dir.to_str() + \"_packet\"))\n+                          .add_ty(cx.ty_path(\n+                              (self.proto.name + self.data_name())\n+                              .add_tys(cx.ty_vars(self.ty_params))))),\n+                      self.ty_params));\n+        items\n+    }\n+}\n+\n+enum protocol {\n+    protocol_(@{\n+        name: ident,\n+        states: dvec<state>,\n+    }),\n+}\n+\n+fn protocol(name: ident) -> protocol {\n+    protocol_(@{name: name, states: dvec()})\n+}\n+\n+impl methods for protocol {\n+    fn add_state(name: ident, dir: direction) -> state {\n+        self.add_state_poly(name, dir, ~[])\n+    }\n+\n+    fn add_state_poly(name: ident, dir: direction,\n+                      +ty_params: ~[ast::ty_param]) -> state {\n+        let messages = dvec();\n+\n+        let state = state_(@{\n+            name: name,\n+            dir: dir,\n+            ty_params: ty_params,\n+            messages: messages,\n+            proto: self\n+        });\n+\n+        self.states.push(state);\n+        state\n+    }\n+\n+    fn filename() -> str {\n+        \"proto://\" + *self.name\n+    }\n+\n+    fn gen_init(cx: ext_ctxt) -> @ast::item {\n+        let start_state = self.states[0];\n+\n+        let body = alt start_state.dir {\n+          send { cx.parse_expr(\"pipes::entangle()\") }\n+          recv {\n+            cx.parse_expr(\"{ \\\n+                           let (s, c) = pipes::entangle(); \\\n+                           (c, s) \\\n+                           }\")\n+          }\n+        };\n+\n+        parse_item_from_source_str(\n+            self.filename(),\n+            @#fmt(\"fn init%s() -> (client::%s, server::%s)\\\n+                   { %s }\",\n+                  start_state.ty_params.to_source(),\n+                  start_state.to_ty(cx).to_source(),\n+                  start_state.to_ty(cx).to_source(),\n+                  body.to_source()),\n+            cx.cfg(),\n+            []/~,\n+            ast::public,\n+            cx.parse_sess()).get()\n+    }\n+\n+    fn compile(cx: ext_ctxt) -> @ast::item {\n+        let mut items = ~[self.gen_init(cx)];\n+        let mut client_states = ~[];\n+        let mut server_states = ~[];\n+\n+        for self.states.each |s| {\n+            items += s.to_type_decls(cx);\n+\n+            client_states += s.to_endpoint_decls(cx, send);\n+            server_states += s.to_endpoint_decls(cx, recv);\n+        }\n+\n+        vec::push(items,\n+                  cx.item_mod(@\"client\",\n+                              client_states));\n+        vec::push(items,\n+                  cx.item_mod(@\"server\",\n+                              server_states));\n+\n+        cx.item_mod(self.name, items)\n+    }\n+}\n+\n+iface to_source {\n+    // Takes a thing and generates a string containing rust code for it.\n+    fn to_source() -> str;\n+}\n+\n+impl of to_source for @ast::item {\n+    fn to_source() -> str {\n+        item_to_str(self)\n+    }\n+}\n+\n+impl of to_source for [@ast::item]/~ {\n+    fn to_source() -> str {\n+        str::connect(self.map(|i| i.to_source()), \"\\n\\n\")\n+    }\n+}\n+\n+impl of to_source for @ast::ty {\n+    fn to_source() -> str {\n+        ty_to_str(self)\n+    }\n+}\n+\n+impl of to_source for [@ast::ty]/~ {\n+    fn to_source() -> str {\n+        str::connect(self.map(|i| i.to_source()), \", \")\n+    }\n+}\n+\n+impl of to_source for ~[ast::ty_param] {\n+    fn to_source() -> str {\n+        pprust::typarams_to_str(self)\n+    }\n+}\n+\n+impl of to_source for @ast::expr {\n+    fn to_source() -> str {\n+        pprust::expr_to_str(self)\n+    }\n+}\n+\n+impl parse_utils for ext_ctxt {\n+    fn parse_item(s: str) -> @ast::item {\n+        let res = parse::parse_item_from_source_str(\n+            \"***protocol expansion***\",\n+            @(copy s),\n+            self.cfg(),\n+            []/~,\n+            ast::public,\n+            self.parse_sess());\n+        alt res {\n+          some(ast) { ast }\n+          none {\n+            #error(\"Parse error with ```\\n%s\\n```\", s);\n+            fail\n+          }\n+        }\n+    }\n+\n+    fn parse_expr(s: str) -> @ast::expr {\n+        parse::parse_expr_from_source_str(\n+            \"***protocol expansion***\",\n+            @(copy s),\n+            self.cfg(),\n+            self.parse_sess())\n+    }\n+}\n+\n+impl methods<A: copy, B: copy> for ([A]/~, [B]/~) {\n+    fn zip() -> [(A, B)]/~ {\n+        let (a, b) = self;\n+        vec::zip(a, b)\n+    }\n+\n+    fn map<C>(f: fn(A, B) -> C) -> [C]/~ {\n+        let (a, b) = self;\n+        vec::map2(a, b, f)\n+    }\n+}"}, {"sha": "852c815e9fe2190d04d9f76bb83f05da27562677", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=f0ef4ef81b26388261ae56fdb019982ed3141668", "patch": "@@ -79,5 +79,8 @@ mod ext {\n     mod auto_serialize;\n     mod source_util;\n \n-    mod pipes;\n+    mod pipes {\n+        mod pipec;\n+        mod ast_builder;\n+    }\n }"}, {"sha": "479b2059bfe3c031f85336cb1eb043ebd9de31be", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ef4ef81b26388261ae56fdb019982ed3141668/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=f0ef4ef81b26388261ae56fdb019982ed3141668", "patch": "@@ -1,7 +1,7 @@\n-// xfail-test\n-\n // An example to make sure the protocol parsing syntax extension works.\n \n+// xfail-pretty\n+\n proto! pingpong {\n     ping:send {\n         ping -> pong\n@@ -12,6 +12,42 @@ proto! pingpong {\n     }\n }\n \n+mod test {\n+    import pipes::recv;\n+    import pingpong::{ping, pong};\n+\n+    fn client(-chan: pingpong::client::ping) {\n+        import pingpong::client;\n+\n+        let chan = client::ping(chan);\n+        log(error, \"Sent ping\");\n+        let pong(_chan) = option::unwrap(recv(chan));\n+        log(error, \"Received pong\");\n+    }\n+    \n+    fn server(-chan: pingpong::server::ping) {\n+        import pingpong::server;\n+\n+        let ping(chan) = option::unwrap(recv(chan));\n+        log(error, \"Received ping\");\n+        let _chan = server::pong(chan);\n+        log(error, \"Sent pong\");\n+    }\n+}\n+\n fn main() {\n-    // TODO: do something with the protocol\n-}\n\\ No newline at end of file\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+\n+    do task::spawn |move client_| {\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        test::client(option::unwrap(client__));\n+    };\n+    do task::spawn |move server_| {\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        test::server(option::unwrap(server_\u02ca));\n+    };\n+}"}]}