{"sha": "74e80468347471779be6060d8d7d6d04e98e467f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZTgwNDY4MzQ3NDcxNzc5YmU2MDYwZDhkN2Q2ZDA0ZTk4ZTQ2N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T12:49:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T12:49:47Z"}, "message": "Auto merge of #72778 - RalfJung:rollup-f01z68m, r=RalfJung\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #72299 (more `LocalDefId`s)\n - #72368 (Resolve overflow behavior for RangeFrom)\n - #72441 (Fix ICE with explicit late-bound lifetimes)\n - #72499 (Override Box::<[T]>::clone_from)\n - #72521 (Properly handle InlineAsmOperand::SymFn when collecting monomorphized items)\n - #72540 (mir: adjust conditional in recursion limit check)\n - #72563 (multiple Return terminators are possible)\n - #72585 (Only capture tokens for items with outer attributes)\n - #72607 (Eagerly lower asm sub-expressions to HIR even if there is an error)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e7d61a1621efe6cc10255c29a95667a8654f8710", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d61a1621efe6cc10255c29a95667a8654f8710"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74e80468347471779be6060d8d7d6d04e98e467f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74e80468347471779be6060d8d7d6d04e98e467f", "html_url": "https://github.com/rust-lang/rust/commit/74e80468347471779be6060d8d7d6d04e98e467f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74e80468347471779be6060d8d7d6d04e98e467f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "html_url": "https://github.com/rust-lang/rust/commit/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce"}, {"sha": "69310dea89caa9257ca7e1ad78922f0852913725", "url": "https://api.github.com/repos/rust-lang/rust/commits/69310dea89caa9257ca7e1ad78922f0852913725", "html_url": "https://github.com/rust-lang/rust/commit/69310dea89caa9257ca7e1ad78922f0852913725"}], "stats": {"total": 836, "additions": 580, "deletions": 256}, "files": [{"sha": "22c344323a2edd6354b99a61e77fcb1ec3f14953", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1109,6 +1109,14 @@ impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {\n         self.to_vec().into_boxed_slice()\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        if self.len() == other.len() {\n+            self.clone_from_slice(&other);\n+        } else {\n+            *self = other.clone();\n+        }\n+    }\n }\n \n #[stable(feature = \"box_borrow\", since = \"1.1.0\")]"}, {"sha": "5377485da8f3b7def467ee749689494cd6399b72", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -16,3 +16,36 @@ fn unitialized_zero_size_box() {\n         NonNull::<MaybeUninit<String>>::dangling().as_ptr(),\n     );\n }\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct Dummy {\n+    _data: u8,\n+}\n+\n+#[test]\n+fn box_clone_and_clone_from_equivalence() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let clone = control.clone();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        copy.clone_from(&control);\n+        assert_eq!(control, clone);\n+        assert_eq!(control, copy);\n+    }\n+}\n+\n+/// This test might give a false positive in case the box realocates, but the alocator keeps the\n+/// original pointer.\n+///\n+/// On the other hand it won't give a false negative, if it fails than the memory was definitly not\n+/// reused\n+#[test]\n+fn box_clone_from_ptr_stability() {\n+    for size in (0..8).map(|i| 2usize.pow(i)) {\n+        let control = vec![Dummy { _data: 42 }; size].into_boxed_slice();\n+        let mut copy = vec![Dummy { _data: 84 }; size].into_boxed_slice();\n+        let copy_raw = copy.as_ptr() as usize;\n+        copy.clone_from(&control);\n+        assert_eq!(copy.as_ptr() as usize, copy_raw);\n+    }\n+}"}, {"sha": "bd7e6cfa5a750116009b7b407ebfeef82d9f1ecc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -619,15 +619,7 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        // If we would jump over the maximum value, panic immediately.\n-        // This is consistent with behavior before the Step redesign,\n-        // even though it's inconsistent with n `next` calls.\n-        // To get consistent behavior, change it to use `forward` instead.\n-        // This change should go through FCP separately to the redesign, so is for now left as a\n-        // FIXME: make this consistent\n-        let plus_n =\n-            Step::forward_checked(self.start.clone(), n).expect(\"overflow in RangeFrom::nth\");\n-        // The final step should always be debug-checked.\n+        let plus_n = Step::forward(self.start.clone(), n);\n         self.start = Step::forward(plus_n.clone(), 1);\n         Some(plus_n)\n     }"}, {"sha": "d86f39c4550c843fc3aa8f5212ccc5c633710e46", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -151,10 +151,16 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///\n /// The `RangeFrom` `start..` contains all values with `x >= start`.\n ///\n-/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n-/// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. **This\n-/// overflow behavior might change in the future.**\n+/// *Note*: Overflow in the [`Iterator`] implementation (when the contained\n+/// data type reaches its numerical limit) is allowed to panic, wrap, or\n+/// saturate. This behavior is defined by the implementation of the [`Step`]\n+/// trait. For primitive integers, this follows the normal rules, and respects\n+/// the overflow checks profile (panic in debug, wrap in release). Note also\n+/// that overflow happens earlier than you might assume: the overflow happens\n+/// in the call to `next` that yields the maximum value, as the range must be\n+/// set to a state to yield the next value.\n+///\n+/// [`Step`]: crate::iter::Step\n ///\n /// # Examples\n ///"}, {"sha": "b7f2e9a9050df0d0ebb6167cefe5a00cce0f0b1b", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -974,20 +974,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        let asm_arch = if let Some(asm_arch) = self.sess.asm_arch {\n-            asm_arch\n-        } else {\n+        if self.sess.asm_arch.is_none() {\n             struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n-            return hir::ExprKind::Err;\n-        };\n-        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-            match asm_arch {\n-                asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64 => {}\n-                _ => self\n-                    .sess\n-                    .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                    .emit(),\n-            }\n+        }\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n+            && !matches!(\n+                self.sess.asm_arch,\n+                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n+            )\n+        {\n+            self.sess\n+                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                .emit();\n         }\n \n         // Lower operands to HIR, filter_map skips any operands with invalid\n@@ -1001,10 +999,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     Some(match reg {\n                         InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n                             asm::InlineAsmReg::parse(\n-                                asm_arch,\n-                                |feature| {\n-                                    self.sess.target_features.contains(&Symbol::intern(feature))\n-                                },\n+                                sess.asm_arch?,\n+                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n                                 s,\n                             )\n                             .map_err(|e| {\n@@ -1015,7 +1011,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ),\n                         InlineAsmRegOrRegClass::RegClass(s) => {\n                             asm::InlineAsmRegOrRegClass::RegClass(\n-                                asm::InlineAsmRegClass::parse(asm_arch, s)\n+                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n                                     .map_err(|e| {\n                                         let msg = format!(\n                                             \"invalid register class `{}`: {}\",\n@@ -1029,33 +1025,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n                     })\n                 };\n-                let op = match op {\n-                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n-                        reg: lower_reg(*reg)?,\n+\n+                // lower_reg is executed last because we need to lower all\n+                // sub-expressions even if we throw them away later.\n+                let op = match *op {\n+                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n                         expr: self.lower_expr_mut(expr),\n+                        reg: lower_reg(reg)?,\n                     },\n-                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n-                        reg: lower_reg(*reg)?,\n-                        late: *late,\n+                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        reg: lower_reg(reg)?,\n                     },\n-                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n-                        reg: lower_reg(*reg)?,\n-                        late: *late,\n-                        expr: self.lower_expr_mut(expr),\n-                    },\n-                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                        hir::InlineAsmOperand::InOut {\n+                            late,\n+                            expr: self.lower_expr_mut(expr),\n+                            reg: lower_reg(reg)?,\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n-                            reg: lower_reg(*reg)?,\n-                            late: *late,\n+                            late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                            reg: lower_reg(reg)?,\n                         }\n                     }\n-                    InlineAsmOperand::Const { expr } => {\n+                    InlineAsmOperand::Const { ref expr } => {\n                         hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n                     }\n-                    InlineAsmOperand::Sym { expr } => {\n+                    InlineAsmOperand::Sym { ref expr } => {\n                         hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n                     }\n                 };\n@@ -1069,6 +1070,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n \n         // Validate template modifiers against the register classes for the operands\n+        let asm_arch = sess.asm_arch.unwrap();\n         for p in &asm.template {\n             if let InlineAsmTemplatePiece::Placeholder {\n                 operand_idx,"}, {"sha": "2a6d1abba9e9dc3f588be30b7c0d2e1681b41031", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -908,13 +908,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(&value.literal);\n                     if let ty::FnDef(def_id, substs) = literal.ty.kind {\n-                        let instance = ty::Instance::resolve(\n+                        let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),\n                             ty::ParamEnv::reveal_all(),\n                             def_id,\n                             substs,\n                         )\n-                        .unwrap()\n                         .unwrap();\n                         InlineAsmOperandRef::SymFn { instance }\n                     } else {"}, {"sha": "223ba4000298614bf3bb6498f3a2531d7dcc22f6", "filename": "src/librustc_error_codes/error_codes/E0055.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -6,7 +6,7 @@ recursion limit (which can be set via the `recursion_limit` attribute).\n For a somewhat artificial example:\n \n ```compile_fail,E0055\n-#![recursion_limit=\"5\"]\n+#![recursion_limit=\"4\"]\n \n struct Foo;\n "}, {"sha": "eeb30e2ced99b641d4c4e4a51cf473a4ffcae91a", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::{parse::ParseSess, Limit};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n@@ -941,7 +941,7 @@ pub struct ExpansionData {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n-    pub reduced_recursion_limit: Option<usize>,\n+    pub reduced_recursion_limit: Option<Limit>,\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,"}, {"sha": "09ba64204c5c37f5c1c15b9caa727c63ba331196", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -24,6 +24,7 @@ use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::Limit;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileName, Span, DUMMY_SP};\n@@ -664,7 +665,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     ) -> ExpandResult<AstFragment, Invocation> {\n         let recursion_limit =\n             self.cx.reduced_recursion_limit.unwrap_or(self.cx.ecfg.recursion_limit);\n-        if self.cx.current_expansion.depth > recursion_limit {\n+        if !recursion_limit.value_within_limit(self.cx.current_expansion.depth) {\n             if self.cx.reduced_recursion_limit.is_none() {\n                 self.error_recursion_limit_reached();\n             }\n@@ -1784,7 +1785,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,\n-    pub recursion_limit: usize,\n+    pub recursion_limit: Limit,\n     pub trace_mac: bool,\n     pub should_test: bool, // If false, strip `#[test]` nodes\n     pub keep_macs: bool,\n@@ -1795,7 +1796,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         ExpansionConfig {\n             crate_name,\n             features: None,\n-            recursion_limit: 1024,\n+            recursion_limit: Limit::new(1024),\n             trace_mac: false,\n             should_test: false,\n             keep_macs: false,"}, {"sha": "c06fd91133b5cfe7edcf09ed24a6b7626592943b", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -838,7 +838,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id.to_def_id())\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n         }\n     });\n "}, {"sha": "85198482bd380a4b32c49aabb7d2ea1711e9b5eb", "filename": "src/librustc_middle/middle/limits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -8,7 +8,7 @@\n use crate::bug;\n use rustc_ast::ast;\n use rustc_data_structures::sync::OnceCell;\n-use rustc_session::Session;\n+use rustc_session::{Limit, Session};\n use rustc_span::symbol::{sym, Symbol};\n \n use std::num::IntErrorKind;\n@@ -22,7 +22,7 @@ pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n fn update_limit(\n     sess: &Session,\n     krate: &ast::Crate,\n-    limit: &OnceCell<usize>,\n+    limit: &OnceCell<Limit>,\n     name: Symbol,\n     default: usize,\n ) {\n@@ -34,7 +34,7 @@ fn update_limit(\n         if let Some(s) = attr.value_str() {\n             match s.as_str().parse() {\n                 Ok(n) => {\n-                    limit.set(n).unwrap();\n+                    limit.set(Limit::new(n)).unwrap();\n                     return;\n                 }\n                 Err(e) => {\n@@ -62,5 +62,5 @@ fn update_limit(\n             }\n         }\n     }\n-    limit.set(default).unwrap();\n+    limit.set(Limit::new(default)).unwrap();\n }"}, {"sha": "0e9c133e2c3226eb684762d48bc4e3afed2cc280", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1072,7 +1072,8 @@ pub enum TerminatorKind<'tcx> {\n     Abort,\n \n     /// Indicates a normal return. The return place should have\n-    /// been filled in by now. This should occur at most once.\n+    /// been filled in before this executes. This can occur multiple times\n+    /// in different basic blocks.\n     Return,\n \n     /// Indicates a terminator that can never be reached."}, {"sha": "59b6f5e529baabc9da003a51af33b587173b9604", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -386,8 +386,14 @@ rustc_queries! {\n             storage(ArenaCacheSelector<'tcx>)\n         }\n \n-        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-        query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n+        ///\n+        /// Unsafety checking is executed for each method separately, but we only want\n+        /// to emit this error once per derive. As there are some impls with multiple\n+        /// methods, we use a query for deduplication.\n+        query unsafe_derive_on_repr_packed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n \n         /// The signature of functions and closures.\n         query fn_sig(_: DefId) -> ty::PolyFnSig<'tcx> {}"}, {"sha": "e93abd3390a2db9518735af52e774a4f6f9e9a22", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -187,10 +187,9 @@ fn layout_raw<'tcx>(\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n-        let rec_limit = tcx.sess.recursion_limit.get().copied().unwrap();\n         let (param_env, ty) = query.into_parts();\n \n-        if icx.layout_depth > rec_limit {\n+        if !tcx.sess.recursion_limit().value_within_limit(icx.layout_depth) {\n             tcx.sess.fatal(&format!(\"overflow representing the type `{}`\", ty));\n         }\n "}, {"sha": "dc13126df0e4cdd5b006c0601be2db3d5551eff0", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -10,6 +10,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_ast::ast::Mutability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n+use rustc_session::Limit;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n@@ -109,8 +110,8 @@ pub struct MemoryExtra {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(super) fn new(const_eval_limit: usize) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit, stack: Vec::new() }\n+    pub(super) fn new(const_eval_limit: Limit) -> Self {\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit.0, stack: Vec::new() }\n     }\n }\n "}, {"sha": "6497e211de316156554d9939206c7813be689315", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -651,7 +651,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n-        if self.stack().len() > self.tcx.sess.recursion_limit() {\n+        if !self.tcx.sess.recursion_limit().value_within_limit(self.stack().len()) {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())"}, {"sha": "6c96b9a66ad854e6ea12496ee8b12758c7ce485a", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -430,7 +430,7 @@ fn check_recursion_limit<'tcx>(\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if adjusted_recursion_depth > tcx.sess.recursion_limit() {\n+    if !tcx.sess.recursion_limit().value_within_limit(adjusted_recursion_depth) {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n         if let Some(def_id) = def_id.as_local() {\n             let hir_id = tcx.hir().as_local_hir_id(def_id);\n@@ -463,7 +463,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     // which means that rustc basically hangs.\n     //\n     // Bail out in these cases to avoid that bad user experience.\n-    if type_length > tcx.sess.type_length_limit() {\n+    if !tcx.sess.type_length_limit().value_within_limit(type_length) {\n         // The instance name is already known to be too long for rustc.\n         // Show only the first and last 32 characters to avoid blasting\n         // the user's terminal with thousands of lines of type-name.\n@@ -632,14 +632,21 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let ty = self.monomorphize(ty);\n                 visit_drop_use(self.tcx, ty, true, self.output);\n             }\n+            mir::TerminatorKind::InlineAsm { ref operands, .. } => {\n+                for op in operands {\n+                    if let mir::InlineAsmOperand::SymFn { value } = op {\n+                        let fn_ty = self.monomorphize(value.literal.ty);\n+                        visit_fn_use(self.tcx, fn_ty, false, &mut self.output);\n+                    }\n+                }\n+            }\n             mir::TerminatorKind::Goto { .. }\n             | mir::TerminatorKind::SwitchInt { .. }\n             | mir::TerminatorKind::Resume\n             | mir::TerminatorKind::Abort\n             | mir::TerminatorKind::Return\n             | mir::TerminatorKind::Unreachable\n-            | mir::TerminatorKind::Assert { .. }\n-            | mir::TerminatorKind::InlineAsm { .. } => {}\n+            | mir::TerminatorKind::Assert { .. } => {}\n             mir::TerminatorKind::GeneratorDrop\n             | mir::TerminatorKind::Yield { .. }\n             | mir::TerminatorKind::FalseEdges { .. }"}, {"sha": "e32bccc85ee6ffc6b8442adccb6e05242dfc51e6", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -579,8 +579,8 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: LocalDefId) -> UnsafetyCheckRe\n     }\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its\n@@ -659,16 +659,15 @@ fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     }\n }\n \n-pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn.\n-    if tcx.is_closure(def_id) {\n+    if tcx.is_closure(def_id.to_def_id()) {\n         return;\n     }\n \n-    let UnsafetyCheckResult { violations, unsafe_blocks } =\n-        tcx.unsafety_check_result(def_id.expect_local());\n+    let UnsafetyCheckResult { violations, unsafe_blocks } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation { source_info, lint_root, description, details, kind } in\n         violations.iter()\n@@ -693,8 +692,10 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                 .emit();\n             }\n             UnsafetyViolationKind::BorrowPacked => {\n-                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n-                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id);\n+                if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id.to_def_id()) {\n+                    // If a method is defined in the local crate,\n+                    // the impl containing that method should also be.\n+                    tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n                 } else {\n                     tcx.struct_span_lint_hir(\n                         SAFE_PACKED_BORROWS,"}, {"sha": "6f13d7994d17d257ec0fecb132f5d8baad5253cd", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -106,11 +106,20 @@ impl<'a> Parser<'a> {\n         });\n \n         let mut unclosed_delims = vec![];\n-        let (mut item, tokens) = self.collect_tokens(|this| {\n+        let has_attrs = !attrs.is_empty();\n+        let parse_item = |this: &mut Self| {\n             let item = this.parse_item_common_(attrs, mac_allowed, attrs_allowed, req_name);\n             unclosed_delims.append(&mut this.unclosed_delims);\n             item\n-        })?;\n+        };\n+\n+        let (mut item, tokens) = if has_attrs {\n+            let (item, tokens) = self.collect_tokens(parse_item)?;\n+            (item, Some(tokens))\n+        } else {\n+            (parse_item(self)?, None)\n+        };\n+\n         self.unclosed_delims.append(&mut unclosed_delims);\n \n         // Once we've parsed an item and recorded the tokens we got while\n@@ -127,9 +136,11 @@ impl<'a> Parser<'a> {\n         // it (bad!). To work around this case for now we just avoid recording\n         // `tokens` if we detect any inner attributes. This should help keep\n         // expansion correct, but we should fix this bug one day!\n-        if let Some(item) = &mut item {\n-            if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-                item.tokens = Some(tokens);\n+        if let Some(tokens) = tokens {\n+            if let Some(item) = &mut item {\n+                if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    item.tokens = Some(tokens);\n+                }\n             }\n         }\n         Ok(item)"}, {"sha": "a943cf3b6749744ad8a659ec28f13b2a02b81fc2", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -29,8 +29,10 @@ use rustc_target::spec::{Target, TargetTriple, TlsModel};\n \n use std::cell::{self, RefCell};\n use std::env;\n+use std::fmt;\n use std::io::Write;\n use std::num::NonZeroU32;\n+use std::ops::{Div, Mul};\n use std::path::PathBuf;\n use std::str::FromStr;\n use std::sync::Arc;\n@@ -55,6 +57,46 @@ pub enum CtfeBacktrace {\n     Immediate,\n }\n \n+/// New-type wrapper around `usize` for representing limits. Ensures that comparisons against\n+/// limits are consistent throughout the compiler.\n+#[derive(Clone, Copy, Debug)]\n+pub struct Limit(pub usize);\n+\n+impl Limit {\n+    /// Create a new limit from a `usize`.\n+    pub fn new(value: usize) -> Self {\n+        Limit(value)\n+    }\n+\n+    /// Check that `value` is within the limit. Ensures that the same comparisons are used\n+    /// throughout the compiler, as mismatches can cause ICEs, see #72540.\n+    pub fn value_within_limit(&self, value: usize) -> bool {\n+        value <= self.0\n+    }\n+}\n+\n+impl fmt::Display for Limit {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+impl Div<usize> for Limit {\n+    type Output = Limit;\n+\n+    fn div(self, rhs: usize) -> Self::Output {\n+        Limit::new(self.0 / rhs)\n+    }\n+}\n+\n+impl Mul<usize> for Limit {\n+    type Output = Limit;\n+\n+    fn mul(self, rhs: usize) -> Self::Output {\n+        Limit::new(self.0 * rhs)\n+    }\n+}\n+\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n@@ -89,13 +131,13 @@ pub struct Session {\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n-    pub recursion_limit: OnceCell<usize>,\n+    pub recursion_limit: OnceCell<Limit>,\n \n     /// The maximum length of types during monomorphization.\n-    pub type_length_limit: OnceCell<usize>,\n+    pub type_length_limit: OnceCell<Limit>,\n \n     /// The maximum blocks a const expression can evaluate.\n-    pub const_eval_limit: OnceCell<usize>,\n+    pub const_eval_limit: OnceCell<Limit>,\n \n     incr_comp_session: OneThread<RefCell<IncrCompSession>>,\n     /// Used for incremental compilation tests. Will only be populated if\n@@ -255,15 +297,15 @@ impl Session {\n         self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n     }\n \n-    pub fn recursion_limit(&self) -> usize {\n+    pub fn recursion_limit(&self) -> Limit {\n         self.recursion_limit.get().copied().unwrap()\n     }\n \n-    pub fn type_length_limit(&self) -> usize {\n+    pub fn type_length_limit(&self) -> Limit {\n         self.type_length_limit.get().copied().unwrap()\n     }\n \n-    pub fn const_eval_limit(&self) -> usize {\n+    pub fn const_eval_limit(&self) -> Limit {\n         self.const_eval_limit.get().copied().unwrap()\n     }\n "}, {"sha": "1126480b02a0d1239268d75a3a6ab832a3ec3cc4", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -333,10 +333,10 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n \n                     Reveal::All => {\n                         let recursion_limit = self.tcx().sess.recursion_limit();\n-                        if self.depth >= recursion_limit {\n+                        if !recursion_limit.value_within_limit(self.depth) {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),\n-                                recursion_limit,\n+                                recursion_limit.0,\n                                 self.param_env,\n                                 ty,\n                             );\n@@ -522,7 +522,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // But for now, let's classify this as an overflow:\n             let recursion_limit = selcx.tcx().sess.recursion_limit();\n             let obligation =\n-                Obligation::with_depth(cause, recursion_limit, param_env, projection_ty);\n+                Obligation::with_depth(cause, recursion_limit.0, param_env, projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n         Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n@@ -814,8 +814,7 @@ fn project_type<'cx, 'tcx>(\n ) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n     debug!(\"project(obligation={:?})\", obligation);\n \n-    let recursion_limit = selcx.tcx().sess.recursion_limit();\n-    if obligation.recursion_depth >= recursion_limit {\n+    if !selcx.tcx().sess.recursion_limit().value_within_limit(obligation.recursion_depth) {\n         debug!(\"project: overflow!\");\n         return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n     }"}, {"sha": "3e7749356d212ac439bf4deea5821456f9e7d257", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -109,10 +109,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n                     Reveal::All => {\n                         let recursion_limit = self.tcx().sess.recursion_limit();\n-                        if self.anon_depth >= recursion_limit {\n+                        if !recursion_limit.value_within_limit(self.anon_depth) {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),\n-                                recursion_limit,\n+                                recursion_limit.0,\n                                 self.param_env,\n                                 ty,\n                             );"}, {"sha": "7aa5aa2dae89bea53e3a347aaa56208e4cb3feb8", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -919,7 +919,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &Obligation<'tcx, T>,\n         error_obligation: &Obligation<'tcx, V>,\n     ) -> Result<(), OverflowError> {\n-        if obligation.recursion_depth >= self.infcx.tcx.sess.recursion_limit() {\n+        if !self.infcx.tcx.sess.recursion_limit().value_within_limit(obligation.recursion_depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     self.infcx().report_overflow_error(error_obligation, true);"}, {"sha": "11c48559bd68320ca76e5758822024180b816e3c", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -163,7 +163,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n ) -> Result<(), NoSolution> {\n     debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n \n-    if depth >= tcx.sess.recursion_limit() {\n+    if !tcx.sess.recursion_limit().value_within_limit(depth) {\n         constraints.overflows.push(ty);\n         return Ok(());\n     }"}, {"sha": "c54704e7877f1ea3a8cd5c95a568ba71fa3695db", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::util::{needs_drop_components, AlwaysRequiresDrop};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::Limit;\n use rustc_span::DUMMY_SP;\n \n type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n@@ -30,7 +31,7 @@ struct NeedsDropTypes<'tcx, F> {\n     /// if it needs drop. If the result depends on whether some other types\n     /// need drop we push them onto the stack.\n     unchecked_tys: Vec<(Ty<'tcx>, usize)>,\n-    recursion_limit: usize,\n+    recursion_limit: Limit,\n     adt_components: F,\n }\n \n@@ -66,7 +67,7 @@ where\n         let tcx = self.tcx;\n \n         while let Some((ty, level)) = self.unchecked_tys.pop() {\n-            if level > self.recursion_limit {\n+            if !self.recursion_limit.value_within_limit(level) {\n                 // Not having a `Span` isn't great. But there's hopefully some other\n                 // recursion limit error as well.\n                 tcx.sess.span_err("}, {"sha": "12edfed19c07e409606ec7c507d02cdedd41f487", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 187, "deletions": 123, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -123,7 +123,22 @@ enum ConvertedBindingKind<'a, 'tcx> {\n     Constraint(&'a [hir::GenericBound<'a>]),\n }\n \n-#[derive(PartialEq)]\n+/// New-typed boolean indicating whether explicit late-bound lifetimes\n+/// are present in a set of generic arguments.\n+///\n+/// For example if we have some method `fn f<'a>(&'a self)` implemented\n+/// for some type `T`, although `f` is generic in the lifetime `'a`, `'a`\n+/// is late-bound so should not be provided explicitly. Thus, if `f` is\n+/// instantiated with some generic arguments providing `'a` explicitly,\n+/// we taint those arguments with `ExplicitLateBound::Yes` so that we\n+/// can provide an appropriate diagnostic later.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum ExplicitLateBound {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n enum GenericArgPosition {\n     Type,\n     Value, // e.g., functions\n@@ -132,13 +147,22 @@ enum GenericArgPosition {\n \n /// A marker denoting that the generic arguments that were\n /// provided did not match the respective generic parameters.\n+#[derive(Clone, Default)]\n pub struct GenericArgCountMismatch {\n     /// Indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n     pub reported: Option<ErrorReported>,\n     /// A list of spans of arguments provided that were not valid.\n     pub invalid_args: Vec<Span>,\n }\n \n+/// Decorates the result of a generic argument count mismatch\n+/// check with whether explicit late bounds were provided.\n+#[derive(Clone)]\n+pub struct GenericArgCountResult {\n+    pub explicit_late_bound: ExplicitLateBound,\n+    pub correct: Result<(), GenericArgCountMismatch>,\n+}\n+\n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n         &self,\n@@ -271,7 +295,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: &ty::Generics,\n         seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         let empty_args = hir::GenericArgs::none();\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n@@ -295,7 +319,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -320,112 +344,94 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n         }\n \n-        // Prohibit explicit lifetime arguments if late-bound lifetime parameters are present.\n-        let mut explicit_lifetimes = Ok(());\n-        if !infer_lifetimes {\n-            if let Some(span_late) = def.has_late_bound_regions {\n-                let msg = \"cannot specify lifetime arguments explicitly \\\n-                           if late bound lifetime parameters are present\";\n-                let note = \"the late bound lifetime parameter is introduced here\";\n-                let span = args.args[0].span();\n-                if position == GenericArgPosition::Value\n-                    && arg_counts.lifetimes != param_counts.lifetimes\n-                {\n-                    explicit_lifetimes = Err(true);\n-                    let mut err = tcx.sess.struct_span_err(span, msg);\n-                    err.span_note(span_late, note);\n-                    err.emit();\n-                } else {\n-                    explicit_lifetimes = Err(false);\n-                    let mut multispan = MultiSpan::from_span(span);\n-                    multispan.push_span_label(span_late, note.to_string());\n-                    tcx.struct_span_lint_hir(\n-                        LATE_BOUND_LIFETIME_ARGUMENTS,\n-                        args.args[0].id(),\n-                        multispan,\n-                        |lint| lint.build(msg).emit(),\n-                    );\n-                }\n+        let explicit_late_bound =\n+            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n+\n+        let check_kind_count = |kind,\n+                                required,\n+                                permitted,\n+                                provided,\n+                                offset,\n+                                unexpected_spans: &mut Vec<Span>,\n+                                silent| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind, required, permitted, provided, offset\n+            );\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return Ok(());\n             }\n-        }\n \n-        let check_kind_count =\n-            |kind, required, permitted, provided, offset, unexpected_spans: &mut Vec<Span>| {\n-                debug!(\n-                    \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                    kind, required, permitted, provided, offset\n-                );\n-                // We enforce the following: `required` <= `provided` <= `permitted`.\n-                // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-                // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-                if required <= provided && provided <= permitted {\n-                    return Ok(());\n-                }\n-\n-                // Unfortunately lifetime and type parameter mismatches are typically styled\n-                // differently in diagnostics, which means we have a few cases to consider here.\n-                let (bound, quantifier) = if required != permitted {\n-                    if provided < required {\n-                        (required, \"at least \")\n-                    } else {\n-                        // provided > permitted\n-                        (permitted, \"at most \")\n-                    }\n-                } else {\n-                    (required, \"\")\n-                };\n+            if silent {\n+                return Err(true);\n+            }\n \n-                let (spans, label) = if required == permitted && provided > permitted {\n-                    // In the case when the user has provided too many arguments,\n-                    // we want to point to the unexpected arguments.\n-                    let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span())\n-                        .collect();\n-                    unexpected_spans.extend(spans.clone());\n-                    (spans, format!(\"unexpected {} argument\", kind))\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \")\n                 } else {\n-                    (\n-                        vec![span],\n-                        format!(\n-                            \"expected {}{} {} argument{}\",\n-                            quantifier,\n-                            bound,\n-                            kind,\n-                            pluralize!(bound),\n-                        ),\n-                    )\n-                };\n-\n-                let mut err = tcx.sess.struct_span_err_with_code(\n-                    spans.clone(),\n-                    &format!(\n-                        \"wrong number of {} arguments: expected {}{}, found {}\",\n-                        kind, quantifier, bound, provided,\n-                    ),\n-                    DiagnosticId::Error(\"E0107\".into()),\n-                );\n-                for span in spans {\n-                    err.span_label(span, label.as_str());\n+                    // provided > permitted\n+                    (permitted, \"at most \")\n                 }\n-                err.emit();\n+            } else {\n+                (required, \"\")\n+            };\n \n-                Err(true)\n+            let (spans, label) = if required == permitted && provided > permitted {\n+                // In the case when the user has provided too many arguments,\n+                // we want to point to the unexpected arguments.\n+                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span())\n+                    .collect();\n+                unexpected_spans.extend(spans.clone());\n+                (spans, format!(\"unexpected {} argument\", kind))\n+            } else {\n+                (\n+                    vec![span],\n+                    format!(\n+                        \"expected {}{} {} argument{}\",\n+                        quantifier,\n+                        bound,\n+                        kind,\n+                        pluralize!(bound),\n+                    ),\n+                )\n             };\n \n-        let mut arg_count_correct = explicit_lifetimes;\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                spans.clone(),\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind, quantifier, bound, provided,\n+                ),\n+                DiagnosticId::Error(\"E0107\".into()),\n+            );\n+            for span in spans {\n+                err.span_label(span, label.as_str());\n+            }\n+            err.emit();\n+\n+            Err(true)\n+        };\n+\n+        let mut arg_count_correct = Ok(());\n         let mut unexpected_spans = vec![];\n \n-        if arg_count_correct.is_ok()\n-            && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes)\n-        {\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n             arg_count_correct = check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n                 arg_counts.lifetimes,\n                 0,\n                 &mut unexpected_spans,\n+                explicit_late_bound == ExplicitLateBound::Yes,\n             )\n             .and(arg_count_correct);\n         }\n@@ -438,6 +444,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 arg_counts.consts,\n                 arg_counts.lifetimes + arg_counts.types,\n                 &mut unexpected_spans,\n+                false,\n             )\n             .and(arg_count_correct);\n         }\n@@ -451,14 +458,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 arg_counts.types,\n                 arg_counts.lifetimes,\n                 &mut unexpected_spans,\n+                false,\n             )\n             .and(arg_count_correct);\n         }\n \n-        arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n-            reported: if reported_err { Some(ErrorReported) } else { None },\n-            invalid_args: unexpected_spans,\n-        })\n+        GenericArgCountResult {\n+            explicit_late_bound,\n+            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+                reported: if reported_err { Some(ErrorReported) } else { None },\n+                invalid_args: unexpected_spans,\n+            }),\n+        }\n     }\n \n     /// Report an error that a generic argument did not match the generic parameter that was\n@@ -512,7 +523,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count_correct: bool,\n+        arg_count: GenericArgCountResult,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n         mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n@@ -585,30 +596,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // input. We try to handle both sensibly.\n                 match (args.peek(), params.peek()) {\n                     (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. })\n-                            | (GenericArg::Const(_), GenericParamDefKind::Const) => {\n+                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n                                 substs.push(provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n                             }\n                             (\n                                 GenericArg::Type(_) | GenericArg::Const(_),\n                                 GenericParamDefKind::Lifetime,\n+                                _,\n                             ) => {\n                                 // We expected a lifetime argument, but got a type or const\n                                 // argument. That means we're inferring the lifetimes.\n                                 substs.push(inferred_kind(None, param, infer_args));\n                                 force_infer_lt = Some(arg);\n                                 params.next();\n                             }\n-                            (_, kind) => {\n+                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                                // We've come across a lifetime when we expected something else in\n+                                // the presence of explicit late bounds. This is most likely\n+                                // due to the presence of the explicit bound so we're just going to\n+                                // ignore it.\n+                                args.next();\n+                            }\n+                            (_, kind, _) => {\n                                 // We expected one kind of parameter, but the user provided\n                                 // another. This is an error. However, if we already know that\n                                 // the arguments don't match up with the parameters, we won't issue\n                                 // an additional error, as the user already knows what's wrong.\n-                                if arg_count_correct {\n+                                if arg_count.correct.is_ok()\n+                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                                {\n                                     Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n                                 }\n \n@@ -624,17 +645,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                     (Some(&arg), None) => {\n                         // We should never be able to reach this point with well-formed input.\n-                        // There are two situations in which we can encounter this issue.\n+                        // There are three situations in which we can encounter this issue.\n                         //\n                         //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it. This case\n-                        //      also occurs when late-bound lifetime parameters are present, yet\n-                        //      the lifetime arguments have also been explicitly specified by the\n+                        //      will already have been emitted, and we can ignore it.\n+                        //  2.  There are late-bound lifetime parameters present, yet the\n+                        //      lifetime arguments have also been explicitly specified by the\n                         //      user.\n-                        //  2.  We've inferred some lifetimes, which have been provided later (i.e.\n+                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n                         //      after a type or const). We want to throw an error in this case.\n \n-                        if arg_count_correct {\n+                        if arg_count.correct.is_ok()\n+                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                        {\n                             let kind = arg.descr();\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n@@ -699,8 +722,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n-    {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n@@ -726,7 +748,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none() && parent_substs.is_empty());\n         }\n \n-        let arg_count_correct = Self::check_generic_arg_count(\n+        let arg_count = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n@@ -761,7 +783,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count_correct.is_ok(),\n+            arg_count.clone(),\n             // Provide the generic args, and whether types should be inferred.\n             |did| {\n                 if did == def_id {\n@@ -880,7 +902,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_params, self_ty, substs\n         );\n \n-        (substs, assoc_bindings, arg_count_correct)\n+        (substs, assoc_bindings, arg_count)\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -1011,14 +1033,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings, arg_count_correct) = self.create_substs_for_ast_trait_ref(\n+        let (substs, assoc_bindings, arg_count) = self.create_substs_for_ast_trait_ref(\n             trait_ref.path.span,\n             trait_def_id,\n             self_ty,\n@@ -1048,7 +1070,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_ref, bounds, poly_trait_ref\n         );\n \n-        arg_count_correct\n+        arg_count\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -1076,7 +1098,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n-    ) -> Result<(), GenericArgCountMismatch> {\n+    ) -> GenericArgCountResult {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n@@ -1166,8 +1188,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n-    {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n@@ -1515,9 +1536,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         for trait_bound in trait_bounds.iter().rev() {\n-            if let Err(GenericArgCountMismatch {\n-                invalid_args: cur_potential_assoc_types, ..\n-            }) = self.instantiate_poly_trait_ref(\n+            if let GenericArgCountResult {\n+                correct:\n+                    Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n+                ..\n+            } = self.instantiate_poly_trait_ref(\n                 trait_bound,\n                 Constness::NotConst,\n                 dummy_self,\n@@ -2473,6 +2496,47 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n+    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+    /// are present. This is used both for datatypes and function calls.\n+    fn prohibit_explicit_late_bound_lifetimes(\n+        tcx: TyCtxt<'_>,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+    ) -> ExplicitLateBound {\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        if infer_lifetimes {\n+            ExplicitLateBound::No\n+        } else if let Some(span_late) = def.has_late_bound_regions {\n+            let msg = \"cannot specify lifetime arguments explicitly \\\n+                       if late bound lifetime parameters are present\";\n+            let note = \"the late bound lifetime parameter is introduced here\";\n+            let span = args.args[0].span();\n+            if position == GenericArgPosition::Value\n+                && arg_counts.lifetimes != param_counts.lifetimes\n+            {\n+                let mut err = tcx.sess.struct_span_err(span, msg);\n+                err.span_note(span_late, note);\n+                err.emit();\n+            } else {\n+                let mut multispan = MultiSpan::from_span(span);\n+                multispan.push_span_label(span_late, note.to_string());\n+                tcx.struct_span_lint_hir(\n+                    LATE_BOUND_LIFETIME_ARGUMENTS,\n+                    args.args[0].id(),\n+                    multispan,\n+                    |lint| lint.build(msg).emit(),\n+                );\n+            }\n+            ExplicitLateBound::Yes\n+        } else {\n+            ExplicitLateBound::No\n+        }\n+    }\n+\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,"}, {"sha": "73d4e2b78206d98300bce537efa8f31aebf2df0b", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n             return Some((self.cur_ty, 0));\n         }\n \n-        if self.steps.len() >= tcx.sess.recursion_limit() {\n+        if !tcx.sess.recursion_limit().value_within_limit(self.steps.len()) {\n             if !self.silence_errors {\n                 report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n             }"}, {"sha": "48d27387476a2a3a17b21c7bad81b7f485efc889", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_correct.is_ok(),\n+            arg_count_correct,\n             // Provide the generic args, and whether types should be inferred.\n             |def_id| {\n                 // The last component of the returned tuple here is unimportant."}, {"sha": "a8fa65a135ac2c92241380a767b7728e2c6a120f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -87,7 +87,9 @@ mod upvar;\n mod wfcheck;\n pub mod writeback;\n \n-use crate::astconv::{AstConv, GenericArgCountMismatch, PathSeg};\n+use crate::astconv::{\n+    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, PathSeg,\n+};\n use rustc_ast::ast;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_attr as attr;\n@@ -5495,11 +5497,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            if let Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }) =\n-                AstConv::check_generic_arg_count_for_call(\n-                    tcx, span, &generics, &seg, false, // `is_method_call`\n-                )\n-            {\n+            if let GenericArgCountResult {\n+                correct: Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }),\n+                ..\n+            } = AstConv::check_generic_arg_count_for_call(\n+                tcx, span, &generics, &seg, false, // `is_method_call`\n+            ) {\n                 infer_args_for_err.insert(index);\n                 self.set_tainted_by_errors(); // See issue #53251.\n             }\n@@ -5555,14 +5558,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // escaping late-bound regions, and nor should the base type scheme.\n         let ty = tcx.type_of(def_id);\n \n+        let arg_count = GenericArgCountResult {\n+            explicit_late_bound: ExplicitLateBound::No,\n+            correct: if infer_args_for_err.is_empty() {\n+                Ok(())\n+            } else {\n+                Err(GenericArgCountMismatch::default())\n+            },\n+        };\n+\n         let substs = self_ctor_substs.unwrap_or_else(|| {\n             AstConv::create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                infer_args_for_err.is_empty(),\n+                arg_count,\n                 // Provide the generic args, and whether types should be inferred.\n                 |def_id| {\n                     if let Some(&PathSeg(_, index)) ="}, {"sha": "f34525a664ebe4d136a34360df975c060749e56b", "filename": "src/test/ui/asm/issue-72570.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fissue-72570.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fissue-72570.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-72570.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,10 @@\n+// only-x86_64\n+\n+#![feature(asm)]\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\", in(\"invalid\") \"\".len());\n+        //~^ ERROR: invalid register `invalid`: unknown register\n+    }\n+}"}, {"sha": "49013a23ced2da7543e91ba1b35cb7e9f0013485", "filename": "src/test/ui/asm/issue-72570.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fissue-72570.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fissue-72570.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-72570.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,8 @@\n+error: invalid register `invalid`: unknown register\n+  --> $DIR/issue-72570.rs:7:18\n+   |\n+LL |         asm!(\"\", in(\"invalid\") \"\".len());\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "83a3672af49ce620b3b534a0587c689889d5c660", "filename": "src/test/ui/asm/sym.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fasm%2Fsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fsym.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,38 @@\n+// no-system-llvm\n+// only-x86_64\n+// run-pass\n+\n+#![feature(asm, track_caller)]\n+\n+extern \"C\" fn f1() -> i32 {\n+    111\n+}\n+\n+// The compiler will generate a shim to hide the caller location parameter.\n+#[track_caller]\n+fn f2() -> i32 {\n+    222\n+}\n+\n+macro_rules! call {\n+    ($func:path) => {{\n+        let result: i32;\n+        unsafe {\n+            asm!(\"call {}\", sym $func,\n+                out(\"rax\") result,\n+                out(\"rcx\") _, out(\"rdx\") _, out(\"rdi\") _, out(\"rsi\") _,\n+                out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n+                out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n+                out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n+                out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n+                out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n+            );\n+        }\n+        result\n+    }}\n+}\n+\n+fn main() {\n+    assert_eq!(call!(f1), 111);\n+    assert_eq!(call!(f2), 222);\n+}"}, {"sha": "c7b0fbeb0e39bcc819fc0cf305b36a576af10396", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "59ed68c2a773fba2dfc0e22cb0da1b4ba5eb72ef", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "c9a6d42b5cc223a779c0541baf30c89d46e8630e", "filename": "src/test/ui/did_you_mean/recursion_limit.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,4 +1,4 @@\n-error[E0275]: overflow evaluating the requirement `J: std::marker::Send`\n+error[E0275]: overflow evaluating the requirement `K: std::marker::Send`\n   --> $DIR/recursion_limit.rs:34:5\n    |\n LL | fn is_send<T:Send>() { }\n@@ -8,6 +8,7 @@ LL |     is_send::<A>();\n    |     ^^^^^^^^^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate (`recursion_limit`)\n+   = note: required because it appears within the type `J`\n    = note: required because it appears within the type `I`\n    = note: required because it appears within the type `H`\n    = note: required because it appears within the type `G`"}, {"sha": "8339cc291cf30171a1bee0cde18ef69b8d8d0837", "filename": "src/test/ui/did_you_mean/recursion_limit_deref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,4 +1,4 @@\n-error[E0055]: reached the recursion limit while auto-dereferencing `I`\n+error[E0055]: reached the recursion limit while auto-dereferencing `J`\n   --> $DIR/recursion_limit_deref.rs:50:22\n    |\n LL |     let x: &Bottom = &t;"}, {"sha": "5df69e4649df55cffe1a9077b051f248ef497038", "filename": "src/test/ui/dropck/dropck_no_diverge_on_nonregular_1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_1.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -4,15 +4,15 @@ error[E0320]: overflow while adding drop-check rules for FingerTree<i32>\n LL |     let ft =\n    |         ^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error[E0320]: overflow while adding drop-check rules for FingerTree<i32>\n   --> $DIR/dropck_no_diverge_on_nonregular_1.rs:25:9\n    |\n LL |         FingerTree::Single(1);\n    |         ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d34097d4010046956b0f894006f77c3a74d31d9a", "filename": "src/test/ui/dropck/dropck_no_diverge_on_nonregular_2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_2.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -4,15 +4,15 @@ error[E0320]: overflow while adding drop-check rules for FingerTree<i32>\n LL |     let ft =\n    |         ^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error[E0320]: overflow while adding drop-check rules for FingerTree<i32>\n   --> $DIR/dropck_no_diverge_on_nonregular_2.rs:24:9\n    |\n LL |         FingerTree::Single(1);\n    |         ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<i32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1c810df24238954a8b9b2b46ca15ea07a9db9e3d", "filename": "src/test/ui/dropck/dropck_no_diverge_on_nonregular_3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_no_diverge_on_nonregular_3.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -4,23 +4,23 @@ error[E0320]: overflow while adding drop-check rules for std::option::Option<Wra\n LL |     let w =\n    |         ^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error[E0320]: overflow while adding drop-check rules for std::option::Option<Wrapper<u32>>\n   --> $DIR/dropck_no_diverge_on_nonregular_3.rs:33:9\n    |\n LL |         Some(Wrapper::Simple::<u32>);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error[E0320]: overflow while adding drop-check rules for Wrapper<u32>\n   --> $DIR/dropck_no_diverge_on_nonregular_3.rs:33:14\n    |\n LL |         Some(Wrapper::Simple::<u32>);\n    |              ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n+   = note: overflowed on FingerTree<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<Node<u32>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n \n error: aborting due to 3 previous errors\n "}, {"sha": "fd5804bbc2a598fc30d9ffa53e0711dd6bf06b5c", "filename": "src/test/ui/error-codes/E0055.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,4 +1,4 @@\n-#![recursion_limit=\"5\"]\n+#![recursion_limit=\"4\"]\n struct Foo;\n \n impl Foo {"}, {"sha": "1b8c5760e65bf0012a60350cdeaad7591ccff2e7", "filename": "src/test/ui/error-codes/E0055.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -4,7 +4,7 @@ error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n LL |     ref_foo.foo();\n    |             ^^^ deref recursion limit reached\n    |\n-   = help: consider adding a `#![recursion_limit=\"10\"]` attribute to your crate (`E0055`)\n+   = help: consider adding a `#![recursion_limit=\"8\"]` attribute to your crate (`E0055`)\n \n error: aborting due to previous error\n "}, {"sha": "2692fe6945e09ce61ebb5c9e8f3e244e5d7ef5e5", "filename": "src/test/ui/error-codes/E0275.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,4 +1,4 @@\n-error[E0275]: overflow evaluating the requirement `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n+error[E0275]: overflow evaluating the requirement `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n   --> $DIR/E0275.rs:5:33\n    |\n LL | trait Foo {}\n@@ -8,6 +8,7 @@ LL | impl<T> Foo for T where Bar<T>: Foo {}\n    |                                 ^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`E0275`)\n+   = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`"}, {"sha": "ed9137ce396cf44b7167a414c55c5116f5e7a6c3", "filename": "src/test/ui/issues/issue-18400.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-18400.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-18400.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18400.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -133,6 +133,7 @@ LL |     0.contains(bits);\n    = note: required because of the requirements on the impl of `Set<&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[_]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]>` for `{integer}`\n    = note: required because of the requirements on the impl of `Set<&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[_]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]>` for `{integer}`\n    = note: required because of the requirements on the impl of `Set<&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[_]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]>` for `{integer}`\n+   = note: required because of the requirements on the impl of `Set<&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[&[_]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]>` for `{integer}`\n \n error: aborting due to previous error\n "}, {"sha": "a3eb4fec70f321722788a601787100df8cb8831f", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -6,7 +6,7 @@ LL | struct NoData<T>;\n    |\n    = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData`\n \n-error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n+error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n   --> $DIR/issue-20413.rs:8:36\n    |\n LL | trait Foo {\n@@ -16,6 +16,7 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    |                                    ^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n@@ -144,7 +145,7 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<T>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<T>`\n \n-error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n+error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n   --> $DIR/issue-20413.rs:8:36\n    |\n LL | trait Foo {\n@@ -154,6 +155,7 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    |                                    ^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_20413`)\n+   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`"}, {"sha": "c4032b27edcbddb2f3276fbfd996d32244fc42ac", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,20 +1,20 @@\n-error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n+error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n   --> $DIR/issue-23122-2.rs:7:15\n    |\n LL | impl<T: Next> Next for GetNext<T> {\n    |               ^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_23122_2`)\n-   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n+   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n \n-error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n+error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: std::marker::Sized`\n   --> $DIR/issue-23122-2.rs:9:5\n    |\n LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_23122_2`)\n-   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n+   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3f10fc017a73fe736b26ff843380752aced21dfc", "filename": "src/test/ui/issues/issue-38940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -42,5 +42,5 @@ fn main() {\n     let t = Top::new();\n     let x: &Bottom = &t;\n     //~^ ERROR mismatched types\n-    //~| ERROR reached the recursion limit while auto-dereferencing `I`\n+    //~| ERROR reached the recursion limit while auto-dereferencing `J`\n }"}, {"sha": "0671cede73bbe5c16dcb1c625c4f64c206dc80be", "filename": "src/test/ui/issues/issue-38940.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -1,4 +1,4 @@\n-error[E0055]: reached the recursion limit while auto-dereferencing `I`\n+error[E0055]: reached the recursion limit while auto-dereferencing `J`\n   --> $DIR/issue-38940.rs:43:22\n    |\n LL |     let x: &Bottom = &t;"}, {"sha": "1400c6f97b60509f31e419574d63a1e642c5168f", "filename": "src/test/ui/issues/issue-67552.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,30 @@\n+// build-fail\n+\n+fn main() {\n+    rec(Empty);\n+}\n+\n+struct Empty;\n+\n+impl Iterator for Empty {\n+    type Item = ();\n+    fn next<'a>(&'a mut self) -> core::option::Option<()> {\n+        None\n+    }\n+}\n+\n+fn identity<T>(x: T) -> T {\n+    x\n+}\n+\n+fn rec<T>(mut it: T)\n+//~^ ERROR reached the recursion limit while instantiating\n+where\n+    T: Iterator,\n+{\n+    if () == () {\n+        T::count(it);\n+    } else {\n+        rec(identity(&mut it))\n+    }\n+}"}, {"sha": "881f9d221d6aedf9bf2cb4e8a2c710da3ba2f56e", "filename": "src/test/ui/issues/issue-67552.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67552.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,14 @@\n+error: reached the recursion limit while instantiating `rec::<&mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut &mut Empty>`\n+  --> $DIR/issue-67552.rs:20:1\n+   |\n+LL | / fn rec<T>(mut it: T)\n+LL | |\n+LL | | where\n+LL | |     T: Iterator,\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "92fd1f73a937f78833a94caf97326a5897604d06", "filename": "src/test/ui/issues/issue-72278.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72278.rs?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#![allow(unused)]\n+\n+struct S;\n+\n+impl S {\n+    fn func<'a, U>(&'a self) -> U {\n+        todo!()\n+    }\n+}\n+\n+fn dont_crash<'a, U>() -> U {\n+    S.func::<'a, U>()\n+    //~^ WARN cannot specify lifetime arguments explicitly\n+    //~| WARN this was previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "41dff686bc4aeff5864492a116228ea7074e3d0f", "filename": "src/test/ui/issues/issue-72278.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74e80468347471779be6060d8d7d6d04e98e467f/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72278.stderr?ref=74e80468347471779be6060d8d7d6d04e98e467f", "patch": "@@ -0,0 +1,15 @@\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+  --> $DIR/issue-72278.rs:14:14\n+   |\n+LL |     fn func<'a, U>(&'a self) -> U {\n+   |             -- the late bound lifetime parameter is introduced here\n+...\n+LL |     S.func::<'a, U>()\n+   |              ^^\n+   |\n+   = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+\n+warning: 1 warning emitted\n+"}]}