{"sha": "f06bab77586e377a24393b9e2e49d1bb7003dc0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNmJhYjc3NTg2ZTM3N2EyNDM5M2I5ZTJlNDlkMWJiNzAwM2RjMGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-16T18:51:26Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-16T18:51:26Z"}, "message": "debuginfo: argument and upvar names for MIR.", "tree": {"sha": "416f99f8ebaab988cbb82979691291b06fc117f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416f99f8ebaab988cbb82979691291b06fc117f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f06bab77586e377a24393b9e2e49d1bb7003dc0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f06bab77586e377a24393b9e2e49d1bb7003dc0b", "html_url": "https://github.com/rust-lang/rust/commit/f06bab77586e377a24393b9e2e49d1bb7003dc0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f06bab77586e377a24393b9e2e49d1bb7003dc0b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd2881ed47cedd3b26ca3cb9024e4d7bad54f95", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd2881ed47cedd3b26ca3cb9024e4d7bad54f95", "html_url": "https://github.com/rust-lang/rust/commit/7fd2881ed47cedd3b26ca3cb9024e4d7bad54f95"}], "stats": {"total": 234, "additions": 176, "deletions": 58}, "files": [{"sha": "3bc65124d34646540857ca68efbfb08de58ae72a", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -52,6 +52,10 @@ pub struct Mir<'tcx> {\n     /// through the resulting reference.\n     pub temp_decls: Vec<TempDecl<'tcx>>,\n \n+    /// Names and capture modes of all the closure upvars, assuming\n+    /// the first argument is either the closure or a reference to it.\n+    pub upvar_decls: Vec<UpvarDecl>,\n+\n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n }\n@@ -197,7 +201,20 @@ pub struct ArgDecl<'tcx> {\n \n     /// If true, this argument is a tuple after monomorphization,\n     /// and has to be collected from multiple actual arguments.\n-    pub spread: bool\n+    pub spread: bool,\n+\n+    /// Either special_idents::invalid or the name of a single-binding\n+    /// pattern associated with this argument. Useful for debuginfo.\n+    pub debug_name: Name\n+}\n+\n+/// A closure capture, with its name and mode.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct UpvarDecl {\n+    pub debug_name: Name,\n+\n+    /// If true, the capture is behind a reference.\n+    pub by_ref: bool\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "10afd3dd953d0ba4b13cc1bfa15be9f0651ef9d1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -248,6 +248,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* var_decls,\n                     ref $($mutability)* arg_decls,\n                     ref $($mutability)* temp_decls,\n+                    upvar_decls: _,\n                     ref $($mutability)* span,\n                 } = *mir;\n \n@@ -599,7 +600,8 @@ macro_rules! make_mir_visitor {\n                               arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n                 let ArgDecl {\n                     ref $($mutability)* ty,\n-                    spread: _\n+                    spread: _,\n+                    debug_name: _\n                 } = *arg_decl;\n \n                 self.visit_ty(ty);"}, {"sha": "5284a2ef39535fc21c72a8ccf23e96788c8fb67a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -10,13 +10,15 @@\n \n use hair::cx::Cx;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{FnOutput, Ty};\n+use rustc::ty::{self, FnOutput, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n+use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::parse::token;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n@@ -224,13 +226,37 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                        true\n                    }));\n \n+    // Gather the upvars of a closure, if any.\n+    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n+        freevars.iter().map(|fv| {\n+            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+                var_id: fv.def.var_id(),\n+                closure_expr_id: fn_id\n+            }).map_or(false, |capture| match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true\n+            });\n+            let mut decl = UpvarDecl {\n+                debug_name: token::special_idents::invalid.name,\n+                by_ref: by_ref\n+            };\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n+                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                    decl.debug_name = ident.node.name;\n+                }\n+            }\n+            decl\n+        }).collect()\n+    });\n+\n     (\n         Mir {\n             basic_blocks: builder.cfg.basic_blocks,\n             scopes: builder.scope_datas,\n             var_decls: builder.var_decls,\n             arg_decls: arg_decls.take().expect(\"args never built?\"),\n             temp_decls: builder.temp_decls,\n+            upvar_decls: upvar_decls,\n             return_ty: return_ty,\n             span: span\n         },\n@@ -269,7 +295,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                    argument_extent, &lvalue, ty);\n \n-                ArgDecl { ty: ty, spread: false }\n+                let mut name = token::special_idents::invalid.name;\n+                if let Some(pat) = pattern {\n+                    if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                        if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n+                            name = ident.node.name;\n+                        }\n+                    }\n+                }\n+\n+                ArgDecl {\n+                    ty: ty,\n+                    spread: false,\n+                    debug_name: name\n+                }\n             })\n             .collect();\n "}, {"sha": "4b1292e4086f78b66f3453718c3917e177b7ada5", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -120,21 +120,28 @@ fn make_mir_scope(ccx: &CrateContext,\n         return;\n     };\n \n-    scopes[idx] = if !has_variables.contains(idx) {\n+    if !has_variables.contains(idx) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n-        parent_scope\n-    } else {\n-        let loc = span_start(ccx, scope_data.span);\n-        let file_metadata = file_metadata(ccx, &loc.file.name);\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                DIB(ccx),\n-                parent_scope,\n-                file_metadata,\n-                loc.line as c_uint,\n-                loc.col.to_usize() as c_uint)\n+\n+        // However, we don't skip creating a nested scope if\n+        // our parent is the root, because we might want to\n+        // put arguments in the root and not have shadowing.\n+        if parent_scope != fn_metadata {\n+            scopes[idx] = parent_scope;\n+            return;\n         }\n+    }\n+\n+    let loc = span_start(ccx, scope_data.span);\n+    let file_metadata = file_metadata(ccx, &loc.file.name);\n+    scopes[idx] = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(ccx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n     };\n }\n "}, {"sha": "3edbea88c057502d8849e170ec34667fd275cfa9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -126,6 +126,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n     // Allocate variable and temp allocas\n+    let args = arg_value_refs(&bcx, &mir, &scopes);\n     let vars = mir.var_decls.iter()\n                             .map(|decl| (bcx.monomorphize(&decl.ty), decl))\n                             .map(|(mty, decl)| {\n@@ -156,7 +157,6 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, &mir, &scopes);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n@@ -278,15 +278,15 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     let byte_offset_of_var_in_tuple =\n                         machine::llelement_offset(bcx.ccx(), lltuplety, i);\n \n-                    let address_operations = unsafe {\n+                    let ops = unsafe {\n                         [llvm::LLVMDIBuilderCreateOpDeref(),\n                          llvm::LLVMDIBuilderCreateOpPlus(),\n                          byte_offset_of_var_in_tuple as i64]\n                     };\n \n                     let variable_access = VariableAccess::IndirectVariable {\n                         alloca: lltemp,\n-                        address_operations: &address_operations\n+                        address_operations: &ops\n                     };\n                     declare_local(bcx, token::special_idents::invalid.name,\n                                   tupled_arg_ty, scope, variable_access,\n@@ -327,10 +327,78 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             lltemp\n         };\n         bcx.with_block(|bcx| arg_scope.map(|scope| {\n-            declare_local(bcx, token::special_idents::invalid.name, arg_ty, scope,\n-                          VariableAccess::DirectVariable { alloca: llval },\n-                          VariableKind::ArgumentVariable(arg_index + 1),\n-                          bcx.fcx().span.unwrap_or(DUMMY_SP));\n+            // Is this a regular argument?\n+            if arg_index > 0 || mir.upvar_decls.is_empty() {\n+                declare_local(bcx, arg_decl.debug_name, arg_ty, scope,\n+                              VariableAccess::DirectVariable { alloca: llval },\n+                              VariableKind::ArgumentVariable(arg_index + 1),\n+                              bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                return;\n+            }\n+\n+            // Or is it the closure environment?\n+            let (closure_ty, env_ref) = if let ty::TyRef(_, mt) = arg_ty.sty {\n+                (mt.ty, true)\n+            } else {\n+                (arg_ty, false)\n+            };\n+            let upvar_tys = if let ty::TyClosure(_, ref substs) = closure_ty.sty {\n+                &substs.upvar_tys[..]\n+            } else {\n+                bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n+            };\n+\n+            // Store the pointer to closure data in an alloca for debuginfo\n+            // because that's what the llvm.dbg.declare intrinsic expects.\n+\n+            // FIXME(eddyb) this shouldn't be necessary but SROA seems to\n+            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e. it\n+            // doesn't actually strip the offset when splitting the closure\n+            // environment into its components so it ends up out of bounds.\n+            let env_ptr = if !env_ref {\n+                use base::*;\n+                use build::*;\n+                use common::*;\n+                let alloc = alloca(bcx, val_ty(llval), \"__debuginfo_env_ptr\");\n+                Store(bcx, llval, alloc);\n+                alloc\n+            } else {\n+                llval\n+            };\n+\n+            let llclosurety = type_of::type_of(bcx.ccx(), closure_ty);\n+            for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n+                let byte_offset_of_var_in_env =\n+                    machine::llelement_offset(bcx.ccx(), llclosurety, i);\n+\n+                let ops = unsafe {\n+                    [llvm::LLVMDIBuilderCreateOpDeref(),\n+                     llvm::LLVMDIBuilderCreateOpPlus(),\n+                     byte_offset_of_var_in_env as i64,\n+                     llvm::LLVMDIBuilderCreateOpDeref()]\n+                };\n+\n+                // The environment and the capture can each be indirect.\n+\n+                // FIXME(eddyb) see above why we have to keep\n+                // a pointer in an alloca for debuginfo atm.\n+                let mut ops = if env_ref || true { &ops[..] } else { &ops[1..] };\n+\n+                let ty = if let (true, &ty::TyRef(_, mt)) = (decl.by_ref, &ty.sty) {\n+                    mt.ty\n+                } else {\n+                    ops = &ops[..ops.len() - 1];\n+                    ty\n+                };\n+\n+                let variable_access = VariableAccess::IndirectVariable {\n+                    alloca: env_ptr,\n+                    address_operations: &ops\n+                };\n+                declare_local(bcx, decl.debug_name, ty, scope, variable_access,\n+                              VariableKind::CapturedVariable,\n+                              bcx.fcx().span.unwrap_or(DUMMY_SP));\n+            }\n         }));\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n     }).collect()"}, {"sha": "f0ecda92993706ce145e3c1961298400e6b12076", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -251,7 +251,7 @@\n #![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn immediate_args(a: isize, b: bool, c: f64) {\n     println!(\"\");\n }\n@@ -268,51 +268,51 @@ struct BigStruct {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn function_call(x: u64, y: u64, z: f64) {\n     println!(\"Hi!\")\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn identifier(x: u64, y: u64, z: f64) -> u64 {\n     x\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n     return x;\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n     x + y\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n     if x + y < 1000 {\n         x\n@@ -322,7 +322,7 @@ fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     while x + y < 1000 {\n         x += z\n@@ -331,7 +331,7 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     loop {\n         x += z;"}, {"sha": "7090377e5db1bfd7fbdf23f51e3f492cd40116bd", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -78,7 +78,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(box_syntax)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -88,7 +88,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -102,14 +101,10 @@ fn main() {\n     let struct_ref = &a_struct;\n     let owned: Box<_> = box 6;\n \n-    let mut closure =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    || {\n+    let mut closure = || {\n         let closure_local = 8;\n \n-        let mut nested_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut nested_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned + closure_local;\n         };"}, {"sha": "aa269edadd8f410b9a96b40e1e965e38f5124c43", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -40,7 +40,7 @@\n // lldb-check:[...]$2 = 5\n \n #![allow(unused_variables)]\n-#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(unboxed_closures, box_syntax)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -50,7 +50,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let constant = 1;\n \n@@ -62,9 +61,7 @@ fn main() {\n \n     let owned: Box<_> = box 5;\n \n-    let closure =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    move || {\n+    let closure = move || {\n         zzz(); // #break\n         do_something(&constant, &a_struct.a, &*owned);\n     };\n@@ -76,9 +73,7 @@ fn main() {\n     // The `self` argument of the following closure should be passed by value\n     // to FnOnce::call_once(self, args), which gets translated a bit differently\n     // than the regular case. Let's make sure this is supported too.\n-    let immedate_env =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    move || {\n+    let immedate_env = move || {\n         zzz(); // #break\n         return constant2;\n     };"}, {"sha": "6def5cf285934f7790f334ccbf06960eb902fd39", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06bab77586e377a24393b9e2e49d1bb7003dc0b/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=f06bab77586e377a24393b9e2e49d1bb7003dc0b", "patch": "@@ -69,7 +69,7 @@\n // lldb-command:print *owned\n // lldb-check:[...]$9 = 6\n \n-#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(unboxed_closures, box_syntax)]\n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n@@ -80,7 +80,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -95,9 +94,7 @@ fn main() {\n     let owned: Box<_> = box 6;\n \n     {\n-        let mut first_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut first_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };\n@@ -106,9 +103,7 @@ fn main() {\n     }\n \n     {\n-        let mut second_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut second_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };"}]}