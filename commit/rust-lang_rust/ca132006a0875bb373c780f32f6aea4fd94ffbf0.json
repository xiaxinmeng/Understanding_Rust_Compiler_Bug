{"sha": "ca132006a0875bb373c780f32f6aea4fd94ffbf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMTMyMDA2YTA4NzViYjM3M2M3ODBmMzJmNmFlYTRmZDk0ZmZiZjA=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-23T03:56:46Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-28T01:25:19Z"}, "message": "Remove dead code from cryptoutil.rs and remove macro_rules feature flag.", "tree": {"sha": "88317d2ef0d765c49c38def77845c2ef9554f3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88317d2ef0d765c49c38def77845c2ef9554f3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca132006a0875bb373c780f32f6aea4fd94ffbf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca132006a0875bb373c780f32f6aea4fd94ffbf0", "html_url": "https://github.com/rust-lang/rust/commit/ca132006a0875bb373c780f32f6aea4fd94ffbf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca132006a0875bb373c780f32f6aea4fd94ffbf0/comments", "author": null, "committer": null, "parents": [{"sha": "72a9482b3f656a009304de9cfa05011083045e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a9482b3f656a009304de9cfa05011083045e4f", "html_url": "https://github.com/rust-lang/rust/commit/72a9482b3f656a009304de9cfa05011083045e4f"}], "stats": {"total": 303, "additions": 73, "deletions": 230}, "files": [{"sha": "55199b1f2cc76d114165948fccceebce70199b0c", "filename": "src/librustpkg/cryptoutil.rs", "status": "modified", "additions": 72, "deletions": 229, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibrustpkg%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibrustpkg%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcryptoutil.rs?ref=ca132006a0875bb373c780f32f6aea4fd94ffbf0", "patch": "@@ -8,22 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::{One, Zero, CheckedAdd};\n+use std::num::{Zero, CheckedAdd};\n use std::vec::bytes::{MutableByteVector, copy_memory};\n \n \n-/// Write a u64 into a vector, which must be 8 bytes long. The value is written in big-endian\n-/// format.\n-pub fn write_u64_be(dst: &mut[u8], input: u64) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be64;\n-    assert!(dst.len() == 8);\n-    unsafe {\n-        let x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_be64(input as i64);\n-    }\n-}\n-\n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n pub fn write_u32_be(dst: &mut[u8], input: u32) {\n@@ -36,34 +24,6 @@ pub fn write_u32_be(dst: &mut[u8], input: u32) {\n     }\n }\n \n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in little-endian\n-/// format.\n-pub fn write_u32_le(dst: &mut[u8], input: u32) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_le32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        *x = to_le32(input as i32);\n-    }\n-}\n-\n-/// Read a vector of bytes into a vector of u64s. The values are read in big-endian format.\n-pub fn read_u64v_be(dst: &mut[u64], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_be64;\n-    assert!(dst.len() * 8 == input.len());\n-    unsafe {\n-        let mut x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i64 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_be64(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     use std::cast::transmute;\n@@ -80,22 +40,6 @@ pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     }\n }\n \n-/// Read a vector of bytes into a vector of u32s. The values are read in little-endian format.\n-pub fn read_u32v_le(dst: &mut[u32], input: &[u8]) {\n-    use std::cast::transmute;\n-    use std::unstable::intrinsics::to_le32;\n-    assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n-        let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n-            *x = to_le32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n-    }\n-}\n-\n \n trait ToBits {\n     /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n@@ -124,51 +68,6 @@ pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     }\n }\n \n-/// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n-/// the high order value. fail!() if this would cause numeric overflow.\n-pub fn add_bytes_to_bits_tuple\n-        <T: Int + Unsigned + CheckedAdd + ToBits>\n-        (bits: (T, T), bytes: T) -> (T, T) {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-    let (hi, low) = bits;\n-\n-    // Add the low order value - if there is no overflow, then add the high order values\n-    // If the addition of the low order values causes overflow, add one to the high order values\n-    // before adding them.\n-    match low.checked_add(&new_low_bits) {\n-        Some(x) => {\n-            if new_high_bits == Zero::zero() {\n-                // This is the fast path - every other alternative will rarely occur in practice\n-                // considering how large an input would need to be for those paths to be used.\n-                return (hi, x);\n-            } else {\n-                match hi.checked_add(&new_high_bits) {\n-                    Some(y) => return (y, x),\n-                    None => fail!(\"Numeric overflow occured.\")\n-                }\n-            }\n-        },\n-        None => {\n-            let one: T = One::one();\n-            let z = match new_high_bits.checked_add(&one) {\n-                Some(w) => w,\n-                None => fail!(\"Numeric overflow occured.\")\n-            };\n-            match hi.checked_add(&z) {\n-                // This re-executes the addition that was already performed earlier when overflow\n-                // occured, this time allowing the overflow to happen. Technically, this could be\n-                // avoided by using the checked add intrinsic directly, but that involves using\n-                // unsafe code and is not really worthwhile considering how infrequently code will\n-                // run in practice. This is the reason that this function requires that the type T\n-                // be Unsigned - overflow is not defined for Signed types. This function could be\n-                // implemented for signed types as well if that were needed.\n-                Some(y) => return (y, low + new_low_bits),\n-                None => fail!(\"Numeric overflow occured.\")\n-            }\n-        }\n-    }\n-}\n-\n \n /// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n /// must be processed. The input() method takes care of processing and then clearing the buffer\n@@ -204,83 +103,6 @@ pub trait FixedBuffer {\n     fn size(&self) -> uint;\n }\n \n-macro_rules! impl_fixed_buffer( ($name:ident, $size:expr) => (\n-    impl FixedBuffer for $name {\n-        fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n-            let mut i = 0;\n-\n-            // FIXME: #6304 - This local variable shouldn't be necessary.\n-            let size = $size;\n-\n-            // If there is already data in the buffer, copy as much as we can into it and process\n-            // the data if the buffer becomes full.\n-            if self.buffer_idx != 0 {\n-                let buffer_remaining = size - self.buffer_idx;\n-                if input.len() >= buffer_remaining {\n-                        copy_memory(\n-                            self.buffer.mut_slice(self.buffer_idx, size),\n-                            input.slice_to(buffer_remaining),\n-                            buffer_remaining);\n-                    self.buffer_idx = 0;\n-                    func(self.buffer);\n-                    i += buffer_remaining;\n-                } else {\n-                    copy_memory(\n-                        self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                        input,\n-                        input.len());\n-                    self.buffer_idx += input.len();\n-                    return;\n-                }\n-            }\n-\n-            // While we have at least a full buffer size chunks's worth of data, process that data\n-            // without copying it into the buffer\n-            while input.len() - i >= size {\n-                func(input.slice(i, i + size));\n-                i += size;\n-            }\n-\n-            // Copy any input data into the buffer. At this point in the method, the ammount of\n-            // data left in the input vector will be less than the buffer size and the buffer will\n-            // be empty.\n-            let input_remaining = input.len() - i;\n-            copy_memory(\n-                self.buffer.mut_slice(0, input_remaining),\n-                input.slice_from(i),\n-                input.len() - i);\n-            self.buffer_idx += input_remaining;\n-        }\n-\n-        fn reset(&mut self) {\n-            self.buffer_idx = 0;\n-        }\n-\n-        fn zero_until(&mut self, idx: uint) {\n-            assert!(idx >= self.buffer_idx);\n-            self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n-            self.buffer_idx = idx;\n-        }\n-\n-        fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n-            self.buffer_idx += len;\n-            return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n-        }\n-\n-        fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-            assert!(self.buffer_idx == $size);\n-            self.buffer_idx = 0;\n-            return self.buffer.slice_to($size);\n-        }\n-\n-        fn position(&self) -> uint { self.buffer_idx }\n-\n-        fn remaining(&self) -> uint { $size - self.buffer_idx }\n-\n-        fn size(&self) -> uint { $size }\n-    }\n-))\n-\n \n /// A fixed size buffer of 64 bytes useful for cryptographic operations.\n pub struct FixedBuffer64 {\n@@ -298,25 +120,80 @@ impl FixedBuffer64 {\n     }\n }\n \n-impl_fixed_buffer!(FixedBuffer64, 64)\n+impl FixedBuffer for FixedBuffer64 {\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+        let mut i = 0;\n \n-/// A fixed size buffer of 128 bytes useful for cryptographic operations.\n-pub struct FixedBuffer128 {\n-    priv buffer: [u8, ..128],\n-    priv buffer_idx: uint,\n-}\n+        // FIXME: #6304 - This local variable shouldn't be necessary.\n+        let size = 64;\n \n-impl FixedBuffer128 {\n-    /// Create a new buffer\n-    pub fn new() -> FixedBuffer128 {\n-        return FixedBuffer128 {\n-            buffer: [0u8, ..128],\n-            buffer_idx: 0\n-        };\n+        // If there is already data in the buffer, copy as much as we can into it and process\n+        // the data if the buffer becomes full.\n+        if self.buffer_idx != 0 {\n+            let buffer_remaining = size - self.buffer_idx;\n+            if input.len() >= buffer_remaining {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining),\n+                        buffer_remaining);\n+                self.buffer_idx = 0;\n+                func(self.buffer);\n+                i += buffer_remaining;\n+            } else {\n+                copy_memory(\n+                    self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                    input,\n+                    input.len());\n+                self.buffer_idx += input.len();\n+                return;\n+            }\n+        }\n+\n+        // While we have at least a full buffer size chunks's worth of data, process that data\n+        // without copying it into the buffer\n+        while input.len() - i >= size {\n+            func(input.slice(i, i + size));\n+            i += size;\n+        }\n+\n+        // Copy any input data into the buffer. At this point in the method, the ammount of\n+        // data left in the input vector will be less than the buffer size and the buffer will\n+        // be empty.\n+        let input_remaining = input.len() - i;\n+        copy_memory(\n+            self.buffer.mut_slice(0, input_remaining),\n+            input.slice_from(i),\n+            input.len() - i);\n+        self.buffer_idx += input_remaining;\n+    }\n+\n+    fn reset(&mut self) {\n+        self.buffer_idx = 0;\n+    }\n+\n+    fn zero_until(&mut self, idx: uint) {\n+        assert!(idx >= self.buffer_idx);\n+        self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+        self.buffer_idx = idx;\n+    }\n+\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+        self.buffer_idx += len;\n+        return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n     }\n-}\n \n-impl_fixed_buffer!(FixedBuffer128, 128)\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+        assert!(self.buffer_idx == 64);\n+        self.buffer_idx = 0;\n+        return self.buffer.slice_to(64);\n+    }\n+\n+    fn position(&self) -> uint { self.buffer_idx }\n+\n+    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+\n+    fn size(&self) -> uint { 64 }\n+}\n \n \n /// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n@@ -351,7 +228,7 @@ pub mod test {\n     use std::vec;\n     use extra::hex::FromHex;\n \n-    use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n+    use cryptoutil::add_bytes_to_bits;\n     use digest::Digest;\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -391,38 +268,4 @@ pub mod test {\n     fn test_add_bytes_to_bits_overflow() {\n         add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n     }\n-\n-    // A normal addition - no overflow occurs (fast path)\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, 100), 10) == (5, 180));\n-    }\n-\n-    // The low order value overflows into the high order value\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok2() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, Bounded::max_value()), 1) == (6, 7));\n-    }\n-\n-    // The value to add is too large to be converted into bits without overflowing its type\n-    #[test]\n-    fn test_add_bytes_to_bits_tuple_ok3() {\n-        assert!(add_bytes_to_bits_tuple::<u64>((5, 0), 0x4000000000000001) == (7, 8));\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_tuple_overflow() {\n-        add_bytes_to_bits_tuple::<u64>((Bounded::max_value(), Bounded::max_value()), 1);\n-    }\n-\n-    // The value to add is too large to convert to bytes without overflowing its type, but the high\n-    // order value from this conversion overflows when added to the existing high order value\n-    #[test]\n-    #[should_fail]\n-    fn test_add_bytes_to_bits_tuple_overflow2() {\n-        let value: u64 = Bounded::max_value();\n-        add_bytes_to_bits_tuple::<u64>((value - 1, 0), 0x8000000000000000);\n-    }\n }"}, {"sha": "229eecffbea0531fcc16126f7e296b1ff16828f4", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=ca132006a0875bb373c780f32f6aea4fd94ffbf0", "patch": "@@ -18,7 +18,7 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[feature(globs, managed_boxes, macro_rules)];\n+#[feature(globs, managed_boxes)];\n \n extern mod extra;\n extern mod rustc;"}]}