{"sha": "54d1c50c7e7b4c4c7dca6c85c6965c886922b449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZDFjNTBjN2U3YjRjNGM3ZGNhNmM4NWM2OTY1Yzg4NjkyMmI0NDk=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-25T05:41:40Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-25T23:59:35Z"}, "message": "Remove `sip::Hasher::short_write`.\n\n`sip::Hasher::short_write` is currently unused. It is called by\n`sip::Hasher::write_{u8,usize}`, but those methods are also unused,\nbecause `DefaultHasher`, `SipHasher` and `SipHasher13` don't implement\nany of the `write_xyz` methods, so all their write operations end up\ncalling `sip::Hasher::write`.\n\n(I confirmed this by inserting a `panic!` in `sip::Hasher::short_write`\nand running the tests -- they all passed.)\n\nThe alternative would be to add all the missing `write_xyz` methods.\nThis does give some significant speed-ups, but it hurts compile times a\nlittle in some cases. See #69152 for details. This commit does the\nconservative thing and doesn't change existing behaviour.", "tree": {"sha": "547c9738b4ccd10f9d3d44f40584b16d79779d4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/547c9738b4ccd10f9d3d44f40584b16d79779d4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54d1c50c7e7b4c4c7dca6c85c6965c886922b449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54d1c50c7e7b4c4c7dca6c85c6965c886922b449", "html_url": "https://github.com/rust-lang/rust/commit/54d1c50c7e7b4c4c7dca6c85c6965c886922b449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54d1c50c7e7b4c4c7dca6c85c6965c886922b449/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f395de642e8be7bcbbd2bd8aaadab715851f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f395de642e8be7bcbbd2bd8aaadab715851f49", "html_url": "https://github.com/rust-lang/rust/commit/b1f395de642e8be7bcbbd2bd8aaadab715851f49"}], "stats": {"total": 53, "additions": 7, "deletions": 46}, "files": [{"sha": "c3d0c024e1b3fd8b765bcf856d0210a78eccb247", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/54d1c50c7e7b4c4c7dca6c85c6965c886922b449/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d1c50c7e7b4c4c7dca6c85c6965c886922b449/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=54d1c50c7e7b4c4c7dca6c85c6965c886922b449", "patch": "@@ -220,37 +220,6 @@ impl<S: Sip> Hasher<S> {\n         self.state.v3 = self.k1 ^ 0x7465646279746573;\n         self.ntail = 0;\n     }\n-\n-    // Specialized write function that is only valid for buffers with len <= 8.\n-    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n-    // except for composite types (that includes slices and str hashing because of delimiter).\n-    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n-    // degrading performance substantially for the most common use cases.\n-    #[inline]\n-    fn short_write(&mut self, msg: &[u8]) {\n-        debug_assert!(msg.len() <= 8);\n-        let length = msg.len();\n-        self.length += length;\n-\n-        let needed = 8 - self.ntail;\n-        let fill = cmp::min(length, needed);\n-        if fill == 8 {\n-            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n-        } else {\n-            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n-            if length < needed {\n-                self.ntail += length;\n-                return;\n-            }\n-        }\n-        self.state.v3 ^= self.tail;\n-        S::c_rounds(&mut self.state);\n-        self.state.v0 ^= self.tail;\n-\n-        // Buffered tail is now flushed, process new input.\n-        self.ntail = length - needed;\n-        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -280,21 +249,13 @@ impl super::Hasher for SipHasher13 {\n }\n \n impl<S: Sip> super::Hasher for Hasher<S> {\n-    // see short_write comment for explanation\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        let bytes = unsafe {\n-            crate::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n-        };\n-        self.short_write(bytes);\n-    }\n-\n-    // see short_write comment for explanation\n-    #[inline]\n-    fn write_u8(&mut self, i: u8) {\n-        self.short_write(&[i]);\n-    }\n-\n+    // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n+    // for this type. We could add them, copy the `short_write` implementation\n+    // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n+    // methods to `SipHasher`, `SipHasher13`, and `DefaultHasher`. This would\n+    // greatly speed up integer hashing by those hashers, at the cost of\n+    // slightly slowing down compile speeds on some benchmarks. See #69152 for\n+    // details.\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();"}]}