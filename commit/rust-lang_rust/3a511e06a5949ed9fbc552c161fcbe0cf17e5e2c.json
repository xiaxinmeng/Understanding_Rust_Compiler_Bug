{"sha": "3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTExZTA2YTU5NDllZDlmYmM1NTJjMTYxZmNiZTBjZjE3ZTVlMmM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-09-03T10:43:05Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-20T13:36:24Z"}, "message": "Only consider yields coming after the expressions when computing generator interiors", "tree": {"sha": "ad23a50f1013e9b7300b6d5f9441fc8b90baa5e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad23a50f1013e9b7300b6d5f9441fc8b90baa5e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "html_url": "https://github.com/rust-lang/rust/commit/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e6ec9f33a82886e45d2fd9abb4eddaf15496920", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6ec9f33a82886e45d2fd9abb4eddaf15496920", "html_url": "https://github.com/rust-lang/rust/commit/1e6ec9f33a82886e45d2fd9abb4eddaf15496920"}], "stats": {"total": 118, "additions": 85, "deletions": 33}, "files": [{"sha": "c2d178e2207c253e351e951d3283cf1968e72d49", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -18,7 +18,6 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n-use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n@@ -250,8 +249,9 @@ pub struct ScopeTree {\n     closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n \n     /// If there are any `yield` nested within a scope, this map\n-    /// stores the `Span` of the first one.\n-    yield_in_scope: FxHashMap<Scope, Span>,\n+    /// stores the `Span` of the last one and the number of expressions\n+    /// which came before it in a generator body.\n+    yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -274,6 +274,9 @@ pub struct Context {\n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    // The number of expressions visited in the current body\n+    expr_count: usize,\n+\n     // Generated scope tree:\n     scope_tree: ScopeTree,\n \n@@ -611,8 +614,9 @@ impl<'tcx> ScopeTree {\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n-    /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<Span> {\n+    /// returns `Some((span, expr_count))` with the span of a yield we found and\n+    /// the number of expressions appearing before the `yield` in the body.\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<(Span, usize)> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n }\n@@ -738,6 +742,8 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n+    visitor.expr_count += 1;\n+\n     let prev_cx = visitor.cx;\n     visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n \n@@ -808,14 +814,8 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 // Mark this expr's scope and all parent scopes as containing `yield`.\n                 let mut scope = Scope::Node(expr.hir_id.local_id);\n                 loop {\n-                    match visitor.scope_tree.yield_in_scope.entry(scope) {\n-                        // Another `yield` has already been found.\n-                        Entry::Occupied(_) => break,\n-\n-                        Entry::Vacant(entry) => {\n-                            entry.insert(expr.span);\n-                        }\n-                    }\n+                    visitor.scope_tree.yield_in_scope.insert(scope,\n+                        (expr.span, visitor.expr_count));\n \n                     // Keep traversing up while we can.\n                     match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1120,6 +1120,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                body_id,\n                self.cx.parent);\n \n+        let outer_ec = mem::replace(&mut self.expr_count, 0);\n         let outer_cx = self.cx;\n         let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n@@ -1166,6 +1167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         }\n \n         // Restore context we had at the start.\n+        self.expr_count = outer_ec;\n         self.cx = outer_cx;\n         self.terminating_scopes = outer_ts;\n     }\n@@ -1200,6 +1202,7 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n+            expr_count: 0,\n             cx: Context {\n                 root_id: None,\n                 parent: None,"}, {"sha": "ef93e0365e66d2e7dd38c901ca90d4b602531df3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -857,7 +857,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None\n                 };\n \n-                if let Some(yield_span) = maybe_borrow_across_yield {\n+                if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n                     struct_span_err!(self.tcx.sess,\n                                      error_span,"}, {"sha": "c7971666f4444bd17f33ac3193e96366eae42e60", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Body, Pat, PatKind, Expr};\n+use rustc::hir::{self, Pat, PatKind, Expr};\n use rustc::middle::region;\n use rustc::ty::Ty;\n use std::rc::Rc;\n@@ -26,14 +26,27 @@ struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_scope_tree: Rc<region::ScopeTree>,\n+    expr_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<region::Scope>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n+        if self.fcx.tcx.sess.verbose() {\n+        let span = scope.map_or(DUMMY_SP, |s| s.span(self.fcx.tcx, &self.region_scope_tree));\n+        self.fcx.tcx.sess.span_warn(span, &format!(\"temporary scope for node id {:?}\", expr));\n+        }\n+\n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s)\n+            self.region_scope_tree.yield_in_scope(s).and_then(|(span, expr_count)| {\n+                // Check if the span in the region comes after the expression\n+                if expr_count > self.expr_count {\n+                    Some(span)\n+                } else {\n+                    None\n+                }\n+            })\n         });\n \n         if let Some(span) = live_across_yield {\n@@ -60,6 +73,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n         fcx,\n         types: FxHashMap(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+        expr_count: 0,\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -82,15 +96,14 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n    }\n }\n \n+// This visitor has to have the same visit_expr calls as RegionResolutionVisitor in\n+// librustc/middle/region.rs since `expr_count` is compared against the results\n+// there.\n impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_body(&mut self, _body: &'tcx Body) {\n-        // Closures inside are not considered part of the generator interior\n-    }\n-\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n@@ -102,7 +115,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        self.expr_count += 1;\n+\n+        if self.fcx.tcx.sess.verbose() {\n+        self.fcx.tcx.sess.span_warn(expr.span, &format!(\"node id {:?}\", expr.id));\n+        }\n+\n         let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+\n+\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n "}, {"sha": "df1a1dcebe60608cd2831a32e339c50c2d1fe15b", "filename": "src/test/run-pass/generator/borrow-in-tail-expr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-tail-expr.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    let _a = || {\n+        yield;\n+        let a = String::new();\n+        a.len()\n+    };\n+}\n\\ No newline at end of file"}, {"sha": "50981df7566f9ae8ca0b9a5065dabb7f01e0bfca", "filename": "src/test/run-pass/generator/borrow-in-yield-expr.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-yield-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-yield-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fborrow-in-yield-expr.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait, conservative_impl_trait)]\n+\n+use std::ops::Generator;\n+\n+fn bar(baz: String) -> impl Generator<Yield=(), Return=()> {\n+    move || {\n+        yield drop(&baz);\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "e22759291d1d430d544cc0a51d5314b84347d04f", "filename": "src/test/run-pass/generator/yield-in-args-rev.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fyield-in-args-rev.rs?ref=3a511e06a5949ed9fbc552c161fcbe0cf17e5e2c", "patch": "@@ -12,12 +12,10 @@\n \n fn foo(_a: (), _b: &bool) {}\n \n-// Some examples that probably *could* be accepted, but which we reject for now.\n-\n fn bar() {\n     || {\n         let b = true;\n-        foo(yield, &b); //~ ERROR\n+        foo(yield, &b);\n     };\n }\n ", "previous_filename": "src/test/ui/generator/yield-in-args-rev.rs"}, {"sha": "157f896820906fac6b5891061f6c080cf165f87d", "filename": "src/test/ui/generator/yield-in-args-rev.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e6ec9f33a82886e45d2fd9abb4eddaf15496920/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e6ec9f33a82886e45d2fd9abb4eddaf15496920/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-args-rev.stderr?ref=1e6ec9f33a82886e45d2fd9abb4eddaf15496920", "patch": "@@ -1,10 +0,0 @@\n-error[E0626]: borrow may still be in use when generator yields\n-  --> $DIR/yield-in-args-rev.rs:20:21\n-   |\n-20 |         foo(yield, &b); //~ ERROR\n-   |             -----   ^\n-   |             |\n-   |             possible yield occurs here\n-\n-error: aborting due to previous error\n-"}]}