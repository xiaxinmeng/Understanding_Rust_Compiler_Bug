{"sha": "f45c0ef51e342c552021a80ddd343b0c7175111e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NWMwZWY1MWUzNDJjNTUyMDIxYTgwZGRkMzQzYjBjNzE3NTExMWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-14T12:17:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:31Z"}, "message": "Implement \"perfect forwarding\" for HR impls (#19730).", "tree": {"sha": "d2218051fd16fdaf2e564a651def7f50d866ef2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2218051fd16fdaf2e564a651def7f50d866ef2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f45c0ef51e342c552021a80ddd343b0c7175111e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f45c0ef51e342c552021a80ddd343b0c7175111e", "html_url": "https://github.com/rust-lang/rust/commit/f45c0ef51e342c552021a80ddd343b0c7175111e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f45c0ef51e342c552021a80ddd343b0c7175111e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ca1a4b622baa8394ab19e76bef75afe680ad18", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ca1a4b622baa8394ab19e76bef75afe680ad18", "html_url": "https://github.com/rust-lang/rust/commit/c2ca1a4b622baa8394ab19e76bef75afe680ad18"}], "stats": {"total": 1175, "additions": 759, "deletions": 416}, "files": [{"sha": "f6fd9f60e5c3f666337675029dce02d35d10cb8c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -1784,9 +1784,7 @@ impl LintPass for Stability {\n                                 method_num: index,\n                                 ..\n                             }) => {\n-                                ty::trait_item(cx.tcx,\n-                                               trait_ref.def_id(),\n-                                               index).def_id()\n+                                ty::trait_item(cx.tcx, trait_ref.def_id, index).def_id()\n                             }\n                         }\n                     }"}, {"sha": "4cbb1babf9a2cbf8e9b5bc01790a8b14e78f440d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -262,7 +262,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             def: ast::DefId)\n-                            -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n+                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)"}, {"sha": "7f1df80da3c8fa9dcdf94f1cf1086a529673e8d9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -425,11 +425,11 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)\n-                            -> Option<Rc<ty::PolyTraitRef<'tcx>>>\n+                            -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        Rc::new(ty::Binder(doc_trait_ref(tp, tcx, cdata)))\n+        Rc::new(doc_trait_ref(tp, tcx, cdata))\n     })\n }\n "}, {"sha": "69fbd59fd924142ae2dd9d26d33515b8a098aab4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -887,7 +887,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &p.trait_ref.0))\n+                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n@@ -901,7 +901,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &o.trait_ref.0))\n+                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n                                 Ok(this.emit_def_id(o.object_trait_id))\n@@ -1457,7 +1457,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 ty::MethodParam {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_poly_trait_ref(dcx))\n+                                            Ok(this.read_trait_ref(dcx))\n                                         }).unwrap()\n                                     },\n                                     method_num: {\n@@ -1475,7 +1475,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 ty::MethodObject {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n-                                            Ok(this.read_poly_trait_ref(dcx))\n+                                            Ok(this.read_trait_ref(dcx))\n                                         }).unwrap()\n                                     },\n                                     object_trait_id: {"}, {"sha": "939775e7507130eeec8b011f904d370eb5beb696", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         ..\n                     }) => {\n                         let trait_item = ty::trait_item(self.tcx,\n-                                                        trait_ref.def_id(),\n+                                                        trait_ref.def_id,\n                                                         index);\n                         match trait_item {\n                             ty::MethodTraitItem(method) => {"}, {"sha": "901944cd0168e2b0d90c8285f7d95e6291c252f2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -265,7 +265,7 @@ impl OverloadedCallType {\n             }\n             Some(ref trait_ref) => (*trait_ref).clone(),\n         };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id())\n+        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n     }\n \n     fn from_unboxed_closure(tcx: &ty::ctxt, closure_did: ast::DefId)\n@@ -292,7 +292,7 @@ impl OverloadedCallType {\n             }\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id())\n+                OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n             }\n         }\n     }"}, {"sha": "b4c1c0b396b64ceb15284e4662ca500b36be8fac", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -395,7 +395,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n         }\n     }\n \n@@ -1647,6 +1648,16 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n+                   -> Rc<ty::TraitRef<'tcx>> {\n+        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::trait_ref_contains_error(&**self)\n+    }\n+}\n+\n impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> Rc<ty::PolyTraitRef<'tcx>> {"}, {"sha": "ab0f98ec74a7fe9e8e0bdf4f1973081840f5f466", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -219,7 +219,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 self.infcx().resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n \n-            // Generalize the regions appearing in fn_ty0 if possible\n+            // Generalize the regions appearing in result0 if possible\n             let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n             let span = self.trace().origin.span();\n             let result1 =\n@@ -358,7 +358,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T : Combineable<'tcx>,\n           F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -414,11 +414,11 @@ impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n          *\n          * The reason is that when we walk through the subtyping\n          * algorith, we begin by replacing `'a` with a skolemized\n-         * variable `'0`. We then have `fn(_#0t) <: fn(&'0 int)`. This\n-         * can be made true by unifying `_#0t` with `&'0 int`. In the\n+         * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n+         * can be made true by unifying `_#0t` with `&'1 int`. In the\n          * process, we create a fresh variable for the skolemized\n-         * region, `'$0`, and hence we have that `_#0t == &'$0\n-         * int`. However, because `'$0` was created during the sub\n+         * region, `'$2`, and hence we have that `_#0t == &'$2\n+         * int`. However, because `'$2` was created during the sub\n          * computation, if we're not careful we will erroneously\n          * assume it is one of the transient region variables\n          * representing a lub/glb internally. Not good.\n@@ -522,3 +522,93 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n     Ok(())\n }\n+\n+/// This code converts from skolemized regions back to late-bound\n+/// regions. It works by replacing each region in the taint set of a\n+/// skolemized region with a bound-region. The bound region will be bound\n+/// by the outer-most binder in `value`; the caller must ensure that there is\n+/// such a binder and it is the right place.\n+///\n+/// This routine is only intended to be used when the leak-check has\n+/// passed; currently, it's used in the trait matching code to create\n+/// a set of nested obligations frmo an impl that matches against\n+/// something higher-ranked.  More details can be found in\n+/// `middle::traits::doc.rs`.\n+///\n+/// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n+/// -> &'a int`, and the impl:\n+///\n+///     impl<A,R> Fn<A,R> for SomethingOrOther\n+///         where A : Clone\n+///     { ... }\n+///\n+/// Here we will have replaced `'a` with a skolemized region\n+/// `'0`. This means that our substitution will be `{A=>&'0\n+/// int, R=>&'0 int}`.\n+///\n+/// When we apply the substitution to the bounds, we will wind up with\n+/// `&'0 int : Clone` as a predicate. As a last step, we then go and\n+/// replace `'0` with a late-bound region `'a`.  The depth is matched\n+/// to the depth of the predicate, in this case 1, so that the final\n+/// predicate is `for<'a> &'a int : Clone`.\n+pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                             skol_map: SkolemizationMap,\n+                             snapshot: &CombinedSnapshot,\n+                             value: &T)\n+                             -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n+\n+    debug!(\"plug_leaks(skol_map={}, value={})\",\n+           skol_map.repr(infcx.tcx),\n+           value.repr(infcx.tcx));\n+\n+    // Compute a mapping from the \"taint set\" of each skolemized\n+    // region back to the `ty::BoundRegion` that it originally\n+    // represented. Because `leak_check` passed, we know that that\n+    // these taint sets are mutually disjoint.\n+    let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+        skol_map\n+        .into_iter()\n+        .flat_map(|(skol_br, skol)| {\n+            infcx.tainted_regions(snapshot, skol)\n+                .into_iter()\n+                .map(move |tainted_region| (tainted_region, skol_br))\n+        })\n+        .collect();\n+\n+    debug!(\"plug_leaks: inv_skol_map={}\",\n+           inv_skol_map.repr(infcx.tcx));\n+\n+    // Remove any instantiated type variables from `value`; those can hide\n+    // references to regions from the `fold_regions` code below.\n+    let value = infcx.resolve_type_vars_if_possible(value);\n+\n+    // Map any skolemization byproducts back to a late-bound\n+    // region. Put that late-bound region at whatever the outermost\n+    // binder is that we encountered in `value`. The caller is\n+    // responsible for ensuring that (a) `value` contains at least one\n+    // binder and (b) that binder is the one we want to use.\n+    let result = ty_fold::fold_regions(infcx.tcx, &value, |r, current_depth| {\n+        match inv_skol_map.get(&r) {\n+            None => r,\n+            Some(br) => {\n+                // It is the responsibility of the caller to ensure\n+                // that each skolemized region appears within a\n+                // binder. In practice, this routine is only used by\n+                // trait checking, and all of the skolemized regions\n+                // appear inside predicates, which always have\n+                // binders, so this assert is satisfied.\n+                assert!(current_depth > 1);\n+\n+                ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+            }\n+        }\n+    });\n+\n+    debug!(\"plug_leaks: result={}\",\n+           result.repr(infcx.tcx));\n+\n+    result\n+}"}, {"sha": "f419f050cf5943f9b3d4cde20a1bac5809c4d93b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -137,7 +137,8 @@ impl Copy for TypeOrigin {}\n #[deriving(Clone, Show)]\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n+    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n+    PolyTraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -349,7 +350,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               b: Ty<'tcx>)\n                               -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|| {\n+    cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n@@ -362,7 +363,7 @@ pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                              a: Ty<'tcx>, b: Ty<'tcx>)\n                              -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|| {\n+    cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n@@ -634,11 +635,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n-        F: FnOnce() -> R,\n+        F: FnOnce(&CombinedSnapshot) -> R,\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         self.rollback_to(snapshot);\n         r\n     }\n@@ -683,21 +684,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn sub_trait_refs(&self,\n+                          a_is_expected: bool,\n+                          origin: TypeOrigin,\n+                          a: Rc<ty::TraitRef<'tcx>>,\n+                          b: Rc<ty::TraitRef<'tcx>>)\n+                          -> ures<'tcx>\n+    {\n+        debug!(\"sub_trait_refs({} <: {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n+        self.commit_if_ok(|| {\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+            };\n+            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n+        })\n+    }\n+\n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                origin: TypeOrigin,\n                                a: Rc<ty::PolyTraitRef<'tcx>>,\n                                b: Rc<ty::PolyTraitRef<'tcx>>)\n                                -> ures<'tcx>\n     {\n-        debug!(\"sub_trait_refs({} <: {})\",\n+        debug!(\"sub_poly_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n         self.commit_if_ok(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected,\n-                                                 a.clone(), b.clone()))\n+                values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n             self.sub(a_is_expected, trace).binders(&*a, &*b).to_ures()\n         })\n@@ -727,6 +746,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn plug_leaks<T>(&self,\n+                         skol_map: SkolemizationMap,\n+                         snapshot: &CombinedSnapshot,\n+                         value: &T)\n+                         -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    {\n+        /*! See `higher_ranked::leak_check` */\n+\n+        higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n+    }\n+\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)"}, {"sha": "8cce1321d728bdc7b9ae770f35cd219b01aaf0c9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -257,8 +257,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !is_local(tr.def_id()) ||\n-                     self.exported_items.contains(&tr.def_id().node)\n+                    !is_local(tr.def_id) ||\n+                     self.exported_items.contains(&tr.def_id.node)\n                 });\n \n                 if public_ty || public_trait {\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.def_id())\n+                                    self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a method {}\",\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.def_id())\n+                                    self.def_privacy(t.def_id)\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a typedef {}\",\n@@ -811,7 +811,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // is whether the trait itself is accessible or not.\n             MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_ref.def_id(),\n+                self.report_error(self.ensure_public(span, trait_ref.def_id,\n                                                      None, \"source trait\"));\n             }\n         }"}, {"sha": "33701905aa11098a68f963b355b728138c39d340", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -108,7 +108,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 ast::ItemTy(_, ref generics) |\n                 ast::ItemEnum(_, ref generics) |\n                 ast::ItemStruct(_, ref generics) |\n-                ast::ItemTrait(_, ref generics, _, _, _) => {\n+                ast::ItemTrait(_, ref generics, _, _, _) |\n+                ast::ItemImpl(_, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n                     let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n@@ -117,12 +118,6 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         visit::walk_item(this, item);\n                     });\n                 }\n-                ast::ItemImpl(_, ref generics, _, _, _) => {\n-                    // Impls have both early- and late-bound lifetimes.\n-                    this.visit_early_late(subst::TypeSpace, generics, |this| {\n-                        visit::walk_item(this, item);\n-                    })\n-                }\n             }\n         });\n     }"}, {"sha": "9804f6d222afde9513661697da44141411ac3ef0", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -17,7 +17,7 @@ use super::util;\n use middle::subst;\n use middle::subst::Subst;\n use middle::ty::{mod, Ty};\n-use middle::infer::{mod, InferCtxt};\n+use middle::infer::InferCtxt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n@@ -38,12 +38,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     let impl1_substs =\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n     let impl1_trait_ref =\n-        ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n-                                                   .subst(infcx.tcx, &impl1_substs);\n-    let impl1_trait_ref =\n-        infcx.replace_late_bound_regions_with_fresh_var(DUMMY_SP,\n-                                                        infer::FnCall,\n-                                                        &*impl1_trait_ref).0;\n+        (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n@@ -67,15 +62,15 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the trait is local to the crate, ok.\n-    if trait_ref.def_id().krate == ast::LOCAL_CRATE {\n+    if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n         debug!(\"trait {} is local to current crate\",\n-               trait_ref.def_id().repr(tcx));\n+               trait_ref.def_id.repr(tcx));\n         return true;\n     }\n \n     // Otherwise, at least one of the input types must be local to the\n     // crate.\n-    trait_ref.0.input_types().iter().any(|&t| ty_is_local(tcx, t))\n+    trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "213d97b4b344aecd851b8bfa1bf6387e49fc891b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -360,10 +360,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             // For now, we just check that there are no higher-ranked\n             // regions.  If there are, we will call this obligation an\n             // error. Eventually we should be able to support some\n-            // cases here, I imagine (e.g., `for<'a> &'a int : 'a`).\n-            //\n-            // TODO This is overly conservative, but good enough for\n-            // now.\n+            // cases here, I imagine (e.g., `for<'a> int : 'a`).\n             if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n                 errors.push(\n                     FulfillmentError::new("}, {"sha": "6c7ae666ae06cdc9e80f1ce9dac1f36e9316d483", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 168, "deletions": 124, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -289,7 +289,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::Equate(ref p) => {\n-                let result = self.infcx.probe(|| {\n+                let result = self.infcx.probe(|_| {\n                     self.infcx.equality_predicate(obligation.cause.span, p)\n                 });\n                 match result {\n@@ -410,13 +410,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_def_id.repr(self.tcx()),\n                obligation.repr(self.tcx()));\n \n-        self.infcx.probe(|| {\n-            match self.match_impl(impl_def_id, obligation) {\n+        self.infcx.probe(|snapshot| {\n+            let (skol_obligation_trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+            match self.match_impl(impl_def_id, obligation, snapshot,\n+                                  &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n                                                        obligation.cause,\n-                                                       obligation.recursion_depth + 1);\n+                                                       obligation.recursion_depth + 1,\n+                                                       skol_map,\n+                                                       snapshot);\n                     self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n@@ -711,8 +716,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(\n                 |bound| self.infcx.probe(\n-                    || self.match_trait_refs(obligation,\n-                                             (*bound).clone())).is_ok());\n+                    |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n             matching_bounds.map(\n@@ -819,8 +823,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let all_impls = self.all_impls(obligation.trait_ref.def_id());\n         for &impl_def_id in all_impls.iter() {\n-            self.infcx.probe(|| {\n-                match self.match_impl(impl_def_id, obligation) {\n+            self.infcx.probe(|snapshot| {\n+                let (skol_obligation_trait_ref, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                match self.match_impl(impl_def_id, obligation, snapshot,\n+                                      &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                     Ok(_) => {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n@@ -848,15 +855,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &Candidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        /*!\n-         * Further evaluate `candidate` to decide whether all type parameters match\n-         * and whether nested obligations are met. Returns true if `candidate` remains\n-         * viable after this further scrutiny.\n-         */\n-\n-        debug!(\"winnow_candidate: depth={} candidate={}\",\n-               stack.obligation.recursion_depth, candidate.repr(self.tcx()));\n-        let result = self.infcx.probe(|| {\n+        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n+        let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(Some(stack), selection),\n@@ -919,17 +919,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));\n \n-                self.infcx.probe(|| {\n+                self.infcx.probe(|snapshot| {\n+                    let (skol_obligation_trait_ref, skol_map) =\n+                        self.infcx().skolemize_late_bound_regions(\n+                            &*stack.obligation.trait_ref, snapshot);\n                     let impl_substs =\n-                        self.rematch_impl(impl_def_id, stack.obligation);\n+                        self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n+                                          &skol_map, Rc::new(skol_obligation_trait_ref));\n                     let impl_trait_ref =\n                         ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n                     let impl_trait_ref =\n                         impl_trait_ref.subst(self.tcx(), &impl_substs);\n+                    let poly_impl_trait_ref =\n+                        Rc::new(ty::Binder((*impl_trait_ref).clone()));\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n-                        .sub_poly_trait_refs(false, origin, impl_trait_ref, vt.bound.clone())\n+                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, vt.bound.clone())\n                         .is_ok()\n                 })\n             }\n@@ -1400,10 +1406,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()),\n                param.repr(self.tcx()));\n \n-        let () = try!(self.confirm(obligation.cause,\n-                                   obligation.trait_ref.clone(),\n-                                   param.bound.clone()));\n-        Ok(param)\n+        // During evaluation, we already checked that this\n+        // where-clause trait-ref could be unified with the obligation\n+        // trait-ref. Repeat that unification now without any\n+        // transactional boundary; it should not fail.\n+        match self.confirm_poly_trait_refs(obligation.cause,\n+                                           obligation.trait_ref.clone(),\n+                                           param.bound.clone()) {\n+            Ok(()) => Ok(param),\n+            Err(_) => {\n+                self.tcx().sess.bug(\n+                    format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n+                            param.bound.repr(self.tcx()),\n+                            obligation.repr(self.tcx())).as_slice());\n+            }\n+        }\n     }\n \n     fn confirm_builtin_candidate(&mut self,\n@@ -1476,23 +1493,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        let substs = self.rematch_impl(impl_def_id, obligation);\n-        debug!(\"confirm_impl_candidate substs={}\", substs);\n-        Ok(self.vtable_impl(impl_def_id, substs, obligation.cause, obligation.recursion_depth + 1))\n+        self.infcx.try(|snapshot| {\n+            let (skol_obligation_trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+            let substs = self.rematch_impl(impl_def_id, obligation,\n+                                           snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n+            debug!(\"confirm_impl_candidate substs={}\", substs);\n+            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause,\n+                                obligation.recursion_depth + 1, skol_map, snapshot))\n+        })\n     }\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: ast::DefId,\n                    substs: Substs<'tcx>,\n                    cause: ObligationCause<'tcx>,\n-                   recursion_depth: uint)\n+                   recursion_depth: uint,\n+                   skol_map: infer::SkolemizationMap,\n+                   snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_impl(impl_def_id={}, substs={}, recursion_depth={}, skol_map={})\",\n+               impl_def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               recursion_depth,\n+               skol_map.repr(self.tcx()));\n+\n         let impl_predicates =\n             self.impl_predicates(cause,\n                                  recursion_depth,\n                                  impl_def_id,\n-                                 &substs);\n+                                 &substs,\n+                                 skol_map,\n+                                 snapshot);\n+\n+        debug!(\"vtable_impl: impl_def_id={} impl_predicates={}\",\n+               impl_def_id.repr(self.tcx()),\n+               impl_predicates.repr(self.tcx()));\n+\n         VtableImplData { impl_def_id: impl_def_id,\n                          substs: substs,\n                          nested: impl_predicates }\n@@ -1535,10 +1573,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: substs,\n         }));\n \n-        let () =\n-            try!(self.confirm(obligation.cause,\n-                              obligation.trait_ref.clone(),\n-                              trait_ref));\n+        try!(self.confirm_poly_trait_refs(obligation.cause,\n+                                          obligation.trait_ref.clone(),\n+                                          trait_ref));\n \n         Ok(self_ty)\n     }\n@@ -1582,9 +1619,52 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n-        self.confirm(obligation.cause,\n-                     obligation.trait_ref.clone(),\n-                     trait_ref)\n+        self.confirm_poly_trait_refs(obligation.cause,\n+                                     obligation.trait_ref.clone(),\n+                                     trait_ref)\n+    }\n+\n+    /// In the case of unboxed closure types and fn pointers,\n+    /// we currently treat the input type parameters on the trait as\n+    /// outputs. This means that when we have a match we have only\n+    /// considered the self type, so we have to go back and make sure\n+    /// to relate the argument types too.  This is kind of wrong, but\n+    /// since we control the full set of impls, also not that wrong,\n+    /// and it DOES yield better error messages (since we don't report\n+    /// errors as if there is no applicable impl, but rather report\n+    /// errors are about mismatched argument types.\n+    ///\n+    /// Here is an example. Imagine we have an unboxed closure expression\n+    /// and we desugared it so that the type of the expression is\n+    /// `Closure`, and `Closure` expects an int as argument. Then it\n+    /// is \"as if\" the compiler generated this impl:\n+    ///\n+    ///     impl Fn(int) for Closure { ... }\n+    ///\n+    /// Now imagine our obligation is `Fn(uint) for Closure`. So far\n+    /// we have matched the self-type `Closure`. At this point we'll\n+    /// compare the `int` to `uint` and generate an error.\n+    ///\n+    /// Note that this checking occurs *after* the impl has selected,\n+    /// because these output type parameters should not affect the\n+    /// selection of the impl. Therefore, if there is a mismatch, we\n+    /// report an error to the user.\n+    fn confirm_poly_trait_refs(&mut self,\n+                               obligation_cause: ObligationCause,\n+                               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+                               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                               -> Result<(), SelectionError<'tcx>>\n+    {\n+        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n+\n+        let obligation_trait_ref = obligation_trait_ref.clone();\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             expected_trait_ref.clone(),\n+                                             obligation_trait_ref.clone()) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1599,10 +1679,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn rematch_impl(&mut self,\n                     impl_def_id: ast::DefId,\n-                    obligation: &TraitObligation<'tcx>)\n+                    obligation: &TraitObligation<'tcx>,\n+                    snapshot: &infer::CombinedSnapshot,\n+                    skol_map: &infer::SkolemizationMap,\n+                    skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n                     -> Substs<'tcx>\n     {\n-        match self.match_impl(impl_def_id, obligation) {\n+        match self.match_impl(impl_def_id, obligation, snapshot,\n+                              skol_map, skol_obligation_trait_ref) {\n             Ok(substs) => {\n                 substs\n             }\n@@ -1618,11 +1702,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_impl(&mut self,\n                   impl_def_id: ast::DefId,\n-                  obligation: &TraitObligation<'tcx>)\n+                  obligation: &TraitObligation<'tcx>,\n+                  snapshot: &infer::CombinedSnapshot,\n+                  skol_map: &infer::SkolemizationMap,\n+                  skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n                   -> Result<Substs<'tcx>, ()>\n     {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n-                                                impl_def_id).unwrap();\n+        let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n@@ -1638,15 +1724,42 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n \n-        match self.match_trait_refs(obligation, impl_trait_ref) {\n-            Ok(()) => Ok(impl_substs),\n-            Err(()) => Err(())\n+        debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n+               impl_trait_ref={}, skol_obligation_trait_ref={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation.repr(self.tcx()),\n+               impl_trait_ref.repr(self.tcx()),\n+               skol_obligation_trait_ref.repr(self.tcx()));\n+\n+        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        match self.infcx.sub_trait_refs(false,\n+                                        origin,\n+                                        impl_trait_ref,\n+                                        skol_obligation_trait_ref) {\n+            Ok(()) => { }\n+            Err(e) => {\n+                debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n+                       ty::type_err_to_str(self.tcx(), &e));\n+                return Err(());\n+            }\n+        }\n+\n+        match self.infcx.leak_check(skol_map, snapshot) {\n+            Ok(()) => { }\n+            Err(e) => {\n+                debug!(\"match_impl: failed leak check due to `{}`\",\n+                       ty::type_err_to_str(self.tcx(), &e));\n+                return Err(());\n+            }\n         }\n+\n+        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n+        Ok(impl_substs)\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n                               obligation: &TraitObligation,\n-                              impl_trait_ref: &ty::PolyTraitRef)\n+                              impl_trait_ref: &ty::TraitRef)\n                               -> bool\n     {\n         // We can avoid creating type variables and doing the full\n@@ -1667,19 +1780,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n-    fn match_trait_refs(&mut self,\n-                        obligation: &TraitObligation<'tcx>,\n-                        trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+    fn match_where_clause(&mut self,\n+                          obligation: &TraitObligation<'tcx>,\n+                          where_clause_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n-        debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n+        debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n                obligation.repr(self.tcx()),\n-               trait_ref.repr(self.tcx()));\n+               where_clause_trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n-                                             trait_ref,\n+                                             where_clause_trait_ref,\n                                              obligation.trait_ref.clone()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n@@ -1754,78 +1867,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // Confirmation\n-    //\n-    // The final step of selection: once we know how an obligation is\n-    // is resolved, we confirm that selection in order to have\n-    // side-effects on the typing environment. This step also unifies\n-    // the output type parameters from the obligation with those found\n-    // on the impl/bound, which may yield type errors.\n-\n-    /// Relates the output type parameters from an impl to the\n-    /// trait.  This may lead to type errors. The confirmation step\n-    /// is separated from the main match procedure because these\n-    /// type errors do not cause us to select another impl.\n-    ///\n-    /// As an example, consider matching the obligation\n-    /// `Iterator<char> for Elems<int>` using the following impl:\n-    ///\n-    ///    impl<T> Iterator<T> for Elems<T> { ... }\n-    ///\n-    /// The match phase will succeed with substitution `T=int`.\n-    /// The confirm step will then try to unify `int` and `char`\n-    /// and yield an error.\n-    fn confirm_impl_vtable(&mut self,\n-                           impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause<'tcx>,\n-                           obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                           substs: &Substs<'tcx>)\n-                           -> Result<(), SelectionError<'tcx>>\n-    {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n-                                                impl_def_id).unwrap();\n-        let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n-                                                  substs);\n-        self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n-    }\n-\n-    /// After we have determined which impl applies, and with what substitutions, there is one last\n-    /// step. We have to go back and relate the \"output\" type parameters from the obligation to the\n-    /// types that are specified in the impl.\n-    ///\n-    /// For example, imagine we have:\n-    ///\n-    ///     impl<T> Iterator<T> for Vec<T> { ... }\n-    ///\n-    /// and our obligation is `Iterator<Foo> for Vec<int>` (note the mismatch in the obligation\n-    /// types). Up until this step, no error would be reported: the self type is `Vec<int>`, and\n-    /// that matches `Vec<T>` with the substitution `T=int`. At this stage, we could then go and\n-    /// check that the type parameters to the `Iterator` trait match. (In terms of the parameters,\n-    /// the `expected_trait_ref` here would be `Iterator<int> for Vec<int>`, and the\n-    /// `obligation_trait_ref` would be `Iterator<Foo> for Vec<int>`.\n-    ///\n-    /// Note that this checking occurs *after* the impl has selected, because these output type\n-    /// parameters should not affect the selection of the impl. Therefore, if there is a mismatch,\n-    /// we report an error to the user.\n-    fn confirm(&mut self,\n-               obligation_cause: ObligationCause,\n-               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n-               -> Result<(), SelectionError<'tcx>>\n-    {\n-        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n-\n-        let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             expected_trait_ref.clone(),\n-                                             obligation_trait_ref.clone()) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n@@ -1857,11 +1898,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                        cause: ObligationCause<'tcx>,\n                        recursion_depth: uint,\n                        impl_def_id: ast::DefId,\n-                       impl_substs: &Substs<'tcx>)\n+                       impl_substs: &Substs<'tcx>,\n+                       skol_map: infer::SkolemizationMap,\n+                       snapshot: &infer::CombinedSnapshot)\n                        -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n+        let bounds = self.infcx().plug_leaks(skol_map, snapshot, &bounds);\n         util::predicates_for_generics(self.tcx(), cause, recursion_depth, &bounds)\n     }\n "}, {"sha": "ee56d919fefc7159aad7e25c63d4e64e789e5903", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -478,8 +478,10 @@ pub enum MethodOrigin<'tcx> {\n #[deriving(Clone, Show)]\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n-    // be a supertrait of what the user actually typed.\n-    pub trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+    // be a supertrait of what the user actually typed. Note that it\n+    // never contains bound regions; those regions should have been\n+    // instantiated with fresh variables at this point.\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n@@ -489,7 +491,7 @@ pub struct MethodParam<'tcx> {\n #[deriving(Clone, Show)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -665,7 +667,7 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::PolyTraitRef<'tcx>>>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n \n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n@@ -1306,7 +1308,7 @@ pub enum sty<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n     // Principal trait reference.\n-    pub principal: PolyTraitRef<'tcx>, // would use Rc<TraitRef>, but it runs afoul of some static rules\n+    pub principal: PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds\n }\n \n@@ -1315,7 +1317,9 @@ impl<'tcx> TyTrait<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>) -> Rc<ty::PolyTraitRef<'tcx>> {\n+    pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>)\n+                                            -> Rc<ty::PolyTraitRef<'tcx>>\n+    {\n         Rc::new(ty::Binder(ty::TraitRef {\n             def_id: self.principal.def_id(),\n             substs: self.principal.substs().with_self_ty(self_ty),\n@@ -4818,7 +4822,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n }\n \n pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n-                            -> Option<Rc<PolyTraitRef<'tcx>>> {\n+                            -> Option<Rc<TraitRef<'tcx>>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n@@ -4828,9 +4832,8 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                         ast::ItemImpl(_, _, ref opt_trait, _, _) => {\n                             match opt_trait {\n                                 &Some(ref t) => {\n-                                    let trait_ref =\n-                                        (*ty::node_id_to_trait_ref(cx, t.ref_id)).clone();\n-                                    Some(Rc::new(ty::Binder(trait_ref)))\n+                                    let trait_ref = ty::node_id_to_trait_ref(cx, t.ref_id);\n+                                    Some(trait_ref)\n                                 }\n                                 &None => None\n                             }\n@@ -5736,7 +5739,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         // Record the trait->implementation mappings, if applicable.\n         let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n         for trait_ref in associated_traits.iter() {\n-            record_trait_implementation(tcx, trait_ref.def_id(), impl_def_id);\n+            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -6432,26 +6435,24 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n     debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n \n     let mut map = FnvHashMap::new();\n-    let value = {\n-        let mut f = ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n-            debug!(\"region={}\", region.repr(tcx));\n-            match region {\n-                ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                    * match map.entry(br) {\n-                        Vacant(entry) => entry.set(mapf(br, debruijn)),\n-                        Occupied(entry) => entry.into_mut(),\n-                    }\n-                }\n-                _ => {\n-                    region\n+\n+    // Note: fold the field `0`, not the binder, so that late-bound\n+    // regions bound by `binder` are considered free.\n+    let value = ty_fold::fold_regions(tcx, &binder.0, |region, current_depth| {\n+        debug!(\"region={}\", region.repr(tcx));\n+        match region {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n+                * match map.entry(br) {\n+                    Vacant(entry) => entry.set(mapf(br, debruijn)),\n+                    Occupied(entry) => entry.into_mut(),\n                 }\n             }\n-        });\n+            _ => {\n+                region\n+            }\n+        }\n+    });\n \n-        // Note: fold the field `0`, not the binder, so that late-bound\n-        // regions bound by `binder` are considered free.\n-        binder.0.fold_with(&mut f)\n-    };\n     debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n     (value, map)\n }"}, {"sha": "cde0470ff48e2ce76c9ea114d82479ca16fa2d7e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -730,14 +730,17 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n /// regions (aka \"lifetimes\") that are bound within a type are not\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n-pub struct RegionFolder<'a, 'tcx: 'a, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n+\n+pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     current_depth: uint,\n-    fld_r: F,\n+    fld_r: &'a mut (FnMut(ty::Region, uint) -> ty::Region + 'a),\n }\n \n-impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: F) -> RegionFolder<'a, 'tcx, F> {\n+impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n+    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+        where F : FnMut(ty::Region, uint) -> ty::Region\n+    {\n         RegionFolder {\n             tcx: tcx,\n             current_depth: 1,\n@@ -750,15 +753,21 @@ pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> Vec<ty::Regio\n     where T : TypeFoldable<'tcx>\n {\n     let mut vec = Vec::new();\n-    {\n-        let mut folder = RegionFolder::new(tcx, |r, _| { vec.push(r); r });\n-        value.fold_with(&mut folder);\n-    }\n+    fold_regions(tcx, value, |r, _| { vec.push(r); r });\n     vec\n }\n \n-impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n-    F: FnMut(ty::Region, uint) -> ty::Region,\n+pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n+                              value: &T,\n+                              mut f: F)\n+                              -> T\n+    where F : FnMut(ty::Region, uint) -> ty::Region,\n+          T : TypeFoldable<'tcx>,\n+{\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut f))\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n@@ -780,7 +789,7 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n             _ => {\n                 debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n                        r.repr(self.tcx()), self.current_depth);\n-                (self.fld_r)(r, self.current_depth)\n+                self.fld_r.call_mut((r, self.current_depth))\n             }\n         }\n     }\n@@ -836,7 +845,7 @@ pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, |region, _current_depth| {\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)\n     }))\n }"}, {"sha": "1a4f06663ef3b694089e7ea544022df20ea6056b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -941,14 +941,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ty::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mp.trait_ref.def_id(),\n+                                                mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n             ty::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n-                                                mo.trait_ref.def_id(),\n+                                                mo.trait_ref.def_id,\n                                                 mo.method_num);\n                 (None, Some(trait_item.def_id()))\n             }"}, {"sha": "f8303a6f030809effcfc022516fb2a46eb022dcb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -421,12 +421,11 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let poly_trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n-                    let trait_ref = ty::erase_late_bound_regions(tcx, &*poly_trait_ref);\n+                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n+                        ty::make_substs_for_receiver_types(tcx, &*trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them"}, {"sha": "f1c3c9be396af0c93d7d4a17f729b51bf22080ea", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -133,14 +133,14 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             method_num\n         }) => {\n             let trait_ref =\n-                Rc::new(trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs));\n+                Rc::new(ty::Binder((**trait_ref).subst(bcx.tcx(), bcx.fcx.param_substs)));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={} trait_ref={}\",\n                    method_call,\n                    trait_ref.repr(bcx.tcx()));\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n-                                            (*trait_ref).clone());\n+                                            trait_ref.clone());\n             debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n             trans_monomorphized_callee(bcx, method_call, trait_ref.def_id(),\n                                        method_num, origin)\n@@ -618,7 +618,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n-        Some(t_id) => t_id.def_id(),\n+        Some(t_id) => t_id.def_id,\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n                                       make a vtable for a type impl!\")\n     };"}, {"sha": "4f4bebabead2cf538ed1228faeb71adb8611dcbb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -53,8 +53,7 @@ use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n-use middle::ty::{mod, Ty};\n-use middle::ty_fold;\n+use middle::ty::{mod, RegionEscape, Ty};\n use rscope::{mod, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n@@ -533,7 +532,8 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     -> Rc<ty::PolyTraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n-    let trait_ref = instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n+    let trait_ref =\n+        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n     let trait_ref = (*trait_ref).clone();\n     Rc::new(ty::Binder(trait_ref)) // Ugh.\n }\n@@ -1200,10 +1200,9 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let (self_ty, mut implied_output_region) = match opt_self_info {\n         None => (None, None),\n         Some(self_info) => {\n-            // Shift regions in the self type by 1 to account for the binding\n-            // level introduced by the function itself.\n-            let untransformed_self_ty =\n-                ty_fold::shift_regions(this.tcx(), 1, &self_info.untransformed_self_ty);\n+            // This type comes from an impl or trait; no late-bound\n+            // regions should be present.\n+            assert!(!self_info.untransformed_self_ty.has_escaping_regions());\n \n             // Figure out and record the explicit self category.\n             let explicit_self_category =\n@@ -1214,19 +1213,19 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                     (None, None)\n                 }\n                 ty::ByValueExplicitSelfCategory => {\n-                    (Some(untransformed_self_ty), None)\n+                    (Some(self_info.untransformed_self_ty), None)\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(ty::mk_rptr(this.tcx(),\n                                       region,\n                                       ty::mt {\n-                                        ty: untransformed_self_ty,\n+                                        ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability\n                                       })),\n                      Some(region))\n                 }\n                 ty::ByBoxExplicitSelfCategory => {\n-                    (Some(ty::mk_uniq(this.tcx(), untransformed_self_ty)), None)\n+                    (Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty)), None)\n                 }\n             }\n         }"}, {"sha": "2c220f298262fdb40d603809c818da0ae8e31f0a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -222,17 +222,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     // argument type), but those cases have already\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n-                    let original_trait_ref =\n+                    let original_poly_trait_ref =\n                         data.principal_trait_ref_with_self_ty(object_ty);\n+                    let upcast_poly_trait_ref =\n+                        this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n-                        this.upcast(original_trait_ref.clone(), trait_def_id);\n-                    debug!(\"original_trait_ref={} upcast_trait_ref={} target_trait={}\",\n-                           original_trait_ref.repr(this.tcx()),\n+                        this.replace_late_bound_regions_with_fresh_var(&*upcast_poly_trait_ref);\n+                    debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n+                           original_poly_trait_ref.repr(this.tcx()),\n                            upcast_trait_ref.repr(this.tcx()),\n                            trait_def_id.repr(this.tcx()));\n-                    let substs = upcast_trait_ref.substs().clone();\n+                    let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: upcast_trait_ref,\n+                        trait_ref: Rc::new(upcast_trait_ref),\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n                         real_index: real_index,\n@@ -257,7 +259,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                      .subst(self.tcx(), &impl_polytype.substs);\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num });\n-                (impl_trait_ref.substs().clone(), origin)\n+                (impl_trait_ref.substs.clone(), origin)\n             }\n \n             probe::TraitPick(trait_def_id, method_num) => {\n@@ -273,16 +275,20 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  self.infcx().next_ty_var());\n \n                 let trait_ref =\n-                    Rc::new(ty::Binder(ty::TraitRef::new(trait_def_id, substs.clone())));\n+                    Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n             }\n \n-            probe::WhereClausePick(ref trait_ref, method_num) => {\n-                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref.clone(),\n+            probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n+                // Where clauses can have bound regions in them. We need to instantiate\n+                // those to convert from a poly-trait-ref to a trait-ref.\n+                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&**poly_trait_ref);\n+                let substs = trait_ref.substs.clone();\n+                let origin = MethodTypeParam(MethodParam { trait_ref: Rc::new(trait_ref),\n                                                            method_num: method_num });\n-                (trait_ref.substs().clone(), origin)\n+                (substs, origin)\n             }\n         }\n     }\n@@ -379,25 +385,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                               all_substs: subst::Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n-        // If this method comes from an impl (as opposed to a trait),\n-        // it may have late-bound regions from the impl that appear in\n-        // the substitutions, method signature, and\n-        // bounds. Instantiate those at this point. (If it comes from\n-        // a trait, this step has no effect, as there are no\n-        // late-bound regions to instantiate.)\n-        //\n-        // The binder level here corresponds to the impl.\n-        let (all_substs, (method_sig, method_generics)) =\n-            self.replace_late_bound_regions_with_fresh_var(\n-                &ty::Binder((all_substs,\n-                             (pick.method_ty.fty.sig.clone(),\n-                              pick.method_ty.generics.clone()))));\n-\n-        debug!(\"late-bound lifetimes from impl instantiated, \\\n-                all_substs={} method_sig={} method_generics={}\",\n-               all_substs.repr(self.tcx()),\n-               method_sig.repr(self.tcx()),\n-               method_generics.repr(self.tcx()));\n+        debug!(\"instantiate_method_sig(pick={}, all_substs={})\",\n+               pick.repr(self.tcx()),\n+               all_substs.repr(self.tcx()));\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed.  The only\n@@ -427,16 +417,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 all_substs.clone()\n             }\n         };\n-        let method_bounds =\n-            method_generics.to_bounds(self.tcx(), &method_bounds_substs);\n+        let method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &method_bounds_substs);\n \n         debug!(\"method_bounds after subst = {}\",\n                method_bounds.repr(self.tcx()));\n \n         // Substitute the type/early-bound-regions into the method\n         // signature. In addition, the method signature may bind\n         // late-bound regions, so instantiate those.\n-        let method_sig = method_sig.subst(self.tcx(), &all_substs);\n+        let method_sig = pick.method_ty.fty.sig.subst(self.tcx(), &all_substs);\n         let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n \n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\","}, {"sha": "ffaeceb3eed11a84111fb991ebfd02f9120f6f03", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -166,12 +166,13 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n-    let trait_ref = Rc::new(ty::Binder(ty::TraitRef::new(trait_def_id, substs)));\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n \n     // Construct an obligation\n+    let poly_trait_ref = Rc::new(ty::Binder((*trait_ref).clone()));\n     let obligation = traits::Obligation::misc(span,\n                                               fcx.body_id,\n-                                              ty::Predicate::Trait(trait_ref.clone()));\n+                                              poly_trait_ref.as_predicate());\n \n     // Now we want to know if this can be matched\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n@@ -194,11 +195,8 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n-    //\n-    // Note that as the method comes from a trait, it can only have\n-    // late-bound regions from the fn itself, not the impl.\n     let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, trait_ref.substs());\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n@@ -221,7 +219,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), trait_ref.substs());\n+    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),\n@@ -293,7 +291,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n                                             method_num: method_num}),\n         ty: fty,\n-        substs: trait_ref.substs().clone()\n+        substs: trait_ref.substs.clone()\n     };\n \n     debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n@@ -379,7 +377,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         None => format!(\"\"),\n                         Some(trait_ref) => format!(\" of the trait `{}`\",\n                                                    ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id())),\n+                                                                     trait_ref.def_id)),\n                     };\n \n                     span_note!(fcx.sess(), method_span,"}, {"sha": "b5776f9aeb34ac158fece9de0fd969014ac8d620", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -19,7 +19,6 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{mod, Ty};\n-use middle::ty::{MethodObject};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -58,8 +57,8 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(MethodObject<'tcx>),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::PolyTraitRef<'tcx>>,\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n@@ -149,7 +148,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n     let mut dummy = Some((steps, opt_simplified_steps)); // FIXME(#18101) need once closures\n-    fcx.infcx().probe(|| {\n+    fcx.infcx().probe(|_| {\n         let (steps, opt_simplified_steps) = dummy.take().unwrap();\n         let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n@@ -313,12 +312,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: ObjectCandidate(MethodObject {\n-                    trait_ref: new_trait_ref,\n-                    object_trait_id: trait_ref.def_id(),\n-                    method_num: method_num,\n-                    real_index: vtable_index\n-                })\n+                kind: ObjectCandidate(new_trait_ref.def_id(), method_num, vtable_index)\n             });\n         });\n     }\n@@ -502,7 +496,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method, impl_trait_ref.substs());\n+                self.xform_self_ty(&method, &impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n@@ -748,7 +742,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                self_ty.repr(self.tcx()),\n                probe.repr(self.tcx()));\n \n-        self.infcx().probe(|| {\n+        self.infcx().probe(|_| {\n             // First check that the self type can be related.\n             match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n                 Ok(()) => { }\n@@ -1033,8 +1027,8 @@ impl<'tcx> Candidate<'tcx> {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n                 }\n-                ObjectCandidate(ref data) => {\n-                    ObjectPick(data.trait_ref.def_id(), data.method_num, data.real_index)\n+                ObjectCandidate(def_id, method_num, real_index) => {\n+                    ObjectPick(def_id, method_num, real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1059,7 +1053,7 @@ impl<'tcx> Candidate<'tcx> {\n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n             InherentImplCandidate(def_id, _) => ImplSource(def_id),\n-            ObjectCandidate(ref obj) => TraitSource(obj.trait_ref.def_id()),\n+            ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n@@ -1075,7 +1069,9 @@ impl<'tcx> Candidate<'tcx> {\n             UnboxedClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, method_num) |\n+            ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n+                Some((trait_ref.def_id, method_num))\n+            }\n             WhereClauseCandidate(ref trait_ref, method_num) => {\n                 Some((trait_ref.def_id(), method_num))\n             }\n@@ -1096,8 +1092,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n         match *self {\n             InherentImplCandidate(ref a, ref b) =>\n                 format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n-            ObjectCandidate(ref a) =>\n-                format!(\"ObjectCandidate({})\", a.repr(tcx)),\n+            ObjectCandidate(a, b, c) =>\n+                format!(\"ObjectCandidate({},{},{})\", a.repr(tcx), b, c),\n             ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n                 format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n                         c.repr(tcx), d),"}, {"sha": "9e249cc449d0749b66be3bcade9d01d55f3313bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 54, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -719,12 +719,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n-    debug!(\"fty (raw): {}\", fty.repr(ccx.tcx));\n-\n-    let body_id = method.pe_body().id;\n-    let fty = liberate_late_bound_regions(\n-        ccx.tcx, CodeExtent::from_node_id(body_id), &ty::Binder(fty));\n-    debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n+    debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n                   &*method.pe_fn_decl(),\n@@ -736,11 +731,11 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n-                                            impl_trait_ref: &ty::PolyTraitRef<'tcx>,\n+                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n                                             impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n-    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id());\n+    let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n@@ -834,8 +829,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = ty::provided_trait_methods(tcx,\n-                                                      impl_trait_ref.def_id());\n+    let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n@@ -894,37 +888,16 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl_m_span: Span,\n                              impl_m_body_id: ast::NodeId,\n                              trait_m: &ty::Method<'tcx>,\n-                             impl_trait_ref: &ty::PolyTraitRef<'tcx>) {\n+                             impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n-    let impl_m_body_scope = CodeExtent::from_node_id(impl_m_body_id);\n-\n-    // The impl's trait ref may bind late-bound regions from the impl.\n-    // Liberate them and assign them the scope of the method body.\n-    //\n-    // An example would be:\n-    //\n-    //     impl<'a> Foo<&'a T> for &'a U { ... }\n-    //\n-    // Here, the region parameter `'a` is late-bound, so the\n-    // trait reference associated with the impl will be\n-    //\n-    //     for<'a> Foo<&'a T>\n-    //\n-    // liberating will convert this into:\n-    //\n-    //     Foo<&'A T>\n-    //\n-    // where `'A` is the `ReFree` version of `'a`.\n-    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_scope, impl_trait_ref);\n-\n     debug!(\"impl_trait_ref (liberated) = {}\",\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let trait_to_impl_substs = impl_trait_ref.substs;\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n \n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n@@ -1060,7 +1033,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !check_region_bounds_on_impl_method(tcx,\n                                            impl_m_span,\n                                            impl_m,\n-                                           impl_m_body_scope,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n@@ -1099,11 +1071,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .map(|trait_param_def| &trait_param_def.bounds);\n     let impl_bounds =\n         impl_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .map(|impl_param_def|\n-             liberate_late_bound_regions(\n-                 tcx,\n-                 impl_m_body_scope,\n-                 &ty::Binder(ty::Binder(impl_param_def.bounds.clone()))).0);\n+        .map(|impl_param_def| &impl_param_def.bounds);\n     for (i, (trait_param_bounds, impl_param_bounds)) in\n         trait_bounds.zip(impl_bounds).enumerate()\n     {\n@@ -1164,12 +1132,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n \n-    // Compute skolemized form of impl and trait method tys. Note\n-    // that we must liberate the late-bound regions from the impl.\n+    // Compute skolemized form of impl and trait method tys.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let impl_fty = liberate_late_bound_regions(\n-        tcx, impl_m_body_scope, &ty::Binder(impl_fty));\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1231,7 +1196,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::Method<'tcx>,\n-                                                impl_m_body_scope: CodeExtent,\n                                                 trait_generics: &ty::Generics<'tcx>,\n                                                 impl_generics: &ty::Generics<'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n@@ -1281,16 +1245,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let impl_bounds =\n                 impl_param.bounds.subst(tcx, impl_to_skol_substs);\n \n-            // The bounds may reference late-bound regions from the\n-            // impl declaration. In that case, we want to replace\n-            // those with the liberated variety so as to match the\n-            // versions appearing in the `trait_to_skol_substs`.\n-            // There are two-levels of binder to be aware of: the\n-            // impl, and the method.\n-            let impl_bounds =\n-                ty::liberate_late_bound_regions(\n-                    tcx, impl_m_body_scope, &ty::Binder(ty::Binder(impl_bounds))).0;\n-\n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n                    impl_param={} \\"}, {"sha": "c09ce3db6ddd21ed15b47c0f5c6b6be0c97e032a", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -166,11 +166,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n-            // to free, and any late-bound regions on the impl\n-            // liberated.\n+            // to free.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let self_ty = liberate_late_bound_regions(fcx.tcx(), item_scope, &ty::Binder(self_ty));\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -181,7 +179,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 Some(t) => { t }\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item_scope, &trait_ref);\n \n             // There are special rules that apply to drop.\n             if"}, {"sha": "5d0bb6622c2e144667664f5983c2c33e7b43347a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -18,8 +18,8 @@\n \n use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n-use middle::region;\n use middle::subst::{mod, Subst};\n+use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_closure, ty_enum, ty_err};\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Record all the trait items.\n         for trait_ref in associated_traits.iter() {\n-            self.add_trait_impl(trait_ref.def_id(), impl_def_id);\n+            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -459,27 +459,25 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let trait_impls = trait_impls.borrow().clone();\n \n         for &impl_did in trait_impls.iter() {\n+            debug!(\"check_implementations_of_copy: impl_did={}\",\n+                   impl_did.repr(tcx));\n+\n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n                 continue\n             }\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n+            debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n+                   self_type.repr(tcx));\n+\n             let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx,\n-                                                           impl_did.node);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n+            assert!(!self_type.has_escaping_regions());\n \n-            // the self-type may have late-bound regions bound in the\n-            // impl; liberate them.\n-            let item_scope = region::CodeExtent::from_node_id(impl_did.node);\n-            let self_type =\n-                ty::liberate_late_bound_regions(tcx,\n-                                                item_scope,\n-                                                &ty::Binder(self_type));\n-\n-            debug!(\"can_type_implement_copy(self_type={})\",\n+            debug!(\"check_implementations_of_copy: self_type={} (free)\",\n                    self_type.repr(tcx));\n \n             match ty::can_type_implement_copy(tcx, self_type, &param_env) {"}, {"sha": "07a84846c47ad26d96192b791939b2030dff9a84", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -45,7 +45,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                     }\n \n                     Some(trait_ref) => {\n-                        let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id());\n+                        let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n                         match (trait_def.unsafety, unsafety) {\n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe) => {\n                                 self.tcx.sess.span_err("}, {"sha": "280b42f0959d28839182f2cff7a1fb70646d2406", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -43,8 +43,8 @@ use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{mod, Ty, Polytype};\n-use middle::ty_fold::{mod, TypeFolder};\n+use middle::ty::{mod, RegionEscape, Ty, Polytype};\n+use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n@@ -226,7 +226,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             ast::StructVariantKind(ref struct_def) => {\n                 let pty = Polytype {\n-                    generics: ty_generics_for_type(\n+                    generics: ty_generics_for_type_or_impl(\n                         ccx,\n                         generics,\n                         DontCreateTypeParametersForAssociatedTypes),\n@@ -239,7 +239,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         let pty = Polytype {\n-            generics: ty_generics_for_type(\n+            generics: ty_generics_for_type_or_impl(\n                           ccx,\n                           generics,\n                           DontCreateTypeParametersForAssociatedTypes),\n@@ -1050,7 +1050,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-            let ty_generics = ty_generics_for_impl(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                     ccx,\n                     generics,\n                     CreateTypeParametersForAssociatedTypes);\n@@ -1482,7 +1482,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             let pty = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 Polytype {\n-                    generics: ty_generics_for_type(\n+                    generics: ty_generics_for_type_or_impl(\n                                   ccx,\n                                   generics,\n                                   DontCreateTypeParametersForAssociatedTypes),\n@@ -1495,7 +1495,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics_for_type(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                 ccx,\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n@@ -1513,7 +1513,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics_for_type(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                 ccx,\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n@@ -1580,11 +1580,11 @@ fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                  generics: &ast::Generics,\n-                                  create_type_parameters_for_associated_types:\n-                                      CreateTypeParametersForAssociatedTypesFlag)\n-                                  -> ty::Generics<'tcx> {\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                          generics: &ast::Generics,\n+                                          create_type_parameters_for_associated_types:\n+                                          CreateTypeParametersForAssociatedTypesFlag)\n+                                          -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes.as_slice(),\n@@ -1664,24 +1664,6 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     generics\n }\n \n-fn ty_generics_for_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                  generics: &ast::Generics,\n-                                  create_type_parameters_for_associated_types:\n-                                      CreateTypeParametersForAssociatedTypesFlag)\n-                                  -> ty::Generics<'tcx>\n-{\n-    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    debug!(\"ty_generics_for_impl: early_lifetimes={}\",\n-           early_lifetimes);\n-    ty_generics(ccx,\n-                subst::TypeSpace,\n-                early_lifetimes.as_slice(),\n-                generics.ty_params.as_slice(),\n-                ty::Generics::empty(),\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n-}\n-\n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n@@ -2186,8 +2168,12 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     subst::Substs::new(types, regions)\n }\n \n-/// Verifies that the explicit self type of a method matches the impl or\n-/// trait.\n+/// Verifies that the explicit self type of a method matches the impl\n+/// or trait. This is a bit weird but basically because right now we\n+/// don't handle the general case, but instead map it to one of\n+/// several pre-defined options using various heuristics, this method\n+/// comes back to check after the fact that explicit type the user\n+/// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     crate_context: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n@@ -2209,19 +2195,21 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         // contain late-bound regions from the method, but not the\n         // trait (since traits only have early-bound region\n         // parameters).\n-        assert!(!ty::type_escapes_depth(required_type, 1));\n+        assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::Binder(required_type));\n+            liberate_early_bound_regions(\n+                crate_context.tcx, body_scope,\n+                &ty::liberate_late_bound_regions(\n+                    crate_context.tcx, body_scope, &ty::Binder(required_type)));\n \n-        // The \"base type\" comes from the impl. It may have late-bound\n-        // regions from the impl or the method.\n+        // The \"base type\" comes from the impl. It too may have late-bound\n+        // regions from the method.\n+        assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n-            ty::liberate_late_bound_regions( // liberate impl regions:\n+            liberate_early_bound_regions(\n                 crate_context.tcx, body_scope,\n-                &ty::liberate_late_bound_regions( // liberate method regions:\n-                    crate_context.tcx, body_scope,\n-                    &ty::Binder(ty::Binder(base_type))));\n+                &ty::liberate_late_bound_regions(\n+                    crate_context.tcx, body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n@@ -2242,4 +2230,30 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }\n+\n+    fn liberate_early_bound_regions<'tcx,T>(\n+        tcx: &ty::ctxt<'tcx>,\n+        scope: region::CodeExtent,\n+        value: &T)\n+        -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    {\n+        /*!\n+         * Convert early-bound regions into free regions; normally this is done by\n+         * applying the `free_substs` from the `ParameterEnvironment`, but this particular\n+         * method-self-type check is kind of hacky and done very early in the process,\n+         * before we really have a `ParameterEnvironment` to check.\n+         */\n+\n+        ty_fold::fold_regions(tcx, value, |region, _| {\n+            match region {\n+                ty::ReEarlyBound(id, _, _, name) => {\n+                    let def_id = local_def(id);\n+                    ty::ReFree(ty::FreeRegion { scope: scope,\n+                                                bound_region: ty::BrNamed(def_id, name) })\n+                }\n+                _ => region\n+            }\n+        })\n+    }\n }"}, {"sha": "d0988af1cb473f9b857fe069a88a5dd79e3d26e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -281,7 +281,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n     // If this is an impl for a #[doc(hidden)] trait, be sure to not inline it.\n     match associated_trait {\n         Some(ref t) => {\n-            let trait_attrs = load_attrs(cx, tcx, t.def_id());\n+            let trait_attrs = load_attrs(cx, tcx, t.def_id);\n             if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n                 return None\n             }"}, {"sha": "670e8710847519c1def1cab7b2bc9e9105391c65", "filename": "src/test/compile-fail/hrtb-conflate-regions.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test what an impl with only one bound region `'a` cannot be used to\n+// satisfy a constraint whre there are two bound regions.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_foo2<T>()\n+    where T : for<'a,'b> Foo<(&'a int, &'b int)>\n+{\n+}\n+\n+fn want_foo1<T>()\n+    where T : for<'z> Foo<(&'z int, &'z int)>\n+{\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as a where clause\n+\n+struct SomeStruct;\n+\n+impl<'a> Foo<(&'a int, &'a int)> for SomeStruct\n+{\n+}\n+\n+fn a() { want_foo1::<SomeStruct>(); } // OK -- foo wants just one region\n+fn b() { want_foo2::<SomeStruct>(); } //~ ERROR not implemented\n+\n+fn main() { }"}, {"sha": "b21bae5653e22df9ce28fe39677c36b8de57956b", "filename": "src/test/compile-fail/hrtb-just-for-static.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where you have an impl of `Foo<X>` for all `X` that\n+// is being applied to `for<'a> Foo<&'a mut X>`. Issue #19730.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_hrtb<T>()\n+    where T : for<'a> Foo<&'a int>\n+{\n+}\n+\n+// AnyInt implements Foo<&'a int> for any 'a, so it is a match.\n+struct AnyInt;\n+impl<'a> Foo<&'a int> for AnyInt { }\n+fn give_any() {\n+    want_hrtb::<AnyInt>()\n+}\n+\n+// StaticInt only implements Foo<&'a int> for 'a, so it is an error.\n+struct StaticInt;\n+impl Foo<&'static int> for StaticInt { }\n+fn give_static() {\n+    want_hrtb::<StaticInt>() //~ ERROR `for<'a> Foo<&'a int>` is not implemented\n+}\n+\n+fn main() { }"}, {"sha": "a8ee2154fc396d5011070c69db58f74767c7d9fd", "filename": "src/test/compile-fail/hrtb-perfect-forwarding.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where you have an impl of `Foo<X>` for all `X` that\n+// is being applied to `for<'a> Foo<&'a mut X>`. Issue #19730.\n+\n+trait Foo<X> {\n+    fn foo(&mut self, x: X) { }\n+}\n+\n+trait Bar<X> {\n+    fn bar(&mut self, x: X) { }\n+}\n+\n+impl<'a,X,F> Foo<X> for &'a mut F\n+    where F : Foo<X> + Bar<X>\n+{\n+}\n+\n+impl<'a,X,F> Bar<X> for &'a mut F\n+    where F : Bar<X>\n+{\n+}\n+\n+fn no_hrtb<'b,T>(mut t: T)\n+    where T : Bar<&'b int>\n+{\n+    // OK -- `T : Bar<&'b int>`, and thus the impl above ensures that\n+    // `&mut T : Bar<&'b int>`.\n+    no_hrtb(&mut t);\n+}\n+\n+fn bar_hrtb<T>(mut t: T)\n+    where T : for<'b> Bar<&'b int>\n+{\n+    // OK -- `T : for<'b> Bar<&'b int>`, and thus the impl above\n+    // ensures that `&mut T : for<'b> Bar<&'b int>`.  This is an\n+    // example of a \"perfect forwarding\" impl.\n+    bar_hrtb(&mut t);\n+}\n+\n+fn foo_hrtb_bar_not<'b,T>(mut t: T)\n+    where T : for<'a> Foo<&'a int> + Bar<&'b int>\n+{\n+    // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n+    // be implemented. Thus to satisfy `&mut T : for<'a> Foo<&'a\n+    // int>`, we require `T : for<'a> Bar<&'a int>`, but the where\n+    // clause only specifies `T : Bar<&'b int>`.\n+    foo_hrtb_bar_not(&mut t); //~ ERROR `for<'a> Bar<&'a int>` is not implemented for the type `T`\n+}\n+\n+fn foo_hrtb_bar_hrtb<T>(mut t: T)\n+    where T : for<'a> Foo<&'a int> + for<'b> Bar<&'b int>\n+{\n+    // OK -- now we have `T : for<'b> Bar&'b int>`.\n+    foo_hrtb_bar_hrtb(&mut t);\n+}\n+\n+fn main() { }"}, {"sha": "9a326aadc6a1cd225ef5026b0cf585ea265c3a62", "filename": "src/test/compile-fail/hrtb-type-outlives.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test what happens when a HR obligation is applie to an impl with\n+// \"outlives\" bounds. Currently we're pretty conservative here; this\n+// will probably improve in time.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_foo<T>()\n+    where T : for<'a> Foo<&'a int>\n+{\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as a where clause\n+\n+struct SomeStruct<X> {\n+    x: X\n+}\n+\n+impl<'a,X> Foo<&'a int> for SomeStruct<X>\n+    where X : 'a\n+{\n+}\n+\n+fn one() {\n+    // In fact there is no good reason for this to be an error, but\n+    // whatever, I'm mostly concerned it doesn't ICE right now:\n+    want_foo::<SomeStruct<uint>>();\n+    //~^ ERROR requirement `for<'a> uint : 'a` is not satisfied\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as shorthand\n+\n+struct AnotherStruct<X> {\n+    x: X\n+}\n+\n+impl<'a,X:'a> Foo<&'a int> for AnotherStruct<X>\n+{\n+}\n+\n+fn two() {\n+    want_foo::<AnotherStruct<uint>>();\n+    //~^ ERROR requirement `for<'a> uint : 'a` is not satisfied\n+}\n+\n+fn main() { }"}, {"sha": "d03885ca7133c57609af0bbb094a4baaa4c37525", "filename": "src/test/compile-fail/issue-14366.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -11,5 +11,4 @@\n fn main() {\n     let _x = \"test\" as &::std::any::Any;\n //~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `str`\n-//~^^ ERROR the trait `core::kinds::Sized` is not implemented for the type `str`\n }"}, {"sha": "f5740992af48eadba48e8fd4b2103f5b0d684950", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -21,10 +21,15 @@ impl<T:Copy> Foo for T {\n \n fn take_param<T:Foo>(foo: &T) { }\n \n-fn main() {\n+fn a() {\n     let x = box 3i;\n     take_param(&x); //~ ERROR `core::kinds::Copy` is not implemented\n+}\n \n+fn b() {\n+    let x = box 3i;\n     let y = &x;\n     let z = &x as &Foo; //~ ERROR `core::kinds::Copy` is not implemented\n }\n+\n+fn main() { }"}, {"sha": "b0b37d077c1709f3d5dfb75614c089aced53abb6", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -20,9 +20,16 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }"}, {"sha": "20a4ab85d7ba8e434688e27333fb15bfde997d58", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -20,9 +20,17 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }\n+"}, {"sha": "f08cff3cd682137ac517bda985cff47e5081edf8", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f45c0ef51e342c552021a80ddd343b0c7175111e/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=f45c0ef51e342c552021a80ddd343b0c7175111e", "patch": "@@ -21,9 +21,16 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }"}]}