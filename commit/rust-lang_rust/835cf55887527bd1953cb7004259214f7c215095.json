{"sha": "835cf55887527bd1953cb7004259214f7c215095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNWNmNTU4ODc1MjdiZDE5NTNjYjcwMDQyNTkyMTRmN2MyMTUwOTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-25T12:15:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-25T12:15:48Z"}, "message": "Merge #8767\n\n8767: implement range formatting r=matklad a=euclio\n\nFixes #7580.\r\n\r\nThis PR implements the `textDocument/rangeFormatting` request using `rustfmt`'s `--file-lines` option.\r\n\r\nStill needs some tests. What I want to know is how I should handle the instability of the `--file-lines` option. It's still unstable in rustfmt, so it's only available on nightly, and needs a special flag to enable. Is there a way for `rust-analyzer` to detect if it's using nightly rustfmt, or for users to opt-in?\n\nCo-authored-by: Andy Russell <arussell123@gmail.com>", "tree": {"sha": "dadc26f171812663779a80cbe9344e9a004b37e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dadc26f171812663779a80cbe9344e9a004b37e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/835cf55887527bd1953cb7004259214f7c215095", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrOp1CRBK7hj4Ov3rIwAAlekIAFJdtWxTzU5Elkdr44hOrsLn\nN0d1f94uuPUumn6+q1qbaIGgHYye4pWdLOpQRKWGxa5nWrIPdbVOhiZpusiAk8ct\nBSlzsIKc/cUVIKTEXyujnRxv+sf8ctJu5IFfz+NbD5AQ/yojfZ67c70zoiQgw3bS\nwmGzzp/JwOFEDSO2ddudXfyPQyR0pdH1xXIHxZQURJ/EdpTZooTtHnClRCxMMCaV\nYkEUx6gBcfTk5iz/aL7Wl5aJ01OEQncfMqgU2lJVQqDGWRYzDMbRaLyJUmazHSTC\nLrKAgz2i+b/mcnWMzESp5L//bF+5t/B9X4XUQYusMeNbEwFDFruhgUXZLgXx/HM=\n=0g7X\n-----END PGP SIGNATURE-----\n", "payload": "tree dadc26f171812663779a80cbe9344e9a004b37e7\nparent b7414fa14a85f4acd37b5bdfdc2a4ab97a072bd2\nparent a90b9a5872c9c916733816e1e0d8c95cb09bfcba\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621944948 +0000\ncommitter GitHub <noreply@github.com> 1621944948 +0000\n\nMerge #8767\n\n8767: implement range formatting r=matklad a=euclio\n\nFixes #7580.\r\n\r\nThis PR implements the `textDocument/rangeFormatting` request using `rustfmt`'s `--file-lines` option.\r\n\r\nStill needs some tests. What I want to know is how I should handle the instability of the `--file-lines` option. It's still unstable in rustfmt, so it's only available on nightly, and needs a special flag to enable. Is there a way for `rust-analyzer` to detect if it's using nightly rustfmt, or for users to opt-in?\n\nCo-authored-by: Andy Russell <arussell123@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/835cf55887527bd1953cb7004259214f7c215095", "html_url": "https://github.com/rust-lang/rust/commit/835cf55887527bd1953cb7004259214f7c215095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/835cf55887527bd1953cb7004259214f7c215095/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7414fa14a85f4acd37b5bdfdc2a4ab97a072bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7414fa14a85f4acd37b5bdfdc2a4ab97a072bd2", "html_url": "https://github.com/rust-lang/rust/commit/b7414fa14a85f4acd37b5bdfdc2a4ab97a072bd2"}, {"sha": "a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a90b9a5872c9c916733816e1e0d8c95cb09bfcba", "html_url": "https://github.com/rust-lang/rust/commit/a90b9a5872c9c916733816e1e0d8c95cb09bfcba"}], "stats": {"total": 269, "additions": 167, "deletions": 102}, "files": [{"sha": "4d88932ca500a92b56dda56a74ea2121e141b185", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -1,4 +1,4 @@\n-//! Advertizes the capabilities of the LSP Server.\n+//! Advertises the capabilities of the LSP Server.\n use std::env;\n \n use lsp_types::{\n@@ -54,7 +54,7 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         code_action_provider: Some(code_action_capabilities(client_caps)),\n         code_lens_provider: Some(CodeLensOptions { resolve_provider: Some(true) }),\n         document_formatting_provider: Some(OneOf::Left(true)),\n-        document_range_formatting_provider: None,\n+        document_range_formatting_provider: Some(OneOf::Left(true)),\n         document_on_type_formatting_provider: Some(DocumentOnTypeFormattingOptions {\n             first_trigger_character: \"=\".to_string(),\n             more_trigger_character: Some(vec![\".\".to_string(), \">\".to_string(), \"{\".to_string()]),"}, {"sha": "7620a2fe176b69733969c8c208d6d5c0958ab65c", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -218,6 +218,10 @@ config_data! {\n         /// Advanced option, fully override the command rust-analyzer uses for\n         /// formatting.\n         rustfmt_overrideCommand: Option<Vec<String>> = \"null\",\n+        /// Enables the use of rustfmt's unstable range formatting command for the\n+        /// `textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n+        /// available on a nightly build.\n+        rustfmt_enableRangeFormatting: bool = \"false\",\n \n         /// Workspace symbol search scope.\n         workspace_symbol_search_scope: WorskpaceSymbolSearchScopeDef = \"\\\"workspace\\\"\",\n@@ -305,7 +309,7 @@ pub struct NotificationsConfig {\n \n #[derive(Debug, Clone)]\n pub enum RustfmtConfig {\n-    Rustfmt { extra_args: Vec<String> },\n+    Rustfmt { extra_args: Vec<String>, enable_range_formatting: bool },\n     CustomCommand { command: String, args: Vec<String> },\n }\n \n@@ -584,9 +588,10 @@ impl Config {\n                 let command = args.remove(0);\n                 RustfmtConfig::CustomCommand { command, args }\n             }\n-            Some(_) | None => {\n-                RustfmtConfig::Rustfmt { extra_args: self.data.rustfmt_extraArgs.clone() }\n-            }\n+            Some(_) | None => RustfmtConfig::Rustfmt {\n+                extra_args: self.data.rustfmt_extraArgs.clone(),\n+                enable_range_formatting: self.data.rustfmt_enableRangeFormatting,\n+            },\n         }\n     }\n     pub fn flycheck(&self) -> Option<FlycheckConfig> {"}, {"sha": "4567446036e4d2e5048a6c9d276c70bae4d67559", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 143, "deletions": 96, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -27,7 +27,7 @@ use lsp_types::{\n };\n use project_model::TargetKind;\n use serde::{Deserialize, Serialize};\n-use serde_json::to_value;\n+use serde_json::{json, to_value};\n use stdx::format_to;\n use syntax::{algo, ast, AstNode, TextRange, TextSize};\n \n@@ -955,104 +955,17 @@ pub(crate) fn handle_formatting(\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile::span(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let file = snap.analysis.file_text(file_id)?;\n-    let crate_ids = snap.analysis.crate_for(file_id)?;\n-\n-    let line_index = snap.file_line_index(file_id)?;\n-\n-    let mut rustfmt = match snap.config.rustfmt() {\n-        RustfmtConfig::Rustfmt { extra_args } => {\n-            let mut cmd = process::Command::new(toolchain::rustfmt());\n-            cmd.args(extra_args);\n-            // try to chdir to the file so we can respect `rustfmt.toml`\n-            // FIXME: use `rustfmt --config-path` once\n-            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n-            match params.text_document.uri.to_file_path() {\n-                Ok(mut path) => {\n-                    // pop off file name\n-                    if path.pop() && path.is_dir() {\n-                        cmd.current_dir(path);\n-                    }\n-                }\n-                Err(_) => {\n-                    log::error!(\n-                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n-                        params.text_document.uri\n-                    );\n-                }\n-            }\n-            if let Some(&crate_id) = crate_ids.first() {\n-                // Assume all crates are in the same edition\n-                let edition = snap.analysis.crate_edition(crate_id)?;\n-                cmd.arg(\"--edition\");\n-                cmd.arg(edition.to_string());\n-            }\n-            cmd\n-        }\n-        RustfmtConfig::CustomCommand { command, args } => {\n-            let mut cmd = process::Command::new(command);\n-            cmd.args(args);\n-            cmd\n-        }\n-    };\n \n-    let mut rustfmt =\n-        rustfmt.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped()).spawn()?;\n-\n-    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n-\n-    let output = rustfmt.wait_with_output()?;\n-    let captured_stdout = String::from_utf8(output.stdout)?;\n-    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n-\n-    if !output.status.success() {\n-        let rustfmt_not_installed =\n-            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n-\n-        return match output.status.code() {\n-            Some(1) if !rustfmt_not_installed => {\n-                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n-                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n-                // formatting because otherwise an error is surfaced to the user on top of the\n-                // syntax error diagnostics they're already receiving. This is especially jarring\n-                // if they have format on save enabled.\n-                log::info!(\"rustfmt exited with status 1, assuming parse error and ignoring\");\n-                Ok(None)\n-            }\n-            _ => {\n-                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n-                Err(LspError::new(\n-                    -32900,\n-                    format!(\n-                        r#\"rustfmt exited with:\n-                           Status: {}\n-                           stdout: {}\n-                           stderr: {}\"#,\n-                        output.status, captured_stdout, captured_stderr,\n-                    ),\n-                )\n-                .into())\n-            }\n-        };\n-    }\n+    run_rustfmt(&snap, params.text_document, None)\n+}\n \n-    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n+pub(crate) fn handle_range_formatting(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::DocumentRangeFormattingParams,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let _p = profile::span(\"handle_range_formatting\");\n \n-    if line_index.endings != new_line_endings {\n-        // If line endings are different, send the entire file.\n-        // Diffing would not work here, as the line endings might be the only\n-        // difference.\n-        Ok(Some(to_proto::text_edit_vec(\n-            &line_index,\n-            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n-        )))\n-    } else if *file == new_text {\n-        // The document is already formatted correctly -- no edits needed.\n-        Ok(None)\n-    } else {\n-        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n-    }\n+    run_rustfmt(&snap, params.text_document, Some(params.range))\n }\n \n pub(crate) fn handle_code_action(\n@@ -1675,6 +1588,140 @@ fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>)\n     }\n }\n \n+fn run_rustfmt(\n+    snap: &GlobalStateSnapshot,\n+    text_document: TextDocumentIdentifier,\n+    range: Option<lsp_types::Range>,\n+) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n+    let file_id = from_proto::file_id(&snap, &text_document.uri)?;\n+    let file = snap.analysis.file_text(file_id)?;\n+    let crate_ids = snap.analysis.crate_for(file_id)?;\n+\n+    let line_index = snap.file_line_index(file_id)?;\n+\n+    let mut rustfmt = match snap.config.rustfmt() {\n+        RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n+            let mut cmd = process::Command::new(toolchain::rustfmt());\n+            cmd.args(extra_args);\n+            // try to chdir to the file so we can respect `rustfmt.toml`\n+            // FIXME: use `rustfmt --config-path` once\n+            // https://github.com/rust-lang/rustfmt/issues/4660 gets fixed\n+            match text_document.uri.to_file_path() {\n+                Ok(mut path) => {\n+                    // pop off file name\n+                    if path.pop() && path.is_dir() {\n+                        cmd.current_dir(path);\n+                    }\n+                }\n+                Err(_) => {\n+                    log::error!(\n+                        \"Unable to get file path for {}, rustfmt.toml might be ignored\",\n+                        text_document.uri\n+                    );\n+                }\n+            }\n+            if let Some(&crate_id) = crate_ids.first() {\n+                // Assume all crates are in the same edition\n+                let edition = snap.analysis.crate_edition(crate_id)?;\n+                cmd.arg(\"--edition\");\n+                cmd.arg(edition.to_string());\n+            }\n+\n+            if let Some(range) = range {\n+                if !enable_range_formatting {\n+                    return Err(LspError::new(\n+                        ErrorCode::InvalidRequest as i32,\n+                        String::from(\n+                            \"rustfmt range formatting is unstable. \\\n+                            Opt-in by using a nightly build of rustfmt and setting \\\n+                            `rustfmt.enableRangeFormatting` to true in your LSP configuration\",\n+                        ),\n+                    )\n+                    .into());\n+                }\n+\n+                let frange = from_proto::file_range(&snap, text_document.clone(), range)?;\n+                let start_line = line_index.index.line_col(frange.range.start()).line;\n+                let end_line = line_index.index.line_col(frange.range.end()).line;\n+\n+                cmd.arg(\"--unstable-features\");\n+                cmd.arg(\"--file-lines\");\n+                cmd.arg(\n+                    json!([{\n+                        \"file\": \"stdin\",\n+                        \"range\": [start_line, end_line]\n+                    }])\n+                    .to_string(),\n+                );\n+            }\n+\n+            cmd\n+        }\n+        RustfmtConfig::CustomCommand { command, args } => {\n+            let mut cmd = process::Command::new(command);\n+            cmd.args(args);\n+            cmd\n+        }\n+    };\n+\n+    let mut rustfmt =\n+        rustfmt.stdin(Stdio::piped()).stdout(Stdio::piped()).stderr(Stdio::piped()).spawn()?;\n+\n+    rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n+\n+    let output = rustfmt.wait_with_output()?;\n+    let captured_stdout = String::from_utf8(output.stdout)?;\n+    let captured_stderr = String::from_utf8(output.stderr).unwrap_or_default();\n+\n+    if !output.status.success() {\n+        let rustfmt_not_installed =\n+            captured_stderr.contains(\"not installed\") || captured_stderr.contains(\"not available\");\n+\n+        return match output.status.code() {\n+            Some(1) if !rustfmt_not_installed => {\n+                // While `rustfmt` doesn't have a specific exit code for parse errors this is the\n+                // likely cause exiting with 1. Most Language Servers swallow parse errors on\n+                // formatting because otherwise an error is surfaced to the user on top of the\n+                // syntax error diagnostics they're already receiving. This is especially jarring\n+                // if they have format on save enabled.\n+                log::info!(\"rustfmt exited with status 1, assuming parse error and ignoring\");\n+                Ok(None)\n+            }\n+            _ => {\n+                // Something else happened - e.g. `rustfmt` is missing or caught a signal\n+                Err(LspError::new(\n+                    -32900,\n+                    format!(\n+                        r#\"rustfmt exited with:\n+                           Status: {}\n+                           stdout: {}\n+                           stderr: {}\"#,\n+                        output.status, captured_stdout, captured_stderr,\n+                    ),\n+                )\n+                .into())\n+            }\n+        };\n+    }\n+\n+    let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n+\n+    if line_index.endings != new_line_endings {\n+        // If line endings are different, send the entire file.\n+        // Diffing would not work here, as the line endings might be the only\n+        // difference.\n+        Ok(Some(to_proto::text_edit_vec(\n+            &line_index,\n+            TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n+        )))\n+    } else if *file == new_text {\n+        // The document is already formatted correctly -- no edits needed.\n+        Ok(None)\n+    } else {\n+        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n+    }\n+}\n+\n #[derive(Debug, Serialize, Deserialize)]\n struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,"}, {"sha": "008758ea0d754886dc001f32a2fbc10efc6b30ce", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -543,6 +543,7 @@ impl GlobalState {\n             .on::<lsp_types::request::Rename>(handlers::handle_rename)\n             .on::<lsp_types::request::References>(handlers::handle_references)\n             .on::<lsp_types::request::Formatting>(handlers::handle_formatting)\n+            .on::<lsp_types::request::RangeFormatting>(handlers::handle_range_formatting)\n             .on::<lsp_types::request::DocumentHighlightRequest>(handlers::handle_document_highlight)\n             .on::<lsp_types::request::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)\n             .on::<lsp_types::request::CallHierarchyIncomingCalls>("}, {"sha": "f3da82febbeeed7c683c568f6f6db1cf4fa3fa75", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -346,6 +346,13 @@ Additional arguments to `rustfmt`.\n Advanced option, fully override the command rust-analyzer uses for\n formatting.\n --\n+[[rust-analyzer.rustfmt.enableRangeFormatting]]rust-analyzer.rustfmt.enableRangeFormatting (default: `false`)::\n++\n+--\n+Enables the use of rustfmt's unstable range formatting command for the\n+`textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n+available on a nightly build.\n+--\n [[rust-analyzer.workspace.symbol.search.scope]]rust-analyzer.workspace.symbol.search.scope (default: `\"workspace\"`)::\n +\n --"}, {"sha": "05cbccf94643726497bdf2d16290d1d4a8392702", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/835cf55887527bd1953cb7004259214f7c215095/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/835cf55887527bd1953cb7004259214f7c215095/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=835cf55887527bd1953cb7004259214f7c215095", "patch": "@@ -795,6 +795,11 @@\n                         \"type\": \"string\"\n                     }\n                 },\n+                \"rust-analyzer.rustfmt.enableRangeFormatting\": {\n+                    \"markdownDescription\": \"Enables the use of rustfmt's unstable range formatting command for the\\n`textDocument/rangeFormatting` request. The rustfmt option is unstable and only\\navailable on a nightly build.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.workspace.symbol.search.scope\": {\n                     \"markdownDescription\": \"Workspace symbol search scope.\",\n                     \"default\": \"workspace\","}]}