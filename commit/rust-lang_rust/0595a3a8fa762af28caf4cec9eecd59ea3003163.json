{"sha": "0595a3a8fa762af28caf4cec9eecd59ea3003163", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OTVhM2E4ZmE3NjJhZjI4Y2FmNGNlYzllZWNkNTllYTMwMDMxNjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-20T15:52:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-20T15:52:01Z"}, "message": "hash the traits-in-scope determinstically\n\nExperimentally, this fixes the poor re-use observed in\nlibsyntex-syntax. I'm not sure how to make a regression test for this,\nthough, given the non-deterministic nature of it.", "tree": {"sha": "1ffad9698c595e0f147034724429d87df335cbe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ffad9698c595e0f147034724429d87df335cbe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0595a3a8fa762af28caf4cec9eecd59ea3003163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0595a3a8fa762af28caf4cec9eecd59ea3003163", "html_url": "https://github.com/rust-lang/rust/commit/0595a3a8fa762af28caf4cec9eecd59ea3003163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0595a3a8fa762af28caf4cec9eecd59ea3003163/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bd80d11163771293ea7bf75a4513af76b754a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd80d11163771293ea7bf75a4513af76b754a41", "html_url": "https://github.com/rust-lang/rust/commit/6bd80d11163771293ea7bf75a4513af76b754a41"}], "stats": {"total": 33, "additions": 24, "deletions": 9}, "files": [{"sha": "1e00e0fc56260b01c5822a2bca8b65eeb33c166e", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0595a3a8fa762af28caf4cec9eecd59ea3003163/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0595a3a8fa762af28caf4cec9eecd59ea3003163/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=0595a3a8fa762af28caf4cec9eecd59ea3003163", "patch": "@@ -25,25 +25,33 @@ use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::hir::intravisit::{Visitor, FnKind};\n-use rustc::hir::map::DefPath;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n \n use std::hash::{Hash, SipHasher};\n \n pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub st: &'a mut SipHasher,\n+\n+    // collect a deterministic hash of def-ids that we have seen\n+    def_id_hashes: DefIdMap<u64>,\n }\n \n impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n     pub fn new(st: &'a mut SipHasher,\n                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                -> Self {\n-        StrictVersionHashVisitor { st: st, tcx: tcx }\n+        StrictVersionHashVisitor { st: st, tcx: tcx, def_id_hashes: DefIdMap() }\n     }\n \n-    fn hash_def_path(&mut self, path: &DefPath) {\n-        path.deterministic_hash_to(self.tcx, self.st);\n+    fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n+        let tcx = self.tcx;\n+        *self.def_id_hashes.entry(def_id)\n+                           .or_insert_with(|| {\n+                               let def_path = tcx.def_path(def_id);\n+                               def_path.deterministic_hash(tcx)\n+                           })\n     }\n }\n \n@@ -376,15 +384,22 @@ impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n         if let Some(traits) = self.tcx.trait_map.get(&id) {\n             debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n             traits.len().hash(self.st);\n-            for candidate in traits {\n-                self.hash_def_id(candidate.def_id);\n-            }\n+\n+            // The ordering of the candidates is not fixed. So we hash\n+            // the def-ids and then sort them and hash the collection.\n+            let mut candidates: Vec<_> =\n+                traits.iter()\n+                      .map(|&TraitCandidate { def_id, import_id: _ }| {\n+                          self.compute_def_id_hash(def_id)\n+                      })\n+                      .collect();\n+            candidates.sort();\n+            candidates.hash(self.st);\n         }\n     }\n \n     fn hash_def_id(&mut self, def_id: DefId) {\n-        let def_path = self.tcx.def_path(def_id);\n-        self.hash_def_path(&def_path);\n+        self.compute_def_id_hash(def_id).hash(self.st);\n     }\n \n     fn hash_partial_def(&mut self, def: &PathResolution) {"}]}