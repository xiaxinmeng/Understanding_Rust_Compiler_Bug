{"sha": "b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "node_id": "C_kwDOAAsO6NoAKGI2MDYyYmRhNGNjZjNjODdkZGVjZGE2YjBhOTdiOTYxYjBmM2ZhMDQ", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T16:46:44Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:30:39Z"}, "message": "Avoid double-deref in `Fields`", "tree": {"sha": "5271b340ab443269567414f5de71411f8f77631d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5271b340ab443269567414f5de71411f8f77631d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "html_url": "https://github.com/rust-lang/rust/commit/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71abc9565f037c3c9da5814c23857545abb0aaab", "url": "https://api.github.com/repos/rust-lang/rust/commits/71abc9565f037c3c9da5814c23857545abb0aaab", "html_url": "https://github.com/rust-lang/rust/commit/71abc9565f037c3c9da5814c23857545abb0aaab"}], "stats": {"total": 66, "additions": 31, "deletions": 35}, "files": [{"sha": "a69f5de372759cebef14e8f888079db9331db925", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "patch": "@@ -62,7 +62,6 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n-use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n use std::fmt;\n use std::iter::{once, IntoIterator};\n@@ -1107,33 +1106,27 @@ impl<'tcx> SplitWildcard<'tcx> {\n /// because the code mustn't observe that it is uninhabited. In that case that field is not\n /// included in `fields`. For that reason, when you have a `mir::Field` you must use\n /// `index_with_declared_idx`.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Copy)]\n pub(super) struct Fields<'p, 'tcx> {\n-    fields: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n+    fields: &'p [DeconstructedPat<'p, 'tcx>],\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n     fn empty() -> Self {\n-        Fields { fields: SmallVec::new() }\n+        Fields { fields: &[] }\n     }\n \n     fn singleton(cx: &MatchCheckCtxt<'p, 'tcx>, field: DeconstructedPat<'p, 'tcx>) -> Self {\n         let field: &_ = cx.pattern_arena.alloc(field);\n-        Fields { fields: smallvec![field] }\n+        Fields { fields: std::slice::from_ref(field) }\n     }\n \n     pub(super) fn from_iter(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         fields: impl IntoIterator<Item = DeconstructedPat<'p, 'tcx>>,\n     ) -> Self {\n-        let fields: &_ = cx.pattern_arena.alloc_from_iter(fields);\n-        Fields { fields: fields.into_iter().collect() }\n-    }\n-\n-    pub(super) fn from_ref_iter(\n-        fields: impl IntoIterator<Item = &'p DeconstructedPat<'p, 'tcx>>,\n-    ) -> Self {\n-        Fields { fields: fields.into_iter().collect() }\n+        let fields: &[_] = cx.pattern_arena.alloc_from_iter(fields);\n+        Fields { fields }\n     }\n \n     fn wildcards_from_tys(\n@@ -1222,7 +1215,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     pub(super) fn iter_patterns<'a>(\n         &'a self,\n     ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Captures<'a> {\n-        self.fields.iter().copied()\n+        self.fields.iter()\n     }\n }\n \n@@ -1245,9 +1238,8 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n \n     pub(crate) fn from_pat(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &Pat<'tcx>) -> Self {\n         let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n-        let allocpat = |pat| &*cx.pattern_arena.alloc(mkpat(pat));\n         let ctor;\n-        let mut fields;\n+        let fields;\n         match pat.kind.as_ref() {\n             PatKind::AscribeUserType { subpattern, .. } => return mkpat(subpattern),\n             PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n@@ -1263,10 +1255,15 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 match pat.ty.kind() {\n                     ty::Tuple(fs) => {\n                         ctor = Single;\n-                        fields = Fields::wildcards_from_tys(cx, fs.iter().map(|ty| ty.expect_ty()));\n+                        let mut wilds: SmallVec<[_; 2]> = fs\n+                            .iter()\n+                            .map(|ty| ty.expect_ty())\n+                            .map(DeconstructedPat::wildcard)\n+                            .collect();\n                         for pat in subpatterns {\n-                            fields.fields[pat.field.index()] = allocpat(&pat.pattern);\n+                            wilds[pat.field.index()] = mkpat(&pat.pattern);\n                         }\n+                        fields = Fields::from_iter(cx, wilds);\n                     }\n                     ty::Adt(adt, substs) if adt.is_box() => {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n@@ -1306,12 +1303,14 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                                 field_id_to_id[field.index()] = Some(i);\n                                 ty\n                             });\n-                        fields = Fields::wildcards_from_tys(cx, tys);\n+                        let mut wilds: SmallVec<[_; 2]> =\n+                            tys.map(DeconstructedPat::wildcard).collect();\n                         for pat in subpatterns {\n                             if let Some(i) = field_id_to_id[pat.field.index()] {\n-                                fields.fields[i] = allocpat(&pat.pattern);\n+                                wilds[i] = mkpat(&pat.pattern);\n                             }\n                         }\n+                        fields = Fields::from_iter(cx, wilds);\n                     }\n                     _ => bug!(\"pattern has unexpected type: pat: {:?}, ty: {:?}\", pat, pat.ty),\n                 }\n@@ -1510,40 +1509,38 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n         &'a self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n-    ) -> Cow<'a, Fields<'p, 'tcx>> {\n+    ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Cow::Owned(Fields::wildcards(cx, self.ty, other_ctor))\n+                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n             {\n                 // The only tricky case: two slices of different arity. Since `self_slice` covers\n                 // `other_slice`, `self_slice` must be `VarLen`, i.e. of the form\n                 // `[prefix, .., suffix]`. Moreover `other_slice` is guaranteed to have a larger\n-                // arity. We fill the middle part with enough wildcards to reach the length of the\n-                // new, larger slice.\n+                // arity. So we fill the middle part with enough wildcards to reach the length of\n+                // the new, larger slice.\n                 match self_slice.kind {\n                     FixedLen(_) => bug!(\"{:?} doesn't cover {:?}\", self_slice, other_slice),\n                     VarLen(prefix, suffix) => {\n                         let inner_ty = match *self.ty.kind() {\n                             ty::Slice(ty) | ty::Array(ty, _) => ty,\n                             _ => bug!(\"bad slice pattern {:?} {:?}\", self.ctor, self.ty),\n                         };\n-                        let prefix = self.fields.fields[..prefix].iter().copied();\n-                        let suffix =\n-                            self.fields.fields[self_slice.arity() - suffix..].iter().copied();\n+                        let prefix = &self.fields.fields[..prefix];\n+                        let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n+                        let wildcard: &_ =\n+                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n-                        let extra_wildcards: &[_] = cx.pattern_arena.alloc_from_iter(\n-                            (0..extra_wildcards).map(|_| DeconstructedPat::wildcard(inner_ty)),\n-                        );\n-                        let fields = prefix.chain(extra_wildcards).chain(suffix);\n-                        Cow::Owned(Fields::from_ref_iter(fields))\n+                        let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n+                        prefix.iter().chain(extra_wildcards).chain(suffix).collect()\n                     }\n                 }\n             }\n-            _ => Cow::Borrowed(&self.fields),\n+            _ => self.fields.iter_patterns().collect(),\n         }\n     }\n }"}, {"sha": "9ab0e906eb7cf4a92ef28146242d1db7f6fd10c9", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=b6062bda4ccf3c87ddecda6b0a97b961b0f3fa04", "patch": "@@ -407,8 +407,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> =\n-            self.head().specialize(cx, ctor).iter_patterns().collect();\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }"}]}