{"sha": "8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NTJhNTYwYjlmNTBlMDRjMzhhYjc1ZTJiNWMzN2QwM2QzMjE0ZDk=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-16T19:59:49Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-21T21:59:35Z"}, "message": "Lift: take self by value", "tree": {"sha": "3b02e3fbd070774813f058c6c7b240ae5fba1c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b02e3fbd070774813f058c6c7b240ae5fba1c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "html_url": "https://github.com/rust-lang/rust/commit/8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "html_url": "https://github.com/rust-lang/rust/commit/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4"}], "stats": {"total": 289, "additions": 138, "deletions": 151}, "files": [{"sha": "32f73237dd410411d3b51dd8c437928af1cfdfe2", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -157,7 +157,7 @@ impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| tcx.lift(&fr)).map(|relation| FreeRegionMap { relation })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+        self.relation.maybe_map(|&fr| tcx.lift(fr)).map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "ad7ac74041749075dcf8b118dc2715a936dd82e4", "filename": "compiler/rustc_macros/src/lift.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_macros%2Fsrc%2Flift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_macros%2Fsrc%2Flift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flift.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -3,6 +3,7 @@ use syn::{self, parse_quote};\n \n pub fn lift_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     s.add_bounds(synstructure::AddBounds::Generics);\n+    s.bind_with(|_| synstructure::BindStyle::Move);\n \n     let tcx: syn::Lifetime = parse_quote!('tcx);\n     let newtcx: syn::GenericParam = parse_quote!('__lifted);\n@@ -43,8 +44,8 @@ pub fn lift_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStre\n         quote! {\n             type Lifted = #lifted;\n \n-            fn lift_to_tcx(&self, __tcx: ::rustc_middle::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n-                Some(match *self { #body })\n+            fn lift_to_tcx(self, __tcx: ::rustc_middle::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n+                Some(match self { #body })\n             }\n         },\n     )"}, {"sha": "6ff0a94ebf3ce1f8b8ee149eb8c59ff32b48074c", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -29,8 +29,8 @@ macro_rules! CloneLiftImpls {\n         $(\n             impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n                 type Lifted = Self;\n-                fn lift_to_tcx(&self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n-                    Some(Clone::clone(self))\n+                fn lift_to_tcx(self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n+                    Some(self)\n                 }\n             }\n         )+"}, {"sha": "05bcf2ba0ce49079fd031b323713a94a1faf087c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -2210,7 +2210,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                         let name = ty::tls::with(|tcx| {\n                             let mut name = String::new();\n-                            let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                            let substs = tcx.lift(substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, &mut name, Namespace::ValueNS)\n                                 .print_def_path(variant_def.def_id, substs)?;\n                             Ok(name)\n@@ -2233,7 +2233,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         if let Some(def_id) = def_id.as_local() {\n                             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n-                                let substs = tcx.lift(&substs).unwrap();\n+                                let substs = tcx.lift(substs).unwrap();\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n@@ -2527,7 +2527,7 @@ fn pretty_print_const(\n ) -> fmt::Result {\n     use crate::ty::print::PrettyPrinter;\n     ty::tls::with(|tcx| {\n-        let literal = tcx.lift(&c).unwrap();\n+        let literal = tcx.lift(c).unwrap();\n         let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n         cx.print_alloc_ids = true;\n         cx.pretty_print_const(literal, print_types)?;"}, {"sha": "c9493c679879eebf1d74d5f9f025d38314f0aefa", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -535,7 +535,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref targets, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift(&switch_ty).unwrap();\n+                let switch_ty = tcx.lift(switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n                 targets\n                     .values"}, {"sha": "29eccc4eae161bce2e2c2c5392068585c61c82f1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -1057,7 +1057,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift<T: Lift<'tcx>>(self, value: T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n \n@@ -1565,16 +1565,16 @@ impl<'tcx> TyCtxt<'tcx> {\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n macro_rules! nop_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n-            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n-                    Some(unsafe { mem::transmute(*self) })\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                    Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n                 }\n@@ -1587,12 +1587,12 @@ macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n             type Lifted = &'tcx List<$lifted>;\n-            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n-                    Some(unsafe { mem::transmute(*self) })\n+                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                    Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n                 }"}, {"sha": "235f8749cf917766e92e6073eeaca71a0bbfb44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -229,7 +229,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(t, n) => {\n-                let n = tcx.lift(&n).unwrap();\n+                let n = tcx.lift(n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     _ if t.is_simple_ty() => format!(\"array `{}`\", self).into(),\n                     Some(n) => format!(\"array of {} element{}\", n, pluralize!(n)).into(),"}, {"sha": "8b3fb8750706122bd28e3a992335963f5df05e5a", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -258,7 +258,7 @@ impl<'tcx> InstanceDef<'tcx> {\n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n-            let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n+            let substs = tcx.lift(self.substs).expect(\"could not lift for printing\");\n             FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n                 .print_def_path(self.def_id(), substs)?;\n             Ok(())"}, {"sha": "de24322e07de226b9d06c5bf2244e02e623d90ab", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -1848,7 +1848,7 @@ macro_rules! forward_display_to_print {\n         $(impl fmt::Display for $ty {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 ty::tls::with(|tcx| {\n-                    tcx.lift(self)\n+                    tcx.lift(*self)\n                         .expect(\"could not lift for printing\")\n                         .print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n                     Ok(())"}, {"sha": "a82a8c895bba7df8652ec5757a2a4fa4303255c7", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 106, "deletions": 120, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -332,130 +332,114 @@ CloneTypeFoldableAndLiftImpls! {\n // FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let (a, b) = self;\n+        tcx.lift(a).and_then(|a| tcx.lift(b).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n     type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.0)\n-            .and_then(|a| tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c))))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let (a, b, c) = self;\n+        tcx.lift(a).and_then(|a| tcx.lift(b).and_then(|b| tcx.lift(c).map(|c| (a, b, c))))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            Some(ref x) => tcx.lift(x).map(Some),\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            Some(x) => tcx.lift(x).map(Some),\n             None => Some(None),\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     type Lifted = Result<T::Lifted, E::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            Ok(ref x) => tcx.lift(x).map(Ok),\n-            Err(ref e) => tcx.lift(e).map(Err),\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            Ok(x) => tcx.lift(x).map(Ok),\n+            Err(e) => tcx.lift(e).map(Err),\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Box::new)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(*self).map(Box::new)\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Rc<T> {\n+impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Rc<T> {\n     type Lifted = Rc<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Rc::new)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.as_ref().clone()).map(Rc::new)\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Arc<T> {\n+impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Arc<T> {\n     type Lifted = Arc<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Arc::new)\n-    }\n-}\n-\n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n-    type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        // type annotation needed to inform `projection_must_outlive`\n-        let mut result: Vec<<T as Lift<'tcx>>::Lifted> = Vec::with_capacity(self.len());\n-        for x in self {\n-            if let Some(value) = tcx.lift(x) {\n-                result.push(value);\n-            } else {\n-                return None;\n-            }\n-        }\n-        Some(result)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.as_ref().clone()).map(Arc::new)\n     }\n }\n-\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self[..])\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.into_iter().map(|v| tcx.lift(v)).collect()\n     }\n }\n \n impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     type Lifted = IndexVec<I, T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        self.iter().map(|e| tcx.lift(e)).collect()\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.into_iter().map(|e| tcx.lift(e)).collect()\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::ExistentialPredicate::Trait(x) => tcx.lift(x).map(ty::ExistentialPredicate::Trait),\n             ty::ExistentialPredicate::Projection(x) => {\n                 tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n             }\n             ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                Some(ty::ExistentialPredicate::AutoTrait(*def_id))\n+                Some(ty::ExistentialPredicate::AutoTrait(def_id))\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate { trait_ref })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate { trait_ref })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n-        tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n+        tcx.lift((self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n             a,\n             b,\n@@ -465,41 +449,41 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n \n impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift((self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n-        tcx.lift(&self.substs)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n+        tcx.lift(self.substs)\n             .map(|substs| ty::ProjectionTy { item_def_id: self.item_def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift(&(self.projection_ty, self.ty))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+        tcx.lift((self.projection_ty, self.ty))\n             .map(|(projection_ty, ty)| ty::ProjectionPredicate { projection_ty, ty })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ExistentialProjection {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ExistentialProjection {\n             substs,\n-            ty: tcx.lift(&self.ty).expect(\"type must lift when substs do\"),\n+            ty: tcx.lift(self.ty).expect(\"type must lift when substs do\"),\n             item_def_id: self.item_def_id,\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::PredicateKind::ForAll(binder) => tcx.lift(binder).map(ty::PredicateKind::ForAll),\n             ty::PredicateKind::Atom(atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n@@ -509,100 +493,101 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n     type Lifted = ty::PredicateAtom<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            ty::PredicateAtom::Trait(ref data, constness) => {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::PredicateAtom::Trait(data, constness) => {\n                 tcx.lift(data).map(|data| ty::PredicateAtom::Trait(data, constness))\n             }\n-            ty::PredicateAtom::Subtype(ref data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n-            ty::PredicateAtom::RegionOutlives(ref data) => {\n+            ty::PredicateAtom::Subtype(data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n+            ty::PredicateAtom::RegionOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::RegionOutlives)\n             }\n-            ty::PredicateAtom::TypeOutlives(ref data) => {\n+            ty::PredicateAtom::TypeOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::TypeOutlives)\n             }\n-            ty::PredicateAtom::Projection(ref data) => {\n+            ty::PredicateAtom::Projection(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::Projection)\n             }\n-            ty::PredicateAtom::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateAtom::WellFormed),\n+            ty::PredicateAtom::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateAtom::WellFormed),\n             ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                tcx.lift(&closure_substs).map(|closure_substs| {\n+                tcx.lift(closure_substs).map(|closure_substs| {\n                     ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n             ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 Some(ty::PredicateAtom::ObjectSafe(trait_def_id))\n             }\n             ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n+                tcx.lift(substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n+                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n             }\n             ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n-                tcx.lift(&ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n+                tcx.lift(ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n             }\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().skip_binder()).map(|v| self.rebind(v))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.map_bound(|v| tcx.lift(v)).transpose()\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.caller_bounds())\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.caller_bounds())\n             .map(|caller_bounds| ty::ParamEnv::new(caller_bounds, self.reveal()))\n     }\n }\n \n impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n     type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.param_env).and_then(|param_env| {\n-            tcx.lift(&self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.param_env).and_then(|param_env| {\n+            tcx.lift(self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ClosureSubsts { substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ClosureSubsts { substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n     type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::GeneratorSubsts { substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::GeneratorSubsts { substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.kind).and_then(|kind| {\n-            tcx.lift(&self.target).map(|target| ty::adjustment::Adjustment { kind, target })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let ty::adjustment::Adjustment { kind, target } = self;\n+        tcx.lift(kind).and_then(|kind| {\n+            tcx.lift(target).map(|target| ty::adjustment::Adjustment { kind, target })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n     type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::adjustment::Adjust::NeverToAny => Some(ty::adjustment::Adjust::NeverToAny),\n             ty::adjustment::Adjust::Pointer(ptr) => Some(ty::adjustment::Adjust::Pointer(ptr)),\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+            ty::adjustment::Adjust::Deref(overloaded) => {\n                 tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n             }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+            ty::adjustment::Adjust::Borrow(autoref) => {\n                 tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n             }\n         }\n@@ -611,8 +596,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.region).map(|region| ty::adjustment::OverloadedDeref {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.region).map(|region| ty::adjustment::OverloadedDeref {\n             region,\n             mutbl: self.mutbl,\n             span: self.span,\n@@ -622,10 +607,10 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n+                tcx.lift(r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n             ty::adjustment::AutoBorrow::RawPtr(m) => Some(ty::adjustment::AutoBorrow::RawPtr(m)),\n         }\n@@ -634,16 +619,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.resume_ty, self.yield_ty, self.return_ty))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift((self.resume_ty, self.yield_ty, self.return_ty))\n             .map(|(resume_ty, yield_ty, return_ty)| ty::GenSig { resume_ty, yield_ty, return_ty })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.inputs_and_output).map(|x| ty::FnSig {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.inputs_and_output).map(|x| ty::FnSig {\n             inputs_and_output: x,\n             c_variadic: self.c_variadic,\n             unsafety: self.unsafety,\n@@ -654,19 +639,20 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.expected).and_then(|expected| {\n-            tcx.lift(&self.found).map(|found| ty::error::ExpectedFound { expected, found })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let ty::error::ExpectedFound { expected, found } = self;\n+        tcx.lift(expected).and_then(|expected| {\n+            tcx.lift(found).map(|found| ty::error::ExpectedFound { expected, found })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         use crate::ty::error::TypeError::*;\n \n-        Some(match *self {\n+        Some(match self {\n             Mismatch => Mismatch,\n             UnsafetyMismatch(x) => UnsafetyMismatch(x),\n             AbiMismatch(x) => AbiMismatch(x),\n@@ -675,51 +661,51 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             FixedArraySize(x) => FixedArraySize(x),\n             ArgCount => ArgCount,\n             RegionsDoesNotOutlive(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n+                return tcx.lift((a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n             }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n+                return tcx.lift(b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n             }\n             RegionsOverlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b));\n+                return tcx.lift(b).map(|b| RegionsOverlyPolymorphic(a, b));\n             }\n             RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n-            CyclicConst(ct) => return tcx.lift(&ct).map(|ct| CyclicConst(ct)),\n+            CyclicTy(t) => return tcx.lift(t).map(|t| CyclicTy(t)),\n+            CyclicConst(ct) => return tcx.lift(ct).map(|ct| CyclicConst(ct)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n-            Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n-            ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            Sorts(x) => return tcx.lift(x).map(Sorts),\n+            ExistentialMismatch(x) => return tcx.lift(x).map(ExistentialMismatch),\n+            ConstMismatch(x) => return tcx.lift(x).map(ConstMismatch),\n             IntrinsicCast => IntrinsicCast,\n-            TargetFeatureCast(ref x) => TargetFeatureCast(*x),\n-            ObjectUnsafeCoercion(ref x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n+            TargetFeatureCast(x) => TargetFeatureCast(x),\n+            ObjectUnsafeCoercion(x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::InstanceDef::Item(def_id) => Some(ty::InstanceDef::Item(def_id)),\n             ty::InstanceDef::VtableShim(def_id) => Some(ty::InstanceDef::VtableShim(def_id)),\n             ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n             ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n-            ty::InstanceDef::FnPtrShim(def_id, ref ty) => {\n+            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n                 Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?))\n             }\n             ty::InstanceDef::Virtual(def_id, n) => Some(ty::InstanceDef::Virtual(def_id, n)),\n             ty::InstanceDef::ClosureOnceShim { call_once } => {\n                 Some(ty::InstanceDef::ClosureOnceShim { call_once })\n             }\n-            ty::InstanceDef::DropGlue(def_id, ref ty) => {\n+            ty::InstanceDef::DropGlue(def_id, ty) => {\n                 Some(ty::InstanceDef::DropGlue(def_id, tcx.lift(ty)?))\n             }\n-            ty::InstanceDef::CloneShim(def_id, ref ty) => {\n+            ty::InstanceDef::CloneShim(def_id, ty) => {\n                 Some(ty::InstanceDef::CloneShim(def_id, tcx.lift(ty)?))\n             }\n         }"}, {"sha": "f04144c218e76721872a7ec3b222830d75698782", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -141,11 +141,11 @@ impl<'tcx> GenericArg<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n     type Lifted = GenericArg<'tcx>;\n \n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            GenericArgKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n-            GenericArgKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n-            GenericArgKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n+            GenericArgKind::Lifetime(lt) => tcx.lift(lt).map(|lt| lt.into()),\n+            GenericArgKind::Type(ty) => tcx.lift(ty).map(|ty| ty.into()),\n+            GenericArgKind::Const(ct) => tcx.lift(ct).map(|ct| ct.into()),\n         }\n     }\n }"}, {"sha": "42f7aa1fb0f765928f3d932b1ecfcf946431318f", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -686,7 +686,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                 // \"Lift\" into the tcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n                 // that is useful later.\n-                tcx.lift(&drop_place_ty).unwrap();\n+                tcx.lift(drop_place_ty).unwrap();\n \n                 debug!(\n                     \"visit_terminator_drop \\"}, {"sha": "3c68b1c8355d5f57ada6c68853dc7aff82fabe10", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -117,7 +117,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n         ty::tls::with(|tcx| {\n             match self.imm {\n                 Immediate::Scalar(s) => {\n-                    if let Some(ty) = tcx.lift(&self.layout.ty) {\n+                    if let Some(ty) = tcx.lift(self.layout.ty) {\n                         let cx = FmtPrinter::new(tcx, f, Namespace::ValueNS);\n                         p(cx, s, ty)?;\n                         return Ok(());"}, {"sha": "bfc747058185e65694dcc15dd7c9487222145638", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -1563,7 +1563,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Str => Primitive(PrimitiveType::Str),\n             ty::Slice(ty) => Slice(box ty.clean(cx)),\n             ty::Array(ty, n) => {\n-                let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n+                let mut n = cx.tcx.lift(n).expect(\"array lift failed\");\n                 n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n                 let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n@@ -1573,7 +1573,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 BorrowedRef { lifetime: r.clean(cx), mutability: mutbl, type_: box ty.clean(cx) }\n             }\n             ty::FnDef(..) | ty::FnPtr(_) => {\n-                let ty = cx.tcx.lift(self).expect(\"FnPtr lift failed\");\n+                let ty = cx.tcx.lift(*self).expect(\"FnPtr lift failed\");\n                 let sig = ty.fn_sig(cx.tcx);\n                 let def_id = DefId::local(CRATE_DEF_INDEX);\n                 BareFunction(box BareFunctionDecl {\n@@ -1675,7 +1675,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the bounds associated with the def_id.\n-                let substs = cx.tcx.lift(&substs).expect(\"Opaque lift failed\");\n+                let substs = cx.tcx.lift(substs).expect(\"Opaque lift failed\");\n                 let bounds = cx\n                     .tcx\n                     .explicit_item_bounds(def_id)"}, {"sha": "b0ed233f5ec7fdb97622d8cce112975efd3635b1", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752a560b9f50e04c38ab75e2b5c37d03d3214d9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=8752a560b9f50e04c38ab75e2b5c37d03d3214d9", "patch": "@@ -503,7 +503,7 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n             format!(\"{}{}\", format_integer_with_underscore_sep(&data.to_string()), ui.name_str())\n         }\n         (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Int(i)) => {\n-            let ty = cx.tcx.lift(&ct.ty).unwrap();\n+            let ty = cx.tcx.lift(ct.ty).unwrap();\n             let size = cx.tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n             let sign_extended_data = sign_extend(data, size) as i128;\n "}]}