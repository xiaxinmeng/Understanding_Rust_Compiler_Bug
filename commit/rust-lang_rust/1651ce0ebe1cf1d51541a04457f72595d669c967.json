{"sha": "1651ce0ebe1cf1d51541a04457f72595d669c967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NTFjZTBlYmUxY2YxZDUxNTQxYTA0NDU3ZjcyNTk1ZDY2OWM5Njc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-23T09:25:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-23T09:25:40Z"}, "message": "Merge #3278\n\n3278: Show more inlay hints r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/3273\r\n\r\nAs suggested in https://github.com/rust-analyzer/rust-analyzer/pull/1606#discussion_r308146363 , there is a simpler way to handle inlay hints after https://github.com/rust-analyzer/rust-analyzer/issues/1618 is closed.\r\n\r\nThis PR uses the approach suggested (which results in more type hints for various bindings) and also adds more name hints for function parameters.\r\n\r\nExamples can be found in the issue:\r\n* https://github.com/rust-analyzer/rust-analyzer/issues/3273#issuecomment-589998051\r\n* https://github.com/rust-analyzer/rust-analyzer/issues/3273#issuecomment-590002839\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "29529e62a16e8ac5db32706c6f44402bbc575c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29529e62a16e8ac5db32706c6f44402bbc575c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1651ce0ebe1cf1d51541a04457f72595d669c967", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeUkUUCRBK7hj4Ov3rIwAAdHIIAG6LWlwEHDbL0M1+ErAZL8BV\nACFFP0eI699q1BKLHpS9jXwMFwrc+hT1B/V7Eu3kuBARskldHQQ7NYsqQHpw2L4u\nl+DhKAxOWrHS6sp8HG4AvsXZ4gzdCCrY+ifdB/Ti+86B+SK53y+8fShr6iE2wHwY\nFDcTqxOUM/eqydGapatePtDFMadFZEG+lwmKJEkoMf6CwZuAELYbvpNljH5b8fcJ\nVpzVhwBxXk8nVYmQiGB1iPpukP/4cMys6wY+u7iTHx6xBXXTgKCou6O6WbCc8cBX\nRKdTsZU3r0mOgst/mgwm9G0HJt5FearJ3VN4MWeGcJBiGKsGV6dk3XKiu1BMxNc=\n=uF4R\n-----END PGP SIGNATURE-----\n", "payload": "tree 29529e62a16e8ac5db32706c6f44402bbc575c2b\nparent 650586a83869d6769c3d0fb94ffd2ccfcbd97db5\nparent ca4557ac524c104bff03d5f6dfc7bece7c919608\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582449940 +0000\ncommitter GitHub <noreply@github.com> 1582449940 +0000\n\nMerge #3278\n\n3278: Show more inlay hints r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/3273\r\n\r\nAs suggested in https://github.com/rust-analyzer/rust-analyzer/pull/1606#discussion_r308146363 , there is a simpler way to handle inlay hints after https://github.com/rust-analyzer/rust-analyzer/issues/1618 is closed.\r\n\r\nThis PR uses the approach suggested (which results in more type hints for various bindings) and also adds more name hints for function parameters.\r\n\r\nExamples can be found in the issue:\r\n* https://github.com/rust-analyzer/rust-analyzer/issues/3273#issuecomment-589998051\r\n* https://github.com/rust-analyzer/rust-analyzer/issues/3273#issuecomment-590002839\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1651ce0ebe1cf1d51541a04457f72595d669c967", "html_url": "https://github.com/rust-lang/rust/commit/1651ce0ebe1cf1d51541a04457f72595d669c967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1651ce0ebe1cf1d51541a04457f72595d669c967/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650586a83869d6769c3d0fb94ffd2ccfcbd97db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/650586a83869d6769c3d0fb94ffd2ccfcbd97db5", "html_url": "https://github.com/rust-lang/rust/commit/650586a83869d6769c3d0fb94ffd2ccfcbd97db5"}, {"sha": "ca4557ac524c104bff03d5f6dfc7bece7c919608", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4557ac524c104bff03d5f6dfc7bece7c919608", "html_url": "https://github.com/rust-lang/rust/commit/ca4557ac524c104bff03d5f6dfc7bece7c919608"}], "stats": {"total": 309, "additions": 174, "deletions": 135}, "files": [{"sha": "8d1c447ef28786d1e7fcefd7c8772546910d9e8a", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 174, "deletions": 135, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/1651ce0ebe1cf1d51541a04457f72595d669c967/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1651ce0ebe1cf1d51541a04457f72595d669c967/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=1651ce0ebe1cf1d51541a04457f72595d669c967", "patch": "@@ -1,12 +1,12 @@\n //! FIXME: write short doc here\n \n-use hir::{HirDisplay, SourceAnalyzer, SourceBinder};\n+use hir::{Function, HirDisplay, SourceAnalyzer, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, ArgListOwner, AstNode, TypeAscriptionOwner},\n-    match_ast, SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n+    match_ast, SmolStr, SourceFile, SyntaxNode, TextRange,\n };\n \n use crate::{FileId, FunctionSignature};\n@@ -50,51 +50,53 @@ fn get_inlay_hints(\n     let analyzer = Lazy::new(move || sb.analyze(hir::InFile::new(file_id.into(), node), None));\n     match_ast! {\n         match node {\n-            ast::LetStmt(it) => {\n-                if it.ascribed_type().is_some() {\n-                    return None;\n-                }\n-                let pat = it.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n-            },\n-            ast::LambdaExpr(it) => {\n-                it.param_list().map(|param_list| {\n-                    param_list\n-                        .params()\n-                        .filter(|closure_param| closure_param.ascribed_type().is_none())\n-                        .filter_map(|closure_param| closure_param.pat())\n-                        .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, false, max_inlay_hint_length))\n-                });\n-            },\n-            ast::ForExpr(it) => {\n-                let pat = it.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, false, max_inlay_hint_length);\n-            },\n-            ast::IfExpr(it) => {\n-                let pat = it.condition()?.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n-            },\n-            ast::WhileExpr(it) => {\n-                let pat = it.condition()?.pat()?;\n-                get_pat_type_hints(acc, db, &analyzer, pat, true, max_inlay_hint_length);\n-            },\n-            ast::MatchArmList(it) => {\n-                it.arms()\n-                    .filter_map(|match_arm| match_arm.pat())\n-                    .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, true, max_inlay_hint_length));\n-            },\n             ast::CallExpr(it) => {\n                 get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n             ast::MethodCallExpr(it) => {\n                 get_param_name_hints(acc, db, &analyzer, ast::Expr::from(it));\n             },\n+            ast::BindPat(it) => {\n+                if should_not_display_type_hint(&it) {\n+                    return None;\n+                }\n+                let pat = ast::Pat::from(it);\n+                let ty = analyzer.type_of_pat(db, &pat)?;\n+                if ty.is_unknown() {\n+                    return None;\n+                }\n+\n+                acc.push(\n+                    InlayHint {\n+                        range: pat.syntax().text_range(),\n+                        kind: InlayKind::TypeHint,\n+                        label: ty.display_truncated(db, max_inlay_hint_length).to_string().into(),\n+                    }\n+                );\n+            },\n             _ => (),\n         }\n     };\n     Some(())\n }\n \n+fn should_not_display_type_hint(bind_pat: &ast::BindPat) -> bool {\n+    for node in bind_pat.syntax().ancestors() {\n+        match_ast! {\n+            match node {\n+                ast::LetStmt(it) => {\n+                    return it.ascribed_type().is_some()\n+                },\n+                ast::Param(it) => {\n+                    return it.ascribed_type().is_some()\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+    false\n+}\n+\n fn get_param_name_hints(\n     acc: &mut Vec<InlayHint>,\n     db: &RootDatabase,\n@@ -105,28 +107,33 @@ fn get_param_name_hints(\n         ast::Expr::CallExpr(expr) => expr.arg_list()?.args(),\n         ast::Expr::MethodCallExpr(expr) => expr.arg_list()?.args(),\n         _ => return None,\n+    }\n+    .into_iter()\n+    // we need args len to determine whether to skip or not the &self parameter\n+    .collect::<Vec<_>>();\n+\n+    let (has_self_param, fn_signature) = get_fn_signature(db, analyzer, &expr)?;\n+    let parameters = if has_self_param && fn_signature.parameter_names.len() > args.len() {\n+        fn_signature.parameter_names.into_iter().skip(1)\n+    } else {\n+        fn_signature.parameter_names.into_iter().skip(0)\n     };\n \n-    let mut parameters = get_fn_signature(db, analyzer, &expr)?.parameter_names.into_iter();\n-\n-    if let ast::Expr::MethodCallExpr(_) = &expr {\n-        parameters.next();\n-    };\n-\n-    let hints = parameters\n-        .zip(args)\n-        .filter_map(|(param, arg)| {\n-            if arg.syntax().kind() == SyntaxKind::LITERAL && !param.is_empty() {\n-                Some((arg.syntax().text_range(), param))\n-            } else {\n-                None\n-            }\n-        })\n-        .map(|(range, param_name)| InlayHint {\n-            range,\n-            kind: InlayKind::ParameterHint,\n-            label: param_name.into(),\n-        });\n+    let hints =\n+        parameters\n+            .zip(args)\n+            .filter_map(|(param, arg)| {\n+                if !param.is_empty() {\n+                    Some((arg.syntax().text_range(), param))\n+                } else {\n+                    None\n+                }\n+            })\n+            .map(|(range, param_name)| InlayHint {\n+                range,\n+                kind: InlayKind::ParameterHint,\n+                label: param_name.into(),\n+            });\n \n     acc.extend(hints);\n     Some(())\n@@ -136,100 +143,32 @@ fn get_fn_signature(\n     db: &RootDatabase,\n     analyzer: &SourceAnalyzer,\n     expr: &ast::Expr,\n-) -> Option<FunctionSignature> {\n+) -> Option<(bool, FunctionSignature)> {\n     match expr {\n         ast::Expr::CallExpr(expr) => {\n             // FIXME: Type::as_callable is broken for closures\n             let callable_def = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n-                    let fn_def = it.into();\n-                    Some(FunctionSignature::from_hir(db, fn_def))\n+                    let fn_def: Function = it.into();\n+                    Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n                 }\n-                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into()),\n+                hir::CallableDef::StructId(it) => FunctionSignature::from_struct(db, it.into())\n+                    .map(|signature| (false, signature)),\n                 hir::CallableDef::EnumVariantId(it) => {\n                     FunctionSignature::from_enum_variant(db, it.into())\n+                        .map(|signature| (false, signature))\n                 }\n             }\n         }\n         ast::Expr::MethodCallExpr(expr) => {\n             let fn_def = analyzer.resolve_method_call(&expr)?;\n-            Some(FunctionSignature::from_hir(db, fn_def))\n+            Some((fn_def.has_self_param(db), FunctionSignature::from_hir(db, fn_def)))\n         }\n         _ => None,\n     }\n }\n \n-fn get_pat_type_hints(\n-    acc: &mut Vec<InlayHint>,\n-    db: &RootDatabase,\n-    analyzer: &SourceAnalyzer,\n-    root_pat: ast::Pat,\n-    skip_root_pat_hint: bool,\n-    max_inlay_hint_length: Option<usize>,\n-) {\n-    let original_pat = &root_pat.clone();\n-\n-    let hints = get_leaf_pats(root_pat)\n-        .into_iter()\n-        .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n-        .filter_map(|pat| {\n-            let ty = analyzer.type_of_pat(db, &pat)?;\n-            if ty.is_unknown() {\n-                return None;\n-            }\n-            Some((pat.syntax().text_range(), ty))\n-        })\n-        .map(|(range, pat_type)| InlayHint {\n-            range,\n-            kind: InlayKind::TypeHint,\n-            label: pat_type.display_truncated(db, max_inlay_hint_length).to_string().into(),\n-        });\n-\n-    acc.extend(hints);\n-}\n-\n-fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n-    let mut pats_to_process = std::collections::VecDeque::<ast::Pat>::new();\n-    pats_to_process.push_back(root_pat);\n-\n-    let mut leaf_pats = Vec::new();\n-\n-    while let Some(maybe_leaf_pat) = pats_to_process.pop_front() {\n-        match &maybe_leaf_pat {\n-            ast::Pat::BindPat(bind_pat) => match bind_pat.pat() {\n-                Some(pat) => pats_to_process.push_back(pat),\n-                _ => leaf_pats.push(maybe_leaf_pat),\n-            },\n-            ast::Pat::OrPat(ref_pat) => pats_to_process.extend(ref_pat.pats()),\n-            ast::Pat::TuplePat(tuple_pat) => pats_to_process.extend(tuple_pat.args()),\n-            ast::Pat::RecordPat(record_pat) => {\n-                if let Some(pat_list) = record_pat.record_field_pat_list() {\n-                    pats_to_process.extend(\n-                        pat_list\n-                            .record_field_pats()\n-                            .filter_map(|record_field_pat| {\n-                                record_field_pat\n-                                    .pat()\n-                                    .filter(|pat| pat.syntax().kind() != SyntaxKind::BIND_PAT)\n-                            })\n-                            .chain(pat_list.bind_pats().map(|bind_pat| {\n-                                bind_pat.pat().unwrap_or_else(|| ast::Pat::from(bind_pat))\n-                            })),\n-                    );\n-                }\n-            }\n-            ast::Pat::TupleStructPat(tuple_struct_pat) => {\n-                pats_to_process.extend(tuple_struct_pat.args())\n-            }\n-            ast::Pat::ParenPat(inner_pat) => pats_to_process.extend(inner_pat.pat()),\n-            ast::Pat::RefPat(ref_pat) => pats_to_process.extend(ref_pat.pat()),\n-            _ => (),\n-        }\n-    }\n-    leaf_pats\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n@@ -345,11 +284,6 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"i32\",\n             },\n-            InlayHint {\n-                range: [584; 585),\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n             InlayHint {\n                 range: [577; 578),\n                 kind: TypeHint,\n@@ -360,6 +294,11 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"f64\",\n             },\n+            InlayHint {\n+                range: [584; 585),\n+                kind: TypeHint,\n+                label: \"i32\",\n+            },\n             InlayHint {\n                 range: [627; 628),\n                 kind: TypeHint,\n@@ -507,6 +446,11 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"CustomOption<Test>\",\n             },\n+            InlayHint {\n+                range: [287; 291),\n+                kind: TypeHint,\n+                label: \"&CustomOption<Test>\",\n+            },\n             InlayHint {\n                 range: [334; 338),\n                 kind: TypeHint,\n@@ -522,11 +466,36 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"&u8\",\n             },\n+            InlayHint {\n+                range: [449; 450),\n+                kind: TypeHint,\n+                label: \"&CustomOption<u32>\",\n+            },\n+            InlayHint {\n+                range: [455; 456),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n             InlayHint {\n                 range: [531; 532),\n                 kind: TypeHint,\n                 label: \"&u32\",\n             },\n+            InlayHint {\n+                range: [538; 539),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n+            InlayHint {\n+                range: [618; 619),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n+            InlayHint {\n+                range: [675; 676),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n         ]\n         \"###\n         );\n@@ -570,6 +539,11 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"CustomOption<Test>\",\n             },\n+            InlayHint {\n+                range: [293; 297),\n+                kind: TypeHint,\n+                label: \"&CustomOption<Test>\",\n+            },\n             InlayHint {\n                 range: [343; 347),\n                 kind: TypeHint,\n@@ -585,11 +559,36 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"&u8\",\n             },\n+            InlayHint {\n+                range: [464; 465),\n+                kind: TypeHint,\n+                label: \"&CustomOption<u32>\",\n+            },\n+            InlayHint {\n+                range: [470; 471),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n             InlayHint {\n                 range: [549; 550),\n                 kind: TypeHint,\n                 label: \"&u32\",\n             },\n+            InlayHint {\n+                range: [556; 557),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n+            InlayHint {\n+                range: [639; 640),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n+            InlayHint {\n+                range: [699; 700),\n+                kind: TypeHint,\n+                label: \"&u8\",\n+            },\n         ]\n         \"###\n         );\n@@ -628,6 +627,11 @@ fn main() {\n \n         assert_debug_snapshot!(analysis.inlay_hints(file_id, None).unwrap(), @r###\"\n         [\n+            InlayHint {\n+                range: [272; 276),\n+                kind: TypeHint,\n+                label: \"CustomOption<Test>\",\n+            },\n             InlayHint {\n                 range: [311; 315),\n                 kind: TypeHint,\n@@ -643,11 +647,36 @@ fn main() {\n                 kind: TypeHint,\n                 label: \"u8\",\n             },\n+            InlayHint {\n+                range: [410; 411),\n+                kind: TypeHint,\n+                label: \"CustomOption<u32>\",\n+            },\n+            InlayHint {\n+                range: [416; 417),\n+                kind: TypeHint,\n+                label: \"u8\",\n+            },\n             InlayHint {\n                 range: [484; 485),\n                 kind: TypeHint,\n                 label: \"u32\",\n             },\n+            InlayHint {\n+                range: [491; 492),\n+                kind: TypeHint,\n+                label: \"u8\",\n+            },\n+            InlayHint {\n+                range: [563; 564),\n+                kind: TypeHint,\n+                label: \"u8\",\n+            },\n+            InlayHint {\n+                range: [612; 613),\n+                kind: TypeHint,\n+                label: \"u8\",\n+            },\n         ]\n         \"###\n         );\n@@ -737,11 +766,21 @@ fn main() {\n                 kind: ParameterHint,\n                 label: \"msg\",\n             },\n+            InlayHint {\n+                range: [277; 288),\n+                kind: ParameterHint,\n+                label: \"last\",\n+            },\n             InlayHint {\n                 range: [331; 334),\n                 kind: ParameterHint,\n                 label: \"param\",\n             },\n+            InlayHint {\n+                range: [354; 356),\n+                kind: ParameterHint,\n+                label: \"&self\",\n+            },\n             InlayHint {\n                 range: [358; 362),\n                 kind: ParameterHint,"}]}