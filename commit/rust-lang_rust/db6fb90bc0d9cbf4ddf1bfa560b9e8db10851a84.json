{"sha": "db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNmZiOTBiYzBkOWNiZjRkZGYxYmZhNTYwYjllOGRiMTA4NTFhODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T13:33:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T13:33:48Z"}, "message": "Auto merge of #6091 - ebroto:rustup, r=ebroto\n\nRustup\n\nchangelog: none\n\nr? `@ghost`", "tree": {"sha": "f57c7979ed924020348eff137aca86d0c323fbc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f57c7979ed924020348eff137aca86d0c323fbc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "html_url": "https://github.com/rust-lang/rust/commit/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "949b834067bdfbde6080358fae29845d86e2db01", "url": "https://api.github.com/repos/rust-lang/rust/commits/949b834067bdfbde6080358fae29845d86e2db01", "html_url": "https://github.com/rust-lang/rust/commit/949b834067bdfbde6080358fae29845d86e2db01"}, {"sha": "8bf27c5e92af39215a3d1da992a7207dafc883e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf27c5e92af39215a3d1da992a7207dafc883e1", "html_url": "https://github.com/rust-lang/rust/commit/8bf27c5e92af39215a3d1da992a7207dafc883e1"}], "stats": {"total": 352, "additions": 351, "deletions": 1}, "files": [{"sha": "529c2450541d714c3eadeec39fe14bf8d26f4b7c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "patch": "@@ -6,6 +6,7 @@\n #![feature(concat_idents)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "3e786da28dfe84224ba1cb9784b47e596c135a5d", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "patch": "@@ -1,10 +1,10 @@\n+use crate::utils::qualify_min_const_fn::is_min_const_fn;\n use crate::utils::{fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, span_lint, trait_ref_of_method};\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_mir::transform::qualify_min_const_fn::is_min_const_fn;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;"}, {"sha": "4d20a819804d90ccf66d7351f136e1a84ca1d185", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "patch": "@@ -87,6 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n \n         let maybe_storage_live_result = MaybeStorageLive\n             .into_engine(cx.tcx, mir, def_id.to_def_id())\n+            .pass_name(\"redundant_clone\")\n             .iterate_to_fixpoint()\n             .into_results_cursor(mir);\n         let mut possible_borrower = {"}, {"sha": "dfe2aadffc04d6757454d2f262182d70aa8b6048", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "patch": "@@ -18,6 +18,7 @@ pub mod internal_lints;\n pub mod numeric_literal;\n pub mod paths;\n pub mod ptr;\n+pub mod qualify_min_const_fn;\n pub mod sugg;\n pub mod usage;\n "}, {"sha": "3773b9d9a2ee9ad8e0c19798439efd3d6745d71c", "filename": "clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=db6fb90bc0d9cbf4ddf1bfa560b9e8db10851a84", "patch": "@@ -0,0 +1,347 @@\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::{\n+    Body, CastKind, NullOp, Operand, Place, ProjectionElem, Rvalue, Statement, StatementKind, Terminator,\n+    TerminatorKind,\n+};\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi::RustIntrinsic;\n+use std::borrow::Cow;\n+\n+type McfResult = Result<(), (Span, Cow<'static, str>)>;\n+\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n+    let mut current = def_id;\n+    loop {\n+        let predicates = tcx.predicates_of(current);\n+        for (predicate, _) in predicates.predicates {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(_)\n+                | ty::PredicateAtom::TypeOutlives(_)\n+                | ty::PredicateAtom::WellFormed(_)\n+                | ty::PredicateAtom::Projection(_)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..)\n+                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n+                ty::PredicateAtom::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n+                ty::PredicateAtom::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n+                ty::PredicateAtom::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n+                ty::PredicateAtom::Trait(pred, _) => {\n+                    if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n+                        continue;\n+                    }\n+                    match pred.self_ty().kind() {\n+                        ty::Param(ref p) => {\n+                            let generics = tcx.generics_of(current);\n+                            let def = generics.type_param(p, tcx);\n+                            let span = tcx.def_span(def.def_id);\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ));\n+                        },\n+                        // other kinds of bounds are either tautologies\n+                        // or cause errors in other passes\n+                        _ => continue,\n+                    }\n+                },\n+            }\n+        }\n+        match predicates.parent {\n+            Some(parent) => current = parent,\n+            None => break,\n+        }\n+    }\n+\n+    for local in &body.local_decls {\n+        check_ty(tcx, local.ty, local.source_info.span)?;\n+    }\n+    // impl trait is gone in MIR, so check the return type manually\n+    check_ty(\n+        tcx,\n+        tcx.fn_sig(def_id).output().skip_binder(),\n+        body.local_decls.iter().next().unwrap().source_info.span,\n+    )?;\n+\n+    for bb in body.basic_blocks() {\n+        check_terminator(tcx, body, bb.terminator())?;\n+        for stmt in &bb.statements {\n+            check_statement(tcx, body, def_id, stmt)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n+    for arg in ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No constraints on lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n+        match ty.kind() {\n+            ty::Ref(_, _, hir::Mutability::Mut) => {\n+                return Err((span, \"mutable references in const fn are unstable\".into()));\n+            },\n+            ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::FnPtr(..) => {\n+                return Err((span, \"function pointers in const fn are unstable\".into()));\n+            },\n+            ty::Dynamic(preds, _) => {\n+                for pred in preds.iter() {\n+                    match pred.skip_binder() {\n+                        ty::ExistentialPredicate::AutoTrait(_) | ty::ExistentialPredicate::Projection(_) => {\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ));\n+                        },\n+                        ty::ExistentialPredicate::Trait(trait_ref) => {\n+                            if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n+                                return Err((\n+                                    span,\n+                                    \"trait bounds other than `Sized` \\\n+                                     on const fn parameters are unstable\"\n+                                        .into(),\n+                                ));\n+                            }\n+                        },\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rvalue<'tcx>, span: Span) -> McfResult {\n+    match rvalue {\n+        Rvalue::ThreadLocalRef(_) => Err((span, \"cannot access thread local storage in const fn\".into())),\n+        Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => check_operand(tcx, operand, span, body),\n+        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+            check_place(tcx, *place, span, body)\n+        },\n+        Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n+            use rustc_middle::ty::cast::CastTy;\n+            let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n+            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            match (cast_in, cast_out) {\n+                (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n+                    Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n+                },\n+                _ => check_operand(tcx, operand, span, body),\n+            }\n+        },\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer), operand, _) => {\n+            check_operand(tcx, operand, span, body)\n+        },\n+        Rvalue::Cast(\n+            CastKind::Pointer(\n+                PointerCast::UnsafeFnPointer | PointerCast::ClosureFnPointer(_) | PointerCast::ReifyFnPointer,\n+            ),\n+            _,\n+            _,\n+        ) => Err((span, \"function pointer casts are not allowed in const fn\".into())),\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), op, cast_ty) => {\n+            let pointee_ty = if let Some(deref_ty) = cast_ty.builtin_deref(true) {\n+                deref_ty.ty\n+            } else {\n+                // We cannot allow this for now.\n+                return Err((span, \"unsizing casts are only allowed for references right now\".into()));\n+            };\n+            let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n+            if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n+                check_operand(tcx, op, span, body)?;\n+                // Casting/coercing things to slices is fine.\n+                Ok(())\n+            } else {\n+                // We just can't allow trait objects until we have figured out trait method calls.\n+                Err((span, \"unsizing casts are not allowed in const fn\".into()))\n+            }\n+        },\n+        // binops are fine on integers\n+        Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+            check_operand(tcx, lhs, span, body)?;\n+            check_operand(tcx, rhs, span, body)?;\n+            let ty = lhs.ty(body, tcx);\n+            if ty.is_integral() || ty.is_bool() || ty.is_char() {\n+                Ok(())\n+            } else {\n+                Err((\n+                    span,\n+                    \"only int, `bool` and `char` operations are stable in const fn\".into(),\n+                ))\n+            }\n+        },\n+        Rvalue::NullaryOp(NullOp::SizeOf, _) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::Box, _) => Err((span, \"heap allocations are not allowed in const fn\".into())),\n+        Rvalue::UnaryOp(_, operand) => {\n+            let ty = operand.ty(body, tcx);\n+            if ty.is_integral() || ty.is_bool() {\n+                check_operand(tcx, operand, span, body)\n+            } else {\n+                Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n+            }\n+        },\n+        Rvalue::Aggregate(_, operands) => {\n+            for operand in operands {\n+                check_operand(tcx, operand, span, body)?;\n+            }\n+            Ok(())\n+        },\n+    }\n+}\n+\n+fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statement: &Statement<'tcx>) -> McfResult {\n+    let span = statement.source_info.span;\n+    match &statement.kind {\n+        StatementKind::Assign(box (place, rval)) => {\n+            check_place(tcx, *place, span, body)?;\n+            check_rvalue(tcx, body, def_id, rval, span)\n+        },\n+\n+        StatementKind::FakeRead(_, place) |\n+        // just an assignment\n+        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, **place, span, body),\n+\n+        StatementKind::LlvmInlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n+\n+        // These are all NOPs\n+        StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        | StatementKind::Retag { .. }\n+        | StatementKind::AscribeUserType(..)\n+        | StatementKind::Coverage(..)\n+        | StatementKind::Nop => Ok(()),\n+    }\n+}\n+\n+fn check_operand(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+    match operand {\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n+        Operand::Constant(c) => match c.check_static_ptr(tcx) {\n+            Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+            None => Ok(()),\n+        },\n+    }\n+}\n+\n+fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+    let mut cursor = place.projection.as_ref();\n+    while let [ref proj_base @ .., elem] = *cursor {\n+        cursor = proj_base;\n+        match elem {\n+            ProjectionElem::Field(..) => {\n+                let base_ty = Place::ty_from(place.local, &proj_base, body, tcx).ty;\n+                if let Some(def) = base_ty.ty_adt_def() {\n+                    // No union field accesses in `const fn`\n+                    if def.is_union() {\n+                        return Err((span, \"accessing union fields is unstable\".into()));\n+                    }\n+                }\n+            },\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Downcast(..)\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Deref\n+            | ProjectionElem::Index(_) => {},\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Terminator<'tcx>) -> McfResult {\n+    let span = terminator.source_info.span;\n+    match &terminator.kind {\n+        TerminatorKind::FalseEdge { .. }\n+        | TerminatorKind::FalseUnwind { .. }\n+        | TerminatorKind::Goto { .. }\n+        | TerminatorKind::Return\n+        | TerminatorKind::Resume\n+        | TerminatorKind::Unreachable => Ok(()),\n+\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, body),\n+        TerminatorKind::DropAndReplace { place, value, .. } => {\n+            check_place(tcx, *place, span, body)?;\n+            check_operand(tcx, value, span, body)\n+        },\n+\n+        TerminatorKind::SwitchInt {\n+            discr,\n+            switch_ty: _,\n+            values: _,\n+            targets: _,\n+        } => check_operand(tcx, discr, span, body),\n+\n+        TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n+        TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n+            Err((span, \"const fn generators are unstable\".into()))\n+        },\n+\n+        TerminatorKind::Call {\n+            func,\n+            args,\n+            from_hir_call: _,\n+            destination: _,\n+            cleanup: _,\n+            fn_span: _,\n+        } => {\n+            let fn_ty = func.ty(body, tcx);\n+            if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n+                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id) {\n+                    return Err((\n+                        span,\n+                        format!(\n+                            \"can only call other `const fn` within a `const fn`, \\\n+                             but `{:?}` is not stable as `const fn`\",\n+                            func,\n+                        )\n+                        .into(),\n+                    ));\n+                }\n+\n+                // HACK: This is to \"unstabilize\" the `transmute` intrinsic\n+                // within const fns. `transmute` is allowed in all other const contexts.\n+                // This won't really scale to more intrinsics or functions. Let's allow const\n+                // transmutes in const fn before we add more hacks to this.\n+                if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic && tcx.item_name(fn_def_id) == sym::transmute {\n+                    return Err((\n+                        span,\n+                        \"can only call `transmute` from const items, not `const fn`\".into(),\n+                    ));\n+                }\n+\n+                check_operand(tcx, func, span, body)?;\n+\n+                for arg in args {\n+                    check_operand(tcx, arg, span, body)?;\n+                }\n+                Ok(())\n+            } else {\n+                Err((span, \"can only call other const fns within const fn\".into()))\n+            }\n+        },\n+\n+        TerminatorKind::Assert {\n+            cond,\n+            expected: _,\n+            msg: _,\n+            target: _,\n+            cleanup: _,\n+        } => check_operand(tcx, cond, span, body),\n+\n+        TerminatorKind::InlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n+    }\n+}"}]}