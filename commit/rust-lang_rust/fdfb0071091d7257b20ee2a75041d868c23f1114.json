{"sha": "fdfb0071091d7257b20ee2a75041d868c23f1114", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZmIwMDcxMDkxZDcyNTdiMjBlZTJhNzUwNDFkODY4YzIzZjExMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-20T23:26:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-20T23:26:20Z"}, "message": "Auto merge of #46862 - nikomatsakis:nll-master, r=arielb1\n\nNLL feature complete (adds `feature(nll)`)!\n\nThis is the final PR for the nll-master branch; it brings over all remaining content.\n\nThe contents of the branch include:\n\n- track causal information and use it to report extended errors\n- handle `impl Trait` in NLL code\n- improve printing of outlives errors\n- add `#![feature(nll)]` and some more sample tests\n\nThe commits should for the most part build independently.\n\nr? @pnkfelix (and/or @arielb1)", "tree": {"sha": "54815ef2cafd3e9c0cf6000fa19809ac732f2653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54815ef2cafd3e9c0cf6000fa19809ac732f2653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdfb0071091d7257b20ee2a75041d868c23f1114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdfb0071091d7257b20ee2a75041d868c23f1114", "html_url": "https://github.com/rust-lang/rust/commit/fdfb0071091d7257b20ee2a75041d868c23f1114", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdfb0071091d7257b20ee2a75041d868c23f1114/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eb64b86ce44cc1828dd176a8b981e37ea08fc38", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb64b86ce44cc1828dd176a8b981e37ea08fc38", "html_url": "https://github.com/rust-lang/rust/commit/7eb64b86ce44cc1828dd176a8b981e37ea08fc38"}, {"sha": "d925f4d1ddef8b894e4e85a115c39b63c37cc30b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d925f4d1ddef8b894e4e85a115c39b63c37cc30b", "html_url": "https://github.com/rust-lang/rust/commit/d925f4d1ddef8b894e4e85a115c39b63c37cc30b"}], "stats": {"total": 5976, "additions": 4132, "deletions": 1844}, "files": [{"sha": "be5314a2c170a05b46d58f8146299eddbbc24895", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,626 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n+use infer::outlives::free_region_map::FreeRegionRelations;\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax::ast;\n+use traits::{self, PredicateObligation};\n+use ty::{self, Ty};\n+use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::outlives::Component;\n+use ty::subst::{Kind, Substs};\n+use util::nodemap::DefIdMap;\n+\n+pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n+\n+/// Information about the anonymous, abstract types whose values we\n+/// are inferring in this function (these are the `impl Trait` that\n+/// appear in the return type).\n+#[derive(Copy, Clone, Debug)]\n+pub struct AnonTypeDecl<'tcx> {\n+    /// The substitutions that we apply to the abstract that that this\n+    /// `impl Trait` desugars to. e.g., if:\n+    ///\n+    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n+    ///\n+    /// winds up desugared to:\n+    ///\n+    ///     abstract type Foo<'x, T>: Trait<'x>\n+    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n+    ///\n+    /// then `substs` would be `['a, T]`.\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// The type variable that represents the value of the abstract type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    pub concrete_ty: Ty<'tcx>,\n+\n+    /// True if the `impl Trait` bounds include region bounds.\n+    /// For example, this would be true for:\n+    ///\n+    ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n+    ///\n+    /// but false for:\n+    ///\n+    ///     fn foo<'c>() -> impl Trait<'c>\n+    ///\n+    /// unless `Trait` was declared like:\n+    ///\n+    ///     trait Trait<'c>: 'c\n+    ///\n+    /// in which case it would be true.\n+    ///\n+    /// This is used during regionck to decide whether we need to\n+    /// impose any additional constraints to ensure that region\n+    /// variables in `concrete_ty` wind up being constrained to\n+    /// something from `substs` (or, at minimum, things that outlive\n+    /// the fn body). (Ultimately, writeback is responsible for this\n+    /// check.)\n+    pub has_required_region_bounds: bool,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// Replace all anonymized types in `value` with fresh inference variables\n+    /// and creates appropriate obligations. For example, given the input:\n+    ///\n+    ///     impl Iterator<Item = impl Debug>\n+    ///\n+    /// this method would create two type variables, `?0` and `?1`. It would\n+    /// return the type `?0` but also the obligations:\n+    ///\n+    ///     ?0: Iterator<Item = ?1>\n+    ///     ?1: Debug\n+    ///\n+    /// Moreover, it returns a `AnonTypeMap` that would map `?0` to\n+    /// info about the `impl Iterator<..>` type and `?1` to info about\n+    /// the `impl Debug` type.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `parent_def_id` -- we will only instantiate anonymous types\n+    ///   with this parent. This is typically the def-id of the function\n+    ///   in whose return type anon types are being instantiated.\n+    /// - `body_id` -- the body-id with which the resulting obligations should\n+    ///   be associated\n+    /// - `param_env` -- the in-scope parameter environment to be used for\n+    ///   obligations\n+    /// - `value` -- the value within which we are instantiating anon types\n+    pub fn instantiate_anon_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        parent_def_id: DefId,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n+        debug!(\n+            \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n+            value,\n+            parent_def_id,\n+            body_id,\n+            param_env,\n+        );\n+        let mut instantiator = Instantiator {\n+            infcx: self,\n+            parent_def_id,\n+            body_id,\n+            param_env,\n+            anon_types: DefIdMap(),\n+            obligations: vec![],\n+        };\n+        let value = instantiator.instantiate_anon_types_in_map(value);\n+        InferOk {\n+            value: (value, instantiator.anon_types),\n+            obligations: instantiator.obligations,\n+        }\n+    }\n+\n+    /// Given the map `anon_types` containing the existential `impl\n+    /// Trait` types whose underlying, hidden types are being\n+    /// inferred, this method adds constraints to the regions\n+    /// appearing in those underlying hidden types to ensure that they\n+    /// at least do not refer to random scopes within the current\n+    /// function. These constraints are not (quite) sufficient to\n+    /// guarantee that the regions are actually legal values; that\n+    /// final condition is imposed after region inference is done.\n+    ///\n+    /// # The Problem\n+    ///\n+    /// Let's work through an example to explain how it works.  Assume\n+    /// the current function is as follows:\n+    ///\n+    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    ///\n+    /// Here, we have two `impl Trait` types whose values are being\n+    /// inferred (the `impl Bar<'a>` and the `impl\n+    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n+    /// define underlying abstract types (`Foo1`, `Foo2`) and then, in\n+    /// the return type of `foo`, we *reference* those definitions:\n+    ///\n+    ///     abstract type Foo1<'x>: Bar<'x>;\n+    ///     abstract type Foo2<'x>: Bar<'x>;\n+    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                        //  ^^^^ ^^\n+    ///                        //  |    |\n+    ///                        //  |    substs\n+    ///                        //  def_id\n+    ///\n+    /// As indicating in the comments above, each of those references\n+    /// is (in the compiler) basically a substitution (`substs`)\n+    /// applied to the type of a suitable `def_id` (which identifies\n+    /// `Foo1` or `Foo2`).\n+    ///\n+    /// Now, at this point in compilation, what we have done is to\n+    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n+    /// fresh inference variables C1 and C2. We wish to use the values\n+    /// of these variables to infer the underlying types of `Foo1` and\n+    /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n+    /// constraints like:\n+    ///\n+    ///     for<'a> (Foo1<'a> = C1)\n+    ///     for<'b> (Foo1<'b> = C2)\n+    ///\n+    /// For these equation to be satisfiable, the types `C1` and `C2`\n+    /// can only refer to a limited set of regions. For example, `C1`\n+    /// can only refer to `'static` and `'a`, and `C2` can only refer\n+    /// to `'static` and `'b`. The job of this function is to impose that\n+    /// constraint.\n+    ///\n+    /// Up to this point, C1 and C2 are basically just random type\n+    /// inference variables, and hence they may contain arbitrary\n+    /// regions. In fact, it is fairly likely that they do! Consider\n+    /// this possible definition of `foo`:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    ///         (&*x, &*y)\n+    ///     }\n+    ///\n+    /// Here, the values for the concrete types of the two impl\n+    /// traits will include inference variables:\n+    ///\n+    ///     &'0 i32\n+    ///     &'1 i32\n+    ///\n+    /// Ordinarily, the subtyping rules would ensure that these are\n+    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n+    /// type per se, we don't get such constraints by default.  This\n+    /// is where this function comes into play. It adds extra\n+    /// constraints to ensure that all the regions which appear in the\n+    /// inferred type are regions that could validly appear.\n+    ///\n+    /// This is actually a bit of a tricky constraint in general. We\n+    /// want to say that each variable (e.g., `'0``) can only take on\n+    /// values that were supplied as arguments to the abstract type\n+    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n+    /// scope. We don't have a constraint quite of this kind in the current\n+    /// region checker.\n+    ///\n+    /// # The Solution\n+    ///\n+    /// We make use of the constraint that we *do* have in the `<=`\n+    /// relation. To do that, we find the \"minimum\" of all the\n+    /// arguments that appear in the substs: that is, some region\n+    /// which is less than all the others. In the case of `Foo1<'a>`,\n+    /// that would be `'a` (it's the only choice, after all). Then we\n+    /// apply that as a least bound to the variables (e.g., `'a <=\n+    /// '0`).\n+    ///\n+    /// In some cases, there is no minimum. Consider this example:\n+    ///\n+    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    ///\n+    /// Here we would report an error, because `'a` and `'b` have no\n+    /// relation to one another.\n+    ///\n+    /// # The `free_region_relations` parameter\n+    ///\n+    /// The `free_region_relations` argument is used to find the\n+    /// \"minimum\" of the regions supplied to a given abstract type.\n+    /// It must be a relation that can answer whether `'a <= 'b`,\n+    /// where `'a` and `'b` are regions that appear in the \"substs\"\n+    /// for the abstract type references (the `<'a>` in `Foo1<'a>`).\n+    ///\n+    /// Note that we do not impose the constraints based on the\n+    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n+    /// is because the constraints we are imposing here is basically\n+    /// the concern of the one generating the constraining type C1,\n+    /// which is the current function. It also means that we can\n+    /// take \"implied bounds\" into account in some cases:\n+    ///\n+    ///     trait SomeTrait<'a, 'b> { }\n+    ///     fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    ///\n+    /// Here, the fact that `'b: 'a` is known only because of the\n+    /// implied bounds from the `&'a &'b u32` parameter, and is not\n+    /// \"inherent\" to the abstract type definition.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `anon_types` -- the map produced by `instantiate_anon_types`\n+    /// - `free_region_relations` -- something that can be used to relate\n+    ///   the free regions (`'a`) that appear in the impl trait.\n+    pub fn constrain_anon_types<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        anon_types: &AnonTypeMap<'tcx>,\n+        free_region_relations: &FRR,\n+    ) {\n+        debug!(\"constrain_anon_types()\");\n+\n+        for (&def_id, anon_defn) in anon_types {\n+            self.constrain_anon_type(def_id, anon_defn, free_region_relations);\n+        }\n+    }\n+\n+    fn constrain_anon_type<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        def_id: DefId,\n+        anon_defn: &AnonTypeDecl<'tcx>,\n+        free_region_relations: &FRR,\n+    ) {\n+        debug!(\"constrain_anon_type()\");\n+        debug!(\"constrain_anon_type: def_id={:?}\", def_id);\n+        debug!(\"constrain_anon_type: anon_defn={:#?}\", anon_defn);\n+\n+        let concrete_ty = self.resolve_type_vars_if_possible(&anon_defn.concrete_ty);\n+\n+        debug!(\"constrain_anon_type: concrete_ty={:?}\", concrete_ty);\n+\n+        let abstract_type_generics = self.tcx.generics_of(def_id);\n+\n+        let span = self.tcx.def_span(def_id);\n+\n+        // If there are required region bounds, we can just skip\n+        // ahead.  There will already be a registered region\n+        // obligation related `concrete_ty` to those regions.\n+        if anon_defn.has_required_region_bounds {\n+            return;\n+        }\n+\n+        // There were no `required_region_bounds`,\n+        // so we have to search for a `least_region`.\n+        // Go through all the regions used as arguments to the\n+        // abstract type. These are the parameters to the abstract\n+        // type; so in our example above, `substs` would contain\n+        // `['a]` for the first impl trait and `'b` for the\n+        // second.\n+        let mut least_region = None;\n+        for region_def in &abstract_type_generics.regions {\n+            // Find the index of this region in the list of substitutions.\n+            let index = region_def.index as usize;\n+\n+            // Get the value supplied for this region from the substs.\n+            let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+\n+            // Compute the least upper bound of it with the other regions.\n+            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+            debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n+            match least_region {\n+                None => least_region = Some(subst_arg),\n+                Some(lr) => {\n+                    if free_region_relations.sub_free_regions(lr, subst_arg) {\n+                        // keep the current least region\n+                    } else if free_region_relations.sub_free_regions(subst_arg, lr) {\n+                        // switch to `subst_arg`\n+                        least_region = Some(subst_arg);\n+                    } else {\n+                        // There are two regions (`lr` and\n+                        // `subst_arg`) which are not relatable. We can't\n+                        // find a best choice.\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n+                            .span_label(\n+                                span,\n+                                format!(\"neither `{}` nor `{}` outlives the other\", lr, subst_arg),\n+                            )\n+                            .emit();\n+\n+                        least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n+        debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+\n+        // Require that the type `concrete_ty` outlives\n+        // `least_region`, modulo any type parameters that appear\n+        // in the type, which we ignore. This is because impl\n+        // trait values are assumed to capture all the in-scope\n+        // type parameters. This little loop here just invokes\n+        // `outlives` repeatedly, draining all the nested\n+        // obligations that result.\n+        let mut types = vec![concrete_ty];\n+        let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n+        while let Some(ty) = types.pop() {\n+            let mut components = self.tcx.outlives_components(ty);\n+            while let Some(component) = components.pop() {\n+                match component {\n+                    Component::Region(r) => {\n+                        bound_region(r);\n+                    }\n+\n+                    Component::Param(_) => {\n+                        // ignore type parameters like `T`, they are captured\n+                        // implicitly by the `impl Trait`\n+                    }\n+\n+                    Component::UnresolvedInferenceVariable(_) => {\n+                        // we should get an error that more type\n+                        // annotations are needed in this case\n+                        self.tcx\n+                            .sess\n+                            .delay_span_bug(span, \"unresolved inf var in anon\");\n+                    }\n+\n+                    Component::Projection(ty::ProjectionTy {\n+                        substs,\n+                        item_def_id: _,\n+                    }) => {\n+                        for r in substs.regions() {\n+                            bound_region(r);\n+                        }\n+                        types.extend(substs.types());\n+                    }\n+\n+                    Component::EscapingProjection(more_components) => {\n+                        components.extend(more_components);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given the fully resolved, instantiated type for an anonymous\n+    /// type, i.e., the value of an inference variable like C1 or C2\n+    /// (*), computes the \"definition type\" for an abstract type\n+    /// definition -- that is, the inferred value of `Foo1<'x>` or\n+    /// `Foo2<'x>` that we would conceptually use in its definition:\n+    ///\n+    ///     abstract type Foo1<'x>: Bar<'x> = AAA; <-- this type AAA\n+    ///     abstract type Foo2<'x>: Bar<'x> = BBB; <-- or this type BBB\n+    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///\n+    /// Note that these values are defined in terms of a distinct set of\n+    /// generic parameters (`'x` instead of `'a`) from C1 or C2. The main\n+    /// purpose of this function is to do that translation.\n+    ///\n+    /// (*) C1 and C2 were introduced in the comments on\n+    /// `constrain_anon_types`. Read that comment for more context.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `def_id`, the `impl Trait` type\n+    /// - `anon_defn`, the anonymous definition created in `instantiate_anon_types`\n+    /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n+    ///   `anon_defn.concrete_ty`\n+    pub fn infer_anon_definition_from_instantiation(\n+        &self,\n+        def_id: DefId,\n+        anon_defn: &AnonTypeDecl<'tcx>,\n+        instantiated_ty: Ty<'gcx>,\n+    ) -> Ty<'gcx> {\n+        debug!(\n+            \"infer_anon_definition_from_instantiation(instantiated_ty={:?})\",\n+            instantiated_ty\n+        );\n+\n+        let gcx = self.tcx.global_tcx();\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = Substs::identity_for_item(gcx, def_id);\n+        let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> = anon_defn\n+            .substs\n+            .iter()\n+            .enumerate()\n+            .map(|(index, subst)| (*subst, id_substs[index]))\n+            .collect();\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        let definition_ty = gcx.fold_regions(&instantiated_ty, &mut false, |r, _| {\n+            match *r {\n+                // 'static and early-bound regions are valid.\n+                ty::ReStatic | ty::ReEmpty => r,\n+\n+                // All other regions, we map them appropriately to their adjusted\n+                // indices, erroring if we find any lifetimes that were not mapped\n+                // into the new set.\n+                _ => if let Some(r1) = map.get(&Kind::from(r)).and_then(|k| k.as_region()) {\n+                    r1\n+                } else {\n+                    // No mapping was found. This means that\n+                    // it is either a disallowed lifetime,\n+                    // which will be caught by regionck, or it\n+                    // is a region in a non-upvar closure\n+                    // generic, which is explicitly\n+                    // allowed. If that surprises you, read\n+                    // on.\n+                    //\n+                    // The case of closure is a somewhat\n+                    // subtle (read: hacky) consideration. The\n+                    // problem is that our closure types\n+                    // currently include all the lifetime\n+                    // parameters declared on the enclosing\n+                    // function, even if they are unused by\n+                    // the closure itself. We can't readily\n+                    // filter them out, so here we replace\n+                    // those values with `'empty`. This can't\n+                    // really make a difference to the rest of\n+                    // the compiler; those regions are ignored\n+                    // for the outlives relation, and hence\n+                    // don't affect trait selection or auto\n+                    // traits, and they are erased during\n+                    // trans.\n+                    gcx.types.re_empty\n+                },\n+            }\n+        });\n+\n+        debug!(\n+            \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n+            definition_ty\n+        );\n+\n+        definition_ty\n+    }\n+}\n+\n+struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    parent_def_id: DefId,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    anon_types: AnonTypeMap<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n+    fn instantiate_anon_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        debug!(\"instantiate_anon_types_in_map(value={:?})\", value);\n+        let tcx = self.infcx.tcx;\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            fldop: |ty| {\n+                if let ty::TyAnon(def_id, substs) = ty.sty {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named abstract types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using `abstract type` that indicates\n+                    // the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub abstract type Foo: Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references a\n+                    // `TyAnon` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Anon assoc with `foo`\n+                    // }\n+                    // ```\n+                    if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n+                        let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n+                        let anon_parent_def_id = tcx.hir.local_def_id(anon_parent_node_id);\n+                        if self.parent_def_id == anon_parent_def_id {\n+                            return self.fold_anon_ty(ty, def_id, substs);\n+                        }\n+\n+                        debug!(\"instantiate_anon_types_in_map: \\\n+                                encountered anon with wrong parent \\\n+                                def_id={:?} \\\n+                                anon_parent_def_id={:?}\",\n+                               def_id,\n+                               anon_parent_def_id);\n+                    }\n+                }\n+\n+                ty\n+            },\n+        })\n+    }\n+\n+    fn fold_anon_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+\n+        debug!(\n+            \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n+            def_id,\n+            substs\n+        );\n+\n+        // Use the same type variable if the exact same TyAnon appears more\n+        // than once in the return type (e.g. if it's passed to a type alias).\n+        if let Some(anon_defn) = self.anon_types.get(&def_id) {\n+            return anon_defn.concrete_ty;\n+        }\n+        let span = tcx.def_span(def_id);\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+\n+        let predicates_of = tcx.predicates_of(def_id);\n+        let bounds = predicates_of.instantiate(tcx, substs);\n+        debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n+\n+        let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n+        debug!(\n+            \"instantiate_anon_types: required_region_bounds={:?}\",\n+            required_region_bounds\n+        );\n+\n+        self.anon_types.insert(\n+            def_id,\n+            AnonTypeDecl {\n+                substs,\n+                concrete_ty: ty_var,\n+                has_required_region_bounds: !required_region_bounds.is_empty(),\n+            },\n+        );\n+        debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n+\n+        for predicate in bounds.predicates {\n+            // Change the predicate to refer to the type variable,\n+            // which will be the concrete type, instead of the TyAnon.\n+            // This also instantiates nested `impl Trait`.\n+            let predicate = self.instantiate_anon_types_in_map(&predicate);\n+\n+            let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);\n+\n+            // Require that the predicate holds for the concrete type.\n+            debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n+            self.obligations\n+                .push(traits::Obligation::new(cause, self.param_env, predicate));\n+        }\n+\n+        ty_var\n+    }\n+}"}, {"sha": "cade67a44bb0e40adfff9f003db3ae3bdd264d8e", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "removed", "additions": 0, "deletions": 415, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=7eb64b86ce44cc1828dd176a8b981e37ea08fc38", "patch": "@@ -1,415 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where both the regions are anonymous.\n-use hir;\n-use infer::InferCtxt;\n-use ty::{self, Region};\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use hir::map as hir_map;\n-use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use infer::error_reporting::util::AnonymousArgInfo;\n-\n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n-    ///\n-    /// Consider a case where we have\n-    ///\n-    /// ```no_run\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    ///     x.push(y);\n-    /// }\n-    /// ```\n-    ///\n-    /// The example gives\n-    ///\n-    /// ```text\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n-    ///                    ---      --- these references are declared with different lifetimes...\n-    ///     x.push(y);\n-    ///     ^ ...but data from `y` flows into `x` here\n-    /// ```\n-    ///\n-    /// It has been extended for the case of structs too.\n-    ///\n-    /// Consider the example\n-    ///\n-    /// ```no_run\n-    /// struct Ref<'a> { x: &'a u32 }\n-    /// ```\n-    ///\n-    /// ```text\n-    /// fn foo(mut x: Vec<Ref>, y: Ref) {\n-    ///                   ---      --- these structs are declared with different lifetimes...\n-    ///     x.push(y);\n-    ///     ^ ...but data from `y` flows into `x` here\n-    /// }\n-    /// ````\n-    ///\n-    /// It will later be extended to trait objects.\n-    pub fn try_report_anon_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        let (span, sub, sup) = match *error {\n-            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n-            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n-            _ => return false, // inapplicable\n-        };\n-\n-        // Determine whether the sub and sup consist of both anonymous (elided) regions.\n-        let anon_reg_sup = or_false!(self.is_suitable_region(sup));\n-\n-        let anon_reg_sub = or_false!(self.is_suitable_region(sub));\n-        let scope_def_id_sup = anon_reg_sup.def_id;\n-        let bregion_sup = anon_reg_sup.boundregion;\n-        let scope_def_id_sub = anon_reg_sub.def_id;\n-        let bregion_sub = anon_reg_sub.boundregion;\n-\n-        let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n-\n-        let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n-\n-        debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n-               ty_sub,\n-               sup,\n-               bregion_sup);\n-        debug!(\"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n-               ty_sup,\n-               sub,\n-               bregion_sub);\n-\n-        let (ty_sup, ty_fndecl_sup) = ty_sup;\n-        let (ty_sub, ty_fndecl_sub) = ty_sub;\n-\n-        let AnonymousArgInfo { arg: anon_arg_sup, .. } =\n-            or_false!(self.find_arg_with_region(sup, sup));\n-        let AnonymousArgInfo { arg: anon_arg_sub, .. } =\n-            or_false!(self.find_arg_with_region(sub, sub));\n-\n-        let sup_is_ret_type =\n-            self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n-        let sub_is_ret_type =\n-            self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n-\n-        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n-            format!(\" from `{}`\", simple_name)\n-        } else {\n-            format!(\"\")\n-        };\n-\n-        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n-            format!(\" into `{}`\", simple_name)\n-        } else {\n-            format!(\"\")\n-        };\n-\n-\n-        let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n-            (None, None) => {\n-                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n-\n-                    (format!(\"this type is declared with multiple lifetimes...\"),\n-                     format!(\"...but data{} flows{} here\",\n-                             format!(\" with one lifetime\"),\n-                             format!(\" into the other\")))\n-                } else {\n-                    (format!(\"these two types are declared with different lifetimes...\"),\n-                     format!(\"...but data{} flows{} here\",\n-                             span_label_var1,\n-                             span_label_var2))\n-                };\n-                (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n-            }\n-\n-            (Some(ret_span), _) => {\n-                (ty_sub.span,\n-                 ret_span,\n-                 format!(\"this parameter and the return type are declared \\\n-                          with different lifetimes...\",),\n-                 format!(\"...but data{} is returned here\", span_label_var1))\n-            }\n-            (_, Some(ret_span)) => {\n-                (ty_sup.span,\n-                 ret_span,\n-                 format!(\"this parameter and the return type are declared \\\n-                          with different lifetimes...\",),\n-                 format!(\"...but data{} is returned here\", span_label_var1))\n-            }\n-        };\n-\n-\n-        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(span_1, main_label)\n-            .span_label(span_2, format!(\"\"))\n-            .span_label(span, span_label)\n-            .emit();\n-        return true;\n-    }\n-\n-    /// This function calls the `visit_ty` method for the parameters\n-    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n-    /// contains the anonymous type.\n-    ///\n-    /// # Arguments\n-    /// region - the anonymous region corresponding to the anon_anon conflict\n-    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n-    ///\n-    /// # Example\n-    /// ```\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n-    ///    { x.push(y); }\n-    /// ```\n-    /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self,\n-                          region: Region<'tcx>,\n-                          br: &ty::BoundRegion)\n-                          -> Option<(&hir::Ty, &hir::FnDecl)> {\n-        if let Some(anon_reg) = self.is_suitable_region(region) {\n-            let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let fndecl = match self.tcx.hir.get(node_id) {\n-                    hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n-                        &fndecl\n-                    }\n-                    hir_map::NodeTraitItem(&hir::TraitItem {\n-                                               node: hir::TraitItemKind::Method(ref m, ..), ..\n-                                           }) |\n-                    hir_map::NodeImplItem(&hir::ImplItem {\n-                                              node: hir::ImplItemKind::Method(ref m, ..), ..\n-                                          }) => &m.decl,\n-                    _ => return None,\n-                };\n-\n-                return fndecl\n-                           .inputs\n-                           .iter()\n-                           .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n-                           .next()\n-                           .map(|ty| (ty, &**fndecl));\n-            }\n-        }\n-        None\n-    }\n-\n-    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n-    // to the anonymous region.\n-    fn find_component_for_bound_region(&self,\n-                                       arg: &'gcx hir::Ty,\n-                                       br: &ty::BoundRegion)\n-                                       -> Option<(&'gcx hir::Ty)> {\n-        let mut nested_visitor = FindNestedTypeVisitor {\n-            infcx: &self,\n-            hir_map: &self.tcx.hir,\n-            bound_region: *br,\n-            found_type: None,\n-            depth: 1,\n-        };\n-        nested_visitor.visit_ty(arg);\n-        nested_visitor.found_type\n-    }\n-}\n-\n-// The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n-// anonymous region. The example above would lead to a conflict between\n-// the two anonymous lifetimes for &u8 in x and y respectively. This visitor\n-// would be invoked twice, once for each lifetime, and would\n-// walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    // The bound_region corresponding to the Refree(freeregion)\n-    // associated with the anonymous region we are looking for.\n-    bound_region: ty::BoundRegion,\n-    // The type where the anonymous lifetime appears\n-    // for e.g. Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'gcx hir::Ty>,\n-    depth: u32,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        match arg.node {\n-            hir::TyBareFn(_) => {\n-                self.depth += 1;\n-                intravisit::walk_ty(self, arg);\n-                self.depth -= 1;\n-                return;\n-            }\n-\n-            hir::TyTraitObject(ref bounds, _) => {\n-                for bound in bounds {\n-                    self.depth += 1;\n-                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                    self.depth -= 1;\n-                }\n-            }\n-\n-            hir::TyRptr(ref lifetime, _) => {\n-                // the lifetime of the TyRptr\n-                let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-                match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n-                    // Find the index of the anonymous region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n-                     ty::BrAnon(br_index)) => {\n-                        debug!(\"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n-                               debruijn_index.depth,\n-                               anon_index,\n-                               br_index);\n-                        if debruijn_index.depth == self.depth && anon_index == br_index {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    // Find the index of the named region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                        debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\", id, def_id);\n-                        if id == def_id {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    // Find the index of the named region that was part of the\n-                    // error. We will then search the function parameters for a bound\n-                    // region at the right depth with the same index\n-                    (\n-                     Some(rl::Region::LateBound(debruijn_index, id, _)),\n-                     ty::BrNamed(def_id, _)\n-                    ) => {\n-                        debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n-                               debruijn_index.depth);\n-                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n-                        debug!(\"def_id={:?}\", def_id);\n-                        if debruijn_index.depth == self.depth && id == def_id {\n-                            self.found_type = Some(arg);\n-                            return; // we can stop visiting now\n-                        }\n-                    }\n-\n-                    (Some(rl::Region::Static), _) |\n-                    (Some(rl::Region::Free(_, _)), _) |\n-                    (Some(rl::Region::EarlyBound(_, _, _)), _) |\n-                    (Some(rl::Region::LateBound(_, _, _)), _) |\n-                    (Some(rl::Region::LateBoundAnon(_, _)), _) |\n-                    (None, _) => {\n-                        debug!(\"no arg found\");\n-                    }\n-                }\n-            }\n-            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n-            hir::TyPath(_) => {\n-                let subvisitor = &mut TyPathVisitor {\n-                                          infcx: self.infcx,\n-                                          found_it: false,\n-                                          bound_region: self.bound_region,\n-                                          hir_map: self.hir_map,\n-                                          depth: self.depth,\n-                                      };\n-                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n-                // this will visit only outermost type\n-                if subvisitor.found_it {\n-                    self.found_type = Some(arg);\n-                }\n-            }\n-            _ => {}\n-        }\n-        // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n-        // go on to visit `&Foo`\n-        intravisit::walk_ty(self, arg);\n-    }\n-}\n-\n-// The visitor captures the corresponding `hir::Ty` of the anonymous region\n-// in the case of structs ie. `hir::TyPath`.\n-// This visitor would be invoked for each lifetime corresponding to a struct,\n-// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n-// where that lifetime appears. This allows us to highlight the\n-// specific part of the type in the error message.\n-struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    found_it: bool,\n-    bound_region: ty::BoundRegion,\n-    depth: u32,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-\n-    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-\n-        let hir_id = self.infcx.tcx.hir.node_to_hir_id(lifetime.id);\n-        match (self.infcx.tcx.named_region(hir_id), self.bound_region) {\n-            // the lifetime of the TyPath!\n-            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n-                if debruijn_index.depth == self.depth && anon_index == br_index {\n-                    self.found_it = true;\n-                    return;\n-                }\n-            }\n-\n-            (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n-                debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\", id, def_id);\n-                if id == def_id {\n-                    self.found_it = true;\n-                    return; // we can stop visiting now\n-                }\n-            }\n-\n-            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n-                debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n-                       debruijn_index.depth);\n-                debug!(\"id={:?}\", id);\n-                debug!(\"def_id={:?}\", def_id);\n-                if debruijn_index.depth == self.depth && id == def_id {\n-                    self.found_it = true;\n-                    return; // we can stop visiting now\n-                }\n-            }\n-\n-            (Some(rl::Region::Static), _) |\n-            (Some(rl::Region::EarlyBound(_, _, _)), _) |\n-            (Some(rl::Region::LateBound(_, _, _)), _) |\n-            (Some(rl::Region::LateBoundAnon(_, _)), _) |\n-            (Some(rl::Region::Free(_, _)), _) |\n-            (None, _) => {\n-                debug!(\"no arg found\");\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n-        // ignore nested types\n-        //\n-        // If you have a type like `Foo<'a, &Ty>` we\n-        // are only interested in the immediate lifetimes ('a).\n-        //\n-        // Making `visit_ty` empty will ignore the `&Ty` embedded\n-        // inside, it will get reached by the outer visitor.\n-        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n-    }\n-}"}, {"sha": "cae7bf5c25c81b797bf6788371fae79435f7dd1b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -78,10 +78,7 @@ mod note;\n \n mod need_type_info;\n \n-mod named_anon_conflict;\n-#[macro_use]\n-mod util;\n-mod different_lifetimes;\n+pub mod nice_region_error;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -261,10 +258,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_region_errors(&self,\n                                 region_scope_tree: &region::ScopeTree,\n-                                errors: &Vec<RegionResolutionError<'tcx>>) {\n+                                errors: &Vec<RegionResolutionError<'tcx>>,\n+                                will_later_be_reported_by_nll: bool) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n-        if self.tcx.sess.opts.debugging_opts.nll {\n+        if will_later_be_reported_by_nll && self.tcx.sess.nll() {\n+            // With `#![feature(nll)]`, we want to present a nice user\n+            // experience, so don't even mention the errors from the\n+            // AST checker.\n+            if self.tcx.sess.features.borrow().nll {\n+                return;\n+            }\n+\n+            // But with -Znll, it's nice to have some note for later.\n             for error in errors {\n                 match *error {\n                     RegionResolutionError::ConcreteFailure(ref origin, ..) |\n@@ -294,9 +300,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for error in errors {\n             debug!(\"report_region_errors: error = {:?}\", error);\n \n-            if !self.try_report_named_anon_conflict(&error) &&\n-                !self.try_report_anon_anon_conflict(&error)\n-            {\n+            if !self.try_report_nice_region_error(&error) {\n                 match error.clone() {\n                     // These errors could indicate all manner of different\n                     // problems with many different solutions. Rather\n@@ -309,8 +313,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n                     }\n \n-                    RegionResolutionError::GenericBoundFailure(kind, param_ty, sub) => {\n-                        self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n+                    RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n+                        self.report_generic_bound_failure(\n+                            region_scope_tree,\n+                            origin.span(),\n+                            Some(origin),\n+                            param_ty,\n+                            sub,\n+                        );\n                     }\n \n                     RegionResolutionError::SubSupConflict(var_origin,\n@@ -906,11 +916,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n               DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n     }\n \n-    fn report_generic_bound_failure(&self,\n-                                    region_scope_tree: &region::ScopeTree,\n-                                    origin: SubregionOrigin<'tcx>,\n-                                    bound_kind: GenericKind<'tcx>,\n-                                    sub: Region<'tcx>)\n+    pub fn report_generic_bound_failure(&self,\n+                                        region_scope_tree: &region::ScopeTree,\n+                                        span: Span,\n+                                        origin: Option<SubregionOrigin<'tcx>>,\n+                                        bound_kind: GenericKind<'tcx>,\n+                                        sub: Region<'tcx>)\n     {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n@@ -958,9 +969,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n-        if let SubregionOrigin::CompareImplMethodObligation {\n+        if let Some(SubregionOrigin::CompareImplMethodObligation {\n             span, item_name, impl_item_def_id, trait_item_def_id,\n-        } = origin {\n+        }) = origin {\n             self.report_extra_impl_obligation(span,\n                                               item_name,\n                                               impl_item_def_id,\n@@ -995,7 +1006,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,\n-                                               origin.span(),\n+                                               span,\n                                                E0309,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n@@ -1006,7 +1017,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,\n-                                               origin.span(),\n+                                               span,\n                                                E0310,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n@@ -1017,7 +1028,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 // If not, be less specific.\n                 let mut err = struct_span_err!(self.tcx.sess,\n-                                               origin.span(),\n+                                               span,\n                                                E0311,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n@@ -1033,7 +1044,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.note_region_origin(&mut err, &origin);\n+        if let Some(origin) = origin {\n+            self.note_region_origin(&mut err, &origin);\n+        }\n         err.emit();\n     }\n "}, {"sha": "6af7415ba5371147a88fd79b01ad918aaa2766d9", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=7eb64b86ce44cc1828dd176a8b981e37ea08fc38", "patch": "@@ -1,101 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Error Reporting for Anonymous Region Lifetime Errors\n-//! where one region is named and the other is anonymous.\n-use infer::InferCtxt;\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use ty;\n-\n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n-    /// an anonymous region, emit an descriptive diagnostic error.\n-    pub fn try_report_named_anon_conflict(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        let (span, sub, sup) = match *error {\n-            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n-            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n-            _ => return false, // inapplicable\n-        };\n-\n-        debug!(\"try_report_named_anon_conflict(sub={:?}, sup={:?})\", sub, sup);\n-\n-        // Determine whether the sub and sup consist of one named region ('a)\n-        // and one anonymous (elided) region. If so, find the parameter arg\n-        // where the anonymous region appears (there must always be one; we\n-        // only introduced anonymous regions in parameters) as well as a\n-        // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) =\n-            if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n-               self.find_arg_with_region(sup, sub).is_some() {\n-                (sub,\n-                 sup,\n-                 self.find_arg_with_region(sup, sub).unwrap(),\n-                 self.is_suitable_region(sup).unwrap())\n-            } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n-                      self.find_arg_with_region(sub, sup).is_some() {\n-                (sup,\n-                 sub,\n-                 self.find_arg_with_region(sub, sup).unwrap(),\n-                 self.is_suitable_region(sub).unwrap())\n-            } else {\n-                return false; // inapplicable\n-            };\n-\n-        debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n-        debug!(\"try_report_named_anon_conflict: anon_arg_info = {:?}\", anon_arg_info);\n-        debug!(\"try_report_named_anon_conflict: region_info = {:?}\", region_info);\n-\n-        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n-                                                                       anon_arg_info.arg_ty,\n-                                                                       anon_arg_info.bound_region,\n-                                                                       anon_arg_info.is_first,\n-                                                                       region_info.def_id,\n-                                                                       region_info.is_impl_item);\n-        match br {\n-            ty::BrAnon(_) => {}\n-            _ => {\n-                /* not an anonymous region */\n-                debug!(\"try_report_named_anon_conflict: not an anonymous region\");\n-                return false;\n-            }\n-        }\n-\n-        if is_impl_item {\n-            debug!(\"try_report_named_anon_conflict: impl item, bail out\");\n-            return false;\n-        }\n-\n-        if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some() ||\n-               self.is_self_anon(is_first, scope_def_id) {\n-                return false;\n-            }\n-        }\n-\n-        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n-        } else {\n-            (\"parameter type\".to_owned(), \"type\".to_owned())\n-        };\n-\n-        struct_span_err!(self.tcx.sess,\n-                         span,\n-                         E0621,\n-                         \"explicit lifetime required in {}\",\n-                         error_var)\n-                .span_label(arg.pat.span,\n-                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                .span_label(span, format!(\"lifetime `{}` required\", named))\n-                .emit();\n-        return true;\n-    }\n-}"}, {"sha": "d4ea899dc747f1cbf08d27f5054296fa6dee6bb5", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error Reporting for Anonymous Region Lifetime Errors\n+//! where both the regions are anonymous.\n+\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+use infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use util::common::ErrorReported;\n+\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+    /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n+    ///\n+    /// Consider a case where we have\n+    ///\n+    /// ```no_run\n+    /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n+    ///     x.push(y);\n+    /// }\n+    /// ```\n+    ///\n+    /// The example gives\n+    ///\n+    /// ```text\n+    /// fn foo(x: &mut Vec<&u8>, y: &u8) {\n+    ///                    ---      --- these references are declared with different lifetimes...\n+    ///     x.push(y);\n+    ///     ^ ...but data from `y` flows into `x` here\n+    /// ```\n+    ///\n+    /// It has been extended for the case of structs too.\n+    ///\n+    /// Consider the example\n+    ///\n+    /// ```no_run\n+    /// struct Ref<'a> { x: &'a u32 }\n+    /// ```\n+    ///\n+    /// ```text\n+    /// fn foo(mut x: Vec<Ref>, y: Ref) {\n+    ///                   ---      --- these structs are declared with different lifetimes...\n+    ///     x.push(y);\n+    ///     ^ ...but data from `y` flows into `x` here\n+    /// }\n+    /// ````\n+    ///\n+    /// It will later be extended to trait objects.\n+    pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n+        let NiceRegionError { span, sub, sup, .. } = *self;\n+\n+        // Determine whether the sub and sup consist of both anonymous (elided) regions.\n+        let anon_reg_sup = self.is_suitable_region(sup)?;\n+\n+        let anon_reg_sub = self.is_suitable_region(sub)?;\n+        let scope_def_id_sup = anon_reg_sup.def_id;\n+        let bregion_sup = anon_reg_sup.boundregion;\n+        let scope_def_id_sub = anon_reg_sub.def_id;\n+        let bregion_sub = anon_reg_sub.boundregion;\n+\n+        let ty_sup = self.find_anon_type(sup, &bregion_sup)?;\n+\n+        let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n+\n+        debug!(\n+            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            ty_sub,\n+            sup,\n+            bregion_sup\n+        );\n+        debug!(\n+            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            ty_sup,\n+            sub,\n+            bregion_sub\n+        );\n+\n+        let (ty_sup, ty_fndecl_sup) = ty_sup;\n+        let (ty_sub, ty_fndecl_sub) = ty_sub;\n+\n+        let AnonymousArgInfo {\n+            arg: anon_arg_sup, ..\n+        } = self.find_arg_with_region(sup, sup)?;\n+        let AnonymousArgInfo {\n+            arg: anon_arg_sub, ..\n+        } = self.find_arg_with_region(sub, sub)?;\n+\n+        let sup_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n+        let sub_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n+\n+        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+            format!(\" from `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+            format!(\" into `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+\n+        let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n+            (None, None) => {\n+                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n+                    (\n+                        format!(\"this type is declared with multiple lifetimes...\"),\n+                        format!(\n+                            \"...but data{} flows{} here\",\n+                            format!(\" with one lifetime\"),\n+                            format!(\" into the other\")\n+                        ),\n+                    )\n+                } else {\n+                    (\n+                        format!(\"these two types are declared with different lifetimes...\"),\n+                        format!(\n+                            \"...but data{} flows{} here\",\n+                            span_label_var1,\n+                            span_label_var2\n+                        ),\n+                    )\n+                };\n+                (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n+            }\n+\n+            (Some(ret_span), _) => (\n+                ty_sub.span,\n+                ret_span,\n+                format!(\n+                    \"this parameter and the return type are declared \\\n+                     with different lifetimes...\",\n+                ),\n+                format!(\"...but data{} is returned here\", span_label_var1),\n+            ),\n+            (_, Some(ret_span)) => (\n+                ty_sup.span,\n+                ret_span,\n+                format!(\n+                    \"this parameter and the return type are declared \\\n+                     with different lifetimes...\",\n+                ),\n+                format!(\"...but data{} is returned here\", span_label_var1),\n+            ),\n+        };\n+\n+\n+        struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n+            .span_label(span_1, main_label)\n+            .span_label(span_2, format!(\"\"))\n+            .span_label(span, span_label)\n+            .emit();\n+        return Some(ErrorReported);\n+    }\n+}"}, {"sha": "dc53c1db06f14be0ccfc6bf229e32058a56332c8", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,291 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use ty::{self, Region, TyCtxt};\n+use hir::map as hir_map;\n+use middle::resolve_lifetime as rl;\n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+    /// This function calls the `visit_ty` method for the parameters\n+    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n+    /// contains the anonymous type.\n+    ///\n+    /// # Arguments\n+    /// region - the anonymous region corresponding to the anon_anon conflict\n+    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n+    ///\n+    /// # Example\n+    /// ```\n+    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n+    ///    { x.push(y); }\n+    /// ```\n+    /// The function returns the nested type corresponding to the anonymous region\n+    /// for e.g. `&u8` and Vec<`&u8`.\n+    pub(super) fn find_anon_type(\n+        &self,\n+        region: Region<'tcx>,\n+        br: &ty::BoundRegion,\n+    ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n+        if let Some(anon_reg) = self.is_suitable_region(region) {\n+            let def_id = anon_reg.def_id;\n+            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let fndecl = match self.tcx.hir.get(node_id) {\n+                    hir_map::NodeItem(&hir::Item {\n+                        node: hir::ItemFn(ref fndecl, ..),\n+                        ..\n+                    }) => &fndecl,\n+                    hir_map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(ref m, ..),\n+                        ..\n+                    })\n+                    | hir_map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(ref m, ..),\n+                        ..\n+                    }) => &m.decl,\n+                    _ => return None,\n+                };\n+\n+                return fndecl\n+                    .inputs\n+                    .iter()\n+                    .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n+                    .next()\n+                    .map(|ty| (ty, &**fndecl));\n+            }\n+        }\n+        None\n+    }\n+\n+    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n+    // to the anonymous region.\n+    fn find_component_for_bound_region(\n+        &self,\n+        arg: &'gcx hir::Ty,\n+        br: &ty::BoundRegion,\n+    ) -> Option<(&'gcx hir::Ty)> {\n+        let mut nested_visitor = FindNestedTypeVisitor {\n+            tcx: self.tcx,\n+            bound_region: *br,\n+            found_type: None,\n+            depth: 1,\n+        };\n+        nested_visitor.visit_ty(arg);\n+        nested_visitor.found_type\n+    }\n+}\n+\n+// The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the\n+// anonymous region. The example above would lead to a conflict between\n+// the two anonymous lifetimes for &u8 in x and y respectively. This visitor\n+// would be invoked twice, once for each lifetime, and would\n+// walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    // The bound_region corresponding to the Refree(freeregion)\n+    // associated with the anonymous region we are looking for.\n+    bound_region: ty::BoundRegion,\n+    // The type where the anonymous lifetime appears\n+    // for e.g. Vec<`&u8`> and <`&u8`>\n+    found_type: Option<&'gcx hir::Ty>,\n+    depth: u32,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        match arg.node {\n+            hir::TyBareFn(_) => {\n+                self.depth += 1;\n+                intravisit::walk_ty(self, arg);\n+                self.depth -= 1;\n+                return;\n+            }\n+\n+            hir::TyTraitObject(ref bounds, _) => for bound in bounds {\n+                self.depth += 1;\n+                self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                self.depth -= 1;\n+            },\n+\n+            hir::TyRptr(ref lifetime, _) => {\n+                // the lifetime of the TyRptr\n+                let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+                match (self.tcx.named_region(hir_id), self.bound_region) {\n+                    // Find the index of the anonymous region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (\n+                        Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                        ty::BrAnon(br_index),\n+                    ) => {\n+                        debug!(\n+                            \"LateBoundAnon depth = {:?} anon_index = {:?} br_index={:?}\",\n+                            debruijn_index.depth,\n+                            anon_index,\n+                            br_index\n+                        );\n+                        if debruijn_index.depth == self.depth && anon_index == br_index {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n+                        debug!(\n+                            \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                             def_id={:?}\",\n+                            id,\n+                            def_id\n+                        );\n+                        if id == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    // Find the index of the named region that was part of the\n+                    // error. We will then search the function parameters for a bound\n+                    // region at the right depth with the same index\n+                    (\n+                        Some(rl::Region::LateBound(debruijn_index, id, _)),\n+                        ty::BrNamed(def_id, _),\n+                    ) => {\n+                        debug!(\n+                            \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                            debruijn_index.depth\n+                        );\n+                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n+                        debug!(\"def_id={:?}\", def_id);\n+                        if debruijn_index.depth == self.depth && id == def_id {\n+                            self.found_type = Some(arg);\n+                            return; // we can stop visiting now\n+                        }\n+                    }\n+\n+                    (Some(rl::Region::Static), _)\n+                    | (Some(rl::Region::Free(_, _)), _)\n+                    | (Some(rl::Region::EarlyBound(_, _, _)), _)\n+                    | (Some(rl::Region::LateBound(_, _, _)), _)\n+                    | (Some(rl::Region::LateBoundAnon(_, _)), _)\n+                    | (None, _) => {\n+                        debug!(\"no arg found\");\n+                    }\n+                }\n+            }\n+            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n+            hir::TyPath(_) => {\n+                let subvisitor = &mut TyPathVisitor {\n+                    tcx: self.tcx,\n+                    found_it: false,\n+                    bound_region: self.bound_region,\n+                    depth: self.depth,\n+                };\n+                intravisit::walk_ty(subvisitor, arg); // call walk_ty; as visit_ty is empty,\n+                                                      // this will visit only outermost type\n+                if subvisitor.found_it {\n+                    self.found_type = Some(arg);\n+                }\n+            }\n+            _ => {}\n+        }\n+        // walk the embedded contents: e.g., if we are visiting `Vec<&Foo>`,\n+        // go on to visit `&Foo`\n+        intravisit::walk_ty(self, arg);\n+    }\n+}\n+\n+// The visitor captures the corresponding `hir::Ty` of the anonymous region\n+// in the case of structs ie. `hir::TyPath`.\n+// This visitor would be invoked for each lifetime corresponding to a struct,\n+// and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n+// where that lifetime appears. This allows us to highlight the\n+// specific part of the type in the error message.\n+struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    found_it: bool,\n+    bound_region: ty::BoundRegion,\n+    depth: u32,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+    }\n+\n+    fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n+        let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+        match (self.tcx.named_region(hir_id), self.bound_region) {\n+            // the lifetime of the TyPath!\n+            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n+                if debruijn_index.depth == self.depth && anon_index == br_index {\n+                    self.found_it = true;\n+                    return;\n+                }\n+            }\n+\n+            (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n+                debug!(\n+                    \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                     def_id={:?}\",\n+                    id,\n+                    def_id\n+                );\n+                if id == def_id {\n+                    self.found_it = true;\n+                    return; // we can stop visiting now\n+                }\n+            }\n+\n+            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n+                debug!(\n+                    \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n+                    debruijn_index.depth\n+                );\n+                debug!(\"id={:?}\", id);\n+                debug!(\"def_id={:?}\", def_id);\n+                if debruijn_index.depth == self.depth && id == def_id {\n+                    self.found_it = true;\n+                    return; // we can stop visiting now\n+                }\n+            }\n+\n+            (Some(rl::Region::Static), _)\n+            | (Some(rl::Region::EarlyBound(_, _, _)), _)\n+            | (Some(rl::Region::LateBound(_, _, _)), _)\n+            | (Some(rl::Region::LateBoundAnon(_, _)), _)\n+            | (Some(rl::Region::Free(_, _)), _)\n+            | (None, _) => {\n+                debug!(\"no arg found\");\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n+        // ignore nested types\n+        //\n+        // If you have a type like `Foo<'a, &Ty>` we\n+        // are only interested in the immediate lifetimes ('a).\n+        //\n+        // Making `visit_ty` empty will ignore the `&Ty` embedded\n+        // inside, it will get reached by the outer visitor.\n+        debug!(\"`Ty` corresponding to a struct is {:?}\", arg);\n+    }\n+}"}, {"sha": "edc38b6bb14eea3ff2914efb8c4603245d588733", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::lexical_region_resolve::RegionResolutionError::*;\n+use syntax::codemap::Span;\n+use ty::{self, TyCtxt};\n+use util::common::ErrorReported;\n+\n+mod different_lifetimes;\n+mod find_anon_type;\n+mod named_anon_conflict;\n+mod util;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n+        let (span, sub, sup) = match *error {\n+            ConcreteFailure(ref origin, sub, sup) => (origin.span(), sub, sup),\n+            SubSupConflict(_, ref origin, sub, _, sup) => (origin.span(), sub, sup),\n+            _ => return false, // inapplicable\n+        };\n+\n+        if let Some(tables) = self.in_progress_tables {\n+            let tables = tables.borrow();\n+            NiceRegionError::new(self.tcx, span, sub, sup, Some(&tables)).try_report().is_some()\n+        } else {\n+            NiceRegionError::new(self.tcx, span, sub, sup, None).try_report().is_some()\n+        }\n+    }\n+}\n+\n+pub struct NiceRegionError<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    span: Span,\n+    sub: ty::Region<'tcx>,\n+    sup: ty::Region<'tcx>,\n+    tables: Option<&'cx ty::TypeckTables<'tcx>>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        span: Span,\n+        sub: ty::Region<'tcx>,\n+        sup: ty::Region<'tcx>,\n+        tables: Option<&'cx ty::TypeckTables<'tcx>>,\n+    ) -> Self {\n+        Self { tcx, span, sub, sup, tables }\n+    }\n+\n+    pub fn try_report(&self) -> Option<ErrorReported> {\n+        self.try_report_named_anon_conflict()\n+            .or_else(|| self.try_report_anon_anon_conflict())\n+    }\n+}"}, {"sha": "9d0ddfd4be04b27733ce2c949a19d4a40c3f1605", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error Reporting for Anonymous Region Lifetime Errors\n+//! where one region is named and the other is anonymous.\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+use ty;\n+use util::common::ErrorReported;\n+\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// an anonymous region, emit an descriptive diagnostic error.\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<ErrorReported> {\n+        let NiceRegionError { span, sub, sup, .. } = *self;\n+\n+        debug!(\n+            \"try_report_named_anon_conflict(sub={:?}, sup={:?})\",\n+            sub,\n+            sup\n+        );\n+\n+        // Determine whether the sub and sup consist of one named region ('a)\n+        // and one anonymous (elided) region. If so, find the parameter arg\n+        // where the anonymous region appears (there must always be one; we\n+        // only introduced anonymous regions in parameters) as well as a\n+        // version new_ty of its type where the anonymous region is replaced\n+        // with the named one.//scope_def_id\n+        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+            && self.is_suitable_region(sup).is_some()\n+            && self.find_arg_with_region(sup, sub).is_some()\n+        {\n+            (\n+                sub,\n+                sup,\n+                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.is_suitable_region(sup).unwrap(),\n+            )\n+        } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some()\n+            && self.find_arg_with_region(sub, sup).is_some()\n+        {\n+            (\n+                sup,\n+                sub,\n+                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.is_suitable_region(sub).unwrap(),\n+            )\n+        } else {\n+            return None; // inapplicable\n+        };\n+\n+        debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n+        debug!(\n+            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n+            anon_arg_info\n+        );\n+        debug!(\n+            \"try_report_named_anon_conflict: region_info = {:?}\",\n+            region_info\n+        );\n+\n+        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_arg_info.arg,\n+            anon_arg_info.arg_ty,\n+            anon_arg_info.bound_region,\n+            anon_arg_info.is_first,\n+            region_info.def_id,\n+            region_info.is_impl_item,\n+        );\n+        match br {\n+            ty::BrAnon(_) => {}\n+            _ => {\n+                /* not an anonymous region */\n+                debug!(\"try_report_named_anon_conflict: not an anonymous region\");\n+                return None;\n+            }\n+        }\n+\n+        if is_impl_item {\n+            debug!(\"try_report_named_anon_conflict: impl item, bail out\");\n+            return None;\n+        }\n+\n+        if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n+            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some()\n+                || self.is_self_anon(is_first, scope_def_id)\n+            {\n+                return None;\n+            }\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (\n+                format!(\"the type of `{}`\", simple_name),\n+                format!(\"the type of `{}`\", simple_name),\n+            )\n+        } else {\n+            (\"parameter type\".to_owned(), \"type\".to_owned())\n+        };\n+\n+        struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0621,\n+            \"explicit lifetime required in {}\",\n+            error_var\n+        ).span_label(\n+            arg.pat.span,\n+            format!(\"consider changing {} to `{}`\", span_label_var, new_ty),\n+        )\n+            .span_label(span, format!(\"lifetime `{}` required\", named))\n+            .emit();\n+        return Some(ErrorReported);\n+    }\n+}"}, {"sha": "f8b6f7d0afa93c5bcf68aa272d26ce1f58192b8b", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "renamed", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -11,28 +11,16 @@\n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n use hir;\n-use infer::InferCtxt;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n use syntax_pos::Span;\n \n-macro_rules! or_false {\n-     ($v:expr) => {\n-         match $v {\n-             Some(v) => v,\n-             None => {\n-                 debug!(\"or_false failed: {}\", stringify!($v));\n-                 return false;\n-             }\n-         }\n-     }\n-}\n-\n // The struct contains the information about the anonymous region\n // we are searching for.\n #[derive(Debug)]\n-pub struct AnonymousArgInfo<'tcx> {\n+pub(super) struct AnonymousArgInfo<'tcx> {\n     // the argument corresponding to the anonymous region\n     pub arg: &'tcx hir::Arg,\n     // the type corresponding to the anonymopus region argument\n@@ -47,7 +35,7 @@ pub struct AnonymousArgInfo<'tcx> {\n // This struct contains information regarding the\n // Refree((FreeRegion) corresponding to lifetime conflict\n #[derive(Debug)]\n-pub struct FreeRegionInfo {\n+pub(super) struct FreeRegionInfo {\n     // def id corresponding to FreeRegion\n     pub def_id: DefId,\n     // the bound region corresponding to FreeRegion\n@@ -56,7 +44,7 @@ pub struct FreeRegionInfo {\n     pub is_impl_item: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     // This method walks the Type of the function body arguments using\n     // `fold_regions()` function and returns the\n     // &hir::Arg of the function argument corresponding to the anonymous\n@@ -68,47 +56,48 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n     // the hir::Arg is the first argument in the function declaration.\n-    pub fn find_arg_with_region(&self,\n-                                anon_region: Region<'tcx>,\n-                                replace_region: Region<'tcx>)\n-                                -> Option<AnonymousArgInfo> {\n-\n+    pub(super) fn find_arg_with_region(\n+        &self,\n+        anon_region: Region<'tcx>,\n+        replace_region: Region<'tcx>,\n+    ) -> Option<AnonymousArgInfo> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n-                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n-            }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n         let hir = &self.tcx.hir;\n         if let Some(node_id) = hir.as_local_node_id(id) {\n             if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n                 let body = hir.body(body_id);\n-                if let Some(tables) = self.in_progress_tables {\n+                if let Some(tables) = self.tables {\n                     body.arguments\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n                             // May return None; sometimes the tables are not yet populated.\n-                            let ty = tables.borrow().node_id_to_type_opt(arg.hir_id)?;\n+                            let ty = tables.node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx\n-                                .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {\n+                            let new_arg_ty = self.tcx.fold_regions(&ty, &mut false, |r, _| {\n+                                if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n                                 } else {\n                                     r\n-                                });\n+                                }\n+                            });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n                                 Some(AnonymousArgInfo {\n-                                         arg: arg,\n-                                         arg_ty: new_arg_ty,\n-                                         bound_region: bound_region,\n-                                         is_first: is_first,\n-                                     })\n+                                    arg: arg,\n+                                    arg_ty: new_arg_ty,\n+                                    bound_region: bound_region,\n+                                    is_first: is_first,\n+                                })\n                             } else {\n                                 None\n                             }\n@@ -126,14 +115,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // This method returns the DefId and the BoundRegion corresponding to the given region.\n-    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n-\n+    pub(super) fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.tcx.parent_def_id(ebr.def_id).unwrap(),\n-                 ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n-            }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.tcx.parent_def_id(ebr.def_id).unwrap(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n@@ -142,31 +130,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-\n-            Some(hir_map::NodeItem(..)) |\n-            Some(hir_map::NodeTraitItem(..)) => false,\n+            Some(hir_map::NodeItem(..)) | Some(hir_map::NodeTraitItem(..)) => false,\n             Some(hir_map::NodeImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,\n         };\n \n         return Some(FreeRegionInfo {\n-                        def_id: suitable_region_binding_scope,\n-                        boundregion: bound_region,\n-                        is_impl_item: is_impl_item,\n-                    });\n-\n+            def_id: suitable_region_binding_scope,\n+            boundregion: bound_region,\n+            is_impl_item: is_impl_item,\n+        });\n     }\n \n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n-    pub fn is_return_type_anon(&self,\n-                               scope_def_id: DefId,\n-                               br: ty::BoundRegion,\n-                               decl: &hir::FnDecl)\n-                               -> Option<Span> {\n+    pub(super) fn is_return_type_anon(\n+        &self,\n+        scope_def_id: DefId,\n+        br: ty::BoundRegion,\n+        decl: &hir::FnDecl,\n+    ) -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::TyFnDef(_, _) => {\n@@ -185,15 +171,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n-    pub fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n-        is_first &&\n-        self.tcx\n-            .opt_associated_item(scope_def_id)\n-            .map(|i| i.method_has_self_argument) == Some(true)\n+    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+        is_first\n+            && self.tcx\n+                .opt_associated_item(scope_def_id)\n+                .map(|i| i.method_has_self_argument) == Some(true)\n     }\n \n     // Here we check if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n+    pub(super) fn is_bound_region_in_impl_item(\n+        &self,\n+        suitable_region_binding_scope: DefId,\n+    ) -> bool {\n         let container_id = self.tcx\n             .associated_item(suitable_region_binding_scope)\n             .container\n@@ -211,14 +200,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // This method returns whether the given Region is Named\n-    pub fn is_named_region(&self, region: Region<'tcx>) -> bool {\n+    pub(super) fn is_named_region(&self, region: Region<'tcx>) -> bool {\n         match *region {\n-            ty::ReFree(ref free_region) => {\n-                match free_region.bound_region {\n-                    ty::BrNamed(..) => true,\n-                    _ => false,\n-                }\n-            }\n+            ty::ReFree(ref free_region) => match free_region.bound_region {\n+                ty::BrNamed(..) => true,\n+                _ => false,\n+            },\n             ty::ReEarlyBound(_) => true,\n             _ => false,\n         }", "previous_filename": "src/librustc/infer/error_reporting/util.rs"}, {"sha": "07c5b319970f8e673500b0bb4ad01f1982aa7b93", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -48,6 +48,7 @@ use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n+pub mod anon_types;\n pub mod at;\n mod combine;\n mod equate;\n@@ -1158,10 +1159,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_type_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(&self,\n-                                             region_context: DefId,\n-                                             region_map: &region::ScopeTree,\n-                                             outlives_env: &OutlivesEnvironment<'tcx>) {\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        region_context: DefId,\n+        region_map: &region::ScopeTree,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n+        self.resolve_regions_and_report_errors_inner(\n+            region_context,\n+            region_map,\n+            outlives_env,\n+            false,\n+        )\n+    }\n+\n+    /// Like `resolve_regions_and_report_errors`, but skips error\n+    /// reporting if NLL is enabled.  This is used for fn bodies where\n+    /// the same error may later be reported by the NLL-based\n+    /// inference.\n+    pub fn resolve_regions_and_report_errors_unless_nll(\n+        &self,\n+        region_context: DefId,\n+        region_map: &region::ScopeTree,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) {\n+        self.resolve_regions_and_report_errors_inner(\n+            region_context,\n+            region_map,\n+            outlives_env,\n+            true,\n+        )\n+    }\n+\n+    fn resolve_regions_and_report_errors_inner(\n+        &self,\n+        region_context: DefId,\n+        region_map: &region::ScopeTree,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+        will_later_be_reported_by_nll: bool,\n+    ) {\n         assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n                 \"region_obligations not empty: {:#?}\",\n                 self.region_obligations.borrow());\n@@ -1186,7 +1222,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors); // see error_reporting module\n+            self.report_region_errors(region_map, &errors, will_later_be_reported_by_nll);\n         }\n     }\n "}, {"sha": "6163ec1642001f603e4a7e53690596652a53a77f", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -38,20 +38,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    /// Tests whether `r_a <= r_b`. Both must be free regions or\n-    /// `'static`.\n-    pub fn sub_free_regions<'a, 'gcx>(&self,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> bool {\n-        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n-        if let ty::ReStatic = r_b {\n-            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n-        } else {\n-            r_a == r_b || self.relation.contains(&r_a, &r_b)\n-        }\n-    }\n-\n     /// Compute the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -75,6 +61,29 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     }\n }\n \n+/// The NLL region handling code represents free region relations in a\n+/// slightly different way; this trait allows functions to be abstract\n+/// over which version is in use.\n+pub trait FreeRegionRelations<'tcx> {\n+    /// Tests whether `r_a <= r_b`. Both must be free regions or\n+    /// `'static`.\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool;\n+}\n+\n+impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n+    fn sub_free_regions(&self,\n+                        r_a: Region<'tcx>,\n+                        r_b: Region<'tcx>)\n+                        -> bool {\n+        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n+        if let ty::ReStatic = r_b {\n+            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n+        } else {\n+            r_a == r_b || self.relation.contains(&r_a, &r_b)\n+        }\n+    }\n+}\n+\n fn is_free(r: Region) -> bool {\n     match *r {\n         ty::ReEarlyBound(_) | ty::ReFree(_) => true,"}, {"sha": "becaf78f7eca58822cc5aeba4ae0e65e67be2c9a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -46,6 +46,7 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n+#![feature(dyn_trait)]\n #![feature(from_ref)]\n #![feature(i128)]\n #![feature(i128_type)]"}, {"sha": "1341e3515d571d794762312a4a68d6fb74def6f8", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,7 +15,7 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n-use infer::outlives::free_region_map::FreeRegionMap;\n+use infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n use hir::def_id::DefId;\n use middle::region;\n use ty::{self, TyCtxt, Region};"}, {"sha": "f410865a6cd7f37e1b21ab72db5925a92e8bb9c5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n+use mir::visit::MirVisitable;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -868,6 +869,14 @@ impl<'tcx> BasicBlockData<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn visitable(&self, index: usize) -> &dyn MirVisitable<'tcx> {\n+        if index < self.statements.len() {\n+            &self.statements[index]\n+        } else {\n+            &self.terminator\n+        }\n+    }\n }\n \n impl<'tcx> Debug for TerminatorKind<'tcx> {"}, {"sha": "0e6c14af1ecfabfaf13eb7e0969214a2a642fbe5", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -811,6 +811,31 @@ macro_rules! make_mir_visitor {\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n+pub trait MirVisitable<'tcx> {\n+    fn apply(&self, location: Location, visitor: &mut dyn Visitor<'tcx>);\n+}\n+\n+impl<'tcx> MirVisitable<'tcx> for Statement<'tcx> {\n+    fn apply(&self, location: Location, visitor: &mut dyn Visitor<'tcx>)\n+    {\n+        visitor.visit_statement(location.block, self, location)\n+    }\n+}\n+\n+impl<'tcx> MirVisitable<'tcx> for Terminator<'tcx> {\n+    fn apply(&self, location: Location, visitor: &mut dyn Visitor<'tcx>)\n+    {\n+        visitor.visit_terminator(location.block, self, location)\n+    }\n+}\n+\n+impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n+    fn apply(&self, location: Location, visitor: &mut dyn Visitor<'tcx>)\n+    {\n+        visitor.visit_terminator(location.block, self.as_ref().unwrap(), location)\n+    }\n+}\n+\n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "6e0372f009ecefc17af6d0e4ab37cb1e42565469", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -1190,6 +1190,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n+    nll_dump_cause: bool = (false, parse_bool, [UNTRACKED],\n+                 \"dump cause information when reporting errors from NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "60a218500ca78b15761b7a448dc22b602c4e37b0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -18,7 +18,7 @@ use lint;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::DebugInfoLevel;\n+use session::config::{BorrowckMode, DebugInfoLevel};\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n@@ -437,11 +437,62 @@ impl Session {\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n+\n+    /// If true, we should use NLL-style region checking instead of\n+    /// lexical style.\n+    pub fn nll(&self) -> bool {\n+        self.features.borrow().nll || self.opts.debugging_opts.nll\n+    }\n+\n+    /// If true, we should use the MIR-based borrowck (we may *also* use\n+    /// the AST-based borrowck).\n+    pub fn use_mir(&self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n+    /// If true, we should gather causal information during NLL\n+    /// checking. This will eventually be the normal thing, but right\n+    /// now it is too unoptimized.\n+    pub fn nll_dump_cause(&self) -> bool {\n+        self.opts.debugging_opts.nll_dump_cause\n+    }\n+\n+    /// If true, we should enable two-phase borrows checks. This is\n+    /// done with either `-Ztwo-phase-borrows` or with\n+    /// `#![feature(nll)]`.\n+    pub fn two_phase_borrows(&self) -> bool {\n+        self.features.borrow().nll || self.opts.debugging_opts.two_phase_borrows\n+    }\n+\n+    /// What mode(s) of borrowck should we run? AST? MIR? both?\n+    /// (Also considers the `#![feature(nll)]` setting.)\n+    pub fn borrowck_mode(&self) -> BorrowckMode {\n+        match self.opts.borrowck_mode {\n+            mode @ BorrowckMode::Mir |\n+            mode @ BorrowckMode::Compare => mode,\n+\n+            mode @ BorrowckMode::Ast => {\n+                if self.nll() {\n+                    BorrowckMode::Mir\n+                } else {\n+                    mode\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /// Should we emit EndRegion MIR statements? These are consumed by\n+    /// MIR borrowck, but not when NLL is used. They are also consumed\n+    /// by the validation stuff.\n     pub fn emit_end_regions(&self) -> bool {\n+        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n+        // but for now we can't stop doing so because it causes false positives\n         self.opts.debugging_opts.emit_end_regions ||\n-            (self.opts.debugging_opts.mir_emit_validate > 0) ||\n-            self.opts.borrowck_mode.use_mir()\n+            self.opts.debugging_opts.mir_emit_validate > 0 ||\n+            self.use_mir()\n     }\n+\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto || self.target.target.options.requires_lto\n     }"}, {"sha": "51841836698ebbe8e837950bded19eb61566ecc9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -865,13 +865,17 @@ impl fmt::Debug for ty::RegionVid {\n define_print! {\n     () ty::InferTy, (self, f, cx) {\n         display {\n-            match *self {\n-                ty::TyVar(_) => write!(f, \"_\"),\n-                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            if cx.is_verbose {\n+                print!(f, cx, print_debug(self))\n+            } else {\n+                match *self {\n+                    ty::TyVar(_) => write!(f, \"_\"),\n+                    ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                    ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                    ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                    ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                    ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+                }\n             }\n         }\n         debug {"}, {"sha": "b124872ba12ca70eb8ccf51090c77844795552b4", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -275,7 +275,7 @@ impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.tcx.sess.opts.borrowck_mode) {\n+        if !o.should_emit_errors(self.tcx.sess.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "bc1b3edbb6ad91fc2cc54fa0f7b956aa61cff32f", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 94, "deletions": 28, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -88,7 +88,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n@@ -100,23 +100,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        self.tcx\n-            .cannot_move_when_borrowed(\n-                span,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            )\n-            .span_label(\n-                self.retrieve_borrow_span(borrow),\n-                format!(\"borrow of {} occurs here\", borrow_msg),\n-            )\n-            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n-            .emit();\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+        err.span_label(\n+            self.retrieve_borrow_span(borrow),\n+            format!(\"borrow of {} occurs here\", borrow_msg),\n+        );\n+        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        err.emit();\n     }\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n@@ -128,6 +128,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+\n         err.emit();\n     }\n \n@@ -313,12 +315,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n+        self.explain_why_borrow_contains_point(context, issued_borrow, &mut err);\n+\n         err.emit();\n     }\n \n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n-        _: Context,\n+        context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n@@ -357,27 +361,57 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match (borrow.region, &self.describe_place(&borrow.borrowed_place)) {\n             (RegionKind::ReScope(_), Some(name)) => {\n                 self.report_scoped_local_value_does_not_live_long_enough(\n-                    name, &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    name,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span\n+                );\n             },\n             (RegionKind::ReScope(_), None) => {\n                 self.report_scoped_temporary_value_does_not_live_long_enough(\n-                    &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span\n+                );\n             },\n             (RegionKind::ReEarlyBound(_), Some(name)) |\n             (RegionKind::ReFree(_), Some(name)) |\n             (RegionKind::ReStatic, Some(name)) |\n             (RegionKind::ReEmpty, Some(name)) |\n             (RegionKind::ReVar(_), Some(name)) => {\n                 self.report_unscoped_local_value_does_not_live_long_enough(\n-                    name, &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    name,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span,\n+                );\n             },\n             (RegionKind::ReEarlyBound(_), None) |\n             (RegionKind::ReFree(_), None) |\n             (RegionKind::ReStatic, None) |\n             (RegionKind::ReEmpty, None) |\n             (RegionKind::ReVar(_), None) => {\n                 self.report_unscoped_temporary_value_does_not_live_long_enough(\n-                    &scope_tree, &borrow, drop_span, borrow_span, proper_span, end_span);\n+                    context,\n+                    &scope_tree,\n+                    &borrow,\n+                    drop_span,\n+                    borrow_span,\n+                    proper_span,\n+                    end_span,\n+                );\n             },\n             (RegionKind::ReLateBound(_, _), _) |\n             (RegionKind::ReSkolemized(_, _), _) |\n@@ -389,8 +423,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     fn report_scoped_local_value_does_not_live_long_enough(\n-        &mut self, name: &String, _scope_tree: &Rc<ScopeTree>, _borrow: &BorrowData<'tcx>,\n-        drop_span: Span, borrow_span: Span, _proper_span: Span, end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        name: &String,\n+        _scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_span: Span,\n+        _proper_span: Span,\n+        end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n                                                               &format!(\"`{}`\", name),\n@@ -400,12 +441,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(end) = end_span {\n             err.span_label(end, \"borrowed value needs to live until here\");\n         }\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_scoped_temporary_value_does_not_live_long_enough(\n-        &mut self, _scope_tree: &Rc<ScopeTree>, _borrow: &BorrowData<'tcx>,\n-        drop_span: Span, _borrow_span: Span, proper_span: Span, end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        _scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        _borrow_span: Span,\n+        proper_span: Span,\n+        end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n                                                               \"borrowed value\",\n@@ -416,12 +464,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(end) = end_span {\n             err.span_label(end, \"temporary value needs to live until here\");\n         }\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_unscoped_local_value_does_not_live_long_enough(\n-        &mut self, name: &String, scope_tree: &Rc<ScopeTree>, borrow: &BorrowData<'tcx>,\n-        drop_span: Span, borrow_span: Span, _proper_span: Span, _end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        name: &String,\n+        scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrow_span: Span,\n+        _proper_span: Span,\n+        _end_span: Option<Span>,\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n                                                               &format!(\"`{}`\", name),\n@@ -431,12 +487,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_region(scope_tree, &mut err,\n                                          \"borrowed value must be valid for \",\n                                          borrow.region, \"...\");\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     fn report_unscoped_temporary_value_does_not_live_long_enough(\n-        &mut self, scope_tree: &Rc<ScopeTree>, borrow: &BorrowData<'tcx>,\n-        drop_span: Span, _borrow_span: Span, proper_span: Span, _end_span: Option<Span>\n+        &mut self,\n+        context: Context,\n+        scope_tree: &Rc<ScopeTree>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        _borrow_span: Span,\n+        proper_span: Span,\n+        _end_span: Option<Span>\n     ) {\n         let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n                                                               \"borrowed value\",\n@@ -446,12 +509,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_region(scope_tree, &mut err,\n                                          \"borrowed value must be valid for \",\n                                          borrow.region, \"...\");\n+        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n-        _: Context,\n+        context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData,\n     ) {\n@@ -462,6 +526,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n+        self.explain_why_borrow_contains_point(context, loan, &mut err);\n+\n         err.emit();\n     }\n "}, {"sha": "c907c97d6d3ed58b7942b3c4bdf7acf39321cd2d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 243, "deletions": 187, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,6 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -25,6 +26,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n \n+use std::rc::Rc;\n+\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -34,9 +37,9 @@ use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n+use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n use dataflow::{ActiveBorrows, Reservations};\n-use dataflow::indexes::{BorrowIndex};\n+use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -69,10 +72,7 @@ fn mir_borrowck<'a, 'tcx>(\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n-    if {\n-        !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.borrowck_mode.use_mir()\n-            && !tcx.sess.opts.debugging_opts.nll\n-    } {\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.use_mir() {\n         return None;\n     }\n \n@@ -101,7 +101,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // contain non-lexical lifetimes. It will have a lifetime tied\n     // to the inference context.\n     let mut mir: Mir<'tcx> = input_mir.clone();\n-    let free_regions = if !tcx.sess.opts.debugging_opts.nll {\n+    let free_regions = if !tcx.sess.nll() {\n         None\n     } else {\n         let mir = &mut mir;\n@@ -149,9 +149,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         param_env: param_env,\n     };\n     let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor |\n-        DefPathData::EnumVariant(_) => None,\n-        _ => Some(tcx.hir.body_owned_by(id))\n+        DefPathData::StructCtor | DefPathData::EnumVariant(_) => None,\n+        _ => Some(tcx.hir.body_owned_by(id)),\n     };\n \n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n@@ -203,9 +202,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             &mut flow_inits,\n             &mdpe.move_data,\n         );\n-        (Some(regioncx), opt_closure_req)\n+        (Some(Rc::new(regioncx)), opt_closure_req)\n     } else {\n-        assert!(!tcx.sess.opts.debugging_opts.nll);\n+        assert!(!tcx.sess.nll());\n         (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n@@ -217,13 +216,13 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n         locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n-            hir::BodyOwnerKind::Const |\n-            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n             hir::BodyOwnerKind::Fn => true,\n         },\n         storage_dead_or_drop_error_reported_l: FxHashSet(),\n         storage_dead_or_drop_error_reported_s: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n+        nonlexical_regioncx: opt_regioncx.clone(),\n     };\n \n     let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n@@ -241,18 +240,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             // In practice it is easier to be looser; in particular,\n             // it is okay for the kill-sets to hold activation bits.\n             DebugFormatted::new(&(i.kind(), rs.location(i)))\n-        });\n+        },\n+    );\n     let flow_active_borrows = {\n         let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n         let reservations = flow_reservations.0.operator;\n-        let a = DataflowAnalysis::new_with_entry_sets(mir,\n-                                                      &dead_unwinds,\n-                                                      Cow::Borrowed(reservations_on_entry),\n-                                                      ActiveBorrows::new(reservations));\n-        let results = a.run(tcx,\n-                            id,\n-                            &attributes,\n-                            |ab, i| DebugFormatted::new(&(i.kind(), ab.location(i))));\n+        let a = DataflowAnalysis::new_with_entry_sets(\n+            mir,\n+            &dead_unwinds,\n+            Cow::Borrowed(reservations_on_entry),\n+            ActiveBorrows::new(reservations),\n+        );\n+        let results = a.run(tcx, id, &attributes, |ab, i| {\n+            DebugFormatted::new(&(i.kind(), ab.location(i)))\n+        });\n         FlowAtLocation::new(results)\n     };\n \n@@ -297,6 +298,10 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// but it is currently inconvenient to track down the BorrowIndex\n     /// at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// Non-lexical region inference context, if NLL is enabled.  This\n+    /// contains the results from region inference and lets us e.g.\n+    /// find out which CFG points are contained in each borrow region.\n+    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n // Check that:\n@@ -551,9 +556,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     }\n                 });\n             }\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Unreachable |\n-            TerminatorKind::FalseEdges { .. } => {\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::FalseEdges { .. } => {\n                 // no data used, thus irrelevant to borrowck\n             }\n         }\n@@ -648,13 +653,12 @@ enum LocalMutationIsAllowed {\n     /// We want use of immutable upvars to cause a \"write to immutable upvar\"\n     /// error, not an \"reassignment\" error.\n     ExceptUpvars,\n-    No\n+    No,\n }\n \n struct AccessErrorsReported {\n     mutability_error: bool,\n-    #[allow(dead_code)]\n-    conflict_error: bool\n+    #[allow(dead_code)] conflict_error: bool,\n }\n \n #[derive(Copy, Clone)]\n@@ -704,9 +708,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if let Activation(_, borrow_index) = rw {\n             if self.reservation_error_reported.contains(&place_span.0) {\n-                debug!(\"skipping access_place for activation of invalid reservation \\\n-                        place: {:?} borrow_index: {:?}\", place_span.0, borrow_index);\n-                return AccessErrorsReported { mutability_error: false, conflict_error: true };\n+                debug!(\n+                    \"skipping access_place for activation of invalid reservation \\\n+                     place: {:?} borrow_index: {:?}\",\n+                    place_span.0,\n+                    borrow_index\n+                );\n+                return AccessErrorsReported {\n+                    mutability_error: false,\n+                    conflict_error: true,\n+                };\n             }\n         }\n \n@@ -715,7 +726,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n-        AccessErrorsReported { mutability_error, conflict_error }\n+        AccessErrorsReported {\n+            mutability_error,\n+            conflict_error,\n+        }\n     }\n \n     fn check_access_for_conflict(\n@@ -738,22 +752,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 //\n                 // NOTE: *reservations* do conflict with themselves;\n                 // thus aren't injecting unsoundenss w/ this check.)\n-                (Activation(_, activating), _) if activating == index.borrow_index() =>\n-                {\n-                    debug!(\"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n-                            skipping {:?} b/c activation of same borrow_index: {:?}\",\n-                           place_span, sd, rw, (index, borrow), index.borrow_index());\n+                (Activation(_, activating), _) if activating == index.borrow_index() => {\n+                    debug!(\n+                        \"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n+                         skipping {:?} b/c activation of same borrow_index: {:?}\",\n+                        place_span,\n+                        sd,\n+                        rw,\n+                        (index, borrow),\n+                        index.borrow_index()\n+                    );\n                     Control::Continue\n                 }\n \n-                (Read(_), BorrowKind::Shared) |\n-                (Reservation(..), BorrowKind::Shared) => Control::Continue,\n+                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    Control::Continue\n+                }\n \n-                (Read(kind), BorrowKind::Unique) |\n-                (Read(kind), BorrowKind::Mut) => {\n+                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.tcx.sess.opts.debugging_opts.two_phase_borrows &&\n-                        index.is_reservation()\n+                    if this.tcx.sess.two_phase_borrows() && index.is_reservation()\n                     {\n                         return Control::Continue;\n                     }\n@@ -781,20 +799,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Control::Break\n                 }\n \n-                (Reservation(kind), BorrowKind::Unique) |\n-                (Reservation(kind), BorrowKind::Mut) |\n-                (Activation(kind, _), _) |\n-                (Write(kind), _) => {\n-\n+                (Reservation(kind), BorrowKind::Unique)\n+                | (Reservation(kind), BorrowKind::Mut)\n+                | (Activation(kind, _), _)\n+                | (Write(kind), _) => {\n                     match rw {\n                         Reservation(_) => {\n-                            debug!(\"recording invalid reservation of \\\n-                                    place: {:?}\", place_span.0);\n+                            debug!(\n+                                \"recording invalid reservation of \\\n+                                 place: {:?}\",\n+                                place_span.0\n+                            );\n                             this.reservation_error_reported.insert(place_span.0.clone());\n                         }\n                         Activation(_, activating) => {\n-                            debug!(\"observing check_place for activation of \\\n-                                    borrow_index: {:?}\", activating);\n+                            debug!(\n+                                \"observing check_place for activation of \\\n+                                 borrow_index: {:?}\",\n+                                activating\n+                            );\n                         }\n                         Read(..) | Write(..) => {}\n                     }\n@@ -818,8 +841,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context, borrow, place_span.1,\n-                                flow_state.borrows.operator());\n+                                context,\n+                                borrow,\n+                                place_span.1,\n+                                flow_state.borrows.operator(),\n+                            );\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -893,7 +919,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut => {\n                         let wk = WriteKind::MutableBorrow(bk);\n-                        if self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+                        if self.tcx.sess.two_phase_borrows() {\n                             (Deep, Reservation(wk))\n                         } else {\n                             (Deep, Write(wk))\n@@ -917,10 +943,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(_ /*un_op*/, ref operand) |\n-            Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n                 self.consume_operand(context, (operand, span), flow_state)\n             }\n \n@@ -945,8 +971,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n-            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n+            | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n                 self.consume_operand(context, (operand1, span), flow_state);\n                 self.consume_operand(context, (operand2, span), flow_state);\n             }\n@@ -1015,12 +1041,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn check_for_invalidation_at_exit(&mut self,\n-                                      context: Context,\n-                                      borrow: &BorrowData<'tcx>,\n-                                      span: Span,\n-                                      flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-    {\n+    fn check_for_invalidation_at_exit(\n+        &mut self,\n+        context: Context,\n+        borrow: &BorrowData<'tcx>,\n+        span: Span,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n@@ -1061,11 +1088,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // FIXME: replace this with a proper borrow_conflicts_with_place when\n         // that is merged.\n-        let sd = if might_be_alive {\n-            Deep\n-        } else {\n-            Shallow(None)\n-        };\n+        let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n         if self.places_conflict(place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n@@ -1075,17 +1098,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 context,\n                 borrow,\n                 span.end_point(),\n-                flow_state.borrows.operator()\n+                flow_state.borrows.operator(),\n             )\n         }\n     }\n \n-    fn check_activations(&mut self,\n-                         location: Location,\n-                         span: Span,\n-                         flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-    {\n-        if !self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n+    fn check_activations(\n+        &mut self,\n+        location: Location,\n+        span: Span,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) {\n+        if !self.tcx.sess.two_phase_borrows() {\n             return;\n         }\n \n@@ -1095,8 +1119,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let domain = flow_state.borrows.operator();\n         let data = domain.borrows();\n         flow_state.borrows.each_gen_bit(|gen| {\n-            if gen.is_activation()\n-            {\n+            if gen.is_activation() {\n                 let borrow_index = gen.borrow_index();\n                 let borrow = &data[borrow_index];\n                 // currently the flow analysis registers\n@@ -1105,16 +1128,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // mutable borrow before we check it.\n                 match borrow.kind {\n                     BorrowKind::Shared => return,\n-                    BorrowKind::Unique |\n-                    BorrowKind::Mut => {}\n+                    BorrowKind::Unique | BorrowKind::Mut => {}\n                 }\n \n-                self.access_place(ContextKind::Activation.new(location),\n-                                  (&borrow.borrowed_place, span),\n-                                  (Deep, Activation(WriteKind::MutableBorrow(borrow.kind),\n-                                                    borrow_index)),\n-                                  LocalMutationIsAllowed::No,\n-                                  flow_state);\n+                self.access_place(\n+                    ContextKind::Activation.new(location),\n+                    (&borrow.borrowed_place, span),\n+                    (\n+                        Deep,\n+                        Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index),\n+                    ),\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n                 // We do not need to call `check_if_path_is_moved`\n                 // again, as we already called it when we made the\n                 // initial reservation.\n@@ -1135,7 +1161,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n-        debug!(\"check_if_reassignment_to_immutable_state({:?}) - is an imm local\", place);\n+        debug!(\n+            \"check_if_reassignment_to_immutable_state({:?}) - is an imm local\",\n+            place\n+        );\n \n         for i in flow_state.ever_inits.elems_incoming() {\n             let init = self.move_data.inits[i];\n@@ -1364,14 +1393,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         let mut error_reported = false;\n         match kind {\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique)) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n                 if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut)) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n                 self.is_mutable(place, is_local_mutation_allowed)\n             {\n                 error_reported = true;\n@@ -1393,8 +1422,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 err.emit();\n             },\n-            Reservation(WriteKind::Mutate) |\n-            Write(WriteKind::Mutate) => {\n+            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n                 if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n \n@@ -1415,12 +1443,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n-            Reservation(WriteKind::Move) |\n-            Reservation(WriteKind::StorageDeadOrDrop) |\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Shared)) |\n-            Write(WriteKind::Move) |\n-            Write(WriteKind::StorageDeadOrDrop) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n+            Reservation(WriteKind::Move)\n+            | Reservation(WriteKind::StorageDeadOrDrop)\n+            | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Write(WriteKind::Move)\n+            | Write(WriteKind::StorageDeadOrDrop)\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     self.tcx.sess.delay_span_bug(\n                         span,\n@@ -1435,10 +1463,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Activation(..) => {} // permission checks are done at Reservation point.\n \n-            Read(ReadKind::Borrow(BorrowKind::Unique)) |\n-            Read(ReadKind::Borrow(BorrowKind::Mut)) |\n-            Read(ReadKind::Borrow(BorrowKind::Shared)) |\n-            Read(ReadKind::Copy) => {} // Access authorized\n+            Read(ReadKind::Borrow(BorrowKind::Unique))\n+            | Read(ReadKind::Borrow(BorrowKind::Mut))\n+            | Read(ReadKind::Borrow(BorrowKind::Shared))\n+            | Read(ReadKind::Copy) => {} // Access authorized\n         }\n \n         error_reported\n@@ -1455,8 +1483,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes |\n-                        LocalMutationIsAllowed::ExceptUpvars => Ok(()),\n+                        LocalMutationIsAllowed::Yes | LocalMutationIsAllowed::ExceptUpvars => {\n+                            Ok(())\n+                        }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1481,13 +1510,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match\n-                                            self.is_upvar_field_projection(&proj.base)\n+                                        let mode = match self.is_upvar_field_projection(&proj.base)\n                                         {\n-                                            Some(field) if {\n-                                                self.mir.upvar_decls[field.index()].by_ref\n-                                            } => is_local_mutation_allowed,\n-                                            _ => LocalMutationIsAllowed::Yes\n+                                            Some(field)\n+                                                if {\n+                                                    self.mir.upvar_decls[field.index()].by_ref\n+                                                } =>\n+                                            {\n+                                                is_local_mutation_allowed\n+                                            }\n+                                            _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n                                         self.is_mutable(&proj.base, mode)\n@@ -1513,22 +1545,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                     // All other projections are owned by their base path, so mutable if\n                     // base path is mutable\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::Downcast(..) => {\n                         if let Some(field) = self.is_upvar_field_projection(place) {\n                             let decl = &self.mir.upvar_decls[field.index()];\n-                            debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                   decl, is_local_mutation_allowed, place);\n+                            debug!(\n+                                \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                decl,\n+                                is_local_mutation_allowed,\n+                                place\n+                            );\n                             match (decl.mutability, is_local_mutation_allowed) {\n-                                (Mutability::Not, LocalMutationIsAllowed::No) |\n-                                (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars)\n-                                    => Err(place),\n-                                (Mutability::Not, LocalMutationIsAllowed::Yes) |\n-                                (Mutability::Mut, _) =>\n+                                (Mutability::Not, LocalMutationIsAllowed::No)\n+                                | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n+                                    Err(place)\n+                                }\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes)\n+                                | (Mutability::Mut, _) => {\n                                     self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                }\n                             }\n                         } else {\n                             self.is_mutable(&proj.base, is_local_mutation_allowed)\n@@ -1593,11 +1631,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // Given that the bases of `elem1` and `elem2` are always either equal\n     // or disjoint (and have the same type!), return the overlap situation\n     // between `elem1` and `elem2`.\n-    fn place_element_conflict(&self,\n-                               elem1: &Place<'tcx>,\n-                               elem2: &Place<'tcx>)\n-                               -> Overlap\n-    {\n+    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n         match (elem1, elem2) {\n             (Place::Local(l1), Place::Local(l2)) => {\n                 if l1 == l2 {\n@@ -1623,8 +1657,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Overlap::EqualOrDisjoint\n                 }\n             }\n-            (Place::Local(_), Place::Static(_)) |\n-            (Place::Static(_), Place::Local(_)) => {\n+            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n                 debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n                 Overlap::Disjoint\n             }\n@@ -1689,15 +1722,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             Overlap::Disjoint\n                         }\n                     }\n-                    (ProjectionElem::Index(..), ProjectionElem::Index(..)) |\n-                    (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::Index(..), ProjectionElem::Subslice { .. }) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..)) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. }) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                    | (\n+                        ProjectionElem::ConstantIndex { .. },\n+                        ProjectionElem::ConstantIndex { .. },\n+                    )\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n                         // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n                         // (if the indexes differ) or equal (if they are the same), so this\n                         // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n@@ -1714,41 +1750,45 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Overlap::EqualOrDisjoint\n                     }\n \n-                    (ProjectionElem::Deref, _) |\n-                    (ProjectionElem::Field(..), _) |\n-                    (ProjectionElem::Index(..), _) |\n-                    (ProjectionElem::ConstantIndex { .. }, _) |\n-                    (ProjectionElem::Subslice { .. }, _) |\n-                    (ProjectionElem::Downcast(..), _) => {\n-                        bug!(\"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-\n-                             elem1, elem2)\n-                    }\n+                    (ProjectionElem::Deref, _)\n+                    | (ProjectionElem::Field(..), _)\n+                    | (ProjectionElem::Index(..), _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _)\n+                    | (ProjectionElem::Subslice { .. }, _)\n+                    | (ProjectionElem::Downcast(..), _) => bug!(\n+                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                        elem1,\n+                        elem2\n+                    ),\n                 }\n             }\n-            (Place::Projection(_), _) |\n-            (_, Place::Projection(_)) => {\n-                bug!(\"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-                     elem1, elem2)\n-            }\n+            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                elem1,\n+                elem2\n+            ),\n         }\n     }\n \n     /// Returns whether an access of kind `access` to `access_place` conflicts with\n     /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n     /// locations, this function is symmetric between `borrow_place` & `access_place`).\n-    fn places_conflict(&mut self,\n-                       borrow_place: &Place<'tcx>,\n-                       access_place: &Place<'tcx>,\n-                       access: ShallowOrDeep)\n-                       -> bool\n-    {\n-        debug!(\"places_conflict({:?},{:?},{:?})\", borrow_place, access_place, access);\n+    fn places_conflict(\n+        &mut self,\n+        borrow_place: &Place<'tcx>,\n+        access_place: &Place<'tcx>,\n+        access: ShallowOrDeep,\n+    ) -> bool {\n+        debug!(\n+            \"places_conflict({:?},{:?},{:?})\",\n+            borrow_place,\n+            access_place,\n+            access\n+        );\n \n         // Return all the prefixes of `place` in reverse order, including\n         // downcasts.\n-        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>>\n-        {\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n             let mut result = vec![];\n             let mut place = place;\n             loop {\n@@ -1767,13 +1807,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let borrow_components = place_elements(borrow_place);\n         let access_components = place_elements(access_place);\n-        debug!(\"places_conflict: components {:?} / {:?}\",\n-               borrow_components, access_components);\n+        debug!(\n+            \"places_conflict: components {:?} / {:?}\",\n+            borrow_components,\n+            access_components\n+        );\n \n-        let borrow_components = borrow_components.into_iter()\n-             .map(Some).chain(iter::repeat(None));\n-        let access_components = access_components.into_iter()\n-             .map(Some).chain(iter::repeat(None));\n+        let borrow_components = borrow_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        let access_components = access_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n         // The borrowck rules for proving disjointness are applied from the \"root\" of the\n         // borrow forwards, iterating over \"similar\" projections in lockstep until\n         // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n@@ -1839,13 +1886,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                     let (base, elem) = match borrow_c {\n                         Place::Projection(box Projection { base, elem }) => (base, elem),\n-                        _ => bug!(\"place has no base?\")\n+                        _ => bug!(\"place has no base?\"),\n                     };\n                     let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n                     match (elem, &base_ty.sty, access) {\n-                        (_, _, Shallow(Some(ArtificialField::Discriminant))) |\n-                        (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n                             // The discriminant and array length are like\n                             // additional fields on the type; they do not\n                             // overlap any existing data there. Furthermore,\n@@ -1866,9 +1913,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             debug!(\"places_conflict: shallow access behind ptr\");\n                             return false;\n                         }\n-                        (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n-                            ty: _, mutbl: hir::MutImmutable\n-                        }), _) => {\n+                        (\n+                            ProjectionElem::Deref,\n+                            ty::TyRef(\n+                                _,\n+                                ty::TypeAndMut {\n+                                    ty: _,\n+                                    mutbl: hir::MutImmutable,\n+                                },\n+                            ),\n+                            _,\n+                        ) => {\n                             // the borrow goes through a dereference of a shared reference.\n                             //\n                             // I'm not sure why we are tracking these borrows - shared\n@@ -1878,12 +1933,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return false;\n                         }\n \n-                        (ProjectionElem::Deref, _, Deep) |\n-                        (ProjectionElem::Field { .. }, _, _) |\n-                        (ProjectionElem::Index { ..}, _, _) |\n-                        (ProjectionElem::ConstantIndex { .. }, _, _) |\n-                        (ProjectionElem::Subslice { .. }, _, _) |\n-                        (ProjectionElem::Downcast { .. }, _, _) => {\n+                        (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n                             // Recursive case. This can still be disjoint on a\n                             // further iteration if this a shallow access and\n                             // there's a deref later on, e.g. a borrow\n@@ -1920,7 +1975,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return false;\n                         }\n                     }\n-\n                 }\n             }\n         }\n@@ -1963,7 +2017,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 let ctrl = op(self, i, borrowed);\n-                if ctrl == Control::Break { return; }\n+                if ctrl == Control::Break {\n+                    return;\n+                }\n             }\n         }\n     }"}, {"sha": "bdacd831cb656ec9699db3e48c2755da99494de1", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::fold::TypeFoldable;\n \n use super::ToRegionVid;\n-use super::region_infer::RegionInferenceContext;\n+use super::region_infer::{RegionInferenceContext, Cause};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -53,14 +53,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n+        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n         self.super_substs(substs);\n     }\n \n     /// We sometimes have `region` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*region, location);\n+        self.add_regular_live_constraint(*region, location, Cause::LiveOther(location));\n         self.super_region(region);\n     }\n \n@@ -75,7 +75,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                           ty_context);\n             }\n             TyContext::Location(location) => {\n-                self.add_regular_live_constraint(*ty, location);\n+                self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n             }\n         }\n \n@@ -85,7 +85,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// We sometimes have `closure_substs` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n     fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*substs, location);\n+        self.add_regular_live_constraint(*substs, location, Cause::LiveOther(location));\n         self.super_closure_substs(substs);\n     }\n \n@@ -112,7 +112,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location, cause: Cause)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -126,7 +126,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location);\n+                self.regioncx.add_live_point(vid, location, &cause);\n             });\n     }\n "}, {"sha": "948c1ac0b136255b35b4d2697a9b219890cb1a04", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::{Context, MirBorrowckCtxt};\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use dataflow::BorrowData;\n+use rustc::mir::{Local, Location, Mir};\n+use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::DiagnosticBuilder;\n+use util::liveness::{self, DefUse, LivenessMode};\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    pub(in borrow_check) fn explain_why_borrow_contains_point(\n+        &self,\n+        context: Context,\n+        borrow: &BorrowData<'_>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if let Some(regioncx) = &self.nonlexical_regioncx {\n+            if let Some(cause) = regioncx.why_region_contains_point(borrow.region, context.loc) {\n+                let mir = self.mir;\n+\n+                match *cause.root_cause() {\n+                    Cause::LiveVar(local, location) => {\n+                        match find_regular_use(&mir, regioncx, borrow, location, local) {\n+                            Some(p) => {\n+                                err.span_label(\n+                                    mir.source_info(p).span,\n+                                    format!(\"borrow later used here\"),\n+                                );\n+                            }\n+\n+                            None => {\n+                                span_bug!(\n+                                    mir.source_info(context.loc).span,\n+                                    \"Cause should end in a LiveVar\"\n+                                );\n+                            }\n+                        }\n+                    }\n+\n+                    Cause::DropVar(local, location) => {\n+                        match find_drop_use(&mir, regioncx, borrow, location, local) {\n+                            Some(p) => {\n+                                let local_name = &mir.local_decls[local].name.unwrap();\n+\n+                                err.span_label(\n+                                    mir.source_info(p).span,\n+                                    format!(\n+                                        \"borrow later used here, when `{}` is dropped\",\n+                                        local_name\n+                                    ),\n+                                );\n+                            }\n+\n+                            None => {\n+                                span_bug!(\n+                                    mir.source_info(context.loc).span,\n+                                    \"Cause should end in a DropVar\"\n+                                );\n+                            }\n+                        }\n+                    }\n+\n+                    _ => {\n+                        cause.label_diagnostic(mir, err);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn find_regular_use<'gcx, 'tcx>(\n+    mir: &'gcx Mir,\n+    regioncx: &'tcx RegionInferenceContext,\n+    borrow: &'tcx BorrowData,\n+    start_point: Location,\n+    local: Local,\n+) -> Option<Location> {\n+    let mut uf = UseFinder {\n+        mir,\n+        regioncx,\n+        borrow,\n+        start_point,\n+        local,\n+        liveness_mode: LivenessMode {\n+            include_regular_use: true,\n+            include_drops: false,\n+        },\n+    };\n+\n+    uf.find()\n+}\n+\n+fn find_drop_use<'gcx, 'tcx>(\n+    mir: &'gcx Mir,\n+    regioncx: &'tcx RegionInferenceContext,\n+    borrow: &'tcx BorrowData,\n+    start_point: Location,\n+    local: Local,\n+) -> Option<Location> {\n+    let mut uf = UseFinder {\n+        mir,\n+        regioncx,\n+        borrow,\n+        start_point,\n+        local,\n+        liveness_mode: LivenessMode {\n+            include_regular_use: false,\n+            include_drops: true,\n+        },\n+    };\n+\n+    uf.find()\n+}\n+\n+struct UseFinder<'gcx, 'tcx> {\n+    mir: &'gcx Mir<'gcx>,\n+    regioncx: &'tcx RegionInferenceContext<'tcx>,\n+    borrow: &'tcx BorrowData<'tcx>,\n+    start_point: Location,\n+    local: Local,\n+    liveness_mode: LivenessMode,\n+}\n+\n+impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n+    fn find(&mut self) -> Option<Location> {\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(self.start_point);\n+        while let Some(p) = stack.pop() {\n+            if !self.regioncx.region_contains_point(self.borrow.region, p) {\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                continue;\n+            }\n+\n+            let block_data = &self.mir[p.block];\n+            let (defined, used) = self.def_use(p, block_data.visitable(p.statement_index));\n+\n+            if used {\n+                return Some(p);\n+            } else if !defined {\n+                if p.statement_index < block_data.statements.len() {\n+                    stack.push(Location {\n+                        statement_index: p.statement_index + 1,\n+                        ..p\n+                    });\n+                } else {\n+                    stack.extend(\n+                        block_data\n+                            .terminator()\n+                            .successors()\n+                            .iter()\n+                            .map(|&basic_block| Location {\n+                                statement_index: 0,\n+                                block: basic_block,\n+                            }),\n+                    );\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn def_use(&self, location: Location, thing: &MirVisitable<'tcx>) -> (bool, bool) {\n+        let mut visitor = DefUseVisitor {\n+            defined: false,\n+            used: false,\n+            local: self.local,\n+            liveness_mode: self.liveness_mode,\n+        };\n+\n+        thing.apply(location, &mut visitor);\n+\n+        (visitor.defined, visitor.used)\n+    }\n+}\n+\n+struct DefUseVisitor {\n+    defined: bool,\n+    used: bool,\n+    local: Local,\n+    liveness_mode: LivenessMode,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DefUseVisitor {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n+        if local == self.local {\n+            match liveness::categorize(context, self.liveness_mode) {\n+                Some(DefUse::Def) => self.defined = true,\n+                Some(DefUse::Use) => self.used = true,\n+                None => (),\n+            }\n+        }\n+    }\n+}"}, {"sha": "f96e107efa38fa76b374b3195908fec29072609f", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -27,6 +27,7 @@ use util::pretty::{self, ALIGN};\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+pub mod explain_borrow;\n pub(crate) mod region_infer;\n mod renumber;\n mod subtype_constraint_generation;\n@@ -77,17 +78,13 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     Option<ClosureRegionRequirements<'gcx>>,\n ) {\n     // Run the MIR type-checker.\n-    let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let liveness = &LivenessResults::compute(mir);\n-    let fr_fn_body = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let constraint_sets = &type_check::type_check(\n         infcx,\n-        mir_node_id,\n         param_env,\n         mir,\n-        fr_fn_body,\n-        universal_regions.input_tys,\n-        universal_regions.output_ty,\n+        def_id,\n+        &universal_regions,\n         &liveness,\n         flow_inits,\n         move_data,\n@@ -285,19 +282,25 @@ fn for_each_region_constraint(\n /// This is reasonable because in our MIR we replace all universal regions\n /// with inference variables.\n pub trait ToRegionVid {\n-    fn to_region_vid(&self) -> RegionVid;\n+    fn to_region_vid(self) -> RegionVid;\n }\n \n-impl ToRegionVid for RegionKind {\n-    fn to_region_vid(&self) -> RegionVid {\n-        if let &ty::ReVar(vid) = self {\n-            vid\n+impl<'tcx> ToRegionVid for &'tcx RegionKind {\n+    fn to_region_vid(self) -> RegionVid {\n+        if let ty::ReVar(vid) = self {\n+            *vid\n         } else {\n             bug!(\"region is not an ReVar: {:?}\", self)\n         }\n     }\n }\n \n+impl ToRegionVid for RegionVid {\n+    fn to_region_vid(self) -> RegionVid {\n+        self\n+    }\n+}\n+\n fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n     // sort and deduplicate:\n     let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();"}, {"sha": "e8a23acd798de8b2df23c8a809be17ed69445893", "filename": "src/librustc_mir/borrow_check/nll/region_infer/annotation.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fannotation.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,32 +15,40 @@\n //! handle the part about dumping the inference context internal\n //! state.\n \n-use rustc::ty;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::universal_regions::DefiningTy;\n use rustc_errors::DiagnosticBuilder;\n-use super::RegionInferenceContext;\n \n impl<'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// Write out our state into the `.mir` files.\n     pub(crate) fn annotate(&self, err: &mut DiagnosticBuilder<'_>) {\n-        match self.universal_regions.defining_ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+        match self.universal_regions.defining_ty {\n+            DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!(\n                     \"defining type: {:?} with closure substs {:#?}\",\n                     def_id,\n                     &substs.substs[..]\n                 ));\n             }\n-            ty::TyFnDef(def_id, substs) => {\n+            DefiningTy::Generator(def_id, substs, interior) => {\n+                err.note(&format!(\n+                    \"defining type: {:?} with closure substs {:#?} and interior {:?}\",\n+                    def_id,\n+                    &substs.substs[..],\n+                    interior\n+                ));\n+            }\n+            DefiningTy::FnDef(def_id, substs) => {\n                 err.note(&format!(\n                     \"defining type: {:?} with substs {:#?}\",\n                     def_id,\n                     &substs[..]\n                 ));\n             }\n-            _ => {\n+            DefiningTy::Const(ty) => {\n                 err.note(&format!(\n                     \"defining type: {:?}\",\n-                    self.universal_regions.defining_ty\n+                    ty\n                 ));\n             }\n         }"}, {"sha": "d55b601823245d55dbb5e1110846a8d5e6848c3a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,6 +15,7 @@ use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueElements,\n                                               RegionValues};\n+use syntax::codemap::Span;\n use rustc::mir::{Location, Mir};\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::FxHashSet;\n@@ -127,6 +128,7 @@ pub(super) struct CopyFromSourceToTarget<'v> {\n     pub target_region: RegionVid,\n     pub inferred_values: &'v mut RegionValues,\n     pub constraint_point: Location,\n+    pub constraint_span: Span,\n }\n \n impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n@@ -143,14 +145,22 @@ impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n     }\n \n     fn add_to_target_region(&mut self, point_index: RegionElementIndex) -> Result<bool, !> {\n-        Ok(self.inferred_values.add(self.target_region, point_index))\n+        Ok(self.inferred_values.add_due_to_outlives(\n+            self.source_region,\n+            self.target_region,\n+            point_index,\n+            self.constraint_point,\n+            self.constraint_span,\n+        ))\n     }\n \n     fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, !> {\n-        Ok(\n-            self.inferred_values\n-                .add_universal_regions_outlived_by(self.source_region, self.target_region),\n-        )\n+        Ok(self.inferred_values.add_universal_regions_outlived_by(\n+            self.source_region,\n+            self.target_region,\n+            self.constraint_point,\n+            self.constraint_span,\n+        ))\n     }\n }\n "}, {"sha": "da136a34b99710b80eeea8a40d7707662e66982b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 297, "deletions": 42, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,12 +15,15 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n+use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-                 Location, Mir};\n+                 Local, Location, Mir};\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n+use rustc::util::common::ErrorReported;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_errors::DiagnosticBuilder;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -34,6 +37,8 @@ mod graphviz;\n mod values;\n use self::values::{RegionValueElements, RegionValues};\n \n+use super::ToRegionVid;\n+\n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n     /// variables are identified by their index (`RegionVid`). The\n@@ -65,6 +70,8 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_regions: UniversalRegions<'tcx>,\n }\n \n+struct TrackCauses(bool);\n+\n struct RegionDefinition<'tcx> {\n     /// Why we created this variable. Mostly these will be\n     /// `RegionVariableOrigin::NLL`, but some variables get created\n@@ -83,6 +90,38 @@ struct RegionDefinition<'tcx> {\n     external_name: Option<ty::Region<'tcx>>,\n }\n \n+/// NB: The variants in `Cause` are intentionally ordered. Lower\n+/// values are preferred when it comes to error messages. Do not\n+/// reorder willy nilly.\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub(crate) enum Cause {\n+    /// point inserted because Local was live at the given Location\n+    LiveVar(Local, Location),\n+\n+    /// point inserted because Local was dropped at the given Location\n+    DropVar(Local, Location),\n+\n+    /// point inserted because the type was live at the given Location,\n+    /// but not as part of some local variable\n+    LiveOther(Location),\n+\n+    /// part of the initial set of values for a universally quantified region\n+    UniversalRegion(RegionVid),\n+\n+    /// Element E was added to R because there was some\n+    /// outlives obligation `R: R1 @ P` and `R1` contained `E`.\n+    Outlives {\n+        /// the reason that R1 had E\n+        original_cause: Rc<Cause>,\n+\n+        /// the point P from the relation\n+        constraint_location: Location,\n+\n+        /// The span indicating why we added the outlives constraint.\n+        constraint_span: Span,\n+    },\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n     // NB. The ordering here is not significant for correctness, but\n@@ -193,7 +232,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n-    pub fn new(\n+    pub(crate) fn new(\n         var_origins: VarOrigins,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n@@ -209,10 +248,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|origin| RegionDefinition::new(origin))\n             .collect();\n \n+        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.nll_dump_cause());\n+\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n-            liveness_constraints: RegionValues::new(elements, num_region_variables),\n+            liveness_constraints: RegionValues::new(\n+                elements,\n+                num_region_variables,\n+                TrackCauses(nll_dump_cause),\n+            ),\n             inferred_values: None,\n             constraints: Vec::new(),\n             type_tests: Vec::new(),\n@@ -262,11 +307,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Add all nodes in the CFG to liveness constraints\n             for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add(variable, point_index);\n+                self.liveness_constraints.add(\n+                    variable,\n+                    point_index,\n+                    &Cause::UniversalRegion(variable),\n+                );\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add(variable, variable);\n+            self.liveness_constraints\n+                .add(variable, variable, &Cause::UniversalRegion(variable));\n         }\n     }\n \n@@ -286,11 +336,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n+    pub fn region_contains_point<R>(&self, r: R, p: Location) -> bool\n+    where\n+        R: ToRegionVid,\n+    {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        inferred_values.contains(r, p)\n+        inferred_values.contains(r.to_region_vid(), p)\n+    }\n+\n+    /// Returns the *reason* that the region `r` contains the given point.\n+    pub(crate) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n+    where\n+        R: ToRegionVid,\n+    {\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+        inferred_values.cause(r.to_region_vid(), p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n@@ -306,13 +370,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location, cause: &Cause) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        debug!(\"add_live_point: @{:?}\", point);\n+        debug!(\"add_live_point: @{:?} Adding cause {:?}\", point, cause);\n \n         let element = self.elements.index(point);\n-        if self.liveness_constraints.add(v, element) {\n+        if self.liveness_constraints.add(v, element, &cause) {\n             true\n         } else {\n             false\n@@ -366,9 +430,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(infcx, mir, outlives_requirements.as_mut());\n+        self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n-        self.check_universal_regions(infcx, outlives_requirements.as_mut());\n+        self.check_universal_regions(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -416,6 +480,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         target_region: constraint.sup,\n                         inferred_values: &mut inferred_values,\n                         constraint_point: constraint.point,\n+                        constraint_span: constraint.span,\n                     },\n                 );\n \n@@ -439,6 +504,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         let tcx = infcx.tcx;\n@@ -457,14 +523,56 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // Oh the humanity. Obviously we will do better than this error eventually.\n-            tcx.sess.span_err(\n-                type_test.span,\n-                &format!(\n-                    \"`{}` does not outlive `{:?}`\",\n+            let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+            if let Some(lower_bound_region) = lower_bound_region {\n+                let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n+                infcx.report_generic_bound_failure(\n+                    region_scope_tree,\n+                    type_test.span,\n+                    None,\n                     type_test.generic_kind,\n-                    type_test.lower_bound,\n-                ),\n-            );\n+                    lower_bound_region,\n+                );\n+            } else {\n+                // FIXME. We should handle this case better. It\n+                // indicates that we have e.g. some region variable\n+                // whose value is like `'a+'b` where `'a` and `'b` are\n+                // distinct unrelated univesal regions that are not\n+                // known to outlive one another. It'd be nice to have\n+                // some examples where this arises to decide how best\n+                // to report it; we could probably handle it by\n+                // iterating over the universal regions and reporting\n+                // an error that multiple bounds are required.\n+                tcx.sess.span_err(\n+                    type_test.span,\n+                    &format!(\n+                        \"`{}` does not live long enough\",\n+                        type_test.generic_kind,\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Converts a region inference variable into a `ty::Region` that\n+    /// we can use for error reporting. If `r` is universally bound,\n+    /// then we use the name that we have on record for it. If `r` is\n+    /// existentially bound, then we check its inferred value and try\n+    /// to find a good name from that. Returns `None` if we can't find\n+    /// one (e.g., this is just some random part of the CFG).\n+    fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+        if self.universal_regions.is_universal_region(r) {\n+            return self.definitions[r].external_name;\n+        } else {\n+            let inferred_values = self.inferred_values\n+                                      .as_ref()\n+                                      .expect(\"region values not yet inferred\");\n+            let upper_bound = self.universal_upper_bound(r);\n+            if inferred_values.contains(r, upper_bound) {\n+                self.to_error_region(upper_bound)\n+            } else {\n+                None\n+            }\n         }\n     }\n \n@@ -598,6 +706,36 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// encoding `T` as part of `try_promote_type_test_subject` (see\n     /// that fn for details).\n     ///\n+    /// This is based on the result `'y` of `universal_upper_bound`,\n+    /// except that it converts further takes the non-local upper\n+    /// bound of `'y`, so that the final result is non-local.\n+    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+\n+        debug!(\n+            \"non_local_universal_upper_bound(r={:?}={})\",\n+            r,\n+            inferred_values.region_value_str(r)\n+        );\n+\n+        let lub = self.universal_upper_bound(r);\n+\n+        // Grow further to get smallest universal region known to\n+        // creator.\n+        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+\n+        debug!(\n+            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n+            non_local_lub\n+        );\n+\n+        non_local_lub\n+    }\n+\n+    /// Returns a universally quantified region that outlives the\n+    /// value of `r` (`r` may be existentially or universally\n+    /// quantified).\n+    ///\n     /// Since `r` is (potentially) an existential region, it has some\n     /// value which may include (a) any number of points in the CFG\n     /// and (b) any number of `end('x)` elements of universally\n@@ -608,15 +746,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n-    /// - Finally, we take the non-local upper bound of `'y`.\n-    ///   - This uses `UniversalRegions::non_local_upper_bound`, which\n-    ///     is similar to this method but only works on universal\n-    ///     regions).\n-    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+    fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n         debug!(\n-            \"non_local_universal_upper_bound(r={:?}={})\",\n+            \"universal_upper_bound(r={:?}={})\",\n             r,\n             inferred_values.region_value_str(r)\n         );\n@@ -628,18 +762,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             lub = self.universal_regions.postdom_upper_bound(lub, ur);\n         }\n \n-        debug!(\"non_local_universal_upper_bound: lub={:?}\", lub);\n-\n-        // Grow further to get smallest universal region known to\n-        // creator.\n-        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+        debug!(\"universal_upper_bound: r={:?} lub={:?}\", r, lub);\n \n-        debug!(\n-            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n-            non_local_lub\n-        );\n-\n-        non_local_lub\n+        lub\n     }\n \n     /// Test if `test` is true when applied to `lower_bound` at\n@@ -743,6 +868,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         // The universal regions are always found in a prefix of the\n@@ -755,7 +882,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // they did not grow too large, accumulating any requirements\n         // for our caller into the `outlives_requirements` vector.\n         for (fr, _) in universal_definitions {\n-            self.check_universal_region(infcx, fr, &mut propagated_outlives_requirements);\n+            self.check_universal_region(\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                fr,\n+                &mut propagated_outlives_requirements,\n+            );\n         }\n     }\n \n@@ -770,6 +903,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -826,33 +961,62 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n+            self.report_error(infcx, mir, mir_def_id, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    /// Report an error because the universal region `fr` was required to outlive\n+    /// `outlived_fr` but it is not known to do so. For example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n+    ///\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     fn report_error(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n         blame_span: Span,\n     ) {\n         // Obviously uncool error reporting.\n \n-        let fr_string = match self.definitions[fr].external_name {\n+        let fr_name = self.to_error_region(fr);\n+        let outlived_fr_name = self.to_error_region(outlived_fr);\n+\n+        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n+            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n+            let nice = NiceRegionError::new(infcx.tcx, blame_span, o, f, Some(tables));\n+            if let Some(ErrorReported) = nice.try_report() {\n+                return;\n+            }\n+        }\n+\n+        let fr_string = match fr_name {\n             Some(r) => format!(\"free region `{}`\", r),\n             None => format!(\"free region `{:?}`\", fr),\n         };\n \n-        let outlived_fr_string = match self.definitions[outlived_fr].external_name {\n+        let outlived_fr_string = match outlived_fr_name {\n             Some(r) => format!(\"free region `{}`\", r),\n             None => format!(\"free region `{:?}`\", outlived_fr),\n         };\n \n-        infcx.tcx.sess.span_err(\n+        let mut diag = infcx.tcx.sess.struct_span_err(\n             blame_span,\n             &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n         );\n+\n+        // Find out why `fr` had to outlive `outlived_fr`...\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+        if let Some(cause) = inferred_values.cause(fr, outlived_fr) {\n+            cause.label_diagnostic(mir, &mut diag);\n+        }\n+\n+        diag.emit();\n     }\n \n     /// Tries to finds a good span to blame for the fact that `fr1`\n@@ -973,7 +1137,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n-    /// adding new subregion obligations to existing variables.\n+    /// adding new outlives obligations to existing variables.\n     ///\n     /// As described on `ClosureRegionRequirements`, the extra\n     /// requirements are expressed in terms of regionvids that index\n@@ -1075,3 +1239,94 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         })\n     }\n }\n+\n+trait CauseExt {\n+    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause;\n+}\n+\n+impl CauseExt for Rc<Cause> {\n+    /// Creates a derived cause due to an outlives constraint.\n+    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause {\n+        Cause::Outlives {\n+            original_cause: self.clone(),\n+            constraint_location,\n+            constraint_span,\n+        }\n+    }\n+}\n+\n+impl Cause {\n+    pub(crate) fn label_diagnostic(&self, mir: &Mir<'_>, diag: &mut DiagnosticBuilder<'_>) {\n+        // The cause information is pretty messy. Only dump it as an\n+        // internal debugging aid if -Znll-dump-cause is given.\n+        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.nll_dump_cause());\n+        if !nll_dump_cause {\n+            return;\n+        }\n+\n+        let mut string = String::new();\n+        self.push_diagnostic_string(mir, &mut string);\n+        diag.note(&string);\n+    }\n+\n+    fn push_diagnostic_string(&self, mir: &Mir<'_>, string: &mut String) {\n+        match self {\n+            Cause::LiveVar(local, location) => {\n+                string.push_str(&format!(\"because `{:?}` is live at {:?}\", local, location));\n+            }\n+\n+            Cause::DropVar(local, location) => {\n+                string.push_str(&format!(\n+                    \"because `{:?}` is dropped at {:?}\",\n+                    local,\n+                    location\n+                ));\n+            }\n+\n+            Cause::LiveOther(location) => {\n+                string.push_str(&format!(\n+                    \"because of a general liveness constraint at {:?}\",\n+                    location\n+                ));\n+            }\n+\n+            Cause::UniversalRegion(region_vid) => {\n+                string.push_str(&format!(\n+                    \"because `{:?}` is universally quantified\",\n+                    region_vid\n+                ));\n+            }\n+\n+            Cause::Outlives {\n+                original_cause,\n+                constraint_location,\n+                constraint_span: _,\n+            } => {\n+                string.push_str(&format!(\n+                    \"because of an outlives relation created at `{:?}`\\n\",\n+                    constraint_location\n+                ));\n+\n+                original_cause.push_diagnostic_string(mir, string);\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn root_cause(&self) -> &Cause {\n+        match self {\n+            Cause::LiveVar(..) |\n+            Cause::DropVar(..) |\n+            Cause::LiveOther(..) |\n+            Cause::UniversalRegion(..) => {\n+                self\n+            }\n+\n+            Cause::Outlives {\n+                original_cause,\n+                ..\n+            } => {\n+                original_cause.root_cause()\n+            }\n+        }\n+    }\n+}"}, {"sha": "b2b2ca1182d0340dff8dfefc9d2b822d0e174a11", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 123, "deletions": 26, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,10 +10,14 @@\n \n use std::rc::Rc;\n use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n+use syntax::codemap::Span;\n+\n+use super::{Cause, CauseExt, TrackCauses};\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -27,18 +31,23 @@ pub(super) struct RegionValueElements {\n impl RegionValueElements {\n     pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block =\n-            mir.basic_blocks()\n-               .iter()\n-               .map(|block_data| {\n-                   let v = num_points;\n-                   num_points += block_data.statements.len() + 1;\n-                   v\n-               })\n-               .collect();\n-\n-        debug!(\"RegionValueElements(num_universal_regions={:?})\", num_universal_regions);\n-        debug!(\"RegionValueElements: statements_before_block={:#?}\", statements_before_block);\n+        let statements_before_block = mir.basic_blocks()\n+            .iter()\n+            .map(|block_data| {\n+                let v = num_points;\n+                num_points += block_data.statements.len() + 1;\n+                v\n+            })\n+            .collect();\n+\n+        debug!(\n+            \"RegionValueElements(num_universal_regions={:?})\",\n+            num_universal_regions\n+        );\n+        debug!(\n+            \"RegionValueElements: statements_before_block={:#?}\",\n+            statements_before_block\n+        );\n         debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n \n         Self {\n@@ -60,7 +69,9 @@ impl RegionValueElements {\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n     pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n+        (0..self.num_points).map(move |i| {\n+            RegionElementIndex::new(i + self.num_universal_regions)\n+        })\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n@@ -95,12 +106,11 @@ impl RegionValueElements {\n             // be (BB2, 20).\n             //\n             // Nit: we could do a binary search here but I'm too lazy.\n-            let (block, &first_index) =\n-                self.statements_before_block\n-                    .iter_enumerated()\n-                    .filter(|(_, first_index)| **first_index <= point_index)\n-                    .last()\n-                    .unwrap();\n+            let (block, &first_index) = self.statements_before_block\n+                .iter_enumerated()\n+                .filter(|(_, first_index)| **first_index <= point_index)\n+                .last()\n+                .unwrap();\n \n             RegionElement::Location(Location {\n                 block,\n@@ -151,7 +161,10 @@ pub(super) trait ToElementIndex {\n \n impl ToElementIndex for Location {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        let Location { block, statement_index } = self;\n+        let Location {\n+            block,\n+            statement_index,\n+        } = self;\n         let start_index = elements.statements_before_block[block];\n         RegionElementIndex::new(elements.num_universal_regions + start_index + statement_index)\n     }\n@@ -178,10 +191,22 @@ impl ToElementIndex for RegionElementIndex {\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: BitMatrix,\n+\n+    /// If cause tracking is enabled, maps from a pair (r, e)\n+    /// consisting of a region `r` that contains some element `e` to\n+    /// the reason that the element is contained. There should be an\n+    /// entry for every bit set to 1 in `BitMatrix`.\n+    causes: Option<CauseMap>,\n }\n \n+type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n+\n impl RegionValues {\n-    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+    pub(super) fn new(\n+        elements: &Rc<RegionValueElements>,\n+        num_region_variables: usize,\n+        track_causes: TrackCauses,\n+    ) -> Self {\n         assert!(\n             elements.num_universal_regions <= num_region_variables,\n             \"universal regions are a subset of the region variables\"\n@@ -190,31 +215,83 @@ impl RegionValues {\n         Self {\n             elements: elements.clone(),\n             matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+            causes: if track_causes.0 {\n+                Some(CauseMap::default())\n+            } else {\n+                None\n+            },\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n+    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E, cause: &Cause) -> bool {\n         let i = self.elements.index(elem);\n+        self.add_internal(r, i, |_| cause.clone())\n+    }\n+\n+    /// Internal method to add an element to a region.\n+    ///\n+    /// Takes a \"lazy\" cause -- this function will return the cause, but it will only\n+    /// be invoked if cause tracking is enabled.\n+    fn add_internal<F>(&mut self, r: RegionVid, i: RegionElementIndex, make_cause: F) -> bool\n+    where\n+        F: FnOnce(&CauseMap) -> Cause,\n+    {\n         if self.matrix.add(r.index(), i.index()) {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n+\n+            if let Some(causes) = &mut self.causes {\n+                let cause = Rc::new(make_cause(causes));\n+                causes.insert((r, i), cause);\n+            }\n+\n             true\n         } else {\n+            if let Some(causes) = &mut self.causes {\n+                let cause = make_cause(causes);\n+                let old_cause = causes.get_mut(&(r, i)).unwrap();\n+                if cause < **old_cause {\n+                    *old_cause = Rc::new(cause);\n+                    return true;\n+                }\n+            }\n+\n             false\n         }\n     }\n \n+    /// Adds `elem` to `to_region` because of a relation:\n+    ///\n+    ///     to_region: from_region @ constraint_location\n+    ///\n+    /// that was added by the cod at `constraint_span`.\n+    pub(super) fn add_due_to_outlives<T: ToElementIndex>(\n+        &mut self,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+        elem: T,\n+        constraint_location: Location,\n+        constraint_span: Span,\n+    ) -> bool {\n+        let elem = self.elements.index(elem);\n+        self.add_internal(to_region, elem, |causes| {\n+            causes[&(from_region, elem)].outlives(constraint_location, constraint_span)\n+        })\n+    }\n+\n     /// Adds all the universal regions outlived by `from_region` to\n     /// `to_region`.\n     pub(super) fn add_universal_regions_outlived_by(\n         &mut self,\n         from_region: RegionVid,\n         to_region: RegionVid,\n+        constraint_location: Location,\n+        constraint_span: Span,\n     ) -> bool {\n-        // FIXME. We could optimize this by improving\n-        // `BitMatrix::merge` so it does not always merge an entire\n-        // row.\n+        // We could optimize this by improving `BitMatrix::merge` so\n+        // it does not always merge an entire row. That would\n+        // complicate causal tracking though.\n         debug!(\n             \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n             from_region,\n@@ -223,7 +300,13 @@ impl RegionValues {\n         let mut changed = false;\n         for elem in self.elements.all_universal_region_indices() {\n             if self.contains(from_region, elem) {\n-                changed |= self.add(to_region, elem);\n+                changed |= self.add_due_to_outlives(\n+                    from_region,\n+                    to_region,\n+                    elem,\n+                    constraint_location,\n+                    constraint_span,\n+                );\n             }\n         }\n         changed\n@@ -338,4 +421,18 @@ impl RegionValues {\n             ));\n         }\n     }\n+\n+    /// Given a region `r` that contains the element `elem`, returns the `Cause`\n+    /// that tells us *why* `elem` is found in that region.\n+    ///\n+    /// Returns None if cause tracking is disabled or `elem` is not\n+    /// actually found in `r`.\n+    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Rc<Cause>> {\n+        let index = self.elements.index(elem);\n+        if let Some(causes) = &self.causes {\n+            causes.get(&(r, index)).cloned()\n+        } else {\n+            None\n+        }\n+    }\n }"}, {"sha": "4aee48b979d6150541087aef8e85d8ba65a0ebd4", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -16,34 +16,44 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Mir<'tcx>) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n     visitor.visit_mir(mir);\n }\n \n+/// Replaces all regions appearing in `value` with fresh inference\n+/// variables.\n+pub fn renumber_regions<'tcx, T>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    ty_context: TyContext,\n+    value: &T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"renumber_regions(value={:?})\", value);\n+\n+    infcx\n+        .tcx\n+        .fold_regions(value, &mut false, |_region, _depth| {\n+            let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n+            infcx.next_nll_region_var(origin)\n+        })\n+}\n+\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    /// Replaces all regions appearing in `value` with fresh inference\n-    /// variables. This is what we do for almost the entire MIR, with\n-    /// the exception of the declared types of our arguments.\n     fn renumber_regions<T>(&mut self, ty_context: TyContext, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_regions(value={:?})\", value);\n-\n-        self.infcx\n-            .tcx\n-            .fold_regions(value, &mut false, |_region, _depth| {\n-                let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n-                self.infcx.next_nll_region_var(origin)\n-            })\n+        renumber_regions(self.infcx, ty_context, value)\n     }\n }\n "}, {"sha": "32728145b29f682b8e733cde1d566acb373e394a", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -51,10 +51,10 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n             outlives_sets.len()\n         );\n \n-        for (region, location) in liveness_set {\n+        for (region, location, cause) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = self.to_region_vid(region);\n-            self.regioncx.add_live_point(region_vid, *location);\n+            self.regioncx.add_live_point(region_vid, *location, &cause);\n         }\n \n         for OutlivesSet { locations, data } in outlives_sets {"}, {"sha": "9e88a632f5c3dc833d10733bfe4858c2b7fee395", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains code to equate the input/output types appearing\n+//! in the MIR with the expected input/output types from the function\n+//! signature. This requires a bit of processing, as the expected types\n+//! are supplied to us before normalization and may contain existential\n+//! `impl Trait` instances. In contrast, the input/output types found in\n+//! the MIR (specifically, in the special local variables for the\n+//! `RETURN_PLACE` the MIR arguments) are always fully normalize (and\n+//! contain revealed `impl Trait` values).\n+\n+use borrow_check::nll::renumber;\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::InferOk;\n+use rustc::ty::Ty;\n+use rustc::ty::subst::Subst;\n+use rustc::mir::*;\n+use rustc::mir::visit::TyContext;\n+use rustc::traits::PredicateObligations;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use super::{AtLocation, TypeChecker};\n+\n+impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+    pub(super) fn equate_inputs_and_outputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        universal_regions: &UniversalRegions<'tcx>,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+\n+        let &UniversalRegions {\n+            unnormalized_output_ty,\n+            unnormalized_input_tys,\n+            ..\n+        } = universal_regions;\n+        let infcx = self.infcx;\n+\n+        let start_position = Location {\n+            block: START_BLOCK,\n+            statement_index: 0,\n+        };\n+\n+        // Equate expected input tys with those in the MIR.\n+        let argument_locals = (1..).map(Local::new);\n+        for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n+            let input_ty = self.normalize(&unnormalized_input_ty, start_position);\n+            let mir_input_ty = mir.local_decls[local].ty;\n+            self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n+        }\n+\n+        // Return types are a bit more complex. They may contain existential `impl Trait`\n+        // types.\n+        debug!(\n+            \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n+            unnormalized_output_ty\n+        );\n+        let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        debug!(\n+            \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n+            output_ty\n+        );\n+        let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n+        let anon_type_map = self.fully_perform_op(start_position.at_self(), |cx| {\n+            let mut obligations = ObligationAccumulator::default();\n+\n+            let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n+                mir_def_id,\n+                cx.body_id,\n+                cx.param_env,\n+                &output_ty,\n+            ));\n+            debug!(\n+                \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                output_ty\n+            );\n+            debug!(\n+                \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                anon_type_map\n+            );\n+\n+            debug!(\n+                \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                mir_output_ty\n+            );\n+            obligations.add(infcx\n+                .at(&cx.misc(cx.last_span), cx.param_env)\n+                .eq(output_ty, mir_output_ty)?);\n+\n+            for (&anon_def_id, anon_decl) in &anon_type_map {\n+                let anon_defn_ty = tcx.type_of(anon_def_id);\n+                let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                let anon_defn_ty = renumber::renumber_regions(\n+                    cx.infcx,\n+                    TyContext::Location(start_position),\n+                    &anon_defn_ty,\n+                );\n+                debug!(\n+                    \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                    anon_decl.concrete_ty\n+                );\n+                debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                obligations.add(infcx\n+                    .at(&cx.misc(cx.last_span), cx.param_env)\n+                    .eq(anon_decl.concrete_ty, anon_defn_ty)?);\n+            }\n+\n+            debug!(\"equate_inputs_and_outputs: equated\");\n+\n+            Ok(InferOk {\n+                value: Some(anon_type_map),\n+                obligations: obligations.into_vec(),\n+            })\n+        }).unwrap_or_else(|terr| {\n+                span_mirbug!(\n+                    self,\n+                    start_position,\n+                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n+                    output_ty,\n+                    mir_output_ty,\n+                    terr\n+                );\n+                None\n+            });\n+\n+        // Finally, if we instantiated the anon types successfully, we\n+        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n+        // prove that `T: Iterator` where `T` is the type we\n+        // instantiated it with).\n+        if let Some(anon_type_map) = anon_type_map {\n+            self.fully_perform_op(start_position.at_self(), |_cx| {\n+                infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                Ok(InferOk {\n+                    value: (),\n+                    obligations: vec![],\n+                })\n+            }).unwrap();\n+        }\n+    }\n+\n+    fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n+\n+        if let Err(terr) = self.eq_types(a, b, location.at_self()) {\n+            span_mirbug!(\n+                self,\n+                location,\n+                \"equate_normalized_input_or_output: `{:?}=={:?}` failed with `{:?}`\",\n+                a,\n+                b,\n+                terr\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+struct ObligationAccumulator<'tcx> {\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'tcx> ObligationAccumulator<'tcx> {\n+    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = value;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+\n+    fn into_vec(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}"}, {"sha": "50b38f9b46b618b4b2a03ef43198fee253e71e9d", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use borrow_check::nll::region_infer::Cause;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n@@ -79,7 +80,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             .simulate_block(self.mir, bb, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.push_type_live_constraint(live_local_ty, location);\n+                    let cause = Cause::LiveVar(live_local, location);\n+                    self.push_type_live_constraint(live_local_ty, location, cause);\n                 }\n             });\n \n@@ -121,7 +123,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     );\n \n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_drop_live_constraint(live_local_ty, location);\n+                    self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }\n             }\n \n@@ -146,7 +148,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn push_type_live_constraint<T>(&mut self, value: T, location: Location)\n+    fn push_type_live_constraint<T>(&mut self, value: T, location: Location, cause: Cause)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -160,7 +162,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             self.cx\n                 .constraints\n                 .liveness_set\n-                .push((live_region, location));\n+                .push((live_region, location, cause.clone()));\n         });\n     }\n \n@@ -169,9 +171,15 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// the regions in its type must be live at `location`. The\n     /// precise set will depend on the dropck constraints, and in\n     /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+    fn add_drop_live_constraint(\n+        &mut self,\n+        dropped_local: Local,\n+        dropped_ty: Ty<'tcx>,\n+        location: Location,\n+    ) {\n         debug!(\n-            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            \"add_drop_live_constraint(dropped_local={:?}, dropped_ty={:?}, location={:?})\",\n+            dropped_local,\n             dropped_ty,\n             location\n         );\n@@ -196,7 +204,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             // All things in the `outlives` array may be touched by\n             // the destructor and must be live at this point.\n             for outlive in outlives {\n-                self.push_type_live_constraint(outlive, location);\n+                let cause = Cause::DropVar(dropped_local, location);\n+                self.push_type_live_constraint(outlive, location, cause);\n             }\n \n             // However, there may also be some types that\n@@ -207,7 +216,8 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                 let ty = self.cx.normalize(&ty, location);\n                 match ty.sty {\n                     ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                        self.push_type_live_constraint(ty, location);\n+                        let cause = Cause::DropVar(dropped_local, location);\n+                        self.push_type_live_constraint(ty, location, cause);\n                     }\n \n                     _ => if known.insert(ty) {"}, {"sha": "4c8a171299f2c84c7845436c77d661616e157a8c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 82, "deletions": 85, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -11,12 +11,15 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n+use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n-use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n@@ -34,7 +37,32 @@ use util::liveness::LivenessResults;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+macro_rules! span_mirbug {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        $crate::borrow_check::nll::type_check::mirbug(\n+            $context.tcx(),\n+            $context.last_span,\n+            &format!(\n+                \"broken MIR in {:?} ({:?}): {}\",\n+                $context.body_id,\n+                $elem,\n+                format_args!($($message)*),\n+            ),\n+        )\n+    })\n+}\n+\n+macro_rules! span_mirbug_and_err {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        {\n+            span_mirbug!($context, $elem, $($message)*);\n+            $context.error()\n+        }\n+    })\n+}\n+\n mod liveness;\n+mod input_output;\n \n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n@@ -50,9 +78,11 @@ mod liveness;\n /// # Parameters\n ///\n /// - `infcx` -- inference context to use\n-/// - `body_id` -- body-id of the MIR being checked\n /// - `param_env` -- parameter environment to use for trait solving\n /// - `mir` -- MIR to type-check\n+/// - `mir_def_id` -- DefId from which the MIR is derived (must be local)\n+/// - `region_bound_pairs` -- the implied outlives obligations between type parameters\n+///   and lifetimes (e.g., `&'a T` implies `T: 'a`)\n /// - `implicit_region_bound` -- a region which all generic parameters are assumed\n ///   to outlive; should represent the fn body\n /// - `input_tys` -- fully liberated, but **not** normalized, expected types of the arguments;\n@@ -65,31 +95,27 @@ mod liveness;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n-    implicit_region_bound: ty::Region<'tcx>,\n-    input_tys: &[Ty<'tcx>],\n-    output_ty: Ty<'tcx>,\n+    mir_def_id: DefId,\n+    universal_regions: &UniversalRegions<'tcx>,\n     liveness: &LivenessResults,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n+    let body_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+    let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     type_check_internal(\n         infcx,\n         body_id,\n         param_env,\n         mir,\n+        &universal_regions.region_bound_pairs,\n         Some(implicit_region_bound),\n         &mut |cx| {\n             liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n-            // Equate the input and output tys given by the user with\n-            // the ones found in the MIR.\n-            cx.equate_input_or_output(output_ty, mir.local_decls[RETURN_PLACE].ty);\n-            for (&input_ty, local) in input_tys.iter().zip((1..).map(Local::new)) {\n-                cx.equate_input_or_output(input_ty, mir.local_decls[local].ty);\n-            }\n+            cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n         },\n     )\n }\n@@ -99,10 +125,17 @@ fn type_check_internal<'gcx, 'tcx>(\n     body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n+    region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     extra: &mut FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n ) -> MirTypeckRegionConstraints<'tcx> {\n-    let mut checker = TypeChecker::new(infcx, body_id, param_env, implicit_region_bound);\n+    let mut checker = TypeChecker::new(\n+        infcx,\n+        body_id,\n+        param_env,\n+        region_bound_pairs,\n+        implicit_region_bound,\n+    );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n         verifier.visit_mir(mir);\n@@ -119,33 +152,13 @@ fn type_check_internal<'gcx, 'tcx>(\n     checker.constraints\n }\n \n-\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n     // to avoid reporting bugs in those cases.\n     tcx.sess.diagnostic().delay_span_bug(span, msg);\n }\n \n-macro_rules! span_mirbug {\n-    ($context:expr, $elem:expr, $($message:tt)*) => ({\n-        mirbug($context.tcx(), $context.last_span,\n-               &format!(\"broken MIR in {:?} ({:?}): {}\",\n-                        $context.body_id,\n-                        $elem,\n-                        format_args!($($message)*)))\n-    })\n-}\n-\n-macro_rules! span_mirbug_and_err {\n-    ($context:expr, $elem:expr, $($message:tt)*) => ({\n-        {\n-            span_mirbug!($context, $elem, $($message)*);\n-            $context.error()\n-        }\n-    })\n-}\n-\n enum FieldAccessError {\n     OutOfRange { field_count: usize },\n }\n@@ -570,6 +583,7 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n+    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n@@ -578,15 +592,15 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n #[derive(Default)]\n-pub struct MirTypeckRegionConstraints<'tcx> {\n+pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n     /// cases, the MIR type-checker creates temporary regions that do\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    pub liveness_set: Vec<(ty::Region<'tcx>, Location)>,\n+    pub liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n     /// During the course of type-checking, we will accumulate region\n     /// constraints due to performing subtyping operations or solving\n@@ -624,13 +638,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         body_id: ast::NodeId,\n         param_env: ty::ParamEnv<'gcx>,\n+        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n             last_span: DUMMY_SP,\n             body_id,\n             param_env,\n+            region_bound_pairs,\n             implicit_region_bound,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n@@ -657,7 +673,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         self.infcx.process_registered_region_obligations(\n-            &[],\n+            self.region_bound_pairs,\n             self.implicit_region_bound,\n             self.param_env,\n             self.body_id,\n@@ -694,25 +710,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn equate_input_or_output(&mut self, unnormalized_a: Ty<'tcx>, b: Ty<'tcx>) {\n-        let start_position = Location {\n-            block: START_BLOCK,\n-            statement_index: 0,\n-        };\n-        let a = self.normalize(&unnormalized_a, start_position);\n-        if let Err(terr) = self.eq_types(a, b, start_position.at_self()) {\n-            span_mirbug!(\n-                self,\n-                start_position,\n-                \"bad input or output {:?} normalized to {:?} should equal {:?} but got error {:?}\",\n-                unnormalized_a,\n-                a,\n-                b,\n-                terr\n-            );\n-        }\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -763,12 +760,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::StorageLive(_) |\n-            StatementKind::StorageDead(_) |\n-            StatementKind::InlineAsm { .. } |\n-            StatementKind::EndRegion(_) |\n-            StatementKind::Validate(..) |\n-            StatementKind::Nop => {}\n+            StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::InlineAsm { .. }\n+            | StatementKind::EndRegion(_)\n+            | StatementKind::Validate(..)\n+            | StatementKind::Nop => {}\n         }\n     }\n \n@@ -781,13 +778,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n-            TerminatorKind::Goto { .. } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Return |\n-            TerminatorKind::GeneratorDrop |\n-            TerminatorKind::Unreachable |\n-            TerminatorKind::Drop { .. } |\n-            TerminatorKind::FalseEdges { .. } => {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::FalseEdges { .. } => {\n                 // no checks needed for these\n             }\n \n@@ -887,9 +884,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    self.constraints\n-                        .liveness_set\n-                        .push((late_bound_region, term_location));\n+                    self.constraints.liveness_set.push((\n+                        late_bound_region,\n+                        term_location,\n+                        Cause::LiveOther(term_location),\n+                    ));\n                 }\n \n                 if self.is_box_free(func) {\n@@ -1099,9 +1098,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Unreachable => {}\n-            TerminatorKind::Drop { target, unwind, .. } |\n-            TerminatorKind::DropAndReplace { target, unwind, .. } |\n-            TerminatorKind::Assert {\n+            TerminatorKind::Drop { target, unwind, .. }\n+            | TerminatorKind::DropAndReplace { target, unwind, .. }\n+            | TerminatorKind::Assert {\n                 target,\n                 cleanup: unwind,\n                 ..\n@@ -1357,13 +1356,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             },\n \n             // FIXME: These other cases have to be implemented in future PRs\n-            Rvalue::Use(..) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) => {}\n+            Rvalue::Use(..)\n+            | Rvalue::Ref(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..) => {}\n         }\n     }\n \n@@ -1497,9 +1496,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             let cause = this.misc(this.last_span);\n             let obligations = predicates\n                 .iter()\n-                .map(|&p| {\n-                    traits::Obligation::new(cause.clone(), this.param_env, p)\n-                })\n+                .map(|&p| traits::Obligation::new(cause.clone(), this.param_env, p))\n                 .collect();\n             Ok(InferOk {\n                 value: (),\n@@ -1563,7 +1560,7 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _ = type_check_internal(&infcx, id, param_env, mir, None, &mut |_| ());\n+            let _ = type_check_internal(&infcx, id, param_env, mir, &[], None, &mut |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "45604d52958c185f7535ab98a4bc3ebd00ad0d91", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 135, "deletions": 85, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -22,11 +22,12 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n-use rustc::hir::HirId;\n+use rustc::hir::{BodyOwnerKind, HirId};\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::outlives::bounds::{self, OutlivesBound};\n+use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n@@ -67,19 +68,21 @@ pub struct UniversalRegions<'tcx> {\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated.  For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `TyFnDef`.\n-    pub defining_ty: Ty<'tcx>,\n+    pub defining_ty: DefiningTy<'tcx>,\n \n     /// The return type of this function, with all regions replaced by\n-    /// their universal `RegionVid` equivalents. This type is **NOT\n-    /// NORMALIZED** (i.e., it contains unnormalized associated type\n-    /// projections).\n-    pub output_ty: Ty<'tcx>,\n+    /// their universal `RegionVid` equivalents.\n+    ///\n+    /// NB. Associated types in this type have not been normalized,\n+    /// as the name suggests. =)\n+    pub unnormalized_output_ty: Ty<'tcx>,\n \n     /// The fully liberated input types of this function, with all\n     /// regions replaced by their universal `RegionVid` equivalents.\n-    /// This type is **NOT NORMALIZED** (i.e., it contains\n-    /// unnormalized associated type projections).\n-    pub input_tys: &'tcx [Ty<'tcx>],\n+    ///\n+    /// NB. Associated types in these types have not been normalized,\n+    /// as the name suggests. =)\n+    pub unnormalized_input_tys: &'tcx [Ty<'tcx>],\n \n     /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n     /// be true. These encode relationships like `T: 'a` that are\n@@ -96,6 +99,33 @@ pub struct UniversalRegions<'tcx> {\n     relations: UniversalRegionRelations,\n }\n \n+/// The \"defining type\" for this MIR. The key feature of the \"defining\n+/// type\" is that it contains the information needed to derive all the\n+/// universal regions that are in scope as well as the types of the\n+/// inputs/output from the MIR. In general, early-bound universal\n+/// regions appear free in the defining type and late-bound regions\n+/// appear bound in the signature.\n+#[derive(Copy, Clone, Debug)]\n+pub enum DefiningTy<'tcx> {\n+    /// The MIR is a closure. The signature is found via\n+    /// `ClosureSubsts::closure_sig_ty`.\n+    Closure(DefId, ty::ClosureSubsts<'tcx>),\n+\n+    /// The MIR is a generator. The signature is that generators take\n+    /// no parameters and return the result of\n+    /// `ClosureSubsts::generator_return_ty`.\n+    Generator(DefId, ty::ClosureSubsts<'tcx>, ty::GeneratorInterior<'tcx>),\n+\n+    /// The MIR is a fn item with the given def-id and substs. The signature\n+    /// of the function can be bound then with the `fn_sig` query.\n+    FnDef(DefId, &'tcx Substs<'tcx>),\n+\n+    /// The MIR represents some form of constant. The signature then\n+    /// is that it has no inputs and a single return value, which is\n+    /// the value of the constant.\n+    Const(Ty<'tcx>),\n+}\n+\n #[derive(Debug)]\n struct UniversalRegionIndices<'tcx> {\n     /// For those regions that may appear in the parameter environment\n@@ -415,16 +445,20 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let defining_ty = self.defining_ty();\n         debug!(\"build: defining_ty={:?}\", defining_ty);\n \n-        let indices = self.compute_indices(fr_static, defining_ty);\n+        let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n         let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n \n         // \"Liberate\" the late-bound regions. These correspond to\n         // \"local\" free regions.\n         let first_local_index = self.infcx.num_region_vars();\n-        let inputs_and_output = self.infcx\n-            .replace_bound_regions_with_nll_infer_vars(FR, &bound_inputs_and_output);\n+        let inputs_and_output = self.infcx.replace_bound_regions_with_nll_infer_vars(\n+            FR,\n+            self.mir_def_id,\n+            &bound_inputs_and_output,\n+            &mut indices,\n+        );\n         let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n         let num_universals = self.infcx.num_region_vars();\n \n@@ -452,10 +486,8 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             self.relations.relate_universal_regions(fr, fr_fn_body);\n         }\n \n-        let (output_ty, input_tys) = inputs_and_output.split_last().unwrap();\n-\n-        // we should not have created any more variables\n-        assert_eq!(self.infcx.num_region_vars(), num_universals);\n+        let (unnormalized_output_ty, unnormalized_input_tys) =\n+            inputs_and_output.split_last().unwrap();\n \n         debug!(\n             \"build: global regions = {}..{}\",\n@@ -481,30 +513,18 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             first_local_index,\n             num_universals,\n             defining_ty,\n-            output_ty,\n-            input_tys,\n+            unnormalized_output_ty,\n+            unnormalized_input_tys,\n             region_bound_pairs: self.region_bound_pairs,\n             relations: self.relations,\n         }\n     }\n \n-    /// Returns the \"defining type\" of the current MIR:\n-    ///\n-    /// - for functions, this is the `TyFnDef`;\n-    /// - for closures, this is the `TyClosure`;\n-    /// - for generators, this is the `TyGenerator`;\n-    /// - for constants, this is the type of value that gets produced.\n-    ///   - FIXME. Constants are handled somewhat inelegantly; this gets\n-    ///     patched in a later PR that has already landed on nll-master.\n-    ///\n-    /// The key feature of the \"defining type\" is that it contains the\n-    /// information needed to derive all the universal regions that\n-    /// are in scope as well as the types of the inputs/output from\n-    /// the MIR. In general, early-bound universal regions appear free\n-    /// in the defining type and late-bound regions appear bound in\n-    /// the signature.\n-    fn defining_ty(&self) -> ty::Ty<'tcx> {\n+    /// Returns the \"defining type\" of the current MIR;\n+    /// see `DefiningTy` for details.\n+    fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n+\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n \n         let defining_ty = if self.mir_def_id == closure_base_def_id {\n@@ -514,8 +534,25 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             tables.node_id_to_type(self.mir_hir_id)\n         };\n \n-        self.infcx\n-            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n+        let defining_ty = self.infcx\n+            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n+\n+        match tcx.hir.body_owner_kind(self.mir_node_id) {\n+            BodyOwnerKind::Fn => match defining_ty.sty {\n+                ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n+                ty::TyGenerator(def_id, substs, interior) => {\n+                    DefiningTy::Generator(def_id, substs, interior)\n+                }\n+                ty::TyFnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n+                _ => span_bug!(\n+                    tcx.def_span(self.mir_def_id),\n+                    \"expected defining type for `{:?}`: `{:?}`\",\n+                    self.mir_def_id,\n+                    defining_ty\n+                ),\n+            },\n+            BodyOwnerKind::Const | BodyOwnerKind::Static(..) => DefiningTy::Const(defining_ty),\n+        }\n     }\n \n     /// Builds a hashmap that maps from the universal regions that are\n@@ -525,14 +562,14 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     fn compute_indices(\n         &self,\n         fr_static: RegionVid,\n-        defining_ty: Ty<'tcx>,\n+        defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n         let gcx = tcx.global_tcx();\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n         let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n-        let fr_substs = match defining_ty.sty {\n-            ty::TyClosure(_, substs) | ty::TyGenerator(_, substs, ..) => {\n+        let fr_substs = match defining_ty {\n+            DefiningTy::Closure(_, substs) | DefiningTy::Generator(_, substs, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `closure_base_def_id`.\n@@ -544,28 +581,18 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 assert_eq!(substs.substs.regions().count(), identity_substs.regions().count());\n                 substs.substs\n             }\n-            ty::TyFnDef(_, substs) => substs,\n \n-            // FIXME. When we encounter other sorts of constant\n+            DefiningTy::FnDef(_, substs) => substs,\n+\n+            // When we encounter other sorts of constant\n             // expressions, such as the `22` in `[foo; 22]`, we can\n             // get the type `usize` here. For now, just return an\n             // empty vector of substs in this case, since there are no\n             // generics in scope in such expressions right now.\n-            //\n-            // Eventually I imagine we could get a wider range of\n-            // types.  What is the best way to handle this? Should we\n-            // be checking something other than the type of the def-id\n-            // to figure out what to do (e.g. the def-key?).\n-            ty::TyUint(..) => {\n+            DefiningTy::Const(_) => {\n                 assert!(identity_substs.is_empty());\n                 identity_substs\n             }\n-\n-            _ => span_bug!(\n-                tcx.def_span(self.mir_def_id),\n-                \"unknown defining type: {:?}\",\n-                defining_ty\n-            ),\n         };\n \n         let global_mapping = iter::once((gcx.types.re_static, fr_static));\n@@ -581,11 +608,11 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n     fn compute_inputs_and_output(\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n-        defining_ty: Ty<'tcx>,\n+        defining_ty: DefiningTy<'tcx>,\n     ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n-        match defining_ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+        match defining_ty {\n+            DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def_id, def_id);\n                 let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n                 let inputs_and_output = closure_sig.inputs_and_output();\n@@ -613,32 +640,24 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 )\n             }\n \n-            ty::TyGenerator(def_id, substs, ..) => {\n+            DefiningTy::Generator(def_id, substs, interior) => {\n                 assert_eq!(self.mir_def_id, def_id);\n                 let output = substs.generator_return_ty(def_id, tcx);\n-                let inputs_and_output = self.infcx.tcx.intern_type_list(&[defining_ty, output]);\n+                let generator_ty = tcx.mk_generator(def_id, substs, interior);\n+                let inputs_and_output = self.infcx.tcx.intern_type_list(&[generator_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }\n \n-            ty::TyFnDef(def_id, _) => {\n+            DefiningTy::FnDef(def_id, _) => {\n                 let sig = tcx.fn_sig(def_id);\n                 let sig = indices.fold_to_region_vids(tcx, &sig);\n                 sig.inputs_and_output()\n             }\n \n-            // FIXME: as above, this happens on things like `[foo;\n-            // 22]`. For now, no inputs, one output, but it seems like\n-            // we need a more general way to handle this category of\n-            // MIR.\n-            ty::TyUint(..) => {\n-                ty::Binder::dummy(tcx.mk_type_list(iter::once(defining_ty)))\n-            }\n-\n-            _ => span_bug!(\n-                tcx.def_span(self.mir_def_id),\n-                \"unexpected defining type: {:?}\",\n-                defining_ty\n-            ),\n+            // This happens on things like `[foo; 22]`. Hence, no\n+            // inputs, one output, but it seems like we need a more\n+            // general way to handle this category of MIR.\n+            DefiningTy::Const(ty) => ty::Binder::dummy(tcx.mk_type_list(iter::once(ty))),\n         }\n     }\n \n@@ -702,7 +721,7 @@ impl UniversalRegionRelations {\n     }\n }\n \n-pub(crate) trait InferCtxtExt<'tcx> {\n+trait InferCtxtExt<'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n@@ -714,7 +733,9 @@ pub(crate) trait InferCtxtExt<'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n+        all_outlive_scope: DefId,\n         value: &ty::Binder<T>,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>;\n@@ -729,28 +750,46 @@ impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.fold_regions(\n-            value,\n-            &mut false,\n-            |_region, _depth| self.next_nll_region_var(origin),\n-        )\n+        self.tcx.fold_regions(value, &mut false, |_region, _depth| {\n+            self.next_nll_region_var(origin)\n+        })\n     }\n \n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n+        all_outlive_scope: DefId,\n         value: &ty::Binder<T>,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let (value, _map) = self.tcx\n-            .replace_late_bound_regions(value, |_br| self.next_nll_region_var(origin));\n+        let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n+            let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope,\n+                bound_region: br,\n+            }));\n+            let region_vid = self.next_nll_region_var(origin);\n+            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n+            region_vid\n+        });\n         value\n     }\n }\n \n impl<'tcx> UniversalRegionIndices<'tcx> {\n+    /// Initially, the `UniversalRegionIndices` map contains only the\n+    /// early-bound regions in scope. Once that is all setup, we come\n+    /// in later and instantiate the late-bound regions, and then we\n+    /// insert the `ReFree` version of those into the map as\n+    /// well. These are used for error reporting.\n+    fn insert_late_bound_region(&mut self, r: ty::Region<'tcx>,\n+                                vid: ty::RegionVid)\n+    {\n+        self.indices.insert(r, vid);\n+    }\n+\n     /// Converts `r` into a local inference variable: `r` can either\n     /// by a `ReVar` (i.e., already a reference to an inference\n     /// variable) or it can be `'static` or some early-bound\n@@ -773,10 +812,21 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(\n-            value,\n-            &mut false,\n-            |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))),\n-        )\n+        tcx.fold_regions(value, &mut false, |region, _| {\n+            tcx.mk_region(ty::ReVar(self.to_region_vid(region)))\n+        })\n+    }\n+}\n+\n+/// This trait is used by the `impl-trait` constraint code to abstract\n+/// over the `FreeRegionMap` from lexical regions and\n+/// `UniversalRegions` (from NLL)`.\n+impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegions<'tcx> {\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+        let shorter = shorter.to_region_vid();\n+        assert!(self.is_universal_region(shorter));\n+        let longer = longer.to_region_vid();\n+        assert!(self.is_universal_region(longer));\n+        self.outlives(longer, shorter)\n     }\n }"}, {"sha": "25e4b30da80958f48cc5931bc558afdcfef1eaf9", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -66,7 +66,7 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n+    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n // Two-phase borrows actually requires two flow analyses; they need\n@@ -147,7 +147,7 @@ impl ReserveOrActivateIndex {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n+               nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n                def_id: DefId,\n                body_id: Option<hir::BodyId>)\n                -> Self {"}, {"sha": "a7efdaf08264a384e35345924ea997e253d5d6e9", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n+#![feature(dyn_trait)]\n #![feature(i128_type)]\n #![feature(inclusive_range_syntax)]\n #![feature(inclusive_range)]"}, {"sha": "38227bd713322f19ef213aaa1e635f5440dbbb22", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -75,7 +75,7 @@ pub trait BorrowckErrors {\n                                 -> DiagnosticBuilder<'a>;\n \n     fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder\n+                                 -> DiagnosticBuilder<'_>\n     {\n         let err = struct_span_err!(self, span, E0505,\n                                    \"cannot move out of `{}` because it is borrowed{OGN}\",\n@@ -89,7 +89,7 @@ pub trait BorrowckErrors {\n                                         borrow_span: Span,\n                                         borrow_desc: &str,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder\n+                                        -> DiagnosticBuilder<'_>\n     {\n         let mut err = struct_span_err!(self, span, E0503,\n                          \"cannot use `{}` because it was mutably borrowed{OGN}\",\n@@ -509,7 +509,7 @@ impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.sess.opts.borrowck_mode) {\n+        if !o.should_emit_errors(self.sess.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "765d50b4006132ac8eacba7aff7e87ddc8c39371", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -39,6 +39,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n use rustc::ty::item_path;\n+use rustc::mir::visit::MirVisitable;\n use std::path::{Path, PathBuf};\n use std::fs;\n use rustc::ty::TyCtxt;\n@@ -219,6 +220,81 @@ impl LivenessResult {\n     }\n }\n \n+#[derive(Eq, PartialEq, Clone)]\n+pub enum DefUse {\n+    Def,\n+    Use,\n+}\n+\n+pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Option<DefUse> {\n+    match context {\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DEFS\n+\n+        PlaceContext::Store |\n+\n+        // This is potentially both a def and a use...\n+        PlaceContext::AsmOutput |\n+\n+        // We let Call define the result in both the success and\n+        // unwind cases. This is not really correct, however it\n+        // does not seem to be observable due to the way that we\n+        // generate MIR. See the test case\n+        // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n+        // properly, we would apply the def in call only to the\n+        // input from the success path and not the unwind\n+        // path. -nmatsakis\n+        PlaceContext::Call |\n+\n+        // Storage live and storage dead aren't proper defines, but we can ignore\n+        // values that come before them.\n+        PlaceContext::StorageLive |\n+        PlaceContext::StorageDead => Some(DefUse::Def),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // REGULAR USES\n+        //\n+        // These are uses that occur *outside* of a drop. For the\n+        // purposes of NLL, these are special in that **all** the\n+        // lifetimes appearing in the variable must be live for each regular use.\n+\n+        PlaceContext::Projection(..) |\n+\n+        // Borrows only consider their local used at the point of the borrow.\n+        // This won't affect the results since we use this analysis for generators\n+        // and we only care about the result at suspension points. Borrows cannot\n+        // cross suspension points so this behavior is unproblematic.\n+        PlaceContext::Borrow { .. } |\n+\n+        PlaceContext::Inspect |\n+        PlaceContext::Copy |\n+        PlaceContext::Move |\n+        PlaceContext::Validate => {\n+            if mode.include_regular_use {\n+                Some(DefUse::Use)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DROP USES\n+        //\n+        // These are uses that occur in a DROP (a MIR drop, not a\n+        // call to `std::mem::drop()`). For the purposes of NLL,\n+        // uses in drop are special because `#[may_dangle]`\n+        // attributes can affect whether lifetimes must be live.\n+\n+        PlaceContext::Drop => {\n+            if mode.include_drops {\n+                Some(DefUse::Use)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n struct DefsUsesVisitor {\n     mode: LivenessMode,\n     defs_uses: DefsUses,\n@@ -267,69 +343,16 @@ impl DefsUses {\n \n impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        match context {\n-            ///////////////////////////////////////////////////////////////////////////\n-            // DEFS\n-\n-            PlaceContext::Store |\n-\n-            // This is potentially both a def and a use...\n-            PlaceContext::AsmOutput |\n-\n-            // We let Call define the result in both the success and\n-            // unwind cases. This is not really correct, however it\n-            // does not seem to be observable due to the way that we\n-            // generate MIR. See the test case\n-            // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n-            // properly, we would apply the def in call only to the\n-            // input from the success path and not the unwind\n-            // path. -nmatsakis\n-            PlaceContext::Call |\n-\n-            // Storage live and storage dead aren't proper defines, but we can ignore\n-            // values that come before them.\n-            PlaceContext::StorageLive |\n-            PlaceContext::StorageDead => {\n+        match categorize(context, self.mode) {\n+            Some(DefUse::Def) => {\n                 self.defs_uses.add_def(local);\n             }\n \n-            ///////////////////////////////////////////////////////////////////////////\n-            // REGULAR USES\n-            //\n-            // These are uses that occur *outside* of a drop. For the\n-            // purposes of NLL, these are special in that **all** the\n-            // lifetimes appearing in the variable must be live for each regular use.\n-\n-            PlaceContext::Projection(..) |\n-\n-            // Borrows only consider their local used at the point of the borrow.\n-            // This won't affect the results since we use this analysis for generators\n-            // and we only care about the result at suspension points. Borrows cannot\n-            // cross suspension points so this behavior is unproblematic.\n-            PlaceContext::Borrow { .. } |\n-\n-            PlaceContext::Inspect |\n-            PlaceContext::Copy |\n-            PlaceContext::Move |\n-            PlaceContext::Validate => {\n-                if self.mode.include_regular_use {\n-                    self.defs_uses.add_use(local);\n-                }\n+            Some(DefUse::Use) => {\n+                self.defs_uses.add_use(local);\n             }\n \n-            ///////////////////////////////////////////////////////////////////////////\n-            // DROP USES\n-            //\n-            // These are uses that occur in a DROP (a MIR drop, not a\n-            // call to `std::mem::drop()`). For the purposes of NLL,\n-            // uses in drop are special because `#[may_dangle]`\n-            // attributes can affect whether lifetimes must be live.\n-\n-            PlaceContext::Drop => {\n-                if self.mode.include_drops {\n-                    self.defs_uses.add_use(local);\n-                }\n-            }\n+            None => {}\n         }\n     }\n }\n@@ -358,30 +381,6 @@ fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> D\n     visitor.defs_uses\n }\n \n-trait MirVisitable<'tcx> {\n-    fn apply<V>(&self, location: Location, visitor: &mut V)\n-    where\n-        V: Visitor<'tcx>;\n-}\n-\n-impl<'tcx> MirVisitable<'tcx> for Statement<'tcx> {\n-    fn apply<V>(&self, location: Location, visitor: &mut V)\n-    where\n-        V: Visitor<'tcx>,\n-    {\n-        visitor.visit_statement(location.block, self, location)\n-    }\n-}\n-\n-impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n-    fn apply<V>(&self, location: Location, visitor: &mut V)\n-    where\n-        V: Visitor<'tcx>,\n-    {\n-        visitor.visit_terminator(location.block, self.as_ref().unwrap(), location)\n-    }\n-}\n-\n pub fn dump_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,"}, {"sha": "14296e78ddd1c6c2fa55777c4a2072f85beac2a9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 93, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -90,14 +90,15 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n+use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n-use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -225,43 +226,6 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: Option<hir::BodyId>,\n }\n \n-/// Information about the anonymous, abstract types whose values we\n-/// are inferring in this function (these are the `impl Trait` that\n-/// appear in the return type).\n-#[derive(Debug)]\n-struct AnonTypeDecl<'tcx> {\n-    /// The substitutions that we apply to the abstract that that this\n-    /// `impl Trait` desugars to. e.g., if:\n-    ///\n-    ///     fn foo<'a, 'b, T>() -> impl Trait<'a>\n-    ///\n-    /// winds up desugared to:\n-    ///\n-    ///     abstract type Foo<'x, T>: Trait<'x>\n-    ///     fn foo<'a, 'b, T>() -> Foo<'a, T>\n-    ///\n-    /// then `substs` would be `['a, T]`.\n-    substs: &'tcx Substs<'tcx>,\n-\n-    /// The type variable that represents the value of the abstract type\n-    /// that we require. In other words, after we compile this function,\n-    /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n-    /// where `?C` is the value of this type variable. =) It may\n-    /// naturally refer to the type and lifetime parameters in scope\n-    /// in this function, though ultimately it should only reference\n-    /// those that are arguments to `Foo` in the constraint above. (In\n-    /// other words, `?C` should not include `'b`, even though it's a\n-    /// lifetime parameter on `foo`.)\n-    concrete_ty: Ty<'tcx>,\n-\n-    /// A list of all required region bounds on the impl Trait type,\n-    /// e.g. `'a` and `'b` in `fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b`.\n-    required_region_bounds: Vec<ty::Region<'tcx>>,\n-}\n-\n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     type Target = InferCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -873,8 +837,6 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   &fn_sig);\n \n             let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, false).0;\n-            // Ensure anon_types have been instantiated prior to entering regionck\n-            fcx.instantiate_anon_types(&fn_sig.output());\n             fcx\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n@@ -1023,7 +985,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let ret_ty = fcx.instantiate_anon_types(&ret_ty);\n+    let ret_ty = fcx.instantiate_anon_types_from_return_value(fn_id, &ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1914,60 +1876,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Replace all anonymized types with fresh inference variables\n-    /// and record them for writeback.\n-    fn instantiate_anon_types<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n-        debug!(\"instantiate_anon_types(value={:?})\", value);\n-        value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n-            if let ty::TyAnon(def_id, substs) = ty.sty {\n-                debug!(\"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\", def_id, substs);\n+    /// Replace the anonymized types from the return value of the\n+    /// function with type variables and records the `AnonTypeMap` for\n+    /// later use during writeback. See\n+    /// `InferCtxt::instantiate_anon_types` for more details.\n+    fn instantiate_anon_types_from_return_value<T: TypeFoldable<'tcx>>(\n+        &self,\n+        fn_id: ast::NodeId,\n+        value: &T,\n+    ) -> T {\n+        let fn_def_id = self.tcx.hir.local_def_id(fn_id);\n+        debug!(\n+            \"instantiate_anon_types_from_return_value(fn_def_id={:?}, value={:?})\",\n+            fn_def_id,\n+            value\n+        );\n \n-                // Use the same type variable if the exact same TyAnon appears more\n-                // than once in the return type (e.g. if it's passed to a type alias).\n-                if let Some(anon_defn) = self.anon_types.borrow().get(&def_id) {\n-                    return anon_defn.concrete_ty;\n-                }\n-                let span = self.tcx.def_span(def_id);\n-                let ty_var = self.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-\n-                let predicates_of = self.tcx.predicates_of(def_id);\n-                let bounds = predicates_of.instantiate(self.tcx, substs);\n-                debug!(\"instantiate_anon_types: bounds={:?}\", bounds);\n-\n-                let required_region_bounds =\n-                    self.tcx.required_region_bounds(ty, bounds.predicates.clone());\n-                debug!(\"instantiate_anon_types: required_region_bounds={:?}\",\n-                       required_region_bounds);\n-\n-                self.anon_types.borrow_mut().insert(def_id, AnonTypeDecl {\n-                    substs,\n-                    concrete_ty: ty_var,\n-                    required_region_bounds,\n-                });\n-                debug!(\"instantiate_anon_types: ty_var={:?}\", ty_var);\n-\n-                for predicate in bounds.predicates {\n-                    // Change the predicate to refer to the type variable,\n-                    // which will be the concrete type, instead of the TyAnon.\n-                    // This also instantiates nested `impl Trait`.\n-                    let predicate = self.instantiate_anon_types(&predicate);\n-\n-                    // Require that the predicate holds for the concrete type.\n-                    let cause = traits::ObligationCause::new(span,\n-                                                             self.body_id,\n-                                                             traits::SizedReturnType);\n-\n-                    debug!(\"instantiate_anon_types: predicate={:?}\", predicate);\n-                    self.register_predicate(traits::Obligation::new(cause,\n-                                                                    self.param_env,\n-                                                                    predicate));\n-                }\n+        let (value, anon_type_map) = self.register_infer_ok_obligations(\n+            self.instantiate_anon_types(\n+                fn_def_id,\n+                self.body_id,\n+                self.param_env,\n+                value,\n+            )\n+        );\n \n-                ty_var\n-            } else {\n-                ty\n-            }\n-        }})\n+        let mut anon_types = self.anon_types.borrow_mut();\n+        for (ty, decl) in anon_type_map {\n+            let old_value = anon_types.insert(ty, decl);\n+            assert!(old_value.is_none(), \"instantiated twice: {:?}/{:?}\", ty, decl);\n+        }\n+\n+        value\n     }\n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T"}, {"sha": "64063ec5beda9b4febd656a9723387947ee08acb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 12, "deletions": 192, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -93,7 +93,6 @@ use rustc::ty::{self, Ty};\n use rustc::infer;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::ty::adjustment;\n-use rustc::ty::outlives::Component;\n \n use std::mem;\n use std::ops::Deref;\n@@ -125,7 +124,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n         }\n-        rcx.resolve_regions_and_report_errors();\n+        rcx.resolve_regions_and_report_errors_unless_nll();\n \n         assert!(self.tables.borrow().free_region_map.is_empty());\n         self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n@@ -174,7 +173,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n-        rcx.resolve_regions_and_report_errors();\n+        rcx.resolve_regions_and_report_errors_unless_nll();\n \n         // In this mode, we also copy the free-region-map into the\n         // tables of the enclosing fcx. In the other regionck modes\n@@ -344,7 +343,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                        body_hir_id,\n                                        call_site_region);\n \n-        self.constrain_anon_types();\n+        self.constrain_anon_types(\n+            &self.fcx.anon_types.borrow(),\n+            self.outlives_environment.free_region_map(),\n+        );\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -363,200 +365,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.body_id);\n     }\n \n-    /// Go through each of the existential `impl Trait` types that\n-    /// appear in the function signature. For example, if the current\n-    /// function is as follows:\n-    ///\n-    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n-    ///\n-    /// we would iterate through the `impl Bar<'a>` and the\n-    /// `impl Bar<'b>` here. Remember that each of them has\n-    /// their own \"abstract type\" definition created for them. As\n-    /// we iterate, we have a `def_id` that corresponds to this\n-    /// definition, and a set of substitutions `substs` that are\n-    /// being supplied to this abstract typed definition in the\n-    /// signature:\n-    ///\n-    ///     abstract type Foo1<'x>: Bar<'x>;\n-    ///     abstract type Foo2<'x>: Bar<'x>;\n-    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///                            ^^^^ ^^ substs\n-    ///                            def_id\n-    ///\n-    /// In addition, for each of the types we will have a type\n-    /// variable `concrete_ty` containing the concrete type that\n-    /// this function uses for `Foo1` and `Foo2`. That is,\n-    /// conceptually, there is a constraint like:\n-    ///\n-    ///     for<'a> (Foo1<'a> = C)\n-    ///\n-    /// where `C` is `concrete_ty`. For this equation to be satisfiable,\n-    /// the type `C` can only refer to two regions: `'static` and `'a`.\n-    ///\n-    /// The problem is that this type `C` may contain arbitrary\n-    /// region variables. In fact, it is fairly likely that it\n-    /// does!  Consider this possible definition of `foo`:\n-    ///\n-    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n-    ///         (&*x, &*y)\n-    ///     }\n-    ///\n-    /// Here, the values for the concrete types of the two impl\n-    /// traits will include inference variables:\n-    ///\n-    ///     &'0 i32\n-    ///     &'1 i32\n-    ///\n-    /// Ordinarily, the subtyping rules would ensure that these are\n-    /// sufficiently large.  But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default.  This\n-    /// is where this function comes into play. It adds extra\n-    /// constraints to ensure that all the regions which appear in the\n-    /// inferred type are regions that could validly appear.\n-    ///\n-    /// This is actually a bit of a tricky constraint in general. We\n-    /// want to say that each variable (e.g., `'0``) can only take on\n-    /// values that were supplied as arguments to the abstract type\n-    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n-    /// scope. We don't have a constraint quite of this kind in the current\n-    /// region checker.\n-    ///\n-    /// What we *do* have is the `<=` relation. So what we do is to\n-    /// find the LUB of all the arguments that appear in the substs:\n-    /// in this case, that would be `LUB('a) = 'a`, and then we apply\n-    /// that as a least bound to the variables (e.g., `'a <= '0`).\n-    ///\n-    /// In some cases this is pretty suboptimal. Consider this example:\n-    ///\n-    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n-    ///\n-    /// Here, the regions `'a` and `'b` appear in the substitutions,\n-    /// so we would generate `LUB('a, 'b)` as a kind of \"minimal upper\n-    /// bound\", but that turns out be `'static` -- which is clearly\n-    /// too strict!\n-    fn constrain_anon_types(&mut self) {\n-        debug!(\"constrain_anon_types()\");\n-\n-        for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n-            let concrete_ty = self.resolve_type(anon_defn.concrete_ty);\n-\n-            debug!(\"constrain_anon_types: def_id={:?}\", def_id);\n-            debug!(\"constrain_anon_types: anon_defn={:#?}\", anon_defn);\n-            debug!(\"constrain_anon_types: concrete_ty={:?}\", concrete_ty);\n-\n-            let abstract_type_generics = self.tcx.generics_of(def_id);\n-\n-            let span = self.tcx.def_span(def_id);\n-\n-            // If there are required region bounds, we can just skip\n-            // ahead.  There will already be a registered region\n-            // obligation related `concrete_ty` to those regions.\n-            if anon_defn.required_region_bounds.len() != 0 {\n-                continue;\n-            }\n-\n-            // There were no `required_region_bounds`,\n-            // so we have to search for a `least_region`.\n-            // Go through all the regions used as arguments to the\n-            // abstract type. These are the parameters to the abstract\n-            // type; so in our example above, `substs` would contain\n-            // `['a]` for the first impl trait and `'b` for the\n-            // second.\n-            let mut least_region = None;\n-            for region_def in &abstract_type_generics.regions {\n-                // Find the index of this region in the list of substitutions.\n-                let index = region_def.index as usize;\n-\n-                // Get the value supplied for this region from the substs.\n-                let subst_arg = anon_defn.substs[index].as_region().unwrap();\n-\n-                // Compute the least upper bound of it with the other regions.\n-                debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n-                debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n-                match least_region {\n-                    None => least_region = Some(subst_arg),\n-                    Some(lr) => {\n-                        if self.outlives_environment\n-                               .free_region_map()\n-                               .sub_free_regions(lr, subst_arg) {\n-                            // keep the current least region\n-                        } else if self.outlives_environment\n-                                      .free_region_map()\n-                                      .sub_free_regions(subst_arg, lr) {\n-                            // switch to `subst_arg`\n-                            least_region = Some(subst_arg);\n-                        } else {\n-                            // There are two regions (`lr` and\n-                            // `subst_arg`) which are not relatable. We can't\n-                            // find a best choice.\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n-                                .span_label(span,\n-                                            format!(\"neither `{}` nor `{}` outlives the other\",\n-                                                    lr, subst_arg))\n-                                .emit();\n-\n-                            least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n-            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n-\n-            // Require that the type `concrete_ty` outlives\n-            // `least_region`, modulo any type parameters that appear\n-            // in the type, which we ignore. This is because impl\n-            // trait values are assumed to capture all the in-scope\n-            // type parameters. This little loop here just invokes\n-            // `outlives` repeatedly, draining all the nested\n-            // obligations that result.\n-            let mut types = vec![concrete_ty];\n-            let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n-            while let Some(ty) = types.pop() {\n-                let mut components = self.tcx.outlives_components(ty);\n-                while let Some(component) = components.pop() {\n-                    match component {\n-                        Component::Region(r) => {\n-                            bound_region(r);\n-                        }\n-\n-                        Component::Param(_) => {\n-                            // ignore type parameters like `T`, they are captured\n-                            // implicitly by the `impl Trait`\n-                        }\n-\n-                        Component::UnresolvedInferenceVariable(_) => {\n-                            // we should get an error that more type\n-                            // annotations are needed in this case\n-                            self.tcx.sess.delay_span_bug(span, \"unresolved inf var in anon\");\n-                        }\n-\n-                        Component::Projection(ty::ProjectionTy { substs, item_def_id: _ }) => {\n-                            for r in substs.regions() {\n-                                bound_region(r);\n-                            }\n-                            types.extend(substs.types());\n-                        }\n-\n-                        Component::EscapingProjection(more_components) => {\n-                            components.extend(more_components);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,\n                                                    &self.outlives_environment);\n     }\n \n+    fn resolve_regions_and_report_errors_unless_nll(&self) {\n+        self.fcx.resolve_regions_and_report_errors_unless_nll(self.subject_def_id,\n+                                                              &self.region_scope_tree,\n+                                                              &self.outlives_environment);\n+    }\n+\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, id, span, _| {"}, {"sha": "29dc983ab560b9c09066f3c2bcf570013fba72d9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 123, "deletions": 131, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,12 +15,11 @@\n use check::FnCtxt;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::infer::{InferCtxt};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::infer::InferCtxt;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::{TypeFolder, TypeFoldable};\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::util::nodemap::{DefIdSet, FxHashMap};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n@@ -30,8 +29,7 @@ use std::rc::Rc;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body)\n-                                     -> &'gcx ty::TypeckTables<'gcx> {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -48,14 +46,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n \n-        let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n-                                              Rc::new(DefIdSet()));\n-        debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n+        let used_trait_imports = mem::replace(\n+            &mut self.tables.borrow_mut().used_trait_imports,\n+            Rc::new(DefIdSet()),\n+        );\n+        debug!(\n+            \"used_trait_imports({:?}) = {:?}\",\n+            item_def_id,\n+            used_trait_imports\n+        );\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n         wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n \n-        debug!(\"writeback: tables for {:?} are {:#?}\", item_def_id, wbcx.tables);\n+        debug!(\n+            \"writeback: tables for {:?} are {:#?}\",\n+            item_def_id,\n+            wbcx.tables\n+        );\n \n         self.tcx.alloc_tables(wbcx.tables)\n     }\n@@ -69,7 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+struct WritebackCx<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n \n     tables: ty::TypeckTables<'gcx>,\n@@ -78,9 +86,10 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n-        -> WritebackCx<'cx, 'gcx, 'tcx>\n-    {\n+    fn new(\n+        fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+        body: &'gcx hir::Body,\n+    ) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n \n         WritebackCx {\n@@ -95,7 +104,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n+        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n         assert!(!ty.needs_infer());\n         self.tables.node_types_mut().insert(hir_id, ty);\n     }\n@@ -106,8 +115,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref inner) |\n-            hir::ExprUnary(hir::UnNot, ref inner)  => {\n+            hir::ExprUnary(hir::UnNeg, ref inner) | hir::ExprUnary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -117,8 +125,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n-            hir::ExprBinary(ref op, ref lhs, ref rhs) |\n-            hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            hir::ExprBinary(ref op, ref lhs, ref rhs)\n+            | hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n@@ -137,15 +145,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                 adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n                                 adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n-                        },\n+                        }\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n-                        },\n-                        _ => {},\n+                            tables\n+                                .adjustments_mut()\n+                                .get_mut(lhs.hir_id)\n+                                .map(|a| a.pop());\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }\n-            _ => {},\n+            _ => {}\n         }\n     }\n }\n@@ -189,11 +200,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n                 let bm = *self.fcx\n-                              .tables\n-                              .borrow()\n-                              .pat_binding_modes()\n-                              .get(p.hir_id)\n-                              .expect(\"missing binding mode\");\n+                    .tables\n+                    .borrow()\n+                    .pat_binding_modes()\n+                    .get(p.hir_id)\n+                    .expect(\"missing binding mode\");\n                 self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n             _ => {}\n@@ -228,14 +239,20 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     let r = upvar_borrow.region;\n                     let r = self.resolve(&r, &upvar_id.var_id);\n-                    ty::UpvarCapture::ByRef(\n-                        ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: upvar_borrow.kind,\n+                        region: r,\n+                    })\n                 }\n             };\n-            debug!(\"Upvar capture for {:?} resolved to {:?}\",\n-                   upvar_id,\n-                   new_upvar_capture);\n-            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n+            debug!(\n+                \"Upvar capture for {:?} resolved to {:?}\",\n+                upvar_id,\n+                new_upvar_capture\n+            );\n+            self.tables\n+                .upvar_capture_map\n+                .insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -249,7 +266,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 owner: common_local_id_root.index,\n                 local_id: id,\n             };\n-            self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n+            self.tables\n+                .closure_kind_origins_mut()\n+                .insert(hir_id, origin);\n         }\n     }\n \n@@ -270,7 +289,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n+        let free_region_map = self.tcx()\n+            .lift_to_global(&self.fcx.tables.borrow().free_region_map);\n         let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n         self.tables.free_region_map = free_region_map;\n     }\n@@ -279,77 +299,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         let gcx = self.tcx().global_tcx();\n         for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n             let node_id = gcx.hir.as_local_node_id(def_id).unwrap();\n-            let inside_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n-\n-            // Use substs to build up a reverse map from regions\n-            // to their identity mappings.\n-            // This is necessary because of `impl Trait` lifetimes\n-            // are computed by replacing existing lifetimes with 'static\n-            // and remapping only those used in the `impl Trait` return type,\n-            // resulting in the parameters shifting.\n-            let id_substs = Substs::identity_for_item(gcx, def_id);\n-            let map: FxHashMap<Kind<'tcx>, Kind<'gcx>> =\n-                anon_defn.substs\n-                         .iter()\n-                         .enumerate()\n-                         .map(|(index, subst)| (*subst, id_substs[index]))\n-                         .collect();\n-\n-            // Convert the type from the function into a type valid outside\n-            // the function, by replacing invalid regions with 'static,\n-            // after producing an error for each of them.\n-            let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n-                match *r {\n-                    // 'static and early-bound regions are valid.\n-                    ty::ReStatic |\n-                    ty::ReEmpty => r,\n-\n-                    // All other regions, we map them appropriately to their adjusted\n-                    // indices, erroring if we find any lifetimes that were not mapped\n-                    // into the new set.\n-                    _ => if let Some(r1) =\n-                            map.get(&Kind::from(r)).and_then(|k| k.as_region()) { r1 } else\n-                        {\n-                            // No mapping was found. This means that\n-                            // it is either a disallowed lifetime,\n-                            // which will be caught by regionck, or it\n-                            // is a region in a non-upvar closure\n-                            // generic, which is explicitly\n-                            // allowed. If that surprises you, read\n-                            // on.\n-                            //\n-                            // The case of closure is a somewhat\n-                            // subtle (read: hacky) consideration. The\n-                            // problem is that our closure types\n-                            // currently include all the lifetime\n-                            // parameters declared on the enclosing\n-                            // function, even if they are unused by\n-                            // the closure itself. We can't readily\n-                            // filter them out, so here we replace\n-                            // those values with `'empty`. This can't\n-                            // really make a difference to the rest of\n-                            // the compiler; those regions are ignored\n-                            // for the outlives relation, and hence\n-                            // don't affect trait selection or auto\n-                            // traits, and they are erased during\n-                            // trans.\n-                            gcx.types.re_empty\n-                        },\n-                }\n-            });\n-\n+            let instantiated_ty = self.resolve(&anon_defn.concrete_ty, &node_id);\n+            let definition_ty = self.fcx.infer_anon_definition_from_instantiation(\n+                def_id,\n+                anon_defn,\n+                instantiated_ty,\n+            );\n             let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-            self.tables.node_types_mut().insert(hir_id, outside_ty);\n+            self.tables.node_types_mut().insert(hir_id, definition_ty);\n         }\n     }\n \n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n         if let Some(def) = self.fcx\n-                               .tables\n-                               .borrow_mut()\n-                               .type_dependent_defs_mut()\n-                               .remove(hir_id) {\n+            .tables\n+            .borrow_mut()\n+            .type_dependent_defs_mut()\n+            .remove(hir_id)\n+        {\n             self.tables.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n@@ -373,38 +341,50 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx\n-                             .tables\n-                             .borrow_mut()\n-                             .adjustments_mut()\n-                             .remove(hir_id);\n+            .tables\n+            .borrow_mut()\n+            .adjustments_mut()\n+            .remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"No adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n+                debug!(\n+                    \"Adjustments for node {:?}: {:?}\",\n+                    hir_id,\n+                    resolved_adjustment\n+                );\n+                self.tables\n+                    .adjustments_mut()\n+                    .insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_pat_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n         let adjustment = self.fcx\n-                             .tables\n-                             .borrow_mut()\n-                             .pat_adjustments_mut()\n-                             .remove(hir_id);\n+            .tables\n+            .borrow_mut()\n+            .pat_adjustments_mut()\n+            .remove(hir_id);\n         match adjustment {\n             None => {\n                 debug!(\"No pat_adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"pat_adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n-                self.tables.pat_adjustments_mut().insert(hir_id, resolved_adjustment);\n+                debug!(\n+                    \"pat_adjustments for node {:?}: {:?}\",\n+                    hir_id,\n+                    resolved_adjustment\n+                );\n+                self.tables\n+                    .pat_adjustments_mut()\n+                    .insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n@@ -420,7 +400,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 local_id,\n             };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n-            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n+            self.tables\n+                .liberated_fn_sigs_mut()\n+                .insert(hir_id, fn_sig.clone());\n         }\n     }\n \n@@ -440,15 +422,18 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn resolve<T>(&self, x: &T, span: &Locatable) -> T::Lifted\n-        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    where\n+        T: TypeFoldable<'tcx> + ty::Lift<'gcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n         if let Some(lifted) = self.tcx().lift_to_global(&x) {\n             lifted\n         } else {\n-            span_bug!(span.to_span(&self.fcx.tcx),\n-                      \"writeback: `{:?}` missing from the global type context\",\n-                      x);\n+            span_bug!(\n+                span.to_span(&self.fcx.tcx),\n+                \"writeback: `{:?}` missing from the global type context\",\n+                x\n+            );\n         }\n     }\n }\n@@ -458,11 +443,15 @@ trait Locatable {\n }\n \n impl Locatable for Span {\n-    fn to_span(&self, _: &TyCtxt) -> Span { *self }\n+    fn to_span(&self, _: &TyCtxt) -> Span {\n+        *self\n+    }\n }\n \n impl Locatable for ast::NodeId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        tcx.hir.span(*self)\n+    }\n }\n \n impl Locatable for DefIndex {\n@@ -483,17 +472,19 @@ impl Locatable for hir::HirId {\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+struct Resolver<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: &'cx Locatable,\n     body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, span: &'cx Locatable, body: &'gcx hir::Body)\n-        -> Resolver<'cx, 'gcx, 'tcx>\n-    {\n+    fn new(\n+        fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+        span: &'cx Locatable,\n+        body: &'gcx hir::Body,\n+    ) -> Resolver<'cx, 'gcx, 'tcx> {\n         Resolver {\n             tcx: fcx.tcx,\n             infcx: fcx,\n@@ -504,7 +495,8 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n \n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n-            self.infcx.need_type_info(Some(self.body.id()), self.span.to_span(&self.tcx), t);\n+            self.infcx\n+                .need_type_info(Some(self.body.id()), self.span.to_span(&self.tcx), t);\n         }\n     }\n }\n@@ -518,8 +510,10 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(_) => {\n-                debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n-                       t);\n+                debug!(\n+                    \"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n+                    t\n+                );\n                 self.report_error(t);\n                 self.tcx().types.err\n             }\n@@ -531,9 +525,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n-            Err(_) => {\n-                self.tcx.types.re_static\n-            }\n+            Err(_) => self.tcx.types.re_static,\n         }\n     }\n }"}, {"sha": "e8d669838d3fbcbd95c343969bea35c131d6ffab", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -81,6 +81,7 @@ This API is completely unstable and subject to change.\n #![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(quote)]\n+#![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n "}, {"sha": "379881302eef70918b4b964faf8c430858c38957", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -186,6 +186,9 @@ declare_features! (\n     // Allows the use of rustc_* attributes; RFC 572\n     (active, rustc_attrs, \"1.0.0\", Some(29642)),\n \n+    // Allows the use of non lexical lifetimes; RFC 2094\n+    (active, nll, \"1.0.0\", Some(44928)),\n+\n     // Allows the use of #[allow_internal_unstable]. This is an\n     // attribute on macro_rules! and can't use the attribute handling\n     // below (it has to be checked before expansion possibly makes\n@@ -798,6 +801,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                           libcore functions that are inlined \\\n                                                           across crates and will never be stable\",\n                                                           cfg_fn!(rustc_attrs))),\n+\n+    // RFC #2094\n+    (\"nll\", Whitelisted, Gated(Stability::Unstable,\n+                               \"nll\",\n+                               \"Non lexical lifetimes\",\n+                               cfg_fn!(nll))),\n     (\"compiler_builtins\", Whitelisted, Gated(Stability::Unstable,\n                                              \"compiler_builtins\",\n                                              \"the `#[compiler_builtins]` attribute is used to \\"}, {"sha": "f6ad2820d17ce4d6e651eb1a88198e277767a61e", "filename": "src/test/compile-fail/mir_check_cast_reify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -45,7 +45,7 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `'_#1r` does not outlive free region `'static`\n+    //~| ERROR free region `'a` does not outlive free region `'static`\n     f(x)\n }\n "}, {"sha": "c9b378dacd540cb7bfd283efbe2d895a1f5f780c", "filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -17,7 +17,7 @@ fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `'_#1r` does not outlive free region `'static`\n+    //~| ERROR free region `'a` does not outlive free region `'static`\n     unsafe { g(input) }\n }\n "}, {"sha": "1df56793f73bdab5d5c30c07d6b40f56e4253639", "filename": "src/test/compile-fail/mir_check_cast_unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -16,7 +16,7 @@\n use std::fmt::Debug;\n \n fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n-    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n+    //~^ ERROR free region `'a` does not outlive free region `'static`\n     x\n     //~^ WARNING not reporting region error due to -Znll\n }"}, {"sha": "ecea8756903aeb9f694ef3830f3a1fa7ab20e2ef", "filename": "src/test/compile-fail/nll/where_clauses_in_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -21,7 +21,7 @@ where\n \n fn bar<'a, 'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n     foo(x, y)\n-    //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+    //~^ ERROR lifetime mismatch [E0623]\n     //~| WARNING not reporting region error due to -Znll\n }\n "}, {"sha": "f1a6dc48e13b80ed809652e7cb18c8042626dfcb", "filename": "src/test/compile-fail/nll/where_clauses_in_structs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -21,7 +21,7 @@ struct Foo<'a: 'b, 'b> {\n \n fn bar<'a, 'b>(x: Cell<&'a u32>, y: Cell<&'b u32>) {\n     Foo { x, y };\n-    //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+    //~^ ERROR lifetime mismatch [E0623]\n     //~| WARNING not reporting region error due to -Znll\n }\n "}, {"sha": "a217cc9ebfa527a70f768f5ca954cf0c16177065", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -24,10 +24,10 @@ fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n fn error(u: &(), v: &()) {\n     static_id(&u); //[ll]~ ERROR cannot infer an appropriate lifetime\n     //[nll]~^ WARNING not reporting region error due to -Znll\n-    //[nll]~| ERROR free region `'_#1r` does not outlive free region `'static`\n+    //[nll]~| ERROR free region `` does not outlive free region `'static`\n     static_id_indirect(&v); //[ll]~ ERROR cannot infer an appropriate lifetime\n     //[nll]~^ WARNING not reporting region error due to -Znll\n-    //[nll]~| ERROR free region `'_#2r` does not outlive free region `'static`\n+    //[nll]~| ERROR free region `` does not outlive free region `'static`\n }\n \n fn main() {}"}, {"sha": "9106f1f0ba69c87d45c1fa0df87b4ea15405a709", "filename": "src/test/compile-fail/regions-struct-not-wf.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-struct-not-wf.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,11 +10,15 @@\n \n // Various examples of structs whose fields are not well-formed.\n \n+// revisions:lexical nll\n+\n #![allow(dead_code)]\n+#![cfg_attr(nll, feature(nll))]\n \n struct Ref<'a, T> {\n     field: &'a T\n-        //~^ ERROR the parameter type `T` may not live long enough\n+        //[lexical]~^ ERROR the parameter type `T` may not live long enough\n+        //[nll]~^^ ERROR the parameter type `T` may not live long enough\n }\n \n struct RefOk<'a, T:'a> {\n@@ -23,12 +27,14 @@ struct RefOk<'a, T:'a> {\n \n struct RefIndirect<'a, T> {\n     field: RefOk<'a, T>\n-        //~^ ERROR the parameter type `T` may not live long enough\n+        //[lexical]~^ ERROR the parameter type `T` may not live long enough\n+        //[nll]~^^ ERROR the parameter type `T` may not live long enough\n }\n \n struct DoubleRef<'a, 'b, T> {\n     field: &'a &'b T\n-        //~^ ERROR reference has a longer lifetime than the data it references\n+        //[lexical]~^ ERROR reference has a longer lifetime than the data it references\n+        //[nll]~^^ ERROR reference has a longer lifetime than the data it references\n }\n \n fn main() { }"}, {"sha": "058a57fe612cff17c815c36bc1aa832339787130", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb64b86ce44cc1828dd176a8b981e37ea08fc38/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=7eb64b86ce44cc1828dd176a8b981e37ea08fc38", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Basic test for liveness constraints: the region (`R1`) that appears\n-// in the type of `p` includes the points after `&v[0]` up to (but not\n-// including) the call to `use_x`. The `else` branch is not included.\n-\n-// ignore-tidy-linelength\n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: usize) -> bool { true }\n-\n-fn main() {\n-    let mut v = [1, 2, 3];\n-    let p: Wrap<& /* R1 */ usize> = Wrap { value: &v[0] };\n-    if true {\n-        use_x(*p.value);\n-    } else {\n-        use_x(22);\n-    }\n-\n-    // `p` will get dropped here. Because the `#[may_dangle]`\n-    // attribute is not present on `Wrap`, we must conservatively\n-    // assume that the dtor may access the `value` field, and hence we\n-    // must consider R1 to be live.\n-}\n-\n-struct Wrap<T> {\n-    value: T\n-}\n-\n-// Look ma, no `#[may_dangle]` attribute here.\n-impl<T> Drop for Wrap<T> {\n-    fn drop(&mut self) { }\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#6r    | {bb2[3..=5], bb3[0..=2], bb4[0], bb5[0..=2], bb6[0], bb7[0..=1], bb8[0]}\n-// ...\n-// let _2: Wrap<&'_#6r usize>;\n-// END rustc.main.nll.0.mir"}, {"sha": "35a5422040a1710df57ff81d165e8a6605e168b1", "filename": "src/test/run-pass/borrowck/two-phase-control-flow-split-before-activation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-control-flow-split-before-activation.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,7 +10,8 @@\n \n // revisions: lxl nll\n //[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+#![cfg_attr(nll, feature(nll))]\n \n fn main() {\n     let mut a = 0;"}, {"sha": "8d035bafab78d6df6bf4184f0a0b213df76782fc", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: normal nll\n+//[nll] compile-flags: -Znll -Zborrowck=mir\n+\n #![feature(conservative_impl_trait,\n            universal_impl_trait,\n            fn_traits,"}, {"sha": "13ef907d8d008d92248ae0aa589a22f07ea8bd35", "filename": "src/test/run-pass/nll/get_default.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnll%2Fget_default.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+use std::collections::HashMap;\n+\n+fn get_default(map: &mut HashMap<usize, String>, key: usize) -> &mut String {\n+    match map.get_mut(&key) {\n+        Some(value) => value,\n+        None => {\n+            map.insert(key, \"\".to_string());\n+            map.get_mut(&key).unwrap()\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let map = &mut HashMap::new();\n+    map.insert(22, format!(\"Hello, world\"));\n+    map.insert(44, format!(\"Goodbye, world\"));\n+    assert_eq!(&*get_default(map, 22), \"Hello, world\");\n+    assert_eq!(&*get_default(map, 66), \"\");\n+}"}, {"sha": "a3a484402cc1401c5044e40ab55d7dfa64b088b0", "filename": "src/test/run-pass/nll/process_or_insert_default.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Fprocess_or_insert_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Fprocess_or_insert_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnll%2Fprocess_or_insert_default.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+use std::collections::HashMap;\n+\n+fn process_or_insert_default(map: &mut HashMap<usize, String>, key: usize) {\n+    match map.get_mut(&key) {\n+        Some(value) => {\n+            process(value);\n+        }\n+        None => {\n+            map.insert(key, \"\".to_string());\n+        }\n+    }\n+}\n+\n+fn process(x: &str) {\n+    assert_eq!(x, \"Hello, world\");\n+}\n+\n+fn main() {\n+    let map = &mut HashMap::new();\n+    map.insert(22, format!(\"Hello, world\"));\n+    map.insert(44, format!(\"Goodbye, world\"));\n+    process_or_insert_default(map, 22);\n+    process_or_insert_default(map, 66);\n+    assert_eq!(map[&66], \"\");\n+}"}, {"sha": "2b746fac4d42610121168999c01e38a199b5f3e1", "filename": "src/test/run-pass/nll/rc-loop.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Frc-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Frun-pass%2Fnll%2Frc-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnll%2Frc-loop.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A test for something that NLL enables. It sometimes happens that\n+// the `while let` pattern makes some borrows from a variable (in this\n+// case, `x`) that you need in order to compute the next value for\n+// `x`.  The lexical checker makes this very painful. The NLL checker\n+// does not.\n+\n+#![feature(match_default_bindings)]\n+#![feature(nll)]\n+\n+use std::rc::Rc;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum Foo {\n+    Base(usize),\n+    Next(Rc<Foo>),\n+}\n+\n+fn find_base(mut x: Rc<Foo>) -> Rc<Foo> {\n+    while let Foo::Next(n) = &*x {\n+        x = n.clone();\n+    }\n+    x\n+}\n+\n+fn main() {\n+    let chain = Rc::new(Foo::Next(Rc::new(Foo::Base(44))));\n+    let base = find_base(chain);\n+    assert_eq!(&*base, &Foo::Base(44));\n+}\n+"}, {"sha": "f34a9cddf98e4b70c111e54fadadcc6ba6439085", "filename": "src/test/ui/feature-gate-nll.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Ffeature-gate-nll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Ffeature-gate-nll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-nll.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+fn main() {\n+    let mut x = 33;\n+\n+    let p = &x;\n+    x = 22; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "4135462305a893930dfecd903e0d911c7b38b3ee", "filename": "src/test/ui/feature-gate-nll.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Ffeature-gate-nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Ffeature-gate-nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-nll.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,10 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/feature-gate-nll.rs:17:5\n+   |\n+16 |     let p = &x;\n+   |              - borrow of `x` occurs here\n+17 |     x = 22; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "74b086ab18a585415808241b16b8d3d9ab2dc4a5", "filename": "src/test/ui/nll/capture-ref-in-struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Znll-dump-cause\n \n // Test that a structure which tries to store a pointer to `y` into\n // `p` (indirectly) fails to compile.\n \n #![feature(rustc_attrs)]\n+#![feature(nll)]\n \n struct SomeStruct<'a, 'b: 'a> {\n     p: &'a mut &'b i32,"}, {"sha": "7e7487daa67a377d3647c22b32aab4d50f378e2b", "filename": "src/test/ui/nll/capture-ref-in-struct.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -1,11 +1,14 @@\n error[E0597]: `y` does not live long enough\n-  --> $DIR/capture-ref-in-struct.rs:32:16\n+  --> $DIR/capture-ref-in-struct.rs:33:16\n    |\n-32 |             y: &y,\n+33 |             y: &y,\n    |                ^^ borrowed value does not live long enough\n ...\n-37 |     }\n+38 |     }\n    |      - borrowed value only lives until here\n+39 | \n+40 |     deref(p);\n+   |           - borrow later used here\n    |\n    = note: borrowed value must be valid for lifetime '_#5r...\n "}, {"sha": "41c744fec6e762024430a75c82cc4ed51acc1534", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -34,7 +34,7 @@ fn test() {\n     {\n         let y = 22;\n         let mut closure = expect_sig(|p, y| *p = y);\n-        //~^ ERROR free region `'_#4r` does not outlive free region `'_#3r`\n+        //~^ ERROR does not outlive free region\n         //~| WARNING not reporting region error due to -Znll\n         closure(&mut p, &y);\n     }"}, {"sha": "3bd02f308c883414032ded73ddc542c6d55d1373", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 36 |         let mut closure = expect_sig(|p, y| *p = y);\n    |                                                  ^\n \n-error: free region `'_#4r` does not outlive free region `'_#3r`\n+error: free region `ReFree(DefId(0/1:9 ~ escape_argument_callee[317d]::test[0]::{{closure}}[0]), BrAnon(3))` does not outlive free region `ReFree(DefId(0/1:9 ~ escape_argument_callee[317d]::test[0]::{{closure}}[0]), BrAnon(2))`\n   --> $DIR/escape-argument-callee.rs:36:45\n    |\n 36 |         let mut closure = expect_sig(|p, y| *p = y);"}, {"sha": "17fadf0a2978b4f235cb5ab0264de530e1183400", "filename": "src/test/ui/nll/closure-requirements/escape-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -22,7 +22,7 @@\n // basically checking that the MIR type checker correctly enforces the\n // closure signature.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "09d5617b08ef564f20b134e4f44dd553862d7878", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -31,6 +31,9 @@ error[E0597]: `y` does not live long enough\n 38 |         //~^ ERROR `y` does not live long enough [E0597]\n 39 |     }\n    |      - borrowed value only lives until here\n+40 | \n+41 |     deref(p);\n+   |           - borrow later used here\n    |\n    = note: borrowed value must be valid for lifetime '_#6r...\n "}, {"sha": "984c9fe7c34bd3b92a9c28d852364503b5fc325e", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,7 +15,7 @@\n //\n // except that the closure does so via a second closure.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "430fb711c635d8c7911e00757f67925ab87c14ea", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -58,6 +58,9 @@ error[E0597]: `y` does not live long enough\n ...\n 36 |       }\n    |        - borrowed value only lives until here\n+37 | \n+38 |       deref(p);\n+   |             - borrow later used here\n    |\n    = note: borrowed value must be valid for lifetime '_#4r...\n "}, {"sha": "499ebd659556ce57663b3b9322e984ac563bca44", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -19,7 +19,7 @@\n // `'b`.  This relationship is propagated to the closure creator,\n // which reports an error.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "090bacbc17d076a047baad94e434580ff575cba5", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -35,6 +35,9 @@ error[E0597]: `y` does not live long enough\n ...\n 36 |     }\n    |      - borrowed value only lives until here\n+37 | \n+38 |     deref(p);\n+   |           - borrow later used here\n    |\n    = note: borrowed value must be valid for lifetime '_#4r...\n "}, {"sha": "30a6dfc5b3edd05bf737f99c8b22c69a633f4427", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -54,7 +54,7 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n             // Only works if 'x: 'y:\n             let p = x.get();\n             //~^ WARN not reporting region error due to -Znll\n-            //~| ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+            //~| ERROR does not outlive free region\n             demand_y(x, y, p)\n         },\n     );"}, {"sha": "7e48c0fc5842a14d61e19fc451f91d945256b083", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 55 |             let p = x.get();\n    |                     ^^^^^^^\n \n-error: free region `'_#5r` does not outlive free region `'_#6r`\n+error: free region `ReFree(DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]), BrAnon(1))` does not outlive free region `ReFree(DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:55:17\n    |\n 55 |             let p = x.get();\n@@ -17,7 +17,7 @@ note: No external requirements\n 54 | |             // Only works if 'x: 'y:\n 55 | |             let p = x.get();\n 56 | |             //~^ WARN not reporting region error due to -Znll\n-57 | |             //~| ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+57 | |             //~| ERROR does not outlive free region\n 58 | |             demand_y(x, y, p)\n 59 | |         },\n    | |_________^"}, {"sha": "91128035f3d95162d81615b188c68c3ecde35611", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -51,7 +51,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-        //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+        //~^ ERROR lifetime mismatch\n \n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll"}, {"sha": "f9a6999243a9c14ec89868a9df6400689bf53783", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n 53 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-54 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+54 | |         //~^ ERROR lifetime mismatch\n 55 | |\n 56 | |         // Only works if 'x: 'y:\n 57 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n@@ -23,18 +23,22 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n-error: free region `'_#1r` does not outlive free region `'_#2r`\n+error[E0623]: lifetime mismatch\n   --> $DIR/propagate-approximated-ref.rs:53:29\n    |\n+52 | fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                                -------                -------\n+   |                                |\n+   |                                these two types are declared with different lifetimes...\n 53 |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                             ^^^^^^^\n+   |                             ^^^^^^^ ...but data from `cell_a` flows into `cell_b` here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-ref.rs:52:1\n    |\n 52 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n 53 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-54 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+54 | |         //~^ ERROR lifetime mismatch\n 55 | |\n ...  |\n 58 | |     });"}, {"sha": "f210346a82a675b1f9a5062cbd063f320a56306d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -31,7 +31,7 @@ fn case1() {\n     foo(cell, |cell_a, cell_x| {\n         //~^ WARNING not reporting region error due to -Znll\n         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-        //~^ ERROR free region `'_#2r` does not outlive free region `'_#1r`\n+        //~^ ERROR does not outlive free region\n     })\n }\n "}, {"sha": "290377996c942a593bf17d08f3de7d50f54cae86", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 31 |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n-error: free region `'_#2r` does not outlive free region `'_#1r`\n+error: free region `ReFree(DefId(0/1:12 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case1[0]::{{closure}}[0]), BrAnon(1))` does not outlive free region `'_#1r`\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n    |\n 33 |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n@@ -17,7 +17,7 @@ note: No external requirements\n    |  _______________^\n 32 | |         //~^ WARNING not reporting region error due to -Znll\n 33 | |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-34 | |         //~^ ERROR free region `'_#2r` does not outlive free region `'_#1r`\n+34 | |         //~^ ERROR does not outlive free region\n 35 | |     })\n    | |_____^\n    |"}, {"sha": "c66472d5ce9b1ec1060843ca0532457e56e61e1c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -43,7 +43,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-        //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+        //~^ ERROR does not outlive free region\n \n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll"}, {"sha": "13aedc408cf06ed8ca7e9e8b7d0ef292eef379b9", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n 45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n-46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+46 | |         //~^ ERROR does not outlive free region\n 47 | |\n 48 | |         // Only works if 'x: 'y:\n 49 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n@@ -23,12 +23,12 @@ note: External requirements\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r\n \n-error: free region `'_#1r` does not outlive free region `ReStatic`\n+error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n    |\n 45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n-46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+46 | |         //~^ ERROR does not outlive free region\n 47 | |\n 48 | |         // Only works if 'x: 'y:\n 49 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n@@ -40,7 +40,7 @@ note: No external requirements\n    |\n 44 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n 45 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+46 | |         //~^ ERROR does not outlive free region\n 47 | |\n ...  |\n 50 | |     });"}, {"sha": "f4011a0e5335e8fdee25a809af6ef98ef133a545", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -46,7 +46,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-        //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+        //~^ ERROR does not outlive free region\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARNING not reporting region error due to -Znll"}, {"sha": "947ed650e6bcac055cc7496d60923841452df962", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n 48 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+49 | |         //~^ ERROR does not outlive free region\n 50 | |         // Only works if 'x: 'y:\n 51 | |         demand_y(x, y, x.get())\n 52 | |         //~^ WARNING not reporting region error due to -Znll\n@@ -23,12 +23,12 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#0r\n \n-error: free region `'_#1r` does not outlive free region `ReStatic`\n+error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n    |\n 48 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+49 | |         //~^ ERROR does not outlive free region\n 50 | |         // Only works if 'x: 'y:\n 51 | |         demand_y(x, y, x.get())\n 52 | |         //~^ WARNING not reporting region error due to -Znll\n@@ -40,7 +40,7 @@ note: No external requirements\n    |\n 47 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n 48 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+49 | |         //~^ ERROR does not outlive free region\n 50 | |         // Only works if 'x: 'y:\n ...  |\n 53 | |     });"}, {"sha": "d163f304ae5b17f2509448dd3f1404e8b2aec70c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -44,7 +44,7 @@ fn demand_y<'x, 'y>(_outlives1: Cell<&&'x u32>, _outlives2: Cell<&'y &u32>, _y:\n #[rustc_regions]\n fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-        //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+        //~^ ERROR lifetime mismatch\n \n         // Only works if 'x: 'y:\n         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll"}, {"sha": "64766296e65a55388b1fee1cab1e88743a2f955e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n 46 |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n    |  _____________________________________________^\n-47 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+47 | |         //~^ ERROR lifetime mismatch\n 48 | |\n 49 | |         // Only works if 'x: 'y:\n 50 | |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n@@ -23,18 +23,22 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n-error: free region `'_#1r` does not outlive free region `'_#2r`\n+error[E0623]: lifetime mismatch\n   --> $DIR/propagate-approximated-val.rs:46:29\n    |\n+45 | fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                              -------                -------\n+   |                              |\n+   |                              these two types are declared with different lifetimes...\n 46 |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-   |                             ^^^^^^\n+   |                             ^^^^^^ ...but data from `cell_a` flows into `cell_b` here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-val.rs:45:1\n    |\n 45 | / fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n 46 | |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-47 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+47 | |         //~^ ERROR lifetime mismatch\n 48 | |\n ...  |\n 51 | |     });"}, {"sha": "eb512a3b9b1fb13eded1a71570b5c7510a9b82ac", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -46,7 +46,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARN not reporting region error due to -Znll\n-        //~| ERROR free region `'_#6r` does not outlive free region `'_#4r`\n+        //~| ERROR does not outlive free region\n     });\n }\n "}, {"sha": "08dcfb042b5f4152f74284d22d27b24effbaeff3", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 47 |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: free region `'_#6r` does not outlive free region `'_#4r`\n+error: free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(4))` does not outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:18\n    |\n 47 |         demand_y(x, y, x.get())\n@@ -18,7 +18,7 @@ note: No external requirements\n 46 | |         // Only works if 'x: 'y:\n 47 | |         demand_y(x, y, x.get())\n 48 | |         //~^ WARN not reporting region error due to -Znll\n-49 | |         //~| ERROR free region `'_#6r` does not outlive free region `'_#4r`\n+49 | |         //~| ERROR does not outlive free region\n 50 | |     });\n    | |_____^\n    |"}, {"sha": "930742464297202f9abd7f651fa9189c11935d01", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -50,7 +50,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARN not reporting region error due to -Znll\n-        //~| ERROR free region `'_#5r` does not outlive free region `'_#7r`\n+        //~| ERROR does not outlive free region\n     });\n }\n "}, {"sha": "502f56502497046b3488d0558d562ab650c371df", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 51 |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: free region `'_#5r` does not outlive free region `'_#7r`\n+error: free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))` does not outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(4))`\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:18\n    |\n 51 |         demand_y(x, y, x.get())\n@@ -18,7 +18,7 @@ note: No external requirements\n 50 | |         // Only works if 'x: 'y:\n 51 | |         demand_y(x, y, x.get())\n 52 | |         //~^ WARN not reporting region error due to -Znll\n-53 | |         //~| ERROR free region `'_#5r` does not outlive free region `'_#7r`\n+53 | |         //~| ERROR does not outlive free region\n 54 | |     });\n    | |_____^\n    |"}, {"sha": "91796355752a5eb00af3da727479fae8bfbf5bf0", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -40,7 +40,7 @@ where\n     T: Trait<'a>,\n {\n     establish_relationships(value, |value| {\n-        //~^ ERROR `T` does not outlive\n+        //~^ ERROR the parameter type `T` may not live long enough\n \n         // This function call requires that\n         //"}, {"sha": "aefa160fcbc96d8a73d2038ef2cc62d0c60d5c94", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n 42 |       establish_relationships(value, |value| {\n    |  ____________________________________^\n-43 | |         //~^ ERROR `T` does not outlive\n+43 | |         //~^ ERROR the parameter type `T` may not live long enough\n 44 | |\n 45 | |         // This function call requires that\n ...  |\n@@ -26,18 +26,20 @@ note: External requirements\n    = note: number of external vids: 2\n    = note: where T: '_#1r\n \n-error: `T` does not outlive `'_#3r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/propagate-from-trait-match.rs:42:36\n    |\n 42 |       establish_relationships(value, |value| {\n    |  ____________________________________^\n-43 | |         //~^ ERROR `T` does not outlive\n+43 | |         //~^ ERROR the parameter type `T` may not live long enough\n 44 | |\n 45 | |         // This function call requires that\n ...  |\n 56 | |         //~^ WARNING not reporting region error due to -Znll\n 57 | |     });\n    | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/propagate-from-trait-match.rs:38:1"}, {"sha": "3f56dfe5af48dbe9cfd2cc9ecc3c08eeb3d24f4c", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -18,7 +18,7 @@\n fn foo(x: &u32) -> &'static u32 {\n     &*x\n         //~^ WARN not reporting region error due to -Znll\n-        //~| ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+        //~| ERROR does not outlive free region\n }\n \n fn main() { }"}, {"sha": "6648e38e7dea8c44f21f746feca5a2e298db305c", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 19 |     &*x\n    |     ^^^\n \n-error: free region `'_#1r` does not outlive free region `ReStatic`\n+error: free region `ReFree(DefId(0/0:3 ~ region_lbr_anon_does_not_outlive_static[317d]::foo[0]), BrAnon(0))` does not outlive free region `ReStatic`\n   --> $DIR/region-lbr-anon-does-not-outlive-static.rs:19:5\n    |\n 19 |     &*x"}, {"sha": "a1be8e851851599161c10f5e79b868bede8f43d3", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -18,7 +18,7 @@\n fn foo<'a>(x: &'a u32) -> &'static u32 {\n     &*x\n         //~^ WARN not reporting region error due to -Znll\n-        //~| ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+        //~| ERROR does not outlive free region\n }\n \n fn main() { }"}, {"sha": "1edceba7b0916e4c14b8ae12600e0dec1429e47f", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 19 |     &*x\n    |     ^^^\n \n-error: free region `'_#1r` does not outlive free region `ReStatic`\n+error: free region `ReFree(DefId(0/0:3 ~ region_lbr_named_does_not_outlive_static[317d]::foo[0]), BrNamed(crate0:DefIndex(1:9), 'a))` does not outlive free region `ReStatic`\n   --> $DIR/region-lbr-named-does-not-outlive-static.rs:19:5\n    |\n 19 |     &*x"}, {"sha": "00b09e2ab21ada08e8600b54eb510271993ea1c1", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -18,7 +18,7 @@\n fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n     &*x\n         //~^ WARN not reporting region error due to -Znll\n-        //~| ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+        //~| ERROR lifetime mismatch\n }\n \n fn main() { }"}, {"sha": "efe0b73f195a905c8aacc6f3ea76c15d97811807", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to -Znll\n 19 |     &*x\n    |     ^^^\n \n-error: free region `'_#1r` does not outlive free region `'_#2r`\n+error[E0623]: lifetime mismatch\n   --> $DIR/region-lbr1-does-not-outlive-ebr2.rs:19:5\n    |\n+18 | fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n+   |                   -------                 -------\n+   |                   |\n+   |                   this parameter and the return type are declared with different lifetimes...\n 19 |     &*x\n-   |     ^^^\n+   |     ^^^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "754df4f2c5db624b95f6dfdab3b49da248635869", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -20,7 +20,7 @@\n fn test() {\n     expect_sig(|a, b| b); // ought to return `a`\n     //~^ WARN not reporting region error due to -Znll\n-    //~| ERROR free region `'_#3r` does not outlive free region `'_#2r`\n+    //~| ERROR does not outlive free region\n }\n \n fn expect_sig<F>(f: F) -> F"}, {"sha": "58a26e61e57671ccf12afd159afce367ff81355f", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,7 +4,7 @@ warning: not reporting region error due to -Znll\n 21 |     expect_sig(|a, b| b); // ought to return `a`\n    |                       ^\n \n-error: free region `'_#3r` does not outlive free region `'_#2r`\n+error: free region `ReFree(DefId(0/1:9 ~ return_wrong_bound_region[317d]::test[0]::{{closure}}[0]), BrAnon(2))` does not outlive free region `ReFree(DefId(0/1:9 ~ return_wrong_bound_region[317d]::test[0]::{{closure}}[0]), BrAnon(1))`\n   --> $DIR/return-wrong-bound-region.rs:21:23\n    |\n 21 |     expect_sig(|a, b| b); // ought to return `a`\n@@ -27,7 +27,7 @@ note: No external requirements\n 20 | / fn test() {\n 21 | |     expect_sig(|a, b| b); // ought to return `a`\n 22 | |     //~^ WARN not reporting region error due to -Znll\n-23 | |     //~| ERROR free region `'_#3r` does not outlive free region `'_#2r`\n+23 | |     //~| ERROR does not outlive free region\n 24 | | }\n    | |_^\n    |"}, {"sha": "ced06e5ea0504bd3767f5a680daaecd65f9053c2", "filename": "src/test/ui/nll/constant.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fconstant.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that MIR borrowck and NLL analysis can handle constants of\n+// arbitrary types without ICEs.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+const HI: &str = \"hi\";\n+\n+fn main() {\n+    assert_eq!(HI, \"hi\");\n+}"}, {"sha": "2780b34746378ac33b4736c8a856aad4bfe97621", "filename": "src/test/ui/nll/drop-may-dangle.rs", "status": "renamed", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -12,8 +12,8 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Znll -Zborrowck=mir\n+// must-compile-successfully\n \n #![allow(warnings)]\n #![feature(dropck_eyepatch)]\n@@ -23,28 +23,24 @@ fn use_x(_: usize) -> bool { true }\n \n fn main() {\n     let mut v = [1, 2, 3];\n-    let p: Wrap<& /* R4 */ usize> = Wrap { value: &v[0] };\n+    let p: WrapMayDangle<& /* R4 */ usize> = WrapMayDangle { value: &v[0] };\n     if true {\n+        // `p` will get dropped at end of this block. However, because of\n+        // the `#[may_dangle]` attribute, we do not need to consider R4\n+        // live after this point.\n         use_x(*p.value);\n     } else {\n+        v[0] += 1;\n         use_x(22);\n     }\n \n-    // `p` will get dropped here. However, because of the\n-    // `#[may_dangle]` attribute, we do not need to consider R4 live.\n+    v[0] += 1;\n }\n \n-struct Wrap<T> {\n+struct WrapMayDangle<T> {\n     value: T\n }\n \n-unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n+unsafe impl<#[may_dangle] T> Drop for WrapMayDangle<T> {\n     fn drop(&mut self) { }\n }\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#6r    | {bb2[3..=5], bb3[0..=1]}\n-// ...\n-// let _2: Wrap<&'_#6r usize>;\n-// END rustc.main.nll.0.mir", "previous_filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/drop-may-dangle.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114"}, {"sha": "0220858a0d59ed265eb0a5d2fda03953559ca8c0", "filename": "src/test/ui/nll/drop-no-may-dangle.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` must include everything until `p` is dropped\n+// because of destructor. (Note that the stderr also identifies this\n+// destructor in the error message.)\n+\n+// compile-flags:-Znll -Zborrowck=mir -Znll-dump-cause\n+\n+#![allow(warnings)]\n+#![feature(dropck_eyepatch)]\n+#![feature(generic_param_attrs)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p: WrapMayNotDangle<&usize> = WrapMayNotDangle { value: &v[0] };\n+    if true {\n+        use_x(*p.value);\n+    } else {\n+        use_x(22);\n+        v[0] += 1; //~ ERROR cannot assign to `v[..]` because it is borrowed\n+    }\n+\n+    v[0] += 1; //~ ERROR cannot assign to `v[..]` because it is borrowed\n+}\n+\n+struct WrapMayNotDangle<T> {\n+    value: T\n+}\n+\n+impl<T> Drop for WrapMayNotDangle<T> {\n+    fn drop(&mut self) { }\n+}"}, {"sha": "ef850f3a568c0b84f3a5ddcc9b7090e1d423165e", "filename": "src/test/ui/nll/drop-no-may-dangle.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,25 @@\n+error[E0506]: cannot assign to `v[..]` because it is borrowed\n+  --> $DIR/drop-no-may-dangle.rs:31:9\n+   |\n+26 |     let p: WrapMayNotDangle<&usize> = WrapMayNotDangle { value: &v[0] };\n+   |                                                                 ----- borrow of `v[..]` occurs here\n+...\n+31 |         v[0] += 1; //~ ERROR cannot assign to `v[..]` because it is borrowed\n+   |         ^^^^^^^^^ assignment to borrowed `v[..]` occurs here\n+...\n+35 | }\n+   |  - borrow later used here, when `p` is dropped\n+\n+error[E0506]: cannot assign to `v[..]` because it is borrowed\n+  --> $DIR/drop-no-may-dangle.rs:34:5\n+   |\n+26 |     let p: WrapMayNotDangle<&usize> = WrapMayNotDangle { value: &v[0] };\n+   |                                                                 ----- borrow of `v[..]` occurs here\n+...\n+34 |     v[0] += 1; //~ ERROR cannot assign to `v[..]` because it is borrowed\n+   |     ^^^^^^^^^ assignment to borrowed `v[..]` occurs here\n+35 | }\n+   |  - borrow later used here, when `p` is dropped\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7c52a0c87af95d269ebc0b6e4aa8e8a1b75070c0", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -13,7 +13,7 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=compare\n+// compile-flags:-Znll -Zborrowck=compare -Znll-dump-cause\n \n struct Map {\n }"}, {"sha": "ed2c305090ccc0075317b033d4dd0161e91f764b", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -42,6 +42,9 @@ error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as imm\n 43 |             Some(v) => {\n 44 |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n+...\n+47 |                 return v;\n+   |                        - borrow later used here\n \n error: aborting due to 4 previous errors\n "}, {"sha": "184dfe320d33d7caedd0da90165d726d1bbdef71", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll -Znll-dump-cause\n+\n \n #![allow(warnings)]\n "}, {"sha": "3c685ce111a972e13ae12952995d6fc30b045767", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -1,11 +1,14 @@\n error[E0506]: cannot assign to `x` because it is borrowed\n-  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:31:5\n+  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:32:5\n    |\n-27 |     let wrap = Wrap { p: &mut x };\n+28 |     let wrap = Wrap { p: &mut x };\n    |                          ------ borrow of `x` occurs here\n ...\n-31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+32 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n    |     ^^^^^ assignment to borrowed `x` occurs here\n+33 |     // FIXME ^ Should not error in the future with implicit dtors, only manually implemented ones\n+34 | }\n+   |  - borrow later used here, when `foo` is dropped\n \n error: aborting due to previous error\n "}, {"sha": "beb2c87f8f3bd4e6cea9be0f1b810442572a8d1a", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n \n #![allow(warnings)]\n "}, {"sha": "072818c7ce17bc3fa146a59398c344894b0b2781", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -6,6 +6,8 @@ error[E0506]: cannot assign to `x` because it is borrowed\n ...\n 31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n    |     ^^^^^ assignment to borrowed `x` occurs here\n+32 | }\n+   |  - borrow later used here, when `foo` is dropped\n \n error: aborting due to previous error\n "}, {"sha": "39cad8acee18117f190fc36732b53527d93ff535", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n \n #![allow(warnings)]\n "}, {"sha": "89117c2bfeafead7730d16421c366822a7c3b001", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -6,6 +6,9 @@ error[E0506]: cannot assign to `x` because it is borrowed\n ...\n 32 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n    |     ^^^^^ assignment to borrowed `x` occurs here\n+33 |     // FIXME ^ This currently errors and it should not.\n+34 | }\n+   |  - borrow later used here, when `foo` is dropped\n \n error: aborting due to previous error\n "}, {"sha": "767c5b9b8be8dd1deb1f29d8230a313d735e0ebd", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll -Znll-dump-cause\n \n #![allow(warnings)]\n "}, {"sha": "626307a80ed5783d74c9be1f5f0256a1445db6da", "filename": "src/test/ui/nll/maybe-initialized-drop.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -5,6 +5,8 @@ error[E0506]: cannot assign to `x` because it is borrowed\n    |                          ------ borrow of `x` occurs here\n 26 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n    |     ^^^^^ assignment to borrowed `x` occurs here\n+27 | }\n+   |  - borrow later used here, when `wrap` is dropped\n \n error: aborting due to previous error\n "}, {"sha": "850cd1e7336d739fa9df08a06f695f4edaa44e57", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+\n+trait Foo<'a> {\n+}\n+\n+impl<'a, T> Foo<'a> for T { }\n+\n+fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+    x\n+        //~^ WARNING not reporting region error due to -Znll\n+        //~| ERROR explicit lifetime required in the type of `x` [E0621]\n+}\n+\n+fn main() {}"}, {"sha": "4cfd12002e79612d1c91fa16690ba579d5f8b9b2", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,16 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-captures.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+error[E0621]: explicit lifetime required in the type of `x`\n+  --> $DIR/impl-trait-captures.rs:22:5\n+   |\n+21 | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+   |               - consider changing the type of `x` to `&ReEarlyBound(0, 'a) T`\n+22 |     x\n+   |     ^ lifetime `ReEarlyBound(0, 'a)` required\n+\n+error: aborting due to previous error\n+"}, {"sha": "135805a733944d9904ab9855a378853b3a74c477", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ WARNING not reporting region error due to -Znll\n+where\n+    T: Debug,\n+{\n+    x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ WARNING not reporting region error due to -Znll\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "5916d0060a02ae6af8b6d49e98ca190a07277605", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,30 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-outlives.rs:18:35\n+   |\n+18 | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                   ^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-outlives.rs:34:42\n+   |\n+34 | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                          ^^^^^^^^^^^^^^^\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/impl-trait-outlives.rs:23:5\n+   |\n+23 |     x\n+   |     ^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/impl-trait-outlives.rs:39:5\n+   |\n+39 |     x\n+   |     ^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "0ec6d7b74ad5add6c7f9948d3d2babe23347e9c2", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+// Test that we can deduce when projections like `T::Item` outlive the\n+// function body. Test that this does not imply that `T: 'a` holds.\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+fn twice<F, T>(mut value: T, mut f: F)\n+where\n+    F: FnMut(&T, Cell<&Option<T::Item>>),\n+    T: Iterator,\n+{\n+    let mut n = value.next();\n+    f(&value, Cell::new(&n));\n+    f(&value, Cell::new(&n));\n+}\n+\n+#[rustc_errors]\n+fn generic1<T: Iterator>(value: T) {\n+    // No error here:\n+    twice(value, |value_ref, item| invoke1(item));\n+}\n+\n+fn invoke1<'a, T>(x: Cell<&'a Option<T>>)\n+where\n+    T: 'a,\n+{\n+}\n+\n+#[rustc_errors]\n+fn generic2<T: Iterator>(value: T) {\n+    twice(value, |value_ref, item| invoke2(value_ref, item));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn invoke2<'a, T, U>(a: &T, b: Cell<&'a Option<U>>)\n+where\n+    T: 'a,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "a49bdbbf09edf3779f492eb18db598718ef8e1e9", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,16 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-implied-bounds.rs:45:36\n+   |\n+45 |     twice(value, |value_ref, item| invoke2(value_ref, item));\n+   |                                    ^^^^^^^\n+\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-implied-bounds.rs:45:18\n+   |\n+45 |     twice(value, |value_ref, item| invoke2(value_ref, item));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+\n+error: aborting due to previous error\n+"}, {"sha": "0493bd1ea0d9cce01b3602e5332330e275f8cdaf", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -35,7 +35,7 @@ where\n {\n     with_signature(x, |mut y| Box::new(y.next()))\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+    //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n #[rustc_regions]\n@@ -53,7 +53,7 @@ where\n {\n     with_signature(x, |mut y| Box::new(y.next()))\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+    //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n #[rustc_regions]"}, {"sha": "b2e98b7c2f6a45be62f0962342b7e467de50c295", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -72,11 +72,13 @@ note: External requirements\n    = note: number of external vids: 4\n    = note: where <T as std::iter::Iterator>::Item: '_#3r\n \n-error: `<T as std::iter::Iterator>::Item` does not outlive `'_#4r`\n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-closure.rs:36:23\n    |\n 36 |     with_signature(x, |mut y| Box::new(y.next()))\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:32:1\n@@ -86,7 +88,7 @@ note: No external requirements\n 34 | |     T: Iterator,\n 35 | | {\n ...  |\n-38 | |     //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+38 | |     //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n 39 | | }\n    | |_^\n    |\n@@ -111,11 +113,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `<T as std::iter::Iterator>::Item` does not outlive `'_#6r`\n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-closure.rs:54:23\n    |\n 54 |     with_signature(x, |mut y| Box::new(y.next()))\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:50:1\n@@ -125,7 +129,7 @@ note: No external requirements\n 52 | |     T: 'b + Iterator,\n 53 | | {\n ...  |\n-56 | |     //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+56 | |     //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n 57 | | }\n    | |_^\n    |"}, {"sha": "5f2e84e247a3c925911b708fabe438d96c73685c", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -23,7 +23,7 @@ where\n {\n     Box::new(x.next())\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+    //~| the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n fn correct_region<'a, T>(mut x: T) -> Box<dyn Anything + 'a>\n@@ -39,7 +39,7 @@ where\n {\n     Box::new(x.next())\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+    //~| the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n fn outlives_region<'a, 'b, T>(mut x: T) -> Box<dyn Anything + 'a>"}, {"sha": "d309bf2ce6ca4976eb1910f7a9a2d73e17047249", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,17 +10,21 @@ warning: not reporting region error due to -Znll\n 40 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: `<T as std::iter::Iterator>::Item` does not outlive `'_#4r`\n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-fn.rs:24:5\n    |\n 24 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n \n-error: `<T as std::iter::Iterator>::Item` does not outlive `'_#5r`\n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-fn.rs:40:5\n    |\n 40 |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9a5e04deddfc92ce5a20265c30446027c0047c49", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -55,8 +55,8 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n-    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]\n@@ -67,8 +67,8 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n-    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+    //~| ERROR the parameter type `T` may not live long enough\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]\n@@ -89,7 +89,7 @@ where\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| ERROR the parameter type `T` may not live long enough\n     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n }\n "}, {"sha": "e57a39a9de9635456f65af31d4fdf07b5583eed1", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -83,13 +83,15 @@ note: External requirements\n     = note: where T: '_#3r\n     = note: where '_#2r: '_#3r\n \n-error: `T` does not outlive `'_#5r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:56:29\n    |\n 56 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`...\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`\n   --> $DIR/projection-one-region-closure.rs:56:20\n    |\n 56 |     with_signature(cell, t, |cell, t| require(cell, t));\n@@ -103,7 +105,7 @@ note: No external requirements\n 54 | |     T: Anything<'b>,\n 55 | | {\n ...  |\n-59 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+59 | |     //~| ERROR does not outlive free region\n 60 | | }\n    | |_^\n    |\n@@ -112,11 +114,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `T` does not outlive `'_#6r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:68:29\n    |\n 68 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n   --> $DIR/projection-one-region-closure.rs:68:20\n@@ -132,7 +136,7 @@ note: No external requirements\n 65 | |     T: Anything<'b>,\n 66 | |     'a: 'a,\n ...  |\n-71 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+71 | |     //~| ERROR does not outlive free region\n 72 | | }\n    | |_^\n    |\n@@ -142,11 +146,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `T` does not outlive `'_#6r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:90:29\n    |\n 90 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n   --> $DIR/projection-one-region-closure.rs:90:20"}, {"sha": "232025b57355cf98f5037d52e371b6e1e1358f90", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -47,7 +47,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]\n@@ -58,7 +58,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]\n@@ -79,7 +79,7 @@ where\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]"}, {"sha": "5053b8486959a4cb8f2bc8d49f35629f6feef2c6", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -94,7 +94,7 @@ note: External requirements\n     = note: number of external vids: 3\n     = note: where '_#1r: '_#2r\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:17), 'a))`\n   --> $DIR/projection-one-region-trait-bound-closure.rs:48:20\n    |\n 48 |     with_signature(cell, t, |cell, t| require(cell, t));\n@@ -108,7 +108,7 @@ note: No external requirements\n 46 | |     T: Anything<'b>,\n 47 | | {\n ...  |\n-50 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+50 | |     //~| ERROR does not outlive free region\n 51 | | }\n    | |_^\n    |\n@@ -131,7 +131,7 @@ note: No external requirements\n 56 | |     T: Anything<'b>,\n 57 | |     'a: 'a,\n ...  |\n-61 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+61 | |     //~| ERROR does not outlive free region\n 62 | | }\n    | |_^\n    |\n@@ -155,7 +155,7 @@ note: No external requirements\n 67 | |     T: Anything<'b>,\n 68 | |     T::AssocType: 'a,\n ...  |\n-82 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+82 | |     //~| ERROR does not outlive free region\n 83 | | }\n    | |_^\n    |"}, {"sha": "e3cee00ed4eb3b7539928eb4bdfb31403fa13d10", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -48,7 +48,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+    //~| ERROR associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n }\n \n #[rustc_regions]\n@@ -59,7 +59,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+    //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n }\n \n #[rustc_regions]\n@@ -80,7 +80,7 @@ where\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+    //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n }\n \n #[rustc_regions]\n@@ -108,7 +108,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+    //~| ERROR does not outlive free region\n }\n \n #[rustc_regions]"}, {"sha": "414ae38080f632aa41f0a48f87ff6d124aa81986", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -152,11 +152,13 @@ note: External requirements\n     = note: number of external vids: 3\n     = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n-error: `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+error[E0309]: the associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n    |\n 49 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#5r, '_#6r>>::AssocType: ReFree(DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:19), 'a))`...\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:45:1\n@@ -166,7 +168,7 @@ note: No external requirements\n 47 | |     T: Anything<'b, 'c>,\n 48 | | {\n ...  |\n-51 | |     //~| ERROR `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+51 | |     //~| ERROR associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n 52 | | }\n    | |_^\n    |\n@@ -176,11 +178,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n    |\n 60 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:55:1\n@@ -190,7 +194,7 @@ note: No external requirements\n 57 | |     T: Anything<'b, 'c>,\n 58 | |     'a: 'a,\n ...  |\n-62 | |     //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+62 | |     //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n 63 | | }\n    | |_^\n    |\n@@ -201,11 +205,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n    |\n 81 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:66:1\n@@ -215,7 +221,7 @@ note: No external requirements\n 68 | |     T: Anything<'b, 'c>,\n 69 | |     T::AssocType: 'a,\n ...  |\n-83 | |     //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+83 | |     //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n 84 | | }\n    | |_^\n    |\n@@ -264,7 +270,7 @@ note: No external requirements\n                 T\n             ]\n \n-error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:44), 'a))`\n    --> $DIR/projection-two-region-trait-bound-closure.rs:109:20\n     |\n 109 |     with_signature(cell, t, |cell, t| require(cell, t));\n@@ -278,7 +284,7 @@ note: No external requirements\n 107 | |     T: Anything<'b, 'b>,\n 108 | | {\n ...   |\n-111 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+111 | |     //~| ERROR does not outlive free region\n 112 | | }\n     | |_^\n     |"}, {"sha": "423747a6bd6cbb927aa271f8d9739d93607ec1c4", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+// Invoke in such a way that the callee knows:\n+//\n+// - 'a: 'x\n+//\n+// and it must prove that `T: 'x`. Callee passes along `T: 'a`.\n+fn twice<'a, F, T>(v: Cell<&'a ()>, value: T, mut f: F)\n+where\n+    F: for<'x> FnMut(Option<Cell<&'a &'x ()>>, &T),\n+{\n+    f(None, &value);\n+    f(None, &value);\n+}\n+\n+#[rustc_regions]\n+fn generic<T>(value: T) {\n+    let cell = Cell::new(&());\n+    twice(cell, value, |a, b| invoke(a, b));\n+    //~^ WARNING not reporting region error\n+    //\n+    // This error from the old region solver looks bogus.\n+}\n+\n+#[rustc_regions]\n+fn generic_fail<'a, T>(cell: Cell<&'a ()>, value: T) {\n+    twice(cell, value, |a, b| invoke(a, b));\n+    //~^ WARNING not reporting region error\n+    //~| WARNING not reporting region error\n+    //~| ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn invoke<'a, 'x, T>(x: Option<Cell<&'x &'a ()>>, y: &T)\n+where\n+    T: 'x,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "ef564377e506e00d58e656d2453473b9e5759bf8", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,87 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:35:31\n+   |\n+35 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                               ^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:31\n+   |\n+43 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                               ^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:31\n+   |\n+43 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                               ^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:35:24\n+   |\n+35 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:14 ~ ty_param_closure_approximate_lower_bound[317d]::generic[0]::{{closure}}[0]) with closure substs [\n+               T,\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) ()>>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) T))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:24\n+   |\n+43 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:17 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]::{{closure}}[0]) with closure substs [\n+               T,\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) ()>>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) T))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:33:1\n+   |\n+33 | / fn generic<T>(value: T) {\n+34 | |     let cell = Cell::new(&());\n+35 | |     twice(cell, value, |a, b| invoke(a, b));\n+36 | |     //~^ WARNING not reporting region error\n+37 | |     //\n+38 | |     // This error from the old region solver looks bogus.\n+39 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:5 ~ ty_param_closure_approximate_lower_bound[317d]::generic[0]) with substs [\n+               T\n+           ]\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:24\n+   |\n+43 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:42:1\n+   |\n+42 | / fn generic_fail<'a, T>(cell: Cell<&'a ()>, value: T) {\n+43 | |     twice(cell, value, |a, b| invoke(a, b));\n+44 | |     //~^ WARNING not reporting region error\n+45 | |     //~| WARNING not reporting region error\n+46 | |     //~| ERROR the parameter type `T` may not live long enough\n+47 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]) with substs [\n+               T\n+           ]\n+\n+error: aborting due to previous error\n+"}, {"sha": "95a483b3c355d00058fe1fd36f9c1cb65949c6ef", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -36,7 +36,7 @@ where\n \n     with_signature(x, |y| y)\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| ERROR the parameter type `T` may not live long enough\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n@@ -52,7 +52,7 @@ where\n {\n     x\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| ERROR the parameter type `T` may not live long enough\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>"}, {"sha": "b7120017a2c0e126857edd2f92bef1a8e32f4c75", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -25,11 +25,13 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where T: '_#2r\n \n-error: `T` does not outlive `'_#4r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:23\n    |\n 37 |     with_signature(x, |y| y)\n    |                       ^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:1\n@@ -39,7 +41,7 @@ note: No external requirements\n 28 | |     T: Debug,\n 29 | | {\n ...  |\n-39 | |     //~| ERROR `T` does not outlive\n+39 | |     //~| ERROR the parameter type `T` may not live long enough\n 40 | | }\n    | |_^\n    |\n@@ -48,11 +50,13 @@ note: No external requirements\n                T\n            ]\n \n-error: `T` does not outlive `'_#4r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n    |\n 53 |     x\n    |     ^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1149f250a46e2f53b7deacba724f8f295033eb40", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -36,7 +36,7 @@ where\n #[rustc_regions]\n fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n     with_signature(a, b, |x, y| {\n-        //~^ ERROR `T` does not outlive\n+        //~^ ERROR the parameter type `T` may not live long enough\n         //\n         // See `correct_region`, which explains the point of this\n         // test.  The only difference is that, in the case of this\n@@ -74,7 +74,7 @@ where\n     T: 'b,\n {\n     with_signature(a, b, |x, y| {\n-        //~^ ERROR `T` does not outlive\n+        //~^ ERROR the parameter type `T` may not live long enough\n         // See `correct_region`\n         require(&x, &y)\n         //~^ WARNING not reporting region error due to -Znll"}, {"sha": "d47f506cd2043f314cece98a16180cbe2b930081", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -15,7 +15,7 @@ note: External requirements\n    |\n 38 |       with_signature(a, b, |x, y| {\n    |  __________________________^\n-39 | |         //~^ ERROR `T` does not outlive\n+39 | |         //~^ ERROR the parameter type `T` may not live long enough\n 40 | |         //\n 41 | |         // See `correct_region`, which explains the point of this\n ...  |\n@@ -58,7 +58,7 @@ note: External requirements\n    |\n 76 |       with_signature(a, b, |x, y| {\n    |  __________________________^\n-77 | |         //~^ ERROR `T` does not outlive\n+77 | |         //~^ ERROR the parameter type `T` may not live long enough\n 78 | |         // See `correct_region`\n 79 | |         require(&x, &y)\n 80 | |         //~^ WARNING not reporting region error due to -Znll\n@@ -94,25 +94,27 @@ note: External requirements\n    = note: number of external vids: 4\n    = note: where T: '_#3r\n \n-error: `T` does not outlive `'_#3r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n    |\n 38 |       with_signature(a, b, |x, y| {\n    |  __________________________^\n-39 | |         //~^ ERROR `T` does not outlive\n+39 | |         //~^ ERROR the parameter type `T` may not live long enough\n 40 | |         //\n 41 | |         // See `correct_region`, which explains the point of this\n ...  |\n 46 | |         //~^ WARNING not reporting region error due to -Znll\n 47 | |     })\n    | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]), BrNamed(crate0:DefIndex(1:15), 'a))`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:1\n    |\n 37 | / fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n 38 | |     with_signature(a, b, |x, y| {\n-39 | |         //~^ ERROR `T` does not outlive\n+39 | |         //~^ ERROR the parameter type `T` may not live long enough\n 40 | |         //\n ...  |\n 47 | |     })\n@@ -140,17 +142,19 @@ note: No external requirements\n                T\n            ]\n \n-error: `T` does not outlive `'_#5r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n    |\n 76 |       with_signature(a, b, |x, y| {\n    |  __________________________^\n-77 | |         //~^ ERROR `T` does not outlive\n+77 | |         //~^ ERROR the parameter type `T` may not live long enough\n 78 | |         // See `correct_region`\n 79 | |         require(&x, &y)\n 80 | |         //~^ WARNING not reporting region error due to -Znll\n 81 | |     })\n    | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]), BrNamed(crate0:DefIndex(1:21), 'a))`...\n \n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:72:1"}, {"sha": "babe608354fb92481df3f4465eb8b67dfca2cab3", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body-nll-feature.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we assume that universal types like `T` outlive the\n+// function body. Same as ty-param-fn-body, but uses `feature(nll)`,\n+// which affects error reporting.\n+\n+#![feature(nll)]\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+use std::cell::Cell;\n+\n+// No errors here, because `'a` is local to the body.\n+fn region_within_body<T>(t: T) {\n+    let some_int = 22;\n+    let cell = Cell::new(&some_int);\n+    outlives(cell, t)\n+}\n+\n+// Error here, because T: 'a is not satisfied.\n+fn region_static<'a, T>(cell: Cell<&'a usize>, t: T) {\n+    outlives(cell, t)\n+    //~^ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn outlives<'a, T>(x: Cell<&'a usize>, y: T)\n+where\n+    T: 'a,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "fa9105df070276fcc7620bbda0881496fe31df07", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body-nll-feature.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body-nll-feature.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,10 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-fn-body-nll-feature.rs:31:5\n+   |\n+31 |     outlives(cell, t)\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n+\n+error: aborting due to previous error\n+"}, {"sha": "e66c1853b64b9167e73a39b6e8c9f20d2c2ce0da", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -29,7 +29,7 @@ fn region_within_body<T>(t: T) {\n fn region_static<'a, T>(cell: Cell<&'a usize>, t: T) {\n     outlives(cell, t)\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| ERROR the parameter type `T` may not live long enough\n }\n \n fn outlives<'a, T>(x: Cell<&'a usize>, y: T)"}, {"sha": "3334f4ecc7c869050cd4977b99122af8c1f22f3a", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -4,11 +4,13 @@ warning: not reporting region error due to -Znll\n 30 |     outlives(cell, t)\n    |     ^^^^^^^^\n \n-error: `T` does not outlive `'_#4r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn-body.rs:30:5\n    |\n 30 |     outlives(cell, t)\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error: aborting due to previous error\n "}, {"sha": "aa3a03afa35cdbfd2acb818366c050389ad568d0", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -21,7 +21,7 @@ where\n {\n     x\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| the parameter type `T` may not live long enough\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n@@ -37,7 +37,7 @@ where\n {\n     x\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR `T` does not outlive\n+    //~| the parameter type `T` may not live long enough\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>"}, {"sha": "1e659e2e9f073798280aefb288035511959643c5", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -10,17 +10,21 @@ warning: not reporting region error due to -Znll\n 38 |     x\n    |     ^\n \n-error: `T` does not outlive `'_#3r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn.rs:22:5\n    |\n 22 |     x\n    |     ^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n \n-error: `T` does not outlive `'_#4r`\n+error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-fn.rs:38:5\n    |\n 38 |     x\n    |     ^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cab7ba7a5052518d23bfe576f46cad2a6e914235", "filename": "src/test/ui/nll/ty-outlives/ty-param-implied-bounds.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs?ref=fdfb0071091d7257b20ee2a75041d868c23f1114", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+// Test that we assume that universal types like `T` outlive the\n+// function body.\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+fn twice<F, T>(value: T, mut f: F)\n+where\n+    F: FnMut(Cell<&T>),\n+{\n+    f(Cell::new(&value));\n+    f(Cell::new(&value));\n+}\n+\n+#[rustc_errors]\n+fn generic<T>(value: T) {\n+    // No error here:\n+    twice(value, |r| invoke(r));\n+}\n+\n+fn invoke<'a, T>(x: Cell<&'a T>)\n+where\n+    T: 'a,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/ty-outlives/ty-param-implied-bounds.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fdfb0071091d7257b20ee2a75041d868c23f1114/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr?ref=fdfb0071091d7257b20ee2a75041d868c23f1114"}]}