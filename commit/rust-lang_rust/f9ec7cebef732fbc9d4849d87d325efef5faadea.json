{"sha": "f9ec7cebef732fbc9d4849d87d325efef5faadea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZWM3Y2ViZWY3MzJmYmM5ZDQ4NDlkODdkMzI1ZWZlZjVmYWFkZWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-08T18:09:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T18:09:25Z"}, "message": "Merge #4377\n\n4377: Implement better handling of divergence r=matklad a=flodiebold\n\nDivergence here means that for some reason, the end of a block will not be reached. We tried to model this just using the never type, but that doesn't work fully (e.g. in `let x = { loop {}; \"foo\" };` x should still have type `&str`); so this introduces a `diverges` flag that the type checker keeps track of, like rustc does. We also add some checking for `break`, but no support for break-with-value or labeled breaks yet.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "4a40dbed04c432dee54f8a8d016c89c7411b1e6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a40dbed04c432dee54f8a8d016c89c7411b1e6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ec7cebef732fbc9d4849d87d325efef5faadea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetaBVCRBK7hj4Ov3rIwAAdHIIAGSSYLPTNk7KdOirlV0rR7GR\nciWrzai+g222Kr2S5J4E0hms1VaKozj2a2uXI5NZnurA73Q3SkyPwI9ZSCYX92B7\nfek6ANYzKzopSfpI8nNR9oIyG7v9IzQyHFT8q3lEGPYxu3lcNDQuc9RUCVr1RYd0\ntB+Hh0dMCgC+3+CgcJVrS+GbMUkNRxREE3qXFFKUUUisnQON0PoE7a+NUoPe9S7M\nWtk1ICBWfyIZRsQ27ahGBexWU1heWH105qmoi7bULkKbQwmNl4RB2TbErREdkph1\n3hje5BqfwGSAj6pEUkahjxwtVF2D4oEOeeDTPvdjBkm5j8gQL8FYHv8Po6gZRyc=\n=iZMh\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a40dbed04c432dee54f8a8d016c89c7411b1e6d\nparent f1fa9aa4c4d4fcfe7d6e90ba9cefca90bc7c4998\nparent d0129c4ddba3b72e7b26e94e9c25546d37dbf166\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588961365 +0000\ncommitter GitHub <noreply@github.com> 1588961365 +0000\n\nMerge #4377\n\n4377: Implement better handling of divergence r=matklad a=flodiebold\n\nDivergence here means that for some reason, the end of a block will not be reached. We tried to model this just using the never type, but that doesn't work fully (e.g. in `let x = { loop {}; \"foo\" };` x should still have type `&str`); so this introduces a `diverges` flag that the type checker keeps track of, like rustc does. We also add some checking for `break`, but no support for break-with-value or labeled breaks yet.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ec7cebef732fbc9d4849d87d325efef5faadea", "html_url": "https://github.com/rust-lang/rust/commit/f9ec7cebef732fbc9d4849d87d325efef5faadea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ec7cebef732fbc9d4849d87d325efef5faadea/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1fa9aa4c4d4fcfe7d6e90ba9cefca90bc7c4998", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1fa9aa4c4d4fcfe7d6e90ba9cefca90bc7c4998", "html_url": "https://github.com/rust-lang/rust/commit/f1fa9aa4c4d4fcfe7d6e90ba9cefca90bc7c4998"}, {"sha": "d0129c4ddba3b72e7b26e94e9c25546d37dbf166", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0129c4ddba3b72e7b26e94e9c25546d37dbf166", "html_url": "https://github.com/rust-lang/rust/commit/d0129c4ddba3b72e7b26e94e9c25546d37dbf166"}], "stats": {"total": 387, "additions": 362, "deletions": 25}, "files": [{"sha": "41ac702724e845ec68845a20b4e8357a32beb65c", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -131,3 +131,31 @@ impl AstDiagnostic for MissingOkInTailExpr {\n         ast::Expr::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct BreakOutsideOfLoop {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for BreakOutsideOfLoop {\n+    fn message(&self) -> String {\n+        \"break outside of loop\".to_string()\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for BreakOutsideOfLoop {\n+    type AST = ast::Expr;\n+\n+    fn ast(&self, db: &impl AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.file).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::Expr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "a21ad8d86416b4dab68c78b7d734bb0e704e693a", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -210,6 +210,13 @@ struct InferenceContext<'a> {\n     /// closures, but currently this is the only field that will change there,\n     /// so it doesn't make sense.\n     return_ty: Ty,\n+    diverges: Diverges,\n+    breakables: Vec<BreakableContext>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct BreakableContext {\n+    pub may_break: bool,\n }\n \n impl<'a> InferenceContext<'a> {\n@@ -224,6 +231,8 @@ impl<'a> InferenceContext<'a> {\n             owner,\n             body: db.body(owner),\n             resolver,\n+            diverges: Diverges::Maybe,\n+            breakables: Vec::new(),\n         }\n     }\n \n@@ -666,15 +675,57 @@ impl Expectation {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+enum Diverges {\n+    Maybe,\n+    Always,\n+}\n+\n+impl Diverges {\n+    fn is_always(self) -> bool {\n+        self == Diverges::Always\n+    }\n+}\n+\n+impl std::ops::BitAnd for Diverges {\n+    type Output = Self;\n+    fn bitand(self, other: Self) -> Self {\n+        std::cmp::min(self, other)\n+    }\n+}\n+\n+impl std::ops::BitOr for Diverges {\n+    type Output = Self;\n+    fn bitor(self, other: Self) -> Self {\n+        std::cmp::max(self, other)\n+    }\n+}\n+\n+impl std::ops::BitAndAssign for Diverges {\n+    fn bitand_assign(&mut self, other: Self) {\n+        *self = *self & other;\n+    }\n+}\n+\n+impl std::ops::BitOrAssign for Diverges {\n+    fn bitor_assign(&mut self, other: Self) {\n+        *self = *self | other;\n+    }\n+}\n+\n mod diagnostics {\n     use hir_def::{expr::ExprId, FunctionId};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n-    use crate::{db::HirDatabase, diagnostics::NoSuchField};\n+    use crate::{\n+        db::HirDatabase,\n+        diagnostics::{BreakOutsideOfLoop, NoSuchField},\n+    };\n \n     #[derive(Debug, PartialEq, Eq, Clone)]\n     pub(super) enum InferenceDiagnostic {\n         NoSuchField { expr: ExprId, field: usize },\n+        BreakOutsideOfLoop { expr: ExprId },\n     }\n \n     impl InferenceDiagnostic {\n@@ -690,6 +741,13 @@ mod diagnostics {\n                     let field = source_map.field_syntax(*expr, *field);\n                     sink.push(NoSuchField { file: field.file_id, field: field.value })\n                 }\n+                InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                    let (_, source_map) = db.body_with_source_map(owner.into());\n+                    let ptr = source_map\n+                        .expr_syntax(*expr)\n+                        .expect(\"break outside of loop in synthetic syntax\");\n+                    sink.push(BreakOutsideOfLoop { file: ptr.file_id, expr: ptr.value })\n+                }\n             }\n         }\n     }"}, {"sha": "0b67d216a8bf3ee4570d49a1eace14a775e6315b", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -1,7 +1,7 @@\n //! Type inference for expressions.\n \n use std::iter::{repeat, repeat_with};\n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n use hir_def::{\n     builtin_type::Signedness,\n@@ -21,11 +21,18 @@ use crate::{\n     Ty, TypeCtor, Uncertain,\n };\n \n-use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+use super::{\n+    BindingMode, BreakableContext, Diverges, Expectation, InferenceContext, InferenceDiagnostic,\n+    TypeMismatch,\n+};\n \n impl<'a> InferenceContext<'a> {\n     pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n+        if ty.is_never() {\n+            // Any expression that produces a value of type `!` must have diverged\n+            self.diverges = Diverges::Always;\n+        }\n         let could_unify = self.unify(&ty, &expected.ty);\n         if !could_unify {\n             self.result.type_mismatches.insert(\n@@ -64,11 +71,18 @@ impl<'a> InferenceContext<'a> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n+                let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let mut both_arms_diverge = Diverges::Always;\n+\n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n+                both_arms_diverge &= self.diverges;\n+\n+                self.diverges = condition_diverges | both_arms_diverge;\n \n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n@@ -79,24 +93,43 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+\n+                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                if ctxt.may_break {\n+                    self.diverges = Diverges::Maybe;\n+                }\n                 // FIXME handle break with value\n-                Ty::simple(TypeCtor::Never)\n+                if ctxt.may_break {\n+                    Ty::unit()\n+                } else {\n+                    Ty::simple(TypeCtor::Never)\n+                }\n             }\n             Expr::While { condition, body } => {\n+                self.breakables.push(BreakableContext { may_break: false });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n+                self.breakables.push(BreakableContext { may_break: false });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+                // the body may not run, so it diverging doesn't mean we diverge\n+                self.diverges = Diverges::Maybe;\n                 Ty::unit()\n             }\n             Expr::Lambda { body, args, ret_type, arg_types } => {\n@@ -132,10 +165,12 @@ impl<'a> InferenceContext<'a> {\n                 // infer the body.\n                 self.coerce(&closure_ty, &expected.ty);\n \n-                let prev_ret_ty = std::mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n                 self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n \n+                self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n \n                 closure_ty\n@@ -165,7 +200,11 @@ impl<'a> InferenceContext<'a> {\n                     self.table.new_type_var()\n                 };\n \n+                let matchee_diverges = self.diverges;\n+                let mut all_arms_diverge = Diverges::Always;\n+\n                 for arm in arms {\n+                    self.diverges = Diverges::Maybe;\n                     let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n@@ -175,9 +214,12 @@ impl<'a> InferenceContext<'a> {\n                     }\n \n                     let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    all_arms_diverge &= self.diverges;\n                     result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n+                self.diverges = matchee_diverges | all_arms_diverge;\n+\n                 result_ty\n             }\n             Expr::Path(p) => {\n@@ -191,6 +233,13 @@ impl<'a> InferenceContext<'a> {\n                     // FIXME handle break with value\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n+                if let Some(ctxt) = self.breakables.last_mut() {\n+                    ctxt.may_break = true;\n+                } else {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                    });\n+                }\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {\n@@ -522,7 +571,6 @@ impl<'a> InferenceContext<'a> {\n         tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        let mut diverges = false;\n         for stmt in statements {\n             match stmt {\n                 Statement::Let { pat, type_ref, initializer } => {\n@@ -544,24 +592,30 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n-                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n-                        diverges = true;\n-                    }\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n \n         let ty = if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n-            self.coerce(&Ty::unit(), expected.coercion_target());\n-            Ty::unit()\n+            // Citing rustc: if there is no explicit tail expression,\n+            // that is typically equivalent to a tail expression\n+            // of `()` -- except if the block diverges. In that\n+            // case, there is no value supplied from the tail\n+            // expression (assuming there are no other breaks,\n+            // this implies that the type of the block will be\n+            // `!`).\n+            if self.diverges.is_always() {\n+                // we don't even make an attempt at coercion\n+                self.table.new_maybe_never_type_var()\n+            } else {\n+                self.coerce(&Ty::unit(), expected.coercion_target());\n+                Ty::unit()\n+            }\n         };\n-        if diverges {\n-            Ty::simple(TypeCtor::Never)\n-        } else {\n-            ty\n-        }\n+        ty\n     }\n \n     fn infer_method_call("}, {"sha": "3e5f38d0d5bb3e752270ef3743003b47095413fb", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -730,6 +730,10 @@ impl Ty {\n         }\n     }\n \n+    pub fn is_never(&self) -> bool {\n+        matches!(self, Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }))\n+    }\n+\n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n         match self {"}, {"sha": "5af88b368467670e8f64ddb3c848a15e0f66bff6", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -518,3 +518,21 @@ fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n \n     assert_snapshot!(diagnostics, @\"\");\n }\n+\n+#[test]\n+fn break_outside_of_loop() {\n+    let diagnostics = TestDB::with_files(\n+        r\"\n+        //- /lib.rs\n+        fn foo() {\n+            break;\n+        }\n+        \",\n+    )\n+    .diagnostics()\n+    .0;\n+\n+    assert_snapshot!(diagnostics, @r###\"\"break\": break outside of loop\n+    \"###\n+    );\n+}"}, {"sha": "0c3a833bd9e378be9c95f35bbac02fd331d729c2", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -384,7 +384,7 @@ fn foo() -> u32 {\n }\n \"#, true),\n         @r###\"\n-    17..40 '{     ...own; }': !\n+    17..40 '{     ...own; }': u32\n     23..37 'return unknown': !\n     30..37 'unknown': u32\n     \"###\n@@ -514,7 +514,7 @@ fn foo() {\n     27..103 '{     ...     }': &u32\n     37..82 'if tru...     }': ()\n     40..44 'true': bool\n-    45..82 '{     ...     }': !\n+    45..82 '{     ...     }': ()\n     59..71 'return &1u32': !\n     66..71 '&1u32': &u32\n     67..71 '1u32': u32"}, {"sha": "4c6099aa230dc2c9ce49b8fc7b22b0f656f00822", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -197,7 +197,7 @@ fn spam() {\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n     !0..6 '1isize': isize\n-    54..457 '{     ...!(); }': !\n+    54..457 '{     ...!(); }': ()\n     88..109 'spam!(...am!())': {unknown}\n     115..134 'for _ ...!() {}': ()\n     119..120 '_': {unknown}"}, {"sha": "082c472088488f0db3c29a17e777c617457abe65", "filename": "crates/ra_hir_ty/src/tests/never_type.rs", "status": "modified", "additions": 176, "deletions": 1, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -1,4 +1,6 @@\n-use super::type_at;\n+use insta::assert_snapshot;\n+\n+use super::{infer_with_mismatches, type_at};\n \n #[test]\n fn infer_never1() {\n@@ -261,3 +263,176 @@ fn test(a: i32) {\n     );\n     assert_eq!(t, \"f64\");\n }\n+\n+#[test]\n+fn diverging_expression_1() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    let x: u32 = return;\n+}\n+fn test2() {\n+    let x: u32 = { return; };\n+}\n+fn test3() {\n+    let x: u32 = loop {};\n+}\n+fn test4() {\n+    let x: u32 = { loop {} };\n+}\n+fn test5() {\n+    let x: u32 = { if true { loop {}; } else { loop {}; } };\n+}\n+fn test6() {\n+    let x: u32 = { let y: u32 = { loop {}; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..53 '{     ...urn; }': ()\n+    35..36 'x': u32\n+    44..50 'return': !\n+    65..98 '{     ...; }; }': ()\n+    75..76 'x': u32\n+    84..95 '{ return; }': u32\n+    86..92 'return': !\n+    110..139 '{     ... {}; }': ()\n+    120..121 'x': u32\n+    129..136 'loop {}': !\n+    134..136 '{}': ()\n+    151..184 '{     ...} }; }': ()\n+    161..162 'x': u32\n+    170..181 '{ loop {} }': u32\n+    172..179 'loop {}': !\n+    177..179 '{}': ()\n+    196..260 '{     ...} }; }': ()\n+    206..207 'x': u32\n+    215..257 '{ if t...}; } }': u32\n+    217..255 'if tru... {}; }': u32\n+    220..224 'true': bool\n+    225..237 '{ loop {}; }': u32\n+    227..234 'loop {}': !\n+    232..234 '{}': ()\n+    243..255 '{ loop {}; }': u32\n+    245..252 'loop {}': !\n+    250..252 '{}': ()\n+    272..324 '{     ...; }; }': ()\n+    282..283 'x': u32\n+    291..321 '{ let ...; }; }': u32\n+    297..298 'y': u32\n+    306..318 '{ loop {}; }': u32\n+    308..315 'loop {}': !\n+    313..315 '{}': ()\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_2() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop {}; \"foo\" };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..98 '{     ...\" }; }': ()\n+    68..69 'x': u32\n+    77..95 '{ loop...foo\" }': &str\n+    79..86 'loop {}': !\n+    84..86 '{}': ()\n+    88..93 '\"foo\"': &str\n+    77..95: expected u32, got &str\n+    88..93: expected u32, got &str\n+    \"###);\n+}\n+\n+#[test]\n+fn diverging_expression_3_break() {\n+    let t = infer_with_mismatches(\n+        r#\"\n+//- /main.rs\n+fn test1() {\n+    // should give type mismatch\n+    let x: u32 = { loop { break; } };\n+}\n+fn test2() {\n+    // should give type mismatch\n+    let x: u32 = { for a in b { break; }; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { for a in b { return; }; };\n+}\n+fn test3() {\n+    // should give type mismatch\n+    let x: u32 = { while true { break; }; };\n+    // should give type mismatch as well -- there's an implicit break, even if it's never hit\n+    let x: u32 = { while true {}; };\n+    // should give type mismatch as well\n+    let x: u32 = { while true { return; }; };\n+}\n+\"#,\n+        true,\n+    );\n+    assert_snapshot!(t, @r###\"\n+    25..99 '{     ...} }; }': ()\n+    68..69 'x': u32\n+    77..96 '{ loop...k; } }': ()\n+    79..94 'loop { break; }': ()\n+    84..94 '{ break; }': ()\n+    86..91 'break': !\n+    77..96: expected u32, got ()\n+    79..94: expected u32, got ()\n+    111..357 '{     ...; }; }': ()\n+    154..155 'x': u32\n+    163..189 '{ for ...; }; }': ()\n+    165..186 'for a ...eak; }': ()\n+    169..170 'a': {unknown}\n+    174..175 'b': {unknown}\n+    176..186 '{ break; }': ()\n+    178..183 'break': !\n+    240..241 'x': u32\n+    249..267 '{ for ... {}; }': ()\n+    251..264 'for a in b {}': ()\n+    255..256 'a': {unknown}\n+    260..261 'b': {unknown}\n+    262..264 '{}': ()\n+    318..319 'x': u32\n+    327..354 '{ for ...; }; }': ()\n+    329..351 'for a ...urn; }': ()\n+    333..334 'a': {unknown}\n+    338..339 'b': {unknown}\n+    340..351 '{ return; }': ()\n+    342..348 'return': !\n+    163..189: expected u32, got ()\n+    249..267: expected u32, got ()\n+    327..354: expected u32, got ()\n+    369..668 '{     ...; }; }': ()\n+    412..413 'x': u32\n+    421..447 '{ whil...; }; }': ()\n+    423..444 'while ...eak; }': ()\n+    429..433 'true': bool\n+    434..444 '{ break; }': ()\n+    436..441 'break': !\n+    551..552 'x': u32\n+    560..578 '{ whil... {}; }': ()\n+    562..575 'while true {}': ()\n+    568..572 'true': bool\n+    573..575 '{}': ()\n+    629..630 'x': u32\n+    638..665 '{ whil...; }; }': ()\n+    640..662 'while ...urn; }': ()\n+    646..650 'true': bool\n+    651..662 '{ return; }': ()\n+    653..659 'return': !\n+    421..447: expected u32, got ()\n+    560..578: expected u32, got ()\n+    638..665: expected u32, got ()\n+    \"###);\n+}"}, {"sha": "3820175f6c20a009c9b1a6558fb2c314a885a67a", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ec7cebef732fbc9d4849d87d325efef5faadea/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f9ec7cebef732fbc9d4849d87d325efef5faadea", "patch": "@@ -179,7 +179,7 @@ fn test(a: u32, b: isize, c: !, d: &str) {\n     17..18 'b': isize\n     27..28 'c': !\n     33..34 'd': &str\n-    42..121 '{     ...f32; }': !\n+    42..121 '{     ...f32; }': ()\n     48..49 'a': u32\n     55..56 'b': isize\n     62..63 'c': !\n@@ -935,7 +935,7 @@ fn foo() {\n     29..33 'true': bool\n     34..51 '{     ...     }': i32\n     44..45 '1': i32\n-    57..80 '{     ...     }': !\n+    57..80 '{     ...     }': i32\n     67..73 'return': !\n     90..93 '_x2': i32\n     96..149 'if tru...     }': i32\n@@ -951,7 +951,7 @@ fn foo() {\n     186..190 'true': bool\n     194..195 '3': i32\n     205..206 '_': bool\n-    210..241 '{     ...     }': !\n+    210..241 '{     ...     }': i32\n     224..230 'return': !\n     257..260 '_x4': i32\n     263..320 'match ...     }': i32\n@@ -1687,7 +1687,7 @@ fn foo() -> u32 {\n     17..59 '{     ...; }; }': ()\n     27..28 'x': || -> usize\n     31..56 '|| -> ...n 1; }': || -> usize\n-    43..56 '{ return 1; }': !\n+    43..56 '{ return 1; }': usize\n     45..53 'return 1': !\n     52..53 '1': usize\n     \"###\n@@ -1706,7 +1706,7 @@ fn foo() -> u32 {\n     17..48 '{     ...; }; }': ()\n     27..28 'x': || -> ()\n     31..45 '|| { return; }': || -> ()\n-    34..45 '{ return; }': !\n+    34..45 '{ return; }': ()\n     36..42 'return': !\n     \"###\n     );"}]}