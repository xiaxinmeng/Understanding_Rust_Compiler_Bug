{"sha": "fb42dae9870c8e1085e9e524363123741a49a255", "node_id": "C_kwDOAAsO6NoAKGZiNDJkYWU5ODcwYzhlMTA4NWU5ZTUyNDM2MzEyMzc0MWE0OWEyNTU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-09-14T15:38:44Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-09-14T17:36:03Z"}, "message": "Simplify CSS parser to check themes", "tree": {"sha": "15da572b65900baa75fde8941ddcc00c222f7194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15da572b65900baa75fde8941ddcc00c222f7194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb42dae9870c8e1085e9e524363123741a49a255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb42dae9870c8e1085e9e524363123741a49a255", "html_url": "https://github.com/rust-lang/rust/commit/fb42dae9870c8e1085e9e524363123741a49a255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb42dae9870c8e1085e9e524363123741a49a255/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c81575657c9591d07c12778fe74c326e5ac76558", "url": "https://api.github.com/repos/rust-lang/rust/commits/c81575657c9591d07c12778fe74c326e5ac76558", "html_url": "https://github.com/rust-lang/rust/commit/c81575657c9591d07c12778fe74c326e5ac76558"}], "stats": {"total": 385, "additions": 178, "deletions": 207}, "files": [{"sha": "932533db05c14066f43ceed4dab20604847c42e0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb42dae9870c8e1085e9e524363123741a49a255/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb42dae9870c8e1085e9e524363123741a49a255/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=fb42dae9870c8e1085e9e524363123741a49a255", "patch": "@@ -412,7 +412,13 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"check-theme\");\n         if !to_check.is_empty() {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n             let mut errors = 0;\n \n             println!(\"rustdoc: [check-theme] Starting tests! (Ignoring all other arguments)\");\n@@ -547,7 +553,13 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"theme\") {\n-            let paths = theme::load_css_paths(static_files::themes::LIGHT.as_bytes());\n+            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+                Ok(p) => p,\n+                Err(e) => {\n+                    diag.struct_err(&e.to_string()).emit();\n+                    return Err(1);\n+                }\n+            };\n \n             for (theme_file, theme_s) in\n                 matches.opt_strs(\"theme\").iter().map(|s| (PathBuf::from(&s), s.to_owned()))"}, {"sha": "77f8359bd42ca82df5086514839d2834168368b8", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 164, "deletions": 205, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/fb42dae9870c8e1085e9e524363123741a49a255/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb42dae9870c8e1085e9e524363123741a49a255/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=fb42dae9870c8e1085e9e524363123741a49a255", "patch": "@@ -1,271 +1,230 @@\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map::Entry;\n use std::fs;\n-use std::hash::{Hash, Hasher};\n+use std::iter::Peekable;\n use std::path::Path;\n+use std::str::Chars;\n \n use rustc_errors::Handler;\n \n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug, Clone, Eq)]\n+#[derive(Debug)]\n pub(crate) struct CssPath {\n-    pub(crate) name: String,\n-    pub(crate) children: FxHashSet<CssPath>,\n+    pub(crate) rules: FxHashMap<String, String>,\n+    pub(crate) children: FxHashMap<String, CssPath>,\n }\n \n-// This PartialEq implementation IS NOT COMMUTATIVE!!!\n-//\n-// The order is very important: the second object must have all first's rules.\n-// However, the first is not required to have all of the second's rules.\n-impl PartialEq for CssPath {\n-    fn eq(&self, other: &CssPath) -> bool {\n-        if self.name != other.name {\n-            false\n-        } else {\n-            for child in &self.children {\n-                if !other.children.iter().any(|c| child == c) {\n-                    return false;\n-                }\n-            }\n-            true\n-        }\n-    }\n-}\n+/// When encountering a `\"` or a `'`, returns the whole string, including the quote characters.\n+fn get_string(iter: &mut Peekable<Chars<'_>>, string_start: char) -> String {\n+    let mut s = String::with_capacity(2);\n \n-impl Hash for CssPath {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state);\n-        for x in &self.children {\n-            x.hash(state);\n+    s.push(string_start);\n+    while let Some(c) = iter.next() {\n+        s.push(c);\n+        if c == '\\\\' {\n+            iter.next();\n+        } else if c == string_start {\n+            break;\n         }\n     }\n+    s\n }\n \n-impl CssPath {\n-    fn new(name: String) -> CssPath {\n-        CssPath { name, children: FxHashSet::default() }\n+/// Skips a `/*` comment.\n+fn skip_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '*' && iter.next() == Some('/') {\n+            break;\n+        }\n     }\n }\n \n-/// All variants contain the position they occur.\n-#[derive(Debug, Clone, Copy)]\n-enum Events {\n-    StartLineComment(usize),\n-    StartComment(usize),\n-    EndComment(usize),\n-    InBlock(usize),\n-    OutBlock(usize),\n-}\n-\n-impl Events {\n-    fn get_pos(&self) -> usize {\n-        match *self {\n-            Events::StartLineComment(p)\n-            | Events::StartComment(p)\n-            | Events::EndComment(p)\n-            | Events::InBlock(p)\n-            | Events::OutBlock(p) => p,\n+/// Skips a line comment (`//`).\n+fn skip_line_comment(iter: &mut Peekable<Chars<'_>>) {\n+    while let Some(c) = iter.next() {\n+        if c == '\\n' {\n+            break;\n         }\n     }\n-\n-    fn is_comment(&self) -> bool {\n-        matches!(\n-            self,\n-            Events::StartLineComment(_) | Events::StartComment(_) | Events::EndComment(_)\n-        )\n-    }\n }\n \n-fn previous_is_line_comment(events: &[Events]) -> bool {\n-    matches!(events.last(), Some(&Events::StartLineComment(_)))\n-}\n-\n-fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n-    if let Some(&Events::StartComment(_)) = events.last() {\n-        return false;\n+fn handle_common_chars(c: char, buffer: &mut String, iter: &mut Peekable<Chars<'_>>) {\n+    match c {\n+        '\"' | '\\'' => buffer.push_str(&get_string(iter, c)),\n+        '/' if iter.peek() == Some(&'*') => skip_comment(iter),\n+        '/' if iter.peek() == Some(&'/') => skip_line_comment(iter),\n+        _ => buffer.push(c),\n     }\n-    v[pos + 1] == b'/'\n }\n \n-fn load_css_events(v: &[u8]) -> Vec<Events> {\n-    let mut pos = 0;\n-    let mut events = Vec::with_capacity(100);\n-\n-    while pos + 1 < v.len() {\n-        match v[pos] {\n-            b'/' if v[pos + 1] == b'*' => {\n-                events.push(Events::StartComment(pos));\n-                pos += 1;\n-            }\n-            b'/' if is_line_comment(pos, v, &events) => {\n-                events.push(Events::StartLineComment(pos));\n-                pos += 1;\n-            }\n-            b'\\n' if previous_is_line_comment(&events) => {\n-                events.push(Events::EndComment(pos));\n-            }\n-            b'*' if v[pos + 1] == b'/' => {\n-                events.push(Events::EndComment(pos + 2));\n-                pos += 1;\n-            }\n-            b'{' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::InBlock(pos + 1));\n-            }\n-            b'}' if !previous_is_line_comment(&events) => {\n-                if let Some(&Events::StartComment(_)) = events.last() {\n-                    pos += 1;\n-                    continue;\n-                }\n-                events.push(Events::OutBlock(pos + 1));\n-            }\n-            _ => {}\n+/// Returns a CSS property name. Ends when encountering a `:` character.\n+///\n+/// If the `:` character isn't found, returns `None`.\n+///\n+/// If a `{` character is encountered, returns an error.\n+fn parse_property_name(iter: &mut Peekable<Chars<'_>>) -> Result<Option<String>, String> {\n+    let mut content = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ':' => return Ok(Some(content.trim().to_owned())),\n+            '{' => return Err(\"Unexpected `{` in a `{}` block\".to_owned()),\n+            '}' => break,\n+            _ => handle_common_chars(c, &mut content, iter),\n         }\n-        pos += 1;\n     }\n-    events\n-}\n-\n-fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n-    while *pos < events.len() {\n-        if !events[*pos].is_comment() {\n-            return Some(events[*pos]);\n+    Ok(None)\n+}\n+\n+/// Try to get the value of a CSS property (the `#fff` in `color: #fff`). It'll stop when it\n+/// encounters a `{` or a `;` character.\n+///\n+/// It returns the value string and a boolean set to `true` if the value is ended with a `}` because\n+/// it means that the parent block is done and that we should notify the parent caller.\n+fn parse_property_value(iter: &mut Peekable<Chars<'_>>) -> (String, bool) {\n+    let mut value = String::new();\n+    let mut out_block = false;\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            ';' => break,\n+            '}' => {\n+                out_block = true;\n+                break;\n+            }\n+            _ => handle_common_chars(c, &mut value, iter),\n         }\n-        *pos += 1;\n     }\n-    None\n+    (value.trim().to_owned(), out_block)\n }\n \n-fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n-    let mut ret = Vec::with_capacity(3);\n+/// This is used to parse inside a CSS `{}` block. If we encounter a new `{` inside it, we consider\n+/// it as a new block and therefore recurse into `parse_rules`.\n+fn parse_rules(\n+    content: &str,\n+    selector: String,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut rules = FxHashMap::default();\n+    let mut children = FxHashMap::default();\n \n-    ret.push(events[pos].get_pos());\n-    if pos > 0 {\n-        pos -= 1;\n-    }\n     loop {\n-        if pos < 1 || !events[pos].is_comment() {\n-            let x = events[pos].get_pos();\n-            if *ret.last().unwrap() != x {\n-                ret.push(x);\n-            } else {\n-                ret.push(0);\n+        // If the parent isn't a \"normal\" CSS selector, we only expect sub-selectors and not CSS\n+        // properties.\n+        if selector.starts_with('@') {\n+            parse_selectors(content, iter, &mut children)?;\n+            break;\n+        }\n+        let rule = match parse_property_name(iter)? {\n+            Some(r) => {\n+                if r.is_empty() {\n+                    return Err(format!(\"Found empty rule in selector `{selector}`\"));\n+                }\n+                r\n             }\n+            None => break,\n+        };\n+        let (value, out_block) = parse_property_value(iter);\n+        if value.is_empty() {\n+            return Err(format!(\"Found empty value for rule `{rule}` in selector `{selector}`\"));\n+        }\n+        match rules.entry(rule) {\n+            Entry::Occupied(mut o) => {\n+                eprintln!(\"Duplicated rule `{}` in CSS selector `{selector}`\", o.key());\n+                *o.get_mut() = value;\n+            }\n+            Entry::Vacant(v) => {\n+                v.insert(value);\n+            }\n+        }\n+        if out_block {\n             break;\n         }\n-        ret.push(events[pos].get_pos());\n-        pos -= 1;\n     }\n-    if ret.len() & 1 != 0 && events[pos].is_comment() {\n-        ret.push(0);\n-    }\n-    ret.iter().rev().cloned().collect()\n-}\n \n-fn build_rule(v: &[u8], positions: &[usize]) -> String {\n-    minifier::css::minify(\n-        &positions\n-            .chunks(2)\n-            .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n-            .collect::<String>()\n-            .trim()\n-            .chars()\n-            .filter_map(|c| match c {\n-                '\\n' | '\\t' => Some(' '),\n-                '/' | '{' | '}' => None,\n-                c => Some(c),\n-            })\n-            .collect::<String>()\n-            .split(' ')\n-            .filter(|s| !s.is_empty())\n-            .intersperse(\" \")\n-            .collect::<String>(),\n-    )\n-    .map(|css| css.to_string())\n-    .unwrap_or_else(|_| String::new())\n-}\n-\n-fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n-    let mut paths = Vec::with_capacity(50);\n-\n-    while *pos < events.len() {\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n-            break;\n+    match paths.entry(selector) {\n+        Entry::Occupied(mut o) => {\n+            eprintln!(\"Duplicated CSS selector: `{}`\", o.key());\n+            let v = o.get_mut();\n+            for (key, value) in rules.into_iter() {\n+                v.rules.insert(key, value);\n+            }\n+            for (sel, child) in children.into_iter() {\n+                v.children.insert(sel, child);\n+            }\n         }\n-        if let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            paths.push(CssPath::new(build_rule(v, &get_previous_positions(events, *pos))));\n-            *pos += 1;\n+        Entry::Vacant(v) => {\n+            v.insert(CssPath { rules, children });\n         }\n-        while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            if let Some(ref mut path) = paths.last_mut() {\n-                for entry in inner(v, events, pos).iter() {\n-                    path.children.insert(entry.clone());\n-                }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn parse_selectors(\n+    content: &str,\n+    iter: &mut Peekable<Chars<'_>>,\n+    paths: &mut FxHashMap<String, CssPath>,\n+) -> Result<(), String> {\n+    let mut selector = String::new();\n+\n+    while let Some(c) = iter.next() {\n+        match c {\n+            '{' => {\n+                let s = minifier::css::minify(selector.trim()).map(|s| s.to_string())?;\n+                parse_rules(content, s, iter, paths)?;\n+                selector.clear();\n             }\n-        }\n-        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            *pos += 1;\n+            '}' => break,\n+            ';' => selector.clear(), // We don't handle inline selectors like `@import`.\n+            _ => handle_common_chars(c, &mut selector, iter),\n         }\n     }\n-    paths.iter().cloned().collect()\n+    Ok(())\n }\n \n-pub(crate) fn load_css_paths(v: &[u8]) -> CssPath {\n-    let events = load_css_events(v);\n-    let mut pos = 0;\n+/// The entry point to parse the CSS rules. Every time we encounter a `{`, we then parse the rules\n+/// inside it.\n+pub(crate) fn load_css_paths(content: &str) -> Result<FxHashMap<String, CssPath>, String> {\n+    let mut iter = content.chars().peekable();\n+    let mut paths = FxHashMap::default();\n \n-    let mut parent = CssPath::new(\"parent\".to_owned());\n-    parent.children = inner(v, &events, &mut pos);\n-    parent\n+    parse_selectors(content, &mut iter, &mut paths)?;\n+    Ok(paths)\n }\n \n-pub(crate) fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n-    if against.name == other.name {\n-        for child in &against.children {\n-            let mut found = false;\n-            let mut found_working = false;\n-            let mut tmp = Vec::new();\n-\n-            for other_child in &other.children {\n-                if child.name == other_child.name {\n-                    if child != other_child {\n-                        get_differences(child, other_child, &mut tmp);\n-                    } else {\n-                        found_working = true;\n-                    }\n-                    found = true;\n-                    break;\n-                }\n-            }\n-            if !found {\n-                v.push(format!(\"  Missing \\\"{}\\\" rule\", child.name));\n-            } else if !found_working {\n-                v.extend(tmp.iter().cloned());\n-            }\n+pub(crate) fn get_differences(\n+    origin: &FxHashMap<String, CssPath>,\n+    against: &FxHashMap<String, CssPath>,\n+    v: &mut Vec<String>,\n+) {\n+    for (selector, entry) in origin.iter() {\n+        match against.get(selector) {\n+            Some(a) => get_differences(&a.children, &entry.children, v),\n+            None => v.push(format!(\"  Missing rule `{}`\", selector)),\n         }\n     }\n }\n \n pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n-    against: &CssPath,\n+    origin: &FxHashMap<String, CssPath>,\n     diag: &Handler,\n ) -> (bool, Vec<String>) {\n-    let data = match fs::read(f) {\n+    let against = match fs::read_to_string(f)\n+        .map_err(|e| e.to_string())\n+        .and_then(|data| load_css_paths(&data))\n+    {\n         Ok(c) => c,\n         Err(e) => {\n-            diag.struct_err(&e.to_string()).emit();\n+            diag.struct_err(&e).emit();\n             return (false, vec![]);\n         }\n     };\n \n-    let paths = load_css_paths(&data);\n     let mut ret = vec![];\n-    get_differences(against, &paths, &mut ret);\n+    get_differences(origin, &against, &mut ret);\n     (true, ret)\n }"}]}