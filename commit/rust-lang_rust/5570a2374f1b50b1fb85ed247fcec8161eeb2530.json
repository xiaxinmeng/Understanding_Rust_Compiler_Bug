{"sha": "5570a2374f1b50b1fb85ed247fcec8161eeb2530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NzBhMjM3NGYxYjUwYjFmYjg1ZWQyNDdmY2VjODE2MWVlYjI1MzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-19T05:57:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-19T05:57:32Z"}, "message": "Rollup merge of #69814 - jonas-schievink:gen-ret-unw, r=Zoxc\n\nSmaller and more correct generator codegen\n\nThis removes unnecessary panicking branches in the resume function when the generator can not return or unwind, respectively.\n\nCloses https://github.com/rust-lang/rust/issues/66100\n\nIt also addresses the correctness concerns wrt poisoning on unwind. These are not currently a soundness issue because any operation *inside* a generator that could possibly unwind will result in a cleanup path for dropping it, ultimately reaching a `Resume` terminator, which we already handled correctly. Future MIR optimizations might optimize that out, though.\n\nr? @Zoxc", "tree": {"sha": "4fc464ac8c09ee54a3e3c0daf5ece60487743edb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fc464ac8c09ee54a3e3c0daf5ece60487743edb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5570a2374f1b50b1fb85ed247fcec8161eeb2530", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecwnMCRBK7hj4Ov3rIwAAdHIIAFJfK/F4EuvUVQcdfGdM0/2A\nh2vtQ/XETANPU/jm0wPaDGybWczaT0N7zfAlqpitbamjQYBBZxK3H5Fnj3cdY9SV\n1W7PEMPJOuMxBv3NNKCO7d+sZTI8JyypQy028zaD45HSP2RUtvpmVfN3Crv2r2M2\nBXExDjEhq2PCv6ZudbwKiTBaISuNgrz9NlW+s2h1nioUGA7Gu4Mk59ykwmLMI8sj\nSw6MXV0LKnmqNo0dbbiJmlvHf/6kpsCoMbz7Vuu9ktOL+bGPS/lgJ/VgO22AN8Tm\nu2nPe6hr01XIXm68gPZfXlIY3gmOE5mQMfYnBhxUdmcPFr7T0S8wttTzZJSXsKQ=\n=Z1Yh\n-----END PGP SIGNATURE-----\n", "payload": "tree 4fc464ac8c09ee54a3e3c0daf5ece60487743edb\nparent 61fe2e4036cb8917372e42df66c54596a05d69b7\nparent 38fa3783ce635814b7e3814ab26d52b653fc0ab0\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584597452 +0100\ncommitter GitHub <noreply@github.com> 1584597452 +0100\n\nRollup merge of #69814 - jonas-schievink:gen-ret-unw, r=Zoxc\n\nSmaller and more correct generator codegen\n\nThis removes unnecessary panicking branches in the resume function when the generator can not return or unwind, respectively.\n\nCloses https://github.com/rust-lang/rust/issues/66100\n\nIt also addresses the correctness concerns wrt poisoning on unwind. These are not currently a soundness issue because any operation *inside* a generator that could possibly unwind will result in a cleanup path for dropping it, ultimately reaching a `Resume` terminator, which we already handled correctly. Future MIR optimizations might optimize that out, though.\n\nr? @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5570a2374f1b50b1fb85ed247fcec8161eeb2530", "html_url": "https://github.com/rust-lang/rust/commit/5570a2374f1b50b1fb85ed247fcec8161eeb2530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5570a2374f1b50b1fb85ed247fcec8161eeb2530/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fe2e4036cb8917372e42df66c54596a05d69b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fe2e4036cb8917372e42df66c54596a05d69b7", "html_url": "https://github.com/rust-lang/rust/commit/61fe2e4036cb8917372e42df66c54596a05d69b7"}, {"sha": "38fa3783ce635814b7e3814ab26d52b653fc0ab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/38fa3783ce635814b7e3814ab26d52b653fc0ab0", "html_url": "https://github.com/rust-lang/rust/commit/38fa3783ce635814b7e3814ab26d52b653fc0ab0"}], "stats": {"total": 145, "additions": 138, "deletions": 7}, "files": [{"sha": "b2906739ff1b1de3ffcc86b7ea62188712f31b8c", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 104, "deletions": 7, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5570a2374f1b50b1fb85ed247fcec8161eeb2530/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570a2374f1b50b1fb85ed247fcec8161eeb2530/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=5570a2374f1b50b1fb85ed247fcec8161eeb2530", "patch": "@@ -988,18 +988,101 @@ fn insert_panic_block<'tcx>(\n     assert_block\n }\n \n+fn can_return<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n+    // Returning from a function with an uninhabited return type is undefined behavior.\n+    if body.return_ty().conservative_is_privately_uninhabited(tcx) {\n+        return false;\n+    }\n+\n+    // If there's a return terminator the function may return.\n+    for block in body.basic_blocks() {\n+        if let TerminatorKind::Return = block.terminator().kind {\n+            return true;\n+        }\n+    }\n+\n+    // Otherwise the function can't return.\n+    false\n+}\n+\n+fn can_unwind<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> bool {\n+    // Nothing can unwind when landing pads are off.\n+    if tcx.sess.no_landing_pads() {\n+        return false;\n+    }\n+\n+    // Unwinds can only start at certain terminators.\n+    for block in body.basic_blocks() {\n+        match block.terminator().kind {\n+            // These never unwind.\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+\n+            // Resume will *continue* unwinding, but if there's no other unwinding terminator it\n+            // will never be reached.\n+            TerminatorKind::Resume => {}\n+\n+            TerminatorKind::Yield { .. } => {\n+                unreachable!(\"`can_unwind` called before generator transform\")\n+            }\n+\n+            // These may unwind.\n+            TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::Assert { .. } => return true,\n+        }\n+    }\n+\n+    // If we didn't find an unwinding terminator, the function cannot unwind.\n+    false\n+}\n+\n fn create_generator_resume_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     transform: TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n     body: &mut BodyAndCache<'tcx>,\n+    can_return: bool,\n ) {\n+    let can_unwind = can_unwind(tcx, body);\n+\n     // Poison the generator when it unwinds\n-    for block in body.basic_blocks_mut() {\n-        let source_info = block.terminator().source_info;\n-        if let &TerminatorKind::Resume = &block.terminator().kind {\n-            block.statements.push(transform.set_discr(VariantIdx::new(POISONED), source_info));\n+    if can_unwind {\n+        let poison_block = BasicBlock::new(body.basic_blocks().len());\n+        let source_info = source_info(body);\n+        body.basic_blocks_mut().push(BasicBlockData {\n+            statements: vec![transform.set_discr(VariantIdx::new(POISONED), source_info)],\n+            terminator: Some(Terminator { source_info, kind: TerminatorKind::Resume }),\n+            is_cleanup: true,\n+        });\n+\n+        for (idx, block) in body.basic_blocks_mut().iter_enumerated_mut() {\n+            let source_info = block.terminator().source_info;\n+\n+            if let TerminatorKind::Resume = block.terminator().kind {\n+                // An existing `Resume` terminator is redirected to jump to our dedicated\n+                // \"poisoning block\" above.\n+                if idx != poison_block {\n+                    *block.terminator_mut() = Terminator {\n+                        source_info,\n+                        kind: TerminatorKind::Goto { target: poison_block },\n+                    };\n+                }\n+            } else if !block.is_cleanup {\n+                // Any terminators that *can* unwind but don't have an unwind target set are also\n+                // pointed at our poisoning block (unless they're part of the cleanup path).\n+                if let Some(unwind @ None) = block.terminator_mut().unwind_mut() {\n+                    *unwind = Some(poison_block);\n+                }\n+            }\n         }\n     }\n \n@@ -1012,8 +1095,20 @@ fn create_generator_resume_function<'tcx>(\n \n     // Panic when resumed on the returned or poisoned state\n     let generator_kind = body.generator_kind.unwrap();\n-    cases.insert(1, (RETURNED, insert_panic_block(tcx, body, ResumedAfterReturn(generator_kind))));\n-    cases.insert(2, (POISONED, insert_panic_block(tcx, body, ResumedAfterPanic(generator_kind))));\n+\n+    if can_unwind {\n+        cases.insert(\n+            1,\n+            (POISONED, insert_panic_block(tcx, body, ResumedAfterPanic(generator_kind))),\n+        );\n+    }\n+\n+    if can_return {\n+        cases.insert(\n+            1,\n+            (RETURNED, insert_panic_block(tcx, body, ResumedAfterReturn(generator_kind))),\n+        );\n+    }\n \n     insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n \n@@ -1197,6 +1292,8 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let (remap, layout, storage_liveness) =\n             compute_layout(tcx, source, &upvars, interior, movable, body);\n \n+        let can_return = can_return(tcx, body);\n+\n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n         // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n@@ -1240,6 +1337,6 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         body.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, def_id, source, body);\n+        create_generator_resume_function(tcx, transform, def_id, source, body, can_return);\n     }\n }"}, {"sha": "09e943bd962e64489ff25db8b0283dc08c559357", "filename": "src/test/mir-opt/generator-tiny.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5570a2374f1b50b1fb85ed247fcec8161eeb2530/src%2Ftest%2Fmir-opt%2Fgenerator-tiny.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570a2374f1b50b1fb85ed247fcec8161eeb2530/src%2Ftest%2Fmir-opt%2Fgenerator-tiny.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-tiny.rs?ref=5570a2374f1b50b1fb85ed247fcec8161eeb2530", "patch": "@@ -0,0 +1,34 @@\n+//! Tests that generators that cannot return or unwind don't have unnecessary\n+//! panic branches.\n+\n+// compile-flags: -Zno-landing-pads\n+\n+#![feature(generators, generator_trait)]\n+\n+struct HasDrop;\n+\n+impl Drop for HasDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+fn callee() {}\n+\n+fn main() {\n+    let _gen = |_x: u8| {\n+        let _d = HasDrop;\n+        loop {\n+            yield;\n+            callee();\n+        }\n+    };\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.main-{{closure}}.generator_resume.0.mir\n+// bb0: {\n+//     ...\n+//     switchInt(move _11) -> [0u32: bb1, 3u32: bb5, otherwise: bb6];\n+// }\n+// ...\n+// END rustc.main-{{closure}}.generator_resume.0.mir"}]}