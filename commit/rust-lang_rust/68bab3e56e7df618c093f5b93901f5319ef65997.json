{"sha": "68bab3e56e7df618c093f5b93901f5319ef65997", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YmFiM2U1NmU3ZGY2MThjMDkzZjViOTM5MDFmNTMxOWVmNjU5OTc=", "commit": {"author": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2020-05-22T19:41:24Z"}, "committer": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2020-05-25T11:30:55Z"}, "message": "Add total_cmp to f32 and f64, plus tests", "tree": {"sha": "b1ca87802092315af9b9f22c527fadae34142793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ca87802092315af9b9f22c527fadae34142793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68bab3e56e7df618c093f5b93901f5319ef65997", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68bab3e56e7df618c093f5b93901f5319ef65997", "html_url": "https://github.com/rust-lang/rust/commit/68bab3e56e7df618c093f5b93901f5319ef65997", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68bab3e56e7df618c093f5b93901f5319ef65997/comments", "author": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "html_url": "https://github.com/rust-lang/rust/commit/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d"}], "stats": {"total": 433, "additions": 433, "deletions": 0}, "files": [{"sha": "47f489c40abb1b166d65c2a9261fc3d0cc98eda3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=68bab3e56e7df618c093f5b93901f5319ef65997", "patch": "@@ -810,4 +810,77 @@ impl f32 {\n     pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n         Self::from_bits(u32::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f32,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"total_cmp\", issue = \"none\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i32;\n+        let mut right = other.to_bits() as i32;\n+\n+        // In case of negatives, flip all the bits expect the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        if left < 0 {\n+            // i32::MAX corresponds the bit pattern of \"all ones expect for the sign bit\"\n+            left ^= i32::MAX\n+        };\n+        if right < 0 {\n+            right ^= i32::MAX\n+        };\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "9c02180838014dc1a37d401cc20dfd6db60fc1cc", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=68bab3e56e7df618c093f5b93901f5319ef65997", "patch": "@@ -824,4 +824,77 @@ impl f64 {\n     pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n         Self::from_bits(u64::from_ne_bytes(bytes))\n     }\n+\n+    /// Returns an ordering between self and other values.\n+    /// Unlike the standard partial comparison between floating point numbers,\n+    /// this comparison always produces an ordering in accordance to\n+    /// the totalOrder predicate as defined in IEEE 754 (2008 revision)\n+    /// floating point standard. The values are ordered in following order:\n+    /// - Negative quiet NaN\n+    /// - Negative signaling NaN\n+    /// - Negative infinity\n+    /// - Negative numbers\n+    /// - Negative subnormal numbers\n+    /// - Negative zero\n+    /// - Positive zero\n+    /// - Positive subnormal numbers\n+    /// - Positive numbers\n+    /// - Positive infinity\n+    /// - Positive signaling NaN\n+    /// - Positive quiet NaN\n+    ///\n+    /// # Example\n+    /// ```\n+    /// #![feature(total_cmp)]\n+    /// struct GoodBoy {\n+    ///     name: String,\n+    ///     weight: f64,\n+    /// }\n+    ///\n+    /// let mut bois = vec![\n+    ///     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n+    ///     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n+    ///     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n+    ///     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n+    ///     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n+    ///     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n+    /// ];\n+    ///\n+    /// bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n+    /// # assert!(bois.into_iter().map(|b| b.weight)\n+    /// #     .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n+    /// #     .all(|(a, b)| a.to_bits() == b.to_bits()))\n+    /// ```\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"total_cmp\", issue = \"none\")]\n+    #[inline]\n+    pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        let mut left = self.to_bits() as i64;\n+        let mut right = other.to_bits() as i64;\n+\n+        // In case of negatives, flip all the bits expect the sign\n+        // to achieve a similar layout as two's complement integers\n+        //\n+        // Why does this work? IEEE 754 floats consist of three fields:\n+        // Sign bit, exponent and mantissa. The set of exponent and mantissa\n+        // fields as a whole have the property that their bitwise order is\n+        // equal to the numeric magnitude where the magnitude is defined.\n+        // The magnitude is not normally defined on NaN values, but\n+        // IEEE 754 totalOrder defines the NaN values also to follow the\n+        // bitwise order. This leads to order explained in the doc comment.\n+        // However, the representation of magnitude is the same for negative\n+        // and positive numbers \u2013 only the sign bit is different.\n+        // To easily compare the floats as signed integers, we need to\n+        // flip the exponent and mantissa bits in case of negative numbers.\n+        // We effectively convert the numbers to \"two's complement\" form.\n+        if left < 0 {\n+            // i64::MAX corresponds the bit pattern of \"all ones expect for the sign bit\"\n+            left ^= i64::MAX\n+        };\n+        if right < 0 {\n+            right ^= i64::MAX\n+        };\n+\n+        left.cmp(&right)\n+    }\n }"}, {"sha": "c5d8bb4fcf24342b3bf9d45b8721df101784430a", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=68bab3e56e7df618c093f5b93901f5319ef65997", "patch": "@@ -1531,4 +1531,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f32.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u32 {\n+            1 << (f32::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f32 {\n+            f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f32 {\n+            f32::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f32 {\n+            f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f32 {\n+            f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "eae8a04bfc6377b8708187323209cba8ed2ed507", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=68bab3e56e7df618c093f5b93901f5319ef65997", "patch": "@@ -1554,4 +1554,147 @@ mod tests {\n     fn test_clamp_max_is_nan() {\n         let _ = 1.0f64.clamp(3.0, NAN);\n     }\n+\n+    #[test]\n+    fn test_total_cmp() {\n+        use core::cmp::Ordering;\n+\n+        fn quiet_bit_mask() -> u64 {\n+            1 << (f64::MANTISSA_DIGITS - 2)\n+        }\n+\n+        fn min_subnorm() -> f64 {\n+            f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n+        }\n+\n+        fn max_subnorm() -> f64 {\n+            f64::MIN_POSITIVE - min_subnorm()\n+        }\n+\n+        fn q_nan() -> f64 {\n+            f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n+        }\n+\n+        fn s_nan() -> f64 {\n+            f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+        }\n+\n+        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n+        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n+        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n+        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n+        assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n+        assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n+        assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n+        assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n+        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+    }\n }"}, {"sha": "468ac7bb5e873899db3199582c7eab9dd6bbec2b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68bab3e56e7df618c093f5b93901f5319ef65997/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=68bab3e56e7df618c093f5b93901f5319ef65997", "patch": "@@ -308,6 +308,7 @@\n #![feature(test)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n+#![feature(total_cmp)]\n #![feature(trace_macros)]\n #![feature(track_caller)]\n #![feature(try_reserve)]"}]}