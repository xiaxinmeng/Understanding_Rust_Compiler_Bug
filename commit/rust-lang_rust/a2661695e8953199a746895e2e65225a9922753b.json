{"sha": "a2661695e8953199a746895e2e65225a9922753b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjYxNjk1ZTg5NTMxOTlhNzQ2ODk1ZTJlNjUyMjVhOTkyMjc1M2I=", "commit": {"author": {"name": "Sebastian Imlay", "email": "sebastian@easypost.com", "date": "2020-02-14T18:57:45Z"}, "committer": {"name": "Sebastian Imlay", "email": "sebastian@easypost.com", "date": "2020-02-14T18:57:45Z"}, "message": "Merge branch 'master' of github.com:rust-lang/rust into add-tvSO-target", "tree": {"sha": "3e88fd5c2b598f50c919ad1e5ee5cb2abe5b5886", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e88fd5c2b598f50c919ad1e5ee5cb2abe5b5886"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2661695e8953199a746895e2e65225a9922753b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2661695e8953199a746895e2e65225a9922753b", "html_url": "https://github.com/rust-lang/rust/commit/a2661695e8953199a746895e2e65225a9922753b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2661695e8953199a746895e2e65225a9922753b/comments", "author": null, "committer": null, "parents": [{"sha": "35c4aae99ece980c7c594940724f0728fcccf226", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c4aae99ece980c7c594940724f0728fcccf226", "html_url": "https://github.com/rust-lang/rust/commit/35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "e168dcd254d0a6a0cbaad5f2c054ce5116a07119", "url": "https://api.github.com/repos/rust-lang/rust/commits/e168dcd254d0a6a0cbaad5f2c054ce5116a07119", "html_url": "https://github.com/rust-lang/rust/commit/e168dcd254d0a6a0cbaad5f2c054ce5116a07119"}], "stats": {"total": 108423, "additions": 68587, "deletions": 39836}, "files": [{"sha": "9aef3ebe637a1d1b325266165389786032876f93", "filename": ".github/ISSUE_TEMPLATE/blank_issue.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,4 @@\n+---\n+name: Blank Issue\n+about: Create a blank issue.\n+---"}, {"sha": "5675579bc964a6aab3827db3b3c519c731f98143", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,44 @@\n+---\n+name: Bug Report\n+about: Create a bug report for Rust.\n+labels: C-bug\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary>Backtrace</summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>"}, {"sha": "bd7dc0ac95c1fc6a4c96c7357315f779daf77aef", "filename": ".github/ISSUE_TEMPLATE/config.yml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fconfig.yml?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,5 @@\n+blank_issues_enabled: true\n+contact_links:\n+  - name: Rust Programming Language Forum\n+    url: https://users.rust-lang.org\n+    about: Please ask and answer questions about Rust here."}, {"sha": "e669e4912f8c95c2b54a6beea4d428407a2cbd18", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,52 @@\n+---\n+name: Internal Compiler Error\n+about: Create a report for an internal compiler error in rustc.\n+labels: C-bug, I-ICE, T-compiler\n+---\n+<!--\n+Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n+a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n+how to create smaller examples.\n+\n+http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n+\n+-->\n+\n+### Code\n+\n+```\n+<code>\n+```\n+\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+### Error output\n+\n+```\n+<output>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary><strong>Backtrace</strong></summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>\n+"}, {"sha": "f93591204cd98cbdff70b5c4341c60d56c105995", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,58 @@\n+---\n+name: Tracking Issue\n+about: A tracking issue for a feature in Rust.\n+title: Tracking Issue for XXX\n+labels: C-tracking-issue\n+---\n+<!--\n+Thank you for creating a tracking issue! \ud83d\udcdc Tracking issues are for tracking a\n+feature from implementation to stabilisation. Make sure to include the relevant\n+RFC for the feature if it has one. Otherwise provide a short summary of the\n+feature and link any relevant PRs or issues, and remove any sections that are\n+not relevant to the feature.\n+\n+Remember to add team labels to the tracking issue.\n+For a language team feature, this would e.g., be `T-lang`.\n+Such a feature should also be labeled with e.g., `F-my_feature`.\n+This label is used to associate issues (e.g., bugs and design questions) to the feature.\n+-->\n+\n+This is a tracking issue for the RFC \"XXX\" (rust-lang/rfcs#NNN).\n+The feature gate for the issue is `#![feature(FFF)]`.\n+\n+### About tracking issues\n+\n+Tracking issues are used to record the overall progress of implementation.\n+They are also uses as hubs connecting to other relevant issues, e.g., bugs or open design questions.\n+A tracking issue is however *not* meant for large scale discussion, questions, or bug reports about a feature.\n+Instead, open a dedicated issue for the specific matter and add the relevant feature gate label.\n+\n+### Steps\n+<!--\n+Include each step required to complete the feature. Typically this is a PR\n+implementing a feature, followed by a PR that stabilises the feature. However\n+for larger features an implementation could be broken up into multiple PRs.\n+-->\n+\n+- [ ] Implement the RFC (cc @rust-lang/XXX -- can anyone write up mentoring\n+      instructions?)\n+- [ ] Adjust documentation ([see instructions on rustc-guide][doc-guide])\n+- [ ] Stabilization PR ([see instructions on rustc-guide][stabilization-guide])\n+\n+[stabilization-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#stabilization-pr\n+[doc-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs\n+\n+### Unresolved Questions\n+<!--\n+Include any open questions that need to be answered before the feature can be\n+stabilised.\n+-->\n+\n+XXX --- list all the \"unresolved questions\" found in the RFC to ensure they are\n+not forgotten\n+\n+### Implementation history\n+\n+<!--\n+Include a list of all the PRs that were involved in implementing the feature.\n+-->"}, {"sha": "d9761ce40927ce92d29daa23b4496e04b9e97e4f", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -34,14 +34,7 @@ __pycache__/\n # Created by default with `src/ci/docker/run.sh`:\n /obj/\n /rustllvm/\n-/src/libcore/unicode/DerivedCoreProperties.txt\n-/src/libcore/unicode/DerivedNormalizationProps.txt\n-/src/libcore/unicode/PropList.txt\n-/src/libcore/unicode/ReadMe.txt\n-/src/libcore/unicode/Scripts.txt\n-/src/libcore/unicode/SpecialCasing.txt\n-/src/libcore/unicode/UnicodeData.txt\n-/src/libcore/unicode/downloaded\n+/unicode-downloads\n /target/\n # Generated by compiletest for incremental:\n /tmp/"}, {"sha": "003e50d0788e4c6efb0d4315556a8c1ce0cf73ef", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -15,13 +15,13 @@\n \turl = https://github.com/rust-lang/book.git\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n-\turl = https://github.com/rust-lang-nursery/rls.git\n+\turl = https://github.com/rust-lang/rls.git\n [submodule \"src/tools/clippy\"]\n \tpath = src/tools/clippy\n-\turl = https://github.com/rust-lang-nursery/rust-clippy.git\n+\turl = https://github.com/rust-lang/rust-clippy.git\n [submodule \"src/tools/rustfmt\"]\n \tpath = src/tools/rustfmt\n-\turl = https://github.com/rust-lang-nursery/rustfmt.git\n+\turl = https://github.com/rust-lang/rustfmt.git\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/rust-lang/miri.git\n@@ -40,7 +40,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-09-19\n+\tbranch = rustc/9.0-2019-12-19\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "e5aad52ef4b792b1d1f52e23a100a5fea6b38f12", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -100,6 +100,7 @@ Graydon Hoare <graydon@pobox.com> Graydon Hoare <graydon@mozilla.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com> ggomez <ggomez@ggo.ifr.lan>\n Guillaume Gomez <guillaume1.gomez@gmail.com> Guillaume Gomez <ggomez@ggo.ifr.lan>\n+Hanna Kruppe <hanna.kruppe@gmail.com> <robin.kruppe@gmail.com>\n Heather <heather@cynede.net> <Cynede@Gentoo.org>\n Heather <heather@cynede.net> <Heather@cynede.net>\n Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtke@gmail.com>\n@@ -113,6 +114,7 @@ James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n Jason Fager <jfager@gmail.com>\n+Jason Liquorish <jason@liquori.sh> <Bassetts@users.noreply.github.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason.orendorff@gmail.com>\n Jason Orendorff <jorendorff@mozilla.com> <jason@mozmac-2.local>\n Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n@@ -211,6 +213,7 @@ Peter Liniker <peter.liniker+github@gmail.com>\n Phil Dawes <phil@phildawes.net> Phil Dawes <pdawes@drw.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n+Philipp Krones <hello@philkrones.com> flip1995 <hello@philkrones.com>\n Philipp Matthias Sch\u00e4fer <philipp.matthias.schaefer@posteo.de>\n Przemys\u0142aw Weso\u0142ek <jest@go.art.pl> Przemek Weso\u0142ek <jest@go.art.pl>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com> Rafael Avila de Espindola <espindola@dream.(none)>"}, {"sha": "d6840b20c89ac013d612c527d15fdca7552c825c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -50,6 +50,9 @@ is a bug or not, feel free to file a bug anyway.\n **If you believe reporting your bug publicly represents a security risk to Rust users,\n please follow our [instructions for reporting security vulnerabilities](https://www.rust-lang.org/policies/security)**.\n \n+If you're using the nightly channel, please check if the bug exists in the\n+latest toolchain before filing your bug. It might be fixed already.\n+\n If you have the chance, before reporting a bug, please [search existing\n issues](https://github.com/rust-lang/rust/search?q=&type=Issues&utf8=%E2%9C%93),\n as it's possible that someone else has already reported your error. This doesn't"}, {"sha": "f44644cffa62ab2f4e8e15d7114a385c885521de", "filename": "Cargo.lock", "status": "modified", "additions": 504, "deletions": 298, "changes": 802, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,7 +21,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"rand_xorshift 0.2.0\",\n ]\n \n@@ -32,7 +32,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n dependencies = [\n  \"html5ever\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"maplit\",\n  \"matches\",\n  \"tendril\",\n@@ -57,6 +57,12 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7825f6833612eb2414095684fcf6c635becf3ce97fe48cf6421321e93bfbd53c\"\n+\n [[package]]\n name = \"arc-swap\"\n version = \"0.3.7\"\n@@ -109,15 +115,15 @@ dependencies = [\n \n [[package]]\n name = \"autocfg\"\n-version = \"0.1.6\"\n+version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b671c8fb71b457dd4ae18c4ba1e59aa81793daacc361d82fcd410cef0d491875\"\n+checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.40\"\n+version = \"0.3.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n+checksum = \"e4036b9bf40f3cf16aba72a3d65e8a520fc4bafcdc7079aea8f848c58c5b5536\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -193,14 +199,15 @@ dependencies = [\n  \"filetime\",\n  \"getopts\",\n  \"ignore\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"libc\",\n  \"num_cpus\",\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\",\n  \"time\",\n  \"toml\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -265,18 +272,18 @@ checksum = \"716960a18f978640f25101b5cbf1c6f6b0d3192fab36a2d98ca96f0ecbe41010\"\n \n [[package]]\n name = \"c2-chacha\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d64d04786e0f528460fc884753cf8dddcc466be308f6026f8e355c41a0e4101\"\n+checksum = \"214238caa1bf3a496ec3392968969cab8549f96ff30652c9e56885329315f6bb\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n  \"ppv-lite86\",\n ]\n \n [[package]]\n name = \"cargo\"\n-version = \"0.43.0\"\n+version = \"0.44.0\"\n dependencies = [\n+ \"anyhow\",\n  \"atty\",\n  \"bytesize\",\n  \"cargo-platform\",\n@@ -285,12 +292,12 @@ dependencies = [\n  \"clap\",\n  \"core-foundation 0.7.0\",\n  \"crates-io\",\n+ \"crossbeam-channel\",\n  \"crossbeam-utils 0.7.0\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n  \"env_logger 0.7.1\",\n- \"failure\",\n  \"filetime\",\n  \"flate2\",\n  \"fs2\",\n@@ -300,11 +307,11 @@ dependencies = [\n  \"glob\",\n  \"hex 0.4.0\",\n  \"home\",\n- \"humantime\",\n+ \"humantime 2.0.0\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"lazycell\",\n  \"libc\",\n  \"libgit2-sys\",\n@@ -318,7 +325,7 @@ dependencies = [\n  \"pretty_env_logger\",\n  \"remove_dir_all\",\n  \"rustc-workspace-hack\",\n- \"rustfix\",\n+ \"rustfix 0.5.0\",\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n@@ -357,7 +364,7 @@ dependencies = [\n  \"flate2\",\n  \"git2\",\n  \"glob\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"remove_dir_all\",\n  \"serde_json\",\n  \"tar\",\n@@ -395,19 +402,18 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.49\"\n+version = \"1.0.50\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e450b8da92aa6f274e7c6437692f9f2ce6d701fb73bacfcf87897b3f89a4c20e\"\n+checksum = \"95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd\"\n dependencies = [\n  \"jobserver\",\n- \"num_cpus\",\n ]\n \n [[package]]\n name = \"cfg-if\"\n-version = \"0.1.8\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"89431bba4e6b7092fb5fcd00a6f6ca596c55cc26b2f1e6dcdd08a1f4933f66b2\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -469,7 +475,7 @@ dependencies = [\n  \"compiletest_rs\",\n  \"derive-new\",\n  \"git2\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n@@ -490,7 +496,7 @@ dependencies = [\n  \"cargo_metadata 0.9.0\",\n  \"if_chain\",\n  \"itertools 0.8.0\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"matches\",\n  \"pulldown-cmark 0.6.1\",\n  \"quine-mc_cluskey\",\n@@ -514,9 +520,9 @@ dependencies = [\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.38\"\n+version = \"0.1.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96210eec534fc3fbfc0452a63769424eaa80205fda6cea98e5b61cb3d97bcec8\"\n+checksum = \"81fb25b677f8bf1eb325017cb6bb8452f87969db0fedb4f757b297bee78a7c62\"\n dependencies = [\n  \"cc\",\n ]\n@@ -570,9 +576,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.22\"\n+version = \"0.1.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6f083abf9bb9005a27d2da62706f661245278cb7096da37ab27410eaf60f2c1\"\n+checksum = \"438ac08ddc5efe81452f984a9e33ba425b00b31d1f48e6acd9e2210aa28cc52e\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -585,12 +591,12 @@ dependencies = [\n  \"diff\",\n  \"env_logger 0.7.1\",\n  \"getopts\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"libc\",\n  \"log\",\n  \"miow 0.3.3\",\n  \"regex\",\n- \"rustfix\",\n+ \"rustfix 0.5.0\",\n  \"serde\",\n  \"serde_json\",\n  \"walkdir\",\n@@ -610,7 +616,7 @@ dependencies = [\n  \"log\",\n  \"miow 0.3.3\",\n  \"regex\",\n- \"rustfix\",\n+ \"rustfix 0.4.6\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -657,7 +663,7 @@ dependencies = [\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -694,10 +700,10 @@ checksum = \"b3a71ab494c0b5b860bdc8407ae08978052417070c2ced38573a9157ad75b8ac\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.30.0\"\n+version = \"0.31.0\"\n dependencies = [\n+ \"anyhow\",\n  \"curl\",\n- \"failure\",\n  \"percent-encoding 2.1.0\",\n  \"serde\",\n  \"serde_derive\",\n@@ -716,12 +722,11 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.3.8\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f0ed1a4de2235cabda8558ff5840bffb97fcb64c97827f354a451307df5f72b\"\n+checksum = \"acec9a3b0b3559f15aee4f90746c4e5e293b701c0f7d3925d24e01645267b68c\"\n dependencies = [\n- \"crossbeam-utils 0.6.5\",\n- \"smallvec 0.6.10\",\n+ \"crossbeam-utils 0.7.0\",\n ]\n \n [[package]]\n@@ -743,7 +748,7 @@ dependencies = [\n  \"arrayvec\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"memoffset\",\n  \"scopeguard\",\n ]\n@@ -764,7 +769,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f8306fcef4a7b563b76b7dd949ca48f52bc1141aa067d2ea09565f3e2652aa5c\"\n dependencies = [\n  \"cfg-if\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n ]\n \n [[package]]\n@@ -775,7 +780,7 @@ checksum = \"ce446db02cdc3165b94ae73111e570793400d0794e46125cc4056c81cbb039f4\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n ]\n \n [[package]]\n@@ -792,9 +797,9 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.24\"\n+version = \"0.4.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d08ad3cb89d076a36b0ce5749eec2c9964f70c0c58480ab6b75a91ec4fc206d8\"\n+checksum = \"06aa71e9208a54def20792d877bc663d6aae0732b9852e612c4a933177c31283\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n@@ -807,9 +812,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.22\"\n+version = \"0.4.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e9a9a4e417722876332136a00cacf92c2ceb331fab4b52b6a1ad16c6cd79255\"\n+checksum = \"0c38ca47d60b86d0cc9d42caa90a0885669c2abc9791f871c81f58cdf39e979b\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -874,14 +879,13 @@ dependencies = [\n \n [[package]]\n name = \"derive_more\"\n-version = \"0.13.0\"\n+version = \"0.99.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n+checksum = \"2159be042979966de68315bce7034bb000c775f22e3e834e1c52ff78f041cae8\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"rustc_version\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -972,7 +976,7 @@ version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n@@ -1006,7 +1010,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n dependencies = [\n  \"atty\",\n- \"humantime\",\n+ \"humantime 1.3.0\",\n  \"log\",\n  \"regex\",\n  \"termcolor\",\n@@ -1019,7 +1023,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36\"\n dependencies = [\n  \"atty\",\n- \"humantime\",\n+ \"humantime 1.3.0\",\n  \"log\",\n  \"regex\",\n  \"termcolor\",\n@@ -1072,13 +1076,14 @@ checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.4\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n+checksum = \"1ff6d4dab0aa0c8e6346d46052e93b13a16cf847b54ed357087c35011048cc7d\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -1238,13 +1243,13 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.12\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n+checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"wasi 0.7.0\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -1322,7 +1327,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n dependencies = [\n  \"hashbrown 0.5.0\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"pest\",\n  \"pest_derive\",\n@@ -1447,6 +1452,12 @@ dependencies = [\n  \"quick-error\",\n ]\n \n+[[package]]\n+name = \"humantime\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b9b6c53306532d3c8e8087b44e6580e10db51a023cf9b433cea2ac38066b92da\"\n+\n [[package]]\n name = \"hyper\"\n version = \"0.12.31\"\n@@ -1526,18 +1537,18 @@ checksum = \"c3360c7b59e5ffa2653671fb74b4741a5d343c03f331c0a4aeda42b5c2b0ec7d\"\n \n [[package]]\n name = \"ignore\"\n-version = \"0.4.10\"\n+version = \"0.4.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ec16832258409d571aaef8273f3c3cc5b060d784e159d1a0f3b0017308f84a7\"\n+checksum = \"522daefc3b69036f80c7d2990b28ff9e0471c683bad05ca258e0a01dd22c5a1e\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"globset\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"memchr\",\n  \"regex\",\n  \"same-file\",\n- \"thread_local\",\n+ \"thread_local 1.0.1\",\n  \"walkdir\",\n  \"winapi-util\",\n ]\n@@ -1569,7 +1580,7 @@ dependencies = [\n  \"clap\",\n  \"failure\",\n  \"flate2\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"num_cpus\",\n  \"rayon\",\n  \"remove_dir_all\",\n@@ -1581,12 +1592,11 @@ dependencies = [\n \n [[package]]\n name = \"iovec\"\n-version = \"0.1.2\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n+checksum = \"b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e\"\n dependencies = [\n  \"libc\",\n- \"winapi 0.2.8\",\n ]\n \n [[package]]\n@@ -1632,13 +1642,11 @@ dependencies = [\n \n [[package]]\n name = \"jobserver\"\n-version = \"0.1.16\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f74e73053eaf95399bf926e48fc7a2a3ce50bd0eaaa2357d391e95b2dcdd4f10\"\n+checksum = \"5c71313ebb9439f74b00d9d2dcec36440beaf57a6aa0623068441dd7cd81a7f2\"\n dependencies = [\n  \"libc\",\n- \"log\",\n- \"rand 0.7.0\",\n ]\n \n [[package]]\n@@ -1649,9 +1657,9 @@ checksum = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \n [[package]]\n name = \"jsonrpc-client-transports\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39577db48b004cffb4c5b8e5c9b993c177c52599ecbee88711e815acf65144db\"\n+checksum = \"0a9ae166c4d1f702d297cd76d4b55758ace80272ffc6dbb139fdc1bf810de40b\"\n dependencies = [\n  \"failure\",\n  \"futures\",\n@@ -1668,9 +1676,9 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"13.2.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91d767c183a7e58618a609499d359ce3820700b3ebb4823a18c343b4a2a41a0d\"\n+checksum = \"fe3b688648f1ef5d5072229e2d672ecb92cbff7d1c79bcf3fd5898f3f3df0970\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1681,63 +1689,62 @@ dependencies = [\n \n [[package]]\n name = \"jsonrpc-core-client\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f047c10738edee7c3c6acf5241a0ce33df32ef9230c1a7fb03e4a77ee72c992f\"\n+checksum = \"080dc110be17701097df238fad3c816d4a478a1899dfbcf8ec8957dd40ec7304\"\n dependencies = [\n  \"jsonrpc-client-transports\",\n ]\n \n [[package]]\n name = \"jsonrpc-derive\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29f9149f785deaae92a4c834a9a1a83a4313b8cfedccf15362cd4cf039a64501\"\n+checksum = \"8609af8f63b626e8e211f52441fcdb6ec54f1a446606b10d5c89ae9bf8a20058\"\n dependencies = [\n  \"proc-macro-crate\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n name = \"jsonrpc-ipc-server\"\n-version = \"13.1.0\"\n+version = \"14.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"256c5e4292c17b4c2ecdf542299dc8e9d6b3939c075c54825570ad9317fe5751\"\n+checksum = \"b579cd0840d7db3ebaadf52f6f31ec601a260e78d610e44f68634f919e34497a\"\n dependencies = [\n  \"jsonrpc-core\",\n  \"jsonrpc-server-utils\",\n  \"log\",\n  \"parity-tokio-ipc\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"tokio-service\",\n ]\n \n [[package]]\n name = \"jsonrpc-pubsub\"\n-version = \"13.1.0\"\n+version = \"14.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2c08b444cc0ed70263798834343d0ac875e664257df8079160f23ac1ea79446\"\n+checksum = \"5b31c9b90731276fdd24d896f31bb10aecf2e5151733364ae81123186643d939\"\n dependencies = [\n  \"jsonrpc-core\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.10.0\",\n  \"serde\",\n ]\n \n [[package]]\n name = \"jsonrpc-server-utils\"\n-version = \"13.1.0\"\n+version = \"14.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44561bfdd31401bad790527f1e951dde144f2341ddc3e1b859d32945e1a34eff\"\n+checksum = \"95b7635e618a0edbbe0d2a2bbbc69874277c49383fcf6c3c0414491cfb517d22\"\n dependencies = [\n  \"bytes\",\n  \"globset\",\n  \"jsonrpc-core\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n- \"num_cpus\",\n  \"tokio\",\n  \"tokio-codec\",\n  \"unicase\",\n@@ -1761,9 +1768,9 @@ checksum = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n \n [[package]]\n name = \"lazy_static\"\n-version = \"1.3.0\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n+checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"lazycell\"\n@@ -1796,19 +1803,19 @@ dependencies = [\n \n [[package]]\n name = \"libnghttp2-sys\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d75d7966bda4730b722d1eab8e668df445368a24394bae9fc1e8dc0ab3dbe4f4\"\n+checksum = \"02254d44f4435dd79e695f2c2b83cd06a47919adea30216ceaf0c57ca0a72463\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n ]\n \n [[package]]\n name = \"libssh2-sys\"\n-version = \"0.2.11\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"126a1f4078368b163bfdee65fbab072af08a1b374a5551b21e87ade27b1fbf9d\"\n+checksum = \"36aa6e813339d3a063292b77091dfbbb6152ff9006a459895fa5bebed7d34f10\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1858,7 +1865,7 @@ version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n ]\n \n [[package]]\n@@ -1951,7 +1958,7 @@ dependencies = [\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"memchr\",\n  \"open\",\n@@ -1995,13 +2002,13 @@ dependencies = [\n \n [[package]]\n name = \"measureme\"\n-version = \"0.5.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c420bbc064623934620b5ab2dc0cf96451b34163329e82f95e7fa1b7b99a6ac8\"\n+checksum = \"fef709d3257013bba7cff14fc504e07e80631d3fe0f6d38ce63b8f6510ccb932\"\n dependencies = [\n  \"byteorder\",\n  \"memmap\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n ]\n \n@@ -2145,7 +2152,7 @@ dependencies = [\n  \"hex 0.4.0\",\n  \"log\",\n  \"num-traits\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"serde\",\n@@ -2159,7 +2166,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4b2df1a4c22fd44a62147fd8f13dd0f95c9d8ca7b2610299b2a2f9cf8964274e\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"libc\",\n  \"log\",\n  \"openssl\",\n@@ -2248,7 +2255,7 @@ dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n  \"foreign-types\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"libc\",\n  \"openssl-sys\",\n ]\n@@ -2261,18 +2268,18 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.6.0+1.1.1d\"\n+version = \"111.6.1+1.1.1d\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9c2da1de8a7a3f860919c01540b03a6db16de042405a8a07a5e9d0b4b825d9c\"\n+checksum = \"c91b04cb43c1a8a90e934e0cd612e2a5715d976d2d6cff4490278a0cddf35005\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.52\"\n+version = \"0.9.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c977d08e1312e2f7e4b86f9ebaa0ed3b19d1daff75fae88bbb88108afbd801fc\"\n+checksum = \"465d16ae7fc0e313318f7de5cecf57b2fbe7511fd213978b457e1c96ff46736f\"\n dependencies = [\n  \"autocfg\",\n  \"cc\",\n@@ -2329,7 +2336,7 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.3\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"tokio\",\n  \"tokio-named-pipes\",\n  \"tokio-uds\",\n@@ -2343,10 +2350,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core\",\n+ \"parking_lot_core 0.6.2\",\n  \"rustc_version\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n+dependencies = [\n+ \"lock_api\",\n+ \"parking_lot_core 0.7.0\",\n+]\n+\n [[package]]\n name = \"parking_lot_core\"\n version = \"0.6.2\"\n@@ -2362,6 +2379,20 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cloudabi\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec 1.0.0\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -2457,9 +2488,9 @@ dependencies = [\n \n [[package]]\n name = \"pkg-config\"\n-version = \"0.3.14\"\n+version = \"0.3.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n+checksum = \"05da548ad6865900e60eaba7f589cc0783590a92e940c26953ff81ddbab2d677\"\n \n [[package]]\n name = \"polonius-engine\"\n@@ -2474,9 +2505,9 @@ dependencies = [\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.5\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3cbf9f658cdb5000fcf6f362b8ea2ba154b9f146a61c7a20d647034c6b6561b\"\n+checksum = \"74490b50b9fbe561ac330df47c08f3f33073d2d00c150f719147d7c54522fa1b\"\n \n [[package]]\n name = \"precomputed-hash\"\n@@ -2496,12 +2527,11 @@ dependencies = [\n \n [[package]]\n name = \"pretty_env_logger\"\n-version = \"0.3.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n+checksum = \"926d36b9553851b8b0005f1275891b392ee4d2d833852c417ed025477350fb9d\"\n dependencies = [\n- \"chrono\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.1\",\n  \"log\",\n ]\n \n@@ -2567,7 +2597,7 @@ checksum = \"9bf259a81de2b2eb9850ec990ec78e6a25319715584fd7652b9b26f96fcb1510\"\n dependencies = [\n  \"error-chain\",\n  \"idna 0.2.0\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"regex\",\n  \"url 2.1.0\",\n ]\n@@ -2633,18 +2663,24 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.29\"\n+version = \"2.1.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7a6d7ffceb4da3e0a29c18986f0469c209f4db3ab9f2ffe286eaa1104a3e5028\"\n+checksum = \"0ff33fa15ac0384376741d16ddb05a65263dde4e2c5d0f7a9f3747db788764aa\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger 0.6.2\",\n- \"humantime\",\n- \"lazy_static 1.3.0\",\n+ \"env_logger 0.7.1\",\n+ \"humantime 2.0.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"rls-span\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-syntax\",\n ]\n \n@@ -2669,9 +2705,9 @@ dependencies = [\n \n [[package]]\n name = \"rand\"\n-version = \"0.7.0\"\n+version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d47eab0e83d9693d40f825f86948aa16eff6750ead4bdffc4ab95b8b3a7f052c\"\n+checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom\",\n  \"libc\",\n@@ -2819,7 +2855,7 @@ dependencies = [\n  \"crossbeam-deque\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"num_cpus\",\n ]\n \n@@ -2834,9 +2870,9 @@ dependencies = [\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.1.43\"\n+version = \"0.1.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"679da7508e9a6390aeaf7fbd02a800fdc64b73fe2204dd2c8ae66d22d9d5ad5d\"\n+checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n \n [[package]]\n name = \"redox_termios\"\n@@ -2868,7 +2904,7 @@ dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n  \"regex-syntax\",\n- \"thread_local\",\n+ \"thread_local 0.3.6\",\n  \"utf8-ranges\",\n ]\n \n@@ -2936,26 +2972,26 @@ dependencies = [\n name = \"rls\"\n version = \"1.41.0\"\n dependencies = [\n+ \"anyhow\",\n  \"cargo\",\n  \"cargo_metadata 0.8.0\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n  \"env_logger 0.7.1\",\n- \"failure\",\n  \"futures\",\n  \"heck\",\n  \"home\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"lsp-codec\",\n  \"lsp-types\",\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -3025,10 +3061,9 @@ version = \"0.6.0\"\n dependencies = [\n  \"clippy_lints\",\n  \"env_logger 0.7.1\",\n- \"failure\",\n  \"futures\",\n  \"log\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3059,6 +3094,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap\",\n+ \"codespan\",\n  \"codespan-reporting\",\n  \"failure\",\n  \"mdbook\",\n@@ -3080,17 +3116,15 @@ dependencies = [\n  \"jobserver\",\n  \"log\",\n  \"measureme\",\n- \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n- \"rustc_fs_util\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n@@ -3105,85 +3139,136 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7475f4c707269b56eb7144c53591e3cd6369a5aa1d66434829ea11df96d5e7e3\"\n+checksum = \"ea82fa3d9a8add7422228ca1a2cbba0784fa8861f56148ff64da08b3c7921b03\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6e59a55520f140a70a3e0fad80a36e807caa85e9d7016167b91a5b521ea929be\"\n+checksum = \"638d0b2b3bcf99824e0cb5a25dbc547b61dc20942e11daf6a97e981918aa18e5\"\n+\n+[[package]]\n+name = \"rustc-ap-rustc_ast_pretty\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d38bab04dd676dee6d2f9670506a18c31bfce38bf7f8420aa83eb1140ecde049\"\n+dependencies = [\n+ \"log\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-syntax\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_attr\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"10b843ba8b1ed43739133047673b9f6a54d3b3b4d328d69c6ea89ff971395f35\"\n+dependencies = [\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-serialize\",\n+ \"rustc-ap-syntax\",\n+ \"smallvec 1.0.0\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6420857d5a088f680ec1ba736ffba4ee9c1964b0d397e6318f38d461f4f7d5cb\"\n+checksum = \"dc3d1c6d0a80ab0c1df76405377cec0f3d5423fb5b0953a8eac70a2ad6c44df2\"\n dependencies = [\n+ \"bitflags\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"measureme\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8abfca0960131262254a91d02ff4903526a261ede730d7a2c75b4234c867cdc0\"\n+checksum = \"4909a1eca29331332257230f29120a8ff68c9e37d868c564fcd599e430cf8914\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n- \"term_size\",\n  \"termcolor\",\n+ \"termize\",\n  \"unicode-width\",\n+ \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_feature\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"63ab887a181d795cf5fd3edadf367760deafb90aefb844f168ab5255266e3478\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_span\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_fs_util\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70814116df3c5fbec8f06f6a1d013ca481f620fd22a9475754e9bf3ee9ba70d8\"\n+\n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5a395509dcb90a92c1479c085639594624e06b4ab3fc7c1b795b46a61f2d4f65\"\n+checksum = \"ac1bf1d3cf3d119d41353d6fd229ef7272d5097bc0924de021c0294bf86d48bf\"\n dependencies = [\n  \"rustc-ap-serialize\",\n- \"smallvec 0.6.10\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64eac8a0e6efb8f55292aa24be0208c7c0538236c613e79952fd1fa3d54bcf8e\"\n+checksum = \"4cda21a32cebdc11ec4f5393aa2fcde5ed1b2f673a8571e5a4dcdf07e4ae9cac\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"610.0.0\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f99795e8be4877e9e05d59f201e1740c1cf673364655def5848606d9e25b75af\"\n+checksum = \"75c47b48ea51910ecfd853c9248a9bf4c767bc823449ab6a1d864dff65fbae16\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n@@ -3193,63 +3278,102 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc-ap-rustc_target\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_parse\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f22e21fdd8e1c0030f507158fa79b9f1e080e6241aba994d0f97c14a0a07a826\"\n+checksum = \"abd88e89cd5b5d28dcd3a347a3d534c08627d9455570dc1a2d402cb8437b9d30\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_attr\",\n  \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-syntax\",\n+ \"smallvec 1.0.0\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_session\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5b8487b4575fbb2d1fc6f1cd61225efd108a4d36817e6fb9b643d57fcae9cb12\"\n+dependencies = [\n+ \"log\",\n+ \"num_cpus\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_fs_util\",\n  \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-rustc_target\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n+ \"rustc-ap-syntax\",\n ]\n \n [[package]]\n-name = \"rustc-ap-serialize\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_span\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb1cd6ef5135408d62559866e79986ca261f4c1333253d500e5e66fe66d1432e\"\n+checksum = \"f69746c0d4c21bf20a5bb2bd247261a1aa8631f04202d7303352942dde70d987\"\n dependencies = [\n- \"indexmap\",\n- \"smallvec 0.6.10\",\n+ \"cfg-if\",\n+ \"log\",\n+ \"rustc-ap-arena\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-serialize\",\n+ \"scoped-tls\",\n+ \"unicode-width\",\n ]\n \n [[package]]\n-name = \"rustc-ap-syntax\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-rustc_target\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61fc1c901d2cbd24cae95d7bc5a58aa7661ec3dc5320c78c32830a52a685c33c\"\n+checksum = \"8bbc6ae09b5d42ec66edd520e8412e0615c53a7c93607fe33dc4abab60ba7c8b\"\n dependencies = [\n  \"bitflags\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_index\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_target\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax_pos\",\n- \"scoped-tls\",\n- \"smallvec 0.6.10\",\n ]\n \n [[package]]\n-name = \"rustc-ap-syntax_pos\"\n-version = \"610.0.0\"\n+name = \"rustc-ap-serialize\"\n+version = \"642.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"230534f638255853bb9f13987537e00a818435a0cc54b68d97221b6822c8f1bc\"\n+checksum = \"e13a1ead0252fc3d96da4c336a95950be6795f2b00c84a67ccadf26142f8cb41\"\n dependencies = [\n- \"cfg-if\",\n- \"rustc-ap-arena\",\n+ \"indexmap\",\n+ \"smallvec 1.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-syntax\"\n+version = \"642.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e1f59f48ca3a2ec16a7e82e718ed5aadf9c9e08cf63015d28b4e774767524a6a\"\n+dependencies = [\n+ \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n  \"scoped-tls\",\n- \"unicode-width\",\n+ \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -3278,7 +3402,6 @@ dependencies = [\n  \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n- \"rustc_target\",\n ]\n \n [[package]]\n@@ -3301,7 +3424,7 @@ dependencies = [\n  \"crossbeam-deque\",\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"num_cpus\",\n ]\n \n@@ -3348,25 +3471,14 @@ dependencies = [\n  \"smallvec 1.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_asan\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"alloc\",\n- \"build_helper\",\n- \"cmake\",\n- \"compiler_builtins\",\n- \"core\",\n-]\n-\n [[package]]\n name = \"rustc_ast_lowering\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc\",\n+ \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n@@ -3377,18 +3489,62 @@ dependencies = [\n  \"syntax\",\n ]\n \n+[[package]]\n+name = \"rustc_ast_passes\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_parse\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"syntax\",\n+]\n+\n+[[package]]\n+name = \"rustc_ast_pretty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"rustc_data_structures\",\n+ \"rustc_span\",\n+ \"syntax\",\n+]\n+\n+[[package]]\n+name = \"rustc_attr\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_ast_pretty\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+]\n+\n [[package]]\n name = \"rustc_builtin_macros\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros\",\n  \"log\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_parse\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n@@ -3403,13 +3559,14 @@ dependencies = [\n  \"flate2\",\n  \"libc\",\n  \"log\",\n+ \"measureme\",\n  \"rustc\",\n  \"rustc-demangle\",\n+ \"rustc_attr\",\n  \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n@@ -3419,6 +3576,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"serialize\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n ]\n@@ -3436,9 +3594,9 @@ dependencies = [\n  \"num_cpus\",\n  \"rustc\",\n  \"rustc_apfloat\",\n+ \"rustc_attr\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n@@ -3479,28 +3637,30 @@ dependencies = [\n  \"graphviz\",\n  \"indexmap\",\n  \"jobserver\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_index\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n  \"env_logger 0.7.1\",\n- \"graphviz\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"rustc\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_error_codes\",\n@@ -3513,12 +3673,12 @@ dependencies = [\n  \"rustc_mir\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n- \"rustc_resolve\",\n  \"rustc_save_analysis\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3535,21 +3695,26 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_span\",\n  \"serialize\",\n- \"term_size\",\n  \"termcolor\",\n+ \"termize\",\n  \"unicode-width\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc_expand\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n+ \"rustc_ast_passes\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n  \"rustc_parse\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -3560,7 +3725,7 @@ dependencies = [\n name = \"rustc_feature\"\n version = \"0.0.0\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"rustc_data_structures\",\n  \"rustc_span\",\n ]\n@@ -3573,11 +3738,12 @@ version = \"0.0.0\"\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"lazy_static 1.4.0\",\n+ \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_macros\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n@@ -3591,7 +3757,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3619,6 +3785,8 @@ dependencies = [\n  \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast_lowering\",\n+ \"rustc_ast_passes\",\n+ \"rustc_attr\",\n  \"rustc_builtin_macros\",\n  \"rustc_codegen_llvm\",\n  \"rustc_codegen_ssa\",\n@@ -3631,19 +3799,23 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_mir_build\",\n  \"rustc_parse\",\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n  \"rustc_resolve\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_traits\",\n+ \"rustc_ty\",\n  \"rustc_typeck\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n  \"tempfile\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3659,8 +3831,10 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n+ \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n@@ -3680,22 +3854,10 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"rustc_lsan\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"alloc\",\n- \"build_helper\",\n- \"cmake\",\n- \"compiler_builtins\",\n- \"core\",\n-]\n-\n [[package]]\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n@@ -3710,8 +3872,9 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"rustc\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_hir\",\n@@ -3723,13 +3886,13 @@ dependencies = [\n  \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n  \"syntax\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"either\",\n  \"graphviz\",\n  \"itertools 0.8.0\",\n@@ -3738,8 +3901,9 @@ dependencies = [\n  \"polonius-engine\",\n  \"rustc\",\n  \"rustc_apfloat\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n@@ -3753,14 +3917,25 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc_msan\"\n+name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc\",\n- \"build_helper\",\n- \"cmake\",\n- \"compiler_builtins\",\n- \"core\",\n+ \"arena\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_apfloat\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n ]\n \n [[package]]\n@@ -3769,11 +3944,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n@@ -3786,13 +3963,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_parse\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"syntax\",\n@@ -3803,9 +3980,9 @@ name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_span\",\n  \"syntax\",\n@@ -3817,8 +3994,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_span\",\n@@ -3835,8 +4012,9 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_ast_lowering\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_feature\",\n@@ -3856,6 +4034,7 @@ dependencies = [\n  \"rls-data\",\n  \"rls-span\",\n  \"rustc\",\n+ \"rustc_ast_pretty\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n@@ -3879,6 +4058,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n+ \"syntax\",\n ]\n \n [[package]]\n@@ -3936,14 +4116,14 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc_tsan\"\n+name = \"rustc_ty\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc\",\n- \"build_helper\",\n- \"cmake\",\n- \"compiler_builtins\",\n- \"core\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_data_structures\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n ]\n \n [[package]]\n@@ -3953,8 +4133,8 @@ dependencies = [\n  \"arena\",\n  \"log\",\n  \"rustc\",\n+ \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n@@ -4009,6 +4189,18 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"rustfix\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"804b11883a5ce0ad0378fbf95a8dea59ee6b51c331a73b8f471b6bdaa3bd40c1\"\n+dependencies = [\n+ \"anyhow\",\n+ \"log\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"rustfmt-config_proc_macro\"\n version = \"0.2.0\"\n@@ -4021,7 +4213,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.11\"\n+version = \"1.4.12\"\n dependencies = [\n  \"annotate-snippets\",\n  \"bytecount\",\n@@ -4034,12 +4226,17 @@ dependencies = [\n  \"getopts\",\n  \"ignore\",\n  \"itertools 0.8.0\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"regex\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n  \"rustc-ap-rustc_target\",\n  \"rustc-ap-syntax\",\n- \"rustc-ap-syntax_pos\",\n  \"rustc-workspace-hack\",\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n@@ -4069,11 +4266,11 @@ dependencies = [\n \n [[package]]\n name = \"schannel\"\n-version = \"0.1.14\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e1a231dc10abf6749cfa5d7767f25888d484201accbd919b66ab5413c502d56\"\n+checksum = \"87f550b06b6cba9c8b8be3ee73f391990116bf527450d2556e9b9ce263b9a021\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -4273,9 +4470,9 @@ checksum = \"4ecf3b85f68e8abaa7555aa5abdb1153079387e60b718283d732f03897fcfc86\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.3.8\"\n+version = \"0.3.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c4d11a52082057d87cb5caa31ad812f4504b97ab44732cd8359df2e9ff9f48e7\"\n+checksum = \"e8b74de517221a2cb01a53349cf54182acdc31a074727d3079068448c0676d85\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -4306,13 +4503,9 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.0\",\n- \"rustc_asan\",\n- \"rustc_lsan\",\n- \"rustc_msan\",\n- \"rustc_tsan\",\n+ \"rand 0.7.3\",\n  \"unwind\",\n- \"wasi 0.9.0+wasi-snapshot-preview1\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -4330,7 +4523,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"new_debug_unreachable\",\n  \"phf_shared\",\n  \"precomputed-hash\",\n@@ -4464,17 +4657,11 @@ dependencies = [\n name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n- \"rustc_errors\",\n- \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"scoped-tls\",\n  \"serialize\",\n@@ -4483,9 +4670,9 @@ dependencies = [\n \n [[package]]\n name = \"tar\"\n-version = \"0.4.20\"\n+version = \"0.4.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n+checksum = \"b3196bfbffbba3e57481b6ea32249fbaf590396a52505a2615adbb79d9d826d3\"\n dependencies = [\n  \"filetime\",\n  \"libc\",\n@@ -4501,7 +4688,7 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.7.0\",\n+ \"rand 0.7.3\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.8\",\n@@ -4537,17 +4724,6 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n-[[package]]\n-name = \"term_size\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327\"\n-dependencies = [\n- \"kernel32-sys\",\n- \"libc\",\n- \"winapi 0.2.8\",\n-]\n-\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -4568,6 +4744,16 @@ dependencies = [\n  \"redox_termios\",\n ]\n \n+[[package]]\n+name = \"termize\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1706be6b564323ce7092f5f7e6b118a14c8ef7ed0e69c8c5329c914a9f101295\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"test\"\n version = \"0.0.0\"\n@@ -4608,14 +4794,23 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n ]\n \n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n@@ -4742,7 +4937,7 @@ checksum = \"afbd6ef1b8cc2bd2c2b580d882774d443ebb1c6ceefe35ba9ea4ab586c89dbe8\"\n dependencies = [\n  \"crossbeam-queue\",\n  \"futures\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"libc\",\n  \"log\",\n  \"mio\",\n@@ -4761,11 +4956,11 @@ checksum = \"6732fe6b53c8d11178dcb77ac6d9682af27fc6d4cb87789449152e5377377146\"\n dependencies = [\n  \"crossbeam-utils 0.6.5\",\n  \"futures\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"slab\",\n  \"tokio-executor\",\n  \"tokio-io\",\n@@ -4832,7 +5027,7 @@ dependencies = [\n  \"crossbeam-queue\",\n  \"crossbeam-utils 0.6.5\",\n  \"futures\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"log\",\n  \"num_cpus\",\n  \"slab\",\n@@ -4902,7 +5097,7 @@ dependencies = [\n  \"failure\",\n  \"failure_derive\",\n  \"is-match\",\n- \"lazy_static 1.3.0\",\n+ \"lazy_static 1.4.0\",\n  \"regex\",\n  \"toml\",\n  \"toml-query_derive\",\n@@ -4940,6 +5135,16 @@ version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \n+[[package]]\n+name = \"ucd-parse\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca6b52bf4da6512f0f07785a04769222e50d29639e7ecd016b7806fd2de306b4\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+ \"regex\",\n+]\n+\n [[package]]\n name = \"ucd-trie\"\n version = \"0.1.1\"\n@@ -4961,6 +5166,13 @@ dependencies = [\n  \"version_check 0.1.5\",\n ]\n \n+[[package]]\n+name = \"unicode-bdd\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ucd-parse\",\n+]\n+\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\"\n@@ -5100,9 +5312,9 @@ dependencies = [\n \n [[package]]\n name = \"vcpkg\"\n-version = \"0.2.6\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"def296d3eb3b12371b2c7d0e83bfe1403e4db2d7a0bba324a12b21c4ee13143d\"\n+checksum = \"3fc439f2794e98976c88a2a2dafce96b930fe8010b0a256b3c2199a773933168\"\n \n [[package]]\n name = \"vec_map\"\n@@ -5164,12 +5376,6 @@ dependencies = [\n  \"try-lock\",\n ]\n \n-[[package]]\n-name = \"wasi\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n-\n [[package]]\n name = \"wasi\"\n version = \"0.9.0+wasi-snapshot-preview1\""}, {"sha": "2f5a708e8dc6cff1f353a558f2940de30607e6ae", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -23,20 +23,14 @@ members = [\n   \"src/tools/rustfmt\",\n   \"src/tools/miri\",\n   \"src/tools/rustdoc-themes\",\n+  \"src/tools/unicode-table-generator\",\n ]\n exclude = [\n   \"build\",\n   # HACK(eddyb) This hardcodes the fact that our CI uses `/checkout/obj`.\n   \"obj\",\n ]\n \n-# Curiously, LLVM 7.0 will segfault if compiled with opt-level=3\n-# See issue https://github.com/rust-lang/rust/issues/52378\n-[profile.release]\n-opt-level = 2\n-[profile.bench]\n-opt-level = 2\n-\n # These options are controlled from our rustc wrapper script, so turn them off\n # here and have them controlled elsewhere.\n [profile.dev]"}, {"sha": "1b5ec8b78e237b5c3b3d812a7c0a6589d0f7161d", "filename": "LICENSE-APACHE", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/LICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/LICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-APACHE?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -174,28 +174,3 @@ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n    of your accepting any such warranty or additional liability.\n \n END OF TERMS AND CONDITIONS\n-\n-APPENDIX: How to apply the Apache License to your work.\n-\n-   To apply the Apache License to your work, attach the following\n-   boilerplate notice, with the fields enclosed by brackets \"[]\"\n-   replaced with your own identifying information. (Don't include\n-   the brackets!)  The text should be enclosed in the appropriate\n-   comment syntax for the file format. We also recommend that a\n-   file or class name and description of purpose be included on the\n-   same \"printed page\" as the copyright notice for easier\n-   identification within third-party archives.\n-\n-Copyright [yyyy] [name of copyright owner]\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-\thttp://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License."}, {"sha": "10e485c1a40d56f4c4ea92a33fbc0f1ec518b40e", "filename": "RELEASES.md", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,3 +1,118 @@\n+Version 1.41.0 (2020-01-30)\n+===========================\n+\n+Language\n+--------\n+\n+- [You can now pass type parameters to foreign items when implementing\n+  traits.][65879] E.g. You can now write `impl<T> From<Foo> for Vec<T> {}`.\n+- [You can now arbitrarily nest receiver types in the `self` position.][64325] E.g. you can\n+  now write `fn foo(self: Box<Box<Self>>) {}`. Previously only `Self`, `&Self`,\n+  `&mut Self`, `Arc<Self>`, `Rc<Self>`, and `Box<Self>` were allowed.\n+- [You can now use any valid identifier in a `format_args` macro.][66847]\n+  Previously identifiers starting with an underscore were not allowed.\n+- [Visibility modifiers (e.g. `pub`) are now syntactically allowed on trait items and\n+  enum variants.][66183] These are still rejected semantically, but\n+  can be seen and parsed by procedural macros and conditional compilation.\n+\n+Compiler\n+--------\n+\n+- [Rustc will now warn if you have unused loop `'label`s.][66325]\n+- [Removed support for the `i686-unknown-dragonfly` target.][67255]\n+- [Added tier 3 support\\* for the `riscv64gc-unknown-linux-gnu` target.][66661]\n+- [You can now pass an arguments file passing the `@path` syntax\n+  to rustc.][66172] Note that the format differs somewhat from what is\n+  found in other tooling; please see [the documentation][argfile-docs] for\n+  more information.\n+- [You can now provide `--extern` flag without a path, indicating that it is\n+  available from the search path or specified with an `-L` flag.][64882]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+[argfile-docs]: https://doc.rust-lang.org/nightly/rustc/command-line-arguments.html#path-load-command-line-flags-from-a-path\n+\n+Libraries\n+---------\n+\n+- [The `core::panic` module is now stable.][66771] It was already stable\n+  through `std`.\n+- [`NonZero*` numerics now implement `From<NonZero*>` if it's a smaller integer\n+  width.][66277] E.g. `NonZeroU16` now implements `From<NonZeroU8>`.\n+- [`MaybeUninit<T>` now implements `fmt::Debug`.][65013]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`Result::map_or`]\n+- [`Result::map_or_else`]\n+- [`std::rc::Weak::weak_count`]\n+- [`std::rc::Weak::strong_count`]\n+- [`std::sync::Weak::weak_count`]\n+- [`std::sync::Weak::strong_count`]\n+\n+Cargo\n+-----\n+\n+- [Cargo will now document all the private items for binary crates\n+  by default.][cargo/7593]\n+- [`cargo-install` will now reinstall the package if it detects that it is out\n+  of date.][cargo/7560]\n+- [Cargo.lock now uses a more git friendly format that should help to reduce\n+  merge conflicts.][cargo/7579]\n+- [You can now override specific dependencies's build settings][cargo/7591] E.g.\n+  `[profile.dev.package.image] opt-level = 2` sets the `image` crate's\n+  optimisation level to `2` for debug builds. You can also use\n+  `[profile.<profile>.build-override]` to override build scripts and\n+  their dependencies.\n+\n+Misc\n+----\n+\n+- [You can now specify `edition` in documentation code blocks to compile the block\n+  for that edition.][66238] E.g. `edition2018` tells rustdoc that the code sample\n+  should be compiled the 2018 edition of Rust.\n+- [You can now provide custom themes to rustdoc with `--theme`, and check the\n+  current theme with `--check-theme`.][54733]\n+- [You can use `#[cfg(doc)]` to compile an item when building documentation.][61351]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [As previously announced 1.41.0 will be the last tier 1 release for 32-bit\n+  Apple targets.][apple-32bit-drop] This means that the source code is still\n+  available to build, but the targets are no longer being tested and release\n+  binaries for those platforms will no longer be distributed by the Rust project.\n+  Please refer to the linked blog post for more information.\n+\n+[54733]: https://github.com/rust-lang/rust/pull/54733/\n+[61351]: https://github.com/rust-lang/rust/pull/61351/\n+[67255]: https://github.com/rust-lang/rust/pull/67255/\n+[66661]: https://github.com/rust-lang/rust/pull/66661/\n+[66771]: https://github.com/rust-lang/rust/pull/66771/\n+[66847]: https://github.com/rust-lang/rust/pull/66847/\n+[66238]: https://github.com/rust-lang/rust/pull/66238/\n+[66277]: https://github.com/rust-lang/rust/pull/66277/\n+[66325]: https://github.com/rust-lang/rust/pull/66325/\n+[66172]: https://github.com/rust-lang/rust/pull/66172/\n+[66183]: https://github.com/rust-lang/rust/pull/66183/\n+[65879]: https://github.com/rust-lang/rust/pull/65879/\n+[65013]: https://github.com/rust-lang/rust/pull/65013/\n+[64882]: https://github.com/rust-lang/rust/pull/64882/\n+[64325]: https://github.com/rust-lang/rust/pull/64325/\n+[cargo/7560]: https://github.com/rust-lang/cargo/pull/7560/\n+[cargo/7579]: https://github.com/rust-lang/cargo/pull/7579/\n+[cargo/7591]: https://github.com/rust-lang/cargo/pull/7591/\n+[cargo/7593]: https://github.com/rust-lang/cargo/pull/7593/\n+[`Result::map_or_else`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else\n+[`Result::map_or`]: https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or\n+[`std::rc::Weak::weak_count`]: https://doc.rust-lang.org/std/rc/struct.Weak.html#method.weak_count\n+[`std::rc::Weak::strong_count`]: https://doc.rust-lang.org/std/rc/struct.Weak.html#method.strong_count\n+[`std::sync::Weak::weak_count`]: https://doc.rust-lang.org/std/sync/struct.Weak.html#method.weak_count\n+[`std::sync::Weak::strong_count`]: https://doc.rust-lang.org/std/sync/struct.Weak.html#method.strong_count\n+[apple-32bit-drop]: https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html\n+\n Version 1.40.0 (2019-12-19)\n ===========================\n "}, {"sha": "9b7327ea69e0b1663f3c83b5ed6f9f0bacf36ed0", "filename": "config.toml.example", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -181,21 +181,23 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n-# Typically the build system will build the rust compiler twice. The second\n+# Typically the build system will build the Rust compiler twice. The second\n # compiler, however, will simply use its own libraries to link against. If you\n # would rather to perform a full bootstrap, compiling the compiler three times,\n # then you can set this option to true. You shouldn't ever need to set this\n # option to true.\n #full-bootstrap = false\n \n-# Enable a build of the extended rust tool set which is not only the compiler\n+# Enable a build of the extended Rust tool set which is not only the compiler\n # but also tools such as Cargo. This will also produce \"combined installers\"\n # which are used to install Rust and Cargo together. This is disabled by\n-# default.\n+# default. The `tools` option (immediately below) specifies which tools should\n+# be built if `extended = true`.\n #extended = false\n \n-# Installs chosen set of extended tools if enabled. By default builds all.\n-# If chosen tool failed to build the installation fails.\n+# Installs chosen set of extended tools if `extended = true`. By default builds all.\n+# If chosen tool failed to build the installation fails. If `extended = false`, this\n+# option is ignored.\n #tools = [\"cargo\", \"rls\", \"clippy\", \"rustfmt\", \"analysis\", \"src\"]\n \n # Verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n@@ -393,6 +395,15 @@\n # rustc to execute.\n #lld = false\n \n+# Indicates whether LLD will be used to link Rust crates during bootstrap on\n+# supported platforms. The LLD from the bootstrap distribution will be used\n+# and not the LLD compiled during the bootstrap.\n+#\n+# LLD will not be used if we're cross linking or running tests.\n+#\n+# Explicitly setting the linker for a target will override this option.\n+#use-lld = false\n+\n # Indicates whether some LLVM tools, like llvm-objdump, will be made available in the\n # sysroot.\n #llvm-tools = false\n@@ -433,6 +444,10 @@\n # Use LLVM libunwind as the implementation for Rust's unwinder.\n #llvm-libunwind = false\n \n+# Enable Windows Control Flow Guard checks in the standard library.\n+# This only applies from stage 1 onwards, and only for Windows targets.\n+#control-flow-guard = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -461,6 +476,7 @@\n # Linker to be used to link Rust code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n+# Setting this will override the `use-lld` option for Rust code.\n #linker = \"cc\"\n \n # Path to the `llvm-config` binary of the installation of a custom LLVM to link"}, {"sha": "8f4c901fb9740919dae8d6b72a8e122a97250317", "filename": "rustfmt.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -6,6 +6,9 @@ merge_derives = false\n # by default we ignore everything in the repository\n # tidy only checks files which are not ignored, each entry follows gitignore style\n ignore = [\n+    \"build\",\n+    \"/vendor/\",\n+\n     # tests for now are not formatted, as they are sometimes pretty-printing constrained\n     # (and generally rustfmt can move around comments in UI-testing incompatible ways)\n     \"src/test\","}, {"sha": "c09f58cc591a69365e2004e8cfe0c298b3b52229", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -49,5 +49,9 @@ lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n \n+[target.'cfg(windows)'.dependencies.winapi]\n+version = \"0.3\"\n+features = [\"fileapi\", \"ioapiset\", \"jobapi2\", \"handleapi\", \"winioctl\"]\n+\n [dev-dependencies]\n pretty_assertions = \"0.5\""}, {"sha": "daa030c59d64139cf19951f3b6d63fcb4abba553", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -47,7 +47,7 @@ fn main() {\n     };\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n-    let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n+    let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(Command::new);\n \n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n@@ -64,7 +64,7 @@ fn main() {\n     if let Some(crate_name) = crate_name {\n         if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n             if target == \"all\"\n-                || target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+                || target.into_string().unwrap().split(',').any(|c| c.trim() == crate_name)\n             {\n                 cmd.arg(\"-Ztime\");\n             }\n@@ -134,6 +134,11 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n \n+        // Override linker flavor if necessary.\n+        if let Ok(host_linker_flavor) = env::var(\"RUSTC_HOST_LINKER_FLAVOR\") {\n+            cmd.arg(format!(\"-Clinker-flavor={}\", host_linker_flavor));\n+        }\n+\n         if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n             if s == \"true\" {\n                 cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n@@ -189,7 +194,7 @@ fn main() {\n                 crate_name,\n                 is_test,\n                 dur.as_secs(),\n-                dur.subsec_nanos() / 1_000_000\n+                dur.subsec_millis()\n             );\n \n             match status.code() {"}, {"sha": "04345867bf5c185e21155a195f48665710adfe8b", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -61,7 +61,7 @@ fn main() {\n     }\n \n     // Needed to be able to run all rustdoc tests.\n-    if let Some(_) = env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\") {\n+    if env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\").is_some() {\n         // This \"unstable-options\" can be removed when `--generate-redirect-pages` is stabilized\n         if !has_unstable {\n             cmd.arg(\"-Z\").arg(\"unstable-options\");"}, {"sha": "50e1726240fffd29936c469d15386e60fad3a52b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -80,7 +80,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-s\"\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n-             \"--connect-timeout\", \"30\", # timeout if cannot connect within 30 seconds\n+             \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n              \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n             exception=exception)\n@@ -332,7 +332,6 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n \n-\n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n \n@@ -351,7 +350,7 @@ def support_xz():\n             try:\n                 with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n                     temp_path = temp_file.name\n-                with tarfile.open(temp_path, \"w:xz\") as tar:\n+                with tarfile.open(temp_path, \"w:xz\"):\n                     pass\n                 return True\n             except tarfile.CompressionError:\n@@ -397,7 +396,7 @@ def support_xz():\n \n         if self.rustfmt() and self.rustfmt().startswith(self.bin_root()) and (\n             not os.path.exists(self.rustfmt())\n-            or self.program_out_of_date(self.rustfmt_stamp())\n+            or self.program_out_of_date(self.rustfmt_stamp(), self.rustfmt_channel)\n         ):\n             if rustfmt_channel:\n                 tarball_suffix = '.tar.xz' if support_xz() else '.tar.gz'\n@@ -407,7 +406,7 @@ def support_xz():\n                 self.fix_executable(\"{}/bin/rustfmt\".format(self.bin_root()))\n                 self.fix_executable(\"{}/bin/cargo-fmt\".format(self.bin_root()))\n                 with output(self.rustfmt_stamp()) as rustfmt_stamp:\n-                    rustfmt_stamp.write(self.date)\n+                    rustfmt_stamp.write(self.date + self.rustfmt_channel)\n \n     def _download_stage0_helper(self, filename, pattern, tarball_suffix, date=None):\n         if date is None:\n@@ -521,12 +520,12 @@ def rustfmt_stamp(self):\n         \"\"\"\n         return os.path.join(self.bin_root(), '.rustfmt-stamp')\n \n-    def program_out_of_date(self, stamp_path):\n+    def program_out_of_date(self, stamp_path, extra=\"\"):\n         \"\"\"Check if the given program stamp is out of date\"\"\"\n         if not os.path.exists(stamp_path) or self.clean:\n             return True\n         with open(stamp_path, 'r') as stamp:\n-            return self.date != stamp.read()\n+            return (self.date + extra) != stamp.read()\n \n     def bin_root(self):\n         \"\"\"Return the binary root directory\n@@ -825,7 +824,7 @@ def check_vendored_status(self):\n                 if not os.path.exists(vendor_dir):\n                     print('error: vendoring required, but vendor directory does not exist.')\n                     print('       Run `cargo vendor` without sudo to initialize the '\n-                        'vendor directory.')\n+                          'vendor directory.')\n                     raise Exception(\"{} not found\".format(vendor_dir))\n \n         if self.use_vendored_sources:\n@@ -839,7 +838,7 @@ def check_vendored_status(self):\n                     \"\\n\"\n                     \"[source.vendored-sources]\\n\"\n                     \"directory = '{}/vendor'\\n\"\n-                .format(self.rust_root))\n+                    .format(self.rust_root))\n         else:\n             if os.path.exists('.cargo'):\n                 shutil.rmtree('.cargo')"}, {"sha": "e4b57cddfb891e86e1ed005d0e996216e230010f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -343,6 +343,7 @@ impl<'a> Builder<'a> {\n                 tool::Rustdoc,\n                 tool::Clippy,\n                 native::Llvm,\n+                native::Sanitizers,\n                 tool::Rustfmt,\n                 tool::Miri,\n                 native::Lld\n@@ -509,17 +510,15 @@ impl<'a> Builder<'a> {\n             Subcommand::Format { .. } | Subcommand::Clean { .. } => panic!(),\n         };\n \n-        let builder = Builder {\n+        Builder {\n             build,\n             top_stage: build.config.stage.unwrap_or(2),\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n             time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n             paths: paths.to_owned(),\n-        };\n-\n-        builder\n+        }\n     }\n \n     pub fn execute_cli(&self) {\n@@ -693,7 +692,7 @@ impl<'a> Builder<'a> {\n         cmd.env_remove(\"MAKEFLAGS\");\n         cmd.env_remove(\"MFLAGS\");\n \n-        if let Some(linker) = self.linker(compiler.host) {\n+        if let Some(linker) = self.linker(compiler.host, true) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         cmd\n@@ -752,13 +751,12 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n-        let stage;\n-        if compiler.stage == 0 && self.local_rebuild {\n+        let stage = if compiler.stage == 0 && self.local_rebuild {\n             // Assume the local-rebuild rustc already has stage1 features.\n-            stage = 1;\n+            1\n         } else {\n-            stage = compiler.stage;\n-        }\n+            compiler.stage\n+        };\n \n         let mut rustflags = Rustflags::new(&target);\n         if stage != 0 {\n@@ -849,7 +847,13 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"-Zforce-unstable-if-unmarked\");\n         }\n \n-        rustflags.arg(\"-Zexternal-macro-backtrace\");\n+        // cfg(bootstrap): the flag was renamed from `-Zexternal-macro-backtrace`\n+        // to `-Zmacro-backtrace`, keep only the latter after beta promotion.\n+        if stage == 0 {\n+            rustflags.arg(\"-Zexternal-macro-backtrace\");\n+        } else {\n+            rustflags.arg(\"-Zmacro-backtrace\");\n+        }\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n \n@@ -873,7 +877,7 @@ impl<'a> Builder<'a> {\n         //\n         // Only clear out the directory if we're compiling std; otherwise, we\n         // should let Cargo take care of things for us (via depdep info)\n-        if !self.config.dry_run && mode == Mode::ToolStd && cmd == \"build\" {\n+        if !self.config.dry_run && mode == Mode::Std && cmd == \"build\" {\n             self.clear_if_dirty(&out_dir, &self.rustc(compiler));\n         }\n \n@@ -948,10 +952,31 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        if let Some(host_linker) = self.linker(compiler.host) {\n+        // FIXME: Don't use LLD if we're compiling libtest, since it fails to link it.\n+        // See https://github.com/rust-lang/rust/issues/68647.\n+        let can_use_lld = mode != Mode::Std;\n+\n+        // FIXME: The beta compiler doesn't pick the `lld-link` flavor for `*-pc-windows-msvc`\n+        // Remove `RUSTC_HOST_LINKER_FLAVOR` when this is fixed\n+        let lld_linker_flavor = |linker: &Path, target: Interned<String>| {\n+            compiler.stage == 0\n+                && linker.file_name() == Some(OsStr::new(\"rust-lld\"))\n+                && target.contains(\"pc-windows-msvc\")\n+        };\n+\n+        if let Some(host_linker) = self.linker(compiler.host, can_use_lld) {\n+            if lld_linker_flavor(host_linker, compiler.host) {\n+                cargo.env(\"RUSTC_HOST_LINKER_FLAVOR\", \"lld-link\");\n+            }\n+\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n-        if let Some(target_linker) = self.linker(target) {\n+\n+        if let Some(target_linker) = self.linker(target, can_use_lld) {\n+            if lld_linker_flavor(target_linker, target) {\n+                rustflags.arg(\"-Clinker-flavor=lld-link\");\n+            }\n+\n             let target = crate::envify(&target);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n@@ -1110,6 +1135,20 @@ impl<'a> Builder<'a> {\n             );\n         }\n \n+        // If Control Flow Guard is enabled, pass the `control_flow_guard=checks` flag to rustc\n+        // when compiling the standard library, since this might be linked into the final outputs\n+        // produced by rustc. Since this mitigation is only available on Windows, only enable it\n+        // for the standard library in case the compiler is run on a non-Windows platform.\n+        // This is not needed for stage 0 artifacts because these will only be used for building\n+        // the stage 1 compiler.\n+        if cfg!(windows)\n+            && mode == Mode::Std\n+            && self.config.control_flow_guard\n+            && compiler.stage >= 1\n+        {\n+            rustflags.arg(\"-Zcontrol_flow_guard=checks\");\n+        }\n+\n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n         cargo.env(\"RUSTDOC_CRATE_VERSION\", self.rust_version());\n \n@@ -1251,12 +1290,7 @@ impl<'a> Builder<'a> {\n         };\n \n         if self.config.print_step_timings && dur > Duration::from_millis(100) {\n-            println!(\n-                \"[TIMING] {:?} -- {}.{:03}\",\n-                step,\n-                dur.as_secs(),\n-                dur.subsec_nanos() / 1_000_000\n-            );\n+            println!(\"[TIMING] {:?} -- {}.{:03}\", step, dur.as_secs(), dur.subsec_millis());\n         }\n \n         {\n@@ -1301,7 +1335,7 @@ impl Rustflags {\n \n     fn arg(&mut self, arg: &str) -> &mut Self {\n         assert_eq!(arg.split_whitespace().count(), 1);\n-        if self.0.len() > 0 {\n+        if !self.0.is_empty() {\n             self.0.push_str(\" \");\n         }\n         self.0.push_str(arg);"}, {"sha": "cca8ab80c93b1d329cf3f4bb9f92b4998b1461dd", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -19,7 +19,6 @@ fn configure(host: &[&str], target: &[&str]) -> Config {\n     config.out = dir;\n     config.build = INTERNER.intern_str(\"A\");\n     config.hosts = vec![config.build]\n-        .clone()\n         .into_iter()\n         .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n         .collect::<Vec<_>>();"}, {"sha": "504cba45570c17faf8d171e02a2120a50df9ea0a", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.42.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.43.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "b76515763fbdb19a18d6049418ac28ee6d8165ab", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -45,7 +45,7 @@ impl Step for Std {\n         let compiler = builder.compiler(0, builder.config.build);\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n-        std_cargo(builder, &compiler, target, &mut cargo);\n+        std_cargo(builder, target, &mut cargo);\n \n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo("}, {"sha": "7dded96e18efde448effb85f955c42128f61a0ea", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -18,7 +18,6 @@ use std::str;\n use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n-use serde_json;\n \n use crate::builder::Cargo;\n use crate::dist;\n@@ -87,7 +86,7 @@ impl Step for Std {\n         target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n-        std_cargo(builder, &compiler, target, &mut cargo);\n+        std_cargo(builder, target, &mut cargo);\n \n         builder.info(&format!(\n             \"Building stage{} std artifacts ({} -> {})\",\n@@ -149,21 +148,23 @@ fn copy_third_party_objects(\n     // which is provided by std for this target.\n     if target == \"x86_64-fortanix-unknown-sgx\" {\n         let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let src = env::var(src_path_env).expect(&format!(\"{} not found in env\", src_path_env));\n+        let src =\n+            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n         copy_and_stamp(Path::new(&src), \"libunwind.a\");\n     }\n \n+    if builder.config.sanitizers && compiler.stage != 0 {\n+        // The sanitizers are only copied in stage1 or above,\n+        // to avoid creating dependency on LLVM.\n+        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+    }\n+\n     target_deps\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(\n-    builder: &Builder<'_>,\n-    compiler: &Compiler,\n-    target: Interned<String>,\n-    cargo: &mut Cargo,\n-) {\n+pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -206,19 +207,6 @@ pub fn std_cargo(\n         let mut features = builder.std_features();\n         features.push_str(&compiler_builtins_c_feature);\n \n-        if compiler.stage != 0 && builder.config.sanitizers {\n-            // This variable is used by the sanitizer runtime crates, e.g.\n-            // rustc_lsan, to build the sanitizer runtime from C code\n-            // When this variable is missing, those crates won't compile the C code,\n-            // so we don't set this variable during stage0 where llvm-config is\n-            // missing\n-            // We also only build the runtimes when --enable-sanitizers (or its\n-            // config.toml equivalent) is used\n-            let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n-            cargo.env(\"LLVM_CONFIG\", llvm_config);\n-            cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n-        }\n-\n         cargo\n             .arg(\"--features\")\n             .arg(features)\n@@ -276,31 +264,43 @@ impl Step for StdLink {\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n-\n-        if builder.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n-            // The sanitizers are only built in stage1 or above, so the dylibs will\n-            // be missing in stage0 and causes panic. See the `std()` function above\n-            // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n-        }\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(\n+/// Copies sanitizer runtime libraries into target libdir.\n+fn copy_sanitizers(\n     builder: &Builder<'_>,\n-    native_dir: &Path,\n-    platform: &str,\n-    into: &Path,\n-) {\n-    for &sanitizer in &[\"asan\", \"tsan\"] {\n-        let filename = format!(\"lib__rustc__clang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n-        let mut src_path = native_dir.join(sanitizer);\n-        src_path.push(\"build\");\n-        src_path.push(\"lib\");\n-        src_path.push(\"darwin\");\n-        src_path.push(&filename);\n-        builder.copy(&src_path, &into.join(filename));\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<PathBuf> {\n+    let runtimes: Vec<native::SanitizerRuntime> = builder.ensure(native::Sanitizers { target });\n+\n+    if builder.config.dry_run {\n+        return Vec::new();\n+    }\n+\n+    let mut target_deps = Vec::new();\n+    let libdir = builder.sysroot_libdir(*compiler, target);\n+\n+    for runtime in &runtimes {\n+        let dst = libdir.join(&runtime.name);\n+        builder.copy(&runtime.path, &dst);\n+\n+        if target == \"x86_64-apple-darwin\" {\n+            // Update the library install name reflect the fact it has been renamed.\n+            let status = Command::new(\"install_name_tool\")\n+                .arg(\"-id\")\n+                .arg(format!(\"@rpath/{}\", runtime.name))\n+                .arg(&dst)\n+                .status()\n+                .expect(\"failed to execute `install_name_tool`\");\n+            assert!(status.success());\n+        }\n+\n+        target_deps.push(dst);\n     }\n+\n+    target_deps\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -361,7 +361,7 @@ impl Step for StartupObjects {\n                 );\n             }\n \n-            let target = sysroot_dir.join(file.to_string() + \".o\");\n+            let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n             target_deps.push(target);\n         }\n@@ -515,7 +515,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n         .env(\"CFG_VERSION\", builder.rust_version())\n         .env(\"CFG_PREFIX\", builder.config.prefix.clone().unwrap_or_default());\n \n-    let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n+    let libdir_relative = builder.config.libdir_relative().unwrap_or_else(|| Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n     if let Some(ref ver_date) = builder.rust_info.commit_date() {\n@@ -843,11 +843,11 @@ pub fn run_cargo(\n         };\n         for filename in filenames {\n             // Skip files like executables\n-            if !filename.ends_with(\".rlib\")\n-                && !filename.ends_with(\".lib\")\n-                && !filename.ends_with(\".a\")\n-                && !is_dylib(&filename)\n-                && !(is_check && filename.ends_with(\".rmeta\"))\n+            if !(filename.ends_with(\".rlib\")\n+                || filename.ends_with(\".lib\")\n+                || filename.ends_with(\".a\")\n+                || is_dylib(&filename)\n+                || (is_check && filename.ends_with(\".rmeta\")))\n             {\n                 continue;\n             }\n@@ -905,7 +905,7 @@ pub fn run_cargo(\n     for (prefix, extension, expected_len) in toplevel {\n         let candidates = contents.iter().filter(|&&(_, ref filename, ref meta)| {\n             filename.starts_with(&prefix[..])\n-                && filename[prefix.len()..].starts_with(\"-\")\n+                && filename[prefix.len()..].starts_with('-')\n                 && filename.ends_with(&extension[..])\n                 && meta.len() == expected_len\n         });"}, {"sha": "214d572329ec6c5b16f598f29a6ce815b70d56a9", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -16,7 +16,6 @@ use crate::flags::Flags;\n pub use crate::flags::Subcommand;\n use build_helper::t;\n use serde::Deserialize;\n-use toml;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -83,6 +82,7 @@ pub struct Config {\n     pub llvm_use_linker: Option<String>,\n     pub llvm_allow_old_toolchain: Option<bool>,\n \n+    pub use_lld: bool,\n     pub lld_enabled: bool,\n     pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n@@ -116,6 +116,7 @@ pub struct Config {\n     pub targets: Vec<Interned<String>>,\n     pub local_rebuild: bool,\n     pub jemalloc: bool,\n+    pub control_flow_guard: bool,\n \n     // dist misc\n     pub dist_sign_folder: Option<PathBuf>,\n@@ -322,6 +323,7 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     lld: Option<bool>,\n+    use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n     lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n@@ -332,6 +334,7 @@ struct Rust {\n     jemalloc: Option<bool>,\n     test_compare_mode: Option<bool>,\n     llvm_libunwind: Option<bool>,\n+    control_flow_guard: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -440,7 +443,7 @@ impl Config {\n                     }\n                 }\n             })\n-            .unwrap_or_else(|| TomlConfig::default());\n+            .unwrap_or_else(TomlConfig::default);\n \n         let build = toml.build.clone().unwrap_or_default();\n         // set by bootstrap.py\n@@ -493,9 +496,13 @@ impl Config {\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }\n \n+        // We want the llvm-skip-rebuild flag to take precedence over the\n+        // skip-rebuild config.toml option so we store it separately\n+        // so that we can infer the right value\n+        let mut llvm_skip_rebuild = flags.llvm_skip_rebuild;\n+\n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n-        let mut llvm_skip_rebuild = None;\n         let mut llvm_assertions = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n@@ -517,7 +524,7 @@ impl Config {\n             }\n             set(&mut config.ninja, llvm.ninja);\n             llvm_assertions = llvm.assertions;\n-            llvm_skip_rebuild = llvm.skip_rebuild;\n+            llvm_skip_rebuild = llvm_skip_rebuild.or(llvm.skip_rebuild);\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_thin_lto, llvm.thin_lto);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n@@ -535,7 +542,7 @@ impl Config {\n             config.llvm_ldflags = llvm.ldflags.clone();\n             set(&mut config.llvm_use_libcxx, llvm.use_libcxx);\n             config.llvm_use_linker = llvm.use_linker.clone();\n-            config.llvm_allow_old_toolchain = llvm.allow_old_toolchain.clone();\n+            config.llvm_allow_old_toolchain = llvm.allow_old_toolchain;\n         }\n \n         if let Some(ref rust) = toml.rust {\n@@ -562,6 +569,7 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n+            set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n@@ -574,6 +582,7 @@ impl Config {\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n+            set(&mut config.control_flow_guard, rust.control_flow_guard);\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends =\n@@ -602,7 +611,7 @@ impl Config {\n                 target.ar = cfg.ar.clone().map(PathBuf::from);\n                 target.ranlib = cfg.ranlib.clone().map(PathBuf::from);\n                 target.linker = cfg.linker.clone().map(PathBuf::from);\n-                target.crt_static = cfg.crt_static.clone();\n+                target.crt_static = cfg.crt_static;\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.wasi_root = cfg.wasi_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);"}, {"sha": "3d2eead6788bf2fedcb8aeb93c54daa4a428c782", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -60,6 +60,7 @@ def v(*args):\n o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n+o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")\n \n o(\"cflags\", \"llvm.cflags\", \"build LLVM with these extra compiler flags\")\n o(\"cxxflags\", \"llvm.cxxflags\", \"build LLVM with these extra compiler flags\")\n@@ -392,11 +393,12 @@ def set(key, value):\n \n \n def is_number(value):\n-  try:\n-    float(value)\n-    return True\n-  except ValueError:\n-    return False\n+    try:\n+        float(value)\n+        return True\n+    except ValueError:\n+        return False\n+\n \n # Here we walk through the constructed configuration we have from the parsed\n # command line arguments. We then apply each piece of configuration by"}, {"sha": "8003d8906e8247b4dd60bd5b07918922a26cddf1", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -105,6 +105,7 @@ impl Step for Docs {\n         t!(fs::create_dir_all(&dst));\n         let src = builder.doc_out(host);\n         builder.cp_r(&src, &dst);\n+        builder.install(&builder.src.join(\"src/doc/robots.txt\"), &dst, 0o644);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -827,7 +828,7 @@ impl Step for Analysis {\n         assert!(builder.config.extended);\n         let name = pkgname(builder, \"rust-analysis\");\n \n-        if &compiler.host != builder.config.build {\n+        if compiler.host != builder.config.build {\n             return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -876,7 +877,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             Some(path) => path,\n             None => return false,\n         };\n-        if spath.ends_with(\"~\") || spath.ends_with(\".pyc\") {\n+        if spath.ends_with('~') || spath.ends_with(\".pyc\") {\n             return false;\n         }\n \n@@ -984,10 +985,6 @@ impl Step for Src {\n             \"src/libcore\",\n             \"src/libpanic_abort\",\n             \"src/libpanic_unwind\",\n-            \"src/librustc_asan\",\n-            \"src/librustc_lsan\",\n-            \"src/librustc_msan\",\n-            \"src/librustc_tsan\",\n             \"src/libstd\",\n             \"src/libunwind\",\n             \"src/libtest\","}, {"sha": "b0d9a5b94641cf68aa9eb299b9dd3fe67e8d49cf", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 17, "deletions": 75, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -49,7 +49,7 @@ macro_rules! book {\n                 builder.ensure(RustbookSrc {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n-                    src: doc_src(builder),\n+                    src: INTERNER.intern_path(builder.src.join($path)),\n                 })\n             }\n         }\n@@ -60,6 +60,7 @@ macro_rules! book {\n // NOTE: When adding a book here, make sure to ALSO build the book by\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n+    CargoBook, \"src/tools/cargo/src/doc\", \"cargo\";\n     EditionGuide, \"src/doc/edition-guide\", \"edition-guide\";\n     EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\";\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n@@ -69,10 +70,6 @@ book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n-fn doc_src(builder: &Builder<'_>) -> Interned<PathBuf> {\n-    INTERNER.intern_path(builder.src.join(\"src/doc\"))\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct UnstableBook {\n     target: Interned<String>,\n@@ -96,48 +93,11 @@ impl Step for UnstableBook {\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n-            src: builder.md_doc_out(self.target),\n+            src: INTERNER.intern_path(builder.md_doc_out(self.target).join(\"unstable-book\")),\n         })\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct CargoBook {\n-    target: Interned<String>,\n-    name: Interned<String>,\n-}\n-\n-impl Step for CargoBook {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(CargoBook { target: run.target, name: INTERNER.intern_str(\"cargo\") });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-        let name = self.name;\n-        let src = builder.src.join(\"src/tools/cargo/src/doc\");\n-\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-\n-        let out = out.join(name);\n-\n-        builder.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n-\n-        let _ = fs::remove_dir_all(&out);\n-\n-        builder.run(builder.tool_cmd(Tool::Rustbook).arg(\"build\").arg(&src).arg(\"-d\").arg(out));\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n struct RustbookSrc {\n     target: Interned<String>,\n@@ -164,7 +124,6 @@ impl Step for RustbookSrc {\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n-        let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n@@ -182,7 +141,6 @@ impl Step for RustbookSrc {\n pub struct TheBook {\n     compiler: Compiler,\n     target: Interned<String>,\n-    name: &'static str,\n }\n \n impl Step for TheBook {\n@@ -198,53 +156,37 @@ impl Step for TheBook {\n         run.builder.ensure(TheBook {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n-            name: \"book\",\n         });\n     }\n \n     /// Builds the book and associated stuff.\n     ///\n     /// We need to build:\n     ///\n-    /// * Book (first edition)\n-    /// * Book (second edition)\n+    /// * Book\n+    /// * Older edition redirects\n     /// * Version info and CSS\n     /// * Index page\n     /// * Redirect pages\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n-        let name = self.name;\n \n         // build book\n         builder.ensure(RustbookSrc {\n             target,\n-            name: INTERNER.intern_string(name.to_string()),\n-            src: doc_src(builder),\n+            name: INTERNER.intern_str(\"book\"),\n+            src: INTERNER.intern_path(builder.src.join(\"src/doc/book\")),\n         });\n \n         // building older edition redirects\n-\n-        let source_name = format!(\"{}/first-edition\", name);\n-        builder.ensure(RustbookSrc {\n-            target,\n-            name: INTERNER.intern_string(source_name),\n-            src: doc_src(builder),\n-        });\n-\n-        let source_name = format!(\"{}/second-edition\", name);\n-        builder.ensure(RustbookSrc {\n-            target,\n-            name: INTERNER.intern_string(source_name),\n-            src: doc_src(builder),\n-        });\n-\n-        let source_name = format!(\"{}/2018-edition\", name);\n-        builder.ensure(RustbookSrc {\n-            target,\n-            name: INTERNER.intern_string(source_name),\n-            src: doc_src(builder),\n-        });\n+        for edition in &[\"first-edition\", \"second-edition\", \"2018-edition\"] {\n+            builder.ensure(RustbookSrc {\n+                target,\n+                name: INTERNER.intern_string(format!(\"book/{}\", edition)),\n+                src: INTERNER.intern_path(builder.src.join(\"src/doc/book\").join(edition)),\n+            });\n+        }\n \n         // build the version info page and CSS\n         builder.ensure(Standalone { compiler, target });\n@@ -449,7 +391,7 @@ impl Step for Std {\n \n         let run_cargo_rustdoc_for = |package: &str| {\n             let mut cargo = builder.cargo(compiler, Mode::Std, target, \"rustdoc\");\n-            compile::std_cargo(builder, &compiler, target, &mut cargo);\n+            compile::std_cargo(builder, target, &mut cargo);\n \n             // Keep a whitelist so we do not build internal stdlib crates, these will be\n             // build by the rustc step later if enabled.\n@@ -531,7 +473,7 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items --passes strip-hidden\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         compile::rustc_cargo(builder, &mut cargo, target);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -618,7 +560,7 @@ impl Step for Rustdoc {\n         builder.ensure(Rustc { stage, target });\n \n         // Build rustdoc.\n-        builder.ensure(tool::Rustdoc { compiler: compiler });\n+        builder.ensure(tool::Rustdoc { compiler });\n \n         // Symlink compiler docs to the output directory of rustdoc documentation.\n         let out_dir = builder.stage_out(compiler, Mode::ToolRustc).join(target).join(\"doc\");"}, {"sha": "516be6a30c235125e546239742d7bb73e56affc4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -38,6 +38,8 @@ pub struct Flags {\n     //\n     // true => deny, false => warn\n     pub deny_warnings: Option<bool>,\n+\n+    pub llvm_skip_rebuild: Option<bool>,\n }\n \n pub enum Subcommand {\n@@ -102,7 +104,7 @@ Usage: x.py <subcommand> [options] [<paths>...]\n Subcommands:\n     build       Compile either the compiler or libraries\n     check       Compile either the compiler or libraries, using cargo check\n-    clippy      Run clippy\n+    clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n     fix         Run cargo fix\n     fmt         Run rustfmt\n     test        Build and run some test suites\n@@ -150,6 +152,14 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n+        opts.optopt(\n+            \"\",\n+            \"llvm-skip-rebuild\",\n+            \"whether rebuilding llvm should be skipped \\\n+             a VALUE of TRUE indicates that llvm will not be rebuilt \\\n+             VALUE overrides the skip-rebuild option in config.toml.\",\n+            \"VALUE\",\n+        );\n \n         // fn usage()\n         let usage =\n@@ -487,6 +497,9 @@ Arguments:\n                 .map(|p| p.into())\n                 .collect::<Vec<_>>(),\n             deny_warnings: parse_deny_warnings(&matches),\n+            llvm_skip_rebuild: matches.opt_str(\"llvm-skip-rebuild\").map(|s| s.to_lowercase()).map(\n+                |s| s.parse::<bool>().expect(\"`llvm-skip-rebuild` should be either true or false\"),\n+            ),\n         }\n     }\n }\n@@ -558,7 +571,7 @@ fn split(s: &[String]) -> Vec<String> {\n }\n \n fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n-    match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n+    match matches.opt_str(\"warnings\").as_deref() {\n         Some(\"deny\") => Some(true),\n         Some(\"warn\") => Some(false),\n         Some(value) => {"}, {"sha": "6e5e3fe07e7467065abd36bbef79a49863ce1c33", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -20,7 +20,15 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     cmd.arg(&path);\n     let cmd_debug = format!(\"{:?}\", cmd);\n     let status = cmd.status().expect(\"executing rustfmt\");\n-    assert!(status.success(), \"running {} successful\", cmd_debug);\n+    if !status.success() {\n+        eprintln!(\n+            \"Running `{}` failed.\\nIf you're running `tidy`, \\\n+            try again with `--bless` flag. Or, you just want to format \\\n+            code, run `./x.py fmt` instead.\",\n+            cmd_debug,\n+        );\n+        std::process::exit(1);\n+    }\n }\n \n #[derive(serde::Deserialize)]"}, {"sha": "6549262811b9f32a79f88186ec205cbf3716b9ce", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -126,9 +126,8 @@ fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n         None => return path.to_path_buf(),\n     };\n     for part in path.components() {\n-        match part {\n-            Component::Normal(s) => ret.push(s),\n-            _ => {}\n+        if let Component::Normal(s) = part {\n+            ret.push(s)\n         }\n     }\n     ret"}, {"sha": "efeb86540b7b7215b2c0ce2182022a1514fbe3a4", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 10, "deletions": 78, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -35,84 +35,16 @@ use std::io;\n use std::mem;\n use std::ptr;\n \n-type HANDLE = *mut u8;\n-type BOOL = i32;\n-type DWORD = u32;\n-type LPHANDLE = *mut HANDLE;\n-type LPVOID = *mut u8;\n-type JOBOBJECTINFOCLASS = i32;\n-type SIZE_T = usize;\n-type LARGE_INTEGER = i64;\n-type UINT = u32;\n-type ULONG_PTR = usize;\n-type ULONGLONG = u64;\n-\n-const FALSE: BOOL = 0;\n-const DUPLICATE_SAME_ACCESS: DWORD = 0x2;\n-const PROCESS_DUP_HANDLE: DWORD = 0x40;\n-const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = 9;\n-const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: DWORD = 0x2000;\n-const JOB_OBJECT_LIMIT_PRIORITY_CLASS: DWORD = 0x00000020;\n-const SEM_FAILCRITICALERRORS: UINT = 0x0001;\n-const SEM_NOGPFAULTERRORBOX: UINT = 0x0002;\n-const BELOW_NORMAL_PRIORITY_CLASS: DWORD = 0x00004000;\n-\n-extern \"system\" {\n-    fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n-    fn CloseHandle(hObject: HANDLE) -> BOOL;\n-    fn GetCurrentProcess() -> HANDLE;\n-    fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) -> HANDLE;\n-    fn DuplicateHandle(\n-        hSourceProcessHandle: HANDLE,\n-        hSourceHandle: HANDLE,\n-        hTargetProcessHandle: HANDLE,\n-        lpTargetHandle: LPHANDLE,\n-        dwDesiredAccess: DWORD,\n-        bInheritHandle: BOOL,\n-        dwOptions: DWORD,\n-    ) -> BOOL;\n-    fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;\n-    fn SetInformationJobObject(\n-        hJob: HANDLE,\n-        JobObjectInformationClass: JOBOBJECTINFOCLASS,\n-        lpJobObjectInformation: LPVOID,\n-        cbJobObjectInformationLength: DWORD,\n-    ) -> BOOL;\n-    fn SetErrorMode(mode: UINT) -> UINT;\n-}\n-\n-#[repr(C)]\n-struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {\n-    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,\n-    IoInfo: IO_COUNTERS,\n-    ProcessMemoryLimit: SIZE_T,\n-    JobMemoryLimit: SIZE_T,\n-    PeakProcessMemoryUsed: SIZE_T,\n-    PeakJobMemoryUsed: SIZE_T,\n-}\n-\n-#[repr(C)]\n-struct IO_COUNTERS {\n-    ReadOperationCount: ULONGLONG,\n-    WriteOperationCount: ULONGLONG,\n-    OtherOperationCount: ULONGLONG,\n-    ReadTransferCount: ULONGLONG,\n-    WriteTransferCount: ULONGLONG,\n-    OtherTransferCount: ULONGLONG,\n-}\n-\n-#[repr(C)]\n-struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n-    PerProcessUserTimeLimit: LARGE_INTEGER,\n-    PerJobUserTimeLimit: LARGE_INTEGER,\n-    LimitFlags: DWORD,\n-    MinimumWorkingsetSize: SIZE_T,\n-    MaximumWorkingsetSize: SIZE_T,\n-    ActiveProcessLimit: DWORD,\n-    Affinity: ULONG_PTR,\n-    PriorityClass: DWORD,\n-    SchedulingClass: DWORD,\n-}\n+use winapi::shared::minwindef::{DWORD, FALSE, LPVOID};\n+use winapi::um::errhandlingapi::SetErrorMode;\n+use winapi::um::handleapi::{CloseHandle, DuplicateHandle};\n+use winapi::um::jobapi2::{AssignProcessToJobObject, CreateJobObjectW, SetInformationJobObject};\n+use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcess};\n+use winapi::um::winbase::{BELOW_NORMAL_PRIORITY_CLASS, SEM_NOGPFAULTERRORBOX};\n+use winapi::um::winnt::{\n+    JobObjectExtendedLimitInformation, DUPLICATE_SAME_ACCESS, JOBOBJECT_EXTENDED_LIMIT_INFORMATION,\n+    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE, JOB_OBJECT_LIMIT_PRIORITY_CLASS, PROCESS_DUP_HANDLE,\n+};\n \n pub unsafe fn setup(build: &mut Build) {\n     // Enable the Windows Error Reporting dialog which msys disables,"}, {"sha": "a476d25f10214116918d3447ea9f60cab8966280", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -103,7 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n use std::cell::{Cell, RefCell};\n@@ -239,9 +238,10 @@ pub struct Build {\n     hosts: Vec<Interned<String>>,\n     targets: Vec<Interned<String>>,\n \n-    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents\n+    // Stage 0 (downloaded) compiler, lld and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n+    initial_lld: PathBuf,\n \n     // Runtime state filled in later on\n     // C/C++ compilers and archiver for all targets\n@@ -343,9 +343,18 @@ impl Build {\n         // we always try to use git for LLVM builds\n         let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n \n+        let initial_sysroot = config.initial_rustc.parent().unwrap().parent().unwrap();\n+        let initial_lld = initial_sysroot\n+            .join(\"lib\")\n+            .join(\"rustlib\")\n+            .join(config.build)\n+            .join(\"bin\")\n+            .join(\"rust-lld\");\n+\n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n+            initial_lld,\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n             doc_tests: config.cmd.doc_tests(),\n@@ -444,7 +453,7 @@ impl Build {\n             builder.execute_cli();\n         } else {\n             let builder = builder::Builder::new(&self);\n-            let _ = builder.execute_cli();\n+            builder.execute_cli();\n         }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n@@ -810,7 +819,7 @@ impl Build {\n     }\n \n     /// Returns the path to the linker for the given target if it needs to be overridden.\n-    fn linker(&self, target: Interned<String>) -> Option<&Path> {\n+    fn linker(&self, target: Interned<String>, can_use_lld: bool) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target).and_then(|c| c.linker.as_ref())\n         {\n             Some(linker)\n@@ -819,6 +828,8 @@ impl Build {\n             && !target.contains(\"msvc\")\n         {\n             Some(self.cc(target))\n+        } else if can_use_lld && self.config.use_lld && self.build == target {\n+            Some(&self.initial_lld)\n         } else {\n             None\n         }\n@@ -839,7 +850,7 @@ impl Build {\n             .target_config\n             .get(&target)\n             .and_then(|t| t.musl_root.as_ref())\n-            .or(self.config.musl_root.as_ref())\n+            .or_else(|| self.config.musl_root.as_ref())\n             .map(|p| &**p)\n     }\n \n@@ -1026,7 +1037,7 @@ impl Build {\n     }\n \n     fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n-        (target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\"))\n+        target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }\n \n     /// Returns the `version` string associated with this compiler for Rust"}, {"sha": "292aa3b1e24a73e7eddcfba383cf154280e62378", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -5,7 +5,6 @@ use std::process::Command;\n \n use build_helper::output;\n use serde::Deserialize;\n-use serde_json;\n \n use crate::cache::INTERNER;\n use crate::{Build, Crate};"}, {"sha": "21dcb1d8aa0e1bc2a7908d6a9cbc09209b54fd9e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 156, "deletions": 9, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -15,8 +15,6 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::{output, t};\n-use cc;\n-use cmake;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n@@ -205,7 +203,7 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n         }\n \n-        if enabled_llvm_projects.len() > 0 {\n+        if !enabled_llvm_projects.is_empty() {\n             enabled_llvm_projects.sort();\n             enabled_llvm_projects.dedup();\n             cfg.define(\"LLVM_ENABLE_PROJECTS\", enabled_llvm_projects.join(\";\"));\n@@ -230,6 +228,8 @@ impl Step for Llvm {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n             } else if target.contains(\"freebsd\") {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n+            } else if target.contains(\"windows\") {\n+                cfg.define(\"CMAKE_SYSTEM_NAME\", \"Windows\");\n             }\n \n             cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));\n@@ -262,7 +262,7 @@ impl Step for Llvm {\n             cfg.define(\"PYTHON_EXECUTABLE\", python);\n         }\n \n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g., we just want a few components and a few\n@@ -301,7 +301,12 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cmake::Config) {\n+fn configure_cmake(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+    cfg: &mut cmake::Config,\n+    use_compiler_launcher: bool,\n+) {\n     // Do not print installation messages for up-to-date files.\n     // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n     cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n@@ -372,9 +377,11 @@ fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cm\n     } else {\n         // If ccache is configured we inform the build a little differently how\n         // to invoke ccache while also invoking our compilers.\n-        if let Some(ref ccache) = builder.config.ccache {\n-            cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n-                .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+        if use_compiler_launcher {\n+            if let Some(ref ccache) = builder.config.ccache {\n+                cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n+                    .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+            }\n         }\n         cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n             .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n@@ -458,7 +465,7 @@ impl Step for Lld {\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(builder.src.join(\"src/llvm-project/lld\"));\n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n@@ -546,3 +553,143 @@ impl Step for TestHelpers {\n             .compile(\"rust_test_helpers\");\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Sanitizers {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Sanitizers {\n+    type Output = Vec<SanitizerRuntime>;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/llvm-project/compiler-rt\").path(\"src/sanitizers\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(Sanitizers { target: run.target });\n+    }\n+\n+    /// Builds sanitizer runtime libraries.\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let compiler_rt_dir = builder.src.join(\"src/llvm-project/compiler-rt\");\n+        if !compiler_rt_dir.exists() {\n+            return Vec::new();\n+        }\n+\n+        let out_dir = builder.native_dir(self.target).join(\"sanitizers\");\n+        let runtimes = supported_sanitizers(&out_dir, self.target, &builder.config.channel);\n+        if runtimes.is_empty() {\n+            return runtimes;\n+        }\n+\n+        let llvm_config = builder.ensure(Llvm { target: builder.config.build });\n+        if builder.config.dry_run {\n+            return runtimes;\n+        }\n+\n+        let done_stamp = out_dir.join(\"sanitizers-finished-building\");\n+        if done_stamp.exists() {\n+            builder.info(&format!(\n+                \"Assuming that sanitizers rebuild is not necessary. \\\n+                To force a rebuild, remove the file `{}`\",\n+                done_stamp.display()\n+            ));\n+            return runtimes;\n+        }\n+\n+        builder.info(&format!(\"Building sanitizers for {}\", self.target));\n+        let _time = util::timeit(&builder);\n+\n+        let mut cfg = cmake::Config::new(&compiler_rt_dir);\n+        cfg.profile(\"Release\");\n+        cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target);\n+        cfg.define(\"COMPILER_RT_BUILD_BUILTINS\", \"OFF\");\n+        cfg.define(\"COMPILER_RT_BUILD_CRT\", \"OFF\");\n+        cfg.define(\"COMPILER_RT_BUILD_LIBFUZZER\", \"OFF\");\n+        cfg.define(\"COMPILER_RT_BUILD_PROFILE\", \"OFF\");\n+        cfg.define(\"COMPILER_RT_BUILD_SANITIZERS\", \"ON\");\n+        cfg.define(\"COMPILER_RT_BUILD_XRAY\", \"OFF\");\n+        cfg.define(\"COMPILER_RT_DEFAULT_TARGET_ONLY\", \"ON\");\n+        cfg.define(\"COMPILER_RT_USE_LIBCXX\", \"OFF\");\n+        cfg.define(\"LLVM_CONFIG_PATH\", &llvm_config);\n+\n+        // On Darwin targets the sanitizer runtimes are build as universal binaries.\n+        // Unfortunately sccache currently lacks support to build them successfully.\n+        // Disable compiler launcher on Darwin targets to avoid potential issues.\n+        let use_compiler_launcher = !self.target.contains(\"apple-darwin\");\n+        configure_cmake(builder, self.target, &mut cfg, use_compiler_launcher);\n+\n+        t!(fs::create_dir_all(&out_dir));\n+        cfg.out_dir(out_dir);\n+\n+        for runtime in &runtimes {\n+            cfg.build_target(&runtime.cmake_target);\n+            cfg.build();\n+        }\n+\n+        t!(fs::write(&done_stamp, b\"\"));\n+\n+        runtimes\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SanitizerRuntime {\n+    /// CMake target used to build the runtime.\n+    pub cmake_target: String,\n+    /// Path to the built runtime library.\n+    pub path: PathBuf,\n+    /// Library filename that will be used rustc.\n+    pub name: String,\n+}\n+\n+/// Returns sanitizers available on a given target.\n+fn supported_sanitizers(\n+    out_dir: &Path,\n+    target: Interned<String>,\n+    channel: &str,\n+) -> Vec<SanitizerRuntime> {\n+    let mut result = Vec::new();\n+    match &*target {\n+        \"x86_64-apple-darwin\" => {\n+            for s in &[\"asan\", \"lsan\", \"tsan\"] {\n+                result.push(SanitizerRuntime {\n+                    cmake_target: format!(\"clang_rt.{}_osx_dynamic\", s),\n+                    path: out_dir\n+                        .join(&format!(\"build/lib/darwin/libclang_rt.{}_osx_dynamic.dylib\", s)),\n+                    name: format!(\"librustc-{}_rt.{}.dylib\", channel, s),\n+                });\n+            }\n+        }\n+        \"x86_64-unknown-linux-gnu\" => {\n+            for s in &[\"asan\", \"lsan\", \"msan\", \"tsan\"] {\n+                result.push(SanitizerRuntime {\n+                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n+                    path: out_dir.join(&format!(\"build/lib/linux/libclang_rt.{}-x86_64.a\", s)),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n+                });\n+            }\n+        }\n+        \"x86_64-fuchsia\" => {\n+            for s in &[\"asan\"] {\n+                result.push(SanitizerRuntime {\n+                    cmake_target: format!(\"clang_rt.{}-x86_64\", s),\n+                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-x86_64.a\", s)),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n+                });\n+            }\n+        }\n+        \"aarch64-fuchsia\" => {\n+            for s in &[\"asan\"] {\n+                result.push(SanitizerRuntime {\n+                    cmake_target: format!(\"clang_rt.{}-aarch64\", s),\n+                    path: out_dir.join(&format!(\"build/lib/fuchsia/libclang_rt.{}-aarch64.a\", s)),\n+                    name: format!(\"librustc-{}_rt.{}.a\", channel, s),\n+                });\n+            }\n+        }\n+        _ => {}\n+    }\n+    result\n+}"}, {"sha": "1580091488f20e919e2cde3cd72691cd5163d3e1", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -596,7 +596,7 @@ impl Step for RustdocTheme {\n             .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n             .env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        if let Some(linker) = builder.linker(self.compiler.host) {\n+        if let Some(linker) = builder.linker(self.compiler.host, true) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         try_run(builder, &mut cmd);\n@@ -957,14 +957,6 @@ impl Step for Compiletest {\n         }\n \n         if suite == \"debuginfo\" {\n-            let msvc = builder.config.build.contains(\"msvc\");\n-            if mode == \"debuginfo\" {\n-                return builder.ensure(Compiletest {\n-                    mode: if msvc { \"debuginfo-cdb\" } else { \"debuginfo-gdb+lldb\" },\n-                    ..self\n-                });\n-            }\n-\n             builder\n                 .ensure(dist::DebuggerScripts { sysroot: builder.sysroot(compiler), host: target });\n         }\n@@ -1043,7 +1035,8 @@ impl Step for Compiletest {\n         flags.push(\"-Zunstable-options\".to_string());\n         flags.push(builder.config.cmd.rustc_args().join(\" \"));\n \n-        if let Some(linker) = builder.linker(target) {\n+        // Don't use LLD here since we want to test that rustc finds and uses a linker by itself.\n+        if let Some(linker) = builder.linker(target, false) {\n             cmd.arg(\"--linker\").arg(linker);\n         }\n \n@@ -1157,17 +1150,14 @@ impl Step for Compiletest {\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n                 cmd.arg(\"--cc\")\n                     .arg(builder.cc(target))\n                     .arg(\"--cxx\")\n                     .arg(builder.cxx(target).unwrap())\n                     .arg(\"--cflags\")\n                     .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"))\n                     .arg(\"--llvm-components\")\n-                    .arg(llvm_components.trim())\n-                    .arg(\"--llvm-cxxflags\")\n-                    .arg(llvm_cxxflags.trim());\n+                    .arg(llvm_components.trim());\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n@@ -1205,8 +1195,6 @@ impl Step for Compiletest {\n                 .arg(\"--cflags\")\n                 .arg(\"\")\n                 .arg(\"--llvm-components\")\n-                .arg(\"\")\n-                .arg(\"--llvm-cxxflags\")\n                 .arg(\"\");\n         }\n \n@@ -1437,13 +1425,10 @@ impl Step for ErrorIndex {\n }\n \n fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) -> bool {\n-    match fs::read_to_string(markdown) {\n-        Ok(contents) => {\n-            if !contents.contains(\"```\") {\n-                return true;\n-            }\n+    if let Ok(contents) = fs::read_to_string(markdown) {\n+        if !contents.contains(\"```\") {\n+            return true;\n         }\n-        Err(_) => {}\n     }\n \n     builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n@@ -1659,7 +1644,7 @@ impl Step for Crate {\n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n             Mode::Std => {\n-                compile::std_cargo(builder, &compiler, target, &mut cargo);\n+                compile::std_cargo(builder, target, &mut cargo);\n             }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });"}, {"sha": "67e0ed5c58029df2e34414e6595430af62e01303", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -234,7 +234,7 @@ pub fn prepare_tool_cargo(\n         cargo.env(\"RUSTC_EXTERNAL_TOOL\", \"1\");\n     }\n \n-    let mut features = extra_features.iter().cloned().collect::<Vec<_>>();\n+    let mut features = extra_features.to_vec();\n     if builder.build.config.cargo_native_static {\n         if path.ends_with(\"cargo\")\n             || path.ends_with(\"rls\")\n@@ -289,8 +289,8 @@ fn rustbook_features() -> Vec<String> {\n macro_rules! bootstrap_tool {\n     ($(\n         $name:ident, $path:expr, $tool_name:expr\n-        $(,llvm_tools = $llvm:expr)*\n         $(,is_external_tool = $external:expr)*\n+        $(,is_unstable_tool = $unstable:expr)*\n         $(,features = $features:expr)*\n         ;\n     )+) => {\n@@ -301,15 +301,6 @@ macro_rules! bootstrap_tool {\n             )+\n         }\n \n-        impl Tool {\n-            /// Whether this tool requires LLVM to run\n-            pub fn uses_llvm_tools(&self) -> bool {\n-                match self {\n-                    $(Tool::$name => false $(|| $llvm)*,)+\n-                }\n-            }\n-        }\n-\n         impl<'a> Builder<'a> {\n             pub fn tool_exe(&self, tool: Tool) -> PathBuf {\n                 match tool {\n@@ -350,7 +341,12 @@ macro_rules! bootstrap_tool {\n                     compiler: self.compiler,\n                     target: self.target,\n                     tool: $tool_name,\n-                    mode: Mode::ToolBootstrap,\n+                    mode: if false $(|| $unstable)* {\n+                        // use in-tree libraries for unstable features\n+                        Mode::ToolStd\n+                    } else {\n+                        Mode::ToolBootstrap\n+                    },\n                     path: $path,\n                     is_optional_tool: false,\n                     source_type: if false $(|| $external)* {\n@@ -377,7 +373,7 @@ bootstrap_tool!(\n     Tidy, \"src/tools/tidy\", \"tidy\";\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";\n     CargoTest, \"src/tools/cargotest\", \"cargotest\";\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", llvm_tools = true;\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", is_unstable_tool = true;\n     BuildManifest, \"src/tools/build-manifest\", \"build-manifest\";\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;"}, {"sha": "bb012a38855117e741a9810da13763d8d5ce0c8f", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -124,7 +124,7 @@ fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n     let output = t!(String::from_utf8(output.stdout));\n \n     for (tool, submodule) in STABLE_TOOLS.iter().chain(NIGHTLY_TOOLS.iter()) {\n-        let changed = output.lines().any(|l| l.starts_with(\"M\") && l.ends_with(submodule));\n+        let changed = output.lines().any(|l| l.starts_with('M') && l.ends_with(submodule));\n         eprintln!(\"Verifying status of {}...\", tool);\n         if !changed {\n             continue;"}, {"sha": "eac790fe504b8e1f9a84fdbde31b232d02bb4c2a", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -98,7 +98,7 @@ impl Drop for TimeIt {\n     fn drop(&mut self) {\n         let time = self.1.elapsed();\n         if !self.0 {\n-            println!(\"\\tfinished in {}.{:03}\", time.as_secs(), time.subsec_nanos() / 1_000_000);\n+            println!(\"\\tfinished in {}.{:03}\", time.as_secs(), time.subsec_millis());\n         }\n     }\n }\n@@ -123,37 +123,24 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     // what can be found here:\n     //\n     // http://www.flexhex.com/docs/articles/hard-links.phtml\n-    //\n-    // Copied from std\n     #[cfg(windows)]\n-    #[allow(nonstandard_style)]\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n         use std::ffi::OsStr;\n         use std::os::windows::ffi::OsStrExt;\n         use std::ptr;\n \n-        const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-        const GENERIC_WRITE: DWORD = 0x40000000;\n-        const OPEN_EXISTING: DWORD = 3;\n-        const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n-        const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n-        const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n-        const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\n-        const FILE_SHARE_DELETE: DWORD = 0x4;\n-        const FILE_SHARE_READ: DWORD = 0x1;\n-        const FILE_SHARE_WRITE: DWORD = 0x2;\n-\n-        type BOOL = i32;\n-        type DWORD = u32;\n-        type HANDLE = *mut u8;\n-        type LPCWSTR = *const u16;\n-        type LPDWORD = *mut DWORD;\n-        type LPOVERLAPPED = *mut u8;\n-        type LPSECURITY_ATTRIBUTES = *mut u8;\n-        type LPVOID = *mut u8;\n-        type WCHAR = u16;\n-        type WORD = u16;\n-\n+        use winapi::shared::minwindef::{DWORD, WORD};\n+        use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};\n+        use winapi::um::handleapi::CloseHandle;\n+        use winapi::um::ioapiset::DeviceIoControl;\n+        use winapi::um::winbase::{FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_OPEN_REPARSE_POINT};\n+        use winapi::um::winioctl::FSCTL_SET_REPARSE_POINT;\n+        use winapi::um::winnt::{\n+            FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE, GENERIC_WRITE,\n+            IO_REPARSE_TAG_MOUNT_POINT, MAXIMUM_REPARSE_DATA_BUFFER_SIZE, WCHAR,\n+        };\n+\n+        #[allow(non_snake_case)]\n         #[repr(C)]\n         struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n             ReparseTag: DWORD,\n@@ -165,29 +152,6 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             ReparseTarget: WCHAR,\n         }\n \n-        extern \"system\" {\n-            fn CreateFileW(\n-                lpFileName: LPCWSTR,\n-                dwDesiredAccess: DWORD,\n-                dwShareMode: DWORD,\n-                lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                dwCreationDisposition: DWORD,\n-                dwFlagsAndAttributes: DWORD,\n-                hTemplateFile: HANDLE,\n-            ) -> HANDLE;\n-            fn DeviceIoControl(\n-                hDevice: HANDLE,\n-                dwIoControlCode: DWORD,\n-                lpInBuffer: LPVOID,\n-                nInBufferSize: DWORD,\n-                lpOutBuffer: LPVOID,\n-                nOutBufferSize: DWORD,\n-                lpBytesReturned: LPDWORD,\n-                lpOverlapped: LPOVERLAPPED,\n-            ) -> BOOL;\n-            fn CloseHandle(hObject: HANDLE) -> BOOL;\n-        }\n-\n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n             Ok(s.as_ref().encode_wide().chain(Some(0)).collect())\n         }\n@@ -212,7 +176,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n                 ptr::null_mut(),\n             );\n \n-            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize];\n             let db = data.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n             let buf = &mut (*db).ReparseTarget as *mut u16;\n             let mut i = 0;"}, {"sha": "43c3c5773ce5b2d45cd32ee1157cf2d8ce0dc1b2", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,7 +1,5 @@\n-use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n-use std::thread;\n use std::time::{SystemTime, UNIX_EPOCH};\n use std::{env, fs};\n \n@@ -181,108 +179,6 @@ pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n     }\n }\n \n-#[must_use]\n-pub struct NativeLibBoilerplate {\n-    pub src_dir: PathBuf,\n-    pub out_dir: PathBuf,\n-}\n-\n-impl NativeLibBoilerplate {\n-    /// On macOS we don't want to ship the exact filename that compiler-rt builds.\n-    /// This conflicts with the system and ours is likely a wildly different\n-    /// version, so they can't be substituted.\n-    ///\n-    /// As a result, we rename it here but we need to also use\n-    /// `install_name_tool` on macOS to rename the commands listed inside of it to\n-    /// ensure it's linked against correctly.\n-    pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n-        if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {\n-            return;\n-        }\n-\n-        let dir = self.out_dir.join(\"build/lib/darwin\");\n-        let name = format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name);\n-        let src = dir.join(&format!(\"lib{}.dylib\", name));\n-        let new_name = format!(\"lib__rustc__{}.dylib\", name);\n-        let dst = dir.join(&new_name);\n-\n-        println!(\"{} => {}\", src.display(), dst.display());\n-        fs::rename(&src, &dst).unwrap();\n-        let status = Command::new(\"install_name_tool\")\n-            .arg(\"-id\")\n-            .arg(format!(\"@rpath/{}\", new_name))\n-            .arg(&dst)\n-            .status()\n-            .expect(\"failed to execute `install_name_tool`\");\n-        assert!(status.success());\n-    }\n-}\n-\n-impl Drop for NativeLibBoilerplate {\n-    fn drop(&mut self) {\n-        if !thread::panicking() {\n-            t!(File::create(self.out_dir.join(\"rustbuild.timestamp\")));\n-        }\n-    }\n-}\n-\n-// Perform standard preparations for native libraries that are build only once for all stages.\n-// Emit rerun-if-changed and linking attributes for Cargo, check if any source files are\n-// updated, calculate paths used later in actual build with CMake/make or C/C++ compiler.\n-// If Err is returned, then everything is up-to-date and further build actions can be skipped.\n-// Timestamps are created automatically when the result of `native_lib_boilerplate` goes out\n-// of scope, so all the build actions should be completed until then.\n-pub fn native_lib_boilerplate(\n-    src_dir: &Path,\n-    out_name: &str,\n-    link_name: &str,\n-    search_subdir: &str,\n-) -> Result<NativeLibBoilerplate, ()> {\n-    rerun_if_changed_anything_in_dir(src_dir);\n-\n-    let out_dir =\n-        env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or_else(|| env::var_os(\"OUT_DIR\").unwrap());\n-    let out_dir = PathBuf::from(out_dir).join(out_name);\n-    t!(fs::create_dir_all(&out_dir));\n-    if link_name.contains('=') {\n-        println!(\"cargo:rustc-link-lib={}\", link_name);\n-    } else {\n-        println!(\"cargo:rustc-link-lib=static={}\", link_name);\n-    }\n-    println!(\"cargo:rustc-link-search=native={}\", out_dir.join(search_subdir).display());\n-\n-    let timestamp = out_dir.join(\"rustbuild.timestamp\");\n-    if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n-        Ok(NativeLibBoilerplate { src_dir: src_dir.to_path_buf(), out_dir })\n-    } else {\n-        Err(())\n-    }\n-}\n-\n-pub fn sanitizer_lib_boilerplate(\n-    sanitizer_name: &str,\n-) -> Result<(NativeLibBoilerplate, String), ()> {\n-    let (link_name, search_path, apple) = match &*env::var(\"TARGET\").unwrap() {\n-        \"x86_64-unknown-linux-gnu\" => {\n-            (format!(\"clang_rt.{}-x86_64\", sanitizer_name), \"build/lib/linux\", false)\n-        }\n-        \"x86_64-apple-darwin\" => {\n-            (format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name), \"build/lib/darwin\", true)\n-        }\n-        _ => return Err(()),\n-    };\n-    let to_link = if apple {\n-        format!(\"dylib=__rustc__{}\", link_name)\n-    } else {\n-        format!(\"static={}\", link_name)\n-    };\n-    // This env var is provided by rustbuild to tell us where `compiler-rt`\n-    // lives.\n-    let dir = env::var_os(\"RUST_COMPILER_RT_ROOT\").unwrap();\n-    let lib = native_lib_boilerplate(dir.as_ref(), sanitizer_name, &to_link, search_path)?;\n-    Ok((lib, link_name))\n-}\n-\n fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n         let meta = t!(e.metadata());"}, {"sha": "78ac060368193964fb3fb8420e63894810802863", "filename": "src/ci/cpu-usage-over-time.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -148,11 +148,11 @@ def idle_since(self, prev):\n     print('unknown platform', sys.platform)\n     sys.exit(1)\n \n-cur_state = State();\n+cur_state = State()\n print(\"Time,Idle\")\n while True:\n-    time.sleep(1);\n-    next_state = State();\n+    time.sleep(1)\n+    next_state = State()\n     now = datetime.datetime.utcnow().isoformat()\n     idle = next_state.idle_since(cur_state)\n     print(\"%s,%s\" % (now, idle))"}, {"sha": "2a68a25be21b3342642d51b6ee7f8494dfbedd6f", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -2,11 +2,24 @@ FROM ubuntu:16.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  flex \\\n+  help2man \\\n+  libtool-bin \\\n+  texinfo \\\n+  unzip \\\n+  wget \\\n+  xz-utils \\\n+  libncurses-dev \\\n+  gawk \\\n   make \\\n   file \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -35,6 +48,18 @@ RUN add-apt-repository ppa:team-gcc-arm-embedded/ppa && \\\n     apt-get update && \\\n     apt-get install -y --no-install-recommends gcc-arm-embedded\n \n+COPY scripts/rustbuild-setup.sh dist-various-1/build-riscv-toolchain.sh dist-various-1/riscv64-unknown-linux-gnu.config dist-various-1/crosstool-ng.sh /build/\n+RUN ./crosstool-ng.sh\n+\n+# Crosstool-ng will refuse to build as root\n+RUN sh ./rustbuild-setup.sh\n+USER rustbuild\n+\n+RUN ./build-riscv-toolchain.sh\n+\n+USER root\n+ENV PATH=/x-tools/riscv64-unknown-linux-gnu/bin:$PATH\n+\n COPY dist-various-1/build-rumprun.sh /build\n RUN ./build-rumprun.sh\n \n@@ -129,11 +154,13 @@ ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64gc-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64gc-unknown-linux-gnu\n ENV TARGETS=$TARGETS,armebv7r-none-eabi\n ENV TARGETS=$TARGETS,armebv7r-none-eabihf\n ENV TARGETS=$TARGETS,armv7r-none-eabi\n ENV TARGETS=$TARGETS,armv7r-none-eabihf\n ENV TARGETS=$TARGETS,thumbv7neon-unknown-linux-gnueabihf\n+ENV TARGETS=$TARGETS,armv7a-none-eabi\n \n # riscv targets currently do not need a C compiler, as compiler_builtins\n # doesn't currently have it enabled, and the riscv gcc compiler is not\n@@ -147,6 +174,13 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ \\\n+    CC_armv7a_none_eabi=arm-none-eabi-gcc \\\n+    CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n+    CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n+    CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n+    CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n+    AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n+    CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n     CC_riscv32i_unknown_none_elf=false \\\n     CC_riscv32imc_unknown_none_elf=false \\\n     CC_riscv32imac_unknown_none_elf=false \\"}, {"sha": "9cb5700b3b6fb1eb352863c3a81f7ce833207c3d", "filename": "src/ci/docker/dist-various-1/build-riscv-toolchain.sh", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,27 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir -p /tmp/build-riscv\n+cp riscv64-unknown-linux-gnu.config /tmp/build-riscv/.config\n+cd /tmp/build-riscv\n+hide_output ct-ng build\n+cd ..\n+rm -rf build-riscv"}, {"sha": "b01fdd0bf65e7f355dc1c28207ee3cf13f3f53a8", "filename": "src/ci/docker/dist-various-1/crosstool-ng.sh", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,13 @@\n+#!/bin/bash\n+set -ex\n+\n+# Mirrored from https://github.com/crosstool-ng/crosstool-ng/archive/crosstool-ng-1.24.0.tar.gz\n+url=\"https://ci-mirrors.rust-lang.org/rustc/crosstool-ng-1.24.0.tar.gz\"\n+curl -Lf $url | tar xzf -\n+cd crosstool-ng-crosstool-ng-1.24.0\n+./bootstrap\n+./configure --prefix=/usr/local\n+make -j$(nproc)\n+make install\n+cd ..\n+rm -rf crosstool-ng-crosstool-ng-1.24.0"}, {"sha": "dd06065b19740a2456d9ebcaf759d483075f4672", "filename": "src/ci/docker/dist-various-1/riscv64-unknown-linux-gnu.config", "status": "added", "additions": 908, "deletions": 0, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,908 @@\n+#\n+# Automatically generated file; DO NOT EDIT.\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_python_3_4_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_dtc=y\n+CT_CONFIGURE_has_svn=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n+CT_MODULES=y\n+\n+#\n+# Paths and misc options\n+#\n+\n+#\n+# crosstool-NG behavior\n+#\n+# CT_OBSOLETE is not set\n+CT_EXPERIMENTAL=y\n+# CT_ALLOW_BUILD_AS_ROOT is not set\n+# CT_DEBUG_CT is not set\n+\n+#\n+# Paths\n+#\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n+CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n+CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n+CT_RM_RF_PREFIX_DIR=y\n+CT_REMOVE_DOCS=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n+CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n+# CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n+\n+#\n+# Downloading\n+#\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n+# CT_FORBID_DOWNLOAD is not set\n+# CT_FORCE_DOWNLOAD is not set\n+CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n+# CT_ONLY_DOWNLOAD is not set\n+# CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n+\n+#\n+# Extracting\n+#\n+# CT_FORCE_EXTRACT is not set\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n+# CT_ONLY_EXTRACT is not set\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_LOCAL is not set\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+# CT_PATCH_LOCAL_BUNDLED is not set\n+# CT_PATCH_NONE is not set\n+CT_PATCH_ORDER=\"bundled\"\n+\n+#\n+# Build behavior\n+#\n+CT_PARALLEL_JOBS=0\n+CT_LOAD=\"\"\n+CT_USE_PIPES=y\n+CT_EXTRA_CFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_LDFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_CFLAGS_FOR_HOST=\"\"\n+CT_EXTRA_LDFLAGS_FOR_HOST=\"\"\n+# CT_CONFIG_SHELL_SH is not set\n+# CT_CONFIG_SHELL_ASH is not set\n+CT_CONFIG_SHELL_BASH=y\n+# CT_CONFIG_SHELL_CUSTOM is not set\n+CT_CONFIG_SHELL=\"${bash}\"\n+\n+#\n+# Logging\n+#\n+# CT_LOG_ERROR is not set\n+# CT_LOG_WARN is not set\n+# CT_LOG_INFO is not set\n+# CT_LOG_EXTRA is not set\n+CT_LOG_ALL=y\n+# CT_LOG_DEBUG is not set\n+CT_LOG_LEVEL_MAX=\"ALL\"\n+# CT_LOG_SEE_TOOLS_WARN is not set\n+CT_LOG_TO_FILE=y\n+CT_LOG_FILE_COMPRESS=y\n+\n+#\n+# Target options\n+#\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+# CT_ARCH_ARM is not set\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MICROBLAZE is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_MOXIE is not set\n+# CT_ARCH_MSP430 is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+CT_ARCH_RISCV=y\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n+CT_ARCH=\"riscv\"\n+CT_ARCH_CHOICE_KSYM=\"RISCV\"\n+CT_ARCH_TUNE=\"\"\n+CT_ARCH_RISCV_SHOW=y\n+\n+#\n+# Options for riscv\n+#\n+CT_ARCH_RISCV_PKG_KSYM=\"\"\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n+CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n+\n+#\n+# Generic target options\n+#\n+# CT_MULTILIB is not set\n+# CT_DEMULTILIB is not set\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=64\n+# CT_ARCH_32 is not set\n+CT_ARCH_64=y\n+\n+#\n+# Target optimisations\n+#\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_ABI=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_ARCH=\"rv64gc\"\n+CT_ARCH_ABI=\"\"\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n+\n+#\n+# Toolchain options\n+#\n+\n+#\n+# General toolchain options\n+#\n+CT_FORCE_SYSROOT=y\n+CT_USE_SYSROOT=y\n+CT_SYSROOT_NAME=\"sysroot\"\n+CT_SYSROOT_DIR_PREFIX=\"\"\n+CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n+# CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n+CT_TOOLCHAIN_PKGVERSION=\"\"\n+CT_TOOLCHAIN_BUGURL=\"\"\n+\n+#\n+# Tuple completion and aliasing\n+#\n+CT_TARGET_VENDOR=\"unknown\"\n+CT_TARGET_ALIAS_SED_EXPR=\"\"\n+CT_TARGET_ALIAS=\"\"\n+\n+#\n+# Toolchain type\n+#\n+# CT_NATIVE is not set\n+CT_CROSS=y\n+# CT_CROSS_NATIVE is not set\n+# CT_CANADIAN is not set\n+CT_TOOLCHAIN_TYPE=\"cross\"\n+\n+#\n+# Build system\n+#\n+CT_BUILD=\"\"\n+CT_BUILD_PREFIX=\"\"\n+CT_BUILD_SUFFIX=\"\"\n+\n+#\n+# Misc options\n+#\n+# CT_TOOLCHAIN_ENABLE_NLS is not set\n+\n+#\n+# Operating System\n+#\n+CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n+CT_KERNEL=\"linux\"\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+# CT_LINUX_SRC_DEVEL is not set\n+# CT_LINUX_SRC_CUSTOM is not set\n+CT_LINUX_PATCH_GLOBAL=y\n+# CT_LINUX_PATCH_BUNDLED is not set\n+# CT_LINUX_PATCH_LOCAL is not set\n+# CT_LINUX_PATCH_BUNDLED_LOCAL is not set\n+# CT_LINUX_PATCH_LOCAL_BUNDLED is not set\n+# CT_LINUX_PATCH_NONE is not set\n+CT_LINUX_PATCH_ORDER=\"global\"\n+CT_LINUX_V_4_20=y\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+# CT_LINUX_V_3_2 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"4.20.8\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_later_than_4_8=y\n+CT_LINUX_4_8_or_later=y\n+CT_LINUX_later_than_3_7=y\n+CT_LINUX_3_7_or_later=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n+CT_LINUX_REQUIRE_3_2_or_later=y\n+CT_KERNEL_LINUX_VERBOSITY_0=y\n+# CT_KERNEL_LINUX_VERBOSITY_1 is not set\n+# CT_KERNEL_LINUX_VERBOSITY_2 is not set\n+CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n+CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n+\n+#\n+# Binary utilities\n+#\n+CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n+CT_BINUTILS=\"binutils\"\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+# CT_BINUTILS_SRC_DEVEL is not set\n+# CT_BINUTILS_SRC_CUSTOM is not set\n+CT_BINUTILS_PATCH_GLOBAL=y\n+# CT_BINUTILS_PATCH_BUNDLED is not set\n+# CT_BINUTILS_PATCH_LOCAL is not set\n+# CT_BINUTILS_PATCH_BUNDLED_LOCAL is not set\n+# CT_BINUTILS_PATCH_LOCAL_BUNDLED is not set\n+# CT_BINUTILS_PATCH_NONE is not set\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_REQUIRE_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n+\n+#\n+# GNU binutils\n+#\n+CT_BINUTILS_HAS_HASH_STYLE=y\n+CT_BINUTILS_HAS_GOLD=y\n+CT_BINUTILS_HAS_PLUGINS=y\n+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n+CT_BINUTILS_LINKER_LD=y\n+CT_BINUTILS_LINKERS_LIST=\"ld\"\n+CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n+# CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n+CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_BINUTILS_FOR_TARGET is not set\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n+\n+#\n+# C-library\n+#\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_MUSL is not set\n+# CT_LIBC_UCLIBC is not set\n+CT_LIBC=\"glibc\"\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n+CT_THREADS=\"nptl\"\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+# CT_GLIBC_SRC_DEVEL is not set\n+# CT_GLIBC_SRC_CUSTOM is not set\n+CT_GLIBC_PATCH_GLOBAL=y\n+# CT_GLIBC_PATCH_BUNDLED is not set\n+# CT_GLIBC_PATCH_LOCAL is not set\n+# CT_GLIBC_PATCH_BUNDLED_LOCAL is not set\n+# CT_GLIBC_PATCH_LOCAL_BUNDLED is not set\n+# CT_GLIBC_PATCH_NONE is not set\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+CT_GLIBC_V_2_29=y\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.29\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_later=y\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_REQUIRE_2_29_or_later=y\n+CT_GLIBC_later_than_2_27=y\n+CT_GLIBC_2_27_or_later=y\n+CT_GLIBC_later_than_2_26=y\n+CT_GLIBC_2_26_or_later=y\n+CT_GLIBC_later_than_2_25=y\n+CT_GLIBC_2_25_or_later=y\n+CT_GLIBC_later_than_2_24=y\n+CT_GLIBC_2_24_or_later=y\n+CT_GLIBC_later_than_2_23=y\n+CT_GLIBC_2_23_or_later=y\n+CT_GLIBC_later_than_2_20=y\n+CT_GLIBC_2_20_or_later=y\n+CT_GLIBC_later_than_2_17=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_BUILD_SSP=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_NO_SPARC_V8=y\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_ENABLE_FORTIFIED_BUILD is not set\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+CT_GLIBC_KERNEL_VERSION_NONE=y\n+# CT_GLIBC_KERNEL_VERSION_AS_HEADERS is not set\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"\"\n+CT_GLIBC_SSP_DEFAULT=y\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_GLIBC_ENABLE_WERROR is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n+CT_LIBC_SUPPORT_THREADS_ANY=y\n+CT_LIBC_SUPPORT_THREADS_NATIVE=y\n+\n+#\n+# Common C library options\n+#\n+CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n+CT_LIBC_XLDD=y\n+\n+#\n+# C compiler\n+#\n+CT_CC_CORE_PASSES_NEEDED=y\n+CT_CC_CORE_PASS_1_NEEDED=y\n+CT_CC_CORE_PASS_2_NEEDED=y\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+# CT_GCC_USE_LINARO is not set\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+# CT_GCC_SRC_DEVEL is not set\n+# CT_GCC_SRC_CUSTOM is not set\n+CT_GCC_PATCH_GLOBAL=y\n+# CT_GCC_PATCH_BUNDLED is not set\n+# CT_GCC_PATCH_LOCAL is not set\n+# CT_GCC_PATCH_BUNDLED_LOCAL is not set\n+# CT_GCC_PATCH_LOCAL_BUNDLED is not set\n+# CT_GCC_PATCH_NONE is not set\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_REQUIRE_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_REQUIRE_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_REQUIRE_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n+CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n+CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_STATIC_LIBSTDCXX=y\n+# CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n+\n+#\n+# Optimisation features\n+#\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n+\n+#\n+# Settings for libraries running on target\n+#\n+CT_CC_GCC_ENABLE_TARGET_OPTSPACE=y\n+# CT_CC_GCC_LIBMUDFLAP is not set\n+# CT_CC_GCC_LIBGOMP is not set\n+# CT_CC_GCC_LIBSSP is not set\n+# CT_CC_GCC_LIBQUADMATH is not set\n+# CT_CC_GCC_LIBSANITIZER is not set\n+\n+#\n+# Misc. obscure options.\n+#\n+CT_CC_CXA_ATEXIT=y\n+# CT_CC_GCC_DISABLE_PCH is not set\n+CT_CC_GCC_SJLJ_EXCEPTIONS=m\n+CT_CC_GCC_LDBL_128=m\n+# CT_CC_GCC_BUILD_ID is not set\n+CT_CC_GCC_LNK_HASH_STYLE_DEFAULT=y\n+# CT_CC_GCC_LNK_HASH_STYLE_SYSV is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_GNU is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_BOTH is not set\n+CT_CC_GCC_LNK_HASH_STYLE=\"\"\n+CT_CC_GCC_DEC_FLOAT_AUTO=y\n+# CT_CC_GCC_DEC_FLOAT_BID is not set\n+# CT_CC_GCC_DEC_FLOAT_DPD is not set\n+# CT_CC_GCC_DEC_FLOATS_NO is not set\n+CT_ALL_CC_CHOICES=\"GCC\"\n+\n+#\n+# Additional supported languages:\n+#\n+CT_CC_LANG_CXX=y\n+# CT_CC_LANG_FORTRAN is not set\n+# CT_CC_LANG_ADA is not set\n+# CT_CC_LANG_OBJC is not set\n+# CT_CC_LANG_OBJCXX is not set\n+# CT_CC_LANG_GOLANG is not set\n+CT_CC_LANG_OTHERS=\"\"\n+\n+#\n+# Debug facilities\n+#\n+# CT_DEBUG_DUMA is not set\n+CT_DEBUG_GDB=y\n+CT_DEBUG_GDB_PKG_KSYM=\"GDB\"\n+CT_GDB_DIR_NAME=\"gdb\"\n+CT_GDB_USE_GNU=y\n+CT_GDB_USE=\"GDB\"\n+CT_GDB_PKG_NAME=\"gdb\"\n+CT_GDB_SRC_RELEASE=y\n+# CT_GDB_SRC_DEVEL is not set\n+# CT_GDB_SRC_CUSTOM is not set\n+CT_GDB_PATCH_GLOBAL=y\n+# CT_GDB_PATCH_BUNDLED is not set\n+# CT_GDB_PATCH_LOCAL is not set\n+# CT_GDB_PATCH_BUNDLED_LOCAL is not set\n+# CT_GDB_PATCH_LOCAL_BUNDLED is not set\n+# CT_GDB_PATCH_NONE is not set\n+CT_GDB_PATCH_ORDER=\"global\"\n+CT_GDB_V_8_2=y\n+# CT_GDB_V_8_1 is not set\n+# CT_GDB_V_8_0 is not set\n+# CT_GDB_NO_VERSIONS is not set\n+CT_GDB_VERSION=\"8.2.1\"\n+CT_GDB_MIRRORS=\"$(CT_Mirrors GNU gdb) $(CT_Mirrors sourceware gdb/releases)\"\n+CT_GDB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GDB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GDB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GDB_SIGNATURE_FORMAT=\"\"\n+CT_GDB_later_than_8_0=y\n+CT_GDB_8_0_or_later=y\n+CT_GDB_REQUIRE_8_0_or_later=y\n+CT_GDB_later_than_7_12=y\n+CT_GDB_7_12_or_later=y\n+CT_GDB_later_than_7_2=y\n+CT_GDB_7_2_or_later=y\n+CT_GDB_later_than_7_0=y\n+CT_GDB_7_0_or_later=y\n+CT_GDB_CROSS=y\n+# CT_GDB_CROSS_STATIC is not set\n+# CT_GDB_CROSS_SIM is not set\n+# CT_GDB_CROSS_PYTHON is not set\n+CT_GDB_CROSS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_GDB_NATIVE is not set\n+# CT_GDB_GDBSERVER is not set\n+CT_GDB_HAS_PKGVERSION_BUGURL=y\n+CT_GDB_HAS_PYTHON=y\n+CT_GDB_INSTALL_GDBINIT=y\n+CT_GDB_HAS_IPA_LIB=y\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n+\n+#\n+# Companion libraries\n+#\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+CT_COMP_LIBS_EXPAT=y\n+CT_COMP_LIBS_EXPAT_PKG_KSYM=\"EXPAT\"\n+CT_EXPAT_DIR_NAME=\"expat\"\n+CT_EXPAT_PKG_NAME=\"expat\"\n+CT_EXPAT_SRC_RELEASE=y\n+# CT_EXPAT_SRC_DEVEL is not set\n+# CT_EXPAT_SRC_CUSTOM is not set\n+CT_EXPAT_PATCH_GLOBAL=y\n+# CT_EXPAT_PATCH_BUNDLED is not set\n+# CT_EXPAT_PATCH_LOCAL is not set\n+# CT_EXPAT_PATCH_BUNDLED_LOCAL is not set\n+# CT_EXPAT_PATCH_LOCAL_BUNDLED is not set\n+# CT_EXPAT_PATCH_NONE is not set\n+CT_EXPAT_PATCH_ORDER=\"global\"\n+CT_EXPAT_V_2_2=y\n+# CT_EXPAT_NO_VERSIONS is not set\n+CT_EXPAT_VERSION=\"2.2.6\"\n+CT_EXPAT_MIRRORS=\"http://downloads.sourceforge.net/project/expat/expat/${CT_EXPAT_VERSION}\"\n+CT_EXPAT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_EXPAT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_EXPAT_ARCHIVE_FORMATS=\".tar.bz2\"\n+CT_EXPAT_SIGNATURE_FORMAT=\"\"\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+# CT_GETTEXT_SRC_DEVEL is not set\n+# CT_GETTEXT_SRC_CUSTOM is not set\n+CT_GETTEXT_PATCH_GLOBAL=y\n+# CT_GETTEXT_PATCH_BUNDLED is not set\n+# CT_GETTEXT_PATCH_LOCAL is not set\n+# CT_GETTEXT_PATCH_BUNDLED_LOCAL is not set\n+# CT_GETTEXT_PATCH_LOCAL_BUNDLED is not set\n+# CT_GETTEXT_PATCH_NONE is not set\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+# CT_GMP_SRC_DEVEL is not set\n+# CT_GMP_SRC_CUSTOM is not set\n+CT_GMP_PATCH_GLOBAL=y\n+# CT_GMP_PATCH_BUNDLED is not set\n+# CT_GMP_PATCH_LOCAL is not set\n+# CT_GMP_PATCH_BUNDLED_LOCAL is not set\n+# CT_GMP_PATCH_LOCAL_BUNDLED is not set\n+# CT_GMP_PATCH_NONE is not set\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+# CT_ISL_SRC_DEVEL is not set\n+# CT_ISL_SRC_CUSTOM is not set\n+CT_ISL_PATCH_GLOBAL=y\n+# CT_ISL_PATCH_BUNDLED is not set\n+# CT_ISL_PATCH_LOCAL is not set\n+# CT_ISL_PATCH_BUNDLED_LOCAL is not set\n+# CT_ISL_PATCH_LOCAL_BUNDLED is not set\n+# CT_ISL_PATCH_NONE is not set\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+# CT_LIBICONV_SRC_DEVEL is not set\n+# CT_LIBICONV_SRC_CUSTOM is not set\n+CT_LIBICONV_PATCH_GLOBAL=y\n+# CT_LIBICONV_PATCH_BUNDLED is not set\n+# CT_LIBICONV_PATCH_LOCAL is not set\n+# CT_LIBICONV_PATCH_BUNDLED_LOCAL is not set\n+# CT_LIBICONV_PATCH_LOCAL_BUNDLED is not set\n+# CT_LIBICONV_PATCH_NONE is not set\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+# CT_MPC_SRC_DEVEL is not set\n+# CT_MPC_SRC_CUSTOM is not set\n+CT_MPC_PATCH_GLOBAL=y\n+# CT_MPC_PATCH_BUNDLED is not set\n+# CT_MPC_PATCH_LOCAL is not set\n+# CT_MPC_PATCH_BUNDLED_LOCAL is not set\n+# CT_MPC_PATCH_LOCAL_BUNDLED is not set\n+# CT_MPC_PATCH_NONE is not set\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+# CT_MPFR_SRC_DEVEL is not set\n+# CT_MPFR_SRC_CUSTOM is not set\n+CT_MPFR_PATCH_GLOBAL=y\n+# CT_MPFR_PATCH_BUNDLED is not set\n+# CT_MPFR_PATCH_LOCAL is not set\n+# CT_MPFR_PATCH_BUNDLED_LOCAL is not set\n+# CT_MPFR_PATCH_LOCAL_BUNDLED is not set\n+# CT_MPFR_PATCH_NONE is not set\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+# CT_NCURSES_SRC_DEVEL is not set\n+# CT_NCURSES_SRC_CUSTOM is not set\n+CT_NCURSES_PATCH_GLOBAL=y\n+# CT_NCURSES_PATCH_BUNDLED is not set\n+# CT_NCURSES_PATCH_LOCAL is not set\n+# CT_NCURSES_PATCH_BUNDLED_LOCAL is not set\n+# CT_NCURSES_PATCH_LOCAL_BUNDLED is not set\n+# CT_NCURSES_PATCH_NONE is not set\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+# CT_NCURSES_NEW_ABI is not set\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+# CT_ZLIB_SRC_DEVEL is not set\n+# CT_ZLIB_SRC_CUSTOM is not set\n+CT_ZLIB_PATCH_GLOBAL=y\n+# CT_ZLIB_PATCH_BUNDLED is not set\n+# CT_ZLIB_PATCH_LOCAL is not set\n+# CT_ZLIB_PATCH_BUNDLED_LOCAL is not set\n+# CT_ZLIB_PATCH_LOCAL_BUNDLED is not set\n+# CT_ZLIB_PATCH_NONE is not set\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n+CT_LIBICONV_NEEDED=y\n+CT_GETTEXT_NEEDED=y\n+CT_GMP_NEEDED=y\n+CT_MPFR_NEEDED=y\n+CT_ISL_NEEDED=y\n+CT_MPC_NEEDED=y\n+CT_EXPAT_NEEDED=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n+CT_LIBICONV=y\n+CT_GETTEXT=y\n+CT_GMP=y\n+CT_MPFR=y\n+CT_ISL=y\n+CT_MPC=y\n+CT_EXPAT=y\n+CT_NCURSES=y\n+CT_ZLIB=y\n+\n+#\n+# Companion tools\n+#\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\"\n+\n+#\n+# Test suite\n+#\n+# CT_TEST_SUITE_GCC is not set"}, {"sha": "5bb5436bec59d3faafa838e5d3fb32b232a17292", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -48,7 +48,7 @@ RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n-RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"53b586346f2c7870e20b170decdc30729d97c42b\"\n+RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"5125c169b30837208a842f85f7ae44a83533bd0e\"\n \n COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n RUN /tmp/build-wasi-toolchain.sh"}, {"sha": "b8686775642983b6888d3dbd1350a0d0def8fba9", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-libc\n \n cd wasi-libc\n-git reset --hard f645f498dfbbbc00a7a97874d33082d3605c3f21\n+git reset --hard 1fad33890a5e299027ce0eab7b6ad5260585e347\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "890e13232c3fd35055fbd279b74bd78fd936b497", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:19.04\n+FROM ubuntu:19.10\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\"}, {"sha": "b864c09ea8c45bd1a1b13c39549d34089d8ed059", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:19.04\n+FROM ubuntu:19.10\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\"}, {"sha": "87dd6843678575f8dda962f239d14ef4be14b352", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1 +1 @@\n-Subproject commit 5c5cfd2e94cd42632798d9bd3d1116133e128ac9\n+Subproject commit 87dd6843678575f8dda962f239d14ef4be14b352"}, {"sha": "4d78994915af1bde9a95c04a8c27d8dca066232a", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1 +1 @@\n-Subproject commit 9493b7d4dc97eda439bd8780f05ad7b234cd1cd7\n+Subproject commit 4d78994915af1bde9a95c04a8c27d8dca066232a"}, {"sha": "11e893fc1357bc688418ddf1087c2b7aa25d154d", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1 +1 @@\n-Subproject commit e1157538e86d83df0cf95d5e33bd943f80d0248f\n+Subproject commit 11e893fc1357bc688418ddf1087c2b7aa25d154d"}, {"sha": "d119cc464731b2df094e3018ec86d4fb6ae90252", "filename": "src/doc/robots.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Frobots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Frobots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frobots.txt?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,3 @@\n-# NB: This file is not automatically deployed. After changes, it needs to be uploaded manually to doc.rust-lang.org\n User-agent: *\n Disallow: /0.3/\n Disallow: /0.4/"}, {"sha": "1c2bd024d13f8011307e13386cf1fea2180352b5", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1 +1 @@\n-Subproject commit 1d59403cb5269c190cc52a95584ecc280345495a\n+Subproject commit 1c2bd024d13f8011307e13386cf1fea2180352b5"}, {"sha": "5bd60bc51efaec04e69e2e18b59678e2af066433", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1 +1 @@\n-Subproject commit b5c6babcdd4ce1fa90458b7827a5fde082e79e87\n+Subproject commit 5bd60bc51efaec04e69e2e18b59678e2af066433"}, {"sha": "ef143c8727ee98e6e898ed4f8f7c6a2ba941871c", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -39,7 +39,7 @@ crate level, and ones that are useful at the item level.\n \n ## At the crate level\n \n-These options control how the docs look at a macro level.\n+These options control how the docs look at a crate level.\n \n ### `html_favicon_url`\n "}, {"sha": "f871df46250bad569081a30e083ef0df778d2067", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,34 @@\n+# `control_flow_guard`\n+\n+The tracking issue for this feature is: [#68793](https://github.com/rust-lang/rust/issues/68793).\n+\n+------------------------\n+\n+The `-Zcontrol_flow_guard=checks` compiler flag enables the Windows [Control Flow Guard][cfguard-docs] platform security feature. When enabled, the compiler outputs a list of valid indirect call targets, and inserts runtime checks on all indirect jump instructions to ensure that the destination is in the list of valid call targets.\n+\n+[cfguard-docs]: https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard\n+\n+For testing purposes, the `-Zcontrol_flow_guard=nochecks` compiler flag can be used to emit only the list of valid call targets, but not the runtime checks.\n+\n+It is strongly recommended to also enable Control Flow Guard checks in all linked libraries, including the standard library. \n+\n+To enable Control Flow Guard in the standard library, you can use the [cargo `-Zbuild-std` functionality][build-std] to recompile the standard library with the same configuration options as the main program. \n+\n+[build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n+\n+For example:\n+```cmd\n+rustup toolchain install --force nightly\n+rustup component add rust-src\n+SET RUSTFLAGS=-Zcontrol_flow_guard=checks\n+cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n+```\n+\n+```PowerShell\n+rustup toolchain install --force nightly\n+rustup component add rust-src\n+$Env:RUSTFLAGS = \"-Zcontrol_flow_guard=checks\"\n+cargo +nightly build -Z build-std --target x86_64-pc-windows-msvc\n+```\n+\n+Alternatively, if you are building the standard library from source, you can set `control-flow-guard = true` in the config.toml file."}, {"sha": "414ac7e63a331077e83ef0805cd8dff51edc434a", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,245 @@\n+# `sanitizer`\n+\n+The tracking issue for this feature is: [#39699](https://github.com/rust-lang/rust/issues/39699).\n+\n+------------------------\n+\n+This feature allows for use of one of following sanitizers:\n+\n+* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n+  detect out-of-bounds access to heap, stack, and globals, use after free, use\n+  after return, double free, invalid free, memory leaks.\n+* [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n+* [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n+* [ThreadSanitizer][clang-tsan] a fast data race detector.\n+\n+To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n+of `address`, `leak`, `memory` or `thread`.\n+\n+# Examples\n+\n+This sections show various issues that can be detected with sanitizers.  For\n+simplicity, the examples are prepared under assumption that optimization level\n+used is zero.\n+\n+## AddressSanitizer\n+\n+Stack buffer overflow:\n+\n+```shell\n+$ cat a.rs\n+fn main() {\n+    let xs = [0, 1, 2, 3];\n+    let _y = unsafe { *xs.as_ptr().offset(4) };\n+}\n+$ rustc -Zsanitizer=address a.rs\n+$ ./a\n+=================================================================\n+==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n+READ of size 4 at 0x7ffcc15f43d0 thread T0\n+    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n+    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n+    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n+    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n+    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n+    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n+    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n+    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n+    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n+    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n+    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n+    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n+\n+Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+\n+  This frame has 1 object(s):\n+    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n+      (longjmp and C++ exceptions *are* supported)\n+SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+Shadow bytes around the buggy address:\n+  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+Shadow byte legend (one shadow byte represents 8 application bytes):\n+  Addressable:           00\n+  Partially addressable: 01 02 03 04 05 06 07 \n+  Heap left redzone:       fa\n+  Freed heap region:       fd\n+  Stack left redzone:      f1\n+  Stack mid redzone:       f2\n+  Stack right redzone:     f3\n+  Stack after return:      f5\n+  Stack use after scope:   f8\n+  Global redzone:          f9\n+  Global init order:       f6\n+  Poisoned by user:        f7\n+  Container overflow:      fc\n+  Array cookie:            ac\n+  Intra object redzone:    bb\n+  ASan internal:           fe\n+  Left alloca redzone:     ca\n+  Right alloca redzone:    cb\n+  Shadow gap:              cc\n+==10029==ABORTING\n+```\n+\n+Use of a stack object after its scope has already ended:\n+\n+```shell\n+$ cat b.rs\n+static mut P: *mut usize = std::ptr::null_mut();\n+\n+fn main() {\n+    unsafe {\n+        {\n+            let mut x = 0;\n+            P = &mut x;\n+        }\n+        std::ptr::write_volatile(P, 123);\n+    }\n+}\n+$ rustc -Zsanitizer=address b.rs\n+$./b\n+=================================================================\n+==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n+WRITE of size 8 at 0x7fff67be6be0 thread T0\n+    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n+    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n+    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n+    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n+    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n+    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n+    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n+    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n+    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n+    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n+\n+Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+\n+  This frame has 1 object(s):\n+    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n+      (longjmp and C++ exceptions *are* supported)\n+SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+Shadow bytes around the buggy address:\n+  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n+  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+Shadow byte legend (one shadow byte represents 8 application bytes):\n+  Addressable:           00\n+  Partially addressable: 01 02 03 04 05 06 07\n+  Heap left redzone:       fa\n+  Freed heap region:       fd\n+  Stack left redzone:      f1\n+  Stack mid redzone:       f2\n+  Stack right redzone:     f3\n+  Stack after return:      f5\n+  Stack use after scope:   f8\n+  Global redzone:          f9\n+  Global init order:       f6\n+  Poisoned by user:        f7\n+  Container overflow:      fc\n+  Array cookie:            ac\n+  Intra object redzone:    bb\n+  ASan internal:           fe\n+  Left alloca redzone:     ca\n+  Right alloca redzone:    cb\n+  Shadow gap:              cc\n+==424427==ABORTING\n+```\n+\n+## MemorySanitizer\n+\n+Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n+the standard library, and passing `-Zsanitizer-track-origins` to track the\n+origins of uninitialized memory:\n+\n+```shell\n+$ cat src/main.rs\n+use std::mem::MaybeUninit;\n+\n+fn main() {\n+    unsafe {\n+        let a = MaybeUninit::<[usize; 4]>::uninit();\n+        let a = a.assume_init();\n+        println!(\"{}\", a[2]);\n+    }\n+}\n+\n+$ export \\\n+  CC=clang \\\n+  CXX=clang++ \\\n+  CFLAGS='-fsanitize=memory -fsanitize-memory-track-origins' \\\n+  CXXFLAGS='-fsanitize=memory -fsanitize-memory-track-origins' \\\n+  RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n+  RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n+$ cargo clean\n+$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n+    #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n+...\n+  Uninitialized value was stored to memory at\n+    #0 0x560c04ae898a in __msan_memcpy.part.0 $RUST/src/llvm-project/compiler-rt/lib/msan/msan_interceptors.cc:1558:3\n+    #1 0x560c04b2bf88 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:6:16\n+\n+  Uninitialized value was created by an allocation of 'a' in the stack frame of function '_ZN6memory4main17hd2333c1899d997f5E'\n+    #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n+```\n+\n+\n+# Instrumentation of external dependencies and std\n+\n+The sanitizers to varying degrees work correctly with partially instrumented\n+code. On the one extreme is LeakSanitizer that doesn't use any compile time\n+instrumentation, on the other is MemorySanitizer that requires that all program\n+code to be instrumented (failing to achieve that will inevitably result in\n+false positives).\n+\n+It is strongly recommended to combine sanitizers with recompiled and\n+instrumented standard library, for example using [cargo `-Zbuild-std`\n+functionality][build-std].\n+\n+[build-std]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std\n+\n+# Build scripts and procedural macros\n+\n+Use of sanitizers together with build scripts and procedural macros is\n+technically possible, but in almost all cases it would be best avoided.  This\n+is especially true for procedural macros which would require an instrumented\n+version of rustc.\n+\n+In more practical terms when using cargo always remember to pass `--target`\n+flag, so that rustflags will not be applied to build scripts and procedural\n+macros.\n+\n+# Additional Information\n+\n+* [Sanitizers project page](https://github.com/google/sanitizers/wiki/)\n+* [AddressSanitizer in Clang][clang-asan]\n+* [LeakSanitizer in Clang][clang-lsan]\n+* [MemorySanitizer in Clang][clang-msan]\n+* [ThreadSanitizer in Clang][clang-tsan]\n+\n+[clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n+[clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n+[clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n+[clang-tsan]: https://clang.llvm.org/docs/ThreadSanitizer.html"}, {"sha": "8bc62418b3969c1e3c73d306571b81f10cf5f710", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -37,11 +37,11 @@ fn main() {\n         return \"foo\"\n     };\n \n-    match Pin::new(&mut generator).resume() {\n+    match Pin::new(&mut generator).resume(()) {\n         GeneratorState::Yielded(1) => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n-    match Pin::new(&mut generator).resume() {\n+    match Pin::new(&mut generator).resume(()) {\n         GeneratorState::Complete(\"foo\") => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n@@ -71,9 +71,9 @@ fn main() {\n     };\n \n     println!(\"1\");\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n     println!(\"3\");\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n     println!(\"5\");\n }\n ```\n@@ -92,10 +92,10 @@ The `Generator` trait in `std::ops` currently looks like:\n # use std::ops::GeneratorState;\n # use std::pin::Pin;\n \n-pub trait Generator {\n+pub trait Generator<R = ()> {\n     type Yield;\n     type Return;\n-    fn resume(self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>;\n+    fn resume(self: Pin<&mut Self>, resume: R) -> GeneratorState<Self::Yield, Self::Return>;\n }\n ```\n \n@@ -152,10 +152,6 @@ closure-like semantics. Namely:\n * Whenever a generator is dropped it will drop all captured environment\n   variables.\n \n-Note that unlike closures, generators at this time cannot take any arguments.\n-That is, generators must always look like `|| { ... }`. This restriction may be\n-lifted at a future date, the design is ongoing!\n-\n ### Generators as state machines\n \n In the compiler, generators are currently compiled as state machines. Each\n@@ -179,8 +175,8 @@ fn main() {\n         return ret\n     };\n \n-    Pin::new(&mut generator).resume();\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n+    Pin::new(&mut generator).resume(());\n }\n ```\n \n@@ -205,7 +201,7 @@ fn main() {\n             type Yield = i32;\n             type Return = &'static str;\n \n-            fn resume(mut self: Pin<&mut Self>) -> GeneratorState<i32, &'static str> {\n+            fn resume(mut self: Pin<&mut Self>, resume: ()) -> GeneratorState<i32, &'static str> {\n                 use std::mem;\n                 match mem::replace(&mut *self, __Generator::Done) {\n                     __Generator::Start(s) => {\n@@ -228,8 +224,8 @@ fn main() {\n         __Generator::Start(ret)\n     };\n \n-    Pin::new(&mut generator).resume();\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n+    Pin::new(&mut generator).resume(());\n }\n ```\n "}, {"sha": "53e01091f754e4f15b22042335ac73001cd1df1b", "filename": "src/doc/unstable-book/src/language-features/infer-static-outlives-requirements.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,8 +1,8 @@\n # `infer_static_outlives_requirements`\n \n-The tracking issue for this feature is: [#44493]\n+The tracking issue for this feature is: [#54185]\n \n-[#44493]: https://github.com/rust-lang/rust/issues/44493\n+[#54185]: https://github.com/rust-lang/rust/issues/54185\n \n ------------------------\n The `infer_static_outlives_requirements` feature indicates that certain"}, {"sha": "3ba4a3e6b1f02d169c262c23f9b4e2149c4b98ff", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,8 +1,8 @@\n # `member_constraints`\n \n-The tracking issue for this feature is: [#61977]\n+The tracking issue for this feature is: [#61997]\n \n-[#61977]: https://github.com/rust-lang/rust/issues/61977\n+[#61997]: https://github.com/rust-lang/rust/issues/61997\n \n ------------------------\n "}, {"sha": "28c683934d4ed10d0454f039418e7c2d2ed1b603", "filename": "src/doc/unstable-book/src/language-features/no-sanitize.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,29 @@\n+# `no_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `no_sanitize` attribute can be used to selectively disable sanitizer\n+instrumentation in an annotated function. This might be useful to: avoid\n+instrumentation overhead in a performance critical function, or avoid\n+instrumenting code that contains constructs unsupported by given sanitizer.\n+\n+The precise effect of this annotation depends on particular sanitizer in use.\n+For example, with `no_sanitize(thread)`, the thread sanitizer will no longer\n+instrument non-atomic store / load operations, but it will instrument atomic\n+operations to avoid reporting false positives and provide meaning full stack\n+traces.\n+\n+## Examples\n+\n+``` rust\n+#![feature(no_sanitize)]\n+\n+#[no_sanitize(address)]\n+fn foo() {\n+  // ...\n+}\n+```"}, {"sha": "146f50ee67b500ee0da555df5581b9233f3b4b79", "filename": "src/doc/unstable-book/src/language-features/repr128.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,8 +1,8 @@\n # `repr128`\n \n-The tracking issue for this feature is: [#35118]\n+The tracking issue for this feature is: [#56071]\n \n-[#35118]: https://github.com/rust-lang/rust/issues/35118\n+[#56071]: https://github.com/rust-lang/rust/issues/56071\n \n ------------------------\n "}, {"sha": "cdb74495884a8e6e8d027992e147814ed44946ee", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,32 +0,0 @@\n-# `slice_patterns`\n-\n-The tracking issue for this feature is: [#62254]\n-\n-[#62254]: https://github.com/rust-lang/rust/issues/62254\n-\n-------------------------\n-\n-The `slice_patterns` feature gate lets you use `..` to indicate any number of\n-elements inside a pattern matching a slice. This wildcard can only be used once\n-for a given array. If there's an pattern before the `..`, the subslice will be\n-matched against that pattern. For example:\n-\n-```rust\n-#![feature(slice_patterns)]\n-\n-fn is_symmetric(list: &[u32]) -> bool {\n-    match list {\n-        &[] | &[_] => true,\n-        &[x, ref inside @ .., y] if x == y => is_symmetric(inside),\n-        &[..] => false,\n-    }\n-}\n-\n-fn main() {\n-    let sym = &[0, 1, 4, 2, 4, 1, 0];\n-    assert!(is_symmetric(sym));\n-\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n-    assert!(!is_symmetric(not_sym));\n-}\n-```"}, {"sha": "862411ab392031ee9315d4fc07edf5a61b04c6e9", "filename": "src/doc/unstable-book/src/language-features/transparent-enums.md", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,93 +0,0 @@\n-# `transparent_enums`\n-\n-The tracking issue for this feature is [#60405]\n-\n-[60405]: https://github.com/rust-lang/rust/issues/60405\n-\n-----\n-\n-The `transparent_enums` feature allows you mark `enum`s as\n-`#[repr(transparent)]`. An `enum` may be `#[repr(transparent)]` if it has\n-exactly one variant, and that variant matches the same conditions which `struct`\n-requires for transparency. Some concrete illustrations follow.\n-\n-```rust\n-#![feature(transparent_enums)]\n-\n-// This enum has the same representation as `f32`.\n-#[repr(transparent)]\n-enum SingleFieldEnum {\n-    Variant(f32)\n-}\n-\n-// This enum has the same representation as `usize`.\n-#[repr(transparent)]\n-enum MultiFieldEnum {\n-    Variant { field: usize, nothing: () },\n-}\n-```\n-\n-For consistency with transparent `struct`s, `enum`s must have exactly one\n-non-zero-sized field. If all fields are zero-sized, the `enum` must not be\n-`#[repr(transparent)]`:\n-\n-```rust\n-#![feature(transparent_enums)]\n-\n-// This (non-transparent) enum is already valid in stable Rust:\n-pub enum GoodEnum {\n-    Nothing,\n-}\n-\n-// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n-// #[repr(transparent)]\n-// pub enum BadEnum {\n-//     Nothing(()),\n-// }\n-\n-// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n-// #[repr(transparent)]\n-// pub enum BadEmptyEnum {\n-//     Nothing,\n-// }\n-```\n-\n-The one exception is if the `enum` is generic over `T` and has a field of type\n-`T`, it may be `#[repr(transparent)]` even if `T` is a zero-sized type:\n-\n-```rust\n-#![feature(transparent_enums)]\n-\n-// This enum has the same representation as `T`.\n-#[repr(transparent)]\n-pub enum GenericEnum<T> {\n-    Variant(T, ()),\n-}\n-\n-// This is okay even though `()` is a zero-sized type.\n-pub const THIS_IS_OKAY: GenericEnum<()> = GenericEnum::Variant((), ());\n-```\n-\n-Transparent `enum`s require exactly one variant:\n-\n-```rust\n-// Error: transparent enum needs exactly one variant, but has 0\n-// #[repr(transparent)]\n-// pub enum TooFewVariants {\n-// }\n-\n-// Error: transparent enum needs exactly one variant, but has 2\n-// #[repr(transparent)]\n-// pub enum TooManyVariants {\n-//     First(usize),\n-//     Second,\n-// }\n-```\n-\n-Like transarent `struct`s, a transparent `enum` of type `E` has the same layout,\n-size, and ABI as its single non-ZST field. If it is generic over a type `T`, and\n-all its fields are ZSTs except for exactly one field of type `T`, then it has\n-the same layout and ABI as `T` (even if `T` is a ZST when monomorphized).\n-\n-Like transparent `struct`s, transparent `enum`s are FFI-safe if and only if\n-their underlying representation type is also FFI-safe."}, {"sha": "9f045ce08a4337dfe790fc5e432c881a5c6316a3", "filename": "src/doc/unstable-book/src/library-features/allocator-api.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fallocator-api.md?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -9,7 +9,7 @@ The tracking issue for this feature is [#32838]\n Sometimes you want the memory for one collection to use a different\n allocator than the memory for another collection. In this case,\n replacing the global allocator is not a workable option. Instead,\n-you need to pass in an instance of an `Alloc` to each collection\n+you need to pass in an instance of an `AllocRef` to each collection\n for which you want a custom allocator.\n \n TBD"}, {"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,9 +0,0 @@\n-# `debug_map_key_value`\n-\n-The tracking issue for this feature is: [#62482]\n-\n-[#62482]: https://github.com/rust-lang/rust/issues/62482\n-\n-------------------------\n-\n-Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "82ae67fc05ac3ce680f6bad3c4e8871252229690", "filename": "src/doc/unstable-book/src/library-features/sanitizer-runtime-lib.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsanitizer-runtime-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsanitizer-runtime-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsanitizer-runtime-lib.md?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,5 +0,0 @@\n-# `sanitizer_runtime_lib`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "b3f8f50636bee754b81d0280b505ece3bb9f1a51", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -212,7 +212,6 @@ def __classify_struct(self):\n         # REGULAR STRUCT\n         return TYPE_KIND_REGULAR_STRUCT\n \n-\n     def __classify_union(self):\n         assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n \n@@ -233,7 +232,6 @@ def __classify_union(self):\n         else:\n             return TYPE_KIND_REGULAR_UNION\n \n-\n     def __conforms_to_field_layout(self, expected_fields):\n         actual_fields = self.get_fields()\n         actual_field_count = len(actual_fields)\n@@ -363,6 +361,7 @@ def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (tail, head, data_ptr, capacity)\n \n+\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n@@ -376,8 +375,10 @@ def extract_length_and_ptr_from_slice(slice_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (length, data_ptr)\n \n+\n UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n     \"\"\"Extracts the type name from a fully qualified path\"\"\"\n     if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n@@ -393,6 +394,7 @@ def extract_type_name(qualified_type_name):\n     else:\n         return qualified_type_name[index + 2:]\n \n+\n try:\n     compat_str = unicode  # Python 2\n except NameError:"}, {"sha": "4979882ffeaffecebfaf2a856b7d50191d2a4483", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -14,7 +14,6 @@\n even larger, and it's already uncomfortably large (6 KiB).\n \"\"\"\n from __future__ import print_function\n-import sys\n from math import ceil, log\n from fractions import Fraction\n from collections import namedtuple\n@@ -82,6 +81,7 @@ def error(f, e, z):\n     ulp_err = abs_err / Fraction(2) ** z.exp\n     return float(ulp_err)\n \n+\n HEADER = \"\"\"\n //! Tables of approximations of powers of ten.\n //! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`"}, {"sha": "0914c22eb13f03d0b9d0c94474ac7e5b57795195", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -9,7 +9,7 @@\n if sys.version_info[0] >= 3:\n     xrange = range\n \n-rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n+rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string=True)\n \n # The btree pretty-printers fail in a confusing way unless\n # https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n@@ -21,9 +21,10 @@\n     if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n         gdb_81 = True\n \n-#===============================================================================\n+# ===============================================================================\n # GDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class GdbType(rustpp.Type):\n \n@@ -133,39 +134,39 @@ def rust_pretty_printer_lookup_function(gdb_val):\n \n     if type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = False)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n         return RustStringSlicePrinter(val)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = True,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=True,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = False,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=False,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return RustCStyleVariantPrinter(val.get_child_at_index(0))\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return RustStructPrinter(val,\n-                                 omit_first_field = True,\n-                                 omit_type_name = False,\n-                                 is_tuple_like = True)\n+                                 omit_first_field=True,\n+                                 omit_type_name=False,\n+                                 is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         variant = get_field_at_index(gdb_val, 0)\n@@ -189,9 +190,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     return None\n \n \n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n # Pretty Printer Classes\n-#=------------------------------------------------------------------------------\n+# =------------------------------------------------------------------------------\n class RustEmptyPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -355,6 +356,7 @@ def children_of_node(boxed_node, height, want_values):\n             else:\n                 yield keys[i]['value']['value']\n \n+\n class RustStdBTreeSetPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -429,6 +431,7 @@ def to_string(self):\n     def display_hint(self):\n         return \"string\"\n \n+\n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):\n         assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM"}, {"sha": "c42f942c63cf5fa4597ef663afde6ee1c14704b8", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -8,7 +8,8 @@\n sample usage: src/etc/generate-deriving-span-tests.py\n \"\"\"\n \n-import os, stat\n+import os\n+import stat\n \n TEST_DIR = os.path.abspath(\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n@@ -56,15 +57,17 @@\n \n ENUM_TUPLE, ENUM_STRUCT, STRUCT_FIELDS, STRUCT_TUPLE = range(4)\n \n+\n def create_test_case(type, trait, super_traits, error_count):\n     string = [ENUM_STRING, ENUM_STRUCT_VARIANT_STRING, STRUCT_STRING, STRUCT_TUPLE_STRING][type]\n     all_traits = ','.join([trait] + super_traits)\n     super_traits = ','.join(super_traits)\n     error_deriving = '#[derive(%s)]' % super_traits if super_traits else ''\n \n     errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n-    code = string.format(traits = all_traits, errors = errors)\n-    return TEMPLATE.format(error_deriving=error_deriving, code = code)\n+    code = string.format(traits=all_traits, errors=errors)\n+    return TEMPLATE.format(error_deriving=error_deriving, code=code)\n+\n \n def write_file(name, string):\n     test_file = os.path.join(TEST_DIR, 'derives-span-%s.rs' % name)\n@@ -86,10 +89,10 @@ def write_file(name, string):\n \n traits = {\n     'Default': (STRUCT, [], 1),\n-    'FromPrimitive': (0, [], 0), # only works for C-like enums\n+    'FromPrimitive': (0, [], 0),  # only works for C-like enums\n \n-    'Decodable': (0, [], 0), # FIXME: quoting gives horrible spans\n-    'Encodable': (0, [], 0), # FIXME: quoting gives horrible spans\n+    'Decodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n+    'Encodable': (0, [], 0),  # FIXME: quoting gives horrible spans\n }\n \n for (trait, supers, errs) in [('Clone', [], 1),"}, {"sha": "77c3d2758c6dcd6bcfb188cf7ceafd36fa53d2f1", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -11,7 +11,6 @@\n \n import sys\n import os\n-import datetime\n import stat\n \n "}, {"sha": "7789b24b62c83be1ce1297ebf08893e0bc611805", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -131,6 +131,7 @@\n except NameError:\n     unichr = chr\n \n+\n class CustomHTMLParser(HTMLParser):\n     \"\"\"simplified HTML parser.\n \n@@ -169,21 +170,25 @@ def close(self):\n         HTMLParser.close(self)\n         return self.__builder.close()\n \n+\n Command = namedtuple('Command', 'negated cmd args lineno context')\n \n+\n class FailedCheck(Exception):\n     pass\n \n+\n class InvalidCheck(Exception):\n     pass\n \n+\n def concat_multi_lines(f):\n     \"\"\"returns a generator out of the file object, which\n     - removes `\\\\` then `\\n` then a shared prefix with the previous line then\n       optional whitespace;\n     - keeps a line number (starting from 0) of the first line being\n       concatenated.\"\"\"\n-    lastline = None # set to the last line when the last line has a backslash\n+    lastline = None  # set to the last line when the last line has a backslash\n     firstlineno = None\n     catenated = ''\n     for lineno, line in enumerate(f):\n@@ -208,6 +213,7 @@ def concat_multi_lines(f):\n     if lastline is not None:\n         print_err(lineno, line, 'Trailing backslash at the end of the file')\n \n+\n LINE_PATTERN = re.compile(r'''\n     (?<=(?<!\\S)@)(?P<negated>!?)\n     (?P<cmd>[A-Za-z]+(?:-[A-Za-z]+)*)\n@@ -252,7 +258,7 @@ def flatten(node):\n \n def normalize_xpath(path):\n     if path.startswith('//'):\n-        return '.' + path # avoid warnings\n+        return '.' + path  # avoid warnings\n     elif path.startswith('.//'):\n         return path\n     else:\n@@ -316,7 +322,7 @@ def get_dir(self, path):\n \n def check_string(data, pat, regexp):\n     if not pat:\n-        return True # special case a presence testing\n+        return True  # special case a presence testing\n     elif regexp:\n         return re.search(pat, data, flags=re.UNICODE) is not None\n     else:\n@@ -353,7 +359,7 @@ def check_tree_text(tree, path, pat, regexp):\n                 ret = check_string(value, pat, regexp)\n                 if ret:\n                     break\n-    except Exception as e:\n+    except Exception:\n         print('Failed to get path \"{}\"'.format(path))\n         raise\n     return ret\n@@ -363,6 +369,7 @@ def get_tree_count(tree, path):\n     path = normalize_xpath(path)\n     return len(tree.findall(path))\n \n+\n def stderr(*args):\n     if sys.version_info.major < 3:\n         file = codecs.getwriter('utf-8')(sys.stderr)\n@@ -371,6 +378,7 @@ def stderr(*args):\n \n     print(*args, file=file)\n \n+\n def print_err(lineno, context, err, message=None):\n     global ERR_COUNT\n     ERR_COUNT += 1\n@@ -381,48 +389,50 @@ def print_err(lineno, context, err, message=None):\n     if context:\n         stderr(\"\\t{}\".format(context))\n \n+\n ERR_COUNT = 0\n \n+\n def check_command(c, cache):\n     try:\n         cerr = \"\"\n-        if c.cmd == 'has' or c.cmd == 'matches': # string test\n+        if c.cmd == 'has' or c.cmd == 'matches':  # string test\n             regexp = (c.cmd == 'matches')\n-            if len(c.args) == 1 and not regexp: # @has <path> = file existence\n+            if len(c.args) == 1 and not regexp:  # @has <path> = file existence\n                 try:\n                     cache.get_file(c.args[0])\n                     ret = True\n                 except FailedCheck as err:\n                     cerr = str(err)\n                     ret = False\n-            elif len(c.args) == 2: # @has/matches <path> <pat> = string test\n+            elif len(c.args) == 2:  # @has/matches <path> <pat> = string test\n                 cerr = \"`PATTERN` did not match\"\n                 ret = check_string(cache.get_file(c.args[0]), c.args[1], regexp)\n-            elif len(c.args) == 3: # @has/matches <path> <pat> <match> = XML tree test\n+            elif len(c.args) == 3:  # @has/matches <path> <pat> <match> = XML tree test\n                 cerr = \"`XPATH PATTERN` did not match\"\n                 tree = cache.get_tree(c.args[0])\n                 pat, sep, attr = c.args[1].partition('/@')\n-                if sep: # attribute\n+                if sep:  # attribute\n                     tree = cache.get_tree(c.args[0])\n                     ret = check_tree_attr(tree, pat, attr, c.args[2], regexp)\n-                else: # normalized text\n+                else:  # normalized text\n                     pat = c.args[1]\n                     if pat.endswith('/text()'):\n                         pat = pat[:-7]\n                     ret = check_tree_text(cache.get_tree(c.args[0]), pat, c.args[2], regexp)\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n \n-        elif c.cmd == 'count': # count test\n-            if len(c.args) == 3: # @count <path> <pat> <count> = count test\n+        elif c.cmd == 'count':  # count test\n+            if len(c.args) == 3:  # @count <path> <pat> <count> = count test\n                 expected = int(c.args[2])\n                 found = get_tree_count(cache.get_tree(c.args[0]), c.args[1])\n                 cerr = \"Expected {} occurrences but found {}\".format(expected, found)\n                 ret = expected == found\n             else:\n                 raise InvalidCheck('Invalid number of @{} arguments'.format(c.cmd))\n-        elif c.cmd == 'has-dir': # has-dir test\n-            if len(c.args) == 1: # @has-dir <path> = has-dir test\n+        elif c.cmd == 'has-dir':  # has-dir test\n+            if len(c.args) == 1:  # @has-dir <path> = has-dir test\n                 try:\n                     cache.get_dir(c.args[0])\n                     ret = True\n@@ -448,11 +458,13 @@ def check_command(c, cache):\n     except InvalidCheck as err:\n         print_err(c.lineno, c.context, str(err))\n \n+\n def check(target, commands):\n     cache = CachedFiles(target)\n     for c in commands:\n         check_command(c, cache)\n \n+\n if __name__ == '__main__':\n     if len(sys.argv) != 3:\n         stderr('Usage: {} <doc dir> <template>'.format(sys.argv[0]))"}, {"sha": "99ee7507fa2fb0d121ca340682204ca92a1b781e", "filename": "src/etc/installer/gfx/rust-logo.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "d9c4bc5562f00a19bcf38981e4378ed62c619d18", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -157,6 +157,7 @@ def watchdog():\n # ~main\n ####################################################################################################\n \n+\n if len(sys.argv) != 3:\n     print(\"usage: python lldb_batchmode.py target-path script-path\")\n     sys.exit(1)"}, {"sha": "0c4021b36fb6f6ac7435ea2f40873a26584b5c69", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,10 +1,10 @@\n import lldb\n-import re\n import debugger_pretty_printers_common as rustpp\n \n-#===============================================================================\n+# ===============================================================================\n # LLDB Pretty Printing Module for Rust\n-#===============================================================================\n+# ===============================================================================\n+\n \n class LldbType(rustpp.Type):\n \n@@ -84,16 +84,16 @@ def print_val(lldb_val, internal_dict):\n         type_kind == rustpp.TYPE_KIND_EMPTY):\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = False)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=False)\n \n     if type_kind == rustpp.TYPE_KIND_SLICE:\n         return print_vec_slice_val(val, internal_dict)\n@@ -110,26 +110,26 @@ def print_val(lldb_val, internal_dict):\n     if type_kind == rustpp.TYPE_KIND_TUPLE:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = True,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=True,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = False,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=False,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n         return val.type.get_unqualified_type_name()\n \n     if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n         return print_struct_val(val,\n                                 internal_dict,\n-                                omit_first_field = True,\n-                                omit_type_name = False,\n-                                is_tuple_like = True)\n+                                omit_first_field=True,\n+                                omit_type_name=False,\n+                                is_tuple_like=True)\n \n     if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n         return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n@@ -157,9 +157,9 @@ def print_val(lldb_val, internal_dict):\n     return lldb_val.GetValue()\n \n \n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =---------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n     \"\"\"\n@@ -212,6 +212,7 @@ def render_child(child_index):\n     return template % {\"type_name\": type_name,\n                        \"body\": body}\n \n+\n def print_pointer_val(val, internal_dict):\n     \"\"\"Prints a pointer value with Rust syntax\"\"\"\n     assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n@@ -253,18 +254,21 @@ def print_std_vec_val(val, internal_dict):\n                                               length,\n                                               internal_dict)\n \n+\n def print_str_slice_val(val, internal_dict):\n     (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n     return read_utf8_string(data_ptr, length)\n \n+\n def print_std_string_val(val, internal_dict):\n     vec = val.get_child_at_index(0)\n     (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n     return read_utf8_string(data_ptr, length)\n \n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n # Helper Functions\n-#=--------------------------------------------------------------------------------------------------\n+# =-----------------------------------------------------------------------\n+\n \n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n     \"\"\"Prints a contiguous memory range, interpreting it as values of the"}, {"sha": "f41404bf8cab97ff5eb94a1084393e9297e90fad", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -31,14 +31,14 @@ extern \"Rust\" {\n \n /// The global memory allocator.\n ///\n-/// This type implements the [`Alloc`] trait by forwarding calls\n+/// This type implements the [`AllocRef`] trait by forwarding calls\n /// to the allocator registered with the `#[global_allocator]` attribute\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n ///\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -50,14 +50,14 @@ pub struct Global;\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n ///\n /// # Examples\n@@ -88,14 +88,14 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `dealloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n@@ -110,14 +110,14 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `realloc` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n@@ -132,14 +132,14 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n /// if there is one, or the `std` crate\u2019s default.\n ///\n /// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n-/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+/// of the [`Global`] type when it and the [`AllocRef`] trait become stable.\n ///\n /// # Safety\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n /// [`Global`]: struct.Global.html\n-/// [`Alloc`]: trait.Alloc.html\n+/// [`AllocRef`]: trait.AllocRef.html\n /// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n ///\n /// # Examples\n@@ -163,7 +163,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n }\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl Alloc for Global {\n+unsafe impl AllocRef for Global {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(alloc(layout)).ok_or(AllocErr)\n@@ -200,21 +200,27 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         align as *mut u8\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        let ptr = alloc(layout);\n-        if !ptr.is_null() { ptr } else { handle_alloc_error(layout) }\n+        match Global.alloc(layout) {\n+            Ok(ptr) => ptr.as_ptr(),\n+            Err(_) => handle_alloc_error(layout),\n+        }\n     }\n }\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+// This signature has to be the same as `Box`, otherwise an ICE will happen.\n+// When an additional parameter to `Box` is added (like `A: AllocRef`), this has to be added here as\n+// well.\n+// For example if `Box` is changed to  `struct Box<T: ?Sized, A: AllocRef>(Unique<T>, A)`,\n+// this function has to be changed to `fn box_free<T: ?Sized, A: AllocRef>(Unique<T>, A)` as well.\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    let ptr = ptr.as_ptr();\n-    let size = size_of_val(&*ptr);\n-    let align = min_align_of_val(&*ptr);\n+    let size = size_of_val(ptr.as_ref());\n+    let align = min_align_of_val(ptr.as_ref());\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        dealloc(ptr as *mut u8, layout);\n+        Global.dealloc(ptr.cast().into(), layout);\n     }\n }\n "}, {"sha": "83cdebf0e3f4a7d89e5c6b7e30aac80d55b65185", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n+use std::ops::Bound::{Excluded, Unbounded};\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -146,6 +147,36 @@ pub fn iter_100000(b: &mut Bencher) {\n     bench_iter(b, 100000);\n }\n \n+fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+    let mut map = BTreeMap::<i32, i32>::new();\n+    let mut rng = thread_rng();\n+\n+    for _ in 0..size {\n+        map.insert(rng.gen(), rng.gen());\n+    }\n+\n+    b.iter(|| {\n+        for kv in map.iter_mut() {\n+            black_box(kv);\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn iter_mut_20(b: &mut Bencher) {\n+    bench_iter_mut(b, 20);\n+}\n+\n+#[bench]\n+pub fn iter_mut_1000(b: &mut Bencher) {\n+    bench_iter_mut(b, 1000);\n+}\n+\n+#[bench]\n+pub fn iter_mut_100000(b: &mut Bencher) {\n+    bench_iter_mut(b, 100000);\n+}\n+\n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n@@ -170,3 +201,58 @@ pub fn first_and_last_100(b: &mut Bencher) {\n pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n+\n+#[bench]\n+pub fn range_excluded_excluded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first + 1..size {\n+                black_box(map.range((Excluded(first), Excluded(last))));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_excluded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range((Excluded(first), Unbounded)));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_included(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first..size {\n+                black_box(map.range(first..=last));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range(first..));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| map.range(..));\n+}"}, {"sha": "d7c1d95a45205b77a3ffd3f5661d3e22171e6a18", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -14,19 +14,13 @@ fn random(n: usize) -> BTreeSet<usize> {\n }\n \n fn neg(n: usize) -> BTreeSet<i32> {\n-    let mut set = BTreeSet::new();\n-    for i in -(n as i32)..=-1 {\n-        set.insert(i);\n-    }\n+    let set: BTreeSet<i32> = (-(n as i32)..=-1).collect();\n     assert_eq!(set.len(), n);\n     set\n }\n \n fn pos(n: usize) -> BTreeSet<i32> {\n-    let mut set = BTreeSet::new();\n-    for i in 1..=(n as i32) {\n-        set.insert(i);\n-    }\n+    let set: BTreeSet<i32> = (1..=(n as i32)).collect();\n     assert_eq!(set.len(), n);\n     set\n }\n@@ -56,6 +50,43 @@ macro_rules! set_bench {\n     };\n }\n \n+const BUILD_SET_SIZE: usize = 100;\n+\n+#[bench]\n+pub fn build_and_clear(b: &mut Bencher) {\n+    b.iter(|| pos(BUILD_SET_SIZE).clear())\n+}\n+\n+#[bench]\n+pub fn build_and_drop(b: &mut Bencher) {\n+    b.iter(|| pos(BUILD_SET_SIZE))\n+}\n+\n+#[bench]\n+pub fn build_and_into_iter(b: &mut Bencher) {\n+    b.iter(|| pos(BUILD_SET_SIZE).into_iter().count())\n+}\n+\n+#[bench]\n+pub fn build_and_pop_all(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut s = pos(BUILD_SET_SIZE);\n+        while s.pop_first().is_some() {}\n+        s\n+    });\n+}\n+\n+#[bench]\n+pub fn build_and_remove_all(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut s = pos(BUILD_SET_SIZE);\n+        while let Some(elt) = s.iter().copied().next() {\n+            s.remove(&elt);\n+        }\n+        s\n+    });\n+}\n+\n set_bench! {intersection_100_neg_vs_100_pos, intersection, count, [neg(100), pos(100)]}\n set_bench! {intersection_100_neg_vs_10k_pos, intersection, count, [neg(100), pos(10_000)]}\n set_bench! {intersection_100_pos_vs_100_neg, intersection, count, [pos(100), neg(100)]}"}, {"sha": "5c95160ba2d14dba82ea7a57b4fef7b64ef45f88", "filename": "src/liballoc/benches/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstring.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,5 +1,5 @@\n use std::iter::repeat;\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {"}, {"sha": "3ac4bd82a3a10fa4919d078b9dcefc53d88bd1b9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -2,7 +2,8 @@\n //!\n //! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n-//! drop their contents when they go out of scope.\n+//! drop their contents when they go out of scope. Boxes also ensure that they\n+//! never allocate more than `isize::MAX` bytes.\n //!\n //! # Examples\n //!\n@@ -145,7 +146,7 @@ use core::ptr::{self, NonNull, Unique};\n use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, Alloc, Global};\n+use crate::alloc::{self, AllocRef, Global};\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;\n@@ -195,12 +196,14 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        if layout.size() == 0 {\n-            return Box(NonNull::dangling().into());\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+            };\n+            Box::from_raw(ptr.as_ptr())\n         }\n-        let ptr =\n-            unsafe { Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)) };\n-        Box(ptr.cast().into())\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -263,15 +266,14 @@ impl<T> Box<[T]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n         let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = if layout.size() == 0 {\n-            NonNull::dangling()\n-        } else {\n-            unsafe {\n+        unsafe {\n+            let ptr = if layout.size() == 0 {\n+                NonNull::dangling()\n+            } else {\n                 Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n-            }\n-        };\n-        let slice = unsafe { slice::from_raw_parts_mut(ptr.as_ptr(), len) };\n-        Box(Unique::from(slice))\n+            };\n+            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n+        }\n     }\n }\n \n@@ -307,7 +309,7 @@ impl<T> Box<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<T> {\n-        Box(Box::into_unique(self).cast())\n+        Box::from_raw(Box::into_raw(self) as *mut T)\n     }\n }\n \n@@ -345,7 +347,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Box<[T]> {\n-        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+        Box::from_raw(Box::into_raw(self) as *mut [T])\n     }\n }\n \n@@ -1103,6 +1105,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Box<T> {}\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n     type Yield = G::Yield;\n@@ -1113,6 +1116,7 @@ impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n     }\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     type Yield = G::Yield;\n@@ -1123,6 +1127,28 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume(Pin::new(&mut *self), arg)\n+    }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume((*self).as_mut(), arg)\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;"}, {"sha": "5b4b1c933472d8abeb16e36df78f8e89db18db56", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 174, "deletions": 278, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -6,10 +6,11 @@ use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, intrinsics, mem, ptr};\n+use core::{fmt, mem, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n+use super::unwrap_unchecked;\n \n use Entry::*;\n use UnderflowResult::*;\n@@ -207,6 +208,60 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref())\n         }\n     }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        BTreeClone::clone_from(self, other);\n+    }\n+}\n+\n+trait BTreeClone {\n+    fn clone_from(&mut self, other: &Self);\n+}\n+\n+impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    default fn clone_from(&mut self, other: &Self) {\n+        *self = other.clone();\n+    }\n+}\n+\n+impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n+    fn clone_from(&mut self, other: &Self) {\n+        // This truncates `self` to `other.len()` by calling `split_off` on\n+        // the first key after `other.len()` elements if it exists\n+        let split_off_key = if self.len() > other.len() {\n+            let diff = self.len() - other.len();\n+            if diff <= other.len() {\n+                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n+            } else {\n+                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n+            }\n+        } else {\n+            None\n+        };\n+        if let Some(key) = split_off_key {\n+            self.split_off(&key);\n+        }\n+\n+        let mut siter = self.range_mut(..);\n+        let mut oiter = other.iter();\n+        // After truncation, `self` is at most as long as `other` so this loop\n+        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n+        // order and the structure of the `BTreeMap` stays the same,\n+        // the BTree invariants are maintained at the end of the loop\n+        while !siter.is_empty() {\n+            if let Some((ok, ov)) = oiter.next() {\n+                // SAFETY: This is safe because the `siter.front != siter.back` check\n+                // ensures that `siter` is nonempty\n+                let (sk, sv) = unsafe { siter.next_unchecked() };\n+                sk.clone_from(ok);\n+                sv.clone_from(ov);\n+            } else {\n+                break;\n+            }\n+        }\n+        // If `other` is longer than `self`, the remaining elements are inserted\n+        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n+    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -591,7 +646,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = first_leaf_edge(self.root.as_ref());\n+        let front = self.root.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -620,13 +675,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().first_kv(),\n+        let front = self.root.as_mut().first_leaf_edge();\n+        if let Ok(kv) = front.right_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -652,7 +709,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = last_leaf_edge(self.root.as_ref());\n+        let back = self.root.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -681,13 +738,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().last_kv(),\n+        let back = self.root.as_mut().last_leaf_edge();\n+        if let Ok(kv) = back.left_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -806,13 +865,42 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Ord,\n+    {\n+        self.remove_entry(key).map(|(_, v)| v)\n+    }\n+\n+    /// Removes a key from the map, returning the stored key and value if the key\n+    /// was previously in the map.\n+    ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btreemap_remove_entry)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n+    /// assert_eq!(map.remove_entry(&1), None);\n+    /// ```\n+    #[unstable(feature = \"btreemap_remove_entry\", issue = \"66714\")]\n+    pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => Some(\n-                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }.remove(),\n+                OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n+                    .remove_entry(),\n             ),\n             GoDown(_) => None,\n         }\n@@ -990,7 +1078,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n+        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1030,7 +1118,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 open_node.push(key, value, right_tree);\n \n                 // Go down to the right-most leaf again.\n-                cur_node = last_leaf_edge(open_node.forget_type()).into_node();\n+                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n             }\n \n             self.length += 1;\n@@ -1328,7 +1416,8 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_unchecked()) }\n+            let (k, v) = unsafe { self.range.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n \n@@ -1348,7 +1437,8 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            unsafe { Some(self.range.next_back_unchecked()) }\n+            let (k, v) = unsafe { self.range.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n         }\n     }\n }\n@@ -1374,7 +1464,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: first_leaf_edge(root1), back: last_leaf_edge(root2), length: len }\n+        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n     }\n }\n \n@@ -1389,9 +1479,9 @@ impl<K, V> Drop for IntoIter<K, V> {\n             }\n \n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n-                let mut cur_node = first_parent.into_node();\n-                while let Some(parent) = cur_node.deallocate_and_ascend() {\n-                    cur_node = parent.into_node()\n+                let mut cur_internal_node = first_parent.into_node();\n+                while let Some(parent) = cur_internal_node.deallocate_and_ascend() {\n+                    cur_internal_node = parent.into_node()\n                 }\n             }\n         }\n@@ -1404,37 +1494,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n \n     fn next(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.front) };\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.front = kv.right_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.front.next_unchecked() })\n         }\n     }\n \n@@ -1447,37 +1510,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n-            return None;\n+            None\n         } else {\n             self.length -= 1;\n-        }\n-\n-        let handle = unsafe { ptr::read(&self.back) };\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                self.back = kv.left_edge();\n-                return Some((k, v));\n-            }\n-            Err(last_edge) => unsafe {\n-                unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            },\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n-                    let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return Some((k, v));\n-                }\n-                Err(last_edge) => unsafe {\n-                    cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                },\n-            }\n+            Some(unsafe { self.back.next_back_unchecked() })\n         }\n     }\n }\n@@ -1579,7 +1615,7 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() { None } else { unsafe { Some(self.next_unchecked()) } }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n@@ -1622,73 +1658,25 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n impl<'a, K, V> Range<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.front;\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.front = kv.right_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n \n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() { None } else { Some(unsafe { self.next_back_unchecked() }) }\n     }\n }\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let handle = self.back;\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                let ret = kv.into_kv();\n-                self.back = kv.left_edge();\n-                return ret;\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    let ret = kv.into_kv();\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return ret;\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1707,7 +1695,12 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let (k, v) = unsafe { self.next_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n+        }\n     }\n \n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n@@ -1716,84 +1709,33 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        let handle = ptr::read(&self.front);\n-\n-        let mut cur_handle = match handle.right_kv() {\n-            Ok(kv) => {\n-                self.front = ptr::read(&kv).right_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n+    fn is_empty(&self) -> bool {\n+        self.front == self.back\n+    }\n \n-        loop {\n-            match cur_handle.right_kv() {\n-                Ok(kv) => {\n-                    self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        self.front.next_unchecked()\n     }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        if self.front == self.back { None } else { unsafe { Some(self.next_back_unchecked()) } }\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let (k, v) = unsafe { self.next_back_unchecked() };\n+            Some((k, v)) // coerce k from `&mut K` to `&K`\n+        }\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n-    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n-        let handle = ptr::read(&self.back);\n-\n-        let mut cur_handle = match handle.left_kv() {\n-            Ok(kv) => {\n-                self.back = ptr::read(&kv).left_edge();\n-                // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                // so we have to do this last.\n-                let (k, v) = kv.into_kv_mut();\n-                return (k, v); // coerce k from `&mut K` to `&K`\n-            }\n-            Err(last_edge) => {\n-                let next_level = last_edge.into_node().ascend().ok();\n-                unwrap_unchecked(next_level)\n-            }\n-        };\n-\n-        loop {\n-            match cur_handle.left_kv() {\n-                Ok(kv) => {\n-                    self.back = last_leaf_edge(ptr::read(&kv).left_edge().descend());\n-                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n-                    // so we have to do this last.\n-                    let (k, v) = kv.into_kv_mut();\n-                    return (k, v); // coerce k from `&mut K` to `&K`\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    cur_handle = unwrap_unchecked(next_level);\n-                }\n-            }\n-        }\n+    unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        self.back.next_back_unchecked()\n     }\n }\n \n@@ -1892,32 +1834,6 @@ where\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.first_edge(),\n-            Internal(internal) => {\n-                node = internal.first_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n-fn last_leaf_edge<BorrowType, K, V>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n-    loop {\n-        match node.force() {\n-            Leaf(leaf) => return leaf.last_edge(),\n-            Internal(internal) => {\n-                node = internal.last_edge().descend();\n-            }\n-        }\n-    }\n-}\n-\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -1949,60 +1865,51 @@ where\n     let mut max_node = root2;\n     let mut min_found = false;\n     let mut max_found = false;\n-    let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+        let front = match (min_found, range.start_bound()) {\n+            (false, Included(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.keys().len(),\n-            (true, Excluded(_)) => 0,\n+            (true, Included(_)) => min_node.last_edge(),\n+            (true, Excluded(_)) => min_node.first_edge(),\n+            (_, Unbounded) => min_node.first_edge(),\n         };\n \n-        let max_edge = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+        let back = match (max_found, range.end_bound()) {\n+            (false, Included(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => max_node.keys().len(),\n-            (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.keys().len(),\n+            (true, Included(_)) => max_node.first_edge(),\n+            (true, Excluded(_)) => max_node.last_edge(),\n+            (_, Unbounded) => max_node.last_edge(),\n         };\n \n-        if !diverged {\n-            if max_edge < min_edge {\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n-            if min_edge != max_edge {\n-                diverged = true;\n-            }\n+        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n+            panic!(\"Ord is ill-defined in BTreeMap range\");\n         }\n-\n-        let front = Handle::new_edge(min_node, min_edge);\n-        let back = Handle::new_edge(max_node, max_edge);\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);\n@@ -2016,17 +1923,6 @@ where\n     }\n }\n \n-#[inline(always)]\n-unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n-    val.unwrap_or_else(|| {\n-        if cfg!(debug_assertions) {\n-            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n-        } else {\n-            intrinsics::unreachable();\n-        }\n-    })\n-}\n-\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2053,8 +1949,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: first_leaf_edge(self.root.as_ref()),\n-                back: last_leaf_edge(self.root.as_ref()),\n+                front: self.root.as_ref().first_leaf_edge(),\n+                back: self.root.as_ref().last_leaf_edge(),\n             },\n             length: self.length,\n         }\n@@ -2087,8 +1983,8 @@ impl<K, V> BTreeMap<K, V> {\n         let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n             range: RangeMut {\n-                front: first_leaf_edge(root1),\n-                back: last_leaf_edge(root2),\n+                front: root1.first_leaf_edge(),\n+                back: root2.last_leaf_edge(),\n                 _marker: PhantomData,\n             },\n             length: self.length,\n@@ -2591,7 +2487,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = first_leaf_edge(internal.right_edge().descend()).right_kv().ok();\n+                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();"}, {"sha": "fb5825ee21a9e4459551e269026ae2208a59168c", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,5 @@\n pub mod map;\n+mod navigate;\n mod node;\n mod search;\n pub mod set;\n@@ -11,3 +12,14 @@ trait Recover<Q: ?Sized> {\n     fn take(&mut self, key: &Q) -> Option<Self::Key>;\n     fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n }\n+\n+#[inline(always)]\n+pub unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n+    val.unwrap_or_else(|| {\n+        if cfg!(debug_assertions) {\n+            panic!(\"'unchecked' unwrap on None in BTreeMap\");\n+        } else {\n+            core::intrinsics::unreachable();\n+        }\n+    })\n+}"}, {"sha": "653218972314f374e0cc87bc3d513b74eacbcfc4", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -0,0 +1,244 @@\n+use core::ptr;\n+\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::unwrap_unchecked;\n+\n+macro_rules! def_next {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an immutable tree, returns a handle to the next\n+        /// leaf edge and references to the key and value between these edges.\n+        /// Unsafe because the caller must ensure that the given leaf edge has a successor.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>, &'a K, &'a V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let (k, v) = leaf_kv.into_kv();\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let (k, v) = internal_kv.into_kv();\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_mut {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into a mutable tree, returns handles to the next\n+        /// leaf edge and to the KV between these edges.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - both returned handles represent mutable references into the same tree\n+        ///   that can easily invalidate each other, even on immutable use.\n+        unsafe fn $name <'a, K: 'a, V: 'a>(\n+            leaf_edge: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+              Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let next_leaf_edge = ptr::read(&leaf_kv).$next_edge();\n+                    return (next_leaf_edge, leaf_kv.forget_node_type());\n+                }\n+                Err(last_edge) => {\n+                    let next_level = last_edge.into_node().ascend().ok();\n+                    unwrap_unchecked(next_level)\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let next_internal_edge = ptr::read(&internal_kv).$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, internal_kv.forget_node_type());\n+                    }\n+                    Err(last_edge) => {\n+                        let next_level = last_edge.into_node().ascend().ok();\n+                        unwrap_unchecked(next_level)\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! def_next_dealloc {\n+    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n+        /// Given a leaf edge handle into an owned tree, returns a handle to the next\n+        /// leaf edge and the key and value between these edges, while deallocating\n+        /// any node left behind.\n+        /// Unsafe for two reasons:\n+        /// - the caller must ensure that the given leaf edge has a successor;\n+        /// - the node pointed at by the given handle, and its ancestors, may be deallocated,\n+        ///   while the reference to those nodes in the surviving ancestors is left dangling;\n+        ///   thus using the returned handle is dangerous.\n+        unsafe fn $name <K, V>(\n+            leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+        ) -> (Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+            let mut cur_handle = match leaf_edge.$next_kv() {\n+                Ok(leaf_kv) => {\n+                    let k = ptr::read(leaf_kv.reborrow().into_kv().0);\n+                    let v = ptr::read(leaf_kv.reborrow().into_kv().1);\n+                    let next_leaf_edge = leaf_kv.$next_edge();\n+                    return (next_leaf_edge, k, v);\n+                }\n+                Err(last_edge) => {\n+                    unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                }\n+            };\n+\n+            loop {\n+                cur_handle = match cur_handle.$next_kv() {\n+                    Ok(internal_kv) => {\n+                        let k = ptr::read(internal_kv.reborrow().into_kv().0);\n+                        let v = ptr::read(internal_kv.reborrow().into_kv().1);\n+                        let next_internal_edge = internal_kv.$next_edge();\n+                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n+                        return (next_leaf_edge, k, v);\n+                    }\n+                    Err(last_edge) => {\n+                        unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+def_next! {unsafe fn next_unchecked: right_kv right_edge first_leaf_edge}\n+def_next! {unsafe fn next_back_unchecked: left_kv left_edge last_leaf_edge}\n+def_next_mut! {unsafe fn next_unchecked_mut: right_kv right_edge first_leaf_edge}\n+def_next_mut! {unsafe fn next_back_unchecked_mut: left_kv left_edge last_leaf_edge}\n+def_next_dealloc! {unsafe fn next_unchecked_deallocating: right_kv right_edge first_leaf_edge}\n+def_next_dealloc! {unsafe fn next_back_unchecked_deallocating: left_kv left_edge last_leaf_edge}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n+        let (next_edge, k, v) = next_back_unchecked(*self);\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf and returns references to the\n+    /// key and value in between.\n+    /// Unsafe for two reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n+        let (next_edge, kv) = next_back_unchecked_mut(ptr::read(self));\n+        *self = next_edge;\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n+    }\n+}\n+\n+impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n+    /// Moves the leaf edge handle to the next leaf edge and returns the key and value\n+    /// in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the last one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_back_unchecked`.\n+    /// - If the leaf edge is the last edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+\n+    /// Moves the leaf edge handle to the previous leaf edge and returns the key\n+    /// and value in between, while deallocating any node left behind.\n+    /// Unsafe for three reasons:\n+    /// - The caller must ensure that the leaf edge is not the first one in the tree\n+    ///   and is not a handle previously resulting from counterpart `next_unchecked`.\n+    /// - If the lead edge is the first edge of a node, that node and possibly ancestors\n+    ///   will be deallocated, while the reference to those nodes in the surviving ancestor\n+    ///   is left dangling; thus further use of the leaf edge handle is dangerous.\n+    ///   It is, however, safe to call this method again on the updated handle.\n+    ///   if the two preconditions above hold.\n+    /// - Using the updated handle may well invalidate the returned references.\n+    pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n+        let (next_edge, k, v) = next_back_unchecked_deallocating(ptr::read(self));\n+        *self = next_edge;\n+        (k, v)\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leftmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need first when navigating forward (or last when navigating backward).\n+    #[inline]\n+    pub fn first_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.first_edge(),\n+                Internal(internal) => node = internal.first_edge().descend(),\n+            }\n+        }\n+    }\n+\n+    /// Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n+    /// you need last when navigating forward (or first when navigating backward).\n+    #[inline]\n+    pub fn last_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        let mut node = self;\n+        loop {\n+            match node.force() {\n+                Leaf(leaf) => return leaf.last_edge(),\n+                Internal(internal) => node = internal.last_edge().descend(),\n+            }\n+        }\n+    }\n+}"}, {"sha": "abf926186e82c1d3a12e16e874623d3890c7ddce", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 157, "deletions": 170, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -31,12 +31,13 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Global, Layout};\n+use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n@@ -54,10 +55,8 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n /// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n-/// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n-struct NodeHeader<K, V, K2 = ()> {\n+struct NodeHeader<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -72,9 +71,6 @@ struct NodeHeader<K, V, K2 = ()> {\n     /// This next to `parent_idx` to encourage the compiler to join `len` and\n     /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n-\n-    /// See `into_key_slice`.\n-    keys_start: [K2; 0],\n }\n #[repr(C)]\n struct LeafNode<K, V> {\n@@ -128,7 +124,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0, keys_start: [] };\n+    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n@@ -268,10 +264,10 @@ impl<K, V> Root<K, V> {\n \n     /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n+    /// has only one edge, no cleanup is done on any of the other children of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n     pub fn pop_level(&mut self) {\n-        debug_assert!(self.height > 0);\n+        assert!(self.height > 0);\n \n         let top = self.node.ptr;\n \n@@ -349,6 +345,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n+    /// For any node, the number of possible edge handles is also `len() + 1`.\n+    /// Note that, despite being safe, calling this function can have the side effect\n+    /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n         self.as_header().len as usize\n     }\n@@ -374,7 +373,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// See `NodeRef` on why the node may not be a shared root.\n+    /// Unsafe because the node must not be the shared root. For more information,\n+    /// see the `NodeRef` comments.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n         debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n@@ -390,14 +390,14 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Works on all possible nodes, including the shared root.\n-    pub fn keys(&self) -> &[K] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    pub unsafe fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals(&self) -> &[V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -429,25 +429,26 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n-        Handle::new_edge(self, 0)\n+        unsafe { Handle::new_edge(self, 0) }\n     }\n \n     pub fn last_edge(self) -> Handle<Self, marker::Edge> {\n         let len = self.len();\n-        Handle::new_edge(self, len)\n+        unsafe { Handle::new_edge(self, len) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn first_kv(self) -> Handle<Self, marker::KV> {\n-        debug_assert!(self.len() > 0);\n-        Handle::new_kv(self, 0)\n+        let len = self.len();\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, 0) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn last_kv(self) -> Handle<Self, marker::KV> {\n         let len = self.len();\n-        debug_assert!(len > 0);\n-        Handle::new_kv(self, len - 1)\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, len - 1) }\n     }\n }\n \n@@ -458,7 +459,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        debug_assert!(!self.is_shared_root());\n+        assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n         Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n@@ -513,71 +514,35 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         self.node.as_ptr()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn keys_mut(&mut self) -> &mut [K] {\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn keys_mut(&mut self) -> &mut [K] {\n+        self.reborrow_mut().into_key_slice_mut()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals_mut(&mut self) -> &mut [V] {\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals_mut(&mut self) -> &mut [V] {\n+        self.reborrow_mut().into_val_slice_mut()\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    fn into_key_slice(self) -> &'a [K] {\n-        // We have to be careful here because we might be pointing to the shared root.\n-        // In that case, we must not create an `&LeafNode`.  We could just return\n-        // an empty slice whenever the length is 0 (this includes the shared root),\n-        // but we want to avoid that run-time check.\n-        // Instead, we create a slice pointing into the node whenever possible.\n-        // We can sometimes do this even for the shared root, as the slice will be\n-        // empty and `NodeHeader` contains an empty `keys_start` array.\n-        // We cannot *always* do this because:\n-        // - `keys_start` is not correctly typed because we want `NodeHeader`'s size to\n-        //   not depend on the alignment of `K` (needed because `as_header` should be safe).\n-        //   For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n-        //   and hence just adds a size-0-align-1 field, not affecting layout).\n-        //   If the correctly typed header is more highly aligned than the allocated header,\n-        //   we cannot transmute safely.\n-        // - Even if we can transmute, the offset of a correctly typed `keys_start` might\n-        //   be different and outside the bounds of the allocated header!\n-        // So we do an alignment check and a size check first, that will be evaluated\n-        // at compile-time, and only do any run-time check in the rare case that\n-        // the compile-time checks signal danger.\n-        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n-            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n-            && self.is_shared_root()\n-        {\n-            &[]\n-        } else {\n-            // If we are a `LeafNode<K, V>`, we can always transmute to\n-            // `NodeHeader<K, V, K>` and `keys_start` always has the same offset\n-            // as the actual `keys`.\n-            // Thanks to the checks above, we know that we can transmute to\n-            // `NodeHeader<K, V, K>` and that `keys_start` will be\n-            // in-bounds of some allocation even if this is the shared root!\n-            // (We might be one-past-the-end, but that is allowed by LLVM.)\n-            // Thus we can use `NodeHeader<K, V, K>`\n-            // to compute the pointer where the keys start.\n-            // This entire hack will become unnecessary once\n-            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n-            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n-            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n-            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n-            unsafe { slice::from_raw_parts(keys, self.len()) }\n-        }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice(self) -> &'a [K] {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot be the shared root, so `as_leaf` is okay.\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice(self) -> &'a [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n-        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n     }\n \n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = unsafe { ptr::read(&self) };\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        let k = ptr::read(&self);\n         (k.into_key_slice(), self.into_val_slice())\n     }\n }\n@@ -589,59 +554,45 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // Same as for `into_key_slice` above, we try to avoid a run-time check.\n-        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n-            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n-            && self.is_shared_root()\n-        {\n-            &mut []\n-        } else {\n-            unsafe {\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-                    self.len(),\n-                )\n-            }\n-        }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot be the shared root, so `as_leaf_mut` is okay.\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-                self.len(),\n-            )\n-        }\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n-        unsafe {\n-            let len = self.len();\n-            let leaf = self.as_leaf_mut();\n-            let keys =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-            let vals =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n-            (keys, vals)\n-        }\n+        let len = self.len();\n+        let leaf = self.as_leaf_mut();\n+        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n+        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        (keys, vals)\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -656,8 +607,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -673,9 +623,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key/value pair and an edge to go to the right of that pair to\n     /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -691,23 +640,25 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+    // Unsafe because 'first' and 'after_last' must be in range\n+    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+        debug_assert!(first <= self.len());\n+        debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(unsafe { self.reborrow_mut() }, i).correct_parent_link();\n+            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n         }\n     }\n \n     fn correct_all_childrens_parent_links(&mut self) {\n         let len = self.len();\n-        self.correct_childrens_parent_links(0, len + 1);\n+        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n     }\n \n     /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -733,8 +684,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node. If this is an internal node,\n     /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -760,8 +710,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n     /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -796,8 +745,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -859,20 +808,20 @@ impl<Node, Type> Handle<Node, Type> {\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n-    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n-    pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to a key/value pair in `node`.\n+    /// Unsafe because the caller must ensure that `idx < node.len()`.\n+    pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx < node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx)\n+        unsafe { Handle::new_edge(self.node, self.idx) }\n     }\n \n     pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx + 1)\n+        unsafe { Handle::new_edge(self.node, self.idx + 1) }\n     }\n }\n \n@@ -884,6 +833,14 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     }\n }\n \n+impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n+    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType>\n     Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n@@ -914,21 +871,28 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n-    /// `node.len()`.\n-    pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to an edge in `node`.\n+    /// Unsafe because the caller must ensure that `idx <= node.len()`.\n+    pub unsafe fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx <= node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx > 0 { Ok(Handle::new_kv(self.node, self.idx - 1)) } else { Err(self) }\n+        if self.idx > 0 {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx - 1) })\n+        } else {\n+            Err(self)\n+        }\n     }\n \n     pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx < self.node.len() { Ok(Handle::new_kv(self.node, self.idx)) } else { Err(self) }\n+        if self.idx < self.node.len() {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx) })\n+        } else {\n+            Err(self)\n+        }\n     }\n }\n \n@@ -960,9 +924,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let ptr = self.insert_fit(key, val);\n-            (InsertResult::Fit(Handle::new_kv(self.node, self.idx)), ptr)\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             let ptr = if self.idx <= B {\n                 unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n@@ -1037,14 +1002,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         val: V,\n         edge: Root<K, V>,\n     ) -> InsertResult<'a, K, V, marker::Internal> {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.node.height - 1);\n+        assert!(edge.height == self.node.height - 1);\n \n         if self.node.len() < CAPACITY {\n             self.insert_fit(key, val, edge);\n-            InsertResult::Fit(Handle::new_kv(self.node, self.idx))\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            InsertResult::Fit(kv)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             if self.idx <= B {\n                 unsafe {\n@@ -1083,15 +1048,19 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        let (keys, vals) = self.node.into_slices();\n-        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices();\n+            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n+        }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n-        let (keys, vals) = self.node.into_slices_mut();\n-        unsafe { (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices_mut();\n+            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+        }\n     }\n }\n \n@@ -1113,7 +1082,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1145,7 +1114,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n@@ -1228,7 +1197,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let right_len = right_node.len();\n \n         // necessary for correctness, but in a private module\n-        debug_assert!(left_len + right_len + 1 <= CAPACITY);\n+        assert!(left_len + right_len + 1 <= CAPACITY);\n \n         unsafe {\n             ptr::write(\n@@ -1327,8 +1296,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(right_len + count <= CAPACITY);\n-            debug_assert!(left_len >= count);\n+            assert!(right_len + count <= CAPACITY);\n+            assert!(left_len >= count);\n \n             let new_left_len = left_len - count;\n \n@@ -1384,8 +1353,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(left_len + count <= CAPACITY);\n-            debug_assert!(right_len >= count);\n+            assert!(left_len + count <= CAPACITY);\n+            assert!(right_len >= count);\n \n             let new_right_len = right_len - count;\n \n@@ -1458,6 +1427,22 @@ unsafe fn move_edges<K, V>(\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n impl<BorrowType, K, V, HandleType>\n     Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n {\n@@ -1493,24 +1478,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n             let right_new_len = left_node.len() - left_new_len;\n             let mut right_node = right.reborrow_mut();\n \n-            debug_assert!(right_node.len() == 0);\n-            debug_assert!(left_node.height == right_node.height);\n+            assert!(right_node.len() == 0);\n+            assert!(left_node.height == right_node.height);\n \n-            let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-            let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+            if right_new_len > 0 {\n+                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n \n-            move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n+                move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n-            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n+                (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+                (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n-            match (left_node.force(), right_node.force()) {\n-                (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n-                    move_edges(left, left_new_len + 1, right, 1, right_new_len);\n-                }\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n+                match (left_node.force(), right_node.force()) {\n+                    (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                        move_edges(left, left_new_len + 1, right, 1, right_new_len);\n+                    }\n+                    (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                    _ => {\n+                        unreachable!();\n+                    }\n                 }\n             }\n         }"}, {"sha": "2ba5cebbdee74f788da20f6f88b1092df21a24b3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -10,6 +10,10 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n+/// Looks up a given key in a (sub)tree headed by the given node, recursively.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the possible leaf edge where the key\n+/// belongs.\n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     key: &Q,\n@@ -32,6 +36,10 @@ where\n     }\n }\n \n+/// Looks up a given key in a given node, without recursion.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the edge where the key might be found.\n+/// If the node is a leaf, a `GoDown` edge is not an actual edge but a possible edge.\n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n@@ -41,25 +49,38 @@ where\n     K: Borrow<Q>,\n {\n     match search_linear(&node, key) {\n-        (idx, true) => Found(Handle::new_kv(node, idx)),\n-        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n+        (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n+        (idx, false) => SearchResult::GoDown(unsafe { Handle::new_edge(node, idx) }),\n     }\n }\n \n-pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+/// Returns the index in the node at which the key (or an equivalent) exists\n+/// or could exist, and whether it exists in the node itself. If it doesn't\n+/// exist in the node itself, it may exist in the subtree with that index\n+/// (if the node has subtrees). If the key doesn't exist in node or subtree,\n+/// the returned index is the position or subtree where the key belongs.\n+fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n ) -> (usize, bool)\n where\n     Q: Ord,\n     K: Borrow<Q>,\n {\n-    for (i, k) in node.keys().iter().enumerate() {\n-        match key.cmp(k.borrow()) {\n-            Ordering::Greater => {}\n-            Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false),\n+    // This function is defined over all borrow types (immutable, mutable, owned),\n+    // and may be called on the shared root in each case.\n+    // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n+    // is an index -- not a reference.\n+    let len = node.len();\n+    if len > 0 {\n+        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n+        for (i, k) in keys.iter().enumerate() {\n+            match key.cmp(k.borrow()) {\n+                Ordering::Greater => {}\n+                Ordering::Equal => return (i, true),\n+                Ordering::Less => return (i, false),\n+            }\n         }\n     }\n-    (node.keys().len(), false)\n+    (len, false)\n }"}, {"sha": "b100ce754caad589b92089d51c9c89e087faba4c", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -56,12 +56,23 @@ use crate::collections::btree_map::{self, BTreeMap, Keys};\n ///     println!(\"{}\", book);\n /// }\n /// ```\n-#[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n+#[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Clone> Clone for BTreeSet<T> {\n+    fn clone(&self) -> Self {\n+        BTreeSet { map: self.map.clone() }\n+    }\n+\n+    fn clone_from(&mut self, other: &Self) {\n+        self.map.clone_from(&other.map);\n+    }\n+}\n+\n /// An iterator over the items of a `BTreeSet`.\n ///\n /// This `struct` is created by the [`iter`] method on [`BTreeSet`]."}, {"sha": "b88ca8a0fb0d10870be027d9863fe7224ad61aba", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 555, "deletions": 24, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -242,6 +242,121 @@ impl<T> LinkedList<T> {\n \n         self.len -= 1;\n     }\n+\n+    /// Splices a series of nodes between two existing nodes.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the two existing lists.\n+    #[inline]\n+    unsafe fn splice_nodes(\n+        &mut self,\n+        existing_prev: Option<NonNull<Node<T>>>,\n+        existing_next: Option<NonNull<Node<T>>>,\n+        mut splice_start: NonNull<Node<T>>,\n+        mut splice_end: NonNull<Node<T>>,\n+        splice_length: usize,\n+    ) {\n+        // This method takes care not to create multiple mutable references to whole nodes at the same time,\n+        // to maintain validity of aliasing pointers into `element`.\n+        if let Some(mut existing_prev) = existing_prev {\n+            existing_prev.as_mut().next = Some(splice_start);\n+        } else {\n+            self.head = Some(splice_start);\n+        }\n+        if let Some(mut existing_next) = existing_next {\n+            existing_next.as_mut().prev = Some(splice_end);\n+        } else {\n+            self.tail = Some(splice_end);\n+        }\n+        splice_start.as_mut().prev = existing_prev;\n+        splice_end.as_mut().next = existing_next;\n+\n+        self.len += splice_length;\n+    }\n+\n+    /// Detaches all nodes from a linked list as a series of nodes.\n+    #[inline]\n+    fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {\n+        let head = self.head.take();\n+        let tail = self.tail.take();\n+        let len = mem::replace(&mut self.len, 0);\n+        if let Some(head) = head {\n+            let tail = tail.unwrap_or_else(|| unsafe { core::hint::unreachable_unchecked() });\n+            Some((head, tail, len))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_before_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new head node of the second part\n+        if let Some(mut split_node) = split_node {\n+            let first_part_head;\n+            let first_part_tail;\n+            first_part_tail = split_node.as_mut().prev.take();\n+            if let Some(mut tail) = first_part_tail {\n+                tail.as_mut().next = None;\n+                first_part_head = self.head;\n+            } else {\n+                first_part_head = None;\n+            }\n+\n+            let first_part = LinkedList {\n+                head: first_part_head,\n+                tail: first_part_tail,\n+                len: at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the head ptr of the second part\n+            self.head = Some(split_node);\n+            self.len = self.len - at;\n+\n+            first_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_after_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new tail node of the first part and owns\n+        // the head of the second part.\n+        if let Some(mut split_node) = split_node {\n+            let second_part_head;\n+            let second_part_tail;\n+            second_part_head = split_node.as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n+                second_part_tail = self.tail;\n+            } else {\n+                second_part_tail = None;\n+            }\n+\n+            let second_part = LinkedList {\n+                head: second_part_head,\n+                tail: second_part_tail,\n+                len: self.len - at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the tail ptr of the first part\n+            self.tail = Some(split_node);\n+            self.len = at;\n+\n+            second_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -319,6 +434,27 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n+    /// Moves all elements from `other` to the begin of the list.\n+    #[unstable(feature = \"linked_list_prepend\", issue = \"none\")]\n+    pub fn prepend(&mut self, other: &mut Self) {\n+        match self.head {\n+            None => mem::swap(self, other),\n+            Some(mut head) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n+                if let Some(mut other_tail) = other.tail.take() {\n+                    unsafe {\n+                        head.as_mut().prev = Some(other_tail);\n+                        other_tail.as_mut().next = Some(head);\n+                    }\n+\n+                    self.head = other.head.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Provides a forward iterator.\n     ///\n     /// # Examples\n@@ -373,6 +509,42 @@ impl<T> LinkedList<T> {\n         IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n     }\n \n+    /// Provides a cursor at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front(&self) -> Cursor<'_, T> {\n+        Cursor { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back(&self) -> Cursor<'_, T> {\n+        Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -703,30 +875,7 @@ impl<T> LinkedList<T> {\n             }\n             iter.tail\n         };\n-\n-        // The split node is the new tail node of the first part and owns\n-        // the head of the second part.\n-        let second_part_head;\n-\n-        unsafe {\n-            second_part_head = split_node.unwrap().as_mut().next.take();\n-            if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n-            }\n-        }\n-\n-        let second_part = LinkedList {\n-            head: second_part_head,\n-            tail: self.tail,\n-            len: len - at,\n-            marker: PhantomData,\n-        };\n-\n-        // Fix the tail ptr of the first part\n-        self.tail = split_node;\n-        self.len = at;\n-\n-        second_part\n+        unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n@@ -986,6 +1135,388 @@ impl<T> IterMut<'_, T> {\n     }\n }\n \n+/// A cursor over a `LinkedList`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+///\n+/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct Cursor<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+/// A cursor over a `LinkedList` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the list during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying list. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct CursorMut<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a mut LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+impl<'a, T> Cursor<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&self) -> Option<&'a T> {\n+        unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&self) -> Option<&'a T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &(*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&self) -> Option<&'a T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &(*prev.as_ptr()).element)\n+        }\n+    }\n+}\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&mut self) -> Option<&mut T> {\n+        unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &mut (*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &mut (*prev.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n+        Cursor { list: self.list, current: self.current, index: self.index }\n+    }\n+}\n+\n+// Now the list editing operations\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Inserts a new element into the `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_after(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, spliced_node, spliced_node, 1);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts a new element into the `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_before(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Removes the current element from the `LinkedList`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current(&mut self) -> Option<T> {\n+        let unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+            let unlinked_node = Box::from_raw(unlinked_node.as_ptr());\n+            Some(unlinked_node.element)\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the start of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_after(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_before(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n+            self.index += splice_len;\n+        }\n+    }\n+\n+    /// Splits the list into two after the current element. This will return a\n+    /// new list consisting of everything after the cursor, with the original\n+    /// list retaining everything before.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_after(&mut self) -> LinkedList<T> {\n+        let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n+        if self.index == self.list.len {\n+            // The \"ghost\" non-element's index has changed to 0.\n+            self.index = 0;\n+        }\n+        unsafe { self.list.split_off_after_node(self.current, split_off_idx) }\n+    }\n+\n+    /// Splits the list into two before the current element. This will return a\n+    /// new list consisting of everything before the cursor, with the original\n+    /// list retaining everything after.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_before(&mut self) -> LinkedList<T> {\n+        let split_off_idx = self.index;\n+        self.index = 0;\n+        unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n+    }\n+}\n+\n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n pub struct DrainFilter<'a, T: 'a, F: 'a>"}, {"sha": "085f734ed916a0ca43cc92ad4e257268d48e5ff7", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -304,3 +304,155 @@ fn drain_to_empty_test() {\n     assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n     assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n }\n+\n+#[test]\n+fn test_cursor_move_peek() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front();\n+    assert_eq!(cursor.current(), Some(&1));\n+    assert_eq!(cursor.peek_next(), Some(&2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&2));\n+    assert_eq!(cursor.peek_next(), Some(&3));\n+    assert_eq!(cursor.peek_prev(), Some(&1));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut cursor = m.cursor_back();\n+    assert_eq!(cursor.current(), Some(&6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&5));\n+    assert_eq!(cursor.peek_next(), Some(&6));\n+    assert_eq!(cursor.peek_prev(), Some(&4));\n+    assert_eq!(cursor.index(), Some(4));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    assert_eq!(cursor.current(), Some(&mut 1));\n+    assert_eq!(cursor.peek_next(), Some(&mut 2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.peek_next(), Some(&mut 3));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 1));\n+    assert_eq!(cursor.index(), Some(1));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&2));\n+    assert_eq!(cursor2.index(), Some(1));\n+    cursor2.move_next();\n+    assert_eq!(cursor2.current(), Some(&3));\n+    assert_eq!(cursor2.index(), Some(2));\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_back_mut();\n+    assert_eq!(cursor.current(), Some(&mut 6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.peek_next(), Some(&mut 6));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 4));\n+    assert_eq!(cursor.index(), Some(4));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&5));\n+    assert_eq!(cursor2.index(), Some(4));\n+    cursor2.move_prev();\n+    assert_eq!(cursor2.current(), Some(&4));\n+    assert_eq!(cursor2.index(), Some(3));\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(4));\n+}\n+\n+#[test]\n+fn test_cursor_mut_insert() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.insert_before(7);\n+    cursor.insert_after(8);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    cursor.insert_before(9);\n+    cursor.insert_after(10);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(7));\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), Some(9));\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(10));\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    let mut p: LinkedList<u32> = LinkedList::new();\n+    p.extend(&[100, 101, 102, 103]);\n+    let mut q: LinkedList<u32> = LinkedList::new();\n+    q.extend(&[200, 201, 202, 203]);\n+    cursor.splice_after(p);\n+    cursor.splice_before(q);\n+    check_links(&m);\n+    assert_eq!(\n+        m.iter().cloned().collect::<Vec<_>>(),\n+        &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]\n+    );\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    let tmp = cursor.split_before();\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    m = tmp;\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    let tmp = cursor.split_after();\n+    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n+}"}, {"sha": "ffa4176cc7969533012b20bc4e3ceb1879cb0f2b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -60,6 +60,7 @@\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    html_playground_url = \"https://play.rust-lang.org/\",\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n     test(no_crate_inject, attr(allow(unused_variables), deny(warnings)))\n )]\n@@ -104,7 +105,6 @@\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n-#![feature(slice_from_raw_parts)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]"}, {"sha": "144654946a2acb53225ac5dedb413f4a2aa95dd4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -7,7 +7,7 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, Alloc, AllocErr, Global, Layout};\n+use crate::alloc::{handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n@@ -42,13 +42,13 @@ mod tests;\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Alloc = Global> {\n+pub struct RawVec<T, A: AllocRef = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     a: A,\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n@@ -147,7 +147,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n@@ -182,7 +182,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n     /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n@@ -280,7 +280,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, uniq) = match self.current_layout() {\n+            let (new_cap, ptr) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +297,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Ok(ptr) => (new_cap, ptr),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -308,13 +308,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n                     // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    match self.a.alloc_array::<T>(new_cap) {\n-                        Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n+                    let layout = Layout::array::<T>(new_cap).unwrap();\n+                    match self.a.alloc(layout) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n             };\n-            self.ptr = uniq;\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n         }\n     }\n@@ -622,7 +623,7 @@ enum ReserveStrategy {\n \n use ReserveStrategy::*;\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     fn reserve_internal(\n         &mut self,\n         used_capacity: usize,\n@@ -700,7 +701,7 @@ impl<T> RawVec<T, Global> {\n     }\n }\n \n-impl<T, A: Alloc> RawVec<T, A> {\n+impl<T, A: AllocRef> RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n@@ -712,7 +713,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n+unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe {"}, {"sha": "63087501f0e27684e4c4525f62c795d042813bc9", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -19,7 +19,7 @@ fn allocator_param() {\n     struct BoundedAlloc {\n         fuel: usize,\n     }\n-    unsafe impl Alloc for BoundedAlloc {\n+    unsafe impl AllocRef for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {"}, {"sha": "9dc5447397f09167602c30aa6fa7b11eed67bdee", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -252,7 +252,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, from_raw_parts_mut};\n use core::usize;\n \n-use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -565,9 +565,19 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr: *const T = &*this;\n+        let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n+        let fake_ptr = ptr as *mut T;\n         mem::forget(this);\n-        ptr\n+\n+        // SAFETY: This cannot go through Deref::deref.\n+        // Instead, we manually offset the pointer rather than manifesting a reference.\n+        // This is so that the returned pointer retains the same provenance as our pointer.\n+        // This is required so that e.g. `get_mut` can write through the pointer\n+        // after the Rc is recovered through `from_raw`.\n+        unsafe {\n+            let offset = data_offset(&(*ptr).value);\n+            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n+        }\n     }\n \n     /// Constructs an `Rc` from a raw pointer."}, {"sha": "3cb1f259a0b0dacd2d3a8c763d6f57125974505d", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -319,7 +319,7 @@ pub struct String {\n /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -2208,6 +2208,14 @@ impl AsRef<str> for String {\n     }\n }\n \n+#[stable(feature = \"string_as_mut\", since = \"1.43.0\")]\n+impl AsMut<str> for String {\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut str {\n+        self\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<[u8]> for String {\n     #[inline]"}, {"sha": "fd285242d5be48ec9478ac2d7c509b60ab3194fd", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -25,7 +25,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::{isize, usize};\n \n-use crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n@@ -545,9 +545,19 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr: *const T = &*this;\n+        let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n+        let fake_ptr = ptr as *mut T;\n         mem::forget(this);\n-        ptr\n+\n+        // SAFETY: This cannot go through Deref::deref.\n+        // Instead, we manually offset the pointer rather than manifesting a reference.\n+        // This is so that the returned pointer retains the same provenance as our pointer.\n+        // This is required so that e.g. `get_mut` can write through the pointer\n+        // after the Arc is recovered through `from_raw`.\n+        unsafe {\n+            let offset = data_offset(&(*ptr).data);\n+            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n+        }\n     }\n \n     /// Constructs an `Arc` from a raw pointer."}, {"sha": "0a26d7bf427ab019eb11850d76722493d225ed47", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 175, "deletions": 31, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -4,6 +4,7 @@ use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n+use std::ops::RangeBounds;\n use std::rc::Rc;\n \n use super::DeterministicRng;\n@@ -22,6 +23,11 @@ fn test_basic_large() {\n         assert_eq!(map.len(), i + 1);\n     }\n \n+    assert_eq!(map.first_key_value(), Some((&0, &0)));\n+    assert_eq!(map.last_key_value(), Some((&(size - 1), &(10 * (size - 1)))));\n+    assert_eq!(map.first_entry().unwrap().key(), &0);\n+    assert_eq!(map.last_entry().unwrap().key(), &(size - 1));\n+\n     for i in 0..size {\n         assert_eq!(map.get(&i).unwrap(), &(i * 10));\n     }\n@@ -68,6 +74,11 @@ fn test_basic_small() {\n     assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.keys().count(), 0);\n     assert_eq!(map.values().count(), 0);\n+    assert_eq!(map.range(..).next(), None);\n+    assert_eq!(map.range(..1).next(), None);\n+    assert_eq!(map.range(1..).next(), None);\n+    assert_eq!(map.range(1..=1).next(), None);\n+    assert_eq!(map.range(1..2).next(), None);\n     assert_eq!(map.insert(1, 1), None);\n \n     // 1 key-value pair:\n@@ -118,6 +129,11 @@ fn test_basic_small() {\n     assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.keys().count(), 0);\n     assert_eq!(map.values().count(), 0);\n+    assert_eq!(map.range(..).next(), None);\n+    assert_eq!(map.range(..1).next(), None);\n+    assert_eq!(map.range(1..).next(), None);\n+    assert_eq!(map.range(1..=1).next(), None);\n+    assert_eq!(map.range(1..2).next(), None);\n     assert_eq!(map.remove(&1), None);\n }\n \n@@ -128,7 +144,6 @@ fn test_iter() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -154,7 +169,6 @@ fn test_iter_rev() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -275,7 +289,6 @@ fn test_iter_mixed() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -299,27 +312,147 @@ fn test_iter_mixed() {\n     test(size, map.into_iter());\n }\n \n-#[test]\n-fn test_range_small() {\n-    let size = 5;\n-\n-    // Forwards\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-    let mut j = 0;\n-    for ((&k, &v), i) in map.range(2..).zip(2..size) {\n-        assert_eq!(k, i);\n-        assert_eq!(v, i);\n-        j += 1;\n-    }\n-    assert_eq!(j, size - 2);\n+fn range_keys(map: &BTreeMap<i32, i32>, range: impl RangeBounds<i32>) -> Vec<i32> {\n+    map.range(range)\n+        .map(|(&k, &v)| {\n+            assert_eq!(k, v);\n+            k\n+        })\n+        .collect()\n }\n \n #[test]\n-fn test_range_inclusive() {\n-    let size = 500;\n+fn test_range_small() {\n+    let size = 4;\n+\n+    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n+    let all: Vec<_> = (1..=size).collect();\n+    let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size))), all);\n+    assert_eq!(range_keys(&map, ..), all);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(1))), first);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Included(size), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Excluded(size), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Included(size))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Unbounded)), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Included(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Unbounded)), vec![]);\n+\n+    assert_eq!(range_keys(&map, ..3), vec![1, 2]);\n+    assert_eq!(range_keys(&map, 3..), vec![3, 4]);\n+    assert_eq!(range_keys(&map, 2..=3), vec![2, 3]);\n+}\n+\n+#[test]\n+fn test_range_depth_2() {\n+    // Assuming that node.CAPACITY is 11, having 12 pairs implies a depth 2 tree\n+    // with 2 leaves. Depending on details we don't want or need to rely upon,\n+    // the single key at the root will be 6 or 7.\n+\n+    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    for &root in &[6, 7] {\n+        assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n+        assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n+        assert_eq!(range_keys(&map, (Included(root), Excluded(root + 1))), vec![root]);\n+        assert_eq!(range_keys(&map, (Included(root), Included(root + 1))), vec![root, root + 1]);\n+\n+        assert_eq!(range_keys(&map, (Excluded(root - 1), Excluded(root))), vec![]);\n+        assert_eq!(range_keys(&map, (Included(root - 1), Excluded(root))), vec![root - 1]);\n+        assert_eq!(range_keys(&map, (Excluded(root - 1), Included(root))), vec![root]);\n+        assert_eq!(range_keys(&map, (Included(root - 1), Included(root))), vec![root - 1, root]);\n+    }\n+}\n+\n+#[test]\n+fn test_range_large() {\n+    let size = 200;\n \n-    let map: BTreeMap<_, _> = (0..=size).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n+    let all: Vec<_> = (1..=size).collect();\n+    let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size))), all);\n+    assert_eq!(range_keys(&map, ..), all);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(1))), first);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Included(size), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Excluded(size), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Included(size))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Unbounded)), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Included(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Unbounded)), vec![]);\n \n     fn check<'a, L, R>(lhs: L, rhs: R)\n     where\n@@ -331,18 +464,9 @@ fn test_range_inclusive() {\n         assert_eq!(lhs, rhs);\n     }\n \n-    check(map.range(size + 1..=size + 1), vec![]);\n-    check(map.range(size..=size), vec![(&size, &size)]);\n-    check(map.range(size..=size + 1), vec![(&size, &size)]);\n-    check(map.range(0..=0), vec![(&0, &0)]);\n-    check(map.range(0..=size - 1), map.range(..size));\n-    check(map.range(-1..=-1), vec![]);\n-    check(map.range(-1..=size), map.range(..));\n-    check(map.range(..=size), map.range(..));\n-    check(map.range(..=200), map.range(..201));\n+    check(map.range(..=100), map.range(..101));\n     check(map.range(5..=8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n-    check(map.range(-1..=0), vec![(&0, &0)]);\n-    check(map.range(-1..=2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n+    check(map.range(-1..=2), vec![(&1, &1), (&2, &2)]);\n }\n \n #[test]\n@@ -666,6 +790,26 @@ fn test_clone() {\n     }\n }\n \n+#[test]\n+fn test_clone_from() {\n+    let mut map1 = BTreeMap::new();\n+    let size = 30;\n+\n+    for i in 0..size {\n+        let mut map2 = BTreeMap::new();\n+        for j in 0..i {\n+            let mut map1_copy = map2.clone();\n+            map1_copy.clone_from(&map1);\n+            assert_eq!(map1_copy, map1);\n+            let mut map2_copy = map1.clone();\n+            map2_copy.clone_from(&map2);\n+            assert_eq!(map2_copy, map2);\n+            map2.insert(100 * j + 1, 2 * j + 1);\n+        }\n+        map1.insert(i, 10 * i);\n+    }\n+}\n+\n #[test]\n #[allow(dead_code)]\n fn test_variance() {"}, {"sha": "1a2b62d026b2ec969a38ef9186e9eff027a26eeb", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -487,21 +487,26 @@ fn test_first_last() {\n     a.insert(2);\n     assert_eq!(a.first(), Some(&1));\n     assert_eq!(a.last(), Some(&2));\n-    a.insert(3);\n+    for i in 3..=12 {\n+        a.insert(i);\n+    }\n     assert_eq!(a.first(), Some(&1));\n-    assert_eq!(a.last(), Some(&3));\n-\n-    assert_eq!(a.len(), 3);\n+    assert_eq!(a.last(), Some(&12));\n     assert_eq!(a.pop_first(), Some(1));\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(a.pop_last(), Some(3));\n-    assert_eq!(a.len(), 1);\n+    assert_eq!(a.pop_last(), Some(12));\n     assert_eq!(a.pop_first(), Some(2));\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(a.pop_last(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), Some(11));\n+    assert_eq!(a.pop_first(), Some(3));\n+    assert_eq!(a.pop_last(), Some(10));\n+    assert_eq!(a.pop_first(), Some(4));\n+    assert_eq!(a.pop_first(), Some(5));\n+    assert_eq!(a.pop_first(), Some(6));\n+    assert_eq!(a.pop_first(), Some(7));\n+    assert_eq!(a.pop_first(), Some(8));\n+    assert_eq!(a.clone().pop_last(), Some(9));\n+    assert_eq!(a.pop_first(), Some(9));\n     assert_eq!(a.pop_first(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), None);\n }\n \n fn rand_data(len: usize) -> Vec<u32> {"}, {"sha": "7fcfcf9b2945d26184d9ae9e9738c30c1068df69", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{Alloc, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -11,7 +11,7 @@ fn std_heap_overaligned_request() {\n     check_overalign_requests(Global)\n }\n \n-fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n     for &align in &[4, 8, 16, 32] {\n         // less than and bigger than `MIN_ALIGN`\n         for &size in &[align / 2, align - 1] {"}, {"sha": "c1ae67a1a339f9ae46c5c0e67abadf1fc3bdaef5", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -11,6 +11,7 @@\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n+#![feature(vec_remove_item)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "08859b2b24bde0b2c715cbb569f95ef1cd0c18e1", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -50,7 +50,11 @@ fn test_from_utf8() {\n \n     let xs = b\"hello\\xFF\".to_vec();\n     let err = String::from_utf8(xs).unwrap_err();\n+    assert_eq!(err.as_bytes(), b\"hello\\xff\");\n+    let err_clone = err.clone();\n+    assert_eq!(err, err_clone);\n     assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n+    assert_eq!(err_clone.utf8_error().valid_up_to(), 5);\n }\n \n #[test]"}, {"sha": "4f6b7870e2e8ceca10d51509c2803b9592c97534", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -4,6 +4,8 @@\n //! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n //! `O(1)` pop (from the end).\n //!\n+//! Vectors ensure they never allocate more than `isize::MAX` bytes.\n+//!\n //! # Examples\n //!\n //! You can explicitly create a [`Vec<T>`] with [`new`]:\n@@ -176,7 +178,7 @@ use crate::raw_vec::RawVec;\n /// ```\n ///\n /// In Rust, it's more common to pass slices as arguments rather than vectors\n-/// when you just want to provide a read access. The same goes for [`String`] and\n+/// when you just want to provide read access. The same goes for [`String`] and\n /// [`&str`].\n ///\n /// # Capacity and reallocation\n@@ -1696,13 +1698,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(vec_remove_item)]\n     /// let mut vec = vec![1, 2, 3, 1];\n     ///\n     /// vec.remove_item(&1);\n     ///\n     /// assert_eq!(vec, vec![2, 3, 1]);\n     /// ```\n-    #[stable(feature = \"vec_remove_item\", since = \"1.42.0\")]\n+    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n     pub fn remove_item<V>(&mut self, item: &V) -> Option<T>\n     where\n         T: PartialEq<V>,"}, {"sha": "2a3d92edc4956dafc26936d82c8a506ff0e5029a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,7 +21,6 @@\n extern crate alloc;\n \n use rustc_data_structures::cold_path;\n-use rustc_data_structures::sync::MTLock;\n use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n@@ -116,11 +115,6 @@ impl<T> Default for TypedArena<T> {\n }\n \n impl<T> TypedArena<T> {\n-    pub fn in_arena(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const T as *mut T;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &mut T {\n@@ -334,12 +328,6 @@ impl Default for DroplessArena {\n }\n \n impl DroplessArena {\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const u8 as *mut u8;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n-\n     #[inline]\n     fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n@@ -500,66 +488,5 @@ impl DroplessArena {\n     }\n }\n \n-#[derive(Default)]\n-// FIXME(@Zoxc): this type is entirely unused in rustc\n-pub struct SyncTypedArena<T> {\n-    lock: MTLock<TypedArena<T>>,\n-}\n-\n-impl<T> SyncTypedArena<T> {\n-    #[inline(always)]\n-    pub fn alloc(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn clear(&mut self) {\n-        self.lock.get_mut().clear();\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct SyncDroplessArena {\n-    lock: MTLock<DroplessArena>,\n-}\n-\n-impl SyncDroplessArena {\n-    #[inline(always)]\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        self.lock.lock().in_arena(ptr)\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "71f7f971eabaf8c07145b1a7af81cc18a7adc88e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 169, "deletions": 216, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -17,7 +17,7 @@ use crate::usize;\n #[derive(Debug)]\n pub struct Excess(pub NonNull<u8>, pub usize);\n \n-fn size_align<T>() -> (usize, usize) {\n+const fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n }\n \n@@ -31,7 +31,7 @@ fn size_align<T>() -> (usize, usize) {\n ///\n /// (Note however that layouts are *not* required to have positive\n /// size, even though many allocators require that all memory\n-/// requests have positive size. A caller to the `Alloc::alloc`\n+/// requests have positive size. A caller to the `AllocRef::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n@@ -64,8 +64,9 @@ impl Layout {\n     ///    must not overflow (i.e., the rounded value must be less than\n     ///    `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n+    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n         if !align.is_power_of_two() {\n             return Err(LayoutErr { private: () });\n         }\n@@ -106,28 +107,30 @@ impl Layout {\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn size(&self) -> usize {\n+    pub const fn size(&self) -> usize {\n         self.size_\n     }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn align(&self) -> usize {\n+    pub const fn align(&self) -> usize {\n         self.align_.get()\n     }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n     #[inline]\n-    pub fn new<T>() -> Self {\n+    pub const fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n         // Note that the align is guaranteed by rustc to be a power of two and\n         // the size+align combo is guaranteed to fit in our address space. As a\n         // result use the unchecked constructor here to avoid inserting code\n         // that panics if it isn't optimized well enough.\n-        debug_assert!(Layout::from_size_align(size, align).is_ok());\n         unsafe { Layout::from_size_align_unchecked(size, align) }\n     }\n \n@@ -181,8 +184,9 @@ impl Layout {\n     /// address for the whole allocated block of memory. One way to\n     /// satisfy this constraint is to ensure `align <= self.align()`.\n     #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n     #[inline]\n-    pub fn padding_needed_for(&self, align: usize) -> usize {\n+    pub const fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n \n         // Rounded up value is:\n@@ -360,8 +364,8 @@ impl fmt::Display for AllocErr {\n /// [`shrink_in_place`] were unable to reuse the given memory block for\n /// a requested layout.\n ///\n-/// [`grow_in_place`]: ./trait.Alloc.html#method.grow_in_place\n-/// [`shrink_in_place`]: ./trait.Alloc.html#method.shrink_in_place\n+/// [`grow_in_place`]: ./trait.AllocRef.html#method.grow_in_place\n+/// [`shrink_in_place`]: ./trait.AllocRef.html#method.shrink_in_place\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct CannotReallocInPlace;\n@@ -521,7 +525,8 @@ pub unsafe trait GlobalAlloc {\n     /// The memory may or may not have been deallocated,\n     /// and should be considered unusable (unless of course it was\n     /// transferred back to the caller again via the return value of\n-    /// this method).\n+    /// this method). The new memory block is allocated with `layout`, but\n+    /// with the `size` updated to `new_size`.\n     ///\n     /// If this method returns null, then ownership of the memory\n     /// block has not been transferred to this allocator, and the\n@@ -575,33 +580,32 @@ pub unsafe trait GlobalAlloc {\n     }\n }\n \n-/// An implementation of `Alloc` can allocate, reallocate, and\n+/// An implementation of `AllocRef` can allocate, reallocate, and\n /// deallocate arbitrary blocks of data described via `Layout`.\n ///\n+/// `AllocRef` is designed to be implemented on ZSTs, references, or\n+/// smart pointers because having an allocator like `MyAlloc([u8; N])`\n+/// cannot be moved, without updating the pointers to the allocated\n+/// memory.\n+///\n /// Some of the methods require that a memory block be *currently\n /// allocated* via an allocator. This means that:\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n-///   reallocation method (`realloc`, `realloc_excess`, or\n-///   `realloc_array`), and\n+///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n+///   (`realloc`, `realloc_excess`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n ///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n ///   passed to a reallocation method (see above) that returns `Ok`.\n ///\n /// A note regarding zero-sized types and zero-sized layouts: many\n-/// methods in the `Alloc` trait state that allocation requests\n+/// methods in the `AllocRef` trait state that allocation requests\n /// must be non-zero size, or else undefined behavior can result.\n ///\n-/// * However, some higher-level allocation methods (`alloc_one`,\n-///   `alloc_array`) are well-defined on zero-sized types and can\n-///   optionally support them: it is left up to the implementor\n-///   whether to return `Err`, or to return `Ok` with some pointer.\n-///\n-/// * If an `Alloc` implementation chooses to return `Ok` in this\n+/// * If an `AllocRef` implementation chooses to return `Ok` in this\n ///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n ///   allocated\". On such an allocator, *all* methods that take\n@@ -641,21 +645,24 @@ pub unsafe trait GlobalAlloc {\n ///\n /// # Safety\n ///\n-/// The `Alloc` trait is an `unsafe` trait for a number of reasons, and\n+/// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n /// * Pointers returned from allocation functions must point to valid memory and\n-///   retain their validity until at least the instance of `Alloc` is dropped\n+///   retain their validity until at least one instance of `AllocRef` is dropped\n ///   itself.\n ///\n+/// * Cloning or moving the allocator must not invalidate pointers returned\n+///   from this allocator. Cloning must return a reference to the same allocator.\n+///\n /// * `Layout` queries and calculations in general must be correct. Callers of\n ///   this trait are allowed to rely on the contracts defined on each method,\n ///   and implementors must ensure such contracts remain true.\n ///\n /// Note that this list may get tweaked over time as clarifications are made in\n /// the future.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub unsafe trait Alloc {\n+pub unsafe trait AllocRef {\n     // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n     // e.g., in C, `malloc` of 0 will either return a null pointer or a\n@@ -840,6 +847,59 @@ pub unsafe trait Alloc {\n         result\n     }\n \n+    /// Behaves like `realloc`, but also ensures that the new contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n+        let old_size = layout.size();\n+\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let result = self.alloc_zeroed(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n@@ -891,6 +951,31 @@ pub unsafe trait Alloc {\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Behaves like `realloc`, but also returns the whole size of\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n@@ -921,6 +1006,37 @@ pub unsafe trait Alloc {\n         self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_excess_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -970,6 +1086,34 @@ pub unsafe trait Alloc {\n         if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n+    /// Behaves like `grow_in_place`, but also ensures that the new\n+    /// contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `grow_in_place` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n+    /// function; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n+        self.grow_in_place(ptr, layout, new_size)?;\n+        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n+        Ok(())\n+    }\n+\n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -1022,195 +1166,4 @@ pub unsafe trait Alloc {\n         // new_layout.size() <= layout.size()        [required by this method]\n         if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n-\n-    // == COMMON USAGE PATTERNS ==\n-    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n-\n-    /// Allocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `Alloc` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `T` does not meet allocator's size or alignment constraints.\n-    ///\n-    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n-    /// will *not* yield undefined behavior.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 { unsafe { self.alloc(k).map(|p| p.cast()) } } else { Err(AllocErr) }\n-    }\n-\n-    /// Deallocates a block suitable for holding an instance of `T`.\n-    ///\n-    /// The given block must have been produced by this allocator,\n-    /// and must be suitable for storing a `T` (in terms of alignment\n-    /// as well as minimum and maximum size); otherwise yields\n-    /// undefined behavior.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `T` must *fit* that block of memory.\n-    unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n-    where\n-        Self: Sized,\n-    {\n-        let k = Layout::new::<T>();\n-        if k.size() > 0 {\n-            self.dealloc(ptr.cast(), k);\n-        }\n-    }\n-\n-    /// Allocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n-    /// must be considered \"currently allocated\" and must be\n-    /// acceptable input to methods such as `realloc` or `dealloc`,\n-    /// *even if* `T` is a zero-sized type. In other words, if your\n-    /// `Alloc` implementation overrides this method in a manner\n-    /// that can return a zero-sized `ptr`, then all reallocation and\n-    /// deallocation methods need to be similarly overridden to accept\n-    /// such values as input.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(layout) if layout.size() > 0 => unsafe { self.alloc(layout).map(|p| p.cast()) },\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Reallocates a block previously suitable for holding `n_old`\n-    /// instances of `T`, returning a block suitable for holding\n-    /// `n_new` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// The returned block is suitable for passing to the\n-    /// `realloc`/`dealloc` methods of this allocator.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `[T; n_new]` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n-    /// `Err`, but will *not* yield undefined behavior.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_array<T>(\n-        &mut self,\n-        ptr: NonNull<T>,\n-        n_old: usize,\n-        n_new: usize,\n-    ) -> Result<NonNull<T>, AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n-            (Ok(k_old), Ok(k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n-                debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.cast(), k_old, k_new.size()).map(NonNull::cast)\n-            }\n-            _ => Err(AllocErr),\n-        }\n-    }\n-\n-    /// Deallocates a block suitable for holding `n` instances of `T`.\n-    ///\n-    /// Captures a common usage pattern for allocators.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure both:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via this allocator\n-    ///\n-    /// * the layout of `[T; n]` must *fit* that block of memory.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either `[T; n]` or the given\n-    /// memory block does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Always returns `Err` on arithmetic overflow.\n-    unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n-    where\n-        Self: Sized,\n-    {\n-        match Layout::array::<T>(n) {\n-            Ok(k) if k.size() > 0 => Ok(self.dealloc(ptr.cast(), k)),\n-            _ => Err(AllocErr),\n-        }\n-    }\n }"}, {"sha": "97ef513cbcc63d14ad7bbca205f04f38f20a3213", "filename": "src/libcore/any.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -194,7 +194,9 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         if self.is::<T>() {\n-            // SAFETY: just checked whether we are pointing to the correct type\n+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n+            // that check for memory safety because we have implemented Any for all types; no other\n+            // impls can exist as they would conflict with our impl.\n             unsafe { Some(&*(self as *const dyn Any as *const T)) }\n         } else {\n             None\n@@ -228,7 +230,9 @@ impl dyn Any {\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n         if self.is::<T>() {\n-            // SAFETY: just checked whether we are pointing to the correct type\n+            // SAFETY: just checked whether we are pointing to the correct type, and we can rely on\n+            // that check for memory safety because we have implemented Any for all types; no other\n+            // impls can exist as they would conflict with our impl.\n             unsafe { Some(&mut *(self as *mut dyn Any as *mut T)) }\n         } else {\n             None\n@@ -476,11 +480,15 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n ///\n /// This is intended for diagnostic use. The exact contents and format of the\n /// string are not specified, other than being a best-effort description of the\n-/// type. For example, `type_name_of::<Option<String>>(None)` could return\n+/// type. For example, `type_name_of_val::<Option<String>>(None)` could return\n /// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n /// `\"foobar\"`. In addition, the output may change between versions of the\n /// compiler.\n ///\n+/// This function does not resolve trait objects,\n+/// meaning that `type_name_of_val(&7u32 as &dyn Debug)`\n+/// may return `\"dyn Debug\"`, but not `\"u32\"`.\n+///\n /// The type name should not be considered a unique identifier of a type;\n /// multiple types may share the same type name.\n ///"}, {"sha": "8b8bda2e6b44fb9c08a9326a5b38da713a5f319c", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -187,8 +187,6 @@\n //! ```\n //!\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;\n@@ -368,6 +366,10 @@ impl<T> Cell<T> {\n         if ptr::eq(self, other) {\n             return;\n         }\n+        // SAFETY: This can be risky if called from separate threads, but `Cell`\n+        // is `!Sync` so this won't happen. This also won't invalidate any\n+        // pointers since `Cell` makes sure nothing else will be pointing into\n+        // either of these `Cell`s.\n         unsafe {\n             ptr::swap(self.value.get(), other.value.get());\n         }\n@@ -387,6 +389,8 @@ impl<T> Cell<T> {\n     /// ```\n     #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n     pub fn replace(&self, val: T) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         mem::replace(unsafe { &mut *self.value.get() }, val)\n     }\n \n@@ -423,6 +427,8 @@ impl<T: Copy> Cell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         unsafe { *self.value.get() }\n     }\n \n@@ -491,6 +497,9 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen, and `&mut` guarantees\n+        // unique access.\n         unsafe { &mut *self.value.get() }\n     }\n \n@@ -510,6 +519,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn from_mut(t: &mut T) -> &Cell<T> {\n+        // SAFETY: `&mut` ensures unique access.\n         unsafe { &*(t as *mut T as *const Cell<T>) }\n     }\n }\n@@ -553,6 +563,7 @@ impl<T> Cell<[T]> {\n     /// ```\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn as_slice_of_cells(&self) -> &[Cell<T>] {\n+        // SAFETY: `Cell<T>` has the same memory layout as `T`.\n         unsafe { &*(self as *const Cell<[T]> as *const [Cell<T>]) }\n     }\n }\n@@ -816,6 +827,8 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` ensures that there is only immutable access\n+            // to the value while borrowed.\n             Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n             None => Err(BorrowError { _private: () }),\n         }\n@@ -891,6 +904,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` guarantees unique access.\n             Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n             None => Err(BorrowMutError { _private: () }),\n         }\n@@ -940,6 +954,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: `&mut` guarantees unique access.\n         unsafe { &mut *self.value.get() }\n     }\n \n@@ -1460,6 +1475,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n+#[cfg_attr(not(bootstrap), repr(no_niche))] // rust-lang/rust#68303.\n pub struct UnsafeCell<T: ?Sized> {\n     value: T,\n }"}, {"sha": "302400744e25df541fbda73dcfbdb17dc240997f", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 68, "deletions": 28, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,7 +3,7 @@\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;\n-use crate::unicode::tables::{conversions, derived_property, general_category, property};\n+use crate::unicode::{self, conversions};\n \n use super::*;\n \n@@ -552,7 +552,7 @@ impl char {\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n             'a'..='z' | 'A'..='Z' => true,\n-            c => c > '\\x7f' && derived_property::Alphabetic(c),\n+            c => c > '\\x7f' && unicode::Alphabetic(c),\n         }\n     }\n \n@@ -583,7 +583,7 @@ impl char {\n     pub fn is_lowercase(self) -> bool {\n         match self {\n             'a'..='z' => true,\n-            c => c > '\\x7f' && derived_property::Lowercase(c),\n+            c => c > '\\x7f' && unicode::Lowercase(c),\n         }\n     }\n \n@@ -614,7 +614,7 @@ impl char {\n     pub fn is_uppercase(self) -> bool {\n         match self {\n             'A'..='Z' => true,\n-            c => c > '\\x7f' && derived_property::Uppercase(c),\n+            c => c > '\\x7f' && unicode::Uppercase(c),\n         }\n     }\n \n@@ -642,7 +642,7 @@ impl char {\n     pub fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09'..='\\x0d' => true,\n-            c => c > '\\x7f' && property::White_Space(c),\n+            c => c > '\\x7f' && unicode::White_Space(c),\n         }\n     }\n \n@@ -693,7 +693,7 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_control(self) -> bool {\n-        general_category::Cc(self)\n+        unicode::Cc(self)\n     }\n \n     /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n@@ -707,7 +707,7 @@ impl char {\n     /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n-        derived_property::Grapheme_Extend(self)\n+        unicode::Grapheme_Extend(self)\n     }\n \n     /// Returns `true` if this `char` has one of the general categories for numbers.\n@@ -739,7 +739,7 @@ impl char {\n     pub fn is_numeric(self) -> bool {\n         match self {\n             '0'..='9' => true,\n-            c => c > '\\x7f' && general_category::N(c),\n+            c => c > '\\x7f' && unicode::N(c),\n         }\n     }\n \n@@ -1072,9 +1072,13 @@ impl char {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n+        match *self {\n+            'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII uppercase character:\n@@ -1104,9 +1108,13 @@ impl char {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_uppercase()\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n+        match *self {\n+            'A'..='Z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII lowercase character:\n@@ -1136,9 +1144,13 @@ impl char {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_lowercase()\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n+        match *self {\n+            'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII alphanumeric character:\n@@ -1171,9 +1183,13 @@ impl char {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n+        match *self {\n+            '0'..='9' | 'A'..='Z' | 'a'..='z' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII decimal digit:\n@@ -1203,9 +1219,13 @@ impl char {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_digit()\n+    pub const fn is_ascii_digit(&self) -> bool {\n+        match *self {\n+            '0'..='9' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII hexadecimal digit:\n@@ -1238,9 +1258,13 @@ impl char {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n+        match *self {\n+            '0'..='9' | 'A'..='F' | 'a'..='f' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII punctuation character:\n@@ -1274,9 +1298,13 @@ impl char {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_punctuation()\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n+        match *self {\n+            '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII graphic character:\n@@ -1306,9 +1334,13 @@ impl char {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_graphic()\n+    pub const fn is_ascii_graphic(&self) -> bool {\n+        match *self {\n+            '!'..='~' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII whitespace character:\n@@ -1355,9 +1387,13 @@ impl char {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_whitespace()\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n+        match *self {\n+            '\\t' | '\\n' | '\\x0C' | '\\r' | ' ' => true,\n+            _ => false,\n+        }\n     }\n \n     /// Checks if the value is an ASCII control character:\n@@ -1389,8 +1425,12 @@ impl char {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.is_ascii() && (*self as u8).is_ascii_control()\n+    pub const fn is_ascii_control(&self) -> bool {\n+        match *self {\n+            '\\0'..='\\x1F' | '\\x7F' => true,\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "cf5576e549cdfa043ad0b9ea24b238178f19272d", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -37,9 +37,9 @@ pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n // unstable re-exports\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-pub use crate::unicode::tables::UNICODE_VERSION;\n-#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub use crate::unicode::version::UnicodeVersion;\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub use crate::unicode::UNICODE_VERSION;\n \n use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;"}, {"sha": "604be7d5f68d0f78f8617ee809c1149b468d517d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -35,7 +35,7 @@ use self::Ordering::*;\n ///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n+/// so floating point types implement `PartialEq` but not [`Eq`].\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n@@ -55,12 +55,12 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n+/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n+/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n /// each other. It's easy to accidentally make them disagree by deriving some\n /// of the traits and manually implementing others.\n ///\n@@ -190,6 +190,9 @@ use self::Ordering::*;\n /// assert_eq!(x == y, false);\n /// assert_eq!(x.eq(&y), false);\n /// ```\n+///\n+/// [`eq`]: PartialEq::eq\n+/// [`ne`]: PartialEq::ne\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"==\")]\n@@ -233,7 +236,7 @@ pub macro PartialEq($item:item) {\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n /// This property cannot be checked by the compiler, and therefore `Eq` implies\n-/// `PartialEq`, and has no extra methods.\n+/// [`PartialEq`], and has no extra methods.\n ///\n /// ## Derivable\n ///\n@@ -358,6 +361,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         match self {\n@@ -370,6 +374,7 @@ impl Ordering {\n     /// Chains two orderings.\n     ///\n     /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -394,6 +399,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then(self, other: Ordering) -> Ordering {\n         match self {\n@@ -431,6 +437,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n         match self {\n@@ -442,10 +449,12 @@ impl Ordering {\n \n /// A helper struct for reverse ordering.\n ///\n-/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n+/// This struct is a helper to be used with functions like [`Vec::sort_by_key`] and\n /// can be used to reverse order a part of a key.\n ///\n-/// Example usage:\n+/// [`Vec::sort_by_key`]: ../../std/vec/struct.Vec.html#method.sort_by_key\n+///\n+/// # Examples\n ///\n /// ```\n /// use std::cmp::Reverse;\n@@ -506,12 +515,12 @@ impl<T: Ord> Ord for Reverse<T> {\n ///\n /// ## How can I implement `Ord`?\n ///\n-/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n+/// `Ord` requires that the type also be [`PartialOrd`] and [`Eq`] (which requires [`PartialEq`]).\n ///\n-/// Then you must define an implementation for `cmp()`. You may find it useful to use\n-/// `cmp()` on your type's fields.\n+/// Then you must define an implementation for [`cmp`]. You may find it useful to use\n+/// [`cmp`] on your type's fields.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must*\n+/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n /// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n /// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n /// all `a` and `b`. It's easy to accidentally make them disagree by\n@@ -548,13 +557,15 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+///\n+/// [`cmp`]: Ord::cmp\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n-    /// This method returns an `Ordering` between `self` and `other`.\n+    /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n     /// `self <operator> other` if true.\n@@ -568,6 +579,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10.cmp(&5), Ordering::Greater);\n     /// assert_eq!(5.cmp(&5), Ordering::Equal);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n \n@@ -583,6 +595,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -602,6 +615,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -627,6 +641,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert!(0.clamp(-2, 1) == 0);\n     /// assert!(2.clamp(-2, 1) == 1);\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n@@ -689,20 +704,20 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\n /// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n-/// `PartialOrd` requires your type to be `PartialEq`.\n+/// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n /// easy to accidentally make them disagree by deriving some of the traits and manually\n /// implementing others.\n ///\n-/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n+/// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```\n /// use std::cmp::Ordering;\n@@ -733,7 +748,7 @@ impl PartialOrd for Ordering {\n /// }\n /// ```\n ///\n-/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n+/// You may also find it useful to use [`partial_cmp`] on your type's fields. Here\n /// is an example of `Person` types who have a floating-point `height` field that\n /// is the only field to be used for sorting:\n ///\n@@ -768,6 +783,9 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n+///\n+/// [`partial_cmp`]: PartialOrd::partial_cmp\n+/// [`cmp`]: Ord::cmp\n #[lang = \"partial_ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \">\")]\n@@ -893,7 +911,7 @@ pub macro PartialOrd($item:item) {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::min`.\n+/// Internally uses an alias to [`Ord::min`].\n ///\n /// # Examples\n ///\n@@ -904,6 +922,7 @@ pub macro PartialOrd($item:item) {\n /// assert_eq!(2, cmp::min(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n@@ -924,6 +943,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -947,6 +967,7 @@ pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n@@ -956,7 +977,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::max`.\n+/// Internally uses an alias to [`Ord::max`].\n ///\n /// # Examples\n ///\n@@ -967,6 +988,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n /// assert_eq!(2, cmp::max(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n@@ -987,6 +1009,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -1010,6 +1033,7 @@ pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))"}, {"sha": "63866a5d110e38cf31852f2b79edfff13752f08e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn field(&mut self, name: &str, value: &dyn fmt::Debug) -> &mut DebugStruct<'a, 'b> {\n+    pub fn field(&mut self, name: &str, value: &dyn fmt::Debug) -> &mut Self {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 if !self.has_fields {\n@@ -159,6 +159,62 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n         self\n     }\n \n+    /// Marks the struct as non-exhaustive, indicating to the reader that there are some other\n+    /// fields that are not shown in the debug representation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_non_exhaustive)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Bar {\n+    ///     bar: i32,\n+    ///     hidden: f32,\n+    /// }\n+    ///\n+    /// impl fmt::Debug for Bar {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_struct(\"Bar\")\n+    ///            .field(\"bar\", &self.bar)\n+    ///            .finish_non_exhaustive() // Show that some other field(s) exist.\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n+    ///     \"Bar { bar: 10, .. }\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_non_exhaustive\", issue = \"67364\")]\n+    pub fn finish_non_exhaustive(&mut self) -> fmt::Result {\n+        self.result = self.result.and_then(|_| {\n+            // Draw non-exhaustive dots (`..`), and open brace if necessary (no fields).\n+            if self.is_pretty() {\n+                if !self.has_fields {\n+                    self.fmt.write_str(\" {\\n\")?;\n+                }\n+                let mut slot = None;\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n+                writer.write_str(\"..\\n\")?;\n+            } else {\n+                if self.has_fields {\n+                    self.fmt.write_str(\", ..\")?;\n+                } else {\n+                    self.fmt.write_str(\" { ..\")?;\n+                }\n+            }\n+            if self.is_pretty() {\n+                self.fmt.write_str(\"}\")?\n+            } else {\n+                self.fmt.write_str(\" }\")?;\n+            }\n+            Ok(())\n+        });\n+        self.result\n+    }\n+\n     /// Finishes output and returns any error encountered.\n     ///\n     /// # Examples\n@@ -274,7 +330,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn field(&mut self, value: &dyn fmt::Debug) -> &mut DebugTuple<'a, 'b> {\n+    pub fn field(&mut self, value: &dyn fmt::Debug) -> &mut Self {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 if self.fields == 0 {\n@@ -436,7 +492,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut DebugSet<'a, 'b> {\n+    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut Self {\n         self.inner.entry(entry);\n         self\n     }\n@@ -465,7 +521,7 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>\n+    pub fn entries<D, I>(&mut self, entries: I) -> &mut Self\n     where\n         D: fmt::Debug,\n         I: IntoIterator<Item = D>,\n@@ -568,7 +624,7 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut DebugList<'a, 'b> {\n+    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut Self {\n         self.inner.entry(entry);\n         self\n     }\n@@ -597,7 +653,7 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>\n+    pub fn entries<D, I>(&mut self, entries: I) -> &mut Self\n     where\n         D: fmt::Debug,\n         I: IntoIterator<Item = D>,\n@@ -704,7 +760,7 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+    pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut Self {\n         self.key(key).value(value)\n     }\n \n@@ -722,7 +778,6 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(debug_map_key_value)]\n     /// use std::fmt;\n     ///\n     /// struct Foo(Vec<(String, i32)>);\n@@ -740,8 +795,8 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n     /// );\n     /// ```\n-    #[unstable(feature = \"debug_map_key_value\", reason = \"recently added\", issue = \"62482\")]\n-    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+    #[stable(feature = \"debug_map_key_value\", since = \"1.42.0\")]\n+    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut Self {\n         self.result = self.result.and_then(|_| {\n             assert!(\n                 !self.has_key,\n@@ -787,7 +842,6 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(debug_map_key_value)]\n     /// use std::fmt;\n     ///\n     /// struct Foo(Vec<(String, i32)>);\n@@ -805,8 +859,8 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n     /// );\n     /// ```\n-    #[unstable(feature = \"debug_map_key_value\", reason = \"recently added\", issue = \"62482\")]\n-    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+    #[stable(feature = \"debug_map_key_value\", since = \"1.42.0\")]\n+    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut Self {\n         self.result = self.result.and_then(|_| {\n             assert!(self.has_key, \"attempted to format a map value before its key\");\n \n@@ -852,7 +906,7 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>\n+    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut Self\n     where\n         K: fmt::Debug,\n         V: fmt::Debug,"}, {"sha": "973c2f2b91555d20df31bbd79af3e597f22e30a0", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 29, "deletions": 44, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -10,7 +10,6 @@ use crate::mem;\n use crate::num::flt2dec;\n use crate::ops::Deref;\n use crate::result;\n-use crate::slice;\n use crate::str;\n \n mod builders;\n@@ -234,8 +233,6 @@ pub struct Formatter<'a> {\n     precision: Option<usize>,\n \n     buf: &'a mut (dyn Write + 'a),\n-    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n-    args: &'a [ArgumentV1<'a>],\n }\n \n // NB. Argument is essentially an optimized partially applied formatting function,\n@@ -1043,8 +1040,6 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n         buf: output,\n         align: rt::v1::Alignment::Unknown,\n         fill: ' ',\n-        args: args.args,\n-        curarg: args.args.iter(),\n     };\n \n     let mut idx = 0;\n@@ -1063,7 +1058,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n             // a string piece.\n             for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n                 formatter.buf.write_str(*piece)?;\n-                formatter.run(arg)?;\n+                run(&mut formatter, arg, &args.args)?;\n                 idx += 1;\n             }\n         }\n@@ -1077,6 +1072,28 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     Ok(())\n }\n \n+fn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: &[ArgumentV1<'_>]) -> Result {\n+    fmt.fill = arg.format.fill;\n+    fmt.align = arg.format.align;\n+    fmt.flags = arg.format.flags;\n+    fmt.width = getcount(args, &arg.format.width);\n+    fmt.precision = getcount(args, &arg.format.precision);\n+\n+    // Extract the correct argument\n+    let value = args[arg.position];\n+\n+    // Then actually do some printing\n+    (value.formatter)(value.value, fmt)\n+}\n+\n+fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize> {\n+    match *cnt {\n+        rt::v1::Count::Is(n) => Some(n),\n+        rt::v1::Count::Implied => None,\n+        rt::v1::Count::Param(i) => args[i].as_usize(),\n+    }\n+}\n+\n /// Padding after the end of something. Returned by `Formatter::padding`.\n #[must_use = \"don't forget to write the post padding\"]\n struct PostPadding {\n@@ -1114,41 +1131,6 @@ impl<'a> Formatter<'a> {\n             align: self.align,\n             width: self.width,\n             precision: self.precision,\n-\n-            // These only exist in the struct for the `run` method,\n-            // which won\u2019t be used together with this method.\n-            curarg: self.curarg.clone(),\n-            args: self.args,\n-        }\n-    }\n-\n-    // First up is the collection of functions used to execute a format string\n-    // at runtime. This consumes all of the compile-time statics generated by\n-    // the format! syntax extension.\n-    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n-        // Fill in the format parameters into the formatter\n-        self.fill = arg.format.fill;\n-        self.align = arg.format.align;\n-        self.flags = arg.format.flags;\n-        self.width = self.getcount(&arg.format.width);\n-        self.precision = self.getcount(&arg.format.precision);\n-\n-        // Extract the correct argument\n-        let value = match arg.position {\n-            rt::v1::Position::Next => *self.curarg.next().unwrap(),\n-            rt::v1::Position::At(i) => self.args[i],\n-        };\n-\n-        // Then actually do some printing\n-        (value.formatter)(value.value, self)\n-    }\n-\n-    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n-        match *cnt {\n-            rt::v1::Count::Is(n) => Some(n),\n-            rt::v1::Count::Implied => None,\n-            rt::v1::Count::Param(i) => self.args[i].as_usize(),\n-            rt::v1::Count::NextParam => self.curarg.next()?.as_usize(),\n         }\n     }\n \n@@ -1244,12 +1226,15 @@ impl<'a> Formatter<'a> {\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n-                self.fill = '0';\n-                self.align = rt::v1::Alignment::Right;\n+                let old_fill = crate::mem::replace(&mut self.fill, '0');\n+                let old_align = crate::mem::replace(&mut self.align, rt::v1::Alignment::Right);\n                 write_prefix(self, sign, prefix)?;\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self.buf)?;\n+                self.fill = old_fill;\n+                self.align = old_align;\n+                Ok(())\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {"}, {"sha": "f6460470bfe18e5e3aec17b90cbf39b1351835ec", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -7,7 +7,7 @@\n \n #[derive(Copy, Clone)]\n pub struct Argument {\n-    pub position: Position,\n+    pub position: usize,\n     pub format: FormatSpec,\n }\n \n@@ -37,12 +37,5 @@ pub enum Alignment {\n pub enum Count {\n     Is(usize),\n     Param(usize),\n-    NextParam,\n     Implied,\n }\n-\n-#[derive(Copy, Clone)]\n-pub enum Position {\n-    Next,\n-    At(usize),\n-}"}, {"sha": "2cee23a5c752c9d3ef93193870a01b7992b730aa", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1305,9 +1305,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1321,14 +1323,17 @@ extern \"rust-intrinsic\" {\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n+    #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T>(x: T, y: T) -> T;\n \n     /// Performs rotate left."}, {"sha": "7d10ef3d282198d49a1078da50674b5869c1e887", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1752,6 +1752,95 @@ where\n     }\n }\n \n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: trait.Iterator.html#method.map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    finished: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, finished: false, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.finished).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        if self.finished {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            let ret = (self.predicate)(x);\n+            self.finished = ret.is_none();\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, B, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| match p(x) {\n+                Some(item) => LoopState::from_try(fold(acc, item)),\n+                None => {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }\n+        }\n+\n+        if self.finished {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.finished;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n where\n@@ -1815,8 +1904,14 @@ where\n     }\n \n     #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count().saturating_sub(self.n)\n+    fn count(mut self) -> usize {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return 0;\n+            }\n+        }\n+        self.iter.count()\n     }\n \n     #[inline]"}, {"sha": "5fa9962f811c532eb7a39ffd5fd2ed1d7ddc3421", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -327,7 +327,7 @@ pub use self::sources::{empty, Empty};\n pub use self::sources::{from_fn, FromFn};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub use self::sources::{once, Once};\n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n pub use self::sources::{once_with, OnceWith};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{repeat, Repeat};\n@@ -351,6 +351,8 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+pub use self::adapters::MapWhile;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "28fbd00f36b33558e8f05ccf06632f9d299cf8fb", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -341,16 +341,15 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.start.add_one();\n             mem::replace(&mut self.start, n)\n         } else {\n+            self.exhausted = true;\n             self.start.clone()\n         })\n     }\n@@ -369,8 +368,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -379,19 +377,20 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n+                    self.start = plus_n.clone();\n+                    self.exhausted = true;\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.is_empty = Some(true);\n+        self.start = self.end.clone();\n+        self.exhausted = true;\n         None\n     }\n \n@@ -402,8 +401,6 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -416,7 +413,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;\n@@ -445,24 +442,22 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.end.sub_one();\n             mem::replace(&mut self.end, n)\n         } else {\n+            self.exhausted = true;\n             self.end.clone()\n         })\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -471,19 +466,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.is_empty = Some(false);\n                     self.end = minus_n.sub_one();\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n+                    self.end = minus_n.clone();\n+                    self.exhausted = true;\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.is_empty = Some(true);\n+        self.end = self.start.clone();\n+        self.exhausted = true;\n         None\n     }\n \n@@ -494,8 +490,6 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -508,7 +502,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;"}, {"sha": "a1d4e1b31e9b15f6c9cc77a557f67932247e5063", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -208,6 +208,11 @@ pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub struct Empty<T>(marker::PhantomData<T>);\n \n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Send for Empty<T> {}\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Sync for Empty<T> {}\n+\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<T> fmt::Debug for Empty<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -393,13 +398,13 @@ pub fn once<T>(value: T) -> Once<T> {\n /// See its documentation for more.\n ///\n /// [`once_with`]: fn.once_with.html\n-#[derive(Copy, Clone, Debug)]\n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n pub struct OnceWith<F> {\n     gen: Option<F>,\n }\n \n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n     type Item = A;\n \n@@ -415,24 +420,24 @@ impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n     }\n }\n \n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n     fn next_back(&mut self) -> Option<A> {\n         self.next()\n     }\n }\n \n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n     fn len(&self) -> usize {\n         self.gen.iter().len()\n     }\n }\n \n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n \n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n \n /// Creates an iterator that lazily generates a value exactly once by invoking\n@@ -453,8 +458,6 @@ unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n /// Basic usage:\n ///\n /// ```\n-/// #![feature(iter_once_with)]\n-///\n /// use std::iter;\n ///\n /// // one is the loneliest number\n@@ -471,8 +474,6 @@ unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n /// `.foorc`:\n ///\n /// ```no_run\n-/// #![feature(iter_once_with)]\n-///\n /// use std::iter;\n /// use std::fs;\n /// use std::path::PathBuf;\n@@ -495,7 +496,7 @@ unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n /// }\n /// ```\n #[inline]\n-#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n     OnceWith { gen: Some(gen) }\n }"}, {"sha": "1d055676c7708a75db07fd4d25c018bc33cc3712", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,6 @@\n // ignore-tidy-filelength\n+// This file almost exclusively consists of the definition of `Iterator`. We\n+// can't split that into multiple files.\n \n use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n@@ -7,7 +9,9 @@ use super::super::LoopState;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Product, Sum, Zip};\n-use super::super::{Inspect, Map, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile};\n+use super::super::{\n+    Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n+};\n \n fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n \n@@ -1026,6 +1030,102 @@ pub trait Iterator {\n         TakeWhile::new(self, predicate)\n     }\n \n+    /// Creates an iterator that both yields elements based on a predicate and maps.\n+    ///\n+    /// `map_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns [`Some(_)`][`Some`].\n+    ///\n+    /// After [`None`] is returned, `map_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`take_while`] and [`map`]:\n+    ///\n+    /// [`take_while`]: #method.take_while\n+    /// [`map`]: #method.map\n+    ///\n+    /// ```\n+    /// let a = [-1i32, 4, 0, 1];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|x| 16i32.checked_div(*x))\n+    ///                 .take_while(|x| x.is_some())\n+    ///                 .map(|x| x.unwrap());\n+    ///\n+    /// assert_eq!(iter.next(), Some(-16));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial [`None`]:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [0, -1, 1, -2];\n+    ///\n+    /// let mut iter = a.iter().map_while(|x| u32::try_from(*x).ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(0u32));\n+    ///\n+    /// // We have more elements that are fit in u32, but since we already\n+    /// // got a None, map_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because `map_while()` needs to look at the value in order to see if it\n+    /// should be included or not, consuming iterators will see that it is\n+    /// removed:\n+    ///\n+    /// ```\n+    /// #![feature(iter_map_while)]\n+    /// use std::convert::TryFrom;\n+    ///\n+    /// let a = [1, 2, -3, 4];\n+    /// let mut iter = a.iter();\n+    ///\n+    /// let result: Vec<u32> = iter.by_ref()\n+    ///                            .map_while(|n| u32::try_from(*n).ok())\n+    ///                            .collect();\n+    ///\n+    /// assert_eq!(result, &[1, 2]);\n+    ///\n+    /// let result: Vec<i32> = iter.cloned().collect();\n+    ///\n+    /// assert_eq!(result, &[4]);\n+    /// ```\n+    ///\n+    /// The `-3` is no longer there, because it was consumed in order to see if\n+    /// the iteration should stop, but wasn't placed back into the iterator.\n+    ///\n+    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    #[inline]\n+    #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+    fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>\n+    where\n+        Self: Sized,\n+        P: FnMut(Self::Item) -> Option<B>,\n+    {\n+        MapWhile::new(self, predicate)\n+    }\n+\n     /// Creates an iterator that skips the first `n` elements.\n     ///\n     /// After they have been consumed, the rest of the elements are yielded."}, {"sha": "12647fae9004e34c7936b72a2c6f6d6102097f99", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -44,7 +44,7 @@\n // Here we explicitly #[cfg]-out this whole crate when testing. If we don't do\n // this, both the generated test artifact and the linked libtest (which\n // transitively includes libcore) will both define the same set of lang items,\n-// and this will cause the E0152 \"duplicate lang item found\" error. See\n+// and this will cause the E0152 \"found duplicate lang item\" error. See\n // discussion in #50466 for details.\n //\n // This cfg won't affect doc tests.\n@@ -70,8 +70,14 @@\n #![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n-#![feature(const_fn)]\n+#![feature(const_ascii_ctype_on_intrinsics)]\n+#![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n+#![feature(const_checked_int_methods)]\n+#![feature(const_euclidean_int_methods)]\n+#![feature(const_overflowing_int_methods)]\n+#![feature(const_saturating_int_methods)]\n+#![feature(const_int_unchecked_arith)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n@@ -87,7 +93,6 @@\n #![feature(intrinsics)]\n #![feature(try_find)]\n #![feature(is_sorted)]\n-#![feature(iter_once_with)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n@@ -133,7 +138,8 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n-#![feature(slice_patterns)]\n+#![feature(assoc_int_consts)]\n+#![cfg_attr(not(bootstrap), feature(no_niche))] // rust-lang/rust#68303\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "2800f11cc01b1ae43600b4e82df2ceac154050e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -727,6 +727,10 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n+#[rustc_on_unimplemented(\n+    on(_Self = \"std::future::Future\", note = \"consider using `Box::pin`\",),\n+    message = \"`{Self}` cannot be unpinned\"\n+)]\n #[lang = \"unpin\"]\n pub auto trait Unpin {}\n "}, {"sha": "4c3b81ea5eca5506d1dc9413f9fb6811fb46b9e2", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -87,27 +87,28 @@ impl<T> ManuallyDrop<T> {\n         slot.value\n     }\n \n-    /// Takes the contained value out.\n+    /// Takes the value from the `ManuallyDrop<T>` container out.\n     ///\n     /// This method is primarily intended for moving out values in drop.\n     /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n     /// you can use this method to take the value and use it however desired.\n-    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n     ///\n-    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n+    /// Whenever possible, it is preferrable to use [`into_inner`][`ManuallyDrop::into_inner`]\n+    /// instead, which prevents duplicating the content of the `ManuallyDrop<T>`.\n     ///\n     /// # Safety\n     ///\n-    /// This function semantically moves out the contained value without preventing further usage.\n-    /// It is up to the user of this method to ensure that this container is not used again.\n+    /// This function semantically moves out the contained value without preventing further usage,\n+    /// leaving the state of this container unchanged.\n+    /// It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n     ///\n     /// [`ManuallyDrop::drop`]: #method.drop\n     /// [`ManuallyDrop::into_inner`]: #method.into_inner\n     #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n-    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n+    #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n     pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ManuallyDrop::into_inner(ptr::read(slot))\n+        ptr::read(&slot.value)\n     }\n }\n "}, {"sha": "0ab15b23e5337214cc6d295ef68ac1435d33c041", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -129,15 +129,15 @@ macro_rules! other_constants {\n     ($type: ident) => {\n         const EXPLICIT_SIG_BITS: u8 = Self::SIG_BITS - 1;\n         const MAX_EXP: i16 = (1 << (Self::EXP_BITS - 1)) - 1;\n-        const MIN_EXP: i16 = -Self::MAX_EXP + 1;\n-        const MAX_EXP_INT: i16 = Self::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n+        const MIN_EXP: i16 = -<Self as RawFloat>::MAX_EXP + 1;\n+        const MAX_EXP_INT: i16 = <Self as RawFloat>::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n         const MAX_ENCODED_EXP: i16 = (1 << Self::EXP_BITS) - 1;\n-        const MIN_EXP_INT: i16 = Self::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n+        const MIN_EXP_INT: i16 = <Self as RawFloat>::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n         const MAX_SIG: u64 = (1 << Self::SIG_BITS) - 1;\n         const MIN_SIG: u64 = 1 << (Self::SIG_BITS - 1);\n \n-        const INFINITY: Self = $crate::$type::INFINITY;\n-        const NAN: Self = $crate::$type::NAN;\n+        const INFINITY: Self = $type::INFINITY;\n+        const NAN: Self = $type::NAN;\n         const ZERO: Self = 0.0;\n     };\n }"}, {"sha": "da8dd9acd9f48d013d81690ca05f3314fc3cd3a3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -15,56 +15,56 @@ use crate::num::FpCategory;\n \n /// The radix or base of the internal representation of `f32`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const RADIX: u32 = 2;\n+pub const RADIX: u32 = f32::RADIX;\n \n /// Number of significant digits in base 2.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MANTISSA_DIGITS: u32 = 24;\n+pub const MANTISSA_DIGITS: u32 = f32::MANTISSA_DIGITS;\n /// Approximate number of significant digits in base 10.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const DIGITS: u32 = 6;\n+pub const DIGITS: u32 = f32::DIGITS;\n \n /// [Machine epsilon] value for `f32`.\n ///\n /// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const EPSILON: f32 = 1.1920929e-7_f32;\n+pub const EPSILON: f32 = f32::EPSILON;\n \n /// Smallest finite `f32` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN: f32 = -3.40282347e+38_f32;\n+pub const MIN: f32 = f32::MIN;\n /// Smallest positive normal `f32` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n+pub const MIN_POSITIVE: f32 = f32::MIN_POSITIVE;\n /// Largest finite `f32` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: f32 = 3.40282347e+38_f32;\n+pub const MAX: f32 = f32::MAX;\n \n /// One greater than the minimum possible normal power of 2 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_EXP: i32 = -125;\n+pub const MIN_EXP: i32 = f32::MIN_EXP;\n /// Maximum possible power of 2 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX_EXP: i32 = 128;\n+pub const MAX_EXP: i32 = f32::MAX_EXP;\n \n /// Minimum possible normal power of 10 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_10_EXP: i32 = -37;\n+pub const MIN_10_EXP: i32 = f32::MIN_10_EXP;\n /// Maximum possible power of 10 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX_10_EXP: i32 = 38;\n+pub const MAX_10_EXP: i32 = f32::MAX_10_EXP;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n+pub const NAN: f32 = f32::NAN;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n+pub const INFINITY: f32 = f32::INFINITY;\n /// Negative infinity (\u2212\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n+pub const NEG_INFINITY: f32 = f32::NEG_INFINITY;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -153,6 +153,60 @@ pub mod consts {\n #[lang = \"f32\"]\n #[cfg(not(test))]\n impl f32 {\n+    /// The radix or base of the internal representation of `f32`.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const RADIX: u32 = 2;\n+\n+    /// Number of significant digits in base 2.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MANTISSA_DIGITS: u32 = 24;\n+\n+    /// Approximate number of significant digits in base 10.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const DIGITS: u32 = 6;\n+\n+    /// [Machine epsilon] value for `f32`.\n+    ///\n+    /// This is the difference between `1.0` and the next larger representable number.\n+    ///\n+    /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const EPSILON: f32 = 1.19209290e-07_f32;\n+\n+    /// Smallest finite `f32` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN: f32 = -3.40282347e+38_f32;\n+    /// Smallest positive normal `f32` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n+    /// Largest finite `f32` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX: f32 = 3.40282347e+38_f32;\n+\n+    /// One greater than the minimum possible normal power of 2 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_EXP: i32 = -125;\n+    /// Maximum possible power of 2 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX_EXP: i32 = 128;\n+\n+    /// Minimum possible normal power of 10 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_10_EXP: i32 = -37;\n+    /// Maximum possible power of 10 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX_10_EXP: i32 = 38;\n+\n+    /// Not a Number (NaN).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n+    /// Infinity (\u221e).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n+    /// Negative infinity (-\u221e).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n+\n     /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```"}, {"sha": "a6081f184ab22f5b4c4c0291c049081e94dbc2bd", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -15,56 +15,56 @@ use crate::num::FpCategory;\n \n /// The radix or base of the internal representation of `f64`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const RADIX: u32 = 2;\n+pub const RADIX: u32 = f64::RADIX;\n \n /// Number of significant digits in base 2.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MANTISSA_DIGITS: u32 = 53;\n+pub const MANTISSA_DIGITS: u32 = f64::MANTISSA_DIGITS;\n /// Approximate number of significant digits in base 10.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const DIGITS: u32 = 15;\n+pub const DIGITS: u32 = f64::DIGITS;\n \n /// [Machine epsilon] value for `f64`.\n ///\n /// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n+pub const EPSILON: f64 = f64::EPSILON;\n \n /// Smallest finite `f64` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN: f64 = -1.7976931348623157e+308_f64;\n+pub const MIN: f64 = f64::MIN;\n /// Smallest positive normal `f64` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n+pub const MIN_POSITIVE: f64 = f64::MIN_POSITIVE;\n /// Largest finite `f64` value.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: f64 = 1.7976931348623157e+308_f64;\n+pub const MAX: f64 = f64::MAX;\n \n /// One greater than the minimum possible normal power of 2 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_EXP: i32 = -1021;\n+pub const MIN_EXP: i32 = f64::MIN_EXP;\n /// Maximum possible power of 2 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX_EXP: i32 = 1024;\n+pub const MAX_EXP: i32 = f64::MAX_EXP;\n \n /// Minimum possible normal power of 10 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN_10_EXP: i32 = -307;\n+pub const MIN_10_EXP: i32 = f64::MIN_10_EXP;\n /// Maximum possible power of 10 exponent.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX_10_EXP: i32 = 308;\n+pub const MAX_10_EXP: i32 = f64::MAX_10_EXP;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n+pub const NAN: f64 = f64::NAN;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n+pub const INFINITY: f64 = f64::INFINITY;\n /// Negative infinity (\u2212\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n+pub const NEG_INFINITY: f64 = f64::NEG_INFINITY;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -153,6 +153,59 @@ pub mod consts {\n #[lang = \"f64\"]\n #[cfg(not(test))]\n impl f64 {\n+    /// The radix or base of the internal representation of `f64`.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const RADIX: u32 = 2;\n+\n+    /// Number of significant digits in base 2.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MANTISSA_DIGITS: u32 = 53;\n+    /// Approximate number of significant digits in base 10.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const DIGITS: u32 = 15;\n+\n+    /// [Machine epsilon] value for `f64`.\n+    ///\n+    /// This is the difference between `1.0` and the next larger representable number.\n+    ///\n+    /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n+\n+    /// Smallest finite `f64` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN: f64 = -1.7976931348623157e+308_f64;\n+    /// Smallest positive normal `f64` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n+    /// Largest finite `f64` value.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX: f64 = 1.7976931348623157e+308_f64;\n+\n+    /// One greater than the minimum possible normal power of 2 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_EXP: i32 = -1021;\n+    /// Maximum possible power of 2 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX_EXP: i32 = 1024;\n+\n+    /// Minimum possible normal power of 10 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MIN_10_EXP: i32 = -307;\n+    /// Maximum possible power of 10 exponent.\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const MAX_10_EXP: i32 = 308;\n+\n+    /// Not a Number (NaN).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n+    /// Infinity (\u221e).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n+    /// Negative infinity (-\u221e).\n+    #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+    pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n+\n     /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```"}, {"sha": "471ab966622495ca55e395999330e813f7aa38f8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 260, "deletions": 85, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -69,8 +69,9 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n                 /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n+                #[rustc_const_unstable(feature = \"const_nonzero_int_methods\", issue = \"53718\")]\n                 #[inline]\n-                pub fn new(n: $Int) -> Option<Self> {\n+                pub const fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n                         // SAFETY: we just checked that there's no `0`\n                         Some(unsafe { Self(n) })\n@@ -91,8 +92,12 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n             impl From<$Ty> for $Int {\n-                fn from(nonzero: $Ty) -> Self {\n-                    nonzero.0\n+                doc_comment! {\n+                    concat!(\n+\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\"),\n+                    fn from(nonzero: $Ty) -> Self {\n+                        nonzero.0\n+                    }\n                 }\n             }\n \n@@ -245,42 +250,56 @@ macro_rules! int_impl {\n      $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n      $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n         doc_comment! {\n-            concat!(\"Returns the smallest value that can be represented by this integer type.\n+            concat!(\"The smallest value that can be represented by this integer type.\n \n # Examples\n \n Basic usage:\n \n ```\n-\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\",\n+#![feature(assoc_int_consts)]\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\",\n $EndFeature, \"\n ```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[inline(always)]\n-            #[rustc_promotable]\n-            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n-            pub const fn min_value() -> Self {\n-                !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n-            }\n+            #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+            pub const MIN: Self = !0 ^ ((!0 as $UnsignedT) >> 1) as Self;\n         }\n \n         doc_comment! {\n-            concat!(\"Returns the largest value that can be represented by this integer type.\n+            concat!(\"The largest value that can be represented by this integer type.\n \n # Examples\n \n Basic usage:\n \n ```\n-\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($Max), \");\",\n+#![feature(assoc_int_consts)]\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\",\n $EndFeature, \"\n ```\"),\n+            #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+            pub const MAX: Self = !Self::MIN;\n+        }\n+\n+        doc_comment! {\n+            \"Returns the smallest value that can be represented by this integer type.\",\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline(always)]\n+            #[rustc_promotable]\n+            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n+            pub const fn min_value() -> Self {\n+                Self::MIN\n+            }\n+        }\n+\n+        doc_comment! {\n+            \"Returns the largest value that can be represented by this integer type.\",\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline(always)]\n             #[rustc_promotable]\n             #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n             pub const fn max_value() -> Self {\n-                !Self::min_value()\n+                Self::MAX\n             }\n         }\n \n@@ -393,6 +412,48 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(leading_trailing_ones)]\n+let n = -1\", stringify!($SelfT), \";\n+\n+assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n+            #[inline]\n+            pub const fn leading_ones(self) -> u32 {\n+                (self as $UnsignedT).leading_ones()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(leading_trailing_ones)]\n+let n = 3\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_ones(), 2);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n+            #[inline]\n+            pub const fn trailing_ones(self) -> u32 {\n+                (self as $UnsignedT).trailing_ones()\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n@@ -641,10 +702,11 @@ assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -665,10 +727,11 @@ assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -689,10 +752,11 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -714,10 +778,11 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -742,10 +807,11 @@ assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -771,10 +837,11 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -800,10 +867,11 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n@@ -827,8 +895,9 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_neg(self) -> Option<Self> {\n+            pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n                 if b {None} else {Some(a)}\n             }\n@@ -848,10 +917,11 @@ assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -871,10 +941,11 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -896,8 +967,9 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_abs(self) -> Option<Self> {\n+            pub const fn checked_abs(self) -> Option<Self> {\n                 if self.is_negative() {\n                     self.checked_neg()\n                 } else {\n@@ -1020,8 +1092,9 @@ $EndFeature, \"\n ```\"),\n \n             #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn saturating_neg(self) -> Self {\n+            pub const fn saturating_neg(self) -> Self {\n                 intrinsics::saturating_sub(0, self)\n             }\n         }\n@@ -1046,8 +1119,9 @@ $EndFeature, \"\n ```\"),\n \n             #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn saturating_abs(self) -> Self {\n+            pub const fn saturating_abs(self) -> Self {\n                 if self.is_negative() {\n                     self.saturating_neg()\n                 } else {\n@@ -1073,17 +1147,19 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($Self\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_mul(self, rhs: Self) -> Self {\n-                self.checked_mul(rhs).unwrap_or_else(|| {\n-                    if (self < 0) == (rhs < 0) {\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => if (self < 0) == (rhs < 0) {\n                         Self::max_value()\n                     } else {\n                         Self::min_value()\n                     }\n-                })\n+                }\n             }\n         }\n \n@@ -1209,10 +1285,11 @@ assert_eq!((-128i8).wrapping_div(-1), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n                 self.overflowing_div(rhs).0\n             }\n         }\n@@ -1238,10 +1315,11 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_div_euclid(rhs).0\n             }\n         }\n@@ -1268,10 +1346,11 @@ assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n                 self.overflowing_rem(rhs).0\n             }\n         }\n@@ -1296,10 +1375,11 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_rem_euclid(rhs).0\n             }\n         }\n@@ -1575,9 +1655,10 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n@@ -1609,9 +1690,10 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n@@ -1643,9 +1725,10 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n@@ -1676,10 +1759,11 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n@@ -1921,11 +2005,12 @@ assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euclid(self, rhs: Self) -> Self {\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n                 let q = self / rhs;\n                 if self % rhs < 0 {\n                     return if rhs > 0 { q - 1 } else { q + 1 }\n@@ -1960,11 +2045,12 @@ assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n                 let r = self % rhs;\n                 if r < 0 {\n                     if rhs < 0 {\n@@ -2342,38 +2428,52 @@ macro_rules! uint_impl {\n         $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n         $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n         doc_comment! {\n-            concat!(\"Returns the smallest value that can be represented by this integer type.\n+            concat!(\"The smallest value that can be represented by this integer type.\n \n # Examples\n \n Basic usage:\n \n ```\n-\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\", $EndFeature, \"\n+#![feature(assoc_int_consts)]\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\", $EndFeature, \"\n ```\"),\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_promotable]\n-            #[inline(always)]\n-            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n-            pub const fn min_value() -> Self { 0 }\n+            #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+            pub const MIN: Self = 0;\n         }\n \n         doc_comment! {\n-            concat!(\"Returns the largest value that can be represented by this integer type.\n+            concat!(\"The largest value that can be represented by this integer type.\n \n # Examples\n \n Basic usage:\n \n ```\n-\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \",\n-stringify!($MaxV), \");\", $EndFeature, \"\n+#![feature(assoc_int_consts)]\n+\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\",\n+$EndFeature, \"\n ```\"),\n+            #[unstable(feature = \"assoc_int_consts\", reason = \"recently added\", issue = \"68490\")]\n+            pub const MAX: Self = !0;\n+        }\n+\n+        doc_comment! {\n+            \"Returns the smallest value that can be represented by this integer type.\",\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_promotable]\n             #[inline(always)]\n             #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n-            pub const fn max_value() -> Self { !0 }\n+            pub const fn min_value() -> Self { Self::MIN }\n+        }\n+\n+        doc_comment! {\n+            \"Returns the largest value that can be represented by this integer type.\",\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_promotable]\n+            #[inline(always)]\n+            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n+            pub const fn max_value() -> Self { Self::MAX }\n         }\n \n         doc_comment! {\n@@ -2485,6 +2585,47 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(leading_trailing_ones)]\n+let n = !(\", stringify!($SelfT), \"::max_value() >> 2);\n+\n+assert_eq!(n.leading_ones(), 2);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n+            #[inline]\n+            pub const fn leading_ones(self) -> u32 {\n+                (!self).leading_zeros()\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Returns the number of trailing ones in the binary representation\n+of `self`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"#![feature(leading_trailing_ones)]\n+let n = 0b1010111\", stringify!($SelfT), \";\n+\n+assert_eq!(n.trailing_ones(), 3);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n+            #[inline]\n+            pub const fn trailing_ones(self) -> u32 {\n+                (!self).trailing_zeros()\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n@@ -2732,10 +2873,11 @@ Basic usage:\n assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2754,10 +2896,11 @@ Basic usage:\n assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2776,10 +2919,11 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2798,10 +2942,11 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n                     0 => None,\n                     // SAFETY: div by zero has been checked above and unsigned types have no other\n@@ -2824,10 +2969,11 @@ assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -2850,10 +2996,11 @@ Basic usage:\n assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -2877,10 +3024,11 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n+            pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n@@ -2904,8 +3052,9 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[inline]\n-            pub fn checked_neg(self) -> Option<Self> {\n+            pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n                 if b {None} else {Some(a)}\n             }\n@@ -2924,10 +3073,11 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -2946,10 +3096,11 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_checked_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n+            pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n                 if b {None} else {Some(a)}\n             }\n@@ -3055,11 +3206,15 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n \"::MAX);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_mul(self, rhs: Self) -> Self {\n-                self.checked_mul(rhs).unwrap_or(Self::max_value())\n+            pub const fn saturating_mul(self, rhs: Self) -> Self {\n+                match self.checked_mul(rhs) {\n+                    Some(x) => x,\n+                    None => Self::max_value(),\n+                }\n             }\n         }\n \n@@ -3174,10 +3329,11 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3200,10 +3356,11 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3224,10 +3381,11 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_wrapping_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3251,10 +3409,11 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3499,9 +3658,10 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3530,9 +3690,10 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3558,9 +3719,10 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[rustc_const_unstable(feature = \"const_overflowing_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3589,9 +3751,10 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n-            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n+            pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3782,11 +3945,12 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euclid(self, rhs: Self) -> Self {\n+            pub const fn div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3811,11 +3975,12 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n+            #[rustc_const_unstable(feature = \"const_euclidean_int_methods\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn rem_euclid(self, rhs: Self) -> Self {\n+            pub const fn rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -4284,8 +4449,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n+    pub const fn is_ascii_alphabetic(&self) -> bool {\n         matches!(*self, b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4316,8 +4482,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n+    pub const fn is_ascii_uppercase(&self) -> bool {\n         matches!(*self, b'A'..=b'Z')\n     }\n \n@@ -4348,8 +4515,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n+    pub const fn is_ascii_lowercase(&self) -> bool {\n         matches!(*self, b'a'..=b'z')\n     }\n \n@@ -4383,8 +4551,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n+    pub const fn is_ascii_alphanumeric(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'Z' | b'a'..=b'z')\n     }\n \n@@ -4415,8 +4584,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n+    pub const fn is_ascii_digit(&self) -> bool {\n         matches!(*self, b'0'..=b'9')\n     }\n \n@@ -4450,8 +4620,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n+    pub const fn is_ascii_hexdigit(&self) -> bool {\n         matches!(*self, b'0'..=b'9' | b'A'..=b'F' | b'a'..=b'f')\n     }\n \n@@ -4486,8 +4657,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n+    pub const fn is_ascii_punctuation(&self) -> bool {\n         matches!(*self, b'!'..=b'/' | b':'..=b'@' | b'['..=b'`' | b'{'..=b'~')\n     }\n \n@@ -4518,8 +4690,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n+    pub const fn is_ascii_graphic(&self) -> bool {\n         matches!(*self, b'!'..=b'~')\n     }\n \n@@ -4567,8 +4740,9 @@ impl u8 {\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n+    pub const fn is_ascii_whitespace(&self) -> bool {\n         matches!(*self, b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ')\n     }\n \n@@ -4601,8 +4775,9 @@ impl u8 {\n     /// assert!(esc.is_ascii_control());\n     /// ```\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n+    #[rustc_const_unstable(feature = \"const_ascii_ctype_on_intrinsics\", issue = \"68983\")]\n     #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n+    pub const fn is_ascii_control(&self) -> bool {\n         matches!(*self, b'\\0'..=b'\\x1F' | b'\\x7F')\n     }\n }"}, {"sha": "4e43561996c370ee7c151ef6f632925c7ac35d1a", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -50,11 +50,11 @@ pub enum GeneratorState<Y, R> {\n ///         return \"foo\"\n ///     };\n ///\n-///     match Pin::new(&mut generator).resume() {\n+///     match Pin::new(&mut generator).resume(()) {\n ///         GeneratorState::Yielded(1) => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n-///     match Pin::new(&mut generator).resume() {\n+///     match Pin::new(&mut generator).resume(()) {\n ///         GeneratorState::Complete(\"foo\") => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n@@ -67,7 +67,7 @@ pub enum GeneratorState<Y, R> {\n #[lang = \"generator\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]\n-pub trait Generator {\n+pub trait Generator<#[cfg(not(bootstrap))] R = ()> {\n     /// The type of value this generator yields.\n     ///\n     /// This associated type corresponds to the `yield` expression and the\n@@ -110,9 +110,13 @@ pub trait Generator {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>;\n+    fn resume(\n+        self: Pin<&mut Self>,\n+        #[cfg(not(bootstrap))] arg: R,\n+    ) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n     type Yield = G::Yield;\n@@ -123,6 +127,7 @@ impl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n     }\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n     type Yield = G::Yield;\n@@ -132,3 +137,25 @@ impl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n         G::resume(Pin::new(&mut *self))\n     }\n }\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<&mut G> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume((*self).as_mut(), arg)\n+    }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for &mut G {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume(Pin::new(&mut *self), arg)\n+    }\n+}"}, {"sha": "8ffad82b69d7c688816b15d7157586701f9ede7b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -340,41 +340,21 @@ pub struct RangeInclusive<Idx> {\n     // support that mode.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n-    pub(crate) is_empty: Option<bool>,\n-    // This field is:\n-    //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start <= end` assuming no overflow\n-    //  - `Some(true)` otherwise\n-    // The field cannot be a simple `bool` because the `..=` constructor can\n-    // accept non-PartialOrd types, also we want the constructor to be const.\n-}\n-\n-trait RangeInclusiveEquality: Sized {\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n-}\n-\n-impl<T> RangeInclusiveEquality for T {\n-    #[inline]\n-    default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty.unwrap_or_default()\n-    }\n-}\n \n-impl<T: PartialOrd> RangeInclusiveEquality for T {\n-    #[inline]\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty()\n-    }\n+    // This field is:\n+    //  - `false` upon construction\n+    //  - `false` when iteration has yielded an element and the iterator is not exhausted\n+    //  - `true` when iteration has been used to exhaust the iterator\n+    //\n+    // This is required to support PartialEq and Hash without a PartialOrd bound or specialization.\n+    pub(crate) exhausted: bool,\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start\n-            && self.end == other.end\n-            && RangeInclusiveEquality::canonicalized_is_empty(self)\n-                == RangeInclusiveEquality::canonicalized_is_empty(other)\n+        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n     }\n }\n \n@@ -386,7 +366,7 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        RangeInclusiveEquality::canonicalized_is_empty(self).hash(state);\n+        self.exhausted.hash(state);\n     }\n }\n \n@@ -405,7 +385,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[rustc_promotable]\n     #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self { start, end, exhausted: false }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -481,6 +461,9 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n         self.start.fmt(fmt)?;\n         write!(fmt, \"..=\")?;\n         self.end.fmt(fmt)?;\n+        if self.exhausted {\n+            write!(fmt, \" (exhausted)\")?;\n+        }\n         Ok(())\n     }\n }\n@@ -552,15 +535,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        self.is_empty.unwrap_or_else(|| !(self.start <= self.end))\n-    }\n-\n-    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n-    #[inline]\n-    pub(crate) fn compute_is_empty(&mut self) {\n-        if self.is_empty.is_none() {\n-            self.is_empty = Some(!(self.start <= self.end));\n-        }\n+        self.exhausted || !(self.start <= self.end)\n     }\n }\n "}, {"sha": "9b32442371c37a32c77577b8e66e2f6551972911", "filename": "src/libcore/option.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -151,6 +151,7 @@ use crate::{\n \n /// The `Option` type. See [the module level documentation](index.html) for more.\n #[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[rustc_diagnostic_item = \"option_type\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value\n@@ -316,7 +317,7 @@ impl<T> Option<T> {\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Unwraps an option, yielding the content of a [`Some`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -330,12 +331,12 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"value\");\n-    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n+    /// assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n     /// ```\n     ///\n     /// ```{.should_panic}\n     /// let x: Option<&str> = None;\n-    /// x.expect(\"the world is ending\"); // panics with `the world is ending`\n+    /// x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n     /// ```\n     #[inline]\n     #[track_caller]\n@@ -347,17 +348,22 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n-    /// In general, because this function may panic, its use is discouraged.\n+    /// Because this function may panic, its use is generally discouraged.\n     /// Instead, prefer to use pattern matching and handle the [`None`]\n-    /// case explicitly.\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n     /// Panics if the self value equals [`None`].\n     ///\n-    /// [`Some(v)`]: #variant.Some\n+    /// [`Some`]: #variant.Some\n     /// [`None`]: #variant.None\n     ///\n     /// # Examples\n@@ -381,12 +387,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or a default.\n+    /// Returns the contained [`Some`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n     /// which is lazily evaluated.\n     ///\n+    /// [`Some`]: #variant.Some\n     /// [`unwrap_or_else`]: #method.unwrap_or_else\n     ///\n     /// # Examples\n@@ -404,7 +411,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or computes it from a closure.\n+    /// Returns the contained [`Some`] value or computes it from a closure.\n     ///\n     /// # Examples\n     ///\n@@ -454,6 +461,12 @@ impl<T> Option<T> {\n     /// Applies a function to the contained value (if any),\n     /// or returns the provided default (if not).\n     ///\n+    /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`map_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n+    /// [`map_or_else`]: #method.map_or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -979,7 +992,7 @@ impl<T: Clone> Option<&mut T> {\n }\n \n impl<T: fmt::Debug> Option<T> {\n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1022,7 +1035,7 @@ impl<T: fmt::Debug> Option<T> {\n         }\n     }\n \n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1067,7 +1080,7 @@ impl<T: fmt::Debug> Option<T> {\n }\n \n impl<T: Default> Option<T> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Some`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Some`], returns the contained\n     /// value, otherwise if [`None`], returns the [default value] for that"}, {"sha": "676d2c784acee2143bf2b72efd441193fac2fffd", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -672,6 +672,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n     where\n+        U: ?Sized,\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -763,6 +764,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n     where\n+        U: ?Sized,\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);"}, {"sha": "0ee50966f968c70cbfb876cada69aa2cf26bd6aa", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -169,22 +169,12 @@ mod mut_ptr;\n /// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n /// manually.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n-#[inline(always)]\n-pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n-    real_drop_in_place(&mut *to_drop)\n-}\n-\n-// The real `drop_in_place` -- the one that gets called implicitly when variables go\n-// out of scope -- should have a safe reference and not a raw pointer as argument\n-// type.  When we drop a local variable, we access it with a pointer that behaves\n-// like a safe reference; transmuting that to a raw pointer does not mean we can\n-// actually access it with raw pointers.\n #[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n-unsafe fn real_drop_in_place<T: ?Sized>(to_drop: &mut T) {\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the\n     // real drop glue by the compiler.\n-    real_drop_in_place(to_drop)\n+    drop_in_place(to_drop)\n }\n \n /// Creates a null raw pointer.\n@@ -248,17 +238,16 @@ pub(crate) struct FatPtr<T> {\n /// # Examples\n ///\n /// ```rust\n-/// #![feature(slice_from_raw_parts)]\n /// use std::ptr;\n ///\n /// // create a slice pointer when starting out with a pointer to the first element\n-/// let mut x = [5, 6, 7];\n-/// let ptr = &mut x[0] as *mut _;\n-/// let slice = ptr::slice_from_raw_parts_mut(ptr, 3);\n+/// let x = [5, 6, 7];\n+/// let ptr = x.as_ptr();\n+/// let slice = ptr::slice_from_raw_parts(ptr, 3);\n /// assert_eq!(unsafe { &*slice }[2], 7);\n /// ```\n #[inline]\n-#[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n+#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust }\n@@ -275,7 +264,7 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n /// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n /// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n #[inline]\n-#[unstable(feature = \"slice_from_raw_parts\", reason = \"recently added\", issue = \"36925\")]\n+#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n     unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n@@ -1092,9 +1081,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::max_value()` instead, because we take the result `mod n` at the end\n                 // anyway.\n-                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)))\n-                    & (going_mod - 1);\n-                if going_mod > m {\n+                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n+                if going_mod >= m {\n                     return inverse & (m - 1);\n                 }\n                 going_mod = going_mod.wrapping_mul(going_mod);\n@@ -1126,26 +1114,33 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n     let gcd = 1usize << gcdpow;\n \n-    if p as usize & (gcd - 1) == 0 {\n+    if p as usize & (gcd.wrapping_sub(1)) == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n-        // $$ p + so \u2261 0 mod a $$\n+        // ` p + so = 0 mod a `\n         //\n-        // $p$ here is the pointer value, $s$ \u2013 stride of `T`, $o$ offset in `T`s, and $a$ \u2013 the\n+        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n         // requested alignment.\n         //\n-        // g = gcd(a, s)\n-        // o = (a - (p mod a))/g * ((s/g)\u207b\u00b9 mod a)\n+        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n+        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n+        //\n+        // ` p' + s'o = 0 mod a' `\n+        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n         //\n-        // The first term is \u201cthe relative alignment of p to a\u201d, the second term is \u201chow does\n-        // incrementing p by s bytes change the relative alignment of p\u201d. Division by `g` is\n-        // necessary to make this equation well formed if $a$ and $s$ are not co-prime.\n+        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second\n+        // term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again\n+        // divided by `g`).\n+        // Division by `g` is necessary to make the inverse well formed if `a` and `s` are not\n+        // co-prime.\n         //\n-        // Furthermore, the result produced by this solution is not \u201cminimal\u201d, so it is necessary\n-        // to take the result $o mod lcm(s, a)$. We can replace $lcm(s, a)$ with just a $a / g$.\n-        let j = a.wrapping_sub(pmoda) >> gcdpow;\n-        let k = smoda >> gcdpow;\n-        return intrinsics::unchecked_rem(j.wrapping_mul(mod_inv(k, a)), a >> gcdpow);\n+        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n+        // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n+        let a2 = a >> gcdpow;\n+        let a2minus1 = a2.wrapping_sub(1);\n+        let s2 = smoda >> gcdpow;\n+        let minusp2 = a2.wrapping_sub(pmoda >> gcdpow);\n+        return (minusp2.wrapping_mul(mod_inv(s2, a2))) & a2minus1;\n     }\n \n     // Cannot be aligned at all."}, {"sha": "4bc0a3e9faa607dd93efe45742f92a040a3a5ecb", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -250,6 +250,20 @@ impl<T: ?Sized> *mut T {\n     /// *first_value = 4;\n     /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n     /// ```\n+    ///\n+    /// # Null-unchecked version\n+    ///\n+    /// If you are sure the pointer can never be null and are looking for some kind of\n+    /// `as_mut_unchecked` that returns the `&mut T` instead of `Option<&mut T>`, know that\n+    /// you can dereference the pointer directly.\n+    ///\n+    /// ```\n+    /// let mut s = [1, 2, 3];\n+    /// let ptr: *mut u32 = s.as_mut_ptr();\n+    /// let first_value = unsafe { &mut *ptr };\n+    /// *first_value = 4;\n+    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n+    /// ```\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {"}, {"sha": "0bc29e1bc662cfb94dc28f43b808d2d933401be6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 105, "deletions": 77, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -242,6 +242,7 @@ use crate::ops::{self, Deref, DerefMut};\n /// [`Err`]: enum.Result.html#variant.Err\n #[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use = \"this `Result` may be an `Err` variant, which should be handled\"]\n+#[rustc_diagnostic_item = \"result_type\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {\n     /// Contains the success value\n@@ -523,6 +524,12 @@ impl<T, E> Result<T, E> {\n     /// Applies a function to the contained value (if any),\n     /// or returns the provided default (if not).\n     ///\n+    /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`map_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n+    /// [`map_or_else`]: #method.map_or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -791,8 +798,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// Else, it returns `optb`.\n+    /// Returns the contained [`Ok`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n@@ -807,27 +813,25 @@ impl<T, E> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let optb = 2;\n+    /// let default = 2;\n     /// let x: Result<u32, &str> = Ok(9);\n-    /// assert_eq!(x.unwrap_or(optb), 9);\n+    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n     /// let x: Result<u32, &str> = Err(\"error\");\n-    /// assert_eq!(x.unwrap_or(optb), optb);\n+    /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, optb: T) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => optb,\n+            Err(_) => default,\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// If the value is an [`Err`] then it calls `op` with its value.\n+    /// Returns the contained [`Ok`] value or computes it from a closure.\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -930,7 +934,44 @@ impl<T: Clone, E> Result<&mut T, E> {\n }\n \n impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```{.should_panic}\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// ```\n+    #[inline]\n+    #[track_caller]\n+    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n+    pub fn expect(self, msg: &str) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(msg, &e),\n+        }\n+    }\n+\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n@@ -962,13 +1003,15 @@ impl<T, E: fmt::Debug> Result<T, E> {\n             Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n         }\n     }\n+}\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+impl<T: fmt::Debug, E> Result<T, E> {\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an [`Err`], with a panic message including the\n-    /// passed message, and the content of the [`Err`].\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n     /// [`Err`]: enum.Result.html#variant.Err\n@@ -978,22 +1021,20 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n     #[track_caller]\n-    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n-    pub fn expect(self, msg: &str) -> T {\n+    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n+    pub fn expect_err(self, msg: &str) -> E {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => unwrap_failed(msg, &e),\n+            Ok(t) => unwrap_failed(msg, &t),\n+            Err(e) => e,\n         }\n     }\n-}\n \n-impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Err`].\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -1024,38 +1065,10 @@ impl<T: fmt::Debug, E> Result<T, E> {\n             Err(e) => e,\n         }\n     }\n-\n-    /// Unwraps a result, yielding the content of an [`Err`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Ok`], with a panic message including the\n-    /// passed message, and the content of the [`Ok`].\n-    ///\n-    /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Ok(10);\n-    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n-    /// ```\n-    #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n-    pub fn expect_err(self, msg: &str) -> E {\n-        match self {\n-            Ok(t) => unwrap_failed(msg, &t),\n-            Err(e) => e,\n-        }\n-    }\n }\n \n impl<T: Default, E> Result<T, E> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Ok`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Ok`], returns the contained\n     /// value, otherwise if [`Err`], returns the default value for that\n@@ -1092,13 +1105,51 @@ impl<T: Default, E> Result<T, E> {\n     }\n }\n \n+#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n+impl<T, E: Into<!>> Result<T, E> {\n+    /// Returns the contained [`Ok`] value, but never panics.\n+    ///\n+    /// Unlike [`unwrap`], this method is known to never panic on the\n+    /// result types it is implemented for. Therefore, it can be used\n+    /// instead of `unwrap` as a maintainability safeguard that will fail\n+    /// to compile if the error type of the `Result` is later changed\n+    /// to an error that can actually occur.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    /// [`unwrap`]: enum.Result.html#method.unwrap\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(never_type)]\n+    /// # #![feature(unwrap_infallible)]\n+    ///\n+    /// fn only_good_news() -> Result<String, !> {\n+    ///     Ok(\"this is fine\".into())\n+    /// }\n+    ///\n+    /// let s: String = only_good_news().into_ok();\n+    /// println!(\"{}\", s);\n+    /// ```\n+    #[inline]\n+    pub fn into_ok(self) -> T {\n+        match self {\n+            Ok(x) => x,\n+            Err(e) => e.into(),\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: Deref, E> Result<T, E> {\n     /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E>`.\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n     /// `Ok` type's `Deref::Target` type.\n-    pub fn as_deref_ok(&self) -> Result<&T::Target, &E> {\n+    pub fn as_deref(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n@@ -1114,24 +1165,13 @@ impl<T, E: Deref> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n-impl<T: Deref, E: Deref> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E::Target>`.\n-    ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to both\n-    /// the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref(&self) -> Result<&T::Target, &E::Target> {\n-        self.as_ref().map(|t| t.deref()).map_err(|e| e.deref())\n-    }\n-}\n-\n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: DerefMut, E> Result<T, E> {\n     /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T::Target, &mut E>`.\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n     /// the `Ok` type's `Deref::Target` type.\n-    pub fn as_deref_mut_ok(&mut self) -> Result<&mut T::Target, &mut E> {\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n }\n@@ -1147,18 +1187,6 @@ impl<T, E: DerefMut> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n-impl<T: DerefMut, E: DerefMut> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to\n-    /// `Result<&mut T::Target, &mut E::Target>`.\n-    ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// both the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E::Target> {\n-        self.as_mut().map(|t| t.deref_mut()).map_err(|e| e.deref_mut())\n-    }\n-}\n-\n impl<T, E> Result<Option<T>, E> {\n     /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n     ///"}, {"sha": "e79a775325f4ac09dd9e10ea56716b76778a5b16", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -5584,21 +5584,18 @@ where\n \n #[doc(hidden)]\n // intermediate trait for specialization of slice's PartialOrd\n-trait SlicePartialOrd<B> {\n-    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+trait SlicePartialOrd: Sized {\n+    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n-where\n-    A: PartialOrd,\n-{\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: PartialOrd> SlicePartialOrd for A {\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].partial_cmp(&rhs[i]) {\n@@ -5607,36 +5604,61 @@ where\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        left.len().partial_cmp(&right.len())\n     }\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n+// This is the impl that we would like to have. Unfortunately it's not sound.\n+// See `partial_ord_slice.rs`.\n+/*\n+impl<A> SlicePartialOrd for A\n where\n     A: Ord,\n {\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        Some(SliceOrd::compare(self, other))\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+*/\n+\n+impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n+    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+\n+trait AlwaysApplicableOrd: SliceOrd + Ord {}\n+\n+macro_rules! always_applicable_ord {\n+    ($([$($p:tt)*] $t:ty,)*) => {\n+        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n     }\n }\n \n+always_applicable_ord! {\n+    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n+    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n+    [] bool, [] char,\n+    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n+    [T: AlwaysApplicableOrd] &T,\n+    [T: AlwaysApplicableOrd] &mut T,\n+    [T: AlwaysApplicableOrd] Option<T>,\n+}\n+\n #[doc(hidden)]\n // intermediate trait for specialization of slice's Ord\n-trait SliceOrd<B> {\n-    fn compare(&self, other: &[B]) -> Ordering;\n+trait SliceOrd: Sized {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n }\n \n-impl<A> SliceOrd<A> for [A]\n-where\n-    A: Ord,\n-{\n-    default fn compare(&self, other: &[A]) -> Ordering {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: Ord> SliceOrd for A {\n+    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].cmp(&rhs[i]) {\n@@ -5645,19 +5667,19 @@ where\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        left.len().cmp(&right.len())\n     }\n }\n \n // memcmp compares a sequence of unsigned bytes lexicographically.\n // this matches the order we want for [u8], but no others (not even [i8]).\n-impl SliceOrd<u8> for [u8] {\n+impl SliceOrd for u8 {\n     #[inline]\n-    fn compare(&self, other: &[u8]) -> Ordering {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n-            unsafe { memcmp(self.as_ptr(), other.as_ptr(), cmp::min(self.len(), other.len())) };\n+            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n-            self.len().cmp(&other.len())\n+            left.len().cmp(&right.len())\n         } else if order < 0 {\n             Less\n         } else {"}, {"sha": "88b2bc551b7d1138e136ff4cf49d95ea63d3e804", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,8 +3,6 @@ use crate::fmt::{self, Write};\n use crate::mem;\n use crate::str as core_str;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n pub struct Utf8Lossy {\n@@ -17,6 +15,7 @@ impl Utf8Lossy {\n     }\n \n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required.\n         unsafe { mem::transmute(bytes) }\n     }\n \n@@ -60,6 +59,8 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         while i < self.source.len() {\n             let i_ = i;\n \n+            // SAFETY: `i` starts at `0`, is less than `self.source.len()`, and\n+            // only increases, so `0 <= i < self.source.len()`.\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n@@ -69,6 +70,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n                 macro_rules! error {\n                     () => {{\n+                        // SAFETY: We have checked up to `i` that source is valid UTF-8.\n                         unsafe {\n                             let r = Utf8LossyChunk {\n                                 valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n@@ -130,6 +132,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let r = Utf8LossyChunk {\n+            // SAFETY: We have checked that the entire source is valid UTF-8.\n             valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n             broken: &[],\n         };"}, {"sha": "734b3ba7c6bbaea9ad3bbce7f9c76f54d6a9d058", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!\n@@ -13,7 +12,7 @@ use self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n use crate::char;\n use crate::fmt::{self, Write};\n use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Cloned, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n use crate::mem;\n use crate::ops::Try;\n use crate::option;\n@@ -341,6 +340,7 @@ impl Utf8Error {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -379,6 +379,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked_mut(v) })\n }\n \n@@ -581,7 +582,7 @@ impl<'a> Iterator for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         next_code_point(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -628,7 +629,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -658,6 +659,7 @@ impl<'a> Chars<'a> {\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {\n+        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n         unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n     }\n }\n@@ -748,7 +750,7 @@ impl<'a> CharIndices<'a> {\n /// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n-pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n+pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for Bytes<'_> {\n@@ -1102,6 +1104,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             unsafe {\n                 let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n                 Some(string)\n@@ -1119,6 +1122,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(self.start..a);\n                 self.start = b;\n@@ -1151,11 +1155,13 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(b..self.end);\n                 self.end = a;\n                 Some(elt)\n             },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             None => unsafe {\n                 self.finished = true;\n                 Some(haystack.get_unchecked(self.start..self.end))\n@@ -1297,6 +1303,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     fn next(&mut self) -> Option<(usize, &'a str)> {\n         self.0\n             .next_match()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n \n@@ -1307,6 +1314,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     {\n         self.0\n             .next_match_back()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n }\n@@ -1348,6 +1356,7 @@ where\n impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1359,6 +1368,7 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     where\n         P::Searcher: ReverseSearcher<'a>,\n     {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match_back().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1579,6 +1589,10 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are\n+                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n+                    // always aligned with a `usize` so it's safe to dereference\n+                    // both `block` and `block.offset(1)`.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n@@ -1804,6 +1818,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1815,6 +1830,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1845,6 +1861,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n@@ -1873,6 +1890,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1881,6 +1899,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1903,8 +1922,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n@@ -1934,6 +1953,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1942,6 +1962,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1966,8 +1987,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n@@ -2238,7 +2259,6 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n-    // SAFETY: const sound because we transmute two types with the same layout\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n@@ -2247,6 +2267,7 @@ impl str {\n             str: &'a str,\n             slice: &'a [u8],\n         }\n+        // SAFETY: const sound because we transmute two types with the same layout\n         unsafe { Slices { str: self }.slice }\n     }\n \n@@ -2573,6 +2594,7 @@ impl str {\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe { (self.get_unchecked(0..mid), self.get_unchecked(mid..self.len())) }\n         } else {\n             slice_error_fail(self, 0, mid)\n@@ -2617,6 +2639,7 @@ impl str {\n         if self.is_char_boundary(mid) {\n             let len = self.len();\n             let ptr = self.as_mut_ptr();\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe {\n                 (\n                     from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n@@ -2755,7 +2778,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn bytes(&self) -> Bytes<'_> {\n-        Bytes(self.as_bytes().iter().cloned())\n+        Bytes(self.as_bytes().iter().copied())\n     }\n \n     /// Splits a string slice by whitespace.\n@@ -3805,10 +3828,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -3844,10 +3865,8 @@ impl str {\n         if let Some((a, _)) = matcher.next_reject() {\n             i = a;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..self.len())\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..self.len()) }\n     }\n \n     /// Returns a string slice with the prefix removed.\n@@ -3876,12 +3895,10 @@ impl str {\n             debug_assert_eq!(\n                 start, 0,\n                 \"The first search step from Searcher \\\n-                must include the first character\"\n+                 must include the first character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(len..))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(len..)) }\n         } else {\n             None\n         }\n@@ -3917,12 +3934,10 @@ impl str {\n                 end,\n                 self.len(),\n                 \"The first search step from ReverseSearcher \\\n-                must include the last character\"\n+                 must include the last character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(..start))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(..start)) }\n         } else {\n             None\n         }\n@@ -3970,10 +3985,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(0..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(0..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -4166,6 +4179,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_uppercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_uppercase()\n     }\n@@ -4191,6 +4205,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_lowercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n@@ -4357,6 +4372,7 @@ impl Default for &str {\n impl Default for &mut str {\n     /// Creates an empty mutable str\n     fn default() -> Self {\n+        // SAFETY: The empty string is valid UTF-8.\n         unsafe { from_utf8_unchecked_mut(&mut []) }\n     }\n }\n@@ -4412,6 +4428,7 @@ impl_fn_for_zst! {\n \n     #[derive(Clone)]\n     struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        // SAFETY: not safe\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }"}, {"sha": "ef64d8b0fdf8880883ee168c22a5e0164c72fea7", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,8 +3,6 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![unstable(\n     feature = \"pattern\",\n     reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -271,6 +269,14 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next(&mut self) -> SearchStep {\n         let old_finger = self.finger;\n+        // SAFETY: 1-4 guarantee safety of `get_unchecked`\n+        // 1. `self.finger` and `self.finger_back` are kept on unicode boundaries\n+        //    (this is invariant)\n+        // 2. `self.finger >= 0` since it starts at 0 and only increases\n+        // 3. `self.finger < self.finger_back` because otherwise the char `iter`\n+        //    would return `SearchStep::Done`\n+        // 4. `self.finger` comes before the end of the haystack because `self.finger_back`\n+        //    starts at the end and only decreases\n         let slice = unsafe { self.haystack.get_unchecked(old_finger..self.finger_back) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -293,6 +299,7 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n             // get the haystack after the last character found\n             let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memchr(last_byte, bytes) {\n                 // The new finger is the index of the byte we found,\n@@ -336,6 +343,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n         let old_finger = self.finger_back;\n+        // SAFETY: see the comment for next() above\n         let slice = unsafe { self.haystack.get_unchecked(self.finger..old_finger) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -363,6 +371,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                 return None;\n             };\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memrchr(last_byte, bytes) {\n                 // we searched a slice that was offset by self.finger,"}, {"sha": "9d449bb9915071e3453af165045684d205cbacc9", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -112,8 +112,6 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n@@ -350,6 +348,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut bool {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n@@ -400,6 +399,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe { atomic_load(self.v.get(), order) != 0 }\n     }\n \n@@ -432,6 +433,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe {\n             atomic_store(self.v.get(), val as u8, order);\n         }\n@@ -463,6 +466,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -558,6 +562,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -615,6 +620,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -661,6 +667,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -756,6 +763,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -797,6 +805,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -872,6 +881,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *self.p.get() }\n     }\n \n@@ -923,6 +933,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n@@ -957,6 +968,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n         }\n@@ -990,6 +1002,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n@@ -1074,6 +1087,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange(\n                 self.p.get() as *mut usize,\n@@ -1137,6 +1151,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange_weak(\n                 self.p.get() as *mut usize,\n@@ -1290,6 +1305,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n+                    // SAFETY: the mutable reference guarantees unique ownership.\n                     unsafe { &mut *self.v.get() }\n                 }\n             }\n@@ -1344,6 +1360,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 #[inline]\n                 #[$stable]\n                 pub fn load(&self, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_load(self.v.get(), order) }\n                 }\n             }\n@@ -1378,6 +1395,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_store(self.v.get(), val, order); }\n                 }\n             }\n@@ -1408,6 +1426,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n             }\n@@ -1510,6 +1529,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n                 }\n             }\n@@ -1562,6 +1582,7 @@ loop {\n                                              new: $int_type,\n                                              success: Ordering,\n                                              failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe {\n                         atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                     }\n@@ -1596,6 +1617,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n             }\n@@ -1628,6 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n             }\n@@ -1663,6 +1686,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n             }\n@@ -1699,6 +1723,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n                 #[$stable_nand]\n                 #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n             }\n@@ -1734,6 +1759,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n             }\n@@ -1769,6 +1795,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n@@ -1880,6 +1907,7 @@ assert!(max_foo == 42);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1932,6 +1960,7 @@ assert_eq!(min_foo, 12);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1960,7 +1989,9 @@ extern {\n }\n \n let mut atomic = \", stringify!($atomic_type), \"::new(1);\n-unsafe {\n+\",\n+// SAFETY: Safe as long as `my_atomic_op` is atomic.\n+\"unsafe {\n     my_atomic_op(atomic.as_mut_ptr());\n }\n # }\n@@ -2526,6 +2557,7 @@ pub fn fence(order: Ordering) {\n     // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n     // follow that discussion and implement a solution when one comes about!\n     #[cfg(not(target_arch = \"wasm32\"))]\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n@@ -2613,6 +2645,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_singlethreadfence_acq(),"}, {"sha": "129c121e8ceac0f5cd0974a9b15832a14445c5a2", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -89,6 +89,91 @@ mod debug_struct {\n         baz: 10/20,\n     },\n     hello: \\\"world\\\",\n+}\",\n+            format!(\"{:#?}\", Bar)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_only_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\").finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { .. }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+            \"Foo {\n+    ..\n+}\",\n+            format!(\"{:#?}\", Foo)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_multiple_and_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true, baz: 10/20, .. }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+            \"Foo {\n+    bar: true,\n+    baz: 10/20,\n+    ..\n+}\",\n+            format!(\"{:#?}\", Foo)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_nested_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Bar\")\n+                    .field(\"foo\", &Foo)\n+                    .field(\"hello\", &\"world\")\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\n+            \"Bar { foo: Foo { bar: true, baz: 10/20, .. }, hello: \\\"world\\\", .. }\",\n+            format!(\"{:?}\", Bar)\n+        );\n+        assert_eq!(\n+            \"Bar {\n+    foo: Foo {\n+        bar: true,\n+        baz: 10/20,\n+        ..\n+    },\n+    hello: \\\"world\\\",\n+    ..\n }\",\n             format!(\"{:#?}\", Bar)\n         );"}, {"sha": "7b281ce48e6aa4e102ea048daabaa53708b66080", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -28,3 +28,18 @@ fn test_estimated_capacity() {\n     assert_eq!(format_args!(\"{}, hello!\", \"World\").estimated_capacity(), 0);\n     assert_eq!(format_args!(\"{}. 16-bytes piece\", \"World\").estimated_capacity(), 32);\n }\n+\n+#[test]\n+fn pad_integral_resets() {\n+    struct Bar;\n+\n+    impl core::fmt::Display for Bar {\n+        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+            \"1\".fmt(f)?;\n+            f.pad_integral(true, \"\", \"5\")?;\n+            \"1\".fmt(f)\n+        }\n+    }\n+\n+    assert_eq!(format!(\"{:<03}\", Bar), \"1  0051  \");\n+}"}, {"sha": "5b41ef350657fe491dd7b6cbd34edb48ee3544b1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1477,6 +1477,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n     assert_eq!(c.clone().skip(5).size_hint().1, None);\n     assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.clone().map_while(|_| None::<()>).size_hint(), (0, None));\n     assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n     assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n@@ -1491,6 +1492,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.clone().skip(3).size_hint(), (7, Some(7)));\n     assert_eq!(vi.clone().skip(12).size_hint(), (0, Some(0)));\n     assert_eq!(vi.clone().take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.clone().map_while(|_| None::<()>).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().skip_while(|_| false).size_hint(), (0, Some(10)));\n     assert_eq!(vi.clone().enumerate().size_hint(), (10, Some(10)));\n     assert_eq!(vi.clone().chain(v2).size_hint(), (13, Some(13)));\n@@ -1954,11 +1956,19 @@ fn test_range_inclusive_exhaustion() {\n     assert_eq!(r.next(), None);\n     assert_eq!(r.next(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n     assert!(r.is_empty());\n     assert_eq!(r.next_back(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=12;\n     assert_eq!(r.next(), Some(10));\n     assert_eq!(r.next(), Some(11));\n@@ -2076,6 +2086,9 @@ fn test_range_inclusive_nth() {\n     assert_eq!((10..=15).nth(5), Some(15));\n     assert_eq!((10..=15).nth(6), None);\n \n+    let mut exhausted_via_next = 10_u8..=20;\n+    while exhausted_via_next.next().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth(2), Some(12));\n     assert_eq!(r, 13..=20);\n@@ -2085,6 +2098,7 @@ fn test_range_inclusive_nth() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n@@ -2096,6 +2110,9 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!((10..=15).nth_back(6), None);\n     assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n \n+    let mut exhausted_via_next_back = 10_u8..=20;\n+    while exhausted_via_next_back.next_back().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth_back(2), Some(18));\n     assert_eq!(r, 10..=17);\n@@ -2105,6 +2122,7 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth_back(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next_back);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n "}, {"sha": "991458db5b72bde21de92bdfe382734559a0f495", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -4,7 +4,7 @@\n #![feature(cell_update)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n-#![feature(debug_map_key_value)]\n+#![feature(debug_non_exhaustive)]\n #![feature(dec2flt)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n@@ -13,12 +13,10 @@\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n #![feature(is_sorted)]\n-#![feature(iter_once_with)]\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(saturating_neg)]\n-#![feature(slice_patterns)]\n #![feature(sort_internals)]\n #![feature(slice_partition_at_index)]\n #![feature(specialization)]\n@@ -31,15 +29,17 @@\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n-#![feature(const_fn)]\n #![feature(array_value_iter)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]\n-#![feature(slice_from_raw_parts)]\n+#![feature(iter_map_while)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(never_type)]\n+#![feature(unwrap_infallible)]\n+#![feature(leading_trailing_ones)]\n \n extern crate test;\n "}, {"sha": "48a49073b2cf56a226f5674995d229abcbb96fba", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -89,6 +89,33 @@ macro_rules! int_module {\n                 assert_eq!(C.count_zeros(), bits as u32 - 5);\n             }\n \n+            #[test]\n+            fn test_leading_trailing_ones() {\n+                let bits = (mem::size_of::<$T>() * 8) as u32;\n+\n+                let a: $T = 0b0101_1111;\n+                assert_eq!(a.trailing_ones(), 5);\n+                assert_eq!((!a).leading_ones(), bits - 7);\n+\n+                assert_eq!(a.reverse_bits().leading_ones(), 5);\n+\n+                assert_eq!(_1.leading_ones(), bits);\n+                assert_eq!(_1.trailing_ones(), bits);\n+\n+                assert_eq!((_1 << 1).trailing_ones(), 0);\n+                assert_eq!(MAX.leading_ones(), 0);\n+\n+                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n+                assert_eq!(MAX.trailing_ones(), bits - 1);\n+\n+                assert_eq!(_0.leading_ones(), 0);\n+                assert_eq!(_0.trailing_ones(), 0);\n+\n+                let x: $T = 0b0010_1100;\n+                assert_eq!(x.leading_ones(), 0);\n+                assert_eq!(x.trailing_ones(), 0);\n+            }\n+\n             #[test]\n             fn test_rotate() {\n                 assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);"}, {"sha": "8f1ca8e6fac2c5a60be8072c349fa87cc5d233b5", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -53,6 +53,33 @@ macro_rules! uint_module {\n                 assert!(C.count_zeros() == bits as u32 - 5);\n             }\n \n+            #[test]\n+            fn test_leading_trailing_ones() {\n+                let bits = (mem::size_of::<$T>() * 8) as u32;\n+\n+                let a: $T = 0b0101_1111;\n+                assert_eq!(a.trailing_ones(), 5);\n+                assert_eq!((!a).leading_ones(), bits - 7);\n+\n+                assert_eq!(a.reverse_bits().leading_ones(), 5);\n+\n+                assert_eq!(_1.leading_ones(), bits);\n+                assert_eq!(_1.trailing_ones(), bits);\n+\n+                assert_eq!((_1 << 1).trailing_ones(), 0);\n+                assert_eq!((_1 >> 1).leading_ones(), 0);\n+\n+                assert_eq!((_1 << 1).leading_ones(), bits - 1);\n+                assert_eq!((_1 >> 1).trailing_ones(), bits - 1);\n+\n+                assert_eq!(_0.leading_ones(), 0);\n+                assert_eq!(_0.trailing_ones(), 0);\n+\n+                let x: $T = 0b0010_1100;\n+                assert_eq!(x.leading_ones(), 0);\n+                assert_eq!(x.trailing_ones(), 0);\n+            }\n+\n             #[test]\n             fn test_rotate() {\n                 assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);"}, {"sha": "c835313aae7037cd59860781dee296bc37fc3149", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -183,6 +183,28 @@ pub fn test_unwrap_or_default() {\n     assert_eq!(op2().unwrap_or_default(), 0);\n }\n \n+#[test]\n+pub fn test_into_ok() {\n+    fn infallible_op() -> Result<isize, !> {\n+        Ok(666)\n+    }\n+\n+    assert_eq!(infallible_op().into_ok(), 666);\n+\n+    enum MyNeverToken {}\n+    impl From<MyNeverToken> for ! {\n+        fn from(never: MyNeverToken) -> ! {\n+            match never {}\n+        }\n+    }\n+\n+    fn infallible_op2() -> Result<isize, MyNeverToken> {\n+        Ok(667)\n+    }\n+\n+    assert_eq!(infallible_op2().into_ok(), 667);\n+}\n+\n #[test]\n fn test_try() {\n     fn try_result_some() -> Option<u8> {\n@@ -214,31 +236,17 @@ fn test_try() {\n \n #[test]\n fn test_result_as_deref() {\n-    // &Result<T: Deref, E>::Ok(T).as_deref_ok() ->\n+    // &Result<T: Deref, E>::Ok(T).as_deref() ->\n     //      Result<&T::Deref::Target, &E>::Ok(&*T)\n     let ref_ok = &Result::Ok::<&i32, u8>(&42);\n     let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n-    let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n-    let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    // &Result<T: Deref, E: Deref>::Ok(T).as_deref() ->\n-    //      Result<&T::Deref::Target, &E::Deref::Target>::Ok(&*T)\n-    let ref_ok = &Result::Ok::<&i32, &u8>(&42);\n-    let expected_result = Result::Ok::<&i32, &u8>(&42);\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    let ref_ok = &Result::Ok::<String, &u32>(String::from(\"a result\"));\n+    let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n     let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    let ref_ok = &Result::Ok::<Vec<i32>, &u32>(vec![1, 2, 3, 4, 5]);\n+    let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n     let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n@@ -259,19 +267,21 @@ fn test_result_as_deref() {\n     // &Result<T: Deref, E: Deref>::Err(T).as_deref_err() ->\n     //      Result<&T, &E::Deref::Target>::Err(&*E)\n     let ref_err = &Result::Err::<&u8, &i32>(&41);\n-    let expected_result = Result::Err::<&u8, &i32>(&41);\n+    let expected_result = Result::Err::<&u8, &&i32>(&&41);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n-    let ref_err = &Result::Err::<&u32, String>(String::from(\"an error\"));\n-    let expected_result = Result::Err::<&u32, &str>(\"an error\");\n+    let s = String::from(\"an error\");\n+    let ref_err = &Result::Err::<&u32, String>(s.clone());\n+    let expected_result = Result::Err::<&u32, &String>(&s);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n-    let ref_err = &Result::Err::<&u32, Vec<i32>>(vec![5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32]>([5, 4, 3, 2, 1].as_slice());\n+    let v = vec![5, 4, 3, 2, 1];\n+    let ref_err = &Result::Err::<&u32, Vec<i32>>(v.clone());\n+    let expected_result = Result::Err::<&u32, &Vec<i32>>(&v);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n     // The following cases test calling `as_deref_*` with the wrong variant (i.e.\n-    // `as_deref_ok()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n+    // `as_deref()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n     // While uncommon, these cases are supported to ensure that an `as_deref_*`\n     // call can still be made even when one of the Result types does not implement\n     // `Deref` (for example, std::io::Error).\n@@ -290,56 +300,38 @@ fn test_result_as_deref() {\n     let expected_result = Result::Ok::<&[i32; 5], &u32>(&[1, 2, 3, 4, 5]);\n     assert_eq!(ref_ok.as_deref_err(), expected_result);\n \n-    // &Result<T: Deref, E>::Err(E).as_deref_ok() ->\n+    // &Result<T: Deref, E>::Err(E).as_deref() ->\n     //      Result<&T::Deref::Target, &E>::Err(&E)\n     let ref_err = &Result::Err::<&u8, i32>(41);\n     let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, &str>(\"an error\");\n     let expected_result = Result::Err::<&u32, &&str>(&\"an error\");\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, [i32; 5]>([5, 4, 3, 2, 1]);\n     let expected_result = Result::Err::<&u32, &[i32; 5]>(&[5, 4, 3, 2, 1]);\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n }\n \n #[test]\n fn test_result_as_deref_mut() {\n-    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut_ok() ->\n+    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut() ->\n     //      Result<&mut T::Deref::Target, &mut E>::Ok(&mut *T)\n     let mut val = 42;\n     let mut expected_val = 42;\n     let mut_ok = &mut Result::Ok::<&mut i32, u8>(&mut val);\n     let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    let mut expected_string = String::from(\"a result\");\n-    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n-    let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    let mut expected_vec = vec![1, 2, 3, 4, 5];\n-    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n-    let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    // &mut Result<T: Deref, E: Deref>::Ok(T).as_deref_mut() ->\n-    //      Result<&mut T::Deref::Target, &mut E::Deref::Target>::Ok(&mut *T)\n-    let mut val = 42;\n-    let mut expected_val = 42;\n-    let mut_ok = &mut Result::Ok::<&mut i32, &mut u8>(&mut val);\n-    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n     let mut expected_string = String::from(\"a result\");\n-    let mut_ok = &mut Result::Ok::<String, &mut u32>(expected_string.clone());\n+    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n     let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n     let mut expected_vec = vec![1, 2, 3, 4, 5];\n-    let mut_ok = &mut Result::Ok::<Vec<i32>, &mut u32>(expected_vec.clone());\n+    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n     let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n@@ -364,23 +356,22 @@ fn test_result_as_deref_mut() {\n     // &mut Result<T: Deref, E: Deref>::Err(T).as_deref_mut_err() ->\n     //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n     let mut val = 41;\n-    let mut expected_val = 41;\n-    let mut_err = &mut Result::Err::<&mut u8, &mut i32>(&mut val);\n-    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n+    let mut_err = &mut Result::Err::<&mut u8, i32>(val);\n+    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut val);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_string = String::from(\"an error\");\n     let mut_err = &mut Result::Err::<&mut u32, String>(expected_string.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut str>(expected_string.as_mut_str());\n+    let expected_result = Result::Err::<&mut u32, &mut String>(&mut expected_string);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_vec = vec![5, 4, 3, 2, 1];\n     let mut_err = &mut Result::Err::<&mut u32, Vec<i32>>(expected_vec.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut [i32]>(expected_vec.as_mut_slice());\n+    let expected_result = Result::Err::<&mut u32, &mut Vec<i32>>(&mut expected_vec);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     // The following cases test calling `as_deref_mut_*` with the wrong variant (i.e.\n-    // `as_deref_mut_ok()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n+    // `as_deref_mut()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n     // While uncommon, these cases are supported to ensure that an `as_deref_mut_*`\n     // call can still be made even when one of the Result types does not implement\n     // `Deref` (for example, std::io::Error).\n@@ -404,22 +395,22 @@ fn test_result_as_deref_mut() {\n     let expected_result = Result::Ok::<&mut [i32; 5], &mut u32>(&mut expected_arr);\n     assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n \n-    // &mut Result<T: Deref, E>::Err(E).as_deref_mut_ok() ->\n+    // &mut Result<T: Deref, E>::Err(E).as_deref_mut() ->\n     //      Result<&mut T::Deref::Target, &mut E>::Err(&mut E)\n     let mut expected_val = 41;\n     let mut_err = &mut Result::Err::<&mut u8, i32>(expected_val.clone());\n     let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let string = String::from(\"an error\");\n     let expected_string = string.clone();\n     let mut ref_str = expected_string.as_ref();\n     let mut_err = &mut Result::Err::<&mut u32, &str>(string.as_str());\n     let expected_result = Result::Err::<&mut u32, &mut &str>(&mut ref_str);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_arr = [5, 4, 3, 2, 1];\n     let mut_err = &mut Result::Err::<&mut u32, [i32; 5]>(expected_arr.clone());\n     let expected_result = Result::Err::<&mut u32, &mut [i32; 5]>(&mut expected_arr);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n }"}, {"sha": "b7fba88a540f9012dbc01efd9b5758d86e30709d", "filename": "src/libcore/unicode/bool_trie.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,66 +0,0 @@\n-/// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n-/// implemented with postfix compression (sharing of identical child nodes),\n-/// which gives both compact size and fast lookup.\n-///\n-/// The space of Unicode codepoints is divided into 3 subareas, each\n-/// represented by a trie with different depth. In the first (0..0x800), there\n-/// is no trie structure at all; each u64 entry corresponds to a bitvector\n-/// effectively holding 64 bool values.\n-///\n-/// In the second (0x800..0x10000), each child of the root node represents a\n-/// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n-/// the trie stores an 8-bit index into a shared table of leaf values. This\n-/// exploits the fact that in reasonable sets, many such leaves can be shared.\n-///\n-/// In the third (0x10000..0x110000), each child of the root node represents a\n-/// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n-/// of a child tree. Each of these 64 bytes represents an index into the table\n-/// of shared 64-bit leaf values. This exploits the sparse structure in the\n-/// non-BMP range of most Unicode sets.\n-pub struct BoolTrie {\n-    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    pub r1: [u64; 32], // leaves\n-\n-    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n-    pub r2: [u8; 992],      // first level\n-    pub r3: &'static [u64], // leaves\n-\n-    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    pub r4: [u8; 256],      // first level\n-    pub r5: &'static [u8],  // second level\n-    pub r6: &'static [u64], // leaves\n-}\n-impl BoolTrie {\n-    pub fn lookup(&self, c: char) -> bool {\n-        let c = c as u32;\n-        if c < 0x800 {\n-            trie_range_leaf(c, self.r1[(c >> 6) as usize])\n-        } else if c < 0x10000 {\n-            let child = self.r2[(c >> 6) as usize - 0x20];\n-            trie_range_leaf(c, self.r3[child as usize])\n-        } else {\n-            let child = self.r4[(c >> 12) as usize - 0x10];\n-            let leaf = self.r5[((child as usize) << 6) + ((c >> 6) as usize & 0x3f)];\n-            trie_range_leaf(c, self.r6[leaf as usize])\n-        }\n-    }\n-}\n-\n-pub struct SmallBoolTrie {\n-    pub(crate) r1: &'static [u8],  // first level\n-    pub(crate) r2: &'static [u64], // leaves\n-}\n-\n-impl SmallBoolTrie {\n-    pub fn lookup(&self, c: char) -> bool {\n-        let c = c as u32;\n-        match self.r1.get((c >> 6) as usize) {\n-            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n-            None => false,\n-        }\n-    }\n-}\n-\n-fn trie_range_leaf(c: u32, bitmap_chunk: u64) -> bool {\n-    ((bitmap_chunk >> (c & 63)) & 1) != 0\n-}"}, {"sha": "b6eaf06aa7f63be316f86ef76f26ffa0ba935def", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,15 +1,59 @@\n #![unstable(feature = \"unicode_internals\", issue = \"none\")]\n #![allow(missing_docs)]\n \n-mod bool_trie;\n pub(crate) mod printable;\n-pub(crate) mod tables;\n+mod unicode_data;\n pub(crate) mod version;\n \n+use version::UnicodeVersion;\n+\n+/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+/// `char` and `str` methods are based on.\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n+    major: unicode_data::UNICODE_VERSION.0,\n+    minor: unicode_data::UNICODE_VERSION.1,\n+    micro: unicode_data::UNICODE_VERSION.2,\n+    _priv: (),\n+};\n+\n // For use in liballoc, not re-exported in libstd.\n pub mod derived_property {\n-    pub use crate::unicode::tables::derived_property::{Case_Ignorable, Cased};\n+    pub use super::{Case_Ignorable, Cased};\n }\n-pub mod conversions {\n-    pub use crate::unicode::tables::conversions::{to_lower, to_upper};\n+\n+pub use unicode_data::alphabetic::lookup as Alphabetic;\n+pub use unicode_data::case_ignorable::lookup as Case_Ignorable;\n+pub use unicode_data::cased::lookup as Cased;\n+pub use unicode_data::cc::lookup as Cc;\n+pub use unicode_data::conversions;\n+pub use unicode_data::grapheme_extend::lookup as Grapheme_Extend;\n+pub use unicode_data::lowercase::lookup as Lowercase;\n+pub use unicode_data::n::lookup as N;\n+pub use unicode_data::uppercase::lookup as Uppercase;\n+pub use unicode_data::white_space::lookup as White_Space;\n+\n+#[inline(always)]\n+fn range_search<const N: usize, const N1: usize, const N2: usize>(\n+    needle: u32,\n+    chunk_idx_map: &[u8; N],\n+    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n+    bitset_chunk_idx: &[[u8; 16]; N1],\n+    bitset: &[u64; N2],\n+) -> bool {\n+    let bucket_idx = (needle / 64) as usize;\n+    let chunk_map_idx = bucket_idx / 16;\n+    let chunk_piece = bucket_idx % 16;\n+    let chunk_idx = if chunk_map_idx >= N {\n+        if chunk_map_idx == last_chunk_idx as usize {\n+            last_chunk_mapping\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        chunk_idx_map[chunk_map_idx]\n+    };\n+    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece];\n+    let word = bitset[(idx as usize)];\n+    (word & (1 << (needle % 64) as u64)) != 0\n }"}, {"sha": "3fa125e8fea15fc9921ce35af4660c76554f619c", "filename": "src/libcore/unicode/tables.rs", "status": "removed", "additions": 0, "deletions": 2235, "changes": 2235, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "97df92a56da66ea2b0527a35d4a5eb28f6457390", "filename": "src/libcore/unicode/unicode.py", "status": "removed", "additions": 0, "deletions": 878, "changes": 878, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=35c4aae99ece980c7c594940724f0728fcccf226", "patch": "@@ -1,878 +0,0 @@\n-#!/usr/bin/env python\n-\n-\"\"\"\n-Regenerate Unicode tables (tables.rs).\n-\"\"\"\n-\n-# This script uses the Unicode tables as defined\n-# in the UnicodeFiles class.\n-\n-# Since this should not require frequent updates, we just store this\n-# out-of-line and check the tables.rs file into git.\n-\n-# Note that the \"curl\" program is required for operation.\n-# This script is compatible with Python 2.7 and 3.x.\n-\n-import argparse\n-import datetime\n-import fileinput\n-import itertools\n-import os\n-import re\n-import textwrap\n-import subprocess\n-\n-from collections import defaultdict, namedtuple\n-\n-try:\n-    # Python 3\n-    from itertools import zip_longest\n-    from io import StringIO\n-except ImportError:\n-    # Python 2 compatibility\n-    zip_longest = itertools.izip_longest\n-    from StringIO import StringIO\n-\n-try:\n-    # Completely optional type hinting\n-    # (Python 2 compatible using comments,\n-    # see: https://mypy.readthedocs.io/en/latest/python2.html)\n-    # This is very helpful in typing-aware IDE like PyCharm.\n-    from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Set, Tuple\n-except ImportError:\n-    pass\n-\n-\n-# We don't use enum.Enum because of Python 2.7 compatibility.\n-class UnicodeFiles(object):\n-    # ReadMe does not contain any Unicode data, we\n-    # only use it to extract versions.\n-    README = \"ReadMe.txt\"\n-\n-    DERIVED_CORE_PROPERTIES = \"DerivedCoreProperties.txt\"\n-    DERIVED_NORMALIZATION_PROPS = \"DerivedNormalizationProps.txt\"\n-    PROPS = \"PropList.txt\"\n-    SCRIPTS = \"Scripts.txt\"\n-    SPECIAL_CASING = \"SpecialCasing.txt\"\n-    UNICODE_DATA = \"UnicodeData.txt\"\n-\n-\n-# The order doesn't really matter (Python < 3.6 won't preserve it),\n-# we only want to aggregate all the file names.\n-ALL_UNICODE_FILES = tuple(\n-    value for name, value in UnicodeFiles.__dict__.items()\n-    if not name.startswith(\"_\")\n-)\n-\n-assert len(ALL_UNICODE_FILES) == 7, \"Unexpected number of unicode files\"\n-\n-# The directory this file is located in.\n-THIS_DIR = os.path.dirname(os.path.realpath(__file__))\n-\n-# Where to download the Unicode data.  The downloaded files\n-# will be placed in sub-directories named after Unicode version.\n-FETCH_DIR = os.path.join(THIS_DIR, \"downloaded\")\n-\n-FETCH_URL_LATEST = \"ftp://ftp.unicode.org/Public/UNIDATA/{filename}\"\n-FETCH_URL_VERSION = \"ftp://ftp.unicode.org/Public/{version}/ucd/{filename}\"\n-\n-PREAMBLE = \"\"\"\\\n-// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n-\n-#![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n-\n-use crate::unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};\n-use crate::unicode::version::UnicodeVersion;\n-\"\"\".format(year=datetime.datetime.now().year)\n-\n-# Mapping taken from Table 12 from:\n-# http://www.unicode.org/reports/tr44/#General_Category_Values\n-EXPANDED_CATEGORIES = {\n-    \"Lu\": [\"LC\", \"L\"], \"Ll\": [\"LC\", \"L\"], \"Lt\": [\"LC\", \"L\"],\n-    \"Lm\": [\"L\"], \"Lo\": [\"L\"],\n-    \"Mn\": [\"M\"], \"Mc\": [\"M\"], \"Me\": [\"M\"],\n-    \"Nd\": [\"N\"], \"Nl\": [\"N\"], \"No\": [\"N\"],\n-    \"Pc\": [\"P\"], \"Pd\": [\"P\"], \"Ps\": [\"P\"], \"Pe\": [\"P\"],\n-    \"Pi\": [\"P\"], \"Pf\": [\"P\"], \"Po\": [\"P\"],\n-    \"Sm\": [\"S\"], \"Sc\": [\"S\"], \"Sk\": [\"S\"], \"So\": [\"S\"],\n-    \"Zs\": [\"Z\"], \"Zl\": [\"Z\"], \"Zp\": [\"Z\"],\n-    \"Cc\": [\"C\"], \"Cf\": [\"C\"], \"Cs\": [\"C\"], \"Co\": [\"C\"], \"Cn\": [\"C\"],\n-}\n-\n-# This is the (inclusive) range of surrogate codepoints.\n-# These are not valid Rust characters.\n-SURROGATE_CODEPOINTS_RANGE = (0xd800, 0xdfff)\n-\n-UnicodeData = namedtuple(\n-    \"UnicodeData\", (\n-        # Conversions:\n-        \"to_upper\", \"to_lower\", \"to_title\",\n-\n-        # Decompositions: canonical decompositions, compatibility decomp\n-        \"canon_decomp\", \"compat_decomp\",\n-\n-        # Grouped: general categories and combining characters\n-        \"general_categories\", \"combines\",\n-    )\n-)\n-\n-UnicodeVersion = namedtuple(\n-    \"UnicodeVersion\", (\"major\", \"minor\", \"micro\", \"as_str\")\n-)\n-\n-\n-def fetch_files(version=None):\n-    # type: (str) -> UnicodeVersion\n-    \"\"\"\n-    Fetch all the Unicode files from unicode.org.\n-\n-    This will use cached files (stored in `FETCH_DIR`) if they exist,\n-    creating them if they don't.  In any case, the Unicode version\n-    is always returned.\n-\n-    :param version: The desired Unicode version, as string.\n-        (If None, defaults to latest final release available,\n-         querying the unicode.org service).\n-    \"\"\"\n-    have_version = check_stored_version(version)\n-    if have_version:\n-        return have_version\n-\n-    if version:\n-        # Check if the desired version exists on the server.\n-        get_fetch_url = lambda name: FETCH_URL_VERSION.format(version=version, filename=name)\n-    else:\n-        # Extract the latest version.\n-        get_fetch_url = lambda name: FETCH_URL_LATEST.format(filename=name)\n-\n-    readme_url = get_fetch_url(UnicodeFiles.README)\n-\n-    print(\"Fetching: {}\".format(readme_url))\n-    readme_content = subprocess.check_output((\"curl\", readme_url))\n-\n-    unicode_version = parse_readme_unicode_version(\n-        readme_content.decode(\"utf8\")\n-    )\n-\n-    download_dir = get_unicode_dir(unicode_version)\n-    if not os.path.exists(download_dir):\n-        # For 2.7 compat, we don't use `exist_ok=True`.\n-        os.makedirs(download_dir)\n-\n-    for filename in ALL_UNICODE_FILES:\n-        file_path = get_unicode_file_path(unicode_version, filename)\n-\n-        if os.path.exists(file_path):\n-            # Assume file on the server didn't change if it's been saved before.\n-            continue\n-\n-        if filename == UnicodeFiles.README:\n-            with open(file_path, \"wb\") as fd:\n-                fd.write(readme_content)\n-        else:\n-            url = get_fetch_url(filename)\n-            print(\"Fetching: {}\".format(url))\n-            subprocess.check_call((\"curl\", \"-o\", file_path, url))\n-\n-    return unicode_version\n-\n-\n-def check_stored_version(version):\n-    # type: (Optional[str]) -> Optional[UnicodeVersion]\n-    \"\"\"\n-    Given desired Unicode version, return the version\n-    if stored files are all present, and `None` otherwise.\n-    \"\"\"\n-    if not version:\n-        # If no desired version specified, we should check what's the latest\n-        # version, skipping stored version checks.\n-        return None\n-\n-    fetch_dir = os.path.join(FETCH_DIR, version)\n-\n-    for filename in ALL_UNICODE_FILES:\n-        file_path = os.path.join(fetch_dir, filename)\n-\n-        if not os.path.exists(file_path):\n-            return None\n-\n-    with open(os.path.join(fetch_dir, UnicodeFiles.README)) as fd:\n-        return parse_readme_unicode_version(fd.read())\n-\n-\n-def parse_readme_unicode_version(readme_content):\n-    # type: (str) -> UnicodeVersion\n-    \"\"\"\n-    Parse the Unicode version contained in their `ReadMe.txt` file.\n-    \"\"\"\n-    # \"Raw string\" is necessary for \\d not being treated as escape char\n-    # (for the sake of compat with future Python versions).\n-    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n-    pattern = r\"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n-    groups = re.search(pattern, readme_content).groups()\n-\n-    return UnicodeVersion(*map(int, groups), as_str=\".\".join(groups))\n-\n-\n-def get_unicode_dir(unicode_version):\n-    # type: (UnicodeVersion) -> str\n-    \"\"\"\n-    Indicate in which parent dir the Unicode data files should be stored.\n-\n-    This returns a full, absolute path.\n-    \"\"\"\n-    return os.path.join(FETCH_DIR, unicode_version.as_str)\n-\n-\n-def get_unicode_file_path(unicode_version, filename):\n-    # type: (UnicodeVersion, str) -> str\n-    \"\"\"\n-    Indicate where the Unicode data file should be stored.\n-    \"\"\"\n-    return os.path.join(get_unicode_dir(unicode_version), filename)\n-\n-\n-def is_surrogate(n):\n-    # type: (int) -> bool\n-    \"\"\"\n-    Tell if given codepoint is a surrogate (not a valid Rust character).\n-    \"\"\"\n-    return SURROGATE_CODEPOINTS_RANGE[0] <= n <= SURROGATE_CODEPOINTS_RANGE[1]\n-\n-\n-def load_unicode_data(file_path):\n-    # type: (str) -> UnicodeData\n-    \"\"\"\n-    Load main Unicode data.\n-    \"\"\"\n-    # Conversions\n-    to_lower = {}   # type: Dict[int, Tuple[int, int, int]]\n-    to_upper = {}   # type: Dict[int, Tuple[int, int, int]]\n-    to_title = {}   # type: Dict[int, Tuple[int, int, int]]\n-\n-    # Decompositions\n-    compat_decomp = {}   # type: Dict[int, List[int]]\n-    canon_decomp = {}    # type: Dict[int, List[int]]\n-\n-    # Combining characters\n-    # FIXME: combines are not used\n-    combines = defaultdict(set)   # type: Dict[str, Set[int]]\n-\n-    # Categories\n-    general_categories = defaultdict(set)   # type: Dict[str, Set[int]]\n-    category_assigned_codepoints = set()    # type: Set[int]\n-\n-    all_codepoints = {}\n-\n-    range_start = -1\n-\n-    for line in fileinput.input(file_path):\n-        data = line.split(\";\")\n-        if len(data) != 15:\n-            continue\n-        codepoint = int(data[0], 16)\n-        if is_surrogate(codepoint):\n-            continue\n-        if range_start >= 0:\n-            for i in range(range_start, codepoint):\n-                all_codepoints[i] = data\n-            range_start = -1\n-        if data[1].endswith(\", First>\"):\n-            range_start = codepoint\n-            continue\n-        all_codepoints[codepoint] = data\n-\n-    for code, data in all_codepoints.items():\n-        (code_org, name, gencat, combine, bidi,\n-         decomp, deci, digit, num, mirror,\n-         old, iso, upcase, lowcase, titlecase) = data\n-\n-        # Generate char to char direct common and simple conversions:\n-\n-        # Uppercase to lowercase\n-        if lowcase != \"\" and code_org != lowcase:\n-            to_lower[code] = (int(lowcase, 16), 0, 0)\n-\n-        # Lowercase to uppercase\n-        if upcase != \"\" and code_org != upcase:\n-            to_upper[code] = (int(upcase, 16), 0, 0)\n-\n-        # Title case\n-        if titlecase.strip() != \"\" and code_org != titlecase:\n-            to_title[code] = (int(titlecase, 16), 0, 0)\n-\n-        # Store decomposition, if given\n-        if decomp:\n-            decompositions = decomp.split()[1:]\n-            decomp_code_points = [int(i, 16) for i in decompositions]\n-\n-            if decomp.startswith(\"<\"):\n-                # Compatibility decomposition\n-                compat_decomp[code] = decomp_code_points\n-            else:\n-                # Canonical decomposition\n-                canon_decomp[code] = decomp_code_points\n-\n-        # Place letter in categories as appropriate.\n-        for cat in itertools.chain((gencat, ), EXPANDED_CATEGORIES.get(gencat, [])):\n-            general_categories[cat].add(code)\n-            category_assigned_codepoints.add(code)\n-\n-        # Record combining class, if any.\n-        if combine != \"0\":\n-            combines[combine].add(code)\n-\n-    # Generate Not_Assigned from Assigned.\n-    general_categories[\"Cn\"] = get_unassigned_codepoints(category_assigned_codepoints)\n-\n-    # Other contains Not_Assigned\n-    general_categories[\"C\"].update(general_categories[\"Cn\"])\n-\n-    grouped_categories = group_categories(general_categories)\n-\n-    # FIXME: combines are not used\n-    return UnicodeData(\n-        to_lower=to_lower, to_upper=to_upper, to_title=to_title,\n-        compat_decomp=compat_decomp, canon_decomp=canon_decomp,\n-        general_categories=grouped_categories, combines=combines,\n-    )\n-\n-\n-def load_special_casing(file_path, unicode_data):\n-    # type: (str, UnicodeData) -> None\n-    \"\"\"\n-    Load special casing data and enrich given Unicode data.\n-    \"\"\"\n-    for line in fileinput.input(file_path):\n-        data = line.split(\"#\")[0].split(\";\")\n-        if len(data) == 5:\n-            code, lower, title, upper, _comment = data\n-        elif len(data) == 6:\n-            code, lower, title, upper, condition, _comment = data\n-            if condition.strip():  # Only keep unconditional mappins\n-                continue\n-        else:\n-            continue\n-        code = code.strip()\n-        lower = lower.strip()\n-        title = title.strip()\n-        upper = upper.strip()\n-        key = int(code, 16)\n-        for (map_, values) in ((unicode_data.to_lower, lower),\n-                               (unicode_data.to_upper, upper),\n-                               (unicode_data.to_title, title)):\n-            if values != code:\n-                split = values.split()\n-\n-                codepoints = list(itertools.chain(\n-                    (int(i, 16) for i in split),\n-                    (0 for _ in range(len(split), 3))\n-                ))\n-\n-                assert len(codepoints) == 3\n-                map_[key] = codepoints\n-\n-\n-def group_categories(mapping):\n-    # type: (Dict[Any, Iterable[int]]) -> Dict[str, List[Tuple[int, int]]]\n-    \"\"\"\n-    Group codepoints mapped in \"categories\".\n-    \"\"\"\n-    return {category: group_codepoints(codepoints)\n-            for category, codepoints in mapping.items()}\n-\n-\n-def group_codepoints(codepoints):\n-    # type: (Iterable[int]) -> List[Tuple[int, int]]\n-    \"\"\"\n-    Group integral values into continuous, disjoint value ranges.\n-\n-    Performs value deduplication.\n-\n-    :return: sorted list of pairs denoting start and end of codepoint\n-        group values, both ends inclusive.\n-\n-    >>> group_codepoints([1, 2, 10, 11, 12, 3, 4])\n-    [(1, 4), (10, 12)]\n-    >>> group_codepoints([1])\n-    [(1, 1)]\n-    >>> group_codepoints([1, 5, 6])\n-    [(1, 1), (5, 6)]\n-    >>> group_codepoints([])\n-    []\n-    \"\"\"\n-    sorted_codes = sorted(set(codepoints))\n-    result = []     # type: List[Tuple[int, int]]\n-\n-    if not sorted_codes:\n-        return result\n-\n-    next_codes = sorted_codes[1:]\n-    start_code = sorted_codes[0]\n-\n-    for code, next_code in zip_longest(sorted_codes, next_codes, fillvalue=None):\n-        if next_code is None or next_code - code != 1:\n-            result.append((start_code, code))\n-            start_code = next_code\n-\n-    return result\n-\n-\n-def ungroup_codepoints(codepoint_pairs):\n-    # type: (Iterable[Tuple[int, int]]) -> List[int]\n-    \"\"\"\n-    The inverse of group_codepoints -- produce a flat list of values\n-    from value range pairs.\n-\n-    >>> ungroup_codepoints([(1, 4), (10, 12)])\n-    [1, 2, 3, 4, 10, 11, 12]\n-    >>> ungroup_codepoints([(1, 1), (5, 6)])\n-    [1, 5, 6]\n-    >>> ungroup_codepoints(group_codepoints([1, 2, 7, 8]))\n-    [1, 2, 7, 8]\n-    >>> ungroup_codepoints([])\n-    []\n-    \"\"\"\n-    return list(itertools.chain.from_iterable(\n-        range(lo, hi + 1) for lo, hi in codepoint_pairs\n-    ))\n-\n-\n-def get_unassigned_codepoints(assigned_codepoints):\n-    # type: (Set[int]) -> Set[int]\n-    \"\"\"\n-    Given a set of \"assigned\" codepoints, return a set\n-    of these that are not in assigned and not surrogate.\n-    \"\"\"\n-    return {i for i in range(0, 0x110000)\n-            if i not in assigned_codepoints and not is_surrogate(i)}\n-\n-\n-def generate_table_lines(items, indent, wrap=98):\n-    # type: (Iterable[str], int, int) -> Iterator[str]\n-    \"\"\"\n-    Given table items, generate wrapped lines of text with comma-separated items.\n-\n-    This is a generator function.\n-\n-    :param wrap: soft wrap limit (characters per line), integer.\n-    \"\"\"\n-    line = \" \" * indent\n-    first = True\n-    for item in items:\n-        if len(line) + len(item) < wrap:\n-            if first:\n-                line += item\n-            else:\n-                line += \", \" + item\n-            first = False\n-        else:\n-            yield line + \",\\n\"\n-            line = \" \" * indent + item\n-\n-    yield line\n-\n-\n-def load_properties(file_path, interesting_props):\n-    # type: (str, Iterable[str]) -> Dict[str, List[Tuple[int, int]]]\n-    \"\"\"\n-    Load properties data and return in grouped form.\n-    \"\"\"\n-    props = defaultdict(list)   # type: Dict[str, List[Tuple[int, int]]]\n-    # \"Raw string\" is necessary for `\\.` and `\\w` not to be treated as escape chars\n-    # (for the sake of compat with future Python versions).\n-    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n-    re1 = re.compile(r\"^ *([0-9A-F]+) *; *(\\w+)\")\n-    re2 = re.compile(r\"^ *([0-9A-F]+)\\.\\.([0-9A-F]+) *; *(\\w+)\")\n-\n-    for line in fileinput.input(file_path):\n-        match = re1.match(line) or re2.match(line)\n-        if match:\n-            groups = match.groups()\n-\n-            if len(groups) == 2:\n-                # `re1` matched (2 groups).\n-                d_lo, prop = groups\n-                d_hi = d_lo\n-            else:\n-                d_lo, d_hi, prop = groups\n-        else:\n-            continue\n-\n-        if interesting_props and prop not in interesting_props:\n-            continue\n-\n-        lo_value = int(d_lo, 16)\n-        hi_value = int(d_hi, 16)\n-\n-        props[prop].append((lo_value, hi_value))\n-\n-    # Optimize if possible.\n-    for prop in props:\n-        props[prop] = group_codepoints(ungroup_codepoints(props[prop]))\n-\n-    return props\n-\n-\n-def escape_char(c):\n-    # type: (int) -> str\n-    r\"\"\"\n-    Escape a codepoint for use as Rust char literal.\n-\n-    Outputs are OK to use as Rust source code as char literals\n-    and they also include necessary quotes.\n-\n-    >>> escape_char(97)\n-    \"'\\\\u{61}'\"\n-    >>> escape_char(0)\n-    \"'\\\\0'\"\n-    \"\"\"\n-    return r\"'\\u{%x}'\" % c if c != 0 else r\"'\\0'\"\n-\n-\n-def format_char_pair(pair):\n-    # type: (Tuple[int, int]) -> str\n-    \"\"\"\n-    Format a pair of two Rust chars.\n-    \"\"\"\n-    return \"(%s,%s)\" % (escape_char(pair[0]), escape_char(pair[1]))\n-\n-\n-def generate_table(\n-    name,   # type: str\n-    items,  # type: List[Tuple[int, int]]\n-    decl_type=\"&[(char, char)]\",    # type: str\n-    is_pub=True,                    # type: bool\n-    format_item=format_char_pair,   # type: Callable[[Tuple[int, int]], str]\n-):\n-    # type: (...) -> Iterator[str]\n-    \"\"\"\n-    Generate a nicely formatted Rust constant \"table\" array.\n-\n-    This generates actual Rust code.\n-    \"\"\"\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield \"    %sconst %s: %s = &[\\n\" % (pub_string, name, decl_type)\n-\n-    data = []\n-    first = True\n-    for item in items:\n-        if not first:\n-            data.append(\",\")\n-        first = False\n-        data.extend(format_item(item))\n-\n-    for table_line in generate_table_lines(\"\".join(data).split(\",\"), 8):\n-        yield table_line\n-\n-    yield \"\\n    ];\\n\"\n-\n-\n-def compute_trie(raw_data, chunk_size):\n-    # type: (List[int], int) -> Tuple[List[int], List[int]]\n-    \"\"\"\n-    Compute postfix-compressed trie.\n-\n-    See: bool_trie.rs for more details.\n-\n-    >>> compute_trie([1, 2, 3, 1, 2, 3, 4, 5, 6], 3)\n-    ([0, 0, 1], [1, 2, 3, 4, 5, 6])\n-    >>> compute_trie([1, 2, 3, 1, 2, 4, 4, 5, 6], 3)\n-    ([0, 1, 2], [1, 2, 3, 1, 2, 4, 4, 5, 6])\n-    \"\"\"\n-    root = []\n-    childmap = {}       # type: Dict[Tuple[int, ...], int]\n-    child_data = []\n-\n-    assert len(raw_data) % chunk_size == 0, \"Chunks must be equally sized\"\n-\n-    for i in range(len(raw_data) // chunk_size):\n-        data = raw_data[i * chunk_size : (i + 1) * chunk_size]\n-\n-        # Postfix compression of child nodes (data chunks)\n-        # (identical child nodes are shared).\n-\n-        # Make a tuple out of the list so it's hashable.\n-        child = tuple(data)\n-        if child not in childmap:\n-            childmap[child] = len(childmap)\n-            child_data.extend(data)\n-\n-        root.append(childmap[child])\n-\n-    return root, child_data\n-\n-\n-def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n-    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for BoolTrie struct.\n-\n-    This yields string fragments that should be joined to produce\n-    the final string.\n-\n-    See: `bool_trie.rs`.\n-    \"\"\"\n-    chunk_size = 64\n-    rawdata = [False] * 0x110000\n-    for (lo, hi) in codepoint_ranges:\n-        for cp in range(lo, hi + 1):\n-            rawdata[cp] = True\n-\n-    # Convert to bitmap chunks of `chunk_size` bits each.\n-    chunks = []\n-    for i in range(0x110000 // chunk_size):\n-        chunk = 0\n-        for j in range(chunk_size):\n-            if rawdata[i * chunk_size + j]:\n-                chunk |= 1 << j\n-        chunks.append(chunk)\n-\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield \"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name)\n-    yield \"        r1: [\\n\"\n-    data = (\"0x%016x\" % chunk for chunk in chunks[:0x800 // chunk_size])\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    # 0x800..0x10000 trie\n-    (r2, r3) = compute_trie(chunks[0x800 // chunk_size : 0x10000 // chunk_size], 64 // chunk_size)\n-    yield \"        r2: [\\n\"\n-    data = map(str, r2)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r3: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r3)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    # 0x10000..0x110000 trie\n-    (mid, r6) = compute_trie(chunks[0x10000 // chunk_size : 0x110000 // chunk_size],\n-                             64 // chunk_size)\n-    (r4, r5) = compute_trie(mid, 64)\n-\n-    yield \"        r4: [\\n\"\n-    data = map(str, r4)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r5: &[\\n\"\n-    data = map(str, r5)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r6: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r6)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"    };\\n\"\n-\n-\n-def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n-    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for `SmallBoolTrie` struct.\n-\n-    See: `bool_trie.rs`.\n-    \"\"\"\n-    last_chunk = max(hi // 64 for (lo, hi) in codepoint_ranges)\n-    n_chunks = last_chunk + 1\n-    chunks = [0] * n_chunks\n-    for (lo, hi) in codepoint_ranges:\n-        for cp in range(lo, hi + 1):\n-            assert cp // 64 < len(chunks)\n-            chunks[cp // 64] |= 1 << (cp & 63)\n-\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield (\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n-           % (pub_string, name))\n-\n-    (r1, r2) = compute_trie(chunks, 1)\n-\n-    yield \"        r1: &[\\n\"\n-    data = (str(node) for node in r1)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r2: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r2)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"    };\\n\"\n-\n-\n-def generate_property_module(mod, grouped_categories, category_subset):\n-    # type: (str, Dict[str, List[Tuple[int, int]]], Iterable[str]) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for module defining properties.\n-    \"\"\"\n-\n-    yield \"pub(crate) mod %s {\" % mod\n-    for cat in sorted(category_subset):\n-        if cat in (\"Cc\", \"White_Space\"):\n-            generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n-        else:\n-            generator = generate_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n-\n-        for fragment in generator:\n-            yield fragment\n-\n-        yield \"\\n\"\n-        yield \"    pub fn %s(c: char) -> bool {\\n\" % cat\n-        yield \"        %s_table.lookup(c)\\n\" % cat\n-        yield \"    }\\n\"\n-\n-    yield \"}\\n\\n\"\n-\n-\n-def generate_conversions_module(unicode_data):\n-    # type: (UnicodeData) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for module defining conversions.\n-    \"\"\"\n-\n-    yield \"pub(crate) mod conversions {\"\n-    yield \"\"\"\n-    pub fn to_lower(c: char) -> [char; 3] {\n-        match bsearch_case_table(c, to_lowercase_table) {\n-            None => [c, '\\\\0', '\\\\0'],\n-            Some(index) => to_lowercase_table[index].1,\n-        }\n-    }\n-\n-    pub fn to_upper(c: char) -> [char; 3] {\n-        match bsearch_case_table(c, to_uppercase_table) {\n-            None => [c, '\\\\0', '\\\\0'],\n-            Some(index) => to_uppercase_table[index].1,\n-        }\n-    }\n-\n-    fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n-        table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-    }\\n\"\"\"\n-\n-    decl_type = \"&[(char, [char; 3])]\"\n-    format_conversion = lambda x: \"({},[{},{},{}])\".format(*(\n-        escape_char(c) for c in (x[0], x[1][0], x[1][1], x[1][2])\n-    ))\n-\n-    for fragment in generate_table(\n-        name=\"to_lowercase_table\",\n-        items=sorted(unicode_data.to_lower.items(), key=lambda x: x[0]),\n-        decl_type=decl_type,\n-        is_pub=False,\n-        format_item=format_conversion\n-    ):\n-        yield fragment\n-\n-    for fragment in generate_table(\n-        name=\"to_uppercase_table\",\n-        items=sorted(unicode_data.to_upper.items(), key=lambda x: x[0]),\n-        decl_type=decl_type,\n-        is_pub=False,\n-        format_item=format_conversion\n-    ):\n-        yield fragment\n-\n-    yield \"}\\n\"\n-\n-\n-def parse_args():\n-    # type: () -> argparse.Namespace\n-    \"\"\"\n-    Parse command line arguments.\n-    \"\"\"\n-    parser = argparse.ArgumentParser(description=__doc__)\n-    parser.add_argument(\"-v\", \"--version\", default=None, type=str,\n-                        help=\"Unicode version to use (if not specified,\"\n-                             \" defaults to latest release).\")\n-\n-    return parser.parse_args()\n-\n-\n-def main():\n-    # type: () -> None\n-    \"\"\"\n-    Script entry point.\n-    \"\"\"\n-    args = parse_args()\n-\n-    unicode_version = fetch_files(args.version)\n-    print(\"Using Unicode version: {}\".format(unicode_version.as_str))\n-\n-    # All the writing happens entirely in memory, we only write to file\n-    # once we have generated the file content (it's not very large, <1 MB).\n-    buf = StringIO()\n-    buf.write(PREAMBLE)\n-\n-    unicode_version_notice = textwrap.dedent(\"\"\"\n-    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n-    /// `char` and `str` methods are based on.\n-    #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-    pub const UNICODE_VERSION: UnicodeVersion =\n-        UnicodeVersion {{ major: {v.major}, minor: {v.minor}, micro: {v.micro}, _priv: () }};\n-    \"\"\").format(v=unicode_version)\n-    buf.write(unicode_version_notice)\n-\n-    get_path = lambda f: get_unicode_file_path(unicode_version, f)\n-\n-    unicode_data = load_unicode_data(get_path(UnicodeFiles.UNICODE_DATA))\n-    load_special_casing(get_path(UnicodeFiles.SPECIAL_CASING), unicode_data)\n-\n-    want_derived = {\"Alphabetic\", \"Lowercase\", \"Uppercase\",\n-                    \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"}\n-    derived = load_properties(get_path(UnicodeFiles.DERIVED_CORE_PROPERTIES), want_derived)\n-\n-    props = load_properties(get_path(UnicodeFiles.PROPS),\n-                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"})\n-\n-    # Category tables\n-    for (name, categories, category_subset) in (\n-            (\"general_category\", unicode_data.general_categories, [\"N\", \"Cc\"]),\n-            (\"derived_property\", derived, want_derived),\n-            (\"property\", props, [\"White_Space\"])\n-    ):\n-        for fragment in generate_property_module(name, categories, category_subset):\n-            buf.write(fragment)\n-\n-    for fragment in generate_conversions_module(unicode_data):\n-        buf.write(fragment)\n-\n-    tables_rs_path = os.path.join(THIS_DIR, \"tables.rs\")\n-\n-    # Actually write out the file content.\n-    # Will overwrite the file if it exists.\n-    with open(tables_rs_path, \"w\") as fd:\n-        fd.write(buf.getvalue())\n-\n-    print(\"Regenerated tables.rs.\")\n-\n-\n-if __name__ == \"__main__\":\n-    main()"}, {"sha": "da4cd4e9b1da1900e5703b5a2cc7f3ad65a77d90", "filename": "src/libcore/unicode/unicode_data.rs", "status": "added", "additions": 2343, "deletions": 0, "changes": 2343, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibcore%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode_data.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "a53e0012ca2210eee77bffc2b381eb3f90acf82b", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -597,6 +597,8 @@ pub enum RenderOption {\n     NoNodeLabels,\n     NoEdgeStyles,\n     NoNodeStyles,\n+\n+    Monospace,\n }\n \n /// Returns vec holding all the default render options.\n@@ -626,6 +628,14 @@ where\n     W: Write,\n {\n     writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n+\n+    // Global graph properties\n+    if options.contains(&RenderOption::Monospace) {\n+        writeln!(w, r#\"    graph[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    node[fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    edge[fontname=\"monospace\"];\"#)?;\n+    }\n+\n     for n in g.nodes().iter() {\n         write!(w, \"    \")?;\n         let id = g.node_id(n);"}, {"sha": "9161d49959cf5cc1577264dcdb1502cde151115a", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -52,22 +52,49 @@ pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n+struct Exception {\n+    // This needs to be an Option because the object's lifetime follows C++\n+    // semantics: when catch_unwind moves the Box out of the exception it must\n+    // still leave the exception object in a valid state because its destructor\n+    // is still going to be called by __cxa_end_catch..\n+    data: Option<Box<dyn Any + Send>>,\n+}\n+\n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     assert!(!ptr.is_null());\n-    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void);\n-    let ex = ptr::read(adjusted_ptr as *mut _);\n+    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void) as *mut Exception;\n+    let ex = (*adjusted_ptr).data.take();\n     __cxa_end_catch();\n-    ex\n+    ex.unwrap()\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let sz = mem::size_of_val(&data);\n-    let exception = __cxa_allocate_exception(sz);\n-    if exception == ptr::null_mut() {\n+    let exception = __cxa_allocate_exception(sz) as *mut Exception;\n+    if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception as *mut _, data);\n-    __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, ptr::null_mut());\n+    ptr::write(exception, Exception { data: Some(data) });\n+    __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n+}\n+\n+// On WASM and ARM, the destructor returns the pointer to the object.\n+cfg_if::cfg_if! {\n+    if #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))] {\n+        type DestructorRet = *mut libc::c_void;\n+    } else {\n+        type DestructorRet = ();\n+    }\n+}\n+extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> DestructorRet {\n+    unsafe {\n+        if let Some(b) = (ptr as *mut Exception).read().data {\n+            drop(b);\n+            super::__rust_drop_panic();\n+        }\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))]\n+        ptr\n+    }\n }\n \n #[lang = \"eh_personality\"]\n@@ -89,7 +116,7 @@ extern \"C\" {\n     fn __cxa_throw(\n         thrown_exception: *mut libc::c_void,\n         tinfo: *const TypeInfo,\n-        dest: *mut libc::c_void,\n+        dest: extern \"C\" fn(*mut libc::c_void) -> DestructorRet,\n     ) -> !;\n     fn __gxx_personality_v0(\n         version: c_int,"}, {"sha": "591ff9d7fdcaa3c24f7097b22b177d29063a0dcf", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -4,7 +4,7 @@\n //! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n //! documents linked from it.\n //! These are also good reads:\n-//!     http://mentorembedded.github.io/cxx-abi/abi-eh.html\n+//!     https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html\n //!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n //!     http://www.airs.com/blog/index.php?s=exception+frames\n //!\n@@ -57,7 +57,7 @@ use unwind as uw;\n #[repr(C)]\n struct Exception {\n     _uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<dyn Any + Send>>,\n+    cause: Box<dyn Any + Send>,\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n@@ -67,7 +67,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n             exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n-        cause: Some(data),\n+        cause: data,\n     });\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n     return uw::_Unwind_RaiseException(exception_param) as u32;\n@@ -78,6 +78,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     ) {\n         unsafe {\n             let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n+            super::__rust_drop_panic();\n         }\n     }\n }\n@@ -87,10 +88,8 @@ pub fn payload() -> *mut u8 {\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    let my_ep = ptr as *mut Exception;\n-    let cause = (*my_ep).cause.take();\n-    uw::_Unwind_DeleteException(ptr as *mut _);\n-    cause.unwrap()\n+    let exception = Box::from_raw(ptr as *mut Exception);\n+    exception.cause\n }\n \n // Rust's exception class identifier.  This is used by personality routines to"}, {"sha": "6383ae39fb6dba0c6795de05873964bc528341bb", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -26,6 +26,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(unwind_attributes)]\n+#![feature(abi_thiscall)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n@@ -60,6 +61,12 @@ cfg_if::cfg_if! {\n     }\n }\n \n+extern \"C\" {\n+    /// Handler in libstd called when a panic object is dropped outside of\n+    /// `catch_unwind`.\n+    fn __rust_drop_panic() -> !;\n+}\n+\n mod dwarf;\n \n // Entry point for catching an exception, implemented using the `try` intrinsic"}, {"sha": "6f507e85e742c59f6de1982c2fa76a5c23f4b3ff", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -77,8 +77,11 @@ use libc::{c_int, c_uint, c_void};\n //      #include <stdint.h>\n //\n //      struct rust_panic {\n+//          rust_panic(const rust_panic&);\n+//          ~rust_panic();\n+//\n //          uint64_t x[2];\n-//      }\n+//      };\n //\n //      void foo() {\n //          rust_panic a = {0, 1};\n@@ -128,7 +131,7 @@ mod imp {\n #[repr(C)]\n pub struct _ThrowInfo {\n     pub attributes: c_uint,\n-    pub pnfnUnwind: imp::ptr_t,\n+    pub pmfnUnwind: imp::ptr_t,\n     pub pForwardCompat: imp::ptr_t,\n     pub pCatchableTypeArray: imp::ptr_t,\n }\n@@ -145,7 +148,7 @@ pub struct _CatchableType {\n     pub pType: imp::ptr_t,\n     pub thisDisplacement: _PMD,\n     pub sizeOrOffset: c_int,\n-    pub copy_function: imp::ptr_t,\n+    pub copyFunction: imp::ptr_t,\n }\n \n #[repr(C)]\n@@ -168,7 +171,7 @@ const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n     attributes: 0,\n-    pnfnUnwind: ptr!(0),\n+    pmfnUnwind: ptr!(0),\n     pForwardCompat: ptr!(0),\n     pCatchableTypeArray: ptr!(0),\n };\n@@ -181,7 +184,7 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n     pType: ptr!(0),\n     thisDisplacement: _PMD { mdisp: 0, pdisp: -1, vdisp: 0 },\n     sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n-    copy_function: ptr!(0),\n+    copyFunction: ptr!(0),\n };\n \n extern \"C\" {\n@@ -208,6 +211,43 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     name: TYPE_NAME,\n };\n \n+// Destructor used if the C++ code decides to capture the exception and drop it\n+// without propagating it. The catch part of the try intrinsic will set the\n+// first word of the exception object to 0 so that it is skipped by the\n+// destructor.\n+//\n+// Note that x86 Windows uses the \"thiscall\" calling convention for C++ member\n+// functions instead of the default \"C\" calling convention.\n+//\n+// The exception_copy function is a bit special here: it is invoked by the MSVC\n+// runtime under a try/catch block and the panic that we generate here will be\n+// used as the result of the exception copy. This is used by the C++ runtime to\n+// support capturing exceptions with std::exception_ptr, which we can't support\n+// because Box<dyn Any> isn't clonable.\n+macro_rules! define_cleanup {\n+    ($abi:tt) => {\n+        unsafe extern $abi fn exception_cleanup(e: *mut [u64; 2]) {\n+            if (*e)[0] != 0 {\n+                cleanup(*e);\n+                super::__rust_drop_panic();\n+            }\n+        }\n+        #[unwind(allowed)]\n+        unsafe extern $abi fn exception_copy(_dest: *mut [u64; 2],\n+                                             _src: *mut [u64; 2])\n+                                             -> *mut [u64; 2] {\n+            panic!(\"Rust panics cannot be copied\");\n+        }\n+    }\n+}\n+cfg_if::cfg_if! {\n+   if #[cfg(target_arch = \"x86\")] {\n+       define_cleanup!(\"thiscall\");\n+   } else {\n+       define_cleanup!(\"C\");\n+   }\n+}\n+\n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     use core::intrinsics::atomic_store;\n \n@@ -220,8 +260,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // exception (constructed above).\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let ptrs_ptr = ptrs.as_mut_ptr();\n-    let throw_ptr = ptrs_ptr as *mut _;\n+    let throw_ptr = ptrs.as_mut_ptr() as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -243,6 +282,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     //\n     // In any case, we basically need to do something like this until we can\n     // express more operations in statics (and we may never be able to).\n+    atomic_store(&mut THROW_INFO.pmfnUnwind as *mut _ as *mut u32, ptr!(exception_cleanup) as u32);\n     atomic_store(\n         &mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n         ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32,\n@@ -255,6 +295,10 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n         &mut CATCHABLE_TYPE.pType as *mut _ as *mut u32,\n         ptr!(&TYPE_DESCRIPTOR as *const _) as u32,\n     );\n+    atomic_store(\n+        &mut CATCHABLE_TYPE.copyFunction as *mut _ as *mut u32,\n+        ptr!(exception_copy) as u32,\n+    );\n \n     extern \"system\" {\n         #[unwind(allowed)]"}, {"sha": "c51db695a5b1581efd9e7bdd7c81bcffe34edfb6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,7 +21,6 @@\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(allow_internal_unstable)]\n-#![feature(const_fn)]\n #![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]"}, {"sha": "8adcff67800fe2dc757395c6c0589f0b2f1ecbb9", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,7 +21,6 @@ fn main() {\n         \"InstrProfilingPlatformLinux.c\",\n         \"InstrProfilingPlatformOther.c\",\n         \"InstrProfilingPlatformWindows.c\",\n-        \"InstrProfilingRuntime.cc\",\n         \"InstrProfilingUtil.c\",\n         \"InstrProfilingValue.c\",\n         \"InstrProfilingWriter.c\",\n@@ -68,10 +67,17 @@ fn main() {\n     let root = env::var_os(\"RUST_COMPILER_RT_ROOT\").unwrap();\n     let root = Path::new(&root);\n \n+    let src_root = root.join(\"lib\").join(\"profile\");\n     for src in profile_sources {\n-        cfg.file(root.join(\"lib\").join(\"profile\").join(src));\n+        cfg.file(src_root.join(src));\n     }\n \n+    // The file was renamed in LLVM 10.\n+    let old_runtime_path = src_root.join(\"InstrProfilingRuntime.cc\");\n+    let new_runtime_path = src_root.join(\"InstrProfilingRuntime.cpp\");\n+    cfg.file(if old_runtime_path.exists() { old_runtime_path } else { new_runtime_path });\n+\n+    cfg.include(root.join(\"include\"));\n     cfg.warnings(false);\n     cfg.compile(\"profiler-rt\");\n }"}, {"sha": "782c6879ac58fd6945bd2e6c921d13c3f4ca16e5", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -15,29 +15,27 @@ bitflags = \"1.2.1\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n-num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.3.0\"\n rustc-rayon-core = \"0.3.0\"\n polonius-engine = \"0.11.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_attr = { path = \"../librustc_attr\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n-errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }\n backtrace = \"0.3.40\"\n parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n-rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.5\"\n-rustc_error_codes = { path = \"../librustc_error_codes\" }\n+measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "dd242686d26f202aa82c7cf7027b09f73e1d946f", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -123,8 +123,11 @@ macro_rules! arena_types {\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n             [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n \n+            // Interned types\n+            [] tys: rustc::ty::TyS<$tcx>,\n+\n             // HIR types\n-            [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [few] hir_krate: rustc_hir::Crate<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,\n@@ -176,7 +179,7 @@ macro_rules! declare_arena {\n     ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n-            dropless: DroplessArena,\n+            pub dropless: DroplessArena,\n             drop: DropArena,\n             $($name: arena_for_type!($a[$ty]),)*\n         }\n@@ -213,6 +216,7 @@ arena_types!(declare_arena, [], 'tcx);\n \n arena_types!(impl_arena_allocatable, [], 'tcx);\n \n+#[marker]\n pub trait ArenaAllocatable {}\n \n impl<T: Copy> ArenaAllocatable for T {}"}, {"sha": "237751bcbd787a34c66a400ed6a7d0c6c8e84994", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,4 +1,3 @@\n-#![feature(slice_patterns)]\n #![feature(test)]\n \n extern crate test;"}, {"sha": "29b94986a5f3a00b6effa877341231b78011b645", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -35,7 +35,7 @@\n //! \"infer\" some properties for each kind of `DepNode`:\n //!\n //! * Whether a `DepNode` of a given kind has any parameters at all. Some\n-//!   `DepNode`s, like `Krate`, represent global concepts with only one value.\n+//!   `DepNode`s, like `AllLocalTraitImpls`, represent global concepts with only one value.\n //! * Whether it is possible, in principle, to reconstruct a query key from a\n //!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n //!   in which case it is possible to map the node's fingerprint back to the\n@@ -52,7 +52,7 @@\n use crate::hir::map::DefPathHash;\n use crate::ich::{Fingerprint, StableHashingContext};\n use crate::mir;\n-use crate::mir::interpret::GlobalId;\n+use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n@@ -400,19 +400,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n \n-    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    // distinct from the krate module). This is basically a hash of\n-    // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.hir().krate()`), we will have to assume that any change\n-    // means that you need to be recompiled. This is because the\n-    // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.hir().krate()`; instead, prefer\n-    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    // access to the krate, but you must remember to add suitable\n-    // edges yourself for the individual items that you read.\n-    [eval_always] Krate,\n-\n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n     [eval_always] HirBody(DefId),"}, {"sha": "258723bb39d837308413b5c1c21a97d4b0ef3639", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -1,17 +1,19 @@\n use crate::ty::{self, TyCtxt};\n-use errors::Diagnostic;\n use parking_lot::{Condvar, Mutex};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_errors::Diagnostic;\n+use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::collections::hash_map::Entry;\n use std::env;\n use std::hash::Hash;\n use std::mem;\n-use std::sync::atomic::Ordering::SeqCst;\n+use std::sync::atomic::Ordering::Relaxed;\n \n use crate::ich::{Fingerprint, StableHashingContext, StableHashingContextProvider};\n \n@@ -25,6 +27,12 @@ use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n #[derive(Clone)]\n pub struct DepGraph {\n     data: Option<Lrc<DepGraphData>>,\n+\n+    /// This field is used for assigning DepNodeIndices when running in\n+    /// non-incremental mode. Even in non-incremental mode we make sure that\n+    /// each task has a `DepNodeIndex` that uniquely identifies it. This unique\n+    /// ID is used for self-profiling.\n+    virtual_dep_node_index: Lrc<AtomicU32>,\n }\n \n rustc_index::newtype_index! {\n@@ -35,6 +43,13 @@ impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n }\n \n+impl std::convert::From<DepNodeIndex> for QueryInvocationId {\n+    #[inline]\n+    fn from(dep_node_index: DepNodeIndex) -> Self {\n+        QueryInvocationId(dep_node_index.as_u32())\n+    }\n+}\n+\n #[derive(PartialEq)]\n pub enum DepNodeColor {\n     Red,\n@@ -105,11 +120,12 @@ impl DepGraph {\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n             })),\n+            virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n         }\n     }\n \n     pub fn new_disabled() -> DepGraph {\n-        DepGraph { data: None }\n+        DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n@@ -322,7 +338,7 @@ impl DepGraph {\n \n             (result, dep_node_index)\n         } else {\n-            (task(cx, arg), DepNodeIndex::INVALID)\n+            (task(cx, arg), self.next_virtual_depnode_index())\n         }\n     }\n \n@@ -352,7 +368,7 @@ impl DepGraph {\n             let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n-            (op(), DepNodeIndex::INVALID)\n+            (op(), self.next_virtual_depnode_index())\n         }\n     }\n \n@@ -478,8 +494,8 @@ impl DepGraph {\n             let current_dep_graph = &self.data.as_ref().unwrap().current;\n \n             Some((\n-                current_dep_graph.total_read_count.load(SeqCst),\n-                current_dep_graph.total_duplicate_read_count.load(SeqCst),\n+                current_dep_graph.total_read_count.load(Relaxed),\n+                current_dep_graph.total_duplicate_read_count.load(Relaxed),\n             ))\n         } else {\n             None\n@@ -662,18 +678,33 @@ impl DepGraph {\n                     } else {\n                         match dep_dep_node.kind {\n                             DepKind::Hir | DepKind::HirBody | DepKind::CrateMetadata => {\n-                                if dep_dep_node.extract_def_id(tcx).is_none() {\n+                                if let Some(def_id) = dep_dep_node.extract_def_id(tcx) {\n+                                    if def_id_corresponds_to_hir_dep_node(tcx, def_id) {\n+                                        // The `DefPath` has corresponding node,\n+                                        // and that node should have been marked\n+                                        // either red or green in `data.colors`.\n+                                        bug!(\n+                                            \"DepNode {:?} should have been \\\n+                                             pre-marked as red or green but wasn't.\",\n+                                            dep_dep_node\n+                                        );\n+                                    } else {\n+                                        // This `DefPath` does not have a\n+                                        // corresponding `DepNode` (e.g. a\n+                                        // struct field), and the ` DefPath`\n+                                        // collided with the `DefPath` of a\n+                                        // proper item that existed in the\n+                                        // previous compilation session.\n+                                        //\n+                                        // Since the given `DefPath` does not\n+                                        // denote the item that previously\n+                                        // existed, we just fail to mark green.\n+                                        return None;\n+                                    }\n+                                } else {\n                                     // If the node does not exist anymore, we\n                                     // just fail to mark green.\n                                     return None;\n-                                } else {\n-                                    // If the node does exist, it should have\n-                                    // been pre-allocated.\n-                                    bug!(\n-                                        \"DepNode {:?} should have been \\\n-                                          pre-allocated but wasn't.\",\n-                                        dep_dep_node\n-                                    )\n                                 }\n                             }\n                             _ => {\n@@ -877,6 +908,16 @@ impl DepGraph {\n             }\n         }\n     }\n+\n+    fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n+        let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n+        DepNodeIndex::from_u32(index)\n+    }\n+}\n+\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    def_id.index == hir_id.owner\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -1087,7 +1128,7 @@ impl DepGraphData {\n             if let Some(task_deps) = icx.task_deps {\n                 let mut task_deps = task_deps.lock();\n                 if cfg!(debug_assertions) {\n-                    self.current.total_read_count.fetch_add(1, SeqCst);\n+                    self.current.total_read_count.fetch_add(1, Relaxed);\n                 }\n                 if task_deps.read_set.insert(source) {\n                     task_deps.reads.push(source);\n@@ -1105,7 +1146,7 @@ impl DepGraphData {\n                         }\n                     }\n                 } else if cfg!(debug_assertions) {\n-                    self.current.total_duplicate_read_count.fetch_add(1, SeqCst);\n+                    self.current.total_duplicate_read_count.fetch_add(1, Relaxed);\n                 }\n             }\n         })"}, {"sha": "4c922654e02d57bd7ca836a5d4d780eb15806e87", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -223,12 +223,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (commandline_args_hash, crate_disambiguator.to_fingerprint()),\n         );\n \n-        let (_, crate_hash) = input_dep_node_and_hash(\n-            self.dep_graph,\n-            &mut self.hcx,\n-            DepNode::new_no_params(DepKind::Krate),\n-            crate_hash_input,\n-        );\n+        let mut stable_hasher = StableHasher::new();\n+        crate_hash_input.hash_stable(&mut self.hcx, &mut stable_hasher);\n+        let crate_hash: Fingerprint = stable_hasher.finish();\n \n         let svh = Svh::new(crate_hash.to_smaller_hash());\n         (self.map, svh)"}, {"sha": "048c1f026be82c6ad325241d04d24c00dc12b77b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -10,12 +10,12 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n-use rustc_session::node_id::NodeMap;\n use rustc_session::CrateDisambiguator;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n+use syntax::node_id::NodeMap;\n \n use std::borrow::Borrow;\n use std::fmt::Write;"}, {"sha": "c721faafbecaf408ea04765882477834001be719", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -12,7 +12,7 @@ pub fn check_crate(hir_map: &Map<'_>) {\n \n     let errors = Lock::new(Vec::new());\n \n-    par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n+    par_iter(&hir_map.krate.modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n             local_def_id,"}, {"sha": "1645420892a7531c7eebb061f989c4f66f06d0a9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 35, "deletions": 71, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -129,30 +129,6 @@ impl<'hir> Entry<'hir> {\n     }\n }\n \n-/// Stores a crate and any number of inlined items from other crates.\n-pub struct Forest<'hir> {\n-    krate: Crate<'hir>,\n-    pub dep_graph: DepGraph,\n-}\n-\n-impl Forest<'hir> {\n-    pub fn new(krate: Crate<'hir>, dep_graph: &DepGraph) -> Forest<'hir> {\n-        Forest { krate, dep_graph: dep_graph.clone() }\n-    }\n-\n-    pub fn krate(&self) -> &Crate<'hir> {\n-        self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n-        &self.krate\n-    }\n-\n-    /// This is used internally in the dependency tracking system.\n-    /// Use the `krate` method to ensure your dependency on the\n-    /// crate is tracked.\n-    pub fn untracked_krate(&self) -> &Crate<'hir> {\n-        &self.krate\n-    }\n-}\n-\n /// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n /// but it is implemented as 2 layers of arrays.\n /// - first we have `A = IndexVec<DefIndex, B>` mapping `DefIndex`s to an inner value\n@@ -162,11 +138,8 @@ pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Opt\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n-    /// The backing storage for all the AST nodes.\n-    pub forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n \n-    /// Same as the dep_graph in forest, just available with one fewer\n-    /// deref. This is a gratuitous micro-optimization.\n     pub dep_graph: DepGraph,\n \n     /// The SVH of the local crate.\n@@ -217,6 +190,13 @@ impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n }\n \n impl<'hir> Map<'hir> {\n+    /// This is used internally in the dependency tracking system.\n+    /// Use the `krate` method to ensure your dependency on the\n+    /// crate is tracked.\n+    pub fn untracked_krate(&self) -> &Crate<'hir> {\n+        &self.krate\n+    }\n+\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n         let local_map = self.map.get(id.owner)?;\n@@ -341,7 +321,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Use(..)\n                 | ItemKind::ForeignMod(..)\n                 | ItemKind::GlobalAsm(..)\n-                | ItemKind::Impl(..) => return None,\n+                | ItemKind::Impl { .. } => return None,\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,\n@@ -401,40 +381,36 @@ impl<'hir> Map<'hir> {\n         self.lookup(id).cloned()\n     }\n \n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n-        self.forest.krate()\n-    }\n-\n     pub fn item(&self, id: HirId) -> &'hir Item<'hir> {\n         self.read(id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.item(id)\n+        self.krate.item(id)\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_item(id)\n+        self.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.impl_item(id)\n+        self.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.body(id)\n+        self.krate.body(id)\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -530,9 +506,9 @@ impl<'hir> Map<'hir> {\n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [HirId] {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n+        self.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n@@ -542,15 +518,15 @@ impl<'hir> Map<'hir> {\n         let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n \n         self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-        &self.forest.krate.attrs\n+        &self.krate.attrs\n     }\n \n     pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n+            Node::Crate => (&self.krate.module, self.krate.span, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -567,7 +543,7 @@ impl<'hir> Map<'hir> {\n         // in the expect_* calls the loops below\n         self.read(hir_id);\n \n-        let module = &self.forest.krate.modules[&hir_id];\n+        let module = &self.krate.modules[&hir_id];\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));\n@@ -604,7 +580,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Union(_, ref generics)\n                 | ItemKind::Trait(_, _, ref generics, ..)\n                 | ItemKind::TraitAlias(ref generics, _)\n-                | ItemKind::Impl(_, _, _, ref generics, ..) => Some(generics),\n+                | ItemKind::Impl { ref generics, .. } => Some(generics),\n                 _ => None,\n             },\n             _ => None,\n@@ -821,7 +797,7 @@ impl<'hir> Map<'hir> {\n                     | ItemKind::Struct(..)\n                     | ItemKind::Union(..)\n                     | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n+                    | ItemKind::Impl { .. } => true,\n                     _ => false,\n                 },\n                 Node::ForeignItem(fi) => match fi.kind {\n@@ -984,7 +960,7 @@ impl<'hir> Map<'hir> {\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n             Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n-            Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n+            Some(Node::Crate) => Some(&self.krate.attrs[..]),\n             _ => None,\n         };\n         attrs.unwrap_or(&[])\n@@ -1063,7 +1039,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n-            Some(Node::Crate) => self.forest.krate.span,\n+            Some(Node::Crate) => self.krate.span,\n             None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n         }\n     }\n@@ -1231,7 +1207,8 @@ impl Named for ImplItem<'_> {\n pub fn map_crate<'hir>(\n     sess: &rustc_session::Session,\n     cstore: &CrateStoreDyn,\n-    forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n+    dep_graph: DepGraph,\n     definitions: Definitions,\n ) -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n@@ -1244,31 +1221,18 @@ pub fn map_crate<'hir>(\n         .collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n-\n-        let mut collector = NodeCollector::root(\n-            sess,\n-            &forest.krate,\n-            &forest.dep_graph,\n-            &definitions,\n-            &hir_to_node_id,\n-            hcx,\n-        );\n-        intravisit::walk_crate(&mut collector, &forest.krate);\n+        let hcx = crate::ich::StableHashingContext::new(sess, krate, &definitions, cstore);\n+\n+        let mut collector =\n+            NodeCollector::root(sess, krate, &dep_graph, &definitions, &hir_to_node_id, hcx);\n+        intravisit::walk_crate(&mut collector, krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, cstore, cmdline_args)\n     };\n \n-    let map = Map {\n-        forest,\n-        dep_graph: forest.dep_graph.clone(),\n-        crate_hash,\n-        map,\n-        hir_to_node_id,\n-        definitions,\n-    };\n+    let map = Map { krate, dep_graph, crate_hash, map, hir_to_node_id, definitions };\n \n     sess.time(\"validate_HIR_map\", || {\n         hir_id_validator::check_crate(&map);\n@@ -1332,7 +1296,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n                 ItemKind::Union(..) => \"union\",\n                 ItemKind::Trait(..) => \"trait\",\n                 ItemKind::TraitAlias(..) => \"trait alias\",\n-                ItemKind::Impl(..) => \"impl\",\n+                ItemKind::Impl { .. } => \"impl\",\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }"}, {"sha": "7d48280661a64232a6487687ab4dfc9b10c09eeb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -2,15 +2,52 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n-pub mod check_attr;\n pub mod exports;\n pub mod map;\n-pub mod upvars;\n \n use crate::ty::query::Providers;\n+use crate::ty::TyCtxt;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::print;\n+use rustc_hir::Crate;\n+use std::ops::Deref;\n+\n+/// A wrapper type which allows you to access HIR.\n+#[derive(Clone)]\n+pub struct Hir<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: &'tcx map::Map<'tcx>,\n+}\n+\n+impl<'tcx> Hir<'tcx> {\n+    pub fn krate(&self) -> &'tcx Crate<'tcx> {\n+        self.tcx.hir_crate(LOCAL_CRATE)\n+    }\n+}\n+\n+impl<'tcx> Deref for Hir<'tcx> {\n+    type Target = &'tcx map::Map<'tcx>;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.map\n+    }\n+}\n+\n+impl<'hir> print::PpAnn for Hir<'hir> {\n+    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n+        self.map.nested(state, nested)\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline(always)]\n+    pub fn hir(self) -> Hir<'tcx> {\n+        Hir { tcx: self, map: &self.hir_map }\n+    }\n+}\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    check_attr::provide(providers);\n+    providers.hir_crate = |tcx, _| tcx.hir_map.untracked_krate();\n     map::provide(providers);\n-    upvars::provide(providers);\n }"}, {"sha": "76e4b5f01b775cd4c099ccac8f6c7e6c938e9bd2", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -249,6 +249,12 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         self.hash_spans\n     }\n \n+    #[inline]\n+    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n+    }\n+\n     fn byte_pos_to_line_and_col(\n         &mut self,\n         byte: BytePos,"}, {"sha": "eadc9ddeee6fc827af0b4736b02abc0bb7876f13", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,20 +3,14 @@\n \n use crate::hir::map::DefPathHash;\n use crate::ich::{Fingerprint, NodeIdHashingMode, StableHashingContext};\n+use rustc_attr as attr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use std::mem;\n-use syntax::attr;\n \n impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n-    #[inline]\n-    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n-    }\n-\n     #[inline]\n     fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;\n@@ -40,40 +34,14 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n         }\n     }\n \n-    // The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n-    // `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n-    // the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n-    // are used when another item in the HIR is *referenced* and we certainly\n-    // want to pick up on a reference changing its target, so we hash the NodeIds\n-    // in \"DefPath Mode\".\n-\n-    fn hash_item_id(&mut self, id: hir::ItemId, hasher: &mut StableHasher) {\n+    fn hash_reference_to_item(&mut self, id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;\n-        let hir::ItemId { id } = id;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             id.hash_stable(hcx, hasher);\n         })\n     }\n \n-    fn hash_impl_item_id(&mut self, id: hir::ImplItemId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        let hir::ImplItemId { hir_id } = id;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hir_id.hash_stable(hcx, hasher);\n-        })\n-    }\n-\n-    fn hash_trait_item_id(&mut self, id: hir::TraitItemId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        let hir::TraitItemId { hir_id } = id;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            hir_id.hash_stable(hcx, hasher);\n-        })\n-    }\n-\n     fn hash_hir_mod(&mut self, module: &hir::Mod<'_>, hasher: &mut StableHasher) {\n         let hcx = self;\n         let hir::Mod { inner: ref inner_span, ref item_ids } = *module;\n@@ -283,12 +251,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -308,7 +270,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n \n         let import_keys = import_ids\n             .iter()\n-            .map(|node_id| hcx.node_to_hir_id(*node_id))\n             .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner), hir_id.local_id))\n             .collect();\n         (hcx.def_path_hash(*def_id), import_keys)"}, {"sha": "d1815d5e320dba01023e2e1d16f0dc1616e388e0", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -12,13 +12,6 @@ use smallvec::SmallVec;\n \n impl<'ctx> rustc_target::HashStableContext for StableHashingContext<'ctx> {}\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Lifetime {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.id.hash_stable(hcx, hasher);\n-        self.ident.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if self.len() == 0 {"}, {"sha": "844250f51a099536b67d57446d93ab57abb4ab5d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -63,9 +63,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ty::ReErased | ty::ReStatic | ty::ReEmpty => {\n+            ty::ReErased | ty::ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReEmpty(universe) => {\n+                universe.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);"}, {"sha": "85fafa349151e42c339c3453daac54d8989cc294", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -167,18 +167,29 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_)\n+            | ty::ReErased\n+            | ty::ReStatic\n+            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n+            | ty::ReEarlyBound(..) => r,\n+\n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(*placeholder) },\n                 r,\n             ),\n+\n             ty::ReVar(vid) => {\n                 let universe = canonicalizer.region_var_universe(*vid);\n                 canonicalizer.canonical_var_for_region(\n                     CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n                     r,\n                 )\n             }\n+\n+            ty::ReEmpty(ui) => {\n+                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n+            }\n+\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -213,7 +224,7 @@ impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReEmpty | ty::ReStatic => r,\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n             _ => {\n                 // We only expect region names that the user can type.\n@@ -306,7 +317,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 let r = self\n                     .infcx\n                     .unwrap()\n-                    .borrow_region_constraints()\n+                    .inner\n+                    .borrow_mut()\n+                    .unwrap_region_constraints()\n                     .opportunistic_resolve_var(self.tcx, vid);\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n@@ -320,8 +333,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n+            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) => {\n@@ -610,7 +623,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n \n     /// Returns the universe in which `vid` is defined.\n     fn region_var_universe(&self, vid: ty::RegionVid) -> ty::UniverseIndex {\n-        self.infcx.unwrap().borrow_region_constraints().var_universe(vid)\n+        self.infcx.unwrap().inner.borrow_mut().unwrap_region_constraints().var_universe(vid)\n     }\n \n     /// Creates a canonical variable (with the given `info`)"}, {"sha": "f157d805bcd8cb4f3f2cb2adf946d57e5b839596", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 334, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,284 +21,22 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, BoundVar, List};\n use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_serialize::UseSpecializedDecodable;\n use rustc_span::source_map::Span;\n-use smallvec::SmallVec;\n-use std::ops::Index;\n+\n+pub use rustc::infer::types::canonical::*;\n \n mod canonicalizer;\n \n pub mod query_response;\n \n mod substitute;\n \n-/// A \"canonicalized\" type `V` is one where all free inference\n-/// variables have been rewritten to \"canonical vars\". These are\n-/// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct Canonical<'tcx, V> {\n-    pub max_universe: ty::UniverseIndex,\n-    pub variables: CanonicalVarInfos<'tcx>,\n-    pub value: V,\n-}\n-\n-pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n-\n-impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n-\n-/// A set of values corresponding to the canonical variables from some\n-/// `Canonical`. You can give these values to\n-/// `canonical_value.substitute` to substitute them into the canonical\n-/// value at the right places.\n-///\n-/// When you canonicalize a value `V`, you get back one of these\n-/// vectors with the original values that were replaced by canonical\n-/// variables. You will need to supply it later to instantiate the\n-/// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n-}\n-\n-/// When we canonicalize a value to form a query, we wind up replacing\n-/// various parts of it with canonical variables. This struct stores\n-/// those replaced bits to remember for when we process the query\n-/// result.\n-#[derive(Clone, Debug)]\n-pub struct OriginalQueryValues<'tcx> {\n-    /// Map from the universes that appear in the query to the\n-    /// universes in the caller context. For the time being, we only\n-    /// ever put ROOT values into the query, so this map is very\n-    /// simple.\n-    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n-\n-    /// This is equivalent to `CanonicalVarValues`, but using a\n-    /// `SmallVec` yields a significant performance win.\n-    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n-}\n-\n-impl Default for OriginalQueryValues<'tcx> {\n-    fn default() -> Self {\n-        let mut universe_map = SmallVec::default();\n-        universe_map.push(ty::UniverseIndex::ROOT);\n-\n-        Self { universe_map, var_values: SmallVec::default() }\n-    }\n-}\n-\n-/// Information about a canonical variable that is included with the\n-/// canonical value. This is sufficient information for code to create\n-/// a copy of the canonical value in some other inference context,\n-/// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub struct CanonicalVarInfo {\n-    pub kind: CanonicalVarKind,\n-}\n-\n-impl CanonicalVarInfo {\n-    pub fn universe(&self) -> ty::UniverseIndex {\n-        self.kind.universe()\n-    }\n-\n-    pub fn is_existential(&self) -> bool {\n-        match self.kind {\n-            CanonicalVarKind::Ty(_) => true,\n-            CanonicalVarKind::PlaceholderTy(_) => false,\n-            CanonicalVarKind::Region(_) => true,\n-            CanonicalVarKind::PlaceholderRegion(..) => false,\n-            CanonicalVarKind::Const(_) => true,\n-            CanonicalVarKind::PlaceholderConst(_) => false,\n-        }\n-    }\n-}\n-\n-/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n-/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n-/// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalVarKind {\n-    /// Some kind of type inference variable.\n-    Ty(CanonicalTyVarKind),\n-\n-    /// A \"placeholder\" that represents \"any type\".\n-    PlaceholderTy(ty::PlaceholderType),\n-\n-    /// Region variable `'?R`.\n-    Region(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any region\". Created when you\n-    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n-    /// bound region `'a`.\n-    PlaceholderRegion(ty::PlaceholderRegion),\n-\n-    /// Some kind of const inference variable.\n-    Const(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any const\".\n-    PlaceholderConst(ty::PlaceholderConst),\n-}\n-\n-impl CanonicalVarKind {\n-    pub fn universe(self) -> ty::UniverseIndex {\n-        match self {\n-            CanonicalVarKind::Ty(kind) => match kind {\n-                CanonicalTyVarKind::General(ui) => ui,\n-                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n-            },\n-\n-            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Region(ui) => ui,\n-            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Const(ui) => ui,\n-            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n-        }\n-    }\n-}\n-\n-/// Rust actually has more than one category of type variables;\n-/// notably, the type variables we create for literals (e.g., 22 or\n-/// 22.) can only be instantiated with integral/float types (e.g.,\n-/// usize or f32). In order to faithfully reproduce a type, we need to\n-/// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalTyVarKind {\n-    /// General type variable `?T` that can be unified with arbitrary types.\n-    General(ty::UniverseIndex),\n-\n-    /// Integral type variable `?I` (that can only be unified with integral types).\n-    Int,\n-\n-    /// Floating-point type variable `?F` (that can only be unified with float types).\n-    Float,\n-}\n-\n-/// After we execute a query with a canonicalized key, we get back a\n-/// `Canonical<QueryResponse<..>>`. You can use\n-/// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n-pub struct QueryResponse<'tcx, R> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: QueryRegionConstraints<'tcx>,\n-    pub certainty: Certainty,\n-    pub value: R,\n-}\n-\n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n-pub struct QueryRegionConstraints<'tcx> {\n-    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n-    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n-}\n-\n-impl QueryRegionConstraints<'_> {\n-    /// Represents an empty (trivially true) set of region\n-    /// constraints.\n-    pub fn is_empty(&self) -> bool {\n-        self.outlives.is_empty() && self.member_constraints.is_empty()\n-    }\n-}\n-\n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n-\n-pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n-\n-/// Indicates whether or not we were able to prove the query to be\n-/// true.\n-#[derive(Copy, Clone, Debug, HashStable)]\n-pub enum Certainty {\n-    /// The query is known to be true, presuming that you apply the\n-    /// given `var_values` and the region-constraints are satisfied.\n-    Proven,\n-\n-    /// The query is not known to be true, but also not known to be\n-    /// false. The `var_values` represent *either* values that must\n-    /// hold in order for the query to be true, or helpful tips that\n-    /// *might* make it true. Currently rustc's trait solver cannot\n-    /// distinguish the two (e.g., due to our preference for where\n-    /// clauses over impls).\n-    ///\n-    /// After some unifiations and things have been done, it makes\n-    /// sense to try and prove again -- of course, at that point, the\n-    /// canonical form will be different, making this a distinct\n-    /// query.\n-    Ambiguous,\n-}\n-\n-impl Certainty {\n-    pub fn is_proven(&self) -> bool {\n-        match self {\n-            Certainty::Proven => true,\n-            Certainty::Ambiguous => false,\n-        }\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> QueryResponse<'tcx, R> {\n-    pub fn is_proven(&self) -> bool {\n-        self.certainty.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n-    pub fn is_proven(&self) -> bool {\n-        self.value.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, V> Canonical<'tcx, V> {\n-    /// Allows you to map the `value` of a canonical while keeping the\n-    /// same set of bound variables.\n-    ///\n-    /// **WARNING:** This function is very easy to mis-use, hence the\n-    /// name!  In particular, the new value `W` must use all **the\n-    /// same type/region variables** in **precisely the same order**\n-    /// as the original! (The ordering is defined by the\n-    /// `TypeFoldable` implementation of the type in question.)\n-    ///\n-    /// An example of a **correct** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'_, T> = ...;\n-    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n-    /// ```\n-    ///\n-    /// An example of an **incorrect** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'tcx, T> = ...;\n-    /// let ty: Ty<'tcx> = ...;\n-    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n-    /// ```\n-    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n-        let Canonical { max_universe, variables, value } = self;\n-        Canonical { max_universe, variables, value: map_op(value) }\n-    }\n-}\n-\n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n-\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n     /// inference variables and applies it to the canonical value.\n@@ -424,70 +162,3 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         }\n     }\n }\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    crate::infer::canonical::Certainty,\n-    crate::infer::canonical::CanonicalVarInfo,\n-    crate::infer::canonical::CanonicalVarKind,\n-}\n-\n-CloneTypeFoldableImpls! {\n-    for <'tcx> {\n-        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n-    }\n-}\n-\n-impl<'tcx> CanonicalVarValues<'tcx> {\n-    pub fn len(&self) -> usize {\n-        self.var_values.len()\n-    }\n-\n-    /// Makes an identity substitution from this one: each bound var\n-    /// is matched to the same bound var, preserving the original kinds.\n-    /// For example, if we have:\n-    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n-    /// we'll return a substitution `subst` with:\n-    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n-        use crate::ty::subst::GenericArgKind;\n-\n-        CanonicalVarValues {\n-            var_values: self\n-                .var_values\n-                .iter()\n-                .zip(0..)\n-                .map(|(kind, i)| match kind.unpack() {\n-                    GenericArgKind::Type(..) => {\n-                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n-                    }\n-                    GenericArgKind::Lifetime(..) => tcx\n-                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n-                        .into(),\n-                    GenericArgKind::Const(ct) => tcx\n-                        .mk_const(ty::Const {\n-                            ty: ct.ty,\n-                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n-                        })\n-                        .into(),\n-                })\n-                .collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n-    type Item = GenericArg<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.var_values.iter().cloned()\n-    }\n-}\n-\n-impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n-    type Output = GenericArg<'tcx>;\n-\n-    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n-        &self.var_values[value]\n-    }\n-}"}, {"sha": "012900f8af51b1ec19e6a094c226feb01d23582f", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, BoundVar, Ty, TyCtxt};\n-use crate::util::captures::Captures;\n+use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_span::DUMMY_SP;"}, {"sha": "9eb961255c29518ba5c2b8a369cdee92b3f9d1bd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -74,8 +74,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         match (&a.kind, &b.kind) {\n             // Relate integral variables to other types\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n-                self.int_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n@@ -95,8 +96,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n \n             // Relate floating-point variables to other types\n             (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n-                self.float_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n@@ -131,8 +133,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(self.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(self.const_unification_table.borrow_mut(), b);\n+        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, a);\n+        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, b);\n \n         let a_is_expected = relation.a_is_expected();\n \n@@ -141,8 +143,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n                 ty::ConstKind::Infer(InferConst::Var(b_vid)),\n             ) => {\n-                self.const_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .const_unification_table\n                     .unify_var_var(a_vid, b_vid)\n                     .map_err(|e| const_unification_error(a_is_expected, e))?;\n                 return Ok(a);\n@@ -174,8 +177,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::ConstVid<'tcx>,\n         value: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        self.const_unification_table\n+        self.inner\n             .borrow_mut()\n+            .const_unification_table\n             .unify_var_value(\n                 vid,\n                 ConstVarValue {\n@@ -196,8 +200,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::IntVid,\n         val: ty::IntVarValue,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.int_unification_table\n+        self.inner\n             .borrow_mut()\n+            .int_unification_table\n             .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n@@ -212,8 +217,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::FloatVid,\n         val: ast::FloatTy,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.float_unification_table\n+        self.inner\n             .borrow_mut()\n+            .float_unification_table\n             .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n@@ -260,7 +266,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n+        debug_assert!(self.infcx.inner.borrow_mut().type_variables.probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -280,7 +286,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n             a_ty, dir, b_vid, b_ty\n         );\n-        self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n+        self.infcx.inner.borrow_mut().type_variables.instantiate(b_vid, b_ty);\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(\n@@ -338,7 +344,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n-        let for_universe = match self.infcx.type_variables.borrow_mut().probe(for_vid) {\n+        let for_universe = match self.infcx.inner.borrow_mut().type_variables.probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n                 panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n@@ -350,7 +356,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n             needs_wf: false,\n@@ -502,17 +508,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // us from creating infinitely sized types.\n         match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n-                let vid = variables.root_var(vid);\n-                let sub_vid = variables.sub_root_var(vid);\n+                let vid = self.infcx.inner.borrow_mut().type_variables.root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n-                    match variables.probe(vid) {\n+                    let probe = self.infcx.inner.borrow_mut().type_variables.probe(vid);\n+                    match probe {\n                         TypeVariableValue::Known { value: u } => {\n-                            drop(variables);\n                             debug!(\"generalize: known value {:?}\", u);\n                             self.relate(&u, &u)\n                         }\n@@ -536,8 +541,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(self.for_universe, false, origin);\n+                            let origin =\n+                                *self.infcx.inner.borrow_mut().type_variables.var_origin(vid);\n+                            let new_var_id = self.infcx.inner.borrow_mut().type_variables.new_var(\n+                                self.for_universe,\n+                                false,\n+                                origin,\n+                            );\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -577,7 +587,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReScope(..)\n             | ty::ReEarlyBound(..)\n@@ -612,7 +622,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         match c.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n                     ConstVariableValue::Known { value: u } => self.relate(&u, &u),"}, {"sha": "018bbe035431e9e4f1cc84d2bff67eee000884b6", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -72,14 +72,14 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().equate(a_id, b_id);\n+                infcx.inner.borrow_mut().type_variables.equate(a_id, b_id);\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n@@ -105,7 +105,12 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         let origin = Subtype(box self.fields.trace.clone());\n-        self.fields.infcx.borrow_region_constraints().make_eqregion(origin, a, b);\n+        self.fields\n+            .infcx\n+            .inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .make_eqregion(origin, a, b);\n         Ok(a)\n     }\n \n@@ -125,7 +130,13 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     where\n         T: Relate<'tcx>,\n     {\n-        self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n-        self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n+        if a.skip_binder().has_escaping_bound_vars() || b.skip_binder().has_escaping_bound_vars() {\n+            self.fields.higher_ranked_sub(a, b, self.a_is_expected)?;\n+            self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n+        } else {\n+            // Fast path for the common case.\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+            return Ok(a.clone());\n+        }\n     }\n }"}, {"sha": "01390f2c7195b27dc392e096a2e5c2438e242a12", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 181, "deletions": 15, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -64,13 +64,13 @@ use crate::ty::{\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n };\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n-\n-use errors::{struct_span_err, Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use rustc_error_codes::*;\n-use rustc_span::{Pos, Span};\n+use rustc_span::{DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::{cmp, fmt};\n \n@@ -138,7 +138,10 @@ pub(super) fn note_and_explain_region(\n             msg_span_from_free_region(tcx, region)\n         }\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), None),\n+\n+        // uh oh, hope no user ever sees THIS\n+        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), None),\n \n         ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n@@ -181,7 +184,8 @@ fn msg_span_from_free_region(\n             msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), None),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -253,7 +257,7 @@ fn emit_msg_span(\n \n fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n     match item.kind {\n-        hir::ItemKind::Impl(..) => \"impl\",\n+        hir::ItemKind::Impl { .. } => \"impl\",\n         hir::ItemKind::Struct(..) => \"struct\",\n         hir::ItemKind::Union(..) => \"union\",\n         hir::ItemKind::Enum(..) => \"enum\",\n@@ -375,6 +379,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n+                    RegionResolutionError::UpperBoundUniverseConflict(\n+                        _,\n+                        _,\n+                        var_universe,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        assert!(sup_r.is_placeholder());\n+\n+                        // Make a dummy value for the \"sub region\" --\n+                        // this is the initial value of the\n+                        // placeholder. In practice, we expect more\n+                        // tailored errors that don't really use this\n+                        // value.\n+                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+\n+                        self.report_placeholder_failure(\n+                            region_scope_tree,\n+                            sup_origin,\n+                            sub_r,\n+                            sup_r,\n+                        )\n+                        .emit();\n+                    }\n+\n                     RegionResolutionError::MemberConstraintFailure {\n                         opaque_type_def_id,\n                         hidden_ty,\n@@ -429,6 +458,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n             | RegionResolutionError::SubSupConflict(..)\n+            | RegionResolutionError::UpperBoundUniverseConflict(..)\n             | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n@@ -443,6 +473,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::UpperBoundUniverseConflict(_, ref rvo, _, _, _) => rvo.span(),\n             RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors\n@@ -1289,6 +1320,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         mut values: Option<ValuePairs<'tcx>>,\n         terr: &TypeError<'tcx>,\n     ) {\n+        let span = cause.span(self.tcx);\n+\n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n         match terr {\n@@ -1298,6 +1331,100 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => {}\n         }\n \n+        struct OpaqueTypesVisitor<'tcx> {\n+            types: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            found: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            ignore_span: Span,\n+            tcx: TyCtxt<'tcx>,\n+        }\n+\n+        impl<'tcx> OpaqueTypesVisitor<'tcx> {\n+            fn visit_expected_found(\n+                tcx: TyCtxt<'tcx>,\n+                expected: Ty<'tcx>,\n+                found: Ty<'tcx>,\n+                ignore_span: Span,\n+            ) -> Self {\n+                let mut types_visitor = OpaqueTypesVisitor {\n+                    types: Default::default(),\n+                    expected: Default::default(),\n+                    found: Default::default(),\n+                    ignore_span,\n+                    tcx,\n+                };\n+                // The visitor puts all the relevant encountered types in `self.types`, but in\n+                // here we want to visit two separate types with no relation to each other, so we\n+                // move the results from `types` to `expected` or `found` as appropriate.\n+                expected.visit_with(&mut types_visitor);\n+                std::mem::swap(&mut types_visitor.expected, &mut types_visitor.types);\n+                found.visit_with(&mut types_visitor);\n+                std::mem::swap(&mut types_visitor.found, &mut types_visitor.types);\n+                types_visitor\n+            }\n+\n+            fn report(&self, err: &mut DiagnosticBuilder<'_>) {\n+                self.add_labels_for_types(err, \"expected\", &self.expected);\n+                self.add_labels_for_types(err, \"found\", &self.found);\n+            }\n+\n+            fn add_labels_for_types(\n+                &self,\n+                err: &mut DiagnosticBuilder<'_>,\n+                target: &str,\n+                types: &FxHashMap<TyCategory, FxHashSet<Span>>,\n+            ) {\n+                for (key, values) in types.iter() {\n+                    let count = values.len();\n+                    let kind = key.descr();\n+                    for sp in values {\n+                        err.span_label(\n+                            *sp,\n+                            format!(\n+                                \"{}{}{} {}{}\",\n+                                if sp.is_desugaring(DesugaringKind::Async) {\n+                                    \"the `Output` of this `async fn`'s \"\n+                                } else if count == 1 {\n+                                    \"the \"\n+                                } else {\n+                                    \"\"\n+                                },\n+                                if count > 1 { \"one of the \" } else { \"\" },\n+                                target,\n+                                kind,\n+                                pluralize!(count),\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n+                    let span = self.tcx.def_span(def_id);\n+                    // Avoid cluttering the output when the \"found\" and error span overlap:\n+                    //\n+                    // error[E0308]: mismatched types\n+                    //   --> $DIR/issue-20862.rs:2:5\n+                    //    |\n+                    // LL |     |y| x + y\n+                    //    |     ^^^^^^^^^\n+                    //    |     |\n+                    //    |     the found closure\n+                    //    |     expected `()`, found closure\n+                    //    |\n+                    //    = note: expected unit type `()`\n+                    //                 found closure `[closure@$DIR/issue-20862.rs:2:5: 2:14 x:_]`\n+                    if !self.ignore_span.overlaps(span) {\n+                        self.types.entry(kind).or_default().insert(span);\n+                    }\n+                }\n+                t.super_visit_with(self)\n+            }\n+        }\n+\n         debug!(\"note_type_err(diag={:?})\", diag);\n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n@@ -1306,6 +1433,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ValuePairs::Types(exp_found) => {\n                         let is_simple_err =\n                             exp_found.expected.is_simple_text() && exp_found.found.is_simple_text();\n+                        OpaqueTypesVisitor::visit_expected_found(\n+                            self.tcx,\n+                            exp_found.expected,\n+                            exp_found.found,\n+                            span,\n+                        )\n+                        .report(diag);\n \n                         (is_simple_err, Some(exp_found))\n                     }\n@@ -1323,8 +1457,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let span = cause.span(self.tcx);\n-\n         // Ignore msg for object safe coercion\n         // since E0038 message will be printed\n         match terr {\n@@ -1336,7 +1468,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n-\n         if let Some((expected, found)) = expected_found {\n             let expected_label = exp_found.map_or(\"type\".into(), |ef| ef.expected.prefix_string());\n             let found_label = exp_found.map_or(\"type\".into(), |ef| ef.found.prefix_string());\n@@ -1570,7 +1701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         sub: Region<'tcx>,\n     ) {\n         self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit()\n+            .emit();\n     }\n \n     pub fn construct_generic_bound_failure(\n@@ -1678,8 +1809,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let mut err = match *sub {\n-            ty::ReEarlyBound(_)\n-            | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(..), .. }) => {\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n+            | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n@@ -1688,7 +1819,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                binding_suggestion(&mut err, type_param_span, bound_kind, sub);\n+                // Explicitely use the name instead of `sub`'s `Display` impl. The `Display` impl\n+                // for the bound is not suitable for suggestions when `-Zverbose` is set because it\n+                // uses `Debug` output, so we handle it specially here so that suggestions are\n+                // always correct.\n+                binding_suggestion(&mut err, type_param_span, bound_kind, name);\n                 err\n             }\n \n@@ -1907,7 +2042,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n-                TypeError::ObjectUnsafeCoercion(did) => Error0038(did.clone()),\n+                TypeError::ObjectUnsafeCoercion(did) => Error0038(*did),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }\n@@ -1933,3 +2068,34 @@ impl<'tcx> ObligationCause<'tcx> {\n         }\n     }\n }\n+\n+/// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n+/// extra information about each type, but we only care about the category.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+crate enum TyCategory {\n+    Closure,\n+    Opaque,\n+    Generator,\n+    Foreign,\n+}\n+\n+impl TyCategory {\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::Closure => \"closure\",\n+            Self::Opaque => \"opaque type\",\n+            Self::Generator => \"generator\",\n+            Self::Foreign => \"foreign type\",\n+        }\n+    }\n+\n+    pub fn from_ty(ty: Ty<'_>) -> Option<(Self, DefId)> {\n+        match ty.kind {\n+            ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n+            ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n+            ty::Generator(def_id, ..) => Some((Self::Generator, def_id)),\n+            ty::Foreign(def_id) => Some((Self::Foreign, def_id)),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "0d7fce7eac6c528c834bd180cc654151a067489b", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,7 +3,7 @@ use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::infer::InferCtxt;\n use crate::ty::print::Print;\n use crate::ty::{self, DefIdTree, Infer, Ty, TyVar};\n-use errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -13,8 +13,6 @@ use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n \n-use rustc_error_codes::*;\n-\n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target_ty: Ty<'tcx>,\n@@ -49,9 +47,12 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n                 if ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty\n                         || match (&inner_ty.kind, &self.target_ty.kind) {\n-                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n-                                self.infcx.type_variables.borrow_mut().sub_unified(a_vid, b_vid)\n-                            }\n+                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables\n+                                .sub_unified(a_vid, b_vid),\n                             _ => false,\n                         }\n                 }) {\n@@ -151,12 +152,12 @@ pub enum TypeAnnotationNeeded {\n     E0284,\n }\n \n-impl Into<errors::DiagnosticId> for TypeAnnotationNeeded {\n-    fn into(self) -> errors::DiagnosticId {\n+impl Into<rustc_errors::DiagnosticId> for TypeAnnotationNeeded {\n+    fn into(self) -> rustc_errors::DiagnosticId {\n         match self {\n-            Self::E0282 => errors::error_code!(E0282),\n-            Self::E0283 => errors::error_code!(E0283),\n-            Self::E0284 => errors::error_code!(E0284),\n+            Self::E0282 => rustc_errors::error_code!(E0282),\n+            Self::E0283 => rustc_errors::error_code!(E0283),\n+            Self::E0284 => rustc_errors::error_code!(E0284),\n         }\n     }\n }\n@@ -168,7 +169,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n                 let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n@@ -226,7 +227,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n                 if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {"}, {"sha": "6a9fe19e1ac3d19948352db61564439d1da58e44", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -5,8 +5,7 @@ use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::util::common::ErrorReported;\n \n-use errors::struct_span_err;\n-use rustc_error_codes::*;\n+use rustc_errors::struct_span_err;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -46,7 +45,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = self.tcx().is_suitable_region(sup)?;"}, {"sha": "b10a60ef6f11fbee7c9c75dc9827ae65663bd536", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,7 +3,7 @@ use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n use crate::infer::InferCtxt;\n use crate::ty::{self, TyCtxt};\n use crate::util::common::ErrorReported;\n-use errors::DiagnosticBuilder;\n+use rustc_errors::DiagnosticBuilder;\n use rustc_span::source_map::Span;\n \n mod different_lifetimes;\n@@ -17,11 +17,6 @@ mod util;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        match *error {\n-            ConcreteFailure(..) | SubSupConflict(..) => {}\n-            _ => return false, // inapplicable\n-        }\n-\n         if let Some(tables) = self.in_progress_tables {\n             let tables = tables.borrow();\n             NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n@@ -79,13 +74,14 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n-    pub fn regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {\n+    pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {\n         match (&self.error, self.regions) {\n-            (Some(ConcreteFailure(origin, sub, sup)), None) => (origin.span(), sub, sup),\n-            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n-            (None, Some((span, sub, sup))) => (span, sub, sup),\n-            (Some(_), Some(_)) => panic!(\"incorrectly built NiceRegionError\"),\n-            _ => panic!(\"trying to report on an incorrect lifetime failure\"),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => Some((origin.span(), sub, sup)),\n+            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => {\n+                Some((origin.span(), sub, sup))\n+            }\n+            (None, Some((span, sub, sup))) => Some((span, sub, sup)),\n+            _ => None,\n         }\n     }\n }"}, {"sha": "250dcff372c593b5e35af1695a8ce80773a83464", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -2,16 +2,14 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::ty;\n-use errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::{FunctionRetTy, TyKind};\n \n-use rustc_error_codes::*;\n-\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         debug!(\n             \"try_report_named_anon_conflict(sub={:?}, sup={:?}, error={:?})\","}, {"sha": "0b0bd61ce771e770a7dcd2a919aff509b4916ef5", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -7,7 +7,7 @@ use crate::ty::error::ExpectedFound;\n use crate::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, TyCtxt};\n-use errors::DiagnosticBuilder;\n+use rustc_errors::DiagnosticBuilder;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n \n@@ -107,6 +107,25 @@ impl NiceRegionError<'me, 'tcx> {\n                 found.substs,\n             )),\n \n+            Some(RegionResolutionError::UpperBoundUniverseConflict(\n+                vid,\n+                _,\n+                _,\n+                SubregionOrigin::Subtype(box TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n+\n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace {\n                     cause,"}, {"sha": "c6fc4cd3c15f7721301e49c892756df0e19f037a", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -5,7 +5,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n use crate::util::common::ErrorReported;\n-use errors::Applicability;\n+use rustc_errors::Applicability;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait."}, {"sha": "11dda71b8cb89c9de2bb757b7b5441c5dd972ff3", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -3,9 +3,7 @@ use crate::infer::{self, InferCtxt, SubregionOrigin};\n use crate::middle::region;\n use crate::ty::error::TypeError;\n use crate::ty::{self, Region};\n-use errors::{struct_span_err, DiagnosticBuilder};\n-\n-use rustc_error_codes::*;\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin("}, {"sha": "0190989267bb459e9d8819b8747b09eb9f2c7894", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased\n@@ -154,14 +154,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .int_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n@@ -170,8 +171,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n             ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .float_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n@@ -225,8 +227,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n-                let opt_ct =\n-                    self.infcx.const_unification_table.borrow_mut().probe_value(v).val.known();\n+                let opt_ct = self\n+                    .infcx\n+                    .inner\n+                    .borrow_mut()\n+                    .const_unification_table\n+                    .probe_value(v)\n+                    .val\n+                    .known();\n                 return self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),"}, {"sha": "d0b7bb32b9815cdd46806a4c94a12729db86f39a", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -8,18 +8,17 @@ use super::{ConstVariableOrigin, RegionVariableOrigin};\n use rustc_data_structures::unify as ut;\n use ut::UnifyKey;\n \n-use std::cell::RefMut;\n use std::ops::Range;\n \n fn const_vars_since_snapshot<'tcx>(\n-    mut table: RefMut<'_, ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>>,\n+    table: &mut ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>,\n     snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n ) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n     let range = table.vars_since_snapshot(snapshot);\n     (\n         range.start..range.end,\n         (range.start.index..range.end.index)\n-            .map(|index| table.probe_value(ConstVid::from_index(index)).origin.clone())\n+            .map(|index| table.probe_value(ConstVid::from_index(index)).origin)\n             .collect(),\n     )\n }\n@@ -82,23 +81,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // going to be popped, so we will have to\n                     // eliminate any references to them.\n \n-                    let type_vars = self\n-                        .type_variables\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.type_snapshot);\n-                    let int_vars = self\n-                        .int_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.int_snapshot);\n-                    let float_vars = self\n-                        .float_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.float_snapshot);\n-                    let region_vars = self\n-                        .borrow_region_constraints()\n+                    let mut inner = self.inner.borrow_mut();\n+                    let type_vars =\n+                        inner.type_variables.vars_since_snapshot(&snapshot.type_snapshot);\n+                    let int_vars =\n+                        inner.int_unification_table.vars_since_snapshot(&snapshot.int_snapshot);\n+                    let float_vars =\n+                        inner.float_unification_table.vars_since_snapshot(&snapshot.float_snapshot);\n+                    let region_vars = inner\n+                        .unwrap_region_constraints()\n                         .vars_since_snapshot(&snapshot.region_constraints_snapshot);\n                     let const_vars = const_vars_since_snapshot(\n-                        self.const_unification_table.borrow_mut(),\n+                        &mut inner.const_unification_table,\n                         &snapshot.const_snapshot,\n                     );\n \n@@ -166,7 +160,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     // variables to their binding anyhow, we know\n                     // that it is unbound, so we can just return\n                     // it.\n-                    debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_unknown());\n+                    debug_assert!(\n+                        self.infcx.inner.borrow_mut().type_variables.probe(vid).is_unknown()\n+                    );\n                     ty\n                 }\n             }"}, {"sha": "6ef92132bc7034f19b0b9ce06d422ff41ebe5170", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "1b0f399ca33927058263aea7fbada44bb57f2e69", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -128,7 +128,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n-        self.borrow_region_constraints().leak_check(\n+        // If the user gave `-Zno-leak-check`, or we have been\n+        // configured to skip the leak check, then skip the leak check\n+        // completely. The leak check is deprecated. Any legitimate\n+        // subtyping errors that it would have caught will now be\n+        // caught later on, during region checking. However, we\n+        // continue to use it for a transition period.\n+        if self.tcx.sess.opts.debugging_opts.no_leak_check || self.skip_leak_check.get() {\n+            return Ok(());\n+        }\n+\n+        self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,\n             placeholder_map,"}, {"sha": "df475af1151aaea7abd54da33a63879197ebe1fd", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -56,8 +56,8 @@ where\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-    let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+    let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+    let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n     match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to"}, {"sha": "e0a8c3b4e654a6f4eae4d9a796776425d644e1f8", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 161, "deletions": 67, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use std::fmt;\n@@ -83,6 +82,16 @@ pub enum RegionResolutionError<'tcx> {\n         Region<'tcx>,\n     ),\n \n+    /// Indicates a `'b: 'a` constraint where `'a` is in a universe that\n+    /// cannot name the placeholder `'b`.\n+    UpperBoundUniverseConflict(\n+        RegionVid,\n+        RegionVariableOrigin,\n+        ty::UniverseIndex,     // the universe index of the region variable\n+        SubregionOrigin<'tcx>, // cause of the constraint\n+        Region<'tcx>,          // the placeholder `'b`\n+    ),\n+\n     /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n@@ -150,7 +159,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n+            values: IndexVec::from_fn_n(\n+                |vid| {\n+                    let vid_universe = self.var_infos[vid].universe;\n+                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n+                    VarValue::Value(re_empty)\n+                },\n+                self.num_vars(),\n+            ),\n         }\n     }\n \n@@ -295,62 +311,59 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        let mut process_constraint = |constraint: &Constraint<'tcx>| {\n-            let (a_region, b_vid, b_data, retain) = match *constraint {\n+        let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n+        let mut changes = Vec::new();\n+        for constraint in self.data.constraints.keys() {\n+            let (a_vid, a_region, b_vid, b_data) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (a_region, b_vid, b_data, false)\n+                    (None, a_region, b_vid, b_data)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => return (false, false),\n+                    VarValue::ErrorValue => continue,\n                     VarValue::Value(a_region) => {\n                         let b_data = var_values.value_mut(b_vid);\n-                        let retain = match *b_data {\n-                            VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                            _ => true,\n-                        };\n-                        (a_region, b_vid, b_data, retain)\n+                        (Some(a_vid), a_region, b_vid, b_data)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    return (false, false);\n+                    continue;\n                 }\n             };\n-\n-            let changed = self.expand_node(a_region, b_vid, b_data);\n-            (changed, retain)\n-        };\n-\n-        // Using bitsets to track the remaining elements is faster than using a\n-        // `Vec` by itself (which requires removing elements, which requires\n-        // element shuffling, which is slow).\n-        let constraints: Vec<_> = self.data.constraints.keys().collect();\n-        let mut live_indices: BitSet<usize> = BitSet::new_filled(constraints.len());\n-        let mut killed_indices: BitSet<usize> = BitSet::new_empty(constraints.len());\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            for index in live_indices.iter() {\n-                let constraint = constraints[index];\n-                let (edge_changed, retain) = process_constraint(constraint);\n-                changed |= edge_changed;\n-                if !retain {\n-                    let changed = killed_indices.insert(index);\n-                    debug_assert!(changed);\n+            if self.expand_node(a_region, b_vid, b_data) {\n+                changes.push(b_vid);\n+            }\n+            if let Some(a_vid) = a_vid {\n+                match *b_data {\n+                    VarValue::Value(ReStatic) | VarValue::ErrorValue => (),\n+                    _ => {\n+                        constraints[a_vid].push((a_vid, b_vid));\n+                        constraints[b_vid].push((a_vid, b_vid));\n+                    }\n                 }\n             }\n-            live_indices.subtract(&killed_indices);\n+        }\n \n-            // We could clear `killed_indices` here, but we don't need to and\n-            // it's cheaper not to.\n+        while let Some(vid) = changes.pop() {\n+            constraints[vid].retain(|&(a_vid, b_vid)| {\n+                let a_region = match *var_values.value(a_vid) {\n+                    VarValue::ErrorValue => return false,\n+                    VarValue::Value(a_region) => a_region,\n+                };\n+                let b_data = var_values.value_mut(b_vid);\n+                if self.expand_node(a_region, b_vid, b_data) {\n+                    changes.push(b_vid);\n+                }\n+                match *b_data {\n+                    VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n+                    _ => true,\n+                }\n+            });\n         }\n     }\n \n-    // This function is very hot in some workloads. There's a single callsite\n-    // so always inlining is ok even though it's large.\n-    #[inline(always)]\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,\n@@ -385,8 +398,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n-                if let ReEmpty = a_region {\n-                    return false;\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ReEmpty(a_universe) = a_region {\n+                    if *a_universe == b_universe {\n+                        return false;\n+                    }\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -403,7 +419,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                let b_universe = self.var_infos[b_vid].universe;\n                 if let ty::RePlaceholder(p) = lub {\n                     if b_universe.cannot_name(p.universe) {\n                         lub = self.tcx().lifetimes.re_static;\n@@ -424,12 +439,38 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// True if `a <= b`, but not defined over inference variables.\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        let tcx = self.tcx();\n+        let sub_free_regions = |r1, r2| self.region_rels.free_regions.sub_free_regions(tcx, r1, r2);\n+\n+        // Check for the case where we know that `'b: 'static` -- in that case,\n+        // `a <= b` for all `a`.\n+        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n+            return true;\n+        }\n+\n+        // If both `a` and `b` are free, consult the declared\n+        // relationships.  Note that this can be more precise than the\n+        // `lub` relationship defined below, since sometimes the \"lub\"\n+        // is actually the `postdom_upper_bound` (see\n+        // `TransitiveRelation` for more details).\n+        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        if a_free_or_static && b_free_or_static {\n+            return sub_free_regions(a, b);\n+        }\n+\n+        // For other cases, leverage the LUB code to find the LUB and\n+        // check if it is equal to `b`.\n         self.lub_concrete_regions(a, b) == b\n     }\n \n-    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n+    /// Returns the least-upper-bound of `a` and `b`; i.e., the\n+    /// smallest region `c` such that `a <= c` and `b <= c`.\n+    ///\n+    /// Neither `a` nor `b` may be an inference variable (hence the\n+    /// term \"concrete regions\").\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        match (a, b) {\n+        let r = match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n             | (&ReLateBound(..), _)\n@@ -439,14 +480,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n                     self.var_infos[v_id].origin.span(),\n@@ -457,6 +490,41 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 );\n             }\n \n+            (&ReStatic, _) | (_, &ReStatic) => {\n+                // nothing lives longer than `'static`\n+                self.tcx().lifetimes.re_static\n+            }\n+\n+            (&ReEmpty(_), r @ ReEarlyBound(_))\n+            | (r @ ReEarlyBound(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReFree(_))\n+            | (r @ ReFree(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReScope(_))\n+            | (r @ ReScope(_), &ReEmpty(_)) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                r\n+            }\n+\n+            (&ReEmpty(a_ui), &ReEmpty(b_ui)) => {\n+                // Empty regions are ordered according to the universe\n+                // they are associated with.\n+                let ui = a_ui.min(b_ui);\n+                self.tcx().mk_region(ReEmpty(ui))\n+            }\n+\n+            (&ReEmpty(empty_ui), &RePlaceholder(placeholder))\n+            | (&RePlaceholder(placeholder), &ReEmpty(empty_ui)) => {\n+                // If this empty region is from a universe that can\n+                // name the placeholder, then the placeholder is\n+                // larger; otherwise, the only ancestor is `'static`.\n+                if empty_ui.can_name(placeholder.universe) {\n+                    self.tcx().mk_region(RePlaceholder(placeholder))\n+                } else {\n+                    self.tcx().lifetimes.re_static\n+                }\n+            }\n+\n             (&ReEarlyBound(_), &ReScope(s_id))\n             | (&ReScope(s_id), &ReEarlyBound(_))\n             | (&ReFree(_), &ReScope(s_id))\n@@ -513,7 +581,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     self.tcx().lifetimes.re_static\n                 }\n             }\n-        }\n+        };\n+\n+        debug!(\"lub_concrete_regions({:?}, {:?}) = {:?}\", a, b, r);\n+\n+        r\n     }\n \n     /// After expansion is complete, go and check upper bounds (i.e.,\n@@ -532,7 +604,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n \n                 Constraint::RegSubReg(sub, sup) => {\n-                    if self.region_rels.is_subregion_of(sub, sup) {\n+                    if self.sub_concrete_regions(sub, sup) {\n                         continue;\n                     }\n \n@@ -561,7 +633,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n+                    if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n@@ -596,12 +668,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);\n \n-            // This was an inference variable which didn't get\n-            // constrained, therefore it can be assume to hold.\n-            if let ty::ReEmpty = *sub {\n-                continue;\n-            }\n-\n             let verify_kind_ty = verify.kind.to_ty(self.tcx());\n             if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n@@ -615,7 +681,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n             errors.push(RegionResolutionError::GenericBoundFailure(\n                 verify.origin.clone(),\n-                verify.kind.clone(),\n+                verify.kind,\n                 sub,\n             ));\n         }\n@@ -764,8 +830,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n-                    let origin = self.var_infos[node_idx].origin.clone();\n+                if !self.sub_concrete_regions(effective_lower_bound, upper_bound.region) {\n+                    let origin = self.var_infos[node_idx].origin;\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -784,14 +850,34 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n+        // 'a } }`, we wind up without any lower-bound -- all we have\n+        // are placeholders as upper bounds, but the universe of the\n+        // variable `'a` doesn't permit those placeholders.\n+        for upper_bound in &upper_bounds {\n+            if let ty::RePlaceholder(p) = upper_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    let origin = self.var_infos[node_idx].origin.clone();\n+                    errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n+                        node_idx,\n+                        origin,\n+                        node_universe,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Errors in earlier passes can yield error variables without\n         // resolution errors here; delay ICE in favor of those errors.\n         self.tcx().sess.delay_span_bug(\n             self.var_infos[node_idx].origin.span(),\n             &format!(\n                 \"collect_error_for_expanding_node() could not find \\\n-                      error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n-                      upper_bounds={:#?}\",\n+                 error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n+                 upper_bounds={:#?}\",\n                 node_idx, node_universe, lower_bounds, upper_bounds\n             ),\n         );\n@@ -894,7 +980,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), r))\n+            }\n+\n+            VerifyBound::IsEmpty => {\n+                if let ty::ReEmpty(_) = min {\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n \n             VerifyBound::AnyBound(bs) => {"}, {"sha": "6a699f803c7b84124084d5edc723694f99688fd3", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "be58de996a5dec2cb21626592728798ba1fdbdc8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 211, "deletions": 172, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "patch": "@@ -21,15 +21,15 @@ use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use crate::ty::{ConstVid, FloatVid, IntVid, TyVid};\n \n-use errors::DiagnosticBuilder;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n+use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-use std::cell::{Cell, Ref, RefCell, RefMut};\n+use std::cell::{Cell, Ref, RefCell};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n@@ -61,6 +61,7 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n+mod types;\n pub mod unify_key;\n \n #[must_use]\n@@ -104,6 +105,89 @@ impl SuppressRegionErrors {\n     }\n }\n \n+/// This type contains all the things within `InferCtxt` that sit within a\n+/// `RefCell` and are involved with taking/rolling back snapshots. Snapshot\n+/// operations are hot enough that we want only one call to `borrow_mut` per\n+/// call to `start_snapshot` and `rollback_to`.\n+pub struct InferCtxtInner<'tcx> {\n+    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    ///\n+    /// Public so that `traits::project` can use it.\n+    pub projection_cache: traits::ProjectionCache<'tcx>,\n+\n+    /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n+    /// that might instantiate a general type variable have an order,\n+    /// represented by its upper and lower bounds.\n+    type_variables: type_variable::TypeVariableTable<'tcx>,\n+\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n+    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+\n+    /// Map from floating variable to the kind of float it represents.\n+    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+\n+    /// Tracks the set of region variables and the constraints between them.\n+    /// This is initially `Some(_)` but when\n+    /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n+    /// -- further attempts to perform unification, etc., may fail if new\n+    /// region constraints would've been added.\n+    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+\n+    /// A set of constraints that regionck must validate. Each\n+    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// outlive the lifetime 'a\". These constraints derive from\n+    /// instantiated type parameters. So if you had a struct defined\n+    /// like\n+    ///\n+    ///     struct Foo<T:'static> { ... }\n+    ///\n+    /// then in some expression `let x = Foo { ... }` it will\n+    /// instantiate the type parameter `T` with a fresh type `$0`. At\n+    /// the same time, it will record a region obligation of\n+    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// can't generally check these things right away because we have\n+    /// to wait until types are resolved.)\n+    ///\n+    /// These are stored in a map keyed to the id of the innermost\n+    /// enclosing fn body / static initializer expression. This is\n+    /// because the location where the obligation was incurred can be\n+    /// relevant with respect to which sublifetime assumptions are in\n+    /// place. The reason that we store under the fn-id, and not\n+    /// something more fine-grained, is so that it is easier for\n+    /// regionck to be sure that it has found *all* the region\n+    /// obligations (otherwise, it's easy to fail to walk to a\n+    /// particular node-id).\n+    ///\n+    /// Before running `resolve_regions_and_report_errors`, the creator\n+    /// of the inference context is expected to invoke\n+    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// for each body-id in this map, which will process the\n+    /// obligations within. This is expected to be done 'late enough'\n+    /// that all type inference variables have been bound and so forth.\n+    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+}\n+\n+impl<'tcx> InferCtxtInner<'tcx> {\n+    fn new() -> InferCtxtInner<'tcx> {\n+        InferCtxtInner {\n+            projection_cache: Default::default(),\n+            type_variables: type_variable::TypeVariableTable::new(),\n+            const_unification_table: ut::UnificationTable::new(),\n+            int_unification_table: ut::UnificationTable::new(),\n+            float_unification_table: ut::UnificationTable::new(),\n+            region_constraints: Some(RegionConstraintCollector::new()),\n+            region_obligations: vec![],\n+        }\n+    }\n+\n+    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n+        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -113,32 +197,14 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// and for error reporting logic to read arbitrary node types.\n     pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n-    /// Cache for projections. This cache is snapshotted along with the\n-    /// infcx.\n-    ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n-\n-    /// We instantiate `UnificationTable` with `bounds<Ty>` because the\n-    /// types that might instantiate a general type variable have an\n-    /// order, represented by its upper and lower bounds.\n-    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n-\n-    /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n-    /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n-\n-    /// Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n-\n-    /// Tracks the set of region variables and the constraints between\n-    /// them.  This is initially `Some(_)` but when\n-    /// `resolve_regions_and_report_errors` is invoked, this gets set\n-    /// to `None` -- further attempts to perform unification etc may\n-    /// fail if new region constraints would've been added.\n-    region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n+    /// If set, this flag causes us to skip the 'leak check' during\n+    /// higher-ranked subtyping operations. This flag is a temporary one used\n+    /// to manage the removal of the leak-check: for the time being, we still run the\n+    /// leak-check, but we issue warnings. This flag can only be set to true\n+    /// when entering a snapshot.\n+    skip_leak_check: Cell<bool>,\n \n     /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n@@ -181,39 +247,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n-    /// outlive the lifetime 'a\". These constraints derive from\n-    /// instantiated type parameters. So if you had a struct defined\n-    /// like\n-    ///\n-    ///     struct Foo<T:'static> { ... }\n-    ///\n-    /// then in some expression `let x = Foo { ... }` it will\n-    /// instantiate the type parameter `T` with a fresh type `$0`. At\n-    /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n-    /// can't generally check these things right away because we have\n-    /// to wait until types are resolved.)\n-    ///\n-    /// These are stored in a map keyed to the id of the innermost\n-    /// enclosing fn body / static initializer expression. This is\n-    /// because the location where the obligation was incurred can be\n-    /// relevant with respect to which sublifetime assumptions are in\n-    /// place. The reason that we store under the fn-id, and not\n-    /// something more fine-grained, is so that it is easier for\n-    /// regionck to be sure that it has found *all* the region\n-    /// obligations (otherwise, it's easy to fail to walk to a\n-    /// particular node-id).\n-    ///\n-    /// Before running `resolve_regions_and_report_errors`, the creator\n-    /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n-    /// for each body-id in this map, which will process the\n-    /// obligations within. This is expected to be done 'late enough'\n-    /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n-\n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n     /// universal quantifiers.\n@@ -245,7 +278,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See the `error_reporting` module for more details.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n     values: ValuePairs<'tcx>,\n@@ -535,12 +568,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n-                projection_cache: Default::default(),\n-                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                inner: RefCell::new(InferCtxtInner::new()),\n                 lexical_region_resolutions: RefCell::new(None),\n                 selection_cache: Default::default(),\n                 evaluation_cache: Default::default(),\n@@ -549,23 +577,13 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 tainted_by_errors_flag: Cell::new(false),\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),\n-                region_obligations: RefCell::new(vec![]),\n+                skip_leak_check: Cell::new(false),\n                 universe: Cell::new(ty::UniverseIndex::ROOT),\n             })\n         })\n     }\n }\n \n-impl<T> ExpectedFound<T> {\n-    pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n-        if a_is_expected {\n-            ExpectedFound { expected: a, found: b }\n-        } else {\n-            ExpectedFound { expected: b, found: a }\n-        }\n-    }\n-}\n-\n impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n         InferOk { value: (), obligations: self.obligations }\n@@ -602,6 +620,7 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n     region_obligations_snapshot: usize,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n+    was_skip_leak_check: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n@@ -616,7 +635,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n         match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n             _ => false,\n         }\n     }\n@@ -630,14 +649,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -648,28 +667,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n-        let mut type_variables = self.type_variables.borrow_mut();\n-        let mut int_unification_table = self.int_unification_table.borrow_mut();\n-        let mut float_unification_table = self.float_unification_table.borrow_mut();\n+        let mut inner = self.inner.borrow_mut();\n         // FIXME(const_generics): should there be an equivalent function for const variables?\n \n-        type_variables\n+        let mut vars: Vec<Ty<'_>> = inner\n+            .type_variables\n             .unsolved_variables()\n             .into_iter()\n             .map(|t| self.tcx.mk_ty_var(t))\n-            .chain(\n-                (0..int_unification_table.len())\n-                    .map(|i| ty::IntVid { index: i as u32 })\n-                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v)),\n-            )\n-            .chain(\n-                (0..float_unification_table.len())\n-                    .map(|i| ty::FloatVid { index: i as u32 })\n-                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v)),\n-            )\n-            .collect()\n+            .collect();\n+        vars.extend(\n+            (0..inner.int_unification_table.len())\n+                .map(|i| ty::IntVid { index: i as u32 })\n+                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_int_var(v)),\n+        );\n+        vars.extend(\n+            (0..inner.float_unification_table.len())\n+                .map(|i| ty::FloatVid { index: i as u32 })\n+                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_float_var(v)),\n+        );\n+        vars\n     }\n \n     fn combine_fields(\n@@ -719,16 +738,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let in_snapshot = self.in_snapshot.get();\n         self.in_snapshot.set(true);\n \n+        let mut inner = self.inner.borrow_mut();\n         CombinedSnapshot {\n-            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n-            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n-            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n-            int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n-            float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: self.region_obligations.borrow().len(),\n+            projection_cache_snapshot: inner.projection_cache.snapshot(),\n+            type_snapshot: inner.type_variables.snapshot(),\n+            const_snapshot: inner.const_unification_table.snapshot(),\n+            int_snapshot: inner.int_unification_table.snapshot(),\n+            float_snapshot: inner.float_unification_table.snapshot(),\n+            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n+            region_obligations_snapshot: inner.region_obligations.len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n+            was_skip_leak_check: self.skip_leak_check.get(),\n             // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n@@ -747,19 +768,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot,\n             universe,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n-        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n-        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n-        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.rollback_to(projection_cache_snapshot);\n+        inner.type_variables.rollback_to(type_snapshot);\n+        inner.const_unification_table.rollback_to(const_snapshot);\n+        inner.int_unification_table.rollback_to(int_snapshot);\n+        inner.float_unification_table.rollback_to(float_snapshot);\n+        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n+        inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n@@ -774,17 +798,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().commit(type_snapshot);\n-        self.const_unification_table.borrow_mut().commit(const_snapshot);\n-        self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table.borrow_mut().commit(float_snapshot);\n-        self.borrow_region_constraints().commit(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.commit(projection_cache_snapshot);\n+        inner.type_variables.commit(type_snapshot);\n+        inner.const_unification_table.commit(const_snapshot);\n+        inner.int_unification_table.commit(int_snapshot);\n+        inner.float_unification_table.commit(float_snapshot);\n+        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -831,6 +858,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n+    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n+    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_snapshot();\n+        let skip_leak_check = should_skip || self.skip_leak_check.get();\n+        self.skip_leak_check.set(skip_leak_check);\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n+        r\n+    }\n+\n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n     /// - `None` -- if none of them involve \"region outlives\" constraints\n@@ -840,12 +881,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         snapshot: &CombinedSnapshot<'a, 'tcx>,\n     ) -> Option<bool> {\n-        self.borrow_region_constraints()\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n             .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n     }\n \n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.borrow_region_constraints().add_given(sub, sup);\n+        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n@@ -881,7 +924,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         b: ty::Region<'tcx>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n     }\n \n     /// Require that the region `r` be equal to one of the regions in\n@@ -895,7 +938,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n-        self.borrow_region_constraints().member_constraint(\n+        self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n             opaque_type_def_id,\n             definition_span,\n             hidden_ty,\n@@ -959,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.type_variables.borrow_mut().new_var(self.universe(), diverging, origin)\n+        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -971,7 +1014,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.type_variables.borrow_mut().new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n@@ -994,29 +1037,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         universe: ty::UniverseIndex,\n     ) -> &'tcx ty::Const<'tcx> {\n         let vid = self\n-            .const_unification_table\n+            .inner\n             .borrow_mut()\n+            .const_unification_table\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n             origin,\n             val: ConstVariableValue::Unknown { universe: self.universe() },\n         })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().int_unification_table.new_key(None)\n     }\n \n     pub fn next_int_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_int_var(self.next_int_var_id())\n     }\n \n     fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().float_unification_table.new_key(None)\n     }\n \n     pub fn next_float_var(&self) -> Ty<'tcx> {\n@@ -1038,7 +1082,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: RegionVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> ty::Region<'tcx> {\n-        let region_var = self.borrow_region_constraints().new_region_var(universe, origin);\n+        let region_var =\n+            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n@@ -1048,12 +1093,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// placeholders, however, it will return the universe which which\n     /// they are associated.\n     fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n-        self.borrow_region_constraints().universe(r)\n+        self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n     }\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().num_region_vars()\n+        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -1086,7 +1131,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n@@ -1106,7 +1151,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     span,\n                 };\n                 let const_var_id =\n-                    self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n@@ -1160,9 +1205,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         suppress: SuppressRegionErrors,\n     ) {\n         assert!(\n-            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n         let region_rels = &RegionRelations::new(\n@@ -1172,8 +1217,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             outlives_env.free_region_map(),\n         );\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1205,12 +1251,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n         assert!(\n-            self.region_obligations.borrow().is_empty(),\n+            self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n-        self.borrow_region_constraints().take_and_reset_data()\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n     }\n \n     /// Gives temporary access to the region constraint data.\n@@ -1219,8 +1265,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n     ) -> R {\n-        let region_constraints = self.borrow_region_constraints();\n-        op(region_constraints.data())\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n     }\n \n     /// Takes ownership of the list of variable regions. This implies\n@@ -1230,8 +1276,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1257,7 +1304,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n         use self::type_variable::TypeVariableValue;\n \n-        match self.type_variables.borrow_mut().probe(vid) {\n+        match self.inner.borrow_mut().type_variables.probe(vid) {\n             TypeVariableValue::Known { value } => Ok(value),\n             TypeVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1280,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.type_variables.borrow_mut().root_var(var)\n+        self.inner.borrow_mut().type_variables.root_var(var)\n     }\n \n     /// Where possible, replaces type/const variables in\n@@ -1318,7 +1365,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n+        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1415,7 +1462,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n \n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn type_is_copy_modulo_regions(\n@@ -1490,19 +1540,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         InferOk { value, obligations }\n     }\n \n-    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n-            c.as_mut().expect(\"region constraints already solved\")\n-        })\n-    }\n-\n     /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attempting to select an `Obligation` while changing only\n     /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n-        self.projection_cache.borrow_mut().clear();\n+        self.inner.borrow_mut().projection_cache.clear();\n     }\n \n     fn universe(&self) -> ty::UniverseIndex {\n@@ -1543,27 +1587,27 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.infcx\n-                    .type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.fold_ty(t))\n-                    .unwrap_or(typ)\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.infcx.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n                 .infcx\n-                .int_unification_table\n+                .inner\n                 .borrow_mut()\n+                .int_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n                 .infcx\n-                .float_unification_table\n+                .inner\n                 .borrow_mut()\n+                .float_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n@@ -1584,7 +1628,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n \n                 // If `inlined_probe` returns a `Known` value its `kind` never\n                 // matches `infer`.\n-                match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n+                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1594,15 +1638,15 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n             ty::FloatVar(v) => {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.float_unification_table.borrow_mut().probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n             _ => unreachable!(),\n@@ -1622,8 +1666,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n-                .const_unification_table\n+                .inner\n                 .borrow_mut()\n+                .const_unification_table\n                 .probe_value(*vid)\n                 .val\n                 .known()\n@@ -1656,12 +1701,6 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"TypeTrace({:?})\", self.cause)\n-    }\n-}\n-\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {"}, {"sha": "77e20e6ad8ff2c4cc1ebae0077bd640f056fc616", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "7fef9d27c4d4a353f5aa1c1950165baf8e73c052", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "17153ef97241b24da281f7cbc525392590c48971", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "a2c99064caa4e0c6b0e4ee79d70bb039789b41f2", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "29290cef2d28825b7e91ad98d959f419692240ad", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "8379a73bb9ebb3c8adea89df7d2521a3e0200e84", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "c9acd1cf4a1b319ed40434207b35c6ae0487c581", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ef4903358d5c96ca7fd44f4bb8edeb7d8701de67", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "f391a054a2a5dd1cebb852da55fa06a0eb4e3d20", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "133cf1b592862048616e6bc7de3eeb1f17b4f71b", "filename": "src/librustc/infer/types/canonical.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "534f4cb179c4f78eb7d2e5f183b55343e69fc74e", "filename": "src/librustc/infer/types/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "e205453a48c535176a9cec03853151f2c41d9127", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ceac68704d2b010c136af2f4466761f779b4560e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "004835b230ab44e3260494aaa3c9611a34b28827", "filename": "src/librustc/lint.rs", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "abd52a9de50d520ab781e9b7b5ba943c0d992c3d", "filename": "src/librustc/lint/levels.rs", "status": "removed", "additions": 0, "deletions": 550, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "3f43800590353dea0c72e619a27a73707c16e376", "filename": "src/librustc/lint/mod.rs", "status": "removed", "additions": 0, "deletions": 592, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "88ddd96eec8f5e66a61c1582bad4bd5b035d7ed0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "82adcfddc289ed5891d90ce31e4d699299ee5c99", "filename": "src/librustc/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "0e7ff3a3393efcb35cdfce6488a1ff8f744f79be", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "6ece51fe866745d449ad8af4468ac601c2496483", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "1f4318fa537514bf33c0726f49e4db3bb188440a", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 10, "deletions": 49, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "c8e284be6fc09cf5cad7615b2d19fd125163d61e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 35, "deletions": 392, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "b20f2cf3a85c133f53bec53c9ea3b041aa21ff43", "filename": "src/librustc/middle/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "dd30fb23c2e7681a47b7d84493a0225d3b2a53ae", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "89f385a51bc6a186339efa84650430854f57b700", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "e747eee30f90d2715a6b32c886a2a5bfe0725a1b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 82, "deletions": 111, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "f0879bdd8ae9b6482a1362f016db198cd6a027ab", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "a4974fb541b6b01f0d95d566d061ff051626d444", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ed57f81e782167638a72f317bc7b101a4c759d6c", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "4520d3a333316599fec2759e519e51fb002c6ba8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 138, "deletions": 385, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "6da7c09c7df9efbbb1698bd413cfaa08548ed300", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "34f58ab89b10757117e6054326e5e0fce599ca30", "filename": "src/librustc/mir/query.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "e6c7c84494cd80c0d934ae0aaace8a138fc5ddf1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ed8129b1e09a5eacd0302fb94ddd9fa86d9b7ea2", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "8330bbe0834326b2844d49aec5dbf5509e86cf16", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "11b079806af2d443f017fa3e2bbb9abcc92d5e3a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 90, "deletions": 15, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "3ab87ce8eb4a32b5cb600593bf1e113232995c7b", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "2a667b535508be2600d9fe36e90333994d506bc0", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "84bfc86e6a94ecc887580a428c50423d5e15a18b", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "5b8eb34ead1b387843683dcd0a2c9af1aa3ed826", "filename": "src/librustc/traits/error_reporting.rs", "status": "removed", "additions": 0, "deletions": 2954, "changes": 2954, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "c25b392ec239ae87de88ad73e8bbe0a6f51c89a6", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "added", "additions": 1656, "deletions": 0, "changes": 1656, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ab2d74b1c8deb809bbbc2a0e4baad96811e601c4", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "82b73518d09a86d4e84ee6aa5b5f322df38b322d", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "added", "additions": 1711, "deletions": 0, "changes": 1711, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "0aac6fb81e4a3436abc5214ed47a72bb87ce84b9", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "3fd0d12c626aa9de6132e1ed26d8473f815395c9", "filename": "src/librustc/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmisc.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "556e69b04f8243442e95be9c59946bc1ee148d96", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 31, "deletions": 682, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "4c5cd866b4a01b6651e4634e079810572135d5aa", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 241, "deletions": 58, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ca824d40e381ac0187cbdc1131e1bc7d0800f503", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "5d9f4ddfd167eebb0e3fa022be98686a03be59b0", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "a1d7a2836e42d3c032f5a165bea61a95e2b2c6d7", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 4, "deletions": 75, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "80748c5ef388efe15f3109b5f6990e9e6517896c", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "20a873dc4c6b6692e69730db871580fb0be8ef3f", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "737b4fc6bb9dc4a2b994106337af6226db8b6ce2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "594faffa5f3aa3b9ea4f3b8bd34824af03f0a3f8", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "b14b79f090778fbb230369539b1e41848b92368c", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "1de13430d4623707fe551e1e21b427baea789c81", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "2d03d77cf6645fd4517eaff69f11394ca54fbc2a", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "b1e0e29620df6b132ec7cb20a00422868d495ffb", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "92cfb82e27e953a97afce53868dec46d5daf247a", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "2877a74aaff01bc689713d0979a7d013805fa627", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "1fe8ab58d152caebce006519f9f23d0ddd0f5435", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 134, "deletions": 395, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "7c93a35158b08173c69a0036cd45a3128f4394bb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "e09bcdcbc628ea8d2f5e9b244031359318907e05", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 49, "deletions": 226, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "80731c7b1892fe3d82b79cd4eb0db9d8fea67378", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 704, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "571fb505779ca2408d2303a525fbc4d848df145d", "filename": "src/librustc/traits/types/mod.rs", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "c90551826202efd4300a90cde649cae91c71d8b0", "filename": "src/librustc/traits/types/query.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/types/select.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "36a84369d4a3ac6e407f0e9d2cf49fae1ec31b7e", "filename": "src/librustc/traits/types/specialization_graph.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/types/structural_impls.rs", "status": "added", "additions": 712, "deletions": 0, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "d4c3518260c602be532f9f99d24c0b6ae756db04", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "48721ec04e7fdbe666b21fa84d8d81c6dceaf67f", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "f4006a1cd40c19991c8b540e11f4bd1fbc7f0420", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "df1602b2ac46d83dd9265983a1eca524d252e490", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "5a415fa954f0d52bda6ea5ee5b49ff961a5250f9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 86, "deletions": 124, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "6c5458e6e58a6f05c4899df2d847520d83342525", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "4a4280ba7dc4dd3fabe48f0479d55bf27cc3fb36", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "1f007b970b0ca3dbce2b745dc3cacba3a394cae1", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "2ab12a4acbfa4affd6c5658da0a614b352f1c9e7", "filename": "src/librustc/ty/free_region_map.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffree_region_map.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "335953fc41eddffece47b579899c75a9b1e40942", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "e8bf2eb9a12c98413c9e01131e095336492fb7af", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ad51c60ab017874a627720aca95c6796a5e60569", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 120, "deletions": 440, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "384422956367a5dfc475f409421f20e55b309d32", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 65, "deletions": 26, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "dbb6a1080e6d46f6a305ea5ab0a8dd186d718226", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "8aae57e72cd527b4239a662b87ff6318f0d61618", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 205, "deletions": 104, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "c1c88e96f94b5d3c5c0140a25355bad68e639bac", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "ddaaab412a477ec8fd6e16941f73bba36ab08561", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "01f684dc65c30998b1959e262ae98e10fd3412bb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "8b787915de605e56f4cdb7512ea0a2e1f18d47a3", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 185, "deletions": 123, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "79b32ba83aea0100bf80e6d4a4e2127fe88f17fe", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "b01d15c29b2db7612ec265c9529941a222a5f932", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "3b9df72266f09a688f0ff5c2061f529c1a8accfc", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "59dd41e9d56c911db38e293fc8606129823fafdb", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "0718853b1df59443cde29bbac69d5b8b1c64e3f9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 121, "deletions": 38, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "db7b8d8cfd9ed999a663cd909f58f9c4b5262b95", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 163, "deletions": 28, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "da08fbcf14432f384a097ccec4c13f569b1b85cb", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "19b43bfd162415089209b4c3a37f5742d021504c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "df117de8720e067142a0b0c18ddee60bbf1919ed", "filename": "src/librustc_asan/Cargo.toml", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2FCargo.toml?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "e276dc16c35eee447bab6e79112eb297a5013a27", "filename": "src/librustc_asan/build.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "bdbc154f4e861c615f07fc8907d0f8a78d6f7b27", "filename": "src/librustc_asan/lib.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c4aae99ece980c7c594940724f0728fcccf226/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=35c4aae99ece980c7c594940724f0728fcccf226"}, {"sha": "f6ab60e199f335f977d1f92d8a6d6aeb52d080f3", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "b51d47655831215fd27413a044e8d317389036e3", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "73a25620b5a041c49eac54ec425296336fe3c16f", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 82, "deletions": 69, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "618b1e7964b95da158b0b751e34c0d0718c61403", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 76, "deletions": 749, "changes": 825, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "4c3c4ddac78ee40c115889de8d50ded11ff9cbdb", "filename": "src/librustc_ast_lowering/pat.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "e5f7df6dbf9e453e7f13fc045270e6b79d215717", "filename": "src/librustc_ast_lowering/path.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "01d2ac449b590b034a054c494f5777ecee71eb09", "filename": "src/librustc_ast_passes/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2FCargo.toml?ref=a2661695e8953199a746895e2e65225a9922753b"}, {"sha": "2f0495b8b5a48ec71e10259dc54f5271b9fadc54", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "renamed", "additions": 392, "deletions": 156, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "previous_filename": "src/librustc_passes/ast_validation.rs"}, {"sha": "0b21de4d78b41a513258f823baae67efbf956990", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "renamed", "additions": 52, "deletions": 351, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2661695e8953199a746895e2e65225a9922753b/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=a2661695e8953199a746895e2e65225a9922753b", "previous_filename": "src/libsyntax/feature_gate/check.rs"}]}