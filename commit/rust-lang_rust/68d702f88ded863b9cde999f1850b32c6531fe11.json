{"sha": "68d702f88ded863b9cde999f1850b32c6531fe11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZDcwMmY4OGRlZDg2M2I5Y2RlOTk5ZjE4NTBiMzJjNjUzMWZlMTE=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-17T23:20:19Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection lint: Start Applicability value tracking", "tree": {"sha": "122593d108943004871436f66c33f796177c999f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122593d108943004871436f66c33f796177c999f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68d702f88ded863b9cde999f1850b32c6531fe11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68d702f88ded863b9cde999f1850b32c6531fe11", "html_url": "https://github.com/rust-lang/rust/commit/68d702f88ded863b9cde999f1850b32c6531fe11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68d702f88ded863b9cde999f1850b32c6531fe11/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/060e0e9f9382cb7975165cede8d04b7bbe26bcb2", "html_url": "https://github.com/rust-lang/rust/commit/060e0e9f9382cb7975165cede8d04b7bbe26bcb2"}], "stats": {"total": 158, "additions": 155, "deletions": 3}, "files": [{"sha": "2bdb92376cad952cc6fa79fc07a2c9ca84cbffed", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 155, "deletions": 3, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/68d702f88ded863b9cde999f1850b32c6531fe11/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d702f88ded863b9cde999f1850b32c6531fe11/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=68d702f88ded863b9cde999f1850b32c6531fe11", "patch": "@@ -24,14 +24,21 @@ use if_chain::if_chain;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::{self as hir, ExprKind, Item, ItemKind, Mutability};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n+use rustc_middle::ty::BorrowKind;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n+use rustc_trait_selection::infer::TyCtxtInferExt;\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceWithHirId};\n+use rustc_typeck::hir_ty_to_ty;\n use serde::Serialize;\n-use std::fs::OpenOptions;\n+use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n+use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n-use crate::utils::{last_path_segment, match_function_call, match_type, paths, span_lint, walk_ptrs_ty_depth};\n+use crate::utils::{\n+    last_path_segment, match_function_call, match_type, path_to_local_id, paths, span_lint, walk_ptrs_ty_depth,\n+};\n \n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"metadata_collection.json\";\n@@ -91,6 +98,10 @@ impl Drop for MetadataCollector {\n     /// You might ask: How hacky is this?\n     /// My answer:     YES\n     fn drop(&mut self) {\n+        if self.lints.is_empty() {\n+            return;\n+        }\n+\n         let mut applicability_info = std::mem::take(&mut self.applicability_into);\n \n         // Mapping the final data\n@@ -99,6 +110,9 @@ impl Drop for MetadataCollector {\n             .for_each(|x| x.applicability = applicability_info.remove(&x.id));\n \n         // Outputting\n+        if Path::new(OUTPUT_FILE).exists() {\n+            fs::remove_file(OUTPUT_FILE).unwrap();\n+        }\n         let mut file = OpenOptions::new().write(true).create(true).open(OUTPUT_FILE).unwrap();\n         writeln!(file, \"{}\", serde_json::to_string_pretty(&self.lints).unwrap()).unwrap();\n     }\n@@ -158,6 +172,17 @@ struct ApplicabilityInfo {\n     applicabilities: FxHashSet<String>,\n }\n \n+fn log_to_file(msg: &str) {\n+    let mut file = OpenOptions::new()\n+        .write(true)\n+        .append(true)\n+        .create(true)\n+        .open(\"metadata-lint.log\")\n+        .unwrap();\n+\n+    write!(file, \"{}\", msg).unwrap();\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n     /// Collecting lint declarations like:\n     /// ```rust, ignore\n@@ -213,6 +238,20 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n         }\n     }\n \n+    /// Collecting constant applicability from the actual lint emissions\n+    ///\n+    /// Example:\n+    /// ```rust, ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     SOME_LINT,\n+    ///     item.span,\n+    ///     \"Le lint message\",\n+    ///     \"Here comes help:\",\n+    ///     \"#![allow(clippy::all)]\",\n+    ///     Applicability::MachineApplicable, // <-- Extracts this constant value\n+    /// );\n+    /// ```\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let Some(args) = match_simple_lint_emission(cx, expr) {\n             if let Some((lint_name, mut applicability)) = extract_emission_info(cx, args) {\n@@ -225,6 +264,73 @@ impl<'tcx> LateLintPass<'tcx> for MetadataCollector {\n             }\n         }\n     }\n+\n+    /// Tracking and hopefully collecting dynamic applicability values\n+    ///\n+    /// Example:\n+    /// ```rust, ignore\n+    /// // vvv Applicability value to track\n+    /// let mut applicability = Applicability::MachineApplicable;\n+    /// // vvv Value Mutation\n+    /// let suggestion = snippet_with_applicability(cx, expr.span, \"_\", &mut applicability);\n+    /// // vvv Emission to link the value to the lint\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     SOME_LINT,\n+    ///     expr.span,\n+    ///     \"This can be improved\",\n+    ///     \"try\",\n+    ///     suggestion,\n+    ///     applicability,\n+    /// );\n+    /// ```\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx hir::Local<'tcx>) {\n+        if let Some(tc) = cx.maybe_typeck_results() {\n+            // TODO xFrednet 2021-02-14: support nested applicability (only in tuples)\n+            let local_ty = if let Some(ty) = local.ty {\n+                hir_ty_to_ty(cx.tcx, ty)\n+            } else if let Some(init) = local.init {\n+                tc.expr_ty(init)\n+            } else {\n+                return;\n+            };\n+\n+            if_chain! {\n+                if match_type(cx, local_ty, &paths::APPLICABILITY);\n+                if let Some(body) = get_parent_body(cx, local.hir_id);\n+                then {\n+                    let span = SerializableSpan::from_span(cx, local.span);\n+                    let local_str = crate::utils::snippet(cx, local.span, \"_\");\n+                    let value_life = format!(\"{} -- {}:{}\\n\", local_str, span.path.rsplit('/').next().unwrap_or_default(), span.line);\n+                    let value_hir_id = local.pat.hir_id;\n+                    let mut tracker = ValueTracker {cx, value_hir_id, value_life};\n+\n+                    cx.tcx.infer_ctxt().enter(|infcx| {\n+                        let body_owner_id = cx.tcx.hir().body_owner_def_id(body.id());\n+                        ExprUseVisitor::new(\n+                            &mut tracker,\n+                            &infcx,\n+                            body_owner_id,\n+                            cx.param_env,\n+                            cx.typeck_results()\n+                        )\n+                        .consume_body(body);\n+                    });\n+\n+                    log_to_file(&tracker.value_life);\n+                    lint_collection_error_span(cx, local.span, \"Applicability value found\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn get_parent_body<'a, 'tcx>(cx: &'a LateContext<'tcx>, id: hir::HirId) -> Option<&'tcx hir::Body<'tcx>> {\n+    let map = cx.tcx.hir();\n+\n+    map.parent_iter(id)\n+        .find_map(|(parent, _)| map.maybe_body_owned_by(parent))\n+        .map(|body| map.body(body))\n }\n \n fn sym_to_string(sym: Symbol) -> String {\n@@ -262,6 +368,9 @@ fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n     None\n }\n \n+// ==================================================================\n+// Lint emission\n+// ==================================================================\n fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &str) {\n     span_lint(\n         cx,\n@@ -280,13 +389,16 @@ fn lint_collection_error_span(cx: &LateContext<'_>, span: Span, message: &str) {\n     );\n }\n \n+// ==================================================================\n+// Applicability\n+// ==================================================================\n fn match_simple_lint_emission<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n ) -> Option<&'tcx [hir::Expr<'tcx>]> {\n     LINT_EMISSION_FUNCTIONS\n         .iter()\n-        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn).map(|args| args))\n+        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n }\n \n /// This returns the lint name and the possible applicability of this emission\n@@ -316,3 +428,43 @@ fn extract_emission_info<'tcx>(cx: &LateContext<'tcx>, args: &[hir::Expr<'_>]) -\n         )\n     })\n }\n+\n+struct ValueTracker<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    value_hir_id: hir::HirId,\n+    value_life: String,\n+}\n+\n+impl<'a, 'tcx> ValueTracker<'a, 'tcx> {\n+    fn is_value_expr(&self, expr_id: hir::HirId) -> bool {\n+        match self.cx.tcx.hir().find(expr_id) {\n+            Some(hir::Node::Expr(expr)) => path_to_local_id(expr, self.value_hir_id),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Delegate<'tcx> for ValueTracker<'a, 'tcx> {\n+    fn consume(&mut self, _place_with_id: &PlaceWithHirId<'tcx>, expr_id: hir::HirId, _: ConsumeMode) {\n+        if self.is_value_expr(expr_id) {\n+            // TODO xFrednet 2021-02-17: Check if lint emission and extract lint ID\n+            todo!();\n+        }\n+    }\n+\n+    fn borrow(&mut self, _place_with_id: &PlaceWithHirId<'tcx>, expr_id: hir::HirId, bk: BorrowKind) {\n+        if self.is_value_expr(expr_id) {\n+            if let BorrowKind::MutBorrow = bk {\n+                // TODO xFrednet 2021-02-17: Save the function\n+                todo!();\n+            }\n+        }\n+    }\n+\n+    fn mutate(&mut self, _assignee_place: &PlaceWithHirId<'tcx>, expr_id: hir::HirId) {\n+        if self.is_value_expr(expr_id) {\n+            // TODO xFrednet 2021-02-17: Save the new value as a mutation\n+            todo!();\n+        }\n+    }\n+}"}]}