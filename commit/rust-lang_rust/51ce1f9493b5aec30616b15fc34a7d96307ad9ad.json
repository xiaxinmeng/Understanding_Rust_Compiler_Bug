{"sha": "51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxY2UxZjk0OTNiNWFlYzMwNjE2YjE1ZmMzNGE3ZDk2MzA3YWQ5YWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-06T10:21:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:46Z"}, "message": "formalize giving ownership of region vars to region inf. context", "tree": {"sha": "f30a3d3981abeb786705ff7040b209015336cd9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f30a3d3981abeb786705ff7040b209015336cd9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "html_url": "https://github.com/rust-lang/rust/commit/51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109c9a79ed9e17d54bd4ca2a4a8b9fbdfd29f650", "url": "https://api.github.com/repos/rust-lang/rust/commits/109c9a79ed9e17d54bd4ca2a4a8b9fbdfd29f650", "html_url": "https://github.com/rust-lang/rust/commit/109c9a79ed9e17d54bd4ca2a4a8b9fbdfd29f650"}], "stats": {"total": 190, "additions": 102, "deletions": 88}, "files": [{"sha": "84baece77fe591548ded0b094d16a80b595be4a6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -1029,6 +1029,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let var_name = self.tcx.hir.name(var_node_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n+            infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n         struct_span_err!(self.tcx.sess, var_origin.span(), E0495,"}, {"sha": "2b080c54da1f311e0436cf08d847e7a2732dcdbb", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -16,7 +16,6 @@ pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n-pub use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData};\n \n use hir::def_id::DefId;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n@@ -25,7 +24,7 @@ use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, RegionVid, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::RelateResult;\n@@ -42,6 +41,7 @@ use arena::DroplessArena;\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n+use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n@@ -321,7 +321,7 @@ pub enum LateBoundRegionConversionTime {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting` module for more details\n-#[derive(Clone, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n@@ -349,6 +349,20 @@ pub enum RegionVariableOrigin {\n     UpvarRegion(ty::UpvarId, Span),\n \n     BoundRegionInCoherence(ast::Name),\n+\n+    // This origin is used for the inference variables that we create\n+    // during NLL region processing.\n+    NLL(NLLRegionVariableOrigin),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum NLLRegionVariableOrigin {\n+    // During NLL region processing, we create variables for free\n+    // regions that we encounter in the function signature and\n+    // elsewhere. This origin indices we've got one of those.\n+    FreeRegion,\n+\n+    Inferred(::mir::visit::TyContext),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -1030,11 +1044,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .new_key(None)\n     }\n \n+    /// Create a fresh region variable with the next available index.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `origin`: information about why we created this variable, for use\n+    ///   during diagnostics / error-reporting.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n                            -> ty::Region<'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n     }\n \n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n+                               -> ty::Region<'tcx> {\n+        self.next_region_var(RegionVariableOrigin::NLL(origin))\n+    }\n+\n     /// Create a region inference variable for the given\n     /// region parameter definition.\n     pub fn region_var_for_def(&self,\n@@ -1166,19 +1192,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().take_and_reset_data()\n     }\n \n-    /// Returns the number of region variables created thus far.\n-    pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().var_origins().len()\n-    }\n-\n-    /// Returns an iterator over all region variables created thus far.\n-    pub fn all_region_vars(&self) -> impl Iterator<Item = RegionVid> {\n-        self.borrow_region_constraints().var_origins().indices()\n-    }\n-\n-    /// Returns the origin of a given region variable.\n-    pub fn region_var_origin(&self, var: RegionVid) -> RegionVariableOrigin {\n-        self.borrow_region_constraints().var_origins()[var].clone()\n+    /// Takes ownership of the list of variable regions. This implies\n+    /// that all the region constriants have already been taken, and\n+    /// hence that `resolve_regions_and_report_errors` can never be\n+    /// called. This is used only during NLL processing to \"hand off\" ownership\n+    /// of the set of region vairables into the NLL region context.\n+    pub fn take_region_var_origins(&self) -> VarOrigins {\n+        let (var_origins, data) = self.region_constraints.borrow_mut()\n+                                                         .take()\n+                                                         .expect(\"regions already resolved\")\n+                                                         .into_origins_and_data();\n+        assert!(data.is_empty());\n+        var_origins\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n@@ -1609,7 +1634,8 @@ impl RegionVariableOrigin {\n             EarlyBoundRegion(a, ..) => a,\n             LateBoundRegion(a, ..) => a,\n             BoundRegionInCoherence(_) => syntax_pos::DUMMY_SP,\n-            UpvarRegion(_, a) => a\n+            UpvarRegion(_, a) => a,\n+            NLL(..) => bug!(\"NLL variable used with `span`\"),\n         }\n     }\n }"}, {"sha": "b75163dbaa60f78acfe017d34ec5c9d5b65392a7", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -811,7 +811,7 @@ make_mir_visitor!(MutVisitor,mut);\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting."}, {"sha": "15c74f49c11610cc5597c98ac5fcb29b82761bd5", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -64,7 +64,8 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n \n     // Create the region inference context, generate the constraints,\n     // and then solve them.\n-    let mut regioncx = RegionInferenceContext::new(infcx, free_regions, mir);\n+    let var_origins = infcx.take_region_var_origins();\n+    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n     let param_env = infcx.tcx.param_env(def_id);\n     constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, param_env, liveness);\n     regioncx.solve(infcx, &mir);"}, {"sha": "24821529bade0f983d153a2bbb0315eb969cf154", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -10,6 +10,9 @@\n \n use super::free_regions::FreeRegions;\n use rustc::infer::InferCtxt;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::region_constraints::VarOrigins;\n use rustc::mir::{Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -25,23 +28,17 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n-    /// The indices of all \"free regions\" in scope. These are the\n-    /// lifetime parameters (anonymous and named) declared in the\n-    /// function signature:\n-    ///\n-    ///     fn foo<'a, 'b>(x: &Foo<'a, 'b>)\n-    ///            ^^  ^^     ^\n-    ///\n-    /// These indices will be from 0..N, as it happens, but we collect\n-    /// them into a vector for convenience.\n-    free_regions: Vec<RegionVid>,\n-\n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n }\n \n-#[derive(Default)]\n struct RegionDefinition<'tcx> {\n+    /// Why we created this variable. Mostly these will be\n+    /// `RegionVariableOrigin::NLL`, but some variables get created\n+    /// elsewhere in the code with other causes (e.g., instantiation\n+    /// late-bound-regions).\n+    origin: RegionVariableOrigin,\n+\n     /// If this is a free-region, then this is `Some(X)` where `X` is\n     /// the name of the region.\n     name: Option<ty::Region<'tcx>>,\n@@ -112,15 +109,16 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `free_regions`.\n-    pub fn new(\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        free_regions: &FreeRegions<'tcx>,\n-        mir: &Mir<'tcx>,\n-    ) -> Self {\n+    pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n+        // Create a RegionDefinition for each inference variable.\n+        let definitions = var_origins\n+            .into_iter()\n+            .map(|origin| RegionDefinition::new(origin))\n+            .collect();\n+\n         let mut result = Self {\n-            definitions: infcx.all_region_vars().map(|_| RegionDefinition::default()).collect(),\n+            definitions: definitions,\n             constraints: Vec::new(),\n-            free_regions: Vec::new(),\n         };\n \n         result.init_free_regions(free_regions, mir);\n@@ -155,7 +153,11 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n         // For each free region X:\n         for (free_region, &variable) in indices {\n-            self.free_regions.push(variable);\n+            // These should be free-region variables.\n+            assert!(match self.definitions[variable].origin {\n+                RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n+                _ => false,\n+            });\n \n             // Initialize the name and a few other details.\n             self.definitions[variable].name = Some(free_region);\n@@ -262,10 +264,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(\n-        &mut self,\n-        mir: &Mir<'tcx>,\n-    ) -> Vec<(RegionVid, Span, RegionVid)> {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) -> Vec<(RegionVid, Span, RegionVid)> {\n         let mut changed = true;\n         let mut dfs = Dfs::new(mir);\n         let mut error_regions = FxHashSet();\n@@ -393,3 +392,17 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n         changed\n     }\n }\n+\n+impl<'tcx> RegionDefinition<'tcx> {\n+    fn new(origin: RegionVariableOrigin) -> Self {\n+        // Create a new region definition. Note that, for free\n+        // regions, these fields get updated later in\n+        // `init_free_regions`.\n+        Self {\n+            origin,\n+            name: None,\n+            constant: false,\n+            value: Region::default(),\n+        }\n+    }\n+}"}, {"sha": "a7c8deb18544a48e0c70ce82aa16d43b4e31de4e", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "modified", "additions": 16, "deletions": 43, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{self, ClosureSubsts, RegionKind, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, ClosureSubsts, RegionVid, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Local, Location, Mir, Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n-use rustc::infer::{self as rustc_infer, InferCtxt};\n-use syntax_pos::DUMMY_SP;\n-use std::collections::HashMap;\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n+use super::ToRegionVid;\n use super::free_regions::FreeRegions;\n \n /// Replaces all free regions appearing in the MIR with fresh\n@@ -29,14 +28,16 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     // Create inference variables for each of the free regions\n     // declared on the function signature.\n     let free_region_inference_vars = (0..free_regions.indices.len())\n-        .map(|_| {\n-            infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        .map(RegionVid::new)\n+        .map(|vid_expected| {\n+            let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n+            assert_eq!(vid_expected, r.to_region_vid());\n+            r\n         })\n         .collect();\n \n     let mut visitor = NLLVisitor {\n         infcx,\n-        lookup_map: HashMap::new(),\n         free_regions,\n         free_region_inference_vars,\n         arg_count: mir.arg_count,\n@@ -45,7 +46,6 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    lookup_map: HashMap<RegionVid, TyContext>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     free_regions: &'a FreeRegions<'tcx>,\n     free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n@@ -56,14 +56,15 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n     /// Replaces all regions appearing in `value` with fresh inference\n     /// variables. This is what we do for almost the entire MIR, with\n     /// the exception of the declared types of our arguments.\n-    fn renumber_regions<T>(&mut self, value: &T) -> T\n+    fn renumber_regions<T>(&mut self, ty_context: TyContext, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.infcx\n             .tcx\n             .fold_regions(value, &mut false, |_region, _depth| {\n-                self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+                let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n+                self.infcx.next_nll_region_var(origin)\n             })\n     }\n \n@@ -81,26 +82,6 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn store_region(&mut self, region: &RegionKind, lookup: TyContext) {\n-        if let RegionKind::ReVar(rid) = *region {\n-            self.lookup_map.entry(rid).or_insert(lookup);\n-        }\n-    }\n-\n-    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, ty_context: TyContext) {\n-        for region in ty.regions() {\n-            self.store_region(region, ty_context);\n-        }\n-    }\n-\n-    fn store_kind_regions(&mut self, kind: &'tcx Kind, ty_context: TyContext) {\n-        if let Some(ty) = kind.as_type() {\n-            self.store_ty_regions(&ty, ty_context);\n-        } else if let Some(region) = kind.as_region() {\n-            self.store_region(region, ty_context);\n-        }\n-    }\n-\n     fn is_argument_or_return_slot(&self, local: Local) -> bool {\n         // The first argument is return slot, next N are arguments.\n         local.index() <= self.arg_count\n@@ -118,26 +99,21 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         *ty = if is_arg {\n             self.renumber_free_regions(&old_ty)\n         } else {\n-            self.renumber_regions(&old_ty)\n+            self.renumber_regions(ty_context, &old_ty)\n         };\n-        self.store_ty_regions(ty, ty_context);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{ *substs });\n         let ty_context = TyContext::Location(location);\n-        for kind in *substs {\n-            self.store_kind_regions(kind, ty_context);\n-        }\n+        *substs = self.renumber_regions(ty_context, &{ *substs });\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         match *rvalue {\n             Rvalue::Ref(ref mut r, _, _) => {\n                 let old_r = *r;\n-                *r = self.renumber_regions(&old_r);\n                 let ty_context = TyContext::Location(location);\n-                self.store_region(r, ty_context);\n+                *r = self.renumber_regions(ty_context, &old_r);\n             }\n             Rvalue::Use(..) |\n             Rvalue::Repeat(..) |\n@@ -156,11 +132,8 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_closure_substs(&mut self, substs: &mut ClosureSubsts<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(substs);\n         let ty_context = TyContext::Location(location);\n-        for kind in substs.substs {\n-            self.store_kind_regions(kind, ty_context);\n-        }\n+        *substs = self.renumber_regions(ty_context, substs);\n     }\n \n     fn visit_statement("}, {"sha": "837c3d42fe83701e5ee84e021af4e1c402dc6280", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ce1f9493b5aec30616b15fc34a7d96307ad9ad/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=51ce1f9493b5aec30616b15fc34a7d96307ad9ad", "patch": "@@ -11,8 +11,8 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n-use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime,\n-                   RegionConstraintData, UnitResult};\n+use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n+use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;"}]}