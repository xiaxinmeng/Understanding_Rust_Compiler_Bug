{"sha": "6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYmFmNGU3MDNkOGMyYjE0MTQxMDgxZDNlOTkyYjZmNTFkNWRkMTI=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-06-08T23:21:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-08T23:21:03Z"}, "message": "Rollup merge of #51394 - nnethercote:NCA-depths, r=nikomatsakis\n\nUse scope tree depths to speed up `nearest_common_ancestor`.\n\nThis patch adds depth markings to all entries in the `ScopeTree`'s\n`parent_map`. This change increases memory usage somewhat, but permits a\nmuch faster algorithm to be used:\n\n- If one scope has a greater depth than the other, the deeper scope is\n  moved upward until they are at equal depths.\n\n- Then we move the two scopes upward in lockstep until they match.\n\nThis avoids the need to keep track of which scopes have already been\nseen, which was the major part of the cost of the old algorithm. It also\nreduces the number of child-to-parent moves (which are hash table\nlookups) when the scopes start at different levels, because it never\ngoes past the nearest common ancestor the way the old algorithm did.\n\nFinally, the case where one of the scopes is the root is now handled in\nadvance, because that is moderately common and lets us skip everything.\n\nThis change speeds up runs of several rust-perf benchmarks, the best by\n6%.\n\nA selection of the bigger improvements:\n```\nclap-rs-check\n        avg: -2.6%      min: -6.6%      max: 0.0%\nsyn-check\n        avg: -2.2%      min: -5.0%      max: 0.0%\nstyle-servo-check\n        avg: -2.9%?     min: -4.8%?     max: 0.0%?\ncargo-check\n        avg: -1.3%      min: -2.8%      max: 0.0%\nsentry-cli-check\n        avg: -1.0%      min: -2.1%      max: 0.0%\nwebrender-check\n        avg: -0.9%      min: -2.0%      max: 0.0%\nstyle-servo\n        avg: -0.9%?     min: -1.8%?     max: -0.0%?\nripgrep-check\n        avg: -0.7%      min: -1.8%      max: 0.1%\nclap-rs\n        avg: -0.9%      min: -1.6%      max: -0.2%\nregex-check\n        avg: -0.2%      min: -1.3%      max: 0.1%\nsyn\n        avg: -0.6%      min: -1.3%      max: 0.1%\nhyper-check\n        avg: -0.5%      min: -1.1%      max: 0.0%\n```\nThe idea came from multiple commenters on my blog and on Reddit. Thank you!\n\nr? @nikomatsakis", "tree": {"sha": "47b5d6a95fb4e0196e5f8bee20a47f2d119bbf61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47b5d6a95fb4e0196e5f8bee20a47f2d119bbf61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbGw9fCRBK7hj4Ov3rIwAAdHIIAJBwGBZowi/MVxSgKE1l/jiJ\n9eIUxjVV/J+K8yvbBsBbFVRAHJvPP+tXrfNEfErvHi5/fixNM5bjf0TYYoD7RDnC\nPskKxIFrQdt0D2PkSyXCzH0P3cCoWX9t7vX/kEd+semBAW49pCtgft/WbGgl//dY\nTsxikNB7VtbLUPhCQ74bTExHyaN3slXpW82O6Fc3SvzmCyr9/nrcaoHr7VgS4vqA\nCY4zYOSfuqZ/iH25O3lmLRwlO9P5j0q2zFA/jzksjE7G3URWn6co62cqcCP7vQhs\n6acEv6nLxXxZsGbdjv38PslnYYzuUhrCCihjMgikmo7RPQygxODjnet3vBCEH+c=\n=mFrI\n-----END PGP SIGNATURE-----\n", "payload": "tree 47b5d6a95fb4e0196e5f8bee20a47f2d119bbf61\nparent 32ed5acf989ed843694f1ebc93610fe8b7e2cb3f\nparent 5c36e01f35c1e0290afd654367c2ba1e2353ca36\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1528500063 -0600\ncommitter GitHub <noreply@github.com> 1528500063 -0600\n\nRollup merge of #51394 - nnethercote:NCA-depths, r=nikomatsakis\n\nUse scope tree depths to speed up `nearest_common_ancestor`.\n\nThis patch adds depth markings to all entries in the `ScopeTree`'s\n`parent_map`. This change increases memory usage somewhat, but permits a\nmuch faster algorithm to be used:\n\n- If one scope has a greater depth than the other, the deeper scope is\n  moved upward until they are at equal depths.\n\n- Then we move the two scopes upward in lockstep until they match.\n\nThis avoids the need to keep track of which scopes have already been\nseen, which was the major part of the cost of the old algorithm. It also\nreduces the number of child-to-parent moves (which are hash table\nlookups) when the scopes start at different levels, because it never\ngoes past the nearest common ancestor the way the old algorithm did.\n\nFinally, the case where one of the scopes is the root is now handled in\nadvance, because that is moderately common and lets us skip everything.\n\nThis change speeds up runs of several rust-perf benchmarks, the best by\n6%.\n\nA selection of the bigger improvements:\n```\nclap-rs-check\n        avg: -2.6%      min: -6.6%      max: 0.0%\nsyn-check\n        avg: -2.2%      min: -5.0%      max: 0.0%\nstyle-servo-check\n        avg: -2.9%?     min: -4.8%?     max: 0.0%?\ncargo-check\n        avg: -1.3%      min: -2.8%      max: 0.0%\nsentry-cli-check\n        avg: -1.0%      min: -2.1%      max: 0.0%\nwebrender-check\n        avg: -0.9%      min: -2.0%      max: 0.0%\nstyle-servo\n        avg: -0.9%?     min: -1.8%?     max: -0.0%?\nripgrep-check\n        avg: -0.7%      min: -1.8%      max: 0.1%\nclap-rs\n        avg: -0.9%      min: -1.6%      max: -0.2%\nregex-check\n        avg: -0.2%      min: -1.3%      max: 0.1%\nsyn\n        avg: -0.6%      min: -1.3%      max: 0.1%\nhyper-check\n        avg: -0.5%      min: -1.1%      max: 0.0%\n```\nThe idea came from multiple commenters on my blog and on Reddit. Thank you!\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "html_url": "https://github.com/rust-lang/rust/commit/6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6abaf4e703d8c2b14141081d3e992b6f51d5dd12/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32ed5acf989ed843694f1ebc93610fe8b7e2cb3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/32ed5acf989ed843694f1ebc93610fe8b7e2cb3f", "html_url": "https://github.com/rust-lang/rust/commit/32ed5acf989ed843694f1ebc93610fe8b7e2cb3f"}, {"sha": "5c36e01f35c1e0290afd654367c2ba1e2353ca36", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c36e01f35c1e0290afd654367c2ba1e2353ca36", "html_url": "https://github.com/rust-lang/rust/commit/5c36e01f35c1e0290afd654367c2ba1e2353ca36"}], "stats": {"total": 137, "additions": 74, "deletions": 63}, "files": [{"sha": "0ba204dc20606aab5345ffe885af9e07c0131d70", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6abaf4e703d8c2b14141081d3e992b6f51d5dd12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abaf4e703d8c2b14141081d3e992b6f51d5dd12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "patch": "@@ -22,7 +22,6 @@ use ty;\n \n use std::fmt;\n use std::mem;\n-use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap;\n use syntax::ast;\n@@ -280,6 +279,8 @@ impl Scope {\n     }\n }\n \n+pub type ScopeDepth = u32;\n+\n /// The region scope tree encodes information about region relationships.\n #[derive(Default, Debug)]\n pub struct ScopeTree {\n@@ -297,7 +298,7 @@ pub struct ScopeTree {\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    parent_map: FxHashMap<Scope, Scope>,\n+    parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n@@ -415,11 +416,12 @@ pub struct Context {\n     /// details.\n     root_id: Option<hir::ItemLocalId>,\n \n-    /// the scope that contains any new variables declared\n-    var_parent: Option<Scope>,\n+    /// The scope that contains any new variables declared, plus its depth in\n+    /// the scope tree.\n+    var_parent: Option<(Scope, ScopeDepth)>,\n \n-    /// region parent of expressions etc\n-    parent: Option<Scope>,\n+    /// Region parent of expressions, etc., plus its depth in the scope tree.\n+    parent: Option<(Scope, ScopeDepth)>,\n }\n \n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n@@ -499,7 +501,7 @@ impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n }\n \n impl<'tcx> ScopeTree {\n-    pub fn record_scope_parent(&mut self, child: Scope, parent: Option<Scope>) {\n+    pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n         if let Some(p) = parent {\n@@ -515,7 +517,7 @@ impl<'tcx> ScopeTree {\n \n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(Scope, Scope) {\n         for (&child, &parent) in &self.parent_map {\n-            e(child, parent)\n+            e(child, parent.0)\n         }\n     }\n \n@@ -558,7 +560,7 @@ impl<'tcx> ScopeTree {\n \n     pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.parent_map.get(&id).cloned()\n+        self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n     #[allow(dead_code)] // used in cfg\n@@ -590,7 +592,7 @@ impl<'tcx> ScopeTree {\n         // returned.\n         let mut id = Scope::Node(expr_id);\n \n-        while let Some(&p) = self.parent_map.get(&id) {\n+        while let Some(&(p, _)) = self.parent_map.get(&id) {\n             match p.data() {\n                 ScopeData::Destruction(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n@@ -658,57 +660,61 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n-    /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n-    pub fn nearest_common_ancestor(&self,\n-                                   scope_a: Scope,\n-                                   scope_b: Scope)\n-                                   -> Scope {\n+    /// Finds the nearest common ancestor of two scopes.  That is, finds the\n+    /// smallest scope which is greater than or equal to both `scope_a` and\n+    /// `scope_b`.\n+    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n         if scope_a == scope_b { return scope_a; }\n \n-        // Process the lists in tandem from the innermost scope, recording the\n-        // scopes seen so far. The first scope that comes up for a second time\n-        // is the nearest common ancestor.\n-        //\n-        // Note: another way to compute the nearest common ancestor is to get\n-        // the full scope chain for both scopes and then compare the chains to\n-        // find the first scope in a common tail. But getting a parent scope\n-        // requires a hash table lookup, and we often have very long scope\n-        // chains (10s or 100s of scopes) that only differ by a few elements at\n-        // the start. So this algorithm is faster.\n-\n-        let mut ma = Some(&scope_a);\n-        let mut mb = Some(&scope_b);\n-\n-        // A HashSet<Scope> is a more obvious choice for these, but SmallVec is\n-        // faster because the set size is normally small so linear search is\n-        // as good or better than a hash table lookup, plus the size is usually\n-        // small enough to avoid a heap allocation.\n-        let mut seen_a: SmallVec<[&Scope; 32]> = SmallVec::new();\n-        let mut seen_b: SmallVec<[&Scope; 32]> = SmallVec::new();\n+        let mut a = scope_a;\n+        let mut b = scope_b;\n \n-        loop {\n-            if let Some(a) = ma {\n-                if seen_b.iter().any(|s| *s == a) {\n-                    return *a;\n-                }\n-                seen_a.push(a);\n-                ma = self.parent_map.get(&a);\n-            }\n+        // Get the depth of each scope's parent. If either scope has no parent,\n+        // it must be the root, which means we can stop immediately because the\n+        // root must be the nearest common ancestor. (In practice, this is\n+        // moderately common.)\n+        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n+            Some(pd) => *pd,\n+            None => return a,\n+        };\n+        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n+            Some(pd) => *pd,\n+            None => return b,\n+        };\n \n-            if let Some(b) = mb {\n-                if seen_a.iter().any(|s| *s == b) {\n-                    return *b;\n-                }\n-                seen_b.push(b);\n-                mb = self.parent_map.get(&b);\n+        if parent_a_depth > parent_b_depth {\n+            // `a` is lower than `b`. Move `a` up until it's at the same depth\n+            // as `b`. The first move up is trivial because we already found\n+            // `parent_a` above; the loop does the remaining N-1 moves.\n+            a = parent_a;\n+            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n+                a = self.parent_map.get(&a).unwrap().0;\n             }\n-\n-            if ma.is_none() && mb.is_none() {\n-                // No nearest common ancestor found.\n-                bug!();\n+        } else if parent_b_depth > parent_a_depth {\n+            // `b` is lower than `a`.\n+            b = parent_b;\n+            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n+                b = self.parent_map.get(&b).unwrap().0;\n             }\n+        } else {\n+            // Both scopes are at the same depth, and we know they're not equal\n+            // because that case was tested for at the top of this function. So\n+            // we can trivially move them both up one level now.\n+            assert!(parent_a_depth != 0);\n+            a = parent_a;\n+            b = parent_b;\n         }\n+\n+        // Now both scopes are at the same level. We move upwards in lockstep\n+        // until they match. In practice, this loop is almost always executed\n+        // zero times because `a` is almost always a direct ancestor of `b` or\n+        // vice versa.\n+        while a != b {\n+            a = self.parent_map.get(&a).unwrap().0;\n+            b = self.parent_map.get(&b).unwrap().0;\n+        };\n+\n+        a\n     }\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n@@ -807,7 +813,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n             //\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n-        Some(parent_scope) =>\n+        Some((parent_scope, _)) =>\n             visitor.scope_tree.record_var_scope(var_id, parent_scope),\n     }\n }\n@@ -1019,7 +1025,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n-                Some(&superscope) => match superscope.data() {\n+                Some(&(superscope, _)) => match superscope.data() {\n                     ScopeData::CallSite(_) => break,\n                     _ => scope = superscope\n                 },\n@@ -1036,7 +1042,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                            init: Option<&'tcx hir::Expr>) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n-    let blk_scope = visitor.cx.var_parent;\n+    let blk_scope = visitor.cx.var_parent.map(|(p, _)| p);\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n@@ -1261,16 +1267,20 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n \n impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn record_child_scope(&mut self, child_scope: Scope) {\n+    /// Returns the depth of `child_scope`.\n+    fn record_child_scope(&mut self, child_scope: Scope) -> ScopeDepth {\n         let parent = self.cx.parent;\n         self.scope_tree.record_scope_parent(child_scope, parent);\n+        // If `child_scope` has no parent, it must be the root node, and so has\n+        // a depth of 1. Otherwise, its depth is one more than its parent's.\n+        parent.map_or(1, |(_p, d)| d + 1)\n     }\n \n     /// Records the current parent (if any) as the parent of `child_scope`,\n     /// and sets `child_scope` as the new current parent.\n     fn enter_scope(&mut self, child_scope: Scope) {\n-        self.record_child_scope(child_scope);\n-        self.cx.parent = Some(child_scope);\n+        let child_depth = self.record_child_scope(child_scope);\n+        self.cx.parent = Some((child_scope, child_depth));\n     }\n \n     fn enter_node_scope_with_dtor(&mut self, id: hir::ItemLocalId) {"}, {"sha": "206e58b3e2e2764df976c384e81874b55bffa30f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abaf4e703d8c2b14141081d3e992b6f51d5dd12/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abaf4e703d8c2b14141081d3e992b6f51d5dd12/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6abaf4e703d8c2b14141081d3e992b6f51d5dd12", "patch": "@@ -191,11 +191,12 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: region::Scope) {\n+    pub fn create_region_hierarchy(&mut self, rh: &RH,\n+                                   parent: (region::Scope, region::ScopeDepth)) {\n         let me = region::Scope::Node(rh.id);\n         self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n-            self.create_region_hierarchy(child_rh, me);\n+            self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n         }\n     }\n \n@@ -215,7 +216,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                 id: hir::ItemLocalId(11),\n                 sub: &[],\n             }],\n-        }, dscope);\n+        }, (dscope, 1));\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now"}]}