{"sha": "24526cc3cc53cecb6e73275ae96b4e698b305931", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NTI2Y2MzY2M1M2NlY2I2ZTczMjc1YWU5NmI0ZTY5OGIzMDU5MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T08:35:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T08:35:26Z"}, "message": "Auto merge of #34108 - jseyfried:refactor_prelude_injection, r=nrc\n\nRefactor away the prelude injection fold\n\nInstead, just inject `#[prelude_import] use [core|std]::prelude::v1::*;` at the crate root while injecting `extern crate [core|std];` and process `#[no_implicit_prelude]` attributes in `resolve`.\n\nr? @nrc", "tree": {"sha": "a1ce26874320acac847c88f02dacbbda911d6be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1ce26874320acac847c88f02dacbbda911d6be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24526cc3cc53cecb6e73275ae96b4e698b305931", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24526cc3cc53cecb6e73275ae96b4e698b305931", "html_url": "https://github.com/rust-lang/rust/commit/24526cc3cc53cecb6e73275ae96b4e698b305931", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24526cc3cc53cecb6e73275ae96b4e698b305931/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf", "html_url": "https://github.com/rust-lang/rust/commit/dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf"}, {"sha": "970e15d3c321b8295ff6675c3bc001845ed0c0b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/970e15d3c321b8295ff6675c3bc001845ed0c0b5", "html_url": "https://github.com/rust-lang/rust/commit/970e15d3c321b8295ff6675c3bc001845ed0c0b5"}], "stats": {"total": 271, "additions": 98, "deletions": 173}, "files": [{"sha": "3ef4d7034de50c18887b065df1052a3e94a0a995", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -601,7 +601,8 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n     })?;\n \n     krate = time(time_passes, \"crate injection\", || {\n-        syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n+        let alt_std_name = sess.opts.alt_std_name.clone();\n+        syntax::std_inject::maybe_inject_crates_ref(&sess.parse_sess, krate, alt_std_name)\n     });\n \n     let mut addl_plugins = Some(addl_plugins);\n@@ -729,10 +730,6 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n                                          sess.diagnostic())\n     });\n \n-    krate = time(time_passes,\n-                 \"prelude injection\",\n-                 || syntax::std_inject::maybe_inject_prelude(&sess.parse_sess, krate));\n-\n     time(time_passes,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));"}, {"sha": "775c24b6d4a676753bb52b2ce8cf884bee510a0e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::{self, VariantKind};\n \n use syntax::ast::Name;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -57,6 +57,9 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n     pub fn build_reduced_graph(&mut self, krate: &Crate) {\n+        let no_implicit_prelude = attr::contains_name(&krate.attrs, \"no_implicit_prelude\");\n+        self.graph_root.no_implicit_prelude.set(no_implicit_prelude);\n+\n         let mut visitor = BuildReducedGraphVisitor {\n             parent: self.graph_root,\n             resolver: self,\n@@ -128,7 +131,7 @@ impl<'b> Resolver<'b> {\n                 };\n \n                 // Build up the import directives.\n-                let is_prelude = item.attrs.iter().any(|attr| attr.name() == \"prelude_import\");\n+                let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n@@ -221,6 +224,10 @@ impl<'b> Resolver<'b> {\n                 let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false);\n+                module.no_implicit_prelude.set({\n+                    parent.no_implicit_prelude.get() ||\n+                        attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n                 *parent_ref = module;"}, {"sha": "0fab12c230c0fdaee81ae7a7ebc68f8ad010d0a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -126,7 +126,7 @@ enum ResolutionError<'a> {\n     /// error E0413: cannot be named the same as an enum variant or unit-like struct in scope\n     DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n     /// error E0414: only irrefutable patterns allowed here\n-    ConstantForIrrefutableBinding(Name),\n+    ConstantForIrrefutableBinding(Name, &'a NameBinding<'a>),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n@@ -317,19 +317,15 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                 &format!(\"has same name as enum variant or unit-like struct\"));\n             err\n         }\n-        ResolutionError::ConstantForIrrefutableBinding(name) => {\n+        ResolutionError::ConstantForIrrefutableBinding(name, binding) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0414,\n                                        \"let variables cannot be named the same as const variables\");\n             err.span_label(span,\n                            &format!(\"cannot be named the same as a const variable\"));\n-            if let Some(binding) = resolver.current_module\n-                                           .resolve_name_in_lexical_scope(name, ValueNS) {\n-                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_label(binding.span, &format!(\"a constant `{}` is {} here\",\n-                               name, participle));\n-            }\n+            let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+            err.span_label(binding.span, &format!(\"a constant `{}` is {} here\", name, participle));\n             err\n         }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n@@ -714,9 +710,9 @@ enum AssocItemResolveResult {\n }\n \n #[derive(Copy, Clone)]\n-enum BareIdentifierPatternResolution {\n+enum BareIdentifierPatternResolution<'a> {\n     FoundStructOrEnumVariant(Def),\n-    FoundConst(Def, Name),\n+    FoundConst(&'a NameBinding<'a>, Name),\n     BareIdentifierPatternUnresolved,\n }\n \n@@ -792,7 +788,7 @@ pub struct ModuleS<'a> {\n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n-    prelude: RefCell<Option<Module<'a>>>,\n+    no_implicit_prelude: Cell<bool>,\n \n     glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n@@ -821,7 +817,7 @@ impl<'a> ModuleS<'a> {\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n-            prelude: RefCell::new(None),\n+            no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n@@ -985,6 +981,8 @@ pub struct Resolver<'a> {\n \n     graph_root: Module<'a>,\n \n+    prelude: Option<Module<'a>>,\n+\n     trait_item_map: FnvHashMap<(Name, DefId), bool /* is static method? */>,\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n@@ -1174,6 +1172,7 @@ impl<'a> Resolver<'a> {\n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n             graph_root: graph_root,\n+            prelude: None,\n \n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n@@ -1456,7 +1455,15 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // We can only see through anonymous modules\n-                if module.def.is_some() { return None; }\n+                if module.def.is_some() {\n+                    return match self.prelude {\n+                        Some(prelude) if !module.no_implicit_prelude.get() => {\n+                            prelude.resolve_name(name, ns, false).success()\n+                                   .map(LexicalScopeBinding::Item)\n+                        }\n+                        _ => None,\n+                    };\n+                }\n             }\n         }\n \n@@ -1543,11 +1550,7 @@ impl<'a> Resolver<'a> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n         self.populate_module_if_necessary(module);\n-        match use_lexical_scope {\n-            true => module.resolve_name_in_lexical_scope(name, namespace)\n-                          .map(Success).unwrap_or(Failed(None)),\n-            false => module.resolve_name(name, namespace, false),\n-        }.and_then(|binding| {\n+        module.resolve_name(name, namespace, use_lexical_scope).and_then(|binding| {\n             if record_used {\n                 if let NameBindingKind::Import { directive, .. } = binding.kind {\n                     self.used_imports.insert((directive.id, namespace));\n@@ -2289,21 +2292,21 @@ impl<'a> Resolver<'a> {\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n-                        FoundConst(def, _) if const_ok => {\n+                        FoundConst(binding, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n \n                             self.enforce_default_binding_mode(pattern, binding_mode, \"a constant\");\n                             self.record_def(pattern.id,\n                                             PathResolution {\n-                                                base_def: def,\n+                                                base_def: binding.def().unwrap(),\n                                                 depth: 0,\n                                             });\n                         }\n-                        FoundConst(_, name) => {\n+                        FoundConst(binding, name) => {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n-                                ResolutionError::ConstantForIrrefutableBinding(name)\n+                                ResolutionError::ConstantForIrrefutableBinding(name, binding)\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n@@ -2526,7 +2529,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_bare_identifier_pattern(&mut self, ident: ast::Ident, span: Span)\n-                                       -> BareIdentifierPatternResolution {\n+                                       -> BareIdentifierPatternResolution<'a> {\n         let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n             Some(LexicalScopeBinding::Item(binding)) => binding,\n             _ => return BareIdentifierPatternUnresolved,\n@@ -2535,7 +2538,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n             Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n-            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(def, ident.name),\n+            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(binding, ident.name),\n             Def::Static(..) => {\n                 let error = ResolutionError::StaticVariableReference(binding);\n                 resolve_error(self, span, error);\n@@ -3264,7 +3267,7 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module;\n         loop {\n             // Look for trait children.\n-            let mut search_in_module = |module: Module<'a>| {\n+            let mut search_in_module = |this: &mut Self, module: Module<'a>| {\n                 let mut traits = module.traits.borrow_mut();\n                 if traits.is_none() {\n                     let mut collected_traits = Vec::new();\n@@ -3279,23 +3282,25 @@ impl<'a> Resolver<'a> {\n \n                 for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n                     let trait_def_id = binding.def().unwrap().def_id();\n-                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                    if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         let mut import_id = None;\n                         if let NameBindingKind::Import { directive, .. } = binding.kind {\n                             let id = directive.id;\n-                            self.maybe_unused_trait_imports.insert(id);\n+                            this.maybe_unused_trait_imports.insert(id);\n                             import_id = Some(id);\n                         }\n                         add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                        self.record_use(trait_name, binding);\n+                        this.record_use(trait_name, binding);\n                     }\n                 }\n             };\n-            search_in_module(search_module);\n+            search_in_module(self, search_module);\n \n             match search_module.parent_link {\n                 NoParentLink | ModuleParentLink(..) => {\n-                    search_module.prelude.borrow().map(search_in_module);\n+                    if !search_module.no_implicit_prelude.get() {\n+                        self.prelude.map(|prelude| search_in_module(self, prelude));\n+                    }\n                     break;\n                 }\n                 BlockParentLink(parent_module, _) => {"}, {"sha": "629b687d8f72a365ac30aac96f85501cb297337a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -257,15 +257,6 @@ impl<'a> ::ModuleS<'a> {\n         Failed(None)\n     }\n \n-    // Invariant: this may not be called until import resolution is complete.\n-    pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n-                                         -> Option<&'a NameBinding<'a>> {\n-        self.resolution(name, ns).borrow().binding\n-            .or_else(|| self.prelude.borrow().and_then(|prelude| {\n-                prelude.resolve_name(name, ns, false).success()\n-            }))\n-    }\n-\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n                             -> Result<(), &'a NameBinding<'a>> {\n@@ -633,7 +624,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.resolver.populate_module_if_necessary(target_module);\n \n         if let GlobImport { is_prelude: true } = directive.subclass {\n-            *module_.prelude.borrow_mut() = Some(target_module);\n+            self.resolver.prelude = Some(target_module);\n             return Success(());\n         }\n "}, {"sha": "dc1ef5d94a4aee7136c9580a10931ec941c81273", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -1820,7 +1820,10 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n     }\n \n-    write!(w, \"</table>\")\n+    if curty.is_some() {\n+        write!(w, \"</table>\")?;\n+    }\n+    Ok(())\n }\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<String> {"}, {"sha": "8834c026067c8180a7b5624f26626ee7b0c5a063", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 47, "deletions": 125, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24526cc3cc53cecb6e73275ae96b4e698b305931/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=24526cc3cc53cecb6e73275ae96b4e698b305931", "patch": "@@ -12,12 +12,9 @@ use ast;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n-use fold::Folder;\n-use fold;\n use parse::token::{intern, InternedString, keywords};\n use parse::{token, ParseSess};\n use ptr::P;\n-use util::small_vector::SmallVector;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n@@ -37,33 +34,6 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     return sp;\n }\n \n-pub fn maybe_inject_crates_ref(krate: ast::Crate, alt_std_name: Option<String>)\n-                               -> ast::Crate {\n-    if no_core(&krate) {\n-        krate\n-    } else {\n-        let name = if no_std(&krate) {\"core\"} else {\"std\"};\n-        let mut fold = CrateInjector {\n-            item_name: token::str_to_ident(name),\n-            crate_name: token::intern(&alt_std_name.unwrap_or(name.to_string())),\n-        };\n-        fold.fold_crate(krate)\n-    }\n-}\n-\n-pub fn maybe_inject_prelude(sess: &ParseSess, krate: ast::Crate) -> ast::Crate {\n-    if no_core(&krate) {\n-        krate\n-    } else {\n-        let name = if no_std(&krate) {\"core\"} else {\"std\"};\n-        let mut fold = PreludeInjector {\n-            span: ignored_span(sess, DUMMY_SP),\n-            crate_identifier: token::str_to_ident(name),\n-        };\n-        fold.fold_crate(krate)\n-    }\n-}\n-\n pub fn no_core(krate: &ast::Crate) -> bool {\n     attr::contains_name(&krate.attrs, \"no_core\")\n }\n@@ -72,102 +42,54 @@ pub fn no_std(krate: &ast::Crate) -> bool {\n     attr::contains_name(&krate.attrs, \"no_std\") || no_core(krate)\n }\n \n-fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, \"no_implicit_prelude\")\n-}\n-\n-struct CrateInjector {\n-    item_name: ast::Ident,\n-    crate_name: ast::Name,\n-}\n-\n-impl fold::Folder for CrateInjector {\n-    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        krate.module.items.insert(0, P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: self.item_name,\n-            attrs: vec!(\n-                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n-                        InternedString::new(\"macro_use\")))),\n-            node: ast::ItemKind::ExternCrate(Some(self.crate_name)),\n-            vis: ast::Visibility::Inherited,\n-            span: DUMMY_SP\n-        }));\n-\n-        krate\n-    }\n-}\n-\n-struct PreludeInjector {\n-    span: Span,\n-    crate_identifier: ast::Ident,\n-}\n-\n-impl fold::Folder for PreludeInjector {\n-    fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        // only add `use std::prelude::*;` if there wasn't a\n-        // `#![no_implicit_prelude]` at the crate level.\n-        // fold_mod() will insert glob path.\n-        if !no_prelude(&krate.attrs) {\n-            krate.module = self.fold_mod(krate.module);\n-        }\n-        krate\n-    }\n-\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(&item.attrs) {\n-            // only recur if there wasn't `#![no_implicit_prelude]`\n-            // on this item, i.e. this means that the prelude is not\n-            // implicitly imported though the whole subtree\n-            fold::noop_fold_item(item, self)\n-        } else {\n-            SmallVector::one(item)\n-        }\n+pub fn maybe_inject_crates_ref(sess: &ParseSess,\n+                               mut krate: ast::Crate,\n+                               alt_std_name: Option<String>)\n+                               -> ast::Crate {\n+    if no_core(&krate) {\n+        return krate;\n     }\n \n-    fn fold_mod(&mut self, mut mod_: ast::Mod) -> ast::Mod {\n-        let prelude_path = ast::Path {\n-            span: self.span,\n+    let name = if no_std(&krate) { \"core\" } else { \"std\" };\n+    let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n+\n+    krate.module.items.insert(0, P(ast::Item {\n+        attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n+                                        attr::mk_word_item(InternedString::new(\"macro_use\")))],\n+        vis: ast::Visibility::Inherited,\n+        node: ast::ItemKind::ExternCrate(Some(crate_name)),\n+        ident: token::str_to_ident(name),\n+        id: ast::DUMMY_NODE_ID,\n+        span: DUMMY_SP,\n+    }));\n+\n+    let span = ignored_span(sess, DUMMY_SP);\n+    krate.module.items.insert(0, P(ast::Item {\n+        attrs: vec![ast::Attribute {\n+            node: ast::Attribute_ {\n+                style: ast::AttrStyle::Outer,\n+                value: P(ast::MetaItem {\n+                    node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n+                    span: span,\n+                }),\n+                id: attr::mk_attr_id(),\n+                is_sugared_doc: false,\n+            },\n+            span: span,\n+        }],\n+        vis: ast::Visibility::Inherited,\n+        node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n-            segments: vec![\n-                ast::PathSegment {\n-                    identifier: self.crate_identifier,\n-                    parameters: ast::PathParameters::none(),\n-                },\n-                ast::PathSegment {\n-                    identifier: token::str_to_ident(\"prelude\"),\n-                    parameters: ast::PathParameters::none(),\n-                },\n-                ast::PathSegment {\n-                    identifier: token::str_to_ident(\"v1\"),\n-                    parameters: ast::PathParameters::none(),\n-                },\n-            ],\n-        };\n-\n-        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path)));\n-        mod_.items.insert(0, P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: keywords::Invalid.ident(),\n-            node: ast::ItemKind::Use(vp),\n-            attrs: vec![ast::Attribute {\n-                span: self.span,\n-                node: ast::Attribute_ {\n-                    id: attr::mk_attr_id(),\n-                    style: ast::AttrStyle::Outer,\n-                    value: P(ast::MetaItem {\n-                        span: self.span,\n-                        node: ast::MetaItemKind::Word(\n-                            token::intern_and_get_ident(\"prelude_import\")\n-                        ),\n-                    }),\n-                    is_sugared_doc: false,\n-                },\n-            }],\n-            vis: ast::Visibility::Inherited,\n-            span: self.span,\n-        }));\n-\n-        fold::noop_fold_mod(mod_, self)\n-    }\n+            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n+                identifier: token::str_to_ident(name),\n+                parameters: ast::PathParameters::none(),\n+            }).collect(),\n+            span: span,\n+        })))),\n+        id: ast::DUMMY_NODE_ID,\n+        ident: keywords::Invalid.ident(),\n+        span: span,\n+    }));\n+\n+    krate\n }"}]}