{"sha": "91e7239db40372027a642bdbda19a6d593155a9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZTcyMzlkYjQwMzcyMDI3YTY0MmJkYmRhMTlhNmQ1OTMxNTVhOWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-30T11:24:14Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:07:16Z"}, "message": "rustc_metadata: combine DecodeContext and rbml::reader::Decoder.", "tree": {"sha": "cf2599a98ef5b2ecbab405042d4184545887d4ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf2599a98ef5b2ecbab405042d4184545887d4ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91e7239db40372027a642bdbda19a6d593155a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91e7239db40372027a642bdbda19a6d593155a9f", "html_url": "https://github.com/rust-lang/rust/commit/91e7239db40372027a642bdbda19a6d593155a9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91e7239db40372027a642bdbda19a6d593155a9f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97864d41a65d034fae21de35025e10151d765fef", "url": "https://api.github.com/repos/rust-lang/rust/commits/97864d41a65d034fae21de35025e10151d765fef", "html_url": "https://github.com/rust-lang/rust/commit/97864d41a65d034fae21de35025e10151d765fef"}], "stats": {"total": 1025, "additions": 309, "deletions": 716}, "files": [{"sha": "c201c47ef5c405f3e8903176a578268a0263209a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -495,68 +495,4 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n pub trait MacroLoader {\n      fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n-}\n-\n-/// Metadata encoding and decoding can make use of thread-local encoding and\n-/// decoding contexts. These allow implementers of serialize::Encodable and\n-/// Decodable to access information and datastructures that would otherwise not\n-/// be available to them. For example, we can automatically translate def-id and\n-/// span information during decoding because the decoding context knows which\n-/// crate the data is decoded from. Or it allows to make ty::Ty decodable\n-/// because the context has access to the TyCtxt that is needed for creating\n-/// ty::Ty instances.\n-///\n-/// Note, however, that this only works for RBML-based encoding and decoding at\n-/// the moment.\n-pub mod tls {\n-    use rbml::opaque::Decoder as OpaqueDecoder;\n-    use std::cell::Cell;\n-    use ty::{Ty, TyCtxt};\n-    use ty::subst::Substs;\n-    use hir::def_id::DefId;\n-\n-    /// Marker type used for the TLS slot.\n-    /// The type context cannot be used directly because the TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    struct TlsPayload;\n-\n-    pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n-        fn translate_def_id(&self, def_id: DefId) -> DefId;\n-    }\n-\n-    thread_local! {\n-        static TLS_DECODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given DecodingContext onto the TLS stack.\n-    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>, f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>) -> R\n-    {\n-        let tls_payload = dcx as *const _;\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_DECODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(dcx);\n-            tls.set(prev);\n-            ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context.\n-    /// FIXME(eddyb) This is horribly unsound as it allows the\n-    /// caler to pick any lifetime for 'tcx, including 'static.\n-    pub fn with_decoding_context<'tcx, F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>) -> R,\n-    {\n-        unsafe {\n-            TLS_DECODING.with(|tls| {\n-                let tls = tls.get().unwrap();\n-                f(*(tls as *mut &DecodingContext))\n-            })\n-        }\n-    }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "33110c61e8f8b1f0cf95c30f319c600f599a545d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -20,7 +20,6 @@ use dep_graph::DepNode;\n use hir::map as ast_map;\n use session::Session;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n-use middle::cstore::InlinedItem;\n use ty;\n \n use std::cell::RefCell;\n@@ -1256,19 +1255,3 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n     }\n     return maps;\n }\n-\n-pub fn resolve_inlined_item(sess: &Session,\n-                            region_maps: &RegionMaps,\n-                            item: &InlinedItem) {\n-    let mut visitor = RegionResolutionVisitor {\n-        sess: sess,\n-        region_maps: region_maps,\n-        cx: Context {\n-            root_id: None,\n-            parent: ROOT_CODE_EXTENT,\n-            var_parent: ROOT_CODE_EXTENT\n-        },\n-        terminating_scopes: NodeSet()\n-    };\n-    item.visit(&mut visitor);\n-}"}, {"sha": "c49094cb6881ec8d70360eedd6b16c26afb12cea", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -21,7 +21,7 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use middle::cstore::{self, LOCAL_CRATE};\n+use middle::cstore::LOCAL_CRATE;\n use hir::def::{Def, PathResolution, ExportMap};\n use hir::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n@@ -34,7 +34,7 @@ use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n use util::nodemap::FnvHashMap;\n \n-use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n@@ -1487,17 +1487,7 @@ impl<'tcx> Encodable for AdtDef<'tcx> {\n     }\n }\n \n-impl<'tcx> Decodable for AdtDef<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n-        let def_id: DefId = Decodable::decode(d)?;\n-\n-        cstore::tls::with_decoding_context(|dcx| {\n-            let def_id = dcx.translate_def_id(def_id);\n-            Ok(dcx.tcx().lookup_adt_def(def_id))\n-        })\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }"}, {"sha": "5176fb665fbfb79e7ce1ce3404b6a9f8eb35c084", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -10,7 +10,6 @@\n \n //! This module contains TypeVariants and its major components\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::Substs;\n@@ -25,7 +24,7 @@ use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::{keywords, InternedString};\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use serialize;\n \n use hir;\n \n@@ -253,7 +252,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -266,23 +265,7 @@ pub struct ClosureSubsts<'tcx> {\n     pub upvar_tys: &'tcx [Ty<'tcx>]\n }\n \n-impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (self.func_substs, self.upvar_tys).encode(s)\n-    }\n-}\n-\n-impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n-        let (func_substs, upvar_tys) = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(|dcx| {\n-            Ok(ClosureSubsts {\n-                func_substs: func_substs,\n-                upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n-            })\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for ClosureSubsts<'tcx> {}\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitObject<'tcx> {\n@@ -663,14 +646,7 @@ pub enum Region {\n     ReErased,\n }\n \n-impl<'tcx> Decodable for &'tcx Region {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n-        let r = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(|dcx| {\n-            Ok(dcx.tcx().mk_region(r))\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Region {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {"}, {"sha": "673a31c55abe04c62b82bdd307d444ea53cfa228", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 125, "deletions": 353, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -13,7 +13,6 @@\n #![allow(unused_must_use)]\n \n use rustc::hir::map as ast_map;\n-use rustc::session::Session;\n \n use rustc::hir;\n use rustc::hir::fold;\n@@ -23,25 +22,22 @@ use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n use common as c;\n use cstore;\n use decoder;\n-use encoder as e;\n-use tydecode;\n-use tyencode;\n+\n+use decoder::DecodeContext;\n+use encoder::EncodeContext;\n \n use middle::cstore::{InlinedItem, InlinedItemRef};\n use rustc::ty::adjustment;\n use rustc::ty::cast;\n use middle::const_qualif::ConstQualif;\n use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::DefId;\n-use middle::region;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n \n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos;\n \n-use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n \n@@ -50,23 +46,14 @@ use rbml;\n use rustc_serialize::{Decodable, Decoder, DecoderHelpers};\n use rustc_serialize::{Encodable, EncoderHelpers};\n \n-struct DecodeContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cdata: &'a cstore::CrateMetadata,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n-    // Cache the last used filemap for translating spans as an optimization.\n-    last_filemap_index: Cell<usize>,\n-}\n-\n trait tr {\n     fn tr(&self, dcx: &DecodeContext) -> Self;\n }\n \n // ______________________________________________________________________\n // Top-level methods.\n \n-pub fn encode_inlined_item(ecx: &mut e::EncodeContext, ii: InlinedItemRef) {\n+pub fn encode_inlined_item(ecx: &mut EncodeContext, ii: InlinedItemRef) {\n     let id = match ii {\n         InlinedItemRef::Item(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n@@ -81,11 +68,16 @@ pub fn encode_inlined_item(ecx: &mut e::EncodeContext, ii: InlinedItemRef) {\n     let id_range = inlined_item_id_range(&ii);\n     assert_eq!(expected_id_range, id_range);\n \n-    ecx.start_tag(c::tag_ast as usize);\n-    id_range.encode(ecx);\n-    ecx.start_tag(c::tag_tree as usize);\n-    ecx.emit_opaque(|this| ii.encode(this));\n+    ecx.start_tag(c::tag_ast);\n+\n+    ecx.start_tag(c::tag_id_range);\n+    id_range.encode(&mut ecx.opaque());\n     ecx.end_tag();\n+\n+    ecx.start_tag(c::tag_tree);\n+    ii.encode(ecx);\n+    ecx.end_tag();\n+\n     encode_side_tables_for_ii(ecx, &ii);\n     ecx.end_tag();\n \n@@ -121,54 +113,34 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let mut ast_dsr = reader::Decoder::new(ast_doc);\n-    let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-    let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n-    let dcx = &DecodeContext {\n-        cdata: cdata,\n-        tcx: tcx,\n-        from_id_range: from_id_range,\n-        to_id_range: to_id_range,\n-        last_filemap_index: Cell::new(0)\n-    };\n-    let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n+    let id_range_doc = ast_doc.get(c::tag_id_range);\n+    let from_id_range = IdRange::decode(&mut id_range_doc.opaque()).unwrap();\n+    let mut dcx = DecodeContext::new(tcx, cdata, from_id_range,\n+                                     ast_doc.get(c::tag_tree));\n+    let ii = InlinedItem::decode(&mut dcx).unwrap();\n+\n+    let ii = ast_map::map_decoded_item(&tcx.map,\n                                        parent_def_path,\n                                        parent_did,\n-                                       decode_ast(ast_doc),\n-                                       dcx);\n-    let name = match *ii {\n-        InlinedItem::Item(_, ref i) => i.name,\n-        InlinedItem::TraitItem(_, ref ti) => ti.name,\n-        InlinedItem::ImplItem(_, ref ii) => ii.name\n+                                       ii,\n+                                       &dcx);\n+\n+    let item_node_id = match ii {\n+        &InlinedItem::Item(_, ref i) => i.id,\n+        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id\n     };\n-    debug!(\"Fn named: {}\", name);\n-    debug!(\"< Decoded inlined fn: {}::{}\",\n-            tcx.item_path_str(parent_did),\n-            name);\n-    region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n-    decode_side_tables(dcx, ast_doc);\n-    copy_item_types(dcx, ii, orig_did);\n-    if let InlinedItem::Item(_, ref i) = *ii {\n-        debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-               ::rustc::hir::print::item_to_string(&i));\n-    }\n+    let inlined_did = tcx.map.local_def_id(item_node_id);\n+    tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n+\n+    decode_side_tables(&mut dcx, ast_doc);\n \n     ii\n }\n \n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-fn reserve_id_range(sess: &Session,\n-                    from_id_range: IdRange) -> IdRange {\n-    // Handle the case of an empty range:\n-    if from_id_range.empty() { return from_id_range; }\n-    let cnt = from_id_range.max - from_id_range.min;\n-    let to_id_min = sess.reserve_node_ids(cnt);\n-    let to_id_max = to_id_min + cnt;\n-    IdRange { min: to_id_min, max: to_id_max }\n-}\n-\n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     /// Translates an internal id, meaning a node id that is known to refer to some part of the\n     /// item currently being inlined, such as a local variable or argument.  All naked node-ids\n@@ -312,20 +284,9 @@ fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n     (ii, fld.id_range)\n }\n \n-fn decode_ast(item_doc: rbml::Doc) -> InlinedItem {\n-    let chi_doc = item_doc.get(c::tag_tree as usize);\n-    let mut rbml_r = reader::Decoder::new(chi_doc);\n-    rbml_r.read_opaque(|decoder, _| Decodable::decode(decoder)).unwrap()\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(dcx: &DecodeContext, dsr: &mut reader::Decoder) -> Def {\n-    let def: Def = Decodable::decode(dsr).unwrap();\n-    def.tr(dcx)\n-}\n-\n impl tr for Def {\n     fn tr(&self, dcx: &DecodeContext) -> Def {\n         match *self {\n@@ -378,11 +339,9 @@ impl tr for Def {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-impl<'a> reader::Decoder<'a> {\n-    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n-                          -> hir::Freevar {\n-        let fv: hir::Freevar = Decodable::decode(self).unwrap();\n-        fv.tr(dcx)\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    fn read_freevar_entry(&mut self) -> hir::Freevar {\n+        hir::Freevar::decode(self).unwrap().tr(self)\n     }\n }\n \n@@ -398,7 +357,7 @@ impl tr for hir::Freevar {\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n-impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_method_callee(&mut self,\n                             autoderef: u32,\n                             method: &ty::MethodCallee<'tcx>) {\n@@ -412,31 +371,29 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n                 method.def_id.encode(this)\n             });\n             this.emit_struct_field(\"ty\", 2, |this| {\n-                Ok(this.emit_ty(method.ty))\n+                method.ty.encode(this)\n             });\n             this.emit_struct_field(\"substs\", 3, |this| {\n-                Ok(this.emit_substs(&method.substs))\n+                method.substs.encode(this)\n             })\n         }).unwrap();\n     }\n }\n \n-impl<'a, 'tcx> reader::Decoder<'a> {\n-    fn read_method_callee<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                              -> (u32, ty::MethodCallee<'tcx>) {\n-\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    fn read_method_callee(&mut self)  -> (u32, ty::MethodCallee<'tcx>) {\n         self.read_struct(\"MethodCallee\", 4, |this| {\n             let autoderef = this.read_struct_field(\"autoderef\", 0,\n                                                    Decodable::decode).unwrap();\n             Ok((autoderef, ty::MethodCallee {\n                 def_id: this.read_struct_field(\"def_id\", 1, |this| {\n-                    DefId::decode(this).map(|d| d.tr(dcx))\n+                    DefId::decode(this).map(|d| d.tr(this))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    Ok(this.read_ty(dcx))\n+                    Ty::decode(this)\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(dcx))\n+                    Decodable::decode(this)\n                 }).unwrap()\n             }))\n         }).unwrap()\n@@ -446,21 +403,7 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n-    fn emit_region(&mut self, r: &'tcx ty::Region) {\n-        let cx = self.ty_str_ctxt();\n-        self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n-                                                        &cx,\n-                                                        r)));\n-    }\n-\n-    fn emit_ty(&mut self, ty: Ty<'tcx>) {\n-        let cx = self.ty_str_ctxt();\n-        self.emit_opaque(|this| Ok(tyencode::enc_ty(&mut this.cursor,\n-                                                    &cx,\n-                                                    ty)));\n-    }\n-\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn emit_upvar_capture(&mut self, capture: &ty::UpvarCapture<'tcx>) {\n         use rustc_serialize::Encoder;\n \n@@ -471,23 +414,14 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n                 }\n                 ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, region }) => {\n                     this.emit_enum_variant(\"ByRef\", 2, 0, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| kind.encode(this));\n-                        this.emit_enum_variant_arg(1,\n-                            |this| Ok(this.emit_region(region)))\n+                        this.emit_enum_variant_arg(0, |this| kind.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| region.encode(this))\n                     })\n                 }\n             }\n         }).unwrap()\n     }\n \n-    fn emit_substs(&mut self, substs: &Substs<'tcx>) {\n-        let cx = self.ty_str_ctxt();\n-        self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n-                                                        &cx,\n-                                                        substs)));\n-    }\n-\n     fn emit_auto_adjustment(&mut self, adj: &adjustment::AutoAdjustment<'tcx>) {\n         use rustc_serialize::Encoder;\n \n@@ -518,7 +452,7 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n \n                 adjustment::AdjustNeverToAny(ref ty) => {\n                     this.emit_enum_variant(\"AdjustNeverToAny\", 5, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| Ok(this.emit_ty(ty)))\n+                        this.emit_enum_variant_arg(0, |this| ty.encode(this))\n                     })\n                 }\n             }\n@@ -532,8 +466,7 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n             match autoref {\n                 &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_region(r)));\n+                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -562,24 +495,17 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n             });\n \n             this.emit_struct_field(\"unsize\", 2, |this| {\n-                this.emit_option(|this| {\n-                    match auto_deref_ref.unsize {\n-                        None => this.emit_option_none(),\n-                        Some(target) => this.emit_option_some(|this| {\n-                            Ok(this.emit_ty(target))\n-                        })\n-                    }\n-                })\n+                auto_deref_ref.unsize.encode(this)\n             })\n         });\n     }\n \n     fn tag<F>(&mut self,\n-              tag_id: c::astencode_tag,\n+              tag_id: usize,\n               f: F) where\n         F: FnOnce(&mut Self),\n     {\n-        self.start_tag(tag_id as usize);\n+        self.start_tag(tag_id);\n         f(self);\n         self.end_tag();\n     }\n@@ -590,7 +516,7 @@ impl<'a, 'tcx> e::EncodeContext<'a, 'tcx> {\n }\n \n struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n-    ecx: &'a mut e::EncodeContext<'b, 'tcx>,\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n@@ -599,15 +525,15 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: &mut e::EncodeContext, ii: &InlinedItem) {\n-    ecx.start_tag(c::tag_table as usize);\n+fn encode_side_tables_for_ii(ecx: &mut EncodeContext, ii: &InlinedItem) {\n+    ecx.start_tag(c::tag_table);\n     ii.visit(&mut SideTableEncodingIdVisitor {\n         ecx: ecx\n     });\n     ecx.end_tag();\n }\n \n-fn encode_side_tables_for_id(ecx: &mut e::EncodeContext, id: ast::NodeId) {\n+fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id {}\", id);\n@@ -622,14 +548,14 @@ fn encode_side_tables_for_id(ecx: &mut e::EncodeContext, id: ast::NodeId) {\n     if let Some(ty) = tcx.node_types().get(&id) {\n         ecx.tag(c::tag_table_node_type, |ecx| {\n             ecx.id(id);\n-            ecx.emit_ty(*ty);\n+            ty.encode(ecx);\n         })\n     }\n \n     if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n         ecx.tag(c::tag_table_item_subst, |ecx| {\n             ecx.id(id);\n-            ecx.emit_substs(&item_substs.substs);\n+            item_substs.substs.encode(ecx);\n         })\n     }\n \n@@ -707,47 +633,8 @@ fn encode_side_tables_for_id(ecx: &mut e::EncodeContext, id: ast::NodeId) {\n     }\n }\n \n-impl<'a, 'tcx> reader::Decoder<'a> {\n-    fn read_ty_encoded<'b, F, R>(&mut self, dcx: &DecodeContext<'b, 'tcx>, op: F) -> R\n-        where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x,'tcx>) -> R\n-    {\n-        return self.read_opaque(|_, doc| {\n-            debug!(\"read_ty_encoded({})\", type_string(doc));\n-            Ok(op(\n-                &mut tydecode::TyDecoder::with_doc(\n-                    dcx.tcx, dcx.cdata.cnum, doc,\n-                    &mut |d| convert_def_id(dcx, d))))\n-        }).unwrap();\n-\n-        fn type_string(doc: rbml::Doc) -> String {\n-            let mut str = String::new();\n-            for i in doc.start..doc.end {\n-                str.push(doc.data[i] as char);\n-            }\n-            str\n-        }\n-    }\n-    fn read_region<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>) -> &'tcx ty::Region {\n-        // Note: regions types embed local node ids.  In principle, we\n-        // should translate these node ids into the new decode\n-        // context.  However, we do not bother, because region types\n-        // are not used during trans. This also applies to read_ty.\n-        return self.read_ty_encoded(dcx, |decoder| decoder.parse_region());\n-    }\n-    fn read_ty<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>) -> Ty<'tcx> {\n-        return self.read_ty_encoded(dcx, |decoder| decoder.parse_ty());\n-    }\n-\n-    fn read_substs<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                       -> &'tcx Substs<'tcx> {\n-        self.read_opaque(|_, doc| {\n-            Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n-                                             &mut |d| convert_def_id(dcx, d))\n-               .parse_substs())\n-        }).unwrap()\n-    }\n-    fn read_upvar_capture<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                              -> ty::UpvarCapture<'tcx> {\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    fn read_upvar_capture(&mut self) -> ty::UpvarCapture<'tcx> {\n         self.read_enum(\"UpvarCapture\", |this| {\n             let variants = [\"ByValue\", \"ByRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -757,15 +644,14 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n                         kind: this.read_enum_variant_arg(0,\n                                   |this| Decodable::decode(this)).unwrap(),\n                         region: this.read_enum_variant_arg(1,\n-                                    |this| Ok(this.read_region(dcx))).unwrap()\n+                                    |this| Decodable::decode(this)).unwrap()\n                     }),\n                     _ => bug!(\"bad enum variant for ty::UpvarCapture\")\n                 })\n             })\n         }).unwrap()\n     }\n-    fn read_auto_adjustment<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                                -> adjustment::AutoAdjustment<'tcx> {\n+    fn read_auto_adjustment(&mut self) -> adjustment::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\",\n                             \"AdjustMutToConstPointer\", \"AdjustDerefRef\",\n@@ -778,13 +664,13 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n                     4 => {\n                         let auto_deref_ref: adjustment::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n+                                |this| Ok(this.read_auto_deref_ref())).unwrap();\n \n                         adjustment::AdjustDerefRef(auto_deref_ref)\n                     }\n                     5 => {\n                         let ty: Ty<'tcx> = this.read_enum_variant_arg(0, |this| {\n-                            Ok(this.read_ty(dcx))\n+                            Ty::decode(this)\n                         }).unwrap();\n \n                         adjustment::AdjustNeverToAny(ty)\n@@ -795,8 +681,7 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                               -> adjustment::AutoDerefRef<'tcx> {\n+    fn read_auto_deref_ref(&mut self) -> adjustment::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(adjustment::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n@@ -805,35 +690,28 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n                 autoref: this.read_struct_field(\"autoref\", 1, |this| {\n                     this.read_option(|this, b| {\n                         if b {\n-                            Ok(Some(this.read_autoref(dcx)))\n+                            Ok(Some(this.read_autoref()))\n                         } else {\n                             Ok(None)\n                         }\n                     })\n                 }).unwrap(),\n                 unsize: this.read_struct_field(\"unsize\", 2, |this| {\n-                    this.read_option(|this, b| {\n-                        if b {\n-                            Ok(Some(this.read_ty(dcx)))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    })\n+                    Decodable::decode(this)\n                 }).unwrap(),\n             })\n         }).unwrap()\n     }\n \n-    fn read_autoref<'b>(&mut self, dcx: &DecodeContext<'b, 'tcx>)\n-                        -> adjustment::AutoRef<'tcx> {\n+    fn read_autoref(&mut self) -> adjustment::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let r: &'tcx ty::Region =\n                             this.read_enum_variant_arg(0, |this| {\n-                                Ok(this.read_region(dcx))\n+                                Decodable::decode(this)\n                             }).unwrap();\n                         let m: hir::Mutability =\n                             this.read_enum_variant_arg(1, |this| {\n@@ -853,183 +731,77 @@ impl<'a, 'tcx> reader::Decoder<'a> {\n             })\n         }).unwrap()\n     }\n-\n-    fn read_cast_kind<'b>(&mut self, _dcx: &DecodeContext<'b, 'tcx>)\n-                          -> cast::CastKind\n-    {\n-        Decodable::decode(self).unwrap()\n-    }\n }\n \n-// Converts a def-id that appears in a type.  The correct\n-// translation will depend on what kind of def-id this is.\n-// This is a subtle point: type definitions are not\n-// inlined into the current crate, so if the def-id names\n-// a nominal type or type alias, then it should be\n-// translated to refer to the source crate.\n-//\n-// However, *type parameters* are cloned along with the function\n-// they are attached to.  So we should translate those def-ids\n-// to refer to the new, cloned copy of the type parameter.\n-// We only see references to free type parameters in the body of\n-// an inlined function. In such cases, we need the def-id to\n-// be a local id so that the TypeContents code is able to lookup\n-// the relevant info in the ty_param_defs table.\n-//\n-// *Region parameters*, unfortunately, are another kettle of fish.\n-// In such cases, def_id's can appear in types to distinguish\n-// shadowed bound regions and so forth. It doesn't actually\n-// matter so much what we do to these, since regions are erased\n-// at trans time, but it's good to keep them consistent just in\n-// case. We translate them with `tr_def_id()` which will map\n-// the crate numbers back to the original source crate.\n-//\n-// Scopes will end up as being totally bogus. This can actually\n-// be fixed though.\n-//\n-// Unboxed closures are cloned along with the function being\n-// inlined, and all side tables use interned node IDs, so we\n-// translate their def IDs accordingly.\n-//\n-// It'd be really nice to refactor the type repr to not include\n-// def-ids so that all these distinctions were unnecessary.\n-fn convert_def_id(dcx: &DecodeContext,\n-                  did: DefId)\n-                  -> DefId {\n-    let r = dcx.tr_def_id(did);\n-    debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n-    return r;\n-}\n+fn decode_side_tables<'a, 'tcx>(dcx: &mut DecodeContext<'a, 'tcx>,\n+                                ast_doc: rbml::Doc<'a>) {\n+    for (tag, entry_doc) in reader::docs(ast_doc.get(c::tag_table)) {\n+        dcx.rbml_r = reader::Decoder::new(entry_doc);\n \n-fn decode_side_tables(dcx: &DecodeContext,\n-                      ast_doc: rbml::Doc) {\n-    let tbl_doc = ast_doc.get(c::tag_table as usize);\n-    for (tag, entry_doc) in reader::docs(tbl_doc) {\n-        let mut entry_dsr = reader::Decoder::new(entry_doc);\n-        let id0: ast::NodeId = Decodable::decode(&mut entry_dsr).unwrap();\n+        let id0: ast::NodeId = Decodable::decode(dcx).unwrap();\n         let id = dcx.tr_id(id0);\n \n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-        let tag = tag as u32;\n-        let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n-        match decoded_tag {\n-            None => {\n-                bug!(\"unknown tag found in side tables: {:x}\", tag);\n-            }\n-            Some(value) => {\n-                let val_dsr = &mut entry_dsr;\n \n-                match value {\n-                    c::tag_table_def => {\n-                        let def = decode_def(dcx, val_dsr);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n-                    }\n-                    c::tag_table_node_type => {\n-                        let ty = val_dsr.read_ty(dcx);\n-                        debug!(\"inserting ty for node {}: {:?}\",\n-                               id,  ty);\n-                        dcx.tcx.node_type_insert(id, ty);\n-                    }\n-                    c::tag_table_item_subst => {\n-                        let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(dcx)\n-                        };\n-                        dcx.tcx.tables.borrow_mut().item_substs.insert(\n-                            id, item_substs);\n-                    }\n-                    c::tag_table_freevars => {\n-                        let fv_info = val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(val_dsr.read_freevar_entry(dcx))\n-                        }).unwrap().into_iter().collect();\n-                        dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n-                    }\n-                    c::tag_table_upvar_capture_map => {\n-                        let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n-                        let upvar_id = ty::UpvarId {\n-                            var_id: dcx.tr_id(var_id),\n-                            closure_expr_id: id\n-                        };\n-                        let ub = val_dsr.read_upvar_capture(dcx);\n-                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n-                    }\n-                    c::tag_table_method_map => {\n-                        let (autoderef, method) = val_dsr.read_method_callee(dcx);\n-                        let method_call = ty::MethodCall {\n-                            expr_id: id,\n-                            autoderef: autoderef\n-                        };\n-                        dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n-                    }\n-                    c::tag_table_adjustments => {\n-                        let adj =\n-                            val_dsr.read_auto_adjustment(dcx);\n-                        dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n-                    }\n-                    c::tag_table_cast_kinds => {\n-                        let cast_kind =\n-                            val_dsr.read_cast_kind(dcx);\n-                        dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n-                    }\n-                    c::tag_table_const_qualif => {\n-                        let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n-                    }\n-                    _ => {\n-                        bug!(\"unknown tag found in side tables: {:x}\", tag);\n-                    }\n-                }\n+        match tag {\n+            c::tag_table_def => {\n+                let def = Def::decode(dcx).unwrap().tr(dcx);\n+                dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n-        }\n-\n-        debug!(\">< Side table doc loaded\");\n-    }\n-}\n-\n-// copy the tcache entries from the original item to the new\n-// inlined item\n-fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n-    fn copy_item_type(dcx: &DecodeContext,\n-                      inlined_id: ast::NodeId,\n-                      remote_did: DefId) {\n-        let inlined_did = dcx.tcx.map.local_def_id(inlined_id);\n-        dcx.tcx.register_item_type(inlined_did,\n-                                   dcx.tcx.lookup_item_type(remote_did));\n-\n-    }\n-    // copy the entry for the item itself\n-    let item_node_id = match ii {\n-        &InlinedItem::Item(_, ref i) => i.id,\n-        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id\n-    };\n-    copy_item_type(dcx, item_node_id, orig_did);\n-\n-    // copy the entries of inner items\n-    if let &InlinedItem::Item(_, ref item) = ii {\n-        match item.node {\n-            hir::ItemEnum(ref def, _) => {\n-                let orig_def = dcx.tcx.lookup_adt_def(orig_did);\n-                for (i_variant, orig_variant) in\n-                    def.variants.iter().zip(orig_def.variants.iter())\n-                {\n-                    debug!(\"astencode: copying variant {:?} => {:?}\",\n-                           orig_variant.did, i_variant.node.data.id());\n-                    copy_item_type(dcx, i_variant.node.data.id(), orig_variant.did);\n-                }\n+            c::tag_table_node_type => {\n+                let ty = Ty::decode(dcx).unwrap();\n+                dcx.tcx.node_type_insert(id, ty);\n             }\n-            hir::ItemStruct(ref def, _) => {\n-                if !def.is_struct() {\n-                    let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n-                        .struct_variant().did;\n-                    debug!(\"astencode: copying ctor {:?} => {:?}\", ctor_did,\n-                           def.id());\n-                    copy_item_type(dcx, def.id(), ctor_did);\n-                }\n+            c::tag_table_item_subst => {\n+                let item_substs = ty::ItemSubsts {\n+                    substs: Decodable::decode(dcx).unwrap()\n+                };\n+                dcx.tcx.tables.borrow_mut().item_substs.insert(\n+                    id, item_substs);\n+            }\n+            c::tag_table_freevars => {\n+                let fv_info = dcx.read_to_vec(|dcx| {\n+                    Ok(dcx.read_freevar_entry())\n+                }).unwrap().into_iter().collect();\n+                dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n+            }\n+            c::tag_table_upvar_capture_map => {\n+                let var_id = ast::NodeId::decode(dcx).unwrap();\n+                let upvar_id = ty::UpvarId {\n+                    var_id: dcx.tr_id(var_id),\n+                    closure_expr_id: id\n+                };\n+                let ub = dcx.read_upvar_capture();\n+                dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n+            }\n+            c::tag_table_method_map => {\n+                let (autoderef, method) = dcx.read_method_callee();\n+                let method_call = ty::MethodCall {\n+                    expr_id: id,\n+                    autoderef: autoderef\n+                };\n+                dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n+            }\n+            c::tag_table_adjustments => {\n+                let adj = dcx.read_auto_adjustment();\n+                dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n+            }\n+            c::tag_table_cast_kinds => {\n+                let cast_kind = cast::CastKind::decode(dcx).unwrap();\n+                dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n+            }\n+            c::tag_table_const_qualif => {\n+                let qualif = ConstQualif::decode(dcx).unwrap();\n+                dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n+            }\n+            _ => {\n+                bug!(\"unknown tag found in side tables: {:x}\", tag);\n             }\n-            _ => {}\n         }\n+\n+        debug!(\">< Side table doc loaded\");\n     }\n }\n "}, {"sha": "c18b417466f94f7caf533c61be012af3f8f67211", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -10,8 +10,6 @@\n \n #![allow(non_camel_case_types, non_upper_case_globals)]\n \n-pub use self::astencode_tag::*;\n-\n // RBML enum definitions and utils shared by the encoder and decoder\n //\n // 0x00..0x1f: reserved for RBML generic type tags\n@@ -97,33 +95,30 @@ pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq)]\n-    #[repr(usize)]\n-    pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-        tag_ast = 0x50,\n-\n-        tag_tree = 0x51,\n-\n-        tag_mir = 0x52,\n-\n-        tag_table = 0x53,\n-        // GAP 0x54, 0x55\n-        tag_table_def = 0x56,\n-        tag_table_node_type = 0x57,\n-        tag_table_item_subst = 0x58,\n-        tag_table_freevars = 0x59,\n-        // GAP 0x5a, 0x5b, 0x5c, 0x5d, 0x5e\n-        tag_table_method_map = 0x5f,\n-        // GAP 0x60\n-        tag_table_adjustments = 0x61,\n-        // GAP 0x62, 0x63, 0x64, 0x65\n-        tag_table_upvar_capture_map = 0x66,\n-        // GAP 0x67, 0x68\n-        tag_table_const_qualif = 0x69,\n-        tag_table_cast_kinds = 0x6a,\n-    }\n-}\n+pub const tag_ast: usize = 0x50;\n+\n+pub const tag_tree: usize = 0x51;\n+\n+pub const tag_mir: usize = 0x52;\n+\n+pub const tag_table: usize = 0x53;\n+\n+pub const tag_id_range: usize = 0x54;\n+\n+// GAP 0x55\n+pub const tag_table_def: usize = 0x56;\n+pub const tag_table_node_type: usize = 0x57;\n+pub const tag_table_item_subst: usize = 0x58;\n+pub const tag_table_freevars: usize = 0x59;\n+// GAP 0x5a, 0x5b, 0x5c, 0x5d, 0x5e\n+pub const tag_table_method_map: usize = 0x5f;\n+// GAP 0x60\n+pub const tag_table_adjustments: usize = 0x61;\n+// GAP 0x62, 0x63, 0x64, 0x65\n+pub const tag_table_upvar_capture_map: usize = 0x66;\n+// GAP 0x67, 0x68\n+pub const tag_table_const_qualif: usize = 0x69;\n+pub const tag_table_cast_kinds: usize = 0x6a;\n \n pub const tag_item_trait_item_sort: usize = 0x70;\n "}, {"sha": "10c2747ab169664aa9df5bffcae0f1dbcfd74c1a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 110, "deletions": 12, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -20,7 +20,6 @@ use common::*;\n use def_key;\n use encoder::def_to_u64;\n use index;\n-use tls_context;\n use tydecode::TyDecoder;\n \n use rustc::hir::def_id::CRATE_DEF_INDEX;\n@@ -29,15 +28,17 @@ use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n+use rustc::hir::intravisit::IdRange;\n use rustc::session::config::PanicStrategy;\n \n use middle::cstore::{InlinedItem, LinkagePreference};\n-use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n+use middle::cstore::{DefLike, DlDef, DlField, DlImpl};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use rustc::ty::{ImplContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, VariantKind};\n+use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n \n@@ -47,19 +48,120 @@ use rustc::mir::repr::Location;\n \n use std::cell::Cell;\n use std::io;\n+use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::str;\n \n use rbml::reader;\n use rbml;\n-use rustc_serialize::Decodable;\n+use rustc_serialize::{Decodable, Decoder, SpecializedDecoder};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n+pub struct DecodeContext<'a, 'tcx: 'a> {\n+    pub rbml_r: rbml::reader::Decoder<'a>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub cdata: &'a cstore::CrateMetadata,\n+    pub from_id_range: IdRange,\n+    pub to_id_range: IdRange,\n+    // Cache the last used filemap for translating spans as an optimization.\n+    pub last_filemap_index: Cell<usize>,\n+}\n+\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               cdata: &'a cstore::CrateMetadata,\n+               from_id_range: IdRange,\n+               doc: rbml::Doc<'a>)\n+               -> DecodeContext<'a, 'tcx> {\n+        // Handle the case of an empty range:\n+        let to_id_range = if from_id_range.empty() {\n+            from_id_range\n+        } else {\n+            let cnt = from_id_range.max - from_id_range.min;\n+            let to_id_min = tcx.sess.reserve_node_ids(cnt);\n+            let to_id_max = to_id_min + cnt;\n+            IdRange { min: to_id_min, max: to_id_max }\n+        };\n+\n+        DecodeContext {\n+            rbml_r: reader::Decoder::new(doc),\n+            cdata: cdata,\n+            tcx: tcx,\n+            from_id_range: from_id_range,\n+            to_id_range: to_id_range,\n+            last_filemap_index: Cell::new(0)\n+        }\n+    }\n+\n+    fn read_ty_encoded<F, R>(&mut self, op: F) -> R\n+        where F: for<'x> FnOnce(&mut TyDecoder<'x,'tcx>) -> R\n+    {\n+        self.read_opaque(|this, doc| {\n+            Ok(op(&mut TyDecoder::with_doc(\n+                this.tcx, this.cdata.cnum, doc,\n+                &mut |d| this.tr_def_id(d))))\n+        }).unwrap()\n+    }\n+}\n+\n+impl<'a, 'tcx> Deref for DecodeContext<'a, 'tcx> {\n+    type Target = rbml::reader::Decoder<'a>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.rbml_r\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefMut for DecodeContext<'a, 'tcx> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.rbml_r\n+    }\n+}\n+\n+// FIXME(#36588) These impls are horribly unsound as they allow\n+// the caller to pick any lifetime for 'tcx, including 'static,\n+// by using the unspecialized proxies to them.\n+\n+impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n+        Ok(self.read_ty_encoded(|d| d.parse_ty()))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+        Ok(self.read_ty_encoded(|d| d.parse_substs()))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n+        let r = ty::Region::decode(self)?;\n+        Ok(self.tcx.mk_region(r))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<ty::ClosureSubsts<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::ClosureSubsts<'tcx>, Self::Error> {\n+        Ok(ty::ClosureSubsts {\n+            func_substs: Decodable::decode(this)?,\n+            upvar_tys: this.tcx.mk_type_list(Decodable::decode(this)?)\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n+        let def_id = DefId::decode(self)?;\n+        let def_id = translate_def_id(self.cdata, def_id);\n+        Ok(self.tcx.lookup_adt_def(def_id))\n+    }\n+}\n+\n pub type Cmd<'a> = &'a CrateMetadata;\n \n impl CrateMetadata {\n@@ -796,17 +898,13 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     let item_doc = cdata.lookup_item(id);\n \n     return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n-        let dcx = tls_context::DecodingContext {\n-            crate_metadata: cdata,\n-            tcx: tcx,\n-        };\n-        let mut decoder = reader::Decoder::new(mir_doc);\n+        let mut dcx = DecodeContext::new(tcx, cdata,\n+                                         IdRange { min: 0, max: 0 },\n+                                         mir_doc);\n \n-        let mut mir = tls::enter_decoding_context(&dcx, |_| {\n-            Decodable::decode(&mut decoder)\n-        }).unwrap();\n+        let mut mir = Decodable::decode(&mut dcx).unwrap();\n \n-        assert!(decoder.position() == mir_doc.end);\n+        assert!(dcx.rbml_r.position() == mir_doc.end);\n \n         let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n             crate_metadata: cdata,"}, {"sha": "0f7765713c3c989bf17de06229f4989d60ed26bc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -35,7 +35,7 @@ use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n-use rustc_serialize::{Encodable, SpecializedEncoder, SpecializedDecoder};\n+use rustc_serialize::{Encodable, SpecializedEncoder};\n use std::cell::RefCell;\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n@@ -97,30 +97,6 @@ impl<'a, 'tcx> SpecializedEncoder<&'tcx Substs<'tcx>> for EncodeContext<'a, 'tcx\n     }\n }\n \n-/// FIXME(#31844) This is horribly unsound as it allows the\n-/// caller to pick any lifetime for 'tcx, including 'static.\n-impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for ::rbml::reader::Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        self.read_opaque(|opaque_decoder, _| {\n-            ::middle::cstore::tls::with_decoding_context(|dcx| {\n-                Ok(dcx.decode_ty(opaque_decoder))\n-            })\n-        })\n-    }\n-}\n-\n-/// FIXME(#31844) This is horribly unsound as it allows the\n-/// caller to pick any lifetime for 'tcx, including 'static.\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for ::rbml::reader::Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        self.read_opaque(|opaque_decoder, _| {\n-            ::middle::cstore::tls::with_decoding_context(|dcx| {\n-                Ok(dcx.decode_substs(opaque_decoder))\n-            })\n-        })\n-    }\n-}\n-\n fn encode_name(ecx: &mut EncodeContext, name: Name) {\n     ecx.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }"}, {"sha": "428b33f2bfa6604eabc9248374f83e562f2d4d0a", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -61,9 +61,6 @@ pub mod rbml {\n \n pub use rustc::middle;\n \n-#[macro_use]\n-mod macros;\n-\n pub mod diagnostics;\n \n pub mod astencode;\n@@ -80,6 +77,5 @@ pub mod cstore;\n pub mod index;\n pub mod loader;\n pub mod macro_import;\n-pub mod tls_context;\n \n __build_diagnostic_array! { librustc_metadata, DIAGNOSTICS }"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc_metadata/macros.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/97864d41a65d034fae21de35025e10151d765fef/src%2Flibrustc_metadata%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97864d41a65d034fae21de35025e10151d765fef/src%2Flibrustc_metadata%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacros.rs?ref=97864d41a65d034fae21de35025e10151d765fef", "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-macro_rules! enum_from_u32 {\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant = $e),*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant,)*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    }\n-}"}, {"sha": "02acfef612a196ae42684d2384f1d1f7db6e13eb", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91e7239db40372027a642bdbda19a6d593155a9f/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=91e7239db40372027a642bdbda19a6d593155a9f", "patch": "@@ -555,20 +555,6 @@ impl<'doc> Decoder<'doc> {\n         Ok(r_doc)\n     }\n \n-    fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-    {\n-        let d = self.next_doc(exp_tag)?;\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f(self)?;\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        Ok(r)\n-    }\n-\n     fn _next_sub(&mut self) -> DecodeResult<usize> {\n         // empty vector/map optimization\n         if self.parent.is_empty() {\n@@ -670,14 +656,6 @@ impl<'doc> Decoder<'doc> {\n         Ok(r)\n     }\n \n-    pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-        where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n-    {\n-        let doc = self.next_doc(EsOpaque)?;\n-        let result = op(&mut doc.opaque(), doc)?;\n-        Ok(result)\n-    }\n-\n     pub fn position(&self) -> usize {\n         self.pos\n     }\n@@ -687,7 +665,30 @@ impl<'doc> Decoder<'doc> {\n     }\n }\n \n-impl<'doc> serialize::Decoder for Decoder<'doc> {\n+impl<'doc, 'tcx> ::decoder::DecodeContext<'doc, 'tcx> {\n+    pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n+        where F: FnOnce(&mut Self, Doc) -> DecodeResult<R>\n+    {\n+        let doc = self.next_doc(EsOpaque)?;\n+        op(self, doc)\n+    }\n+\n+    fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n+    {\n+        let d = self.next_doc(exp_tag)?;\n+        let old_parent = self.parent;\n+        let old_pos = self.pos;\n+        self.parent = d;\n+        self.pos = d.start;\n+        let r = f(self)?;\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        Ok(r)\n+    }\n+}\n+\n+impl<'doc, 'tcx> serialize::Decoder for ::decoder::DecodeContext<'doc, 'tcx> {\n     type Error = Error;\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         Ok(())\n@@ -757,7 +758,7 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_enum({})\", name);\n \n@@ -775,7 +776,7 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+        where F: FnMut(&mut Self, usize) -> DecodeResult<T>\n     {\n         debug!(\"read_enum_variant()\");\n         let idx = self._next_sub()?;\n@@ -785,14 +786,14 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+        where F: FnMut(&mut Self, usize) -> DecodeResult<T>\n     {\n         debug!(\"read_enum_struct_variant()\");\n         let idx = self._next_sub()?;\n@@ -806,28 +807,28 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n                                             idx: usize,\n                                             f: F)\n                                             -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n         f(self)\n     }\n \n     fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_struct(name={})\", name);\n         f(self)\n     }\n \n     fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         f(self)\n     }\n \n     fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_tuple()\");\n         self.read_seq(move |d, len| {\n@@ -843,28 +844,28 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(len, f)\n     }\n \n     fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n     fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n+        where F: FnMut(&mut Self, bool) -> DecodeResult<T>\n     {\n         debug!(\"read_option()\");\n         self.read_enum(\"Option\", move |this| {\n@@ -879,7 +880,7 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self, usize) -> DecodeResult<T>\n     {\n         debug!(\"read_seq()\");\n         self.push_doc(EsVec, move |d| {\n@@ -890,14 +891,14 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         self.push_doc(EsVecElt, f)\n     }\n \n     fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self, usize) -> DecodeResult<T>\n     {\n         debug!(\"read_map()\");\n         self.push_doc(EsMap, move |d| {\n@@ -908,14 +909,14 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         self.push_doc(EsMapKey, f)\n     }\n \n     fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+        where F: FnOnce(&mut Self) -> DecodeResult<T>\n     {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         self.push_doc(EsMapVal, f)"}, {"sha": "da6d04fc0ef37e9036b7187b938964952dff32c5", "filename": "src/librustc_metadata/tls_context.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/97864d41a65d034fae21de35025e10151d765fef/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97864d41a65d034fae21de35025e10151d765fef/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=97864d41a65d034fae21de35025e10151d765fef", "patch": "@@ -1,84 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This module provides implementations for the thread-local encoding and\n-// decoding context traits in rustc::middle::cstore::tls.\n-\n-use rbml::opaque::Decoder as OpaqueDecoder;\n-use rustc::middle::cstore::tls;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt};\n-\n-use decoder::{self, Cmd};\n-use tydecode::TyDecoder;\n-\n-pub struct DecodingContext<'a, 'tcx: 'a> {\n-    pub crate_metadata: Cmd<'a>,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n-\n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> Ty<'tcx> {\n-        let def_id_convert = &mut |did| {\n-            decoder::translate_def_id(self.crate_metadata, did)\n-        };\n-\n-        let starting_position = decoder.position();\n-\n-        let mut ty_decoder = TyDecoder::new(\n-            self.crate_metadata.data.as_slice(),\n-            self.crate_metadata.cnum,\n-            starting_position,\n-            self.tcx,\n-            def_id_convert);\n-\n-        let ty = ty_decoder.parse_ty();\n-\n-        let end_position = ty_decoder.position();\n-\n-        // We can just reuse the tydecode implementation for parsing types, but\n-        // we have to make sure to leave the rbml reader at the position just\n-        // after the type.\n-        decoder.advance(end_position - starting_position);\n-        ty\n-    }\n-\n-    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx> {\n-        let def_id_convert = &mut |did| {\n-            decoder::translate_def_id(self.crate_metadata, did)\n-        };\n-\n-        let starting_position = decoder.position();\n-\n-        let mut ty_decoder = TyDecoder::new(\n-            self.crate_metadata.data.as_slice(),\n-            self.crate_metadata.cnum,\n-            starting_position,\n-            self.tcx,\n-            def_id_convert);\n-\n-        let substs = ty_decoder.parse_substs();\n-\n-        let end_position = ty_decoder.position();\n-\n-        decoder.advance(end_position - starting_position);\n-        substs\n-    }\n-\n-    fn translate_def_id(&self, def_id: DefId) -> DefId {\n-        decoder::translate_def_id(self.crate_metadata, def_id)\n-    }\n-}"}]}