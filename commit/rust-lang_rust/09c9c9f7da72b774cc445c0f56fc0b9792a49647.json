{"sha": "09c9c9f7da72b774cc445c0f56fc0b9792a49647", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YzljOWY3ZGE3MmI3NzRjYzQ0NWMwZjU2ZmMwYjk3OTJhNDk2NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-19T22:26:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-19T22:26:32Z"}, "message": "Auto merge of #79060 - dtolnay:symlinkarg, r=Mark-Simulacrum\n\nDisambiguate symlink argument names\n\nThe current argument naming in the following standard library functions is horribly ambiguous.\n\n- std::os::unix::fs::symlink: https://doc.rust-lang.org/1.47.0/std/os/unix/fs/fn.symlink.html\n- std::os::windows::fs::symlink_file: https://doc.rust-lang.org/1.47.0/std/os/windows/fs/fn.symlink_file.html\n- std::os::windows::fs::symlink_dir: https://doc.rust-lang.org/1.47.0/std/os/windows/fs/fn.symlink_dir.html\n\n**Notice that Swift uses one of the same names we do (`dst`) to refer to the opposite thing.**\n\n<br>\n\n| | the&nbsp;one&nbsp;that&nbsp;exists | the&nbsp;one&nbsp;that&nbsp;is<br>being&nbsp;created | reference |\n| --- | --- | --- | --- |\n| Rust | `src` | `dst` | |\n| Swift | `withDestinationPath`<br>`destPath` | `atPath`<br>`path` | <sub>https://developer.apple.com/documentation/foundation/filemanager/1411007-createsymboliclink</sub> |\n| D | `original` | `link` | <sub>https://dlang.org/library/std/file/symlink.html</sub> |\n| Go | `oldname` | `newname` | <sub>https://golang.org/pkg/os/#Symlink</sub> |\n| C++| `target` | `link` | <sub>https://en.cppreference.com/w/cpp/filesystem/create_symlink</sub> |\n| POSIX | `path1` | `path2` | <sub>https://pubs.opengroup.org/onlinepubs/9699919799/functions/symlink.html</sub> |\n| Linux | `target` | `linkpath` | <sub>https://man7.org/linux/man-pages/man2/symlink.2.html</sub> |\n\nOut of these I happen to like D's argument names and am proposing that we adopt them.", "tree": {"sha": "33928a1b3e45601c42be1359c2811f5b9c646cb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33928a1b3e45601c42be1359c2811f5b9c646cb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09c9c9f7da72b774cc445c0f56fc0b9792a49647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09c9c9f7da72b774cc445c0f56fc0b9792a49647", "html_url": "https://github.com/rust-lang/rust/commit/09c9c9f7da72b774cc445c0f56fc0b9792a49647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09c9c9f7da72b774cc445c0f56fc0b9792a49647/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe982319aa0aa5bbfc2795791a753832292bd2ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe982319aa0aa5bbfc2795791a753832292bd2ba", "html_url": "https://github.com/rust-lang/rust/commit/fe982319aa0aa5bbfc2795791a753832292bd2ba"}, {"sha": "29128a5aa2fa5d8439c8faa92a6ee5ac94723bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/29128a5aa2fa5d8439c8faa92a6ee5ac94723bd5", "html_url": "https://github.com/rust-lang/rust/commit/29128a5aa2fa5d8439c8faa92a6ee5ac94723bd5"}], "stats": {"total": 127, "additions": 67, "deletions": 60}, "files": [{"sha": "4cff6cb6f106b48cf262bf5b9dc740de8c3fb67a", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -1698,12 +1698,14 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n \n /// Creates a new hard link on the filesystem.\n ///\n-/// The `dst` path will be a link pointing to the `src` path. Note that systems\n-/// often require these two paths to both be located on the same filesystem.\n+/// The `link` path will be a link pointing to the `original` path. Note that\n+/// systems often require these two paths to both be located on the same\n+/// filesystem.\n ///\n-/// If `src` names a symbolic link, it is platform-specific whether the symbolic\n-/// link is followed. On platforms where it's possible to not follow it, it is\n-/// not followed, and the created hard link points to the symbolic link itself.\n+/// If `original` names a symbolic link, it is platform-specific whether the\n+/// symbolic link is followed. On platforms where it's possible to not follow\n+/// it, it is not followed, and the created hard link points to the symbolic\n+/// link itself.\n ///\n /// # Platform-specific behavior\n ///\n@@ -1718,7 +1720,7 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// This function will return an error in the following situations, but is not\n /// limited to just these cases:\n ///\n-/// * The `src` path is not a file or doesn't exist.\n+/// * The `original` path is not a file or doesn't exist.\n ///\n /// # Examples\n ///\n@@ -1731,13 +1733,13 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::link(src.as_ref(), dst.as_ref())\n+pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n+    fs_imp::link(original.as_ref(), link.as_ref())\n }\n \n /// Creates a new symbolic link on the filesystem.\n ///\n-/// The `dst` path will be a symbolic link pointing to the `src` path.\n+/// The `link` path will be a symbolic link pointing to the `original` path.\n /// On Windows, this will be a file symlink, not a directory symlink;\n /// for this reason, the platform-specific [`std::os::unix::fs::symlink`]\n /// and [`std::os::windows::fs::symlink_file`] or [`symlink_dir`] should be\n@@ -1763,8 +1765,8 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n     reason = \"replaced with std::os::unix::fs::symlink and \\\n               std::os::windows::fs::{symlink_file, symlink_dir}\"\n )]\n-pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::symlink(src.as_ref(), dst.as_ref())\n+pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n+    fs_imp::symlink(original.as_ref(), link.as_ref())\n }\n \n /// Reads a symbolic link, returning the file that the link points to."}, {"sha": "a11cde9aea3e52c0913ab0dba66809204e38b42b", "filename": "library/std/src/sys/cloudabi/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -283,7 +283,7 @@ pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n     unsupported()\n }\n \n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n     unsupported()\n }\n "}, {"sha": "1807655e97170cd2973e72fffbbc22cba7a370b1", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -377,11 +377,11 @@ pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n     unsupported()\n }\n \n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n     unsupported()\n }\n \n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n     unsupported()\n }\n "}, {"sha": "ba75b9bac803593006ffb16b3e2af83604975b91", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -841,7 +841,7 @@ impl DirEntryExt for fs::DirEntry {\n \n /// Creates a new symbolic link on the filesystem.\n ///\n-/// The `dst` path will be a symbolic link pointing to the `src` path.\n+/// The `link` path will be a symbolic link pointing to the `original` path.\n ///\n /// # Examples\n ///\n@@ -854,8 +854,8 @@ impl DirEntryExt for fs::DirEntry {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    sys::fs::symlink(src.as_ref(), dst.as_ref())\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n+    sys::fs::symlink(original.as_ref(), link.as_ref())\n }\n \n /// Unix-specific extensions to [`fs::DirBuilder`]."}, {"sha": "e2f0870ef0e398c5ee06ee82ede85d157f301c5a", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -1071,28 +1071,28 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     }\n }\n \n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n-    cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })?;\n+pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n+    let original = cstr(original)?;\n+    let link = cstr(link)?;\n+    cvt(unsafe { libc::symlink(original.as_ptr(), link.as_ptr()) })?;\n     Ok(())\n }\n \n-pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n+pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n+    let original = cstr(original)?;\n+    let link = cstr(link)?;\n     cfg_if::cfg_if! {\n         if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n             // VxWorks, Redox, and old versions of Android lack `linkat`, so use\n             // `link` instead. POSIX leaves it implementation-defined whether\n             // `link` follows symlinks, so rely on the `symlink_hard_link` test\n             // in library/std/src/fs/tests.rs to check the behavior.\n-            cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+            cvt(unsafe { libc::link(original.as_ptr(), link.as_ptr()) })?;\n         } else {\n             // Use `linkat` with `AT_FDCWD` instead of `link` as `linkat` gives\n             // us a flag to specify how symlinks should be handled. Pass 0 as\n             // the flags argument, meaning don't follow symlinks.\n-            cvt(unsafe { libc::linkat(libc::AT_FDCWD, src.as_ptr(), libc::AT_FDCWD, dst.as_ptr(), 0) })?;\n+            cvt(unsafe { libc::linkat(libc::AT_FDCWD, original.as_ptr(), libc::AT_FDCWD, link.as_ptr(), 0) })?;\n         }\n     }\n     Ok(())"}, {"sha": "4271d9b334588b888d8cbca52a9e0ad2aba2c15c", "filename": "library/std/src/sys/unsupported/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -279,7 +279,7 @@ pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n     unsupported()\n }\n \n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+pub fn symlink(_original: &Path, _link: &Path) -> io::Result<()> {\n     unsupported()\n }\n "}, {"sha": "120b9f59f1e991e48aa05e571ef641db0d62734e", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -549,19 +549,19 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n     }\n }\n \n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst)?;\n-    dst.symlink(osstr2str(src.as_ref())?, osstr2str(dst_file.as_ref())?)\n+pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n+    let (link, link_file) = open_parent(link)?;\n+    link.symlink(osstr2str(original.as_ref())?, osstr2str(link_file.as_ref())?)\n }\n \n-pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src)?;\n-    let (dst, dst_file) = open_parent(dst)?;\n-    src.link(\n+pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n+    let (original, original_file) = open_parent(original)?;\n+    let (link, link_file) = open_parent(link)?;\n+    original.link(\n         wasi::LOOKUPFLAGS_SYMLINK_FOLLOW,\n-        osstr2str(src_file.as_ref())?,\n-        &dst,\n-        osstr2str(dst_file.as_ref())?,\n+        osstr2str(original_file.as_ref())?,\n+        &link,\n+        osstr2str(link_file.as_ref())?,\n     )\n }\n "}, {"sha": "b20eafb4d53a59396a629ea903fda96b33e5e7a0", "filename": "library/std/src/sys/windows/ext/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -519,7 +519,7 @@ impl FileTypeExt for fs::FileType {\n \n /// Creates a new file symbolic link on the filesystem.\n ///\n-/// The `dst` path will be a file symbolic link pointing to the `src`\n+/// The `link` path will be a file symbolic link pointing to the `original`\n /// path.\n ///\n /// # Examples\n@@ -533,13 +533,13 @@ impl FileTypeExt for fs::FileType {\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n+pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n+    sys::fs::symlink_inner(original.as_ref(), link.as_ref(), false)\n }\n \n /// Creates a new directory symlink on the filesystem.\n ///\n-/// The `dst` path will be a directory symbolic link pointing to the `src`\n+/// The `link` path will be a directory symbolic link pointing to the `original`\n /// path.\n ///\n /// # Examples\n@@ -553,6 +553,6 @@ pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Resul\n /// }\n /// ```\n #[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n+pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(original: P, link: Q) -> io::Result<()> {\n+    sys::fs::symlink_inner(original.as_ref(), link.as_ref(), true)\n }"}, {"sha": "307a47678c6a2832c94f53eccdfdf2fc563983d0", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09c9c9f7da72b774cc445c0f56fc0b9792a49647/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=09c9c9f7da72b774cc445c0f56fc0b9792a49647", "patch": "@@ -759,30 +759,32 @@ pub fn readlink(path: &Path) -> io::Result<PathBuf> {\n     file.readlink()\n }\n \n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    symlink_inner(src, dst, false)\n+pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n+    symlink_inner(original, link, false)\n }\n \n-pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n-    let src = to_u16s(src)?;\n-    let dst = to_u16s(dst)?;\n+pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> {\n+    let original = to_u16s(original)?;\n+    let link = to_u16s(link)?;\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     // Formerly, symlink creation required the SeCreateSymbolicLink privilege. For the Windows 10\n     // Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the\n     // computer is in Developer Mode, but SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE must be\n     // added to dwFlags to opt into this behaviour.\n     let result = cvt(unsafe {\n         c::CreateSymbolicLinkW(\n-            dst.as_ptr(),\n-            src.as_ptr(),\n+            link.as_ptr(),\n+            original.as_ptr(),\n             flags | c::SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n         ) as c::BOOL\n     });\n     if let Err(err) = result {\n         if err.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) {\n             // Older Windows objects to SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE,\n             // so if we encounter ERROR_INVALID_PARAMETER, retry without that flag.\n-            cvt(unsafe { c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL })?;\n+            cvt(unsafe {\n+                c::CreateSymbolicLinkW(link.as_ptr(), original.as_ptr(), flags) as c::BOOL\n+            })?;\n         } else {\n             return Err(err);\n         }\n@@ -791,15 +793,15 @@ pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n }\n \n #[cfg(not(target_vendor = \"uwp\"))]\n-pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = to_u16s(src)?;\n-    let dst = to_u16s(dst)?;\n-    cvt(unsafe { c::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut()) })?;\n+pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n+    let original = to_u16s(original)?;\n+    let link = to_u16s(link)?;\n+    cvt(unsafe { c::CreateHardLinkW(link.as_ptr(), original.as_ptr(), ptr::null_mut()) })?;\n     Ok(())\n }\n \n #[cfg(target_vendor = \"uwp\")]\n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n     return Err(io::Error::new(io::ErrorKind::Other, \"hard link are not supported on UWP\"));\n }\n \n@@ -883,8 +885,11 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n }\n \n #[allow(dead_code)]\n-pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    symlink_junction_inner(src.as_ref(), dst.as_ref())\n+pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(\n+    original: P,\n+    junction: Q,\n+) -> io::Result<()> {\n+    symlink_junction_inner(original.as_ref(), junction.as_ref())\n }\n \n // Creating a directory junction on windows involves dealing with reparse\n@@ -893,7 +898,7 @@ pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::R\n //\n // http://www.flexhex.com/docs/articles/hard-links.phtml\n #[allow(dead_code)]\n-fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n+fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     let d = DirBuilder::new();\n     d.mkdir(&junction)?;\n \n@@ -911,7 +916,7 @@ fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n         // FIXME: this conversion is very hacky\n         let v = br\"\\??\\\";\n         let v = v.iter().map(|x| *x as u16);\n-        for c in v.chain(target.as_os_str().encode_wide()) {\n+        for c in v.chain(original.as_os_str().encode_wide()) {\n             *buf.offset(i) = c;\n             i += 1;\n         }"}]}