{"sha": "e015ef5b2633960e7653b744d7a1c3d1d336313a", "node_id": "C_kwDOAAsO6NoAKGUwMTVlZjViMjYzMzk2MGU3NjUzYjc0NGQ3YTFjM2QxZDMzNjMxM2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-21T08:04:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-21T08:04:19Z"}, "message": "Auto merge of #90119 - JohnTitor:rollup-e5t6khz, r=JohnTitor\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #86984 (Reject octal zeros in IPv4 addresses)\n - #87440 (Remove unnecessary condition in Barrier::wait())\n - #88644 (`AbstractConst` private fields)\n - #89292 (Stabilize CString::from_vec_with_nul[_unchecked])\n - #90010 (Avoid overflow in `VecDeque::with_capacity_in()`.)\n - #90029 (Add test for debug logging during incremental compilation)\n - #90031 (config: add the option to enable LLVM tests)\n - #90048 (Add test for line-number setting)\n - #90071 (Remove hir::map::blocks and use FnKind instead)\n - #90074 (2229 migrations small cleanup)\n - #90077 (Make `From` impls of NonZero integer const.)\n - #90097 (Add test for duplicated sidebar entries for reexported macro)\n - #90098 (Add test to ensure that the missing_doc_code_examples is not triggered on foreign trait implementations)\n - #90099 (Fix MIRI UB in `Vec::swap_remove`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b97de10e82d74e3f73f4bc12e0fbcb66a1df5a65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b97de10e82d74e3f73f4bc12e0fbcb66a1df5a65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e015ef5b2633960e7653b744d7a1c3d1d336313a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e015ef5b2633960e7653b744d7a1c3d1d336313a", "html_url": "https://github.com/rust-lang/rust/commit/e015ef5b2633960e7653b744d7a1c3d1d336313a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e015ef5b2633960e7653b744d7a1c3d1d336313a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ebd073829959d47b977c168096968a6ed753f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ebd073829959d47b977c168096968a6ed753f9", "html_url": "https://github.com/rust-lang/rust/commit/40ebd073829959d47b977c168096968a6ed753f9"}, {"sha": "3680ecd8a6e8dcac98833bc8bbc349277f780419", "url": "https://api.github.com/repos/rust-lang/rust/commits/3680ecd8a6e8dcac98833bc8bbc349277f780419", "html_url": "https://github.com/rust-lang/rust/commit/3680ecd8a6e8dcac98833bc8bbc349277f780419"}], "stats": {"total": 569, "additions": 227, "deletions": 342}, "files": [{"sha": "80551518d3c5d8bdbe10341d2fd5d98e8ec1dafb", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1,6 +1,5 @@\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n@@ -44,8 +43,8 @@ fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         } else {\n             false\n         }\n-    } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n-        if fn_like.constness() == hir::Constness::Const {\n+    } else if let Some(fn_kind) = node.fn_kind() {\n+        if fn_kind.constness() == hir::Constness::Const {\n             return true;\n         }\n "}, {"sha": "6f25715fbecc47b4829c0b660f07b878361d5246", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1,6 +1,7 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::{HirId, ItemLocalId};\n+use crate::intravisit::FnKind;\n use crate::LangItem;\n \n use rustc_ast::util::parser::ExprPrecedence;\n@@ -3258,6 +3259,32 @@ impl<'hir> Node<'hir> {\n             _ => None,\n         }\n     }\n+\n+    pub fn fn_kind(self) -> Option<FnKind<'hir>> {\n+        match self {\n+            Node::Item(i) => match i.kind {\n+                ItemKind::Fn(ref sig, ref generics, _) => {\n+                    Some(FnKind::ItemFn(i.ident, generics, sig.header, &i.vis))\n+                }\n+                _ => None,\n+            },\n+            Node::TraitItem(ti) => match ti.kind {\n+                TraitItemKind::Fn(ref sig, TraitFn::Provided(_)) => {\n+                    Some(FnKind::Method(ti.ident, sig, None))\n+                }\n+                _ => None,\n+            },\n+            Node::ImplItem(ii) => match ii.kind {\n+                ImplItemKind::Fn(ref sig, _) => Some(FnKind::Method(ii.ident, sig, Some(&ii.vis))),\n+                _ => None,\n+            },\n+            Node::Expr(e) => match e.kind {\n+                ExprKind::Closure(..) => Some(FnKind::Closure),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "cff543760f42af954123f20e1bd85c4876e92e02", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -117,6 +117,14 @@ impl<'a> FnKind<'a> {\n             FnKind::Closure => None,\n         }\n     }\n+\n+    pub fn constness(self) -> Constness {\n+        self.header().map_or(Constness::NotConst, |header| header.constness)\n+    }\n+\n+    pub fn asyncness(self) -> IsAsync {\n+        self.header().map_or(IsAsync::NotAsync, |header| header.asyncness)\n+    }\n }\n \n /// An abstract representation of the HIR `rustc_middle::hir::map::Map`."}, {"sha": "90bc5b3b2fed1296849bd54b73816031674f7747", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -143,9 +143,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // similar to the asyncness fn in rustc_ty_utils::ty\n         let hir_id = self.tcx().hir().local_def_id_to_hir_id(local_def_id);\n         let node = self.tcx().hir().get(hir_id);\n-        let fn_like = rustc_middle::hir::map::blocks::FnLikeNode::from_node(node)?;\n-\n-        Some(fn_like.asyncness())\n+        let fn_kind = node.fn_kind()?;\n+        Some(fn_kind.asyncness())\n     }\n \n     // Here, we check for the case where the anonymous region"}, {"sha": "8efec8ef5674d6b19b4dabbd2c39db46d243dd18", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "removed", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/40ebd073829959d47b977c168096968a6ed753f9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40ebd073829959d47b977c168096968a6ed753f9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=40ebd073829959d47b977c168096968a6ed753f9", "patch": "@@ -1,239 +0,0 @@\n-//! This module provides a simplified abstraction for working with\n-//! code blocks identified by their integer `NodeId`. In particular,\n-//! it captures a common set of attributes that all \"function-like\n-//! things\" (represented by `FnLike` instances) share. For example,\n-//! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred). And all `FnLike` instances have a body, i.e., the code\n-//! that is run when the function-like thing it represents is invoked.\n-//!\n-//! With the above abstraction in place, one can treat the program\n-//! text as a collection of blocks of code (and most such blocks are\n-//! nested within a uniquely determined `FnLike`), and users can ask\n-//! for the `Code` associated with a particular NodeId.\n-\n-use crate::hir::map::Map;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Expr, FnDecl, Node};\n-use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n-\n-/// An FnLikeNode is a Node that is like a fn, in that it has a decl\n-/// and a body (as well as a NodeId, a span, etc).\n-///\n-/// More specifically, it is one of either:\n-///\n-///   - A function item,\n-///   - A closure expr (i.e., an ExprKind::Closure), or\n-///   - The default implementation for a trait method.\n-///\n-/// To construct one, use the `Code::from_node` function.\n-#[derive(Copy, Clone, Debug)]\n-pub struct FnLikeNode<'a> {\n-    node: Node<'a>,\n-}\n-\n-/// MaybeFnLike wraps a method that indicates if an object\n-/// corresponds to some FnLikeNode.\n-trait MaybeFnLike {\n-    fn is_fn_like(&self) -> bool;\n-}\n-\n-impl MaybeFnLike for hir::Item<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ItemKind::Fn(..))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::ImplItem<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ImplItemKind::Fn(..))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::TraitItem<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::Expr<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ExprKind::Closure(..))\n-    }\n-}\n-\n-/// Carries either an FnLikeNode or an Expr, as these are the two\n-/// constructs that correspond to \"code\" (as in, something from which\n-/// we can construct a control-flow graph).\n-#[derive(Copy, Clone)]\n-pub enum Code<'a> {\n-    FnLike(FnLikeNode<'a>),\n-    Expr(&'a Expr<'a>),\n-}\n-\n-impl<'a> Code<'a> {\n-    pub fn id(&self) -> hir::HirId {\n-        match *self {\n-            Code::FnLike(node) => node.id(),\n-            Code::Expr(block) => block.hir_id,\n-        }\n-    }\n-\n-    /// Attempts to construct a Code from presumed FnLike or Expr node input.\n-    pub fn from_node(map: &Map<'a>, id: hir::HirId) -> Option<Code<'a>> {\n-        match map.get(id) {\n-            Node::Block(_) => {\n-                //  Use the parent, hopefully an expression node.\n-                Code::from_node(map, map.get_parent_node(id))\n-            }\n-            Node::Expr(expr) => Some(Code::Expr(expr)),\n-            node => FnLikeNode::from_node(node).map(Code::FnLike),\n-        }\n-    }\n-}\n-\n-/// These are all the components one can extract from a fn item for\n-/// use when implementing FnLikeNode operations.\n-struct ItemFnParts<'a> {\n-    ident: Ident,\n-    decl: &'a hir::FnDecl<'a>,\n-    header: hir::FnHeader,\n-    vis: &'a hir::Visibility<'a>,\n-    generics: &'a hir::Generics<'a>,\n-    body: hir::BodyId,\n-    id: hir::HirId,\n-    span: Span,\n-}\n-\n-/// These are all the components one can extract from a closure expr\n-/// for use when implementing FnLikeNode operations.\n-struct ClosureParts<'a> {\n-    decl: &'a FnDecl<'a>,\n-    body: hir::BodyId,\n-    id: hir::HirId,\n-    span: Span,\n-}\n-\n-impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl<'a>, b: hir::BodyId, id: hir::HirId, s: Span) -> Self {\n-        ClosureParts { decl: d, body: b, id, span: s }\n-    }\n-}\n-\n-impl<'a> FnLikeNode<'a> {\n-    /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n-    pub fn from_node(node: Node<'_>) -> Option<FnLikeNode<'_>> {\n-        let fn_like = match node {\n-            Node::Item(item) => item.is_fn_like(),\n-            Node::TraitItem(tm) => tm.is_fn_like(),\n-            Node::ImplItem(it) => it.is_fn_like(),\n-            Node::Expr(e) => e.is_fn_like(),\n-            _ => false,\n-        };\n-        fn_like.then_some(FnLikeNode { node })\n-    }\n-\n-    pub fn body(self) -> hir::BodyId {\n-        self.handle(\n-            |i: ItemFnParts<'a>| i.body,\n-            |_, _, _: &'a hir::FnSig<'a>, _, body: hir::BodyId, _| body,\n-            |c: ClosureParts<'a>| c.body,\n-        )\n-    }\n-\n-    pub fn decl(self) -> &'a FnDecl<'a> {\n-        self.handle(\n-            |i: ItemFnParts<'a>| &*i.decl,\n-            |_, _, sig: &'a hir::FnSig<'a>, _, _, _| &sig.decl,\n-            |c: ClosureParts<'a>| c.decl,\n-        )\n-    }\n-\n-    pub fn span(self) -> Span {\n-        self.handle(\n-            |i: ItemFnParts<'_>| i.span,\n-            |_, _, _: &'a hir::FnSig<'a>, _, _, span| span,\n-            |c: ClosureParts<'_>| c.span,\n-        )\n-    }\n-\n-    pub fn id(self) -> hir::HirId {\n-        self.handle(\n-            |i: ItemFnParts<'_>| i.id,\n-            |id, _, _: &'a hir::FnSig<'a>, _, _, _| id,\n-            |c: ClosureParts<'_>| c.id,\n-        )\n-    }\n-\n-    pub fn constness(self) -> hir::Constness {\n-        self.kind().header().map_or(hir::Constness::NotConst, |header| header.constness)\n-    }\n-\n-    pub fn asyncness(self) -> hir::IsAsync {\n-        self.kind().header().map_or(hir::IsAsync::NotAsync, |header| header.asyncness)\n-    }\n-\n-    pub fn unsafety(self) -> hir::Unsafety {\n-        self.kind().header().map_or(hir::Unsafety::Normal, |header| header.unsafety)\n-    }\n-\n-    pub fn kind(self) -> FnKind<'a> {\n-        let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.ident, p.generics, p.header, p.vis)\n-        };\n-        let closure = |_: ClosureParts<'a>| FnKind::Closure;\n-        let method =\n-            |_, ident: Ident, sig: &'a hir::FnSig<'a>, vis, _, _| FnKind::Method(ident, sig, vis);\n-        self.handle(item, method, closure)\n-    }\n-\n-    fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A\n-    where\n-        I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(\n-            hir::HirId,\n-            Ident,\n-            &'a hir::FnSig<'a>,\n-            Option<&'a hir::Visibility<'a>>,\n-            hir::BodyId,\n-            Span,\n-        ) -> A,\n-        C: FnOnce(ClosureParts<'a>) -> A,\n-    {\n-        match self.node {\n-            Node::Item(i) => match i.kind {\n-                hir::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n-                    id: i.hir_id(),\n-                    ident: i.ident,\n-                    decl: &sig.decl,\n-                    body: block,\n-                    vis: &i.vis,\n-                    span: i.span,\n-                    header: sig.header,\n-                    generics,\n-                }),\n-                _ => bug!(\"item FnLikeNode that is not fn-like\"),\n-            },\n-            Node::TraitItem(ti) => match ti.kind {\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    method(ti.hir_id(), ti.ident, sig, None, body, ti.span)\n-                }\n-                _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n-            },\n-            Node::ImplItem(ii) => match ii.kind {\n-                hir::ImplItemKind::Fn(ref sig, body) => {\n-                    method(ii.hir_id(), ii.ident, sig, Some(&ii.vis), body, ii.span)\n-                }\n-                _ => bug!(\"impl method FnLikeNode that is not fn-like\"),\n-            },\n-            Node::Expr(e) => match e.kind {\n-                hir::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) => {\n-                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span))\n-                }\n-                _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n-            },\n-            _ => bug!(\"other FnLikeNode that is not fn-like\"),\n-        }\n-    }\n-}"}, {"sha": "fad7e875fa1c025ac4a6434aab0c109d76aece10", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -20,8 +20,6 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n use std::collections::VecDeque;\n \n-pub mod blocks;\n-\n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n         Node::Item(Item { kind: ItemKind::Fn(sig, _, _), .. })"}, {"sha": "e4c2d2dce67c7d3883b5614c3e23599a74626e59", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -2,7 +2,6 @@ use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::intravisit::FnKind;\n-use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n@@ -14,8 +13,8 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n-        if let FnKind::Closure = fn_like_node.kind() {\n+    if let Some(fn_kind) = tcx.hir().get(hir_id).fn_kind() {\n+        if let FnKind::Closure = fn_kind {\n             // closures can't recur, so they don't matter.\n             return;\n         }"}, {"sha": "63c637af5c21a39ae94067abde5c52efc531b007", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -68,11 +68,10 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             return;\n         }\n \n-        use rustc_middle::hir::map::blocks::FnLikeNode;\n         let def_id = body.source.def_id().expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n         let is_assoc_const = tcx.def_kind(def_id.to_def_id()) == DefKind::AssocConst;\n \n         // Only run const prop on functions, methods, closures and associated constants"}, {"sha": "4ac93f716192308709d3c18b73b58d8cb63041f6", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir;\n-use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::dump_enabled;\n@@ -64,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n         }\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(mir_source.def_id().expect_local());\n-        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n \n         // Only instrument functions, methods, and closures (not constants since they are evaluated\n         // at compile time by Miri).\n@@ -74,7 +73,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n         // be tricky if const expressions have no corresponding statements in the enclosing MIR.\n         // Closures are carved out by their initial `Assign` statement.)\n         if !is_fn_like {\n-            trace!(\"InstrumentCoverage skipped for {:?} (not an FnLikeNode)\", mir_source.def_id());\n+            trace!(\"InstrumentCoverage skipped for {:?} (not an fn-like)\", mir_source.def_id());\n             return;\n         }\n "}, {"sha": "ab1fe6fe077a74b3b72c2bf8a03cac720b9aa425", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -429,8 +429,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     }\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-    use rustc_middle::hir::map::blocks::FnLikeNode;\n-    let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+    let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n     if is_fn_like {\n         let did = def.did.to_def_id();\n         let def = ty::WithOptConstParam::unknown(did);"}, {"sha": "4d4e9432e876dc21f9d88cfd9019735a0175d425", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::span_bug;\n use rustc_middle::thir::abstract_const::Node as ACNode;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n@@ -153,11 +153,8 @@ where\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n-        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root() {\n-            ACNode::Leaf(leaf) => {\n-                let leaf = leaf.subst(tcx, ct.substs);\n-                self.visit_const(leaf)\n-            }\n+        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n+            ACNode::Leaf(leaf) => self.visit_const(leaf),\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n                 ControlFlow::CONTINUE"}, {"sha": "8edb7069fc45f9a19c55f3c66f75a0bc79b9870f", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -80,9 +80,8 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                     Concrete,\n                 }\n                 let mut failure_kind = FailureKind::Concrete;\n-                walk_abstract_const::<!, _>(tcx, ct, |node| match node.root() {\n+                walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n                     Node::Leaf(leaf) => {\n-                        let leaf = leaf.subst(tcx, ct.substs);\n                         if leaf.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n                         } else if leaf.definitely_has_param_types_or_consts(tcx) {\n@@ -92,7 +91,6 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         ControlFlow::CONTINUE\n                     }\n                     Node::Cast(_, _, ty) => {\n-                        let ty = ty.subst(tcx, ct.substs);\n                         if ty.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n                         } else if ty.definitely_has_param_types_or_consts(tcx) {\n@@ -187,8 +185,8 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n pub struct AbstractConst<'tcx> {\n     // FIXME: Consider adding something like `IndexSlice`\n     // and use this here.\n-    pub inner: &'tcx [Node<'tcx>],\n-    pub substs: SubstsRef<'tcx>,\n+    inner: &'tcx [Node<'tcx>],\n+    substs: SubstsRef<'tcx>,\n }\n \n impl<'tcx> AbstractConst<'tcx> {\n@@ -218,8 +216,14 @@ impl<'tcx> AbstractConst<'tcx> {\n     }\n \n     #[inline]\n-    pub fn root(self) -> Node<'tcx> {\n-        self.inner.last().copied().unwrap()\n+    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n+        let node = self.inner.last().copied().unwrap();\n+        match node {\n+            Node::Leaf(leaf) => Node::Leaf(leaf.subst(tcx, self.substs)),\n+            Node::Cast(kind, operand, ty) => Node::Cast(kind, operand, ty.subst(tcx, self.substs)),\n+            // Don't perform substitution on the following as they can't directly contain generic params\n+            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n+        }\n     }\n }\n \n@@ -542,7 +546,7 @@ where\n         f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n     ) -> ControlFlow<R> {\n         f(ct)?;\n-        let root = ct.root();\n+        let root = ct.root(tcx);\n         match root {\n             Node::Leaf(_) => ControlFlow::CONTINUE,\n             Node::Binop(_, l, r) => {\n@@ -570,27 +574,23 @@ pub(super) fn try_unify<'tcx>(\n     // We substitute generics repeatedly to allow AbstractConsts to unify where a\n     // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n     // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    while let Node::Leaf(a_ct) = a.root() {\n-        let a_ct = a_ct.subst(tcx, a.substs);\n+    while let Node::Leaf(a_ct) = a.root(tcx) {\n         match AbstractConst::from_const(tcx, a_ct) {\n             Ok(Some(a_act)) => a = a_act,\n             Ok(None) => break,\n             Err(_) => return true,\n         }\n     }\n-    while let Node::Leaf(b_ct) = b.root() {\n-        let b_ct = b_ct.subst(tcx, b.substs);\n+    while let Node::Leaf(b_ct) = b.root(tcx) {\n         match AbstractConst::from_const(tcx, b_ct) {\n             Ok(Some(b_act)) => b = b_act,\n             Ok(None) => break,\n             Err(_) => return true,\n         }\n     }\n \n-    match (a.root(), b.root()) {\n+    match (a.root(tcx), b.root(tcx)) {\n         (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-            let a_ct = a_ct.subst(tcx, a.substs);\n-            let b_ct = b_ct.subst(tcx, b.substs);\n             if a_ct.ty != b_ct.ty {\n                 return false;\n             }"}, {"sha": "afc546540d2e262d99c2818a6125805a07746eb6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -837,14 +837,13 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n             // constants which are not considered const evaluatable.\n             use rustc_middle::thir::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n-                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n-                    Node::Leaf(leaf) => {\n-                        let leaf = leaf.subst(self.tcx, ct.substs);\n-                        self.visit_const(leaf)\n-                    }\n-                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n+                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| {\n+                    match node.root(self.tcx) {\n+                        Node::Leaf(leaf) => self.visit_const(leaf),\n+                        Node::Cast(_, _, ty) => self.visit_ty(ty),\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                            ControlFlow::CONTINUE\n+                        }\n                     }\n                 })\n             } else {"}, {"sha": "bc77c94809eb58ca47c0f47932b3c6a0f20e08d0", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{\n     self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n@@ -478,11 +477,11 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n \n     let node = tcx.hir().get(hir_id);\n \n-    let fn_like = hir_map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n+    let fn_kind = node.fn_kind().unwrap_or_else(|| {\n         bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n     });\n \n-    fn_like.asyncness()\n+    fn_kind.asyncness()\n }\n \n /// Don't call this directly: use ``tcx.conservative_is_privately_uninhabited`` instead."}, {"sha": "9c7b0b2cacb062e397ed86fedc7b8fa8f518b4bb", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -883,8 +883,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.get_diagnostic_item(sym::unwind_safe_trait),\n             self.tcx.get_diagnostic_item(sym::ref_unwind_safe_trait),\n         ];\n-        let auto_traits =\n-            vec![\"`Clone`\", \"`Sync`\", \"`Send`\", \"`Unpin`\", \"`UnwindSafe`\", \"`RefUnwindSafe`\"];\n+        const AUTO_TRAITS: [&str; 6] =\n+            [\"`Clone`\", \"`Sync`\", \"`Send`\", \"`Unpin`\", \"`UnwindSafe`\", \"`RefUnwindSafe`\"];\n \n         let root_var_min_capture_list = min_captures.and_then(|m| m.get(&var_hir_id))?;\n \n@@ -957,7 +957,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // by the root variable but not by the capture\n             for (idx, _) in obligations_should_hold.iter().enumerate() {\n                 if !obligations_holds_for_capture[idx] && obligations_should_hold[idx] {\n-                    capture_problems.insert(auto_traits[idx]);\n+                    capture_problems.insert(AUTO_TRAITS[idx]);\n                 }\n             }\n \n@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n     ) -> (Vec<MigrationDiagnosticInfo>, String) {\n         let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) else {\n-            return (Vec::new(), format!(\"\"));\n+            return (Vec::new(), String::new());\n         };\n \n         let mut need_migrations = Vec::new();"}, {"sha": "2128fdea2eb460e3144b4ba7265119f8434238b9", "filename": "config.toml.example", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -68,6 +68,12 @@ changelog-seen = 2\n # Indicates whether the LLVM assertions are enabled or not\n #assertions = false\n \n+# Indicates whether the LLVM testsuite is enabled in the build or not. Does\n+# not execute the tests as part of the build as part of x.py build et al,\n+# just makes it possible to do `ninja check-llvm` in the staged LLVM build\n+# directory when doing LLVM development as part of Rust development.\n+#tests = false\n+\n # Indicates whether the LLVM plugin is enabled or not\n #plugins = false\n "}, {"sha": "de607c8fdab31dd098a5ee88c1f76dd81f41ac85", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -543,9 +543,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n+        assert!(capacity < 1_usize << usize::BITS - 1, \"capacity overflow\");\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-        assert!(cap > capacity, \"capacity overflow\");\n \n         VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity_in(cap, alloc) }\n     }"}, {"sha": "d52c78eedf3fad28836477edd8dbc74489a609aa", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1305,10 +1305,11 @@ impl<T, A: Allocator> Vec<T, A> {\n             // We replace self[index] with the last element. Note that if the\n             // bounds check above succeeds there must be a last element (which\n             // can be self[index] itself).\n-            let last = ptr::read(self.as_ptr().add(len - 1));\n-            let hole = self.as_mut_ptr().add(index);\n+            let value = ptr::read(self.as_ptr().add(index));\n+            let base_ptr = self.as_mut_ptr();\n+            ptr::copy(base_ptr.add(len - 1), base_ptr.add(index), 1);\n             self.set_len(len - 1);\n-            ptr::replace(hole, last)\n+            value\n         }\n     }\n "}, {"sha": "2b6ea90bf043019dd9f177fcb313716e8ab42d88", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -390,15 +390,16 @@ use crate::num::NonZeroUsize;\n macro_rules! nzint_impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        impl From<$Small> for $Large {\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n+        impl const From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]\n             #[inline]\n             fn from(small: $Small) -> Self {\n                 // SAFETY: input type guarantees the value is non-zero\n                 unsafe {\n-                    Self::new_unchecked(small.get().into())\n+                    Self::new_unchecked(From::from(small.get()))\n                 }\n             }\n         }"}, {"sha": "58a170401e7c123c5f08c97b164877022dfd2133", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -115,6 +115,7 @@\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_as_ptr)]\n #![feature(const_maybe_uninit_assume_init)]\n+#![feature(const_num_from_num)]\n #![feature(const_option)]\n #![feature(const_pin)]\n #![feature(const_replace)]"}, {"sha": "9b1a4de5d80378ce7016c058f575f6f481241cff", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -82,7 +82,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n-            #[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n+            #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n             impl const From<$Ty> for $Int {\n                 #[doc = concat!(\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\")]\n                 #[inline]"}, {"sha": "1dd3b2d8e3c8d8c2ae4a0202aa090e64c96a16de", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1365,7 +1365,7 @@ macro_rules! atomic_int {\n         }\n \n         #[$stable_from]\n-        #[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n+        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n         impl const From<$int_type> for $atomic_type {\n             #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n             #[inline]"}, {"sha": "a0ca919a851c36c15762c45e1001263f769dffe2", "filename": "library/core/tests/nonzero.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnonzero.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -204,9 +204,9 @@ fn nonzero_const() {\n     // test that the methods of `NonZeroX>` are usable in a const context\n     // Note: only tests NonZero8\n \n-    const NONZERO: NonZeroU8 = unsafe { NonZeroU8::new_unchecked(5) };\n+    const NONZERO_U8: NonZeroU8 = unsafe { NonZeroU8::new_unchecked(5) };\n \n-    const GET: u8 = NONZERO.get();\n+    const GET: u8 = NONZERO_U8.get();\n     assert_eq!(GET, 5);\n \n     const ZERO: Option<NonZeroU8> = NonZeroU8::new(0);\n@@ -215,8 +215,11 @@ fn nonzero_const() {\n     const ONE: Option<NonZeroU8> = NonZeroU8::new(1);\n     assert!(ONE.is_some());\n \n-    const FROM_NONZERO: u8 = u8::from(NONZERO);\n-    assert_eq!(FROM_NONZERO, 5);\n+    const FROM_NONZERO_U8: u8 = u8::from(NONZERO_U8);\n+    assert_eq!(FROM_NONZERO_U8, 5);\n+\n+    const NONZERO_CONVERT: NonZeroU32 = NonZeroU32::from(NONZERO_U8);\n+    assert_eq!(NONZERO_CONVERT.get(), 5);\n }\n \n #[test]"}, {"sha": "cb09717bde577f1eb623505fc67a0670db12597b", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -251,13 +251,12 @@ pub struct FromBytesWithNulError {\n /// # Examples\n ///\n /// ```\n-/// #![feature(cstring_from_vec_with_nul)]\n /// use std::ffi::{CString, FromVecWithNulError};\n ///\n /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"f\\0oo\".to_vec()).unwrap_err();\n /// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n pub struct FromVecWithNulError {\n     error_kind: FromBytesWithNulErrorKind,\n     bytes: Vec<u8>,\n@@ -278,7 +277,7 @@ impl FromBytesWithNulError {\n     }\n }\n \n-#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n impl FromVecWithNulError {\n     /// Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].\n     ///\n@@ -287,7 +286,6 @@ impl FromVecWithNulError {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(cstring_from_vec_with_nul)]\n     /// use std::ffi::CString;\n     ///\n     /// // Some invalid bytes in a vector\n@@ -298,6 +296,7 @@ impl FromVecWithNulError {\n     /// assert_eq!(&bytes[..], value.unwrap_err().as_bytes());\n     /// ```\n     #[must_use]\n+    #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }\n@@ -313,7 +312,6 @@ impl FromVecWithNulError {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(cstring_from_vec_with_nul)]\n     /// use std::ffi::CString;\n     ///\n     /// // Some invalid bytes in a vector\n@@ -324,6 +322,7 @@ impl FromVecWithNulError {\n     /// assert_eq!(bytes, value.unwrap_err().into_bytes());\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n+    #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n         self.bytes\n     }\n@@ -704,15 +703,14 @@ impl CString {\n     /// # Example\n     ///\n     /// ```\n-    /// #![feature(cstring_from_vec_with_nul)]\n     /// use std::ffi::CString;\n     /// assert_eq!(\n     ///     unsafe { CString::from_vec_with_nul_unchecked(b\"abc\\0\".to_vec()) },\n     ///     unsafe { CString::from_vec_unchecked(b\"abc\".to_vec()) }\n     /// );\n     /// ```\n     #[must_use]\n-    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub unsafe fn from_vec_with_nul_unchecked(v: Vec<u8>) -> Self {\n         Self { inner: v.into_boxed_slice() }\n     }\n@@ -733,7 +731,6 @@ impl CString {\n     /// when called without the ending nul byte.\n     ///\n     /// ```\n-    /// #![feature(cstring_from_vec_with_nul)]\n     /// use std::ffi::CString;\n     /// assert_eq!(\n     ///     CString::from_vec_with_nul(b\"abc\\0\".to_vec())\n@@ -745,14 +742,13 @@ impl CString {\n     /// An incorrectly formatted [`Vec`] will produce an error.\n     ///\n     /// ```\n-    /// #![feature(cstring_from_vec_with_nul)]\n     /// use std::ffi::{CString, FromVecWithNulError};\n     /// // Interior nul byte\n     /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"a\\0bc\".to_vec()).unwrap_err();\n     /// // No nul byte\n     /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"abc\".to_vec()).unwrap_err();\n     /// ```\n-    #[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+    #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n     pub fn from_vec_with_nul(v: Vec<u8>) -> Result<Self, FromVecWithNulError> {\n         let nul_pos = memchr::memchr(0, &v);\n         match nul_pos {\n@@ -1084,10 +1080,10 @@ impl fmt::Display for FromBytesWithNulError {\n     }\n }\n \n-#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n impl Error for FromVecWithNulError {}\n \n-#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n impl fmt::Display for FromVecWithNulError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.error_kind {"}, {"sha": "7f3bb836754ed5396607dc6a4889a6f249edebc0", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -145,7 +145,7 @@\n \n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub use self::c_str::FromBytesWithNulError;\n-#[unstable(feature = \"cstring_from_vec_with_nul\", issue = \"73179\")]\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n pub use self::c_str::FromVecWithNulError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::c_str::{CStr, CString, IntoStringError, NulError};"}, {"sha": "c080f783cbb36d76abfbb96eedacf446b44ff9eb", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -59,7 +59,8 @@ pub enum IpAddr {\n ///\n /// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n /// notation, divided by `.` (this is called \"dot-decimal notation\").\n-/// Notably, octal numbers and hexadecimal numbers are not allowed per [IETF RFC 6943].\n+/// Notably, octal numbers (which are indicated with a leading `0`) and hexadecimal numbers (which\n+/// are indicated with a leading `0x`) are not allowed per [IETF RFC 6943].\n ///\n /// [IETF RFC 6943]: https://tools.ietf.org/html/rfc6943#section-3.1.1\n /// [`FromStr`]: crate::str::FromStr\n@@ -72,6 +73,9 @@ pub enum IpAddr {\n /// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n /// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n /// assert_eq!(localhost.is_loopback(), true);\n+/// assert!(\"012.004.002.000\".parse::<Ipv4Addr>().is_err()); // all octets are in octal\n+/// assert!(\"0000000.0.0.0\".parse::<Ipv4Addr>().is_err()); // first octet is a zero in octal\n+/// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "17581f330266dc7394f8b3c42138becb861816a6", "filename": "library/std/src/net/ip/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -20,6 +20,14 @@ fn test_from_str_ipv4() {\n     // no number between dots\n     let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n     assert_eq!(None, none);\n+    // octal\n+    let none: Option<Ipv4Addr> = \"255.0.0.01\".parse().ok();\n+    assert_eq!(None, none);\n+    // octal zero\n+    let none: Option<Ipv4Addr> = \"255.0.0.00\".parse().ok();\n+    assert_eq!(None, none);\n+    let none: Option<Ipv4Addr> = \"255.0.00.0\".parse().ok();\n+    assert_eq!(None, none);\n }\n \n #[test]"}, {"sha": "4e16a55edece26a1b71d9acf7578d712d8efa0ca", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -111,10 +111,12 @@ impl<'a> Parser<'a> {\n         &mut self,\n         radix: u32,\n         max_digits: Option<usize>,\n+        allow_zero_prefix: bool,\n     ) -> Option<T> {\n         self.read_atomically(move |p| {\n             let mut result = T::ZERO;\n             let mut digit_count = 0;\n+            let has_leading_zero = p.peek_char() == Some('0');\n \n             while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n                 result = result.checked_mul(radix)?;\n@@ -127,7 +129,13 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            if digit_count == 0 { None } else { Some(result) }\n+            if digit_count == 0 {\n+                None\n+            } else if !allow_zero_prefix && has_leading_zero && digit_count > 1 {\n+                None\n+            } else {\n+                Some(result)\n+            }\n         })\n     }\n \n@@ -140,10 +148,7 @@ impl<'a> Parser<'a> {\n                 *slot = p.read_separator('.', i, |p| {\n                     // Disallow octal number in IP string.\n                     // https://tools.ietf.org/html/rfc6943#section-3.1.1\n-                    match (p.peek_char(), p.read_number(10, None)) {\n-                        (Some('0'), Some(number)) if number != 0 => None,\n-                        (_, number) => number,\n-                    }\n+                    p.read_number(10, Some(3), false)\n                 })?;\n             }\n \n@@ -175,7 +180,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4)));\n+                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4), true));\n \n                 match group {\n                     Some(g) => *slot = g,\n@@ -227,15 +232,15 @@ impl<'a> Parser<'a> {\n     fn read_port(&mut self) -> Option<u16> {\n         self.read_atomically(|p| {\n             p.read_given_char(':')?;\n-            p.read_number(10, None)\n+            p.read_number(10, None, true)\n         })\n     }\n \n     /// Read a `%` followed by a scope ID in base 10.\n     fn read_scope_id(&mut self) -> Option<u32> {\n         self.read_atomically(|p| {\n             p.read_given_char('%')?;\n-            p.read_number(10, None)\n+            p.read_number(10, None, true)\n         })\n     }\n \n@@ -281,7 +286,12 @@ impl FromStr for IpAddr {\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n+        // don't try to parse if too long\n+        if s.len() > 15 {\n+            Err(AddrParseError(()))\n+        } else {\n+            Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n+        }\n     }\n }\n "}, {"sha": "11836b7b694b38fd06043ca542b23ceb0244835f", "filename": "library/std/src/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -130,7 +130,7 @@ impl Barrier {\n         if lock.count < self.num_threads {\n             // We need a while loop to guard against spurious wakeups.\n             // https://en.wikipedia.org/wiki/Spurious_wakeup\n-            while local_gen == lock.generation_id && lock.count < self.num_threads {\n+            while local_gen == lock.generation_id {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n             BarrierWaitResult(false)"}, {"sha": "8d03aade3413a42a0e59d717d853114f9ed3e8db", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -90,6 +90,7 @@ pub struct Config {\n     // llvm codegen options\n     pub llvm_skip_rebuild: bool,\n     pub llvm_assertions: bool,\n+    pub llvm_tests: bool,\n     pub llvm_plugins: bool,\n     pub llvm_optimize: bool,\n     pub llvm_thin_lto: bool,\n@@ -422,6 +423,7 @@ struct Llvm {\n     thin_lto: Option<bool>,\n     release_debuginfo: Option<bool>,\n     assertions: Option<bool>,\n+    tests: Option<bool>,\n     plugins: Option<bool>,\n     ccache: Option<StringOrBool>,\n     version_check: Option<bool>,\n@@ -715,6 +717,7 @@ impl Config {\n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n         let mut llvm_assertions = None;\n+        let mut llvm_tests = None;\n         let mut llvm_plugins = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n@@ -740,6 +743,7 @@ impl Config {\n             }\n             set(&mut config.ninja_in_file, llvm.ninja);\n             llvm_assertions = llvm.assertions;\n+            llvm_tests = llvm.tests;\n             llvm_plugins = llvm.plugins;\n             llvm_skip_rebuild = llvm_skip_rebuild.or(llvm.skip_rebuild);\n             set(&mut config.llvm_optimize, llvm.optimize);\n@@ -991,6 +995,7 @@ impl Config {\n \n         config.llvm_skip_rebuild = llvm_skip_rebuild.unwrap_or(false);\n         config.llvm_assertions = llvm_assertions.unwrap_or(false);\n+        config.llvm_tests = llvm_tests.unwrap_or(false);\n         config.llvm_plugins = llvm_plugins.unwrap_or(false);\n         config.rust_optimize = optimize.unwrap_or(true);\n "}, {"sha": "6bfaeffa80705e65419d562a42ed2c9abcd8bb64", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -170,6 +170,7 @@ impl Step for Llvm {\n \n         let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };\n         let plugins = if builder.config.llvm_plugins { \"ON\" } else { \"OFF\" };\n+        let enable_tests = if builder.config.llvm_tests { \"ON\" } else { \"OFF\" };\n \n         cfg.out_dir(&out_dir)\n             .profile(profile)\n@@ -180,7 +181,7 @@ impl Step for Llvm {\n             .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n             .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n-            .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n+            .define(\"LLVM_INCLUDE_TESTS\", enable_tests)\n             .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n             .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n             .define(\"LLVM_ENABLE_BINDINGS\", \"OFF\")"}, {"sha": "ba4e1ca31148cf0d29e7af3456d05d4281df1f0a", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -72,7 +72,7 @@ ENV PATH=\"/node-v14.4.0-linux-x64/bin:${PATH}\"\n # https://github.com/puppeteer/puppeteer/issues/375\n #\n # We also specify the version in case we need to update it to go around cache limitations.\n-RUN npm install -g browser-ui-test@0.4.3 --unsafe-perm=true\n+RUN npm install -g browser-ui-test@0.4.5 --unsafe-perm=true\n \n ENV RUST_CONFIGURE_ARGS \\\n   --build=x86_64-unknown-linux-gnu \\"}, {"sha": "a361373dc19554289fb877213eb22ce6eb770919", "filename": "src/test/incremental/auxiliary/rustc-rust-log-aux.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fincremental%2Fauxiliary%2Frustc-rust-log-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fincremental%2Fauxiliary%2Frustc-rust-log-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fauxiliary%2Frustc-rust-log-aux.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -0,0 +1,8 @@\n+// rustc-env:RUSTC_LOG=debug\n+#[cfg(rpass1)]\n+pub fn foo() {}\n+\n+#[cfg(rpass2)]\n+pub fn foo() {\n+    println!();\n+}"}, {"sha": "566f0d96d9732d420821d1cfa0b0970ca74587d2", "filename": "src/test/incremental/rustc-rust-log.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fincremental%2Frustc-rust-log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fincremental%2Frustc-rust-log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frustc-rust-log.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -0,0 +1,16 @@\n+// revisions: rpass1 rpass2\n+// This test is just checking that we won't ICE if logging is turned\n+// on; don't bother trying to compare that (copious) output.\n+//\n+// dont-check-compiler-stdout\n+// dont-check-compiler-stderr\n+// aux-build: rustc-rust-log-aux.rs\n+// rustc-env:RUSTC_LOG=debug\n+\n+#[cfg(rpass1)]\n+fn main() {}\n+\n+#[cfg(rpass2)]\n+fn main() {\n+    println!();\n+}"}, {"sha": "7e6607b55ea8bead372fe82b422233cb431605e8", "filename": "src/test/rustdoc-gui/docblock-code-block-line-number.goml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -0,0 +1,22 @@\n+// Checks that the setting \"line numbers\" is working as expected.\n+goto: file://|DOC_PATH|/test_docs/fn.foo.html\n+\n+// We check that without this setting, there is no line number displayed.\n+assert-false: \"pre.line-number\"\n+\n+// We now set the setting to show the line numbers on code examples.\n+local-storage: {\"rustdoc-line-numbers\": \"true\" }\n+// We reload to make the line numbers appear.\n+reload:\n+\n+// We wait for them to be added into the DOM by the JS...\n+wait-for: \"pre.line-number\"\n+// If the test didn't fail, it means that it was found!\n+// Let's now check some CSS properties...\n+assert-css: (\"pre.line-number\", {\n+    \"margin\": \"0px\",\n+    \"padding\": \"13px 8px\",\n+    \"text-align\": \"right\"\n+})\n+// The first code block has two lines so let's check its `<pre>` elements lists both of them.\n+assert-text: (\"pre.line-number\", \"1\\n2\")"}, {"sha": "a3a62fe54465ec8dedda125c1af8a87ce97d9526", "filename": "src/test/rustdoc-gui/sidebar-macro-reexport.goml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-macro-reexport.goml?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -0,0 +1,5 @@\n+// This test ensures that the reexport of a macro doesn't make the original macro\n+// displayed twice in the sidebar.\n+goto: file://|DOC_PATH|/test_docs/macro.repro.html\n+wait-for: \".sidebar-elems .macro .macro\"\n+assert-count: (\"//*[@class='sidebar-elems']//*[@class='block macro']//a[text()='repro']\", 1)"}, {"sha": "62dc76a40bcf5a315904a5f0ee031a5813caad05", "filename": "src/test/rustdoc-gui/sidebar.goml", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar.goml?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -7,12 +7,13 @@ assert-text: (\".sidebar-elems > #all-types\", \"See all test_docs's items\")\n assert-text: (\".sidebar-elems > .crate > ul > li > a.current\", \"test_docs\")\n // And we're also supposed to have the list of items in the current module.\n assert-text: (\".sidebar-elems > .items > ul > li:nth-child(1)\", \"Modules\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(2)\", \"Structs\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(3)\", \"Enums\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(4)\", \"Traits\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(5)\", \"Functions\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(6)\", \"Type Definitions\")\n-assert-text: (\".sidebar-elems > .items > ul > li:nth-child(7)\", \"Keywords\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(2)\", \"Macros\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(3)\", \"Structs\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(4)\", \"Enums\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(5)\", \"Traits\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(6)\", \"Functions\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(7)\", \"Type Definitions\")\n+assert-text: (\".sidebar-elems > .items > ul > li:nth-child(8)\", \"Keywords\")\n assert-text: (\"#structs + .item-table .item-left > a\", \"Foo\")\n click: \"#structs + .item-table .item-left > a\"\n "}, {"sha": "652308a71cb8501d6deb791d9cd33c2e80408799", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -12,6 +12,7 @@ use std::fmt;\n ///\n /// ```\n /// println!(\"nothing fancy\");\n+/// println!(\"but with two lines!\");\n /// ```\n ///\n /// A failing to compile one:\n@@ -123,3 +124,10 @@ pub mod huge_amount_of_consts {\n \n /// Very long code text `hereIgoWithLongTextBecauseWhyNotAndWhyWouldntI`.\n pub mod long_code_block {}\n+\n+#[macro_export]\n+macro_rules! repro {\n+    () => {};\n+}\n+\n+pub use crate::repro as repro2;"}, {"sha": "315fca195873a233bc8bbb92d2efb932eb6cbeb7", "filename": "src/test/rustdoc-ui/doc-without-codeblock.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -11,3 +11,12 @@ pub mod foo {\n     //~^ ERROR missing code example in this documentation\n     pub fn bar() {}\n }\n+\n+// This impl is here to ensure the lint isn't emitted for foreign traits implementations.\n+impl std::ops::Neg for Foo {\n+    type Output = Self;\n+\n+    fn neg(self) -> Self::Output {\n+        Self\n+    }\n+}"}, {"sha": "1c138044165f233fc53eac31c4c3594015f155b0", "filename": "src/test/rustdoc-ui/doc-without-codeblock.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -6,7 +6,7 @@ LL | |\n LL | | /// Some docs.\n LL | |\n ...  |\n-LL | |     pub fn bar() {}\n+LL | |     }\n LL | | }\n    | |_^\n    |"}, {"sha": "52e7dcf4499a8478d1c12f862e696894cc9ec08f", "filename": "src/test/ui/rustc-rust-log.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fui%2Frustc-rust-log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015ef5b2633960e7653b744d7a1c3d1d336313a/src%2Ftest%2Fui%2Frustc-rust-log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustc-rust-log.rs?ref=e015ef5b2633960e7653b744d7a1c3d1d336313a", "patch": "@@ -1,9 +1,6 @@\n // run-pass\n // This test is just checking that we won't ICE if logging is turned\n-// on; don't bother trying to compare that (copious) output. (Note\n-// also that this test potentially silly, since we do not build+test\n-// debug versions of rustc as part of our continuous integration\n-// process...)\n+// on; don't bother trying to compare that (copious) output.\n //\n // dont-check-compiler-stdout\n // dont-check-compiler-stderr"}]}