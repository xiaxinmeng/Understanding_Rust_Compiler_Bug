{"sha": "9d3c59d69750e07d9446339c4b733c925d3571bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2M1OWQ2OTc1MGUwN2Q5NDQ2MzM5YzRiNzMzYzkyNWQzNTcxYmM=", "commit": {"author": {"name": "Albin Stjerna", "email": "albin.stjerna@gmail.com", "date": "2019-07-12T20:49:15Z"}, "committer": {"name": "Albin Stjerna", "email": "albin.stjerna@gmail.com", "date": "2019-07-12T20:49:15Z"}, "message": "rustfmt all the things!", "tree": {"sha": "5ad130058b9ce9acd5279c71f5f5331dbf3f098c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ad130058b9ce9acd5279c71f5f5331dbf3f098c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3c59d69750e07d9446339c4b733c925d3571bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c59d69750e07d9446339c4b733c925d3571bc", "html_url": "https://github.com/rust-lang/rust/commit/9d3c59d69750e07d9446339c4b733c925d3571bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c59d69750e07d9446339c4b733c925d3571bc/comments", "author": null, "committer": null, "parents": [{"sha": "ac0a3d106bf33395da6251562800ab8df5e60d3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0a3d106bf33395da6251562800ab8df5e60d3a", "html_url": "https://github.com/rust-lang/rust/commit/ac0a3d106bf33395da6251562800ab8df5e60d3a"}], "stats": {"total": 848, "additions": 246, "deletions": 602}, "files": [{"sha": "783964c701ad5fec0db64581cda1d0c06a2629e5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 218, "deletions": 511, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9d3c59d69750e07d9446339c4b733c925d3571bc", "patch": "@@ -9,6 +9,16 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n+use crate::rustc_serialize as serialize;\n+use crate::ty::adjustment::PointerCast;\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::layout::VariantIdx;\n+use crate::ty::print::{FmtPrinter, Printer};\n+use crate::ty::subst::{Subst, SubstsRef};\n+use crate::ty::{\n+    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    UserTypeAnnotationIndex,\n+};\n use polonius_engine::Atom;\n use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n@@ -18,10 +28,9 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n use rustc_macros::HashStable;\n-use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n-use std::fmt::{self, Debug, Formatter, Write, Display};\n+use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n@@ -30,15 +39,6 @@ use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::layout::VariantIdx;\n-use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n-    UserTypeAnnotationIndex,\n-};\n-use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::adjustment::{PointerCast};\n \n pub use crate::mir::interpret::AssertMessage;\n \n@@ -225,10 +225,7 @@ impl<'tcx> Body<'tcx> {\n     #[inline]\n     pub fn basic_blocks_and_local_decls_mut(\n         &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-    ) {\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n         self.cache.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls)\n     }\n@@ -260,16 +257,10 @@ impl<'tcx> Body<'tcx> {\n         let if_not_zero_locations = if loc.statement_index == 0 {\n             None\n         } else {\n-            Some(Location {\n-                block: loc.block,\n-                statement_index: loc.statement_index - 1,\n-            })\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n         };\n \n-        if_zero_locations\n-            .into_iter()\n-            .flatten()\n-            .chain(if_not_zero_locations)\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n     }\n \n     #[inline]\n@@ -407,10 +398,7 @@ impl<'tcx> Body<'tcx> {\n \n     /// Gets the location of the terminator for the given block\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n-        Location {\n-            block: bb,\n-            statement_index: self[bb].statements.len(),\n-        }\n+        Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n }\n \n@@ -509,8 +497,9 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd,\n-         Ord, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -665,7 +654,7 @@ pub enum ImplicitSelfKind {\n     MutRef,\n     /// Represents when a function does not have a self argument or\n     /// when a function has a `self: X` argument.\n-    None\n+    None,\n }\n \n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n@@ -896,8 +885,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)))\n-                => true,\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n \n             _ => false,\n         }\n@@ -966,21 +954,13 @@ impl<'tcx> LocalDecl<'tcx> {\n     }\n \n     #[inline]\n-    fn new_local(\n-        ty: Ty<'tcx>,\n-        mutability: Mutability,\n-        internal: bool,\n-        span: Span,\n-    ) -> Self {\n+    fn new_local(ty: Ty<'tcx>, mutability: Mutability, internal: bool, span: Span) -> Self {\n         LocalDecl {\n             mutability,\n             ty,\n             user_ty: UserTypeProjections::none(),\n             name: None,\n-            source_info: SourceInfo {\n-                span,\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-            },\n+            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n             is_user_variable: None,\n@@ -997,10 +977,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n             user_ty: UserTypeProjections::none(),\n-            source_info: SourceInfo {\n-                span,\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-            },\n+            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             is_block_tail: None,\n@@ -1032,10 +1009,7 @@ newtype_index! {\n \n impl BasicBlock {\n     pub fn start_location(self) -> Location {\n-        Location {\n-            block: self,\n-            statement_index: 0,\n-        }\n+        Location { block: self, statement_index: 0 }\n     }\n }\n \n@@ -1118,11 +1092,7 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// Drop the Place\n-    Drop {\n-        location: Place<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n+    Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n     /// Drop the Place and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n@@ -1270,80 +1240,27 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => None.into_iter().chain(&[]),\n+            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&[]),\n             Goto { target: ref t }\n-            | Call {\n-                destination: None,\n-                cleanup: Some(ref t),\n-                ..\n+            | Call { destination: None, cleanup: Some(ref t), .. }\n+            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n+            | Yield { resume: ref t, drop: None, .. }\n+            | DropAndReplace { target: ref t, unwind: None, .. }\n+            | Drop { target: ref t, unwind: None, .. }\n+            | Assert { target: ref t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref t, unwind: None } => Some(t).into_iter().chain(&[]),\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n+            | Yield { resume: ref t, drop: Some(ref u), .. }\n+            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n+            | Drop { target: ref t, unwind: Some(ref u), .. }\n+            | Assert { target: ref t, cleanup: Some(ref u), .. }\n+            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n             }\n-            | Call {\n-                destination: Some((_, ref t)),\n-                cleanup: None,\n-                ..\n-            }\n-            | Yield {\n-                resume: ref t,\n-                drop: None,\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref t,\n-                unwind: None,\n-                ..\n-            }\n-            | Drop {\n-                target: ref t,\n-                unwind: None,\n-                ..\n-            }\n-            | Assert {\n-                target: ref t,\n-                cleanup: None,\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref t,\n-                unwind: None,\n-            } => Some(t).into_iter().chain(&[]),\n-            Call {\n-                destination: Some((_, ref t)),\n-                cleanup: Some(ref u),\n-                ..\n-            }\n-            | Yield {\n-                resume: ref t,\n-                drop: Some(ref u),\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref t,\n-                unwind: Some(ref u),\n-                ..\n-            }\n-            | Drop {\n-                target: ref t,\n-                unwind: Some(ref u),\n-                ..\n-            }\n-            | Assert {\n-                target: ref t,\n-                cleanup: Some(ref u),\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref t,\n-                unwind: Some(ref u),\n-            } => Some(t).into_iter().chain(slice::from_ref(u)),\n             SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n-            FalseEdges {\n-                ref real_target,\n-                ref imaginary_target,\n-            } => Some(real_target).into_iter().chain(slice::from_ref(imaginary_target)),\n+            FalseEdges { ref real_target, ref imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n+            }\n         }\n     }\n \n@@ -1355,84 +1272,29 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => None.into_iter().chain(&mut []),\n+            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&mut []),\n             Goto { target: ref mut t }\n-            | Call {\n-                destination: None,\n-                cleanup: Some(ref mut t),\n-                ..\n-            }\n-            | Call {\n-                destination: Some((_, ref mut t)),\n-                cleanup: None,\n-                ..\n-            }\n-            | Yield {\n-                resume: ref mut t,\n-                drop: None,\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref mut t,\n-                unwind: None,\n-                ..\n+            | Call { destination: None, cleanup: Some(ref mut t), .. }\n+            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n+            | Yield { resume: ref mut t, drop: None, .. }\n+            | DropAndReplace { target: ref mut t, unwind: None, .. }\n+            | Drop { target: ref mut t, unwind: None, .. }\n+            | Assert { target: ref mut t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: None } => {\n+                Some(t).into_iter().chain(&mut [])\n             }\n-            | Drop {\n-                target: ref mut t,\n-                unwind: None,\n-                ..\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n+            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n+            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_mut(u))\n             }\n-            | Assert {\n-                target: ref mut t,\n-                cleanup: None,\n-                ..\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            FalseEdges { ref mut real_target, ref mut imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n-            | FalseUnwind {\n-                real_target: ref mut t,\n-                unwind: None,\n-            } => Some(t).into_iter().chain(&mut []),\n-            Call {\n-                destination: Some((_, ref mut t)),\n-                cleanup: Some(ref mut u),\n-                ..\n-            }\n-            | Yield {\n-                resume: ref mut t,\n-                drop: Some(ref mut u),\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref mut t,\n-                unwind: Some(ref mut u),\n-                ..\n-            }\n-            | Drop {\n-                target: ref mut t,\n-                unwind: Some(ref mut u),\n-                ..\n-            }\n-            | Assert {\n-                target: ref mut t,\n-                cleanup: Some(ref mut u),\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref mut t,\n-                unwind: Some(ref mut u),\n-            } => Some(t).into_iter().chain(slice::from_mut(u)),\n-            SwitchInt {\n-                ref mut targets, ..\n-            } => None.into_iter().chain(&mut targets[..]),\n-            FalseEdges {\n-                ref mut real_target,\n-                ref mut imaginary_target,\n-            } => Some(real_target)\n-                .into_iter()\n-                .chain(slice::from_mut(imaginary_target)),\n         }\n     }\n \n@@ -1447,14 +1309,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdges { .. } => None,\n-            TerminatorKind::Call {\n-                cleanup: ref unwind,\n-                ..\n-            }\n-            | TerminatorKind::Assert {\n-                cleanup: ref unwind,\n-                ..\n-            }\n+            TerminatorKind::Call { cleanup: ref unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n             | TerminatorKind::DropAndReplace { ref unwind, .. }\n             | TerminatorKind::Drop { ref unwind, .. }\n             | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n@@ -1472,14 +1328,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdges { .. } => None,\n-            TerminatorKind::Call {\n-                cleanup: ref mut unwind,\n-                ..\n-            }\n-            | TerminatorKind::Assert {\n-                cleanup: ref mut unwind,\n-                ..\n-            }\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n             | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n             | TerminatorKind::Drop { ref mut unwind, .. }\n             | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n@@ -1489,11 +1339,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n \n impl<'tcx> BasicBlockData<'tcx> {\n     pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n-        BasicBlockData {\n-            statements: vec![],\n-            terminator,\n-            is_cleanup: false,\n-        }\n+        BasicBlockData { statements: vec![], terminator, is_cleanup: false }\n     }\n \n     /// Accessor for terminator.\n@@ -1555,10 +1401,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.statements.resize(\n             gap.end,\n             Statement {\n-                source_info: SourceInfo {\n-                    span: DUMMY_SP,\n-                    scope: OUTERMOST_SOURCE_SCOPE,\n-                },\n+                source_info: SourceInfo { span: DUMMY_SP, scope: OUTERMOST_SOURCE_SCOPE },\n                 kind: StatementKind::Nop,\n             },\n         );\n@@ -1617,27 +1460,18 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt {\n-                discr: ref place, ..\n-            } => write!(fmt, \"switchInt({:?})\", place),\n+            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n             Abort => write!(fmt, \"abort\"),\n             Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                ..\n-            } => write!(fmt, \"replace({:?} <- {:?})\", location, value),\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                ..\n-            } => {\n+            DropAndReplace { ref location, ref value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", location, value)\n+            }\n+            Call { ref func, ref args, ref destination, .. } => {\n                 if let Some((ref destination, _)) = *destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n                 }\n@@ -1650,12 +1484,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n-            Assert {\n-                ref cond,\n-                expected,\n-                ref msg,\n-                ..\n-            } => {\n+            Assert { ref cond, expected, ref msg, .. } => {\n                 write!(fmt, \"assert(\")?;\n                 if !expected {\n                     write!(fmt, \"!\")?;\n@@ -1673,69 +1502,41 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt {\n-                ref values,\n-                switch_ty,\n-                ..\n-            } => {\n-                ty::tls::with(|tcx| {\n-                    let param_env = ty::ParamEnv::empty();\n-                    let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n-                    let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                    values\n-                        .iter()\n-                        .map(|&u| {\n-                            tcx.mk_const(ty::Const {\n-                                val: ConstValue::Scalar(\n-                                    Scalar::from_uint(u, size).into(),\n-                                ),\n-                                ty: switch_ty,\n-                            }).to_string().into()\n-                        }).chain(iter::once(\"otherwise\".into()))\n-                        .collect()\n-                })\n+            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+                let param_env = ty::ParamEnv::empty();\n+                let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n+                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                values\n+                    .iter()\n+                    .map(|&u| {\n+                        tcx.mk_const(ty::Const {\n+                            val: ConstValue::Scalar(Scalar::from_uint(u, size).into()),\n+                            ty: switch_ty,\n+                        })\n+                        .to_string()\n+                        .into()\n+                    })\n+                    .chain(iter::once(\"otherwise\".into()))\n+                    .collect()\n+            }),\n+            Call { destination: Some(_), cleanup: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n             }\n-            Call {\n-                destination: Some(_),\n-                cleanup: Some(_),\n-                ..\n-            } => vec![\"return\".into(), \"unwind\".into()],\n-            Call {\n-                destination: Some(_),\n-                cleanup: None,\n-                ..\n-            } => vec![\"return\".into()],\n-            Call {\n-                destination: None,\n-                cleanup: Some(_),\n-                ..\n-            } => vec![\"unwind\".into()],\n-            Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => vec![],\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n             Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n             Yield { drop: None, .. } => vec![\"resume\".into()],\n             DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n                 vec![\"return\".into()]\n             }\n-            DropAndReplace {\n-                unwind: Some(_), ..\n+            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n             }\n-            | Drop {\n-                unwind: Some(_), ..\n-            } => vec![\"return\".into(), \"unwind\".into()],\n             Assert { cleanup: None, .. } => vec![\"\".into()],\n             Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n-            FalseEdges {\n-                ..\n-            } => {\n-                vec![\"real\".into(), \"imaginary\".into()]\n-            }\n-            FalseUnwind {\n-                unwind: Some(_), ..\n-            } => vec![\"real\".into(), \"cleanup\".into()],\n+            FalseEdges { .. } => vec![\"real\".into(), \"imaginary\".into()],\n+            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n             FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n         }\n     }\n@@ -1785,10 +1586,7 @@ pub enum StatementKind<'tcx> {\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant {\n-        place: Place<'tcx>,\n-        variant_index: VariantIdx,\n-    },\n+    SetDiscriminant { place: Place<'tcx>, variant_index: VariantIdx },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1885,24 +1683,25 @@ impl<'tcx> Debug for Statement<'tcx> {\n         match self.kind {\n             Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n-            Retag(ref kind, ref place) =>\n-                write!(fmt, \"Retag({}{:?})\",\n-                    match kind {\n-                        RetagKind::FnEntry => \"[fn entry] \",\n-                        RetagKind::TwoPhase => \"[2phase] \",\n-                        RetagKind::Raw => \"[raw] \",\n-                        RetagKind::Default => \"\",\n-                    },\n-                    place,\n-                ),\n+            Retag(ref kind, ref place) => write!(\n+                fmt,\n+                \"Retag({}{:?})\",\n+                match kind {\n+                    RetagKind::FnEntry => \"[fn entry] \",\n+                    RetagKind::TwoPhase => \"[2phase] \",\n+                    RetagKind::Raw => \"[raw] \",\n+                    RetagKind::Default => \"\",\n+                },\n+                place,\n+            ),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n-            SetDiscriminant {\n-                ref place,\n-                variant_index,\n-            } => write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index),\n-            InlineAsm(ref asm) =>\n-                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs),\n+            SetDiscriminant { ref place, variant_index } => {\n+                write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n+            }\n+            InlineAsm(ref asm) => {\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n+            }\n             AscribeUserType(ref place, ref variance, ref c_ty) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n@@ -1916,15 +1715,19 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum Place<'tcx> {\n     Base(PlaceBase<'tcx>),\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     Projection(Box<Projection<'tcx>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum PlaceBase<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1940,7 +1743,9 @@ pub struct Static<'tcx> {\n     pub kind: StaticKind,\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n+)]\n pub enum StaticKind {\n     Promoted(Promoted),\n     Static(DefId),\n@@ -1952,15 +1757,17 @@ impl_stable_hash_for!(struct Static<'tcx> {\n });\n \n /// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub struct Projection<'tcx> {\n     pub base: Place<'tcx>,\n     pub elem: PlaceElem<'tcx>,\n- }\n+}\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -2033,7 +1840,8 @@ impl<'tcx> Place<'tcx> {\n     pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n         self.elem(ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name),\n-            variant_index))\n+            variant_index,\n+        ))\n     }\n \n     pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n@@ -2054,8 +1862,8 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n-            Place::Base(PlaceBase::Local(local)) |\n-            Place::Projection(box Projection {\n+            Place::Base(PlaceBase::Local(local))\n+            | Place::Projection(box Projection {\n                 base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) => Some(*local),\n@@ -2090,13 +1898,9 @@ impl<'tcx> Place<'tcx> {\n         op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n     ) -> R {\n         match self {\n-            Place::Projection(interior) => interior.base.iterate2(\n-                &Projections::List {\n-                    projection: interior,\n-                    next,\n-                },\n-                op,\n-            ),\n+            Place::Projection(interior) => {\n+                interior.base.iterate2(&Projections::List { projection: interior, next }, op)\n+            }\n \n             Place::Base(base) => op(base, next.iter()),\n         }\n@@ -2126,10 +1930,7 @@ impl From<Local> for PlaceBase<'_> {\n pub enum Projections<'p, 'tcx> {\n     Empty,\n \n-    List {\n-        projection: &'p Projection<'tcx>,\n-        next: &'p Projections<'p, 'tcx>,\n-    }\n+    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n }\n \n impl<'p, 'tcx> Projections<'p, 'tcx> {\n@@ -2188,16 +1989,15 @@ impl<'tcx> Debug for Place<'tcx> {\n             let projs_vec: Vec<_> = place_projections.collect();\n             for projection in projs_vec.iter().rev() {\n                 match projection.elem {\n-                    ProjectionElem::Downcast(_, _) |\n-                    ProjectionElem::Field(_, _) => {\n+                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n                         write!(fmt, \"(\").unwrap();\n                     }\n                     ProjectionElem::Deref => {\n                         write!(fmt, \"(*\").unwrap();\n                     }\n-                    ProjectionElem::Index(_) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } => {}\n+                    ProjectionElem::Index(_)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } => {}\n                 }\n             }\n         });\n@@ -2222,18 +2022,10 @@ impl<'tcx> Debug for Place<'tcx> {\n                     ProjectionElem::Index(ref index) => {\n                         write!(fmt, \"[{:?}]\", index)?;\n                     }\n-                    ProjectionElem::ConstantIndex {\n-                        offset,\n-                        min_length,\n-                        from_end: false,\n-                    } => {\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n                         write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n                     }\n-                    ProjectionElem::ConstantIndex {\n-                        offset,\n-                        min_length,\n-                        from_end: true,\n-                    } => {\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                         write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                     }\n                     ProjectionElem::Subslice { from, to } if to == 0 => {\n@@ -2258,21 +2050,11 @@ impl Debug for PlaceBase<'_> {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n             PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n-                write!(\n-                    fmt,\n-                    \"({}: {:?})\",\n-                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                    ty\n-                )\n-            },\n+                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n+            }\n             PlaceBase::Static(box self::Static { ty, kind: StaticKind::Promoted(promoted) }) => {\n-                write!(\n-                    fmt,\n-                    \"({:?}: {:?})\",\n-                    promoted,\n-                    ty\n-                )\n-            },\n+                write!(fmt, \"({:?}: {:?})\", promoted, ty)\n+            }\n         }\n     }\n }\n@@ -2403,7 +2185,6 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n@@ -2421,13 +2202,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field number and is present only for union expressions\n     /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n-    Adt(\n-        &'tcx AdtDef,\n-        VariantIdx,\n-        SubstsRef<'tcx>,\n-        Option<UserTypeAnnotationIndex>,\n-        Option<usize>,\n-    ),\n+    Adt(&'tcx AdtDef, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n     Closure(DefId, ClosureSubsts<'tcx>),\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n@@ -2605,8 +2380,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\",\n-                                               tcx.hir().span(hir_id));\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n@@ -2697,30 +2471,26 @@ impl<'tcx> UserTypeProjections {\n         UserTypeProjections { contents: vec![] }\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection, Span)>) -> Self {\n+    pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection, Span)> {\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item = &(UserTypeProjection, Span)> {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection> {\n+    pub fn projections(&self) -> impl Iterator<Item = &UserTypeProjection> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n \n-    pub fn push_projection(\n-        mut self,\n-        user_ty: &UserTypeProjection,\n-        span: Span,\n-    ) -> Self {\n+    pub fn push_projection(mut self, user_ty: &UserTypeProjection, span: Span) -> Self {\n         self.contents.push((user_ty.clone(), span));\n         self\n     }\n \n     fn map_projections(\n         mut self,\n-        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection\n+        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection,\n     ) -> Self {\n         self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n         self\n@@ -2742,12 +2512,7 @@ impl<'tcx> UserTypeProjections {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n     }\n \n-    pub fn variant(\n-        self,\n-        adt_def: &'tcx AdtDef,\n-        variant_index: VariantIdx,\n-        field: Field,\n-    ) -> Self {\n+    pub fn variant(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx, field: Field) -> Self {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n     }\n }\n@@ -2773,7 +2538,7 @@ pub struct UserTypeProjection {\n     pub projs: Vec<ProjectionKind>,\n }\n \n-impl Copy for ProjectionKind { }\n+impl Copy for ProjectionKind {}\n \n impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n@@ -2804,7 +2569,8 @@ impl UserTypeProjection {\n     ) -> Self {\n         self.projs.push(ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name),\n-            variant_index));\n+            variant_index,\n+        ));\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n@@ -2817,15 +2583,15 @@ impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n         use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n-        let projs: Vec<_> = self.projs\n+        let projs: Vec<_> = self\n+            .projs\n             .iter()\n-            .map(|elem| {\n-                match elem {\n-                    Deref => Deref,\n-                    Field(f, ()) => Field(f.clone(), ()),\n-                    Index(()) => Index(()),\n-                    elem => elem.clone(),\n-                }})\n+            .map(|elem| match elem {\n+                Deref => Deref,\n+                Field(f, ()) => Field(f.clone(), ()),\n+                Index(()) => Index(()),\n+                elem => elem.clone(),\n+            })\n             .collect();\n \n         UserTypeProjection { base, projs }\n@@ -2918,20 +2684,14 @@ impl fmt::Debug for Location {\n }\n \n impl Location {\n-    pub const START: Location = Location {\n-        block: START_BLOCK,\n-        statement_index: 0,\n-    };\n+    pub const START: Location = Location { block: START_BLOCK, statement_index: 0 };\n \n     /// Returns the location immediately after this one within the enclosing block.\n     ///\n     /// Note that if this location represents a terminator, then the\n     /// resulting location would be out of bounds and invalid.\n     pub fn successor_within_block(&self) -> Location {\n-        Location {\n-            block: self.block,\n-            statement_index: self.statement_index + 1,\n-        }\n+        Location { block: self.block, statement_index: self.statement_index + 1 }\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n@@ -3121,8 +2881,19 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n /// order of the category, thereby influencing diagnostic output.\n ///\n /// See also [rustc_mir::borrow_check::nll::constraints]\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n pub enum ConstraintCategory {\n     Return,\n     Yield,\n@@ -3285,56 +3056,27 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n-            SwitchInt {\n-                ref discr,\n-                switch_ty,\n-                ref values,\n-                ref targets,\n-            } => SwitchInt {\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n                 values: values.clone(),\n                 targets: targets.clone(),\n             },\n-            Drop {\n-                ref location,\n-                target,\n-                unwind,\n-            } => Drop {\n-                location: location.fold_with(folder),\n-                target,\n-                unwind,\n-            },\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                target,\n-                unwind,\n-            } => DropAndReplace {\n+            Drop { ref location, target, unwind } => {\n+                Drop { location: location.fold_with(folder), target, unwind }\n+            }\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n                 location: location.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n             },\n-            Yield {\n-                ref value,\n-                resume,\n-                drop,\n-            } => Yield {\n-                value: value.fold_with(folder),\n-                resume: resume,\n-                drop: drop,\n-            },\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                cleanup,\n-                from_hir_call,\n-            } => {\n-                let dest = destination\n-                    .as_ref()\n-                    .map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+            Yield { ref value, resume, drop } => {\n+                Yield { value: value.fold_with(folder), resume: resume, drop: drop }\n+            }\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+                let dest =\n+                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n \n                 Call {\n                     func: func.fold_with(folder),\n@@ -3344,13 +3086,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     from_hir_call,\n                 }\n             }\n-            Assert {\n-                ref cond,\n-                expected,\n-                ref msg,\n-                target,\n-                cleanup,\n-            } => {\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let msg = if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n                     InterpError::BoundsCheck {\n                         len: len.fold_with(folder),\n@@ -3359,72 +3095,42 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 } else {\n                     msg.clone()\n                 };\n-                Assert {\n-                    cond: cond.fold_with(folder),\n-                    expected,\n-                    msg,\n-                    target,\n-                    cleanup,\n-                }\n+                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n             }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n             Abort => Abort,\n             Return => Return,\n             Unreachable => Unreachable,\n-            FalseEdges {\n-                real_target,\n-                imaginary_target,\n-            } => FalseEdges {\n-                real_target,\n-                imaginary_target,\n-            },\n-            FalseUnwind {\n-                real_target,\n-                unwind,\n-            } => FalseUnwind {\n-                real_target,\n-                unwind,\n-            },\n+            FalseEdges { real_target, imaginary_target } => {\n+                FalseEdges { real_target, imaginary_target }\n+            }\n+            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n         };\n-        Terminator {\n-            source_info: self.source_info,\n-            kind,\n-        }\n+        Terminator { source_info: self.source_info, kind }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         use crate::mir::TerminatorKind::*;\n \n         match self.kind {\n-            SwitchInt {\n-                ref discr,\n-                switch_ty,\n-                ..\n-            } => discr.visit_with(visitor) || switch_ty.visit_with(visitor),\n+            SwitchInt { ref discr, switch_ty, .. } => {\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+            }\n             Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                ..\n-            } => location.visit_with(visitor) || value.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, .. } => {\n+                location.visit_with(visitor) || value.visit_with(visitor)\n+            }\n             Yield { ref value, .. } => value.visit_with(visitor),\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                ..\n-            } => {\n+            Call { ref func, ref args, ref destination, .. } => {\n                 let dest = if let Some((ref loc, _)) = *destination {\n                     loc.visit_with(visitor)\n                 } else {\n                     false\n                 };\n                 dest || func.visit_with(visitor) || args.visit_with(visitor)\n             }\n-            Assert {\n-                ref cond, ref msg, ..\n-            } => {\n+            Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n                     if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n@@ -3571,11 +3277,12 @@ impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor) || match self.elem {\n-            Field(_, ref ty) => ty.visit_with(visitor),\n-            Index(ref v) => v.visit_with(visitor),\n-            _ => false,\n-        }\n+        self.base.visit_with(visitor)\n+            || match self.elem {\n+                Field(_, ref ty) => ty.visit_with(visitor),\n+                Index(ref v) => v.visit_with(visitor),\n+                _ => false,\n+            }\n     }\n }\n "}, {"sha": "bb217a1f965e260b7cdb5ba94a71f6a511af90b9", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=9d3c59d69750e07d9446339c4b733c925d3571bc", "patch": "@@ -15,8 +15,8 @@ use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::HasMoveData;\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n use crate::dataflow::MaybeUninitializedPlaces;\n+use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n use either::Either;\n use std::fmt;\n use std::rc::Rc;\n@@ -40,12 +40,7 @@ impl<'b, 'tcx> Flows<'b, 'tcx> {\n         ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> Self {\n-        Flows {\n-            borrows,\n-            uninits,\n-            ever_inits,\n-            polonius_output,\n-        }\n+        Flows { borrows, uninits, ever_inits, polonius_output }\n     }\n \n     crate fn borrows_in_scope("}, {"sha": "05451cdfb83d8e2841a6c4645c02a48e44b38289", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 8, "deletions": 37, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=9d3c59d69750e07d9446339c4b733c925d3571bc", "patch": "@@ -28,8 +28,7 @@ crate trait AllFactsExt {\n impl AllFactsExt for AllFacts {\n     /// Return\n     fn enabled(tcx: TyCtxt<'_>) -> bool {\n-        tcx.sess.opts.debugging_opts.nll_facts\n-            || tcx.sess.opts.debugging_opts.polonius\n+        tcx.sess.opts.debugging_opts.nll_facts || tcx.sess.opts.debugging_opts.polonius\n     }\n \n     fn write_to_dir(\n@@ -91,11 +90,7 @@ struct FactWriter<'w> {\n }\n \n impl<'w> FactWriter<'w> {\n-    fn write_facts_to_path<T>(\n-        &self,\n-        rows: &[T],\n-        file_name: &str,\n-    ) -> Result<(), Box<dyn Error>>\n+    fn write_facts_to_path<T>(&self, rows: &[T], file_name: &str) -> Result<(), Box<dyn Error>>\n     where\n         T: FactRow,\n     {\n@@ -109,19 +104,11 @@ impl<'w> FactWriter<'w> {\n }\n \n trait FactRow {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>>;\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>>;\n }\n \n impl FactRow for RegionVid {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[self])\n     }\n }\n@@ -131,11 +118,7 @@ where\n     A: FactCell,\n     B: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1])\n     }\n }\n@@ -146,11 +129,7 @@ where\n     B: FactCell,\n     C: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1, &self.2])\n     }\n }\n@@ -162,11 +141,7 @@ where\n     C: FactCell,\n     D: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1, &self.2, &self.3])\n     }\n }\n@@ -177,11 +152,7 @@ fn write_row(\n     columns: &[&dyn FactCell],\n ) -> Result<(), Box<dyn Error>> {\n     for (index, c) in columns.iter().enumerate() {\n-        let tail = if index == columns.len() - 1 {\n-            \"\\n\"\n-        } else {\n-            \"\\t\"\n-        };\n+        let tail = if index == columns.len() - 1 { \"\\n\" } else { \"\\t\" };\n         write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n     }\n     Ok(())"}, {"sha": "8970009b6ee9f9b145bdec5e71e3f60b721b0d99", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=9d3c59d69750e07d9446339c4b733c925d3571bc", "patch": "@@ -7,7 +7,7 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use rustc::mir::{Local, Body};\n+use rustc::mir::{Body, Local};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;"}, {"sha": "039ed939ada7c61a04b0682bf1052369282d08a2", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3c59d69750e07d9446339c4b733c925d3571bc/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=9d3c59d69750e07d9446339c4b733c925d3571bc", "patch": "@@ -247,9 +247,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n \n             if self.use_live_at.insert(p) {\n-                self.cx\n-                    .elements\n-                    .push_predecessors(self.cx.body, p, &mut self.stack)\n+                self.cx.elements.push_predecessors(self.cx.body, p, &mut self.stack)\n             }\n         }\n     }\n@@ -287,10 +285,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n         }\n \n-        debug!(\n-            \"compute_drop_live_points_for: drop_locations={:?}\",\n-            self.drop_locations\n-        );\n+        debug!(\"compute_drop_live_points_for: drop_locations={:?}\", self.drop_locations);\n \n         // Reverse DFS. But for drops, we do it a bit differently.\n         // The stack only ever stores *terminators of blocks*. Within\n@@ -326,17 +321,11 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         // block.  One of them may be either a definition or use\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n-        debug_assert_eq!(\n-            self.cx.body.terminator_loc(term_location.block),\n-            term_location,\n-        );\n+        debug_assert_eq!(self.cx.body.terminator_loc(term_location.block), term_location,);\n         let block = term_location.block;\n         let entry_point = self.cx.elements.entry_point(term_location.block);\n         for p in (entry_point..term_point).rev() {\n-            debug!(\n-                \"compute_drop_live_points_for_block: p = {:?}\",\n-                self.cx.elements.to_location(p),\n-            );\n+            debug!(\"compute_drop_live_points_for_block: p = {:?}\", self.cx.elements.to_location(p));\n \n             if self.defs.contains(p) {\n                 debug!(\"compute_drop_live_points_for_block: def site\");\n@@ -355,10 +344,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n \n         for &pred_block in self.cx.body.predecessors_for(block).iter() {\n-            debug!(\n-                \"compute_drop_live_points_for_block: pred_block = {:?}\",\n-                pred_block,\n-            );\n+            debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)\n             // initialized at the exit of this predecessor. If so, we\n@@ -389,18 +375,12 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             // If the terminator of this predecessor either *assigns*\n             // our value or is a \"normal use\", then stop.\n             if self.defs.contains(pred_term_point) {\n-                debug!(\n-                    \"compute_drop_live_points_for_block: defined at {:?}\",\n-                    pred_term_loc\n-                );\n+                debug!(\"compute_drop_live_points_for_block: defined at {:?}\", pred_term_loc);\n                 continue;\n             }\n \n             if self.use_live_at.contains(pred_term_point) {\n-                debug!(\n-                    \"compute_drop_live_points_for_block: use-live at {:?}\",\n-                    pred_term_loc\n-                );\n+                debug!(\"compute_drop_live_points_for_block: use-live at {:?}\", pred_term_loc);\n                 continue;\n             }\n \n@@ -461,10 +441,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // \"just ahead\" of a terminator.\n         self.flow_inits.reset_to_entry_of(block);\n         for statement_index in 0..self.body[block].statements.len() {\n-            let location = Location {\n-                block,\n-                statement_index,\n-            };\n+            let location = Location { block, statement_index };\n             self.flow_inits.reconstruct_statement_effect(location);\n             self.flow_inits.apply_local_effect(location);\n         }\n@@ -531,12 +508,11 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n \n         if let Some(data) = &drop_data.region_constraint_data {\n             for &drop_location in drop_locations {\n-                self.typeck\n-                    .push_region_constraints(\n-                        drop_location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                        data,\n-                    );\n+                self.typeck.push_region_constraints(\n+                    drop_location.to_locations(),\n+                    ConstraintCategory::Boring,\n+                    data,\n+                );\n             }\n         }\n \n@@ -602,14 +578,9 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n         let param_env = typeck.param_env;\n-        let (dropck_result, region_constraint_data) = param_env\n-            .and(DropckOutlives::new(dropped_ty))\n-            .fully_perform(typeck.infcx)\n-            .unwrap();\n-\n-        DropData {\n-            dropck_result,\n-            region_constraint_data,\n-        }\n+        let (dropck_result, region_constraint_data) =\n+            param_env.and(DropckOutlives::new(dropped_ty)).fully_perform(typeck.infcx).unwrap();\n+\n+        DropData { dropck_result, region_constraint_data }\n     }\n }"}]}