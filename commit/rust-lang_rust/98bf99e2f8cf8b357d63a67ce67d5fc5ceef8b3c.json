{"sha": "98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "node_id": "C_kwDOAAsO6NoAKDk4YmY5OWUyZjhjZjhiMzU3ZDYzYTY3Y2U2N2Q1ZmM1Y2VlZjhiM2M", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-09-09T11:36:26Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-09-09T11:36:26Z"}, "message": "Merge commit 'b52fb5234cd7c11ecfae51897a6f7fa52e8777fc' into clippyup", "tree": {"sha": "9737ff22b257f29282e7538d9ecb264451a3c1c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9737ff22b257f29282e7538d9ecb264451a3c1c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "html_url": "https://github.com/rust-lang/rust/commit/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "854f751b263dfac06dc3f635f8a9f92b8bc51da6", "url": "https://api.github.com/repos/rust-lang/rust/commits/854f751b263dfac06dc3f635f8a9f92b8bc51da6", "html_url": "https://github.com/rust-lang/rust/commit/854f751b263dfac06dc3f635f8a9f92b8bc51da6"}], "stats": {"total": 16177, "additions": 15491, "deletions": 686}, "files": [{"sha": "d847e4c749481fbc06566e2c3bde97064e77f0f0", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -3583,7 +3583,7 @@ Released 2018-09-13\n [`almost_complete_letter_range`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_complete_letter_range\n [`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n-[`arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic\n+[`arithmetic_side_effects`]: https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic_side_effects\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n [`as_underscore`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_underscore\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n@@ -3603,6 +3603,7 @@ Released 2018-09-13\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_assert_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_assert_comparison\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n+[`bool_to_int_with_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_to_int_with_if\n [`borrow_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_as_ptr\n [`borrow_deref_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_deref_ref\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const"}, {"sha": "b95061bf81a25e3b5290a95571cf50d87f0e235f", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 165, "deletions": 29, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -3,7 +3,7 @@ use aho_corasick::AhoCorasickBuilder;\n use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::{BTreeSet, HashMap, HashSet};\n use std::ffi::OsStr;\n use std::fmt::Write;\n use std::fs::{self, OpenOptions};\n@@ -124,6 +124,8 @@ fn generate_lint_files(\n     let content = gen_lint_group_list(\"all\", all_group_lints);\n     process_file(\"clippy_lints/src/lib.register_all.rs\", update_mode, &content);\n \n+    update_docs(update_mode, &usable_lints);\n+\n     for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n         let content = gen_lint_group_list(&lint_group, lints.iter());\n         process_file(\n@@ -140,6 +142,62 @@ fn generate_lint_files(\n     process_file(\"tests/ui/rename.rs\", update_mode, &content);\n }\n \n+fn update_docs(update_mode: UpdateMode, usable_lints: &[Lint]) {\n+    replace_region_in_file(update_mode, Path::new(\"src/docs.rs\"), \"docs! {\\n\", \"\\n}\\n\", |res| {\n+        for name in usable_lints.iter().map(|lint| lint.name.clone()).sorted() {\n+            writeln!(res, r#\"    \"{name}\",\"#).unwrap();\n+        }\n+    });\n+\n+    if update_mode == UpdateMode::Check {\n+        let mut extra = BTreeSet::new();\n+        let mut lint_names = usable_lints\n+            .iter()\n+            .map(|lint| lint.name.clone())\n+            .collect::<BTreeSet<_>>();\n+        for file in std::fs::read_dir(\"src/docs\").unwrap() {\n+            let filename = file.unwrap().file_name().into_string().unwrap();\n+            if let Some(name) = filename.strip_suffix(\".txt\") {\n+                if !lint_names.remove(name) {\n+                    extra.insert(name.to_string());\n+                }\n+            }\n+        }\n+\n+        let failed = print_lint_names(\"extra lint docs:\", &extra) | print_lint_names(\"missing lint docs:\", &lint_names);\n+\n+        if failed {\n+            exit_with_failure();\n+        }\n+    } else {\n+        if std::fs::remove_dir_all(\"src/docs\").is_err() {\n+            eprintln!(\"could not remove src/docs directory\");\n+        }\n+        if std::fs::create_dir(\"src/docs\").is_err() {\n+            eprintln!(\"could not recreate src/docs directory\");\n+        }\n+    }\n+    for lint in usable_lints {\n+        process_file(\n+            Path::new(\"src/docs\").join(lint.name.clone() + \".txt\"),\n+            update_mode,\n+            &lint.documentation,\n+        );\n+    }\n+}\n+\n+fn print_lint_names(header: &str, lints: &BTreeSet<String>) -> bool {\n+    if lints.is_empty() {\n+        return false;\n+    }\n+    println!(\"{}\", header);\n+    for lint in lints.iter().sorted() {\n+        println!(\"    {}\", lint);\n+    }\n+    println!();\n+    true\n+}\n+\n pub fn print_lints() {\n     let (lint_list, _, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n@@ -589,17 +647,26 @@ struct Lint {\n     desc: String,\n     module: String,\n     declaration_range: Range<usize>,\n+    documentation: String,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n+    fn new(\n+        name: &str,\n+        group: &str,\n+        desc: &str,\n+        module: &str,\n+        declaration_range: Range<usize>,\n+        documentation: String,\n+    ) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n             declaration_range,\n+            documentation,\n         }\n     }\n \n@@ -852,27 +919,35 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n          }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n     ) {\n         let start = range.start;\n-\n-        let mut iter = iter\n-            .by_ref()\n-            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        let mut docs = String::with_capacity(128);\n+        let mut iter = iter.by_ref().filter(|t| !matches!(t.token_kind, TokenKind::Whitespace));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n-        match iter.next() {\n-            // #[clippy::version = \"version\"] pub\n-            Some(LintDeclSearchResult {\n-                token_kind: TokenKind::Pound,\n-                ..\n-            }) => {\n-                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n-            },\n-            // pub\n-            Some(LintDeclSearchResult {\n-                token_kind: TokenKind::Ident,\n-                ..\n-            }) => (),\n-            _ => continue,\n+        let mut in_code = false;\n+        while let Some(t) = iter.next() {\n+            match t.token_kind {\n+                TokenKind::LineComment { .. } => {\n+                    if let Some(line) = t.content.strip_prefix(\"/// \").or_else(|| t.content.strip_prefix(\"///\")) {\n+                        if line.starts_with(\"```\") {\n+                            docs += \"```\\n\";\n+                            in_code = !in_code;\n+                        } else if !(in_code && line.starts_with(\"# \")) {\n+                            docs += line;\n+                            docs.push('\\n');\n+                        }\n+                    }\n+                },\n+                TokenKind::Pound => {\n+                    match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n+                    break;\n+                },\n+                TokenKind::Ident => {\n+                    break;\n+                },\n+                _ => {},\n+            }\n         }\n+        docs.pop(); // remove final newline\n \n         let (name, group, desc) = match_tokens!(\n             iter,\n@@ -890,7 +965,7 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n             ..\n         }) = iter.next()\n         {\n-            lints.push(Lint::new(name, group, desc, module, start..range.end));\n+            lints.push(Lint::new(name, group, desc, module, start..range.end, docs));\n         }\n     }\n }\n@@ -977,7 +1052,11 @@ fn remove_line_splices(s: &str) -> String {\n         .and_then(|s| s.strip_suffix('\"'))\n         .unwrap_or_else(|| panic!(\"expected quoted string, found `{}`\", s));\n     let mut res = String::with_capacity(s.len());\n-    unescape::unescape_literal(s, unescape::Mode::Str, &mut |range, _| res.push_str(&s[range]));\n+    unescape::unescape_literal(s, unescape::Mode::Str, &mut |range, ch| {\n+        if ch.is_ok() {\n+            res.push_str(&s[range]);\n+        }\n+    });\n     res\n }\n \n@@ -1116,13 +1195,15 @@ mod tests {\n                 \"\\\"really long text\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"doc_markdown\",\n                 \"pedantic\",\n                 \"\\\"single line\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n         ];\n         assert_eq!(expected, result);\n@@ -1162,20 +1243,23 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal_style\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             ),\n         ];\n         let expected = vec![Lint::new(\n@@ -1184,29 +1268,59 @@ mod tests {\n             \"\\\"abc\\\"\",\n             \"module_name\",\n             Range::default(),\n+            String::new(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"should_assert_eq\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"group2\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"incorrect_match\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n             ),\n-            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\n+                    \"should_assert_eq\",\n+                    \"group1\",\n+                    \"\\\"abc\\\"\",\n+                    \"module_name\",\n+                    Range::default(),\n+                    String::new(),\n+                ),\n+                Lint::new(\n+                    \"incorrect_match\",\n+                    \"group1\",\n+                    \"\\\"abc\\\"\",\n+                    \"module_name\",\n+                    Range::default(),\n+                    String::new(),\n+                ),\n             ],\n         );\n         expected.insert(\n@@ -1217,6 +1331,7 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n+                String::new(),\n             )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n@@ -1255,9 +1370,30 @@ mod tests {\n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n-            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"abc\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq\",\n+                \"group1\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n+            Lint::new(\n+                \"internal\",\n+                \"internal_style\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+                String::new(),\n+            ),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "9464694a3b55ad16e0531810740e49fefd80f255", "filename": "clippy_lints/src/async_yields_async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fasync_yields_async.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for AsyncYieldsAsync {\n                     hir_id: body.value.hir_id,\n                 };\n                 let typeck_results = cx.tcx.typeck_body(body_id);\n-                let expr_ty = typeck_results.expr_ty(&body.value);\n+                let expr_ty = typeck_results.expr_ty(body.value);\n \n                 if implements_trait(cx, expr_ty, future_trait_def_id, &[]) {\n                     let return_expr_span = match &body.value.kind {"}, {"sha": "732dc2b433091b047abdffa296f7521ebbd7e3e9", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -475,15 +475,15 @@ fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem\n \n fn is_relevant_item(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Fn(_, _, eid) = item.kind {\n-        is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n+        is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext<'_>, item: &ImplItem<'_>) -> bool {\n     match item.kind {\n-        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value),\n+        ImplItemKind::Fn(_, eid) => is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n@@ -492,7 +492,7 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n     match item.kind {\n         TraitItemKind::Fn(_, TraitFn::Required(_)) => true,\n         TraitItemKind::Fn(_, TraitFn::Provided(eid)) => {\n-            is_relevant_expr(cx, cx.tcx.typeck_body(eid), &cx.tcx.hir().body(eid).value)\n+            is_relevant_expr(cx, cx.tcx.typeck_body(eid), cx.tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }"}, {"sha": "a4b8cbb0d82aaf8294ee89a9b9303efb283f7b94", "filename": "clippy_lints/src/bool_to_int_with_if.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbool_to_int_with_if.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,125 @@\n+use rustc_ast::{ExprPrecedence, LitKind};\n+use rustc_hir::{Block, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, source::snippet_block_with_applicability};\n+use rustc_errors::Applicability;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Instead of using an if statement to convert a bool to an int,\n+    /// this lint suggests using a `from()` function or an `as` coercion.\n+    ///\n+    /// ### Why is this bad?\n+    /// Coercion or `from()` is idiomatic way to convert bool to a number.\n+    /// Both methods are guaranteed to return 1 for true, and 0 for false.\n+    ///\n+    /// See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let condition = false;\n+    /// if condition {\n+    ///     1_i64\n+    /// } else {\n+    ///     0\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let condition = false;\n+    /// i64::from(condition);\n+    /// ```\n+    /// or\n+    /// ```rust\n+    /// # let condition = false;\n+    /// condition as i64;\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub BOOL_TO_INT_WITH_IF,\n+    style,\n+    \"using if to convert bool to int\"\n+}\n+declare_lint_pass!(BoolToIntWithIf => [BOOL_TO_INT_WITH_IF]);\n+\n+impl<'tcx> LateLintPass<'tcx> for BoolToIntWithIf {\n+    fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+        if !expr.span.from_expansion() {\n+            check_if_else(ctx, expr);\n+        }\n+    }\n+}\n+\n+fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+    if let ExprKind::If(check, then, Some(else_)) = expr.kind\n+        && let Some(then_lit) = int_literal(then)\n+        && let Some(else_lit) = int_literal(else_)\n+        && check_int_literal_equals_val(then_lit, 1)\n+        && check_int_literal_equals_val(else_lit, 0)\n+    {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let snippet = snippet_block_with_applicability(ctx, check.span, \"..\", None, &mut applicability);\n+        let snippet_with_braces = {\n+            let need_parens = should_have_parentheses(check);\n+            let (left_paren, right_paren) = if need_parens {(\"(\", \")\")} else {(\"\", \"\")};\n+            format!(\"{left_paren}{snippet}{right_paren}\")\n+        };\n+\n+        let ty = ctx.typeck_results().expr_ty(then_lit); // then and else must be of same type\n+\n+        let suggestion = {\n+            let wrap_in_curly = is_else_clause(ctx.tcx, expr);\n+            let (left_curly, right_curly) = if wrap_in_curly {(\"{\", \"}\")} else {(\"\", \"\")};\n+            format!(\n+                \"{left_curly}{ty}::from({snippet}){right_curly}\"\n+            )\n+        }; // when used in else clause if statement should be wrapped in curly braces\n+\n+        span_lint_and_then(ctx,\n+            BOOL_TO_INT_WITH_IF,\n+            expr.span,\n+            \"boolean to int conversion using if\",\n+            |diag| {\n+            diag.span_suggestion(\n+                expr.span,\n+                \"replace with from\",\n+                suggestion,\n+                applicability,\n+            );\n+            diag.note(format!(\"`{snippet_with_braces} as {ty}` or `{snippet_with_braces}.into()` can also be valid options\"));\n+        });\n+    };\n+}\n+\n+// If block contains only a int literal expression, return literal expression\n+fn int_literal<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>) -> Option<&'tcx rustc_hir::Expr<'tcx>> {\n+    if let ExprKind::Block(block, _) = expr.kind\n+        && let Block {\n+            stmts: [],       // Shouldn't lint if statements with side effects\n+            expr: Some(expr),\n+            ..\n+        } = block\n+        && let ExprKind::Lit(lit) = &expr.kind\n+        && let LitKind::Int(_, _) = lit.node\n+    {\n+        Some(expr)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn check_int_literal_equals_val<'tcx>(expr: &'tcx rustc_hir::Expr<'tcx>, expected_value: u128) -> bool {\n+    if let ExprKind::Lit(lit) = &expr.kind\n+        && let LitKind::Int(val, _) = lit.node\n+        && val == expected_value\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn should_have_parentheses<'tcx>(check: &'tcx rustc_hir::Expr<'tcx>) -> bool {\n+    check.precedence().order() < ExprPrecedence::Cast.order()\n+}"}, {"sha": "be02f328e989a67051091196a4d37a2bc8dc673b", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -69,7 +69,10 @@ struct NumericFallbackVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self { ty_bounds: vec![TyBound::Nothing], cx }\n+        Self {\n+            ty_bounds: vec![TyBound::Nothing],\n+            cx,\n+        }\n     }\n \n     /// Check whether a passed literal has potential to cause fallback or not.\n@@ -126,21 +129,19 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                     }\n                     return;\n                 }\n-            }\n+            },\n \n             ExprKind::MethodCall(_, receiver, args, _) => {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n-                    for (expr, bound) in\n-                        iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs())\n-                    {\n+                    for (expr, bound) in iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs()) {\n                         self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n                     return;\n                 }\n-            }\n+            },\n \n             ExprKind::Struct(_, fields, base) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n@@ -175,15 +176,15 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                         return;\n                     }\n                 }\n-            }\n+            },\n \n             ExprKind::Lit(lit) => {\n                 let ty = self.cx.typeck_results().expr_ty(expr);\n                 self.check_lit(lit, ty, expr.hir_id);\n                 return;\n-            }\n+            },\n \n-            _ => {}\n+            _ => {},\n         }\n \n         walk_expr(self, expr);\n@@ -197,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 } else {\n                     self.ty_bounds.push(TyBound::Nothing);\n                 }\n-            }\n+            },\n \n             _ => self.ty_bounds.push(TyBound::Nothing),\n         }"}, {"sha": "88e28018e5d00529f0f1a63da92e29075aec75cc", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -830,25 +830,22 @@ fn walk_parents<'tcx>(\n                             )\n                         {\n                             return Some(Position::MethodReceiverRefImpl)\n-                        } else {\n-                            return Some(Position::MethodReceiver)\n                         }\n+                        return Some(Position::MethodReceiver);\n                     }\n-                    args.iter()\n-                        .position(|arg| arg.hir_id == child_id)\n-                        .map(|i| {\n-                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n-                            if let ty::Param(param_ty) = ty.kind() {\n-                                needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n-                            } else {\n-                                ty_auto_deref_stability(\n-                                    cx,\n-                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n-                                    precedence,\n-                                )\n-                                .position_for_arg()\n-                            }\n-                        })\n+                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n+                        let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                        if let ty::Param(param_ty) = ty.kind() {\n+                            needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n+                        } else {\n+                            ty_auto_deref_stability(\n+                                cx,\n+                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n+                                precedence,\n+                            )\n+                            .position_for_arg()\n+                        }\n+                    })\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),"}, {"sha": "ef9eeecc6a934f794859510ef414041e51509164", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n-    /// in generic types and the user defined `impl` maybe is more generalized or\n+    /// in generic types and the user defined `impl` may be more generalized or\n     /// specialized than what derive will produce. This lint can't detect the manual `impl`\n     /// has exactly equal bounds, and therefore this lint is disabled for types with\n     /// generic parameters."}, {"sha": "eb158d850fa724b81a8ad83f209bd51697fa8e59", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -236,7 +236,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                         typeck_results: cx.tcx.typeck(item.def_id),\n                         panic_span: None,\n                     };\n-                    fpu.visit_expr(&body.value);\n+                    fpu.visit_expr(body.value);\n                     lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n@@ -286,7 +286,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 typeck_results: cx.tcx.typeck(item.def_id),\n                 panic_span: None,\n             };\n-            fpu.visit_expr(&body.value);\n+            fpu.visit_expr(body.value);\n             lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n@@ -348,7 +348,7 @@ fn lint_for_missing_headers<'tcx>(\n                 if let Some(future) = cx.tcx.lang_items().future_trait();\n                 let typeck = cx.tcx.typeck_body(body_id);\n                 let body = cx.tcx.hir().body(body_id);\n-                let ret_ty = typeck.expr_ty(&body.value);\n+                let ret_ty = typeck.expr_ty(body.value);\n                 if implements_trait(cx, ret_ty, future, &[]);\n                 if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.cx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.cx, receiver_ty, sym::Result)\n             {"}, {"sha": "53bc617a4f5b78929510599109619bcb29753018", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         };\n         if body.value.span.from_expansion() {\n             if body.params.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, &body.value) {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, body.value) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,\n@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         let closure_ty = cx.typeck_results().expr_ty(expr);\n \n         if_chain!(\n-            if !is_adjusted(cx, &body.value);\n+            if !is_adjusted(cx, body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n             if check_inputs(cx, body.params, None, args);\n@@ -145,7 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         );\n \n         if_chain!(\n-            if !is_adjusted(cx, &body.value);\n+            if !is_adjusted(cx, body.value);\n             if let ExprKind::MethodCall(path, receiver, args, _) = body.value.kind;\n             if check_inputs(cx, body.params, Some(receiver), args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n@@ -206,8 +206,7 @@ fn check_inputs(\n             _ => false,\n         }\n     };\n-    std::iter::zip(params, receiver.into_iter().chain(call_args.iter()))\n-        .all(|(param, arg)| check_inputs(param, arg))\n+    std::iter::zip(params, receiver.into_iter().chain(call_args.iter())).all(|(param, arg)| check_inputs(param, arg))\n }\n \n fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {"}, {"sha": "1f69f34a229df4952c4d3b6f5932d6b5b4450703", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -84,7 +84,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n+                let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n                 if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                     || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n                 {\n@@ -110,7 +110,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                     typeck_results: cx.tcx.typeck(impl_item.id.def_id),\n                     result: Vec::new(),\n                 };\n-                fpu.visit_expr(&body.value);\n+                fpu.visit_expr(body.value);\n \n                 // if we've found one, lint\n                 if !fpu.result.is_empty() {"}, {"sha": "ba53a9678801ce2fbfa407a5988356a2ef081a4e", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -238,23 +238,23 @@ fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, receiver: &Expr<'_>, args: &[Expr<'_>]) {\n     // Check receiver\n     if let Some((value, _)) = constant(cx, cx.typeck_results(), receiver) {\n-        let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n-            \"exp\"\n+        if let Some(method) = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            Some(\"exp\")\n         } else if F32(2.0) == value || F64(2.0) == value {\n-            \"exp2\"\n+            Some(\"exp2\")\n         } else {\n-            return;\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            SUBOPTIMAL_FLOPS,\n-            expr.span,\n-            \"exponent for bases 2 and e can be computed more accurately\",\n-            \"consider using\",\n-            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n-            Applicability::MachineApplicable,\n-        );\n+            None\n+        } {\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                \"exponent for bases 2 and e can be computed more accurately\",\n+                \"consider using\",\n+                format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[0]), method),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n     }\n \n     // Check argument"}, {"sha": "00a4937763eb5ad780c10c278f22531ec2ade832", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -272,6 +272,6 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n         cx,\n         mutates_static: false,\n     };\n-    intravisit::walk_expr(&mut v, &body.value);\n+    intravisit::walk_expr(&mut v, body.value);\n     v.mutates_static\n }"}, {"sha": "9591405cb06f7b2d836d55f2c42148faf1ac0947", "filename": "clippy_lints/src/functions/result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -4,7 +4,6 @@ use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{sym, Span};\n-use rustc_typeck::hir_ty_to_ty;\n \n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n@@ -17,11 +16,12 @@ use super::{RESULT_LARGE_ERR, RESULT_UNIT_ERR};\n fn result_err_ty<'tcx>(\n     cx: &LateContext<'tcx>,\n     decl: &hir::FnDecl<'tcx>,\n+    id: hir::def_id::LocalDefId,\n     item_span: Span,\n ) -> Option<(&'tcx hir::Ty<'tcx>, Ty<'tcx>)> {\n     if !in_external_macro(cx.sess(), item_span)\n         && let hir::FnRetTy::Return(hir_ty) = decl.output\n-        && let ty = hir_ty_to_ty(cx.tcx, hir_ty)\n+        && let ty = cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).output())\n         && is_type_diagnostic_item(cx, ty, sym::Result)\n         && let ty::Adt(_, substs) = ty.kind()\n     {\n@@ -34,7 +34,7 @@ fn result_err_ty<'tcx>(\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, large_err_threshold: u64) {\n     if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span)\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span)\n     {\n         if cx.access_levels.is_exported(item.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -47,7 +47,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, l\n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem<'tcx>, large_err_threshold: u64) {\n     // Don't lint if method is a trait's implementation, we can't do anything about those\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span)\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span)\n         && trait_ref_of_method(cx, item.def_id).is_none()\n     {\n         if cx.access_levels.is_exported(item.def_id) {\n@@ -61,7 +61,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitItem<'tcx>, large_err_threshold: u64) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.span) {\n+        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span) {\n             if cx.access_levels.is_exported(item.def_id) {\n                 check_result_unit_err(cx, err_ty, fn_header_span);\n             }"}, {"sha": "feec8ec2e23f8f802c2b249f0931427eea795162", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n             return;\n         }\n \n-        let res_ty = cx.typeck_results().expr_ty(&body.value);\n+        let res_ty = cx.typeck_results().expr_ty(body.value);\n         if res_ty.is_unit() || res_ty.is_never() {\n             return;\n         }\n@@ -243,7 +243,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n                 None => return,\n             }\n         } else {\n-            &body.value\n+            body.value\n         };\n         lint_implicit_returns(cx, expr, expr.span.ctxt(), None);\n     }"}, {"sha": "8c2c96fa105af251ec8796c5e76d122d89394694", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n             Finite => {\n                 return;\n-            }\n+            },\n         };\n         span_lint(cx, lint, expr.span, msg);\n     }\n@@ -161,7 +161,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n             if method.ident.name == sym!(flat_map) && args.len() == 1 {\n                 if let ExprKind::Closure(&Closure { body, .. }) = args[0].kind {\n                     let body = cx.tcx.hir().body(body);\n-                    return is_infinite(cx, &body.value);\n+                    return is_infinite(cx, body.value);\n                 }\n             }\n             Finite\n@@ -230,8 +230,10 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 }\n             }\n             if method.ident.name == sym!(last) && args.is_empty() {\n-                let not_double_ended =\n-                    cx.tcx.get_diagnostic_item(sym::DoubleEndedIterator).map_or(false, |id| {\n+                let not_double_ended = cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::DoubleEndedIterator)\n+                    .map_or(false, |id| {\n                         !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {"}, {"sha": "eb13d0869c037d522b4b3d34b0a66886c7f324db", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,13 +1,12 @@\n //! lint when there is a large size difference between variants on an enum\n \n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{diagnostics::span_lint_and_then, ty::is_copy};\n+use clippy_utils::{diagnostics::span_lint_and_then, ty::approx_ty_size, ty::is_copy};\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::{Adt, Ty};\n+use rustc_middle::ty::{Adt, AdtDef, GenericArg, List, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n@@ -17,7 +16,7 @@ declare_clippy_lint! {\n     /// `enum`s.\n     ///\n     /// ### Why is this bad?\n-    /// Enum size is bounded by the largest variant. Having a\n+    /// Enum size is bounded by the largest variant. Having one\n     /// large variant can penalize the memory layout of that enum.\n     ///\n     /// ### Known problems\n@@ -33,8 +32,9 @@ declare_clippy_lint! {\n     /// use case it may be possible to store the large data in an auxiliary\n     /// structure (e.g. Arena or ECS).\n     ///\n-    /// The lint will ignore generic types if the layout depends on the\n-    /// generics, even if the size difference will be large anyway.\n+    /// The lint will ignore the impact of generic types to the type layout by\n+    /// assuming every type parameter is zero-sized. Depending on your use case,\n+    /// this may lead to a false positive.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -83,6 +83,38 @@ struct VariantInfo {\n     fields_size: Vec<FieldInfo>,\n }\n \n+fn variants_size<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    adt: AdtDef<'tcx>,\n+    subst: &'tcx List<GenericArg<'tcx>>,\n+) -> Vec<VariantInfo> {\n+    let mut variants_size = adt\n+        .variants()\n+        .iter()\n+        .enumerate()\n+        .map(|(i, variant)| {\n+            let mut fields_size = variant\n+                .fields\n+                .iter()\n+                .enumerate()\n+                .map(|(i, f)| FieldInfo {\n+                    ind: i,\n+                    size: approx_ty_size(cx, f.ty(cx.tcx, subst)),\n+                })\n+                .collect::<Vec<_>>();\n+            fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n+\n+            VariantInfo {\n+                ind: i,\n+                size: fields_size.iter().map(|info| info.size).sum(),\n+                fields_size,\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+    variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n+    variants_size\n+}\n+\n impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n@@ -92,57 +124,45 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+            let (adt, subst) = match ty.kind() {\n+                Adt(adt, subst) => (adt, subst),\n+                _ => panic!(\"already checked whether this is an enum\"),\n+            };\n             if adt.variants().len() <= 1 {\n                 return;\n             }\n-            let mut variants_size: Vec<VariantInfo> = Vec::new();\n-            for (i, variant) in adt.variants().iter().enumerate() {\n-                let mut fields_size = Vec::new();\n-                for (i, f) in variant.fields.iter().enumerate() {\n-                    let ty = cx.tcx.type_of(f.did);\n-                    // don't lint variants which have a field of generic type.\n-                    match cx.layout_of(ty) {\n-                        Ok(l) => {\n-                            let fsize = l.size.bytes();\n-                            fields_size.push(FieldInfo { ind: i, size: fsize });\n-                        },\n-                        Err(_) => {\n-                            return;\n-                        },\n-                    }\n-                }\n-                let size: u64 = fields_size.iter().map(|info| info.size).sum();\n-\n-                variants_size.push(VariantInfo {\n-                    ind: i,\n-                    size,\n-                    fields_size,\n-                });\n-            }\n-\n-            variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n+            let variants_size = variants_size(cx, *adt, subst);\n \n             let mut difference = variants_size[0].size - variants_size[1].size;\n             if difference > self.maximum_size_difference_allowed {\n                 let help_text = \"consider boxing the large fields to reduce the total size of the enum\";\n                 span_lint_and_then(\n                     cx,\n                     LARGE_ENUM_VARIANT,\n-                    def.variants[variants_size[0].ind].span,\n+                    item.span,\n                     \"large size difference between variants\",\n                     |diag| {\n+                        diag.span_label(\n+                            item.span,\n+                            format!(\"the entire enum is at least {} bytes\", approx_ty_size(cx, ty)),\n+                        );\n                         diag.span_label(\n                             def.variants[variants_size[0].ind].span,\n-                            &format!(\"this variant is {} bytes\", variants_size[0].size),\n+                            format!(\"the largest variant contains at least {} bytes\", variants_size[0].size),\n                         );\n-                        diag.span_note(\n+                        diag.span_label(\n                             def.variants[variants_size[1].ind].span,\n-                            &format!(\"and the second-largest variant is {} bytes:\", variants_size[1].size),\n+                            &if variants_size[1].fields_size.is_empty() {\n+                                \"the second-largest variant carries no data at all\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"the second-largest variant contains at least {} bytes\",\n+                                    variants_size[1].size\n+                                )\n+                            },\n                         );\n \n                         let fields = def.variants[variants_size[0].ind].data.fields();\n-                        variants_size[0].fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n                         let mut applicability = Applicability::MaybeIncorrect;\n                         if is_copy(cx, ty) || maybe_copy(cx, ty) {\n                             diag.span_note("}, {"sha": "7ae8ef830faea952e65ef77b77e83dcffcbcc2f1", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -370,20 +370,32 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n+    {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, receiver, args, &lit.node, op, compare_to);\n+        check_len(\n+            cx,\n+            span,\n+            method_path.ident.name,\n+            receiver,\n+            args,\n+            &lit.node,\n+            op,\n+            compare_to,\n+        );\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n }\n \n+// FIXME(flip1995): Figure out how to reduce the number of arguments\n+#[allow(clippy::too_many_arguments)]\n fn check_len(\n     cx: &LateContext<'_>,\n     span: Span,"}, {"sha": "1f85382347aa1d992ad9ccc526ceb52e818de481", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -17,6 +17,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n+    LintId::of(bool_to_int_with_if::BOOL_TO_INT_WITH_IF),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n     LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n     LintId::of(borrow_deref_ref::BORROW_DEREF_REF),"}, {"sha": "962e67220069a604992b0040cf38afec55d06656", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -56,6 +56,7 @@ store.register_lints(&[\n     await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n     blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n+    bool_to_int_with_if::BOOL_TO_INT_WITH_IF,\n     booleans::NONMINIMAL_BOOL,\n     booleans::OVERLY_COMPLEX_BOOL_EXPR,\n     borrow_deref_ref::BORROW_DEREF_REF,\n@@ -436,7 +437,7 @@ store.register_lints(&[\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     operators::ABSURD_EXTREME_COMPARISONS,\n-    operators::ARITHMETIC,\n+    operators::ARITHMETIC_SIDE_EFFECTS,\n     operators::ASSIGN_OP_PATTERN,\n     operators::BAD_BIT_MASK,\n     operators::CMP_NAN,"}, {"sha": "6eb9b3d3b9b7aa61be5ce4de886d42d3c3dabd14", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -50,7 +50,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION),\n     LintId::of(module_style::MOD_MODULE_FILES),\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n-    LintId::of(operators::ARITHMETIC),\n+    LintId::of(operators::ARITHMETIC_SIDE_EFFECTS),\n     LintId::of(operators::FLOAT_ARITHMETIC),\n     LintId::of(operators::FLOAT_CMP_CONST),\n     LintId::of(operators::INTEGER_ARITHMETIC),"}, {"sha": "05d2ec2e9e1e6002c1d2c3eb2eff1842b49a2da6", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -6,6 +6,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n+    LintId::of(bool_to_int_with_if::BOOL_TO_INT_WITH_IF),\n     LintId::of(casts::FN_TO_NUMERIC_CAST),\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n     LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),"}, {"sha": "e984254bf2919ae397bc80e990fd9b24ba28108c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -179,6 +179,7 @@ mod attrs;\n mod await_holding_invalid;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n+mod bool_to_int_with_if;\n mod booleans;\n mod borrow_deref_ref;\n mod cargo;\n@@ -523,7 +524,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     #[cfg(feature = \"internal\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n-            store.register_late_pass(|_| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n+            store.register_late_pass(|| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n             return;\n         }\n     }\n@@ -544,8 +545,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n-    let arithmetic_allowed = conf.arithmetic_allowed.clone();\n-    store.register_late_pass(move |_| Box::new(operators::arithmetic::Arithmetic::new(arithmetic_allowed.clone())));\n+    let arithmetic_side_effects_allowed = conf.arithmetic_side_effects_allowed.clone();\n+    store.register_late_pass(move |_| {\n+        Box::new(operators::arithmetic_side_effects::ArithmeticSideEffects::new(\n+            arithmetic_side_effects_allowed.clone(),\n+        ))\n+    });\n     store.register_late_pass(|_| Box::new(utils::dump_hir::DumpHir));\n     store.register_late_pass(|_| Box::new(utils::author::Author));\n     let await_holding_invalid_types = conf.await_holding_invalid_types.clone();\n@@ -901,6 +906,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(manual_string_new::ManualStringNew));\n     store.register_late_pass(|_| Box::new(unused_peekable::UnusedPeekable));\n     store.register_early_pass(|| Box::new(multi_assignments::MultiAssignments));\n+    store.register_late_pass(|_| Box::new(bool_to_int_with_if::BoolToIntWithIf));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "f2b6e0b7ef9ba933b0ec5e1e7cef7f4195fe514a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -276,7 +276,7 @@ fn could_use_elision<'tcx>(\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(&body.value);\n+        checker.visit_expr(body.value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }"}, {"sha": "8ab640051b635fb3da6e6122b6e94359f049a64d", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             },\n             ExprKind::Closure(&Closure { body, .. }) => {\n                 let body = self.cx.tcx.hir().body(body);\n-                self.visit_expr(&body.value);\n+                self.visit_expr(body.value);\n             },\n             _ => walk_expr(self, expr),\n         }"}, {"sha": "deb21894f36a9709cc1cf20815a8c660c9638cd2", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -356,7 +356,7 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n             after_loop: false,\n             used_iter: false,\n         };\n-        v.visit_expr(&cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n+        v.visit_expr(cx.tcx.hir().body(cx.enclosing_body.unwrap()).value);\n         v.used_iter\n     }\n }"}, {"sha": "a3aa2e4b389afe74f1e40f96da6fb5ea4eab66c9", "filename": "clippy_lints/src/matches/match_wild_err_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -40,7 +40,7 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'\n                                 arm.pat.span,\n                                 &format!(\"`Err({})` matches all errors\", ident_bind_name),\n                                 None,\n-                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n+                                \"match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\",\n                             );\n                         }\n                     }"}, {"sha": "56bcdc01fe4d61092502ca6cffa46ac5c0b730fb", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -203,12 +203,8 @@ fn form_exhaustive_matches<'a>(cx: &LateContext<'a>, ty: Ty<'a>, left: &Pat<'_>,\n             let left_pos = left_pos.as_opt_usize();\n             let right_pos = right_pos.as_opt_usize();\n             let len = max(\n-                left_in.len() + {\n-                    if left_pos.is_some() { 1 } else { 0 }\n-                },\n-                right_in.len() + {\n-                    if right_pos.is_some() { 1 } else { 0 }\n-                },\n+                left_in.len() + usize::from(left_pos.is_some()),\n+                right_in.len() + usize::from(right_pos.is_some()),\n             );\n             let mut left_pos = left_pos.unwrap_or(usize::MAX);\n             let mut right_pos = right_pos.unwrap_or(usize::MAX);"}, {"sha": "22f5635a5bccb803ddad652db33ce738039449ac", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -152,7 +152,7 @@ pub(crate) trait BindInsteadOfMap {\n         match arg.kind {\n             hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) => {\n                 let closure_body = cx.tcx.hir().body(body);\n-                let closure_expr = peel_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(closure_body.value);\n \n                 if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, fn_decl_span) {\n                     true"}, {"sha": "b2bc1ad5c9ed0f33cc1ce5d69af3485e58bc94fd", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check(\n         if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0].0).peel_refs();\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(args[0].0).peel_refs();\n \n             if *self_ty.kind() != ty::Str {\n                 return false;"}, {"sha": "7ab6b84c2074918f39b8f0d5aa67de94d23a914c", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -21,7 +21,11 @@ pub(super) fn check(\n     receiver: &Expr<'_>,\n     args: &[Expr<'_>],\n ) {\n-    let arg = if method_name == sym::clone && args.is_empty() { receiver } else { return };\n+    let arg = if method_name == sym::clone && args.is_empty() {\n+        receiver\n+    } else {\n+        return;\n+    };\n     if cx\n         .typeck_results()\n         .type_dependent_def_id(expr.hir_id)"}, {"sha": "9719b2f1c5125ff78f97934aeed8078405aa8878", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -25,7 +25,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n         },\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&body.value);\n+            let closure_expr = peel_blocks(body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n                 hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, receiver, ..) => {"}, {"sha": "8261ef5e1ce345819266a83a37f3905a5b5f47f8", "filename": "clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(&hir::Closure{ body, .. }) = arg.kind;\n         then {\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n             match closure_body.params[0].pat.kind {\n                 hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                     hir::BindingAnnotation::NONE, .., name, None"}, {"sha": "41942b20ea163f34e0e60d47b489b19870b145aa", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -825,8 +825,9 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n-    /// etc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n-    /// `unwrap_or_default` instead.\n+    /// `.or_insert(foo(..))` etc., and suggests to use `.or_else(|| foo(..))`,\n+    /// `.unwrap_or_else(|| foo(..))`, `.unwrap_or_default()` or `.or_default()`\n+    /// etc. instead.\n     ///\n     /// ### Why is this bad?\n     /// The function will always be called and potentially"}, {"sha": "b9593b3687d9cf3633d93dc397eda0893dd729c3", "filename": "clippy_lints/src/methods/mut_mutex_lock.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmut_mutex_lock.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{expr_custom_deref_adjustment, ty::is_type_diagnostic_item};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, Mutability};\n@@ -11,6 +11,7 @@ use super::MUT_MUTEX_LOCK;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>, recv: &'tcx Expr<'tcx>, name_span: Span) {\n     if_chain! {\n+        if matches!(expr_custom_deref_adjustment(cx, recv), None | Some(Mutability::Mut));\n         if let ty::Ref(_, _, Mutability::Mut) = cx.typeck_results().expr_ty(recv).kind();\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(ex.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);"}, {"sha": "597af853dc681a57d44f973f8a4fbe83a9d14977", "filename": "clippy_lints/src/methods/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fopen_options.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -40,7 +40,7 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n         let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n-        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 1 {\n+        if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && !arguments.is_empty() {\n             let argument_option = match arguments[0].kind {\n                 ExprKind::Lit(ref span) => {\n                     if let Spanned {"}, {"sha": "c409268de769d6616a1555071d5a7d1f75a07cdb", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -53,7 +53,7 @@ pub(super) fn check<'tcx>(\n             }),\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n \n             match &closure_expr.kind {\n                 hir::ExprKind::MethodCall(_, receiver, [], _) => {"}, {"sha": "6657cdccd010c4398a7d0b3dbfd9d8a0e8ca6e91", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -74,7 +74,7 @@ pub(super) fn check<'tcx>(\n             if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = map_arg.kind;\n             let arg_snippet = snippet(cx, fn_decl_span, \"..\");\n             let body = cx.tcx.hir().body(body);\n-            if let Some((func, [arg_char])) = reduce_unit_expression(&body.value);\n+            if let Some((func, [arg_char])) = reduce_unit_expression(body.value);\n             if let Some(id) = path_def_id(cx, func).map(|ctor_id| cx.tcx.parent(ctor_id));\n             if Some(id) == cx.tcx.lang_items().option_some_variant();\n             then {"}, {"sha": "b43b9258c471da6ec44eae9a9204d0b4c6327a2d", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -23,7 +23,8 @@ pub(super) fn check<'tcx>(\n     receiver: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n ) {\n-    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    /// Checks for `unwrap_or(T::new())`, `unwrap_or(T::default())`,\n+    /// `or_insert(T::new())` or `or_insert(T::default())`.\n     #[allow(clippy::too_many_arguments)]\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_>,\n@@ -43,7 +44,11 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if !or_has_args;\n-            if name == \"unwrap_or\";\n+            if let Some(sugg) = match name {\n+                \"unwrap_or\" => Some(\"unwrap_or_default\"),\n+                \"or_insert\" => Some(\"or_default\"),\n+                _ => None,\n+            };\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n             if let Some(default_trait_id) = cx.tcx.get_diagnostic_item(sym::Default);\n             let path = last_path_segment(qpath).ident.name;\n@@ -59,7 +64,7 @@ pub(super) fn check<'tcx>(\n                     method_span.with_hi(span.hi()),\n                     &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n                     \"try this\",\n-                    \"unwrap_or_default()\".to_string(),\n+                    format!(\"{}()\", sugg),\n                     Applicability::MachineApplicable,\n                 );\n \n@@ -83,7 +88,7 @@ pub(super) fn check<'tcx>(\n         fun_span: Option<Span>,\n     ) {\n         // (path, fn_has_argument, methods, suffix)\n-        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+        const KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n             (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n             (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n             (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),"}, {"sha": "851cdf544550f6caf077890c8c3d9f1293058bbd", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -15,9 +15,9 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, count_recv: &hi\n         if let Some(def_id) = cx.tcx.hir().opt_local_def_id(closure.hir_id);\n         if let Some(body_id) = cx.tcx.hir().maybe_body_owned_by(def_id);\n         let closure_body = cx.tcx.hir().body(body_id);\n-        if !cx.typeck_results().expr_ty(&closure_body.value).is_unit();\n+        if !cx.typeck_results().expr_ty(closure_body.value).is_unit();\n         then {\n-            if let Some(map_mutated_vars) = mutated_variables(&closure_body.value, cx) {\n+            if let Some(map_mutated_vars) = mutated_variables(closure_body.value, cx) {\n                 // A variable is used mutably inside of the closure. Suppress the lint.\n                 if !map_mutated_vars.is_empty() {\n                     return;"}, {"sha": "4e8c201f470bab9b86fbb2b130ca8af2969f03ef", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -21,22 +21,21 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n     if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = arg.kind {\n         let body = cx.tcx.hir().body(body);\n         let arg_id = body.params[0].pat.hir_id;\n-        let mutates_arg =\n-            mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n-        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n+        let mutates_arg = mutated_variables(body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, body.value);\n \n-        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n+        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n         let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(&body.value);\n+        return_visitor.visit_expr(body.value);\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n             if name == \"filter_map\" { \"map\" } else { \"map(..).next()\" }\n         } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n-            match cx.typeck_results().expr_ty(&body.value).kind() {\n+            match cx.typeck_results().expr_ty(body.value).kind() {\n                 ty::Adt(adt, subst)\n                     if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) && in_ty == subst.type_at(0) =>\n                 {"}, {"sha": "c17ef6809f91281aa7ab9490d0092a1f077d8a0f", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check(\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body);\n-            let closure_expr = peel_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n             if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;"}, {"sha": "ed5a75b0f3ce574ee50790436ef6704d6323bbe0", "filename": "clippy_lints/src/methods/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_sort_by.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -131,7 +131,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Exp\n         ] = &closure_body.params;\n         if let ExprKind::MethodCall(method_path, left_expr, [right_expr], _) = closure_body.value.kind;\n         if method_path.ident.name == sym::cmp;\n-        if is_trait_method(cx, &closure_body.value, sym::Ord);\n+        if is_trait_method(cx, closure_body.value, sym::Ord);\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n                 left_expr,"}, {"sha": "763bfafecef14916ebbccec2203d4c569eabed9a", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 139, "deletions": 78, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,21 +1,25 @@\n use super::implicit_clone::is_clone_like;\n use super::unnecessary_iter_cloned::{self, is_into_iter};\n+use crate::rustc_middle::ty::Subst;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{\n-    get_associated_type, get_iterator_item_ty, implements_trait, is_copy, is_type_diagnostic_item, peel_mid_ty_refs,\n-};\n-use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::visitors::find_all_ret_expressions;\n+use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, Node};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_middle::ty::EarlyBinder;\n+use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n+use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n+use rustc_typeck::check::{FnCtxt, Inherited};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -34,7 +38,7 @@ pub fn check<'tcx>(\n         then {\n             if is_cloned_or_copied(cx, method_name, method_def_id) {\n                 unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n-            } else if is_to_owned_like(cx, method_name, method_def_id) {\n+            } else if is_to_owned_like(cx, expr, method_name, method_def_id) {\n                 // At this point, we know the call is of a `to_owned`-like function. The functions\n                 // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n                 // based on its context, that is, whether it is a referent in an `AddrOf` expression, an\n@@ -246,70 +250,26 @@ fn check_other_call_arg<'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n-        if let Some((callee_def_id, call_substs, call_receiver, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        if let Some((callee_def_id, _, recv, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n-        let index = if let Some(call_receiver) = call_receiver {\n-            std::iter::once(call_receiver).chain(call_args.iter()).position(|arg| arg.hir_id == maybe_arg.hir_id)\n-        } else {\n-            call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id)\n-        };\n-        if let Some(i) = index;\n+        if let Some(i) = recv.into_iter().chain(call_args).position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n         let (input, n_refs) = peel_mid_ty_refs(*input);\n-        if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n+        if let (trait_predicates, _) = get_input_traits_and_projections(cx, callee_def_id, input);\n         if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n         if let [trait_predicate] = trait_predicates\n             .iter()\n             .filter(|trait_predicate| trait_predicate.def_id() != sized_def_id)\n             .collect::<Vec<_>>()[..];\n         if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n         if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+        if trait_predicate.def_id() == deref_trait_id || trait_predicate.def_id() == as_ref_trait_id;\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-        // If the callee has type parameters, they could appear in `projection_predicate.ty` or the\n-        // types of `trait_predicate.trait_ref.substs`.\n-        if if trait_predicate.def_id() == deref_trait_id {\n-            if let [projection_predicate] = projection_predicates[..] {\n-                let normalized_ty =\n-                    cx.tcx\n-                        .subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n-                implements_trait(cx, receiver_ty, deref_trait_id, &[])\n-                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\")\n-                        .map_or(false, |ty| ty::TermKind::Ty(ty) == normalized_ty.unpack())\n-            } else {\n-                false\n-            }\n-        } else if trait_predicate.def_id() == as_ref_trait_id {\n-            let composed_substs = compose_substs(\n-                cx,\n-                &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n-                call_substs,\n-            );\n-            // if `expr` is a `String` and generic target is [u8], skip\n-            // (https://github.com/rust-lang/rust-clippy/issues/9317).\n-            if let [subst] = composed_substs[..]\n-                && let GenericArgKind::Type(arg_ty) = subst.unpack()\n-                && arg_ty.is_slice()\n-                && let inner_ty = arg_ty.builtin_index().unwrap()\n-                && let ty::Uint(ty::UintTy::U8) = inner_ty.kind()\n-                && let self_ty = cx.typeck_results().expr_ty(expr).peel_refs()\n-                && is_type_diagnostic_item(cx, self_ty, sym::String) {\n-                false\n-            } else {\n-                implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n-            }\n-        } else {\n-            false\n-        };\n+        if can_change_type(cx, maybe_arg, receiver_ty);\n         // We can't add an `&` when the trait is `Deref` because `Target = &T` won't match\n         // `Target = T`.\n         if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n         let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n-        // If the trait is `AsRef` and the input type variable `T` occurs in the output type, then\n-        // `T` must not be instantiated with a reference\n-        // (https://github.com/rust-lang/rust-clippy/issues/8507).\n-        if (n_refs == 0 && !receiver_ty.is_ref())\n-            || trait_predicate.def_id() != as_ref_trait_id\n-            || !fn_sig.output().contains(input);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             span_lint_and_sugg(\n@@ -359,11 +319,11 @@ fn get_callee_substs_and_args<'tcx>(\n         }\n     }\n     if_chain! {\n-        if let ExprKind::MethodCall(_, receiver, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(_, recv, args, _) = expr.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         then {\n             let substs = cx.typeck_results().node_substs(expr.hir_id);\n-            return Some((method_def_id, substs, Some(receiver), args));\n+            return Some((method_def_id, substs, Some(recv), args));\n         }\n     }\n     None\n@@ -395,22 +355,103 @@ fn get_input_traits_and_projections<'tcx>(\n     (trait_predicates, projection_predicates)\n }\n \n-/// Composes two substitutions by applying the latter to the types of the former.\n-fn compose_substs<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    left: &[GenericArg<'tcx>],\n-    right: SubstsRef<'tcx>,\n-) -> Vec<GenericArg<'tcx>> {\n-    left.iter()\n-        .map(|arg| {\n-            if let GenericArgKind::Type(arg_ty) = arg.unpack() {\n-                let normalized_ty = cx.tcx.subst_and_normalize_erasing_regions(right, cx.param_env, arg_ty);\n-                GenericArg::from(normalized_ty)\n-            } else {\n-                *arg\n+fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<'a>) -> bool {\n+    for (_, node) in cx.tcx.hir().parent_iter(expr.hir_id) {\n+        match node {\n+            Node::Stmt(_) => return true,\n+            Node::Block(..) => continue,\n+            Node::Item(item) => {\n+                if let ItemKind::Fn(_, _, body_id) = &item.kind\n+                && let output_ty = return_ty(cx, item.hir_id())\n+                && let local_def_id = cx.tcx.hir().local_def_id(item.hir_id())\n+                && Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+                    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.hir_id());\n+                    fn_ctxt.can_coerce(ty, output_ty)\n+                }) {\n+                    if has_lifetime(output_ty) && has_lifetime(ty) {\n+                        return false;\n+                    }\n+                    let body = cx.tcx.hir().body(*body_id);\n+                    let body_expr = &body.value;\n+                    let mut count = 0;\n+                    return find_all_ret_expressions(cx, body_expr, |_| { count += 1; count <= 1 });\n+                }\n             }\n-        })\n-        .collect()\n+            Node::Expr(parent_expr) => {\n+                if let Some((callee_def_id, call_substs, recv, call_args)) = get_callee_substs_and_args(cx, parent_expr)\n+                {\n+                    let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+                    if let Some(arg_index) = recv.into_iter().chain(call_args).position(|arg| arg.hir_id == expr.hir_id)\n+                        && let Some(param_ty) = fn_sig.inputs().get(arg_index)\n+                        && let ty::Param(ParamTy { index: param_index , ..}) = param_ty.kind()\n+                    {\n+                        if fn_sig\n+                            .inputs()\n+                            .iter()\n+                            .enumerate()\n+                            .filter(|(i, _)| *i != arg_index)\n+                            .any(|(_, ty)| ty.contains(*param_ty))\n+                        {\n+                            return false;\n+                        }\n+\n+                        let mut trait_predicates = cx.tcx.param_env(callee_def_id)\n+                            .caller_bounds().iter().filter(|predicate| {\n+                            if let PredicateKind::Trait(trait_predicate) =  predicate.kind().skip_binder()\n+                                && trait_predicate.trait_ref.self_ty() == *param_ty {\n+                                    true\n+                                } else {\n+                                false\n+                            }\n+                        });\n+\n+                        let new_subst = cx.tcx.mk_substs(\n+                            call_substs.iter()\n+                                .enumerate()\n+                                .map(|(i, t)|\n+                                     if i == (*param_index as usize) {\n+                                         GenericArg::from(ty)\n+                                     } else {\n+                                         t\n+                                     }));\n+\n+                        if trait_predicates.any(|predicate| {\n+                            let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n+                            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+                            !cx.tcx\n+                                .infer_ctxt()\n+                                .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+                        }) {\n+                            return false;\n+                        }\n+\n+                        let output_ty = fn_sig.output();\n+                        if output_ty.contains(*param_ty) {\n+                            if let Ok(new_ty)  = cx.tcx.try_subst_and_normalize_erasing_regions(\n+                                new_subst, cx.param_env, output_ty) {\n+                                expr = parent_expr;\n+                                ty = new_ty;\n+                                continue;\n+                            }\n+                            return false;\n+                        }\n+\n+                        return true;\n+                    }\n+                } else if let ExprKind::Block(..) = parent_expr.kind {\n+                    continue;\n+                }\n+                return false;\n+            },\n+            _ => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn has_lifetime(ty: Ty<'_>) -> bool {\n+    ty.walk().any(|t| matches!(t.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n /// Returns true if the named method is `Iterator::cloned` or `Iterator::copied`.\n@@ -421,18 +462,38 @@ fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id:\n \n /// Returns true if the named method can be used to convert the receiver to its \"owned\"\n /// representation.\n-fn is_to_owned_like(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+fn is_to_owned_like<'a>(cx: &LateContext<'a>, call_expr: &Expr<'a>, method_name: Symbol, method_def_id: DefId) -> bool {\n     is_clone_like(cx, method_name.as_str(), method_def_id)\n         || is_cow_into_owned(cx, method_name, method_def_id)\n-        || is_to_string(cx, method_name, method_def_id)\n+        || is_to_string_on_string_like(cx, call_expr, method_name, method_def_id)\n }\n \n /// Returns true if the named method is `Cow::into_owned`.\n fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n     method_name.as_str() == \"into_owned\" && is_diag_item_method(cx, method_def_id, sym::Cow)\n }\n \n-/// Returns true if the named method is `ToString::to_string`.\n-fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n-    method_name == sym::to_string && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+/// Returns true if the named method is `ToString::to_string` and it's called on a type that\n+/// is string-like i.e. implements `AsRef<str>` or `Deref<str>`.\n+fn is_to_string_on_string_like<'a>(\n+    cx: &LateContext<'_>,\n+    call_expr: &'a Expr<'a>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+) -> bool {\n+    if method_name != sym::to_string || !is_diag_trait_item(cx, method_def_id, sym::ToString) {\n+        return false;\n+    }\n+\n+    if let Some(substs) = cx.typeck_results().node_substs_opt(call_expr.hir_id)\n+        && let [generic_arg] = substs.as_slice()\n+        && let GenericArgKind::Type(ty) = generic_arg.unpack()\n+        && let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref)\n+        && let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef)\n+        && (implements_trait(cx, ty, deref_trait_id, &[cx.tcx.types.str_.into()]) ||\n+            implements_trait(cx, ty, as_ref_trait_id, &[cx.tcx.types.str_.into()])) {\n+            true\n+        } else {\n+            false\n+        }\n }"}, {"sha": "045f739e64ded7db0b2a352287eb394ca45d8956", "filename": "clippy_lints/src/methods/unwrap_or_else_default.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_or_else_default.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -5,10 +5,11 @@ use clippy_utils::{\n     diagnostics::span_lint_and_sugg, is_default_equivalent_call, source::snippet_with_applicability,\n     ty::is_type_diagnostic_item,\n };\n+use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_span::sym;\n+use rustc_span::{sym, symbol};\n \n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -25,7 +26,7 @@ pub(super) fn check<'tcx>(\n \n     if_chain! {\n         if is_option || is_result;\n-        if is_default_equivalent_call(cx, u_arg);\n+        if closure_body_returns_empty_to_string(cx, u_arg) || is_default_equivalent_call(cx, u_arg);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n \n@@ -44,3 +45,22 @@ pub(super) fn check<'tcx>(\n         }\n     }\n }\n+\n+fn closure_body_returns_empty_to_string(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n+    if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = e.kind {\n+        let body = cx.tcx.hir().body(body);\n+\n+        if body.params.is_empty()\n+            && let hir::Expr{ kind, .. } = &body.value\n+            && let hir::ExprKind::MethodCall(hir::PathSegment {ident, ..}, self_arg, _, _) = kind\n+            && ident == &symbol::Ident::from_str(\"to_string\")\n+            && let hir::Expr{ kind, .. } = self_arg\n+            && let hir::ExprKind::Lit(lit) = kind\n+            && let LitKind::Str(symbol::kw::Empty, _) = lit.node\n+        {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "4d8579135fc061279efa57bdf4b9e83c8adf1568", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{match_trait_method, paths};\n-use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -84,19 +83,16 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n             }\n         },\n         ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n-            if_chain! {\n-                if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n-                then {\n-                    if path.ident.name == sym!(max) {\n-                        fetch_const(cx, Some(receiver), args, MinMax::Max)\n-                    } else if path.ident.name == sym!(min) {\n-                        fetch_const(cx, Some(receiver), args, MinMax::Min)\n-                    } else {\n-                        None\n-                    }\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+                if path.ident.name == sym!(max) {\n+                    fetch_const(cx, Some(receiver), args, MinMax::Max)\n+                } else if path.ident.name == sym!(min) {\n+                    fetch_const(cx, Some(receiver), args, MinMax::Min)\n                 } else {\n                     None\n                 }\n+            } else {\n+                None\n             }\n         },\n         _ => None,\n@@ -109,18 +105,18 @@ fn fetch_const<'a>(\n     args: &'a [Expr<'a>],\n     m: MinMax,\n ) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    let mut args = receiver.into_iter().chain(args.into_iter());\n-    let arg0 = args.next()?;\n-    let arg1 = args.next()?;\n+    let mut args = receiver.into_iter().chain(args);\n+    let first_arg = args.next()?;\n+    let second_arg = args.next()?;\n     if args.next().is_some() {\n         return None;\n     }\n-    constant_simple(cx, cx.typeck_results(), arg0).map_or_else(\n-        || constant_simple(cx, cx.typeck_results(), arg1).map(|c| (m, c, arg0)),\n+    constant_simple(cx, cx.typeck_results(), first_arg).map_or_else(\n+        || constant_simple(cx, cx.typeck_results(), second_arg).map(|c| (m, c, first_arg)),\n         |c| {\n-            if constant_simple(cx, cx.typeck_results(), arg1).is_none() {\n+            if constant_simple(cx, cx.typeck_results(), second_arg).is_none() {\n                 // otherwise ignore\n-                Some((m, c, arg1))\n+                Some((m, c, second_arg))\n             } else {\n                 None\n             }"}, {"sha": "3233d87c073193f99a0046745ff49c603f7576a5", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n             if let ExprKind::Block(..) = body.value.kind;\n             then {\n                 let mut ret_collector = RetCollector::default();\n-                ret_collector.visit_expr(&body.value);\n+                ret_collector.visit_expr(body.value);\n \n                 // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n                 if ret_collector.ret_in_loop {"}, {"sha": "6217110a1f3aee8253704a06c8894757fd54ed51", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, ConstKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n+use std::iter;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -234,11 +235,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n             })) => (\n                 def_id.to_def_id(),\n                 FnKind::TraitFn,\n-                if sig.decl.implicit_self.has_implicit_self() {\n-                    1\n-                } else {\n-                    0\n-                },\n+                usize::from(sig.decl.implicit_self.has_implicit_self()),\n             ),\n             Some(Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(ref sig, _),\n@@ -253,11 +250,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                     (\n                         trait_item_id,\n                         FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n-                        if sig.decl.implicit_self.has_implicit_self() {\n-                            1\n-                        } else {\n-                            0\n-                        },\n+                        usize::from(sig.decl.implicit_self.has_implicit_self()),\n                     )\n                 } else {\n                     (def_id.to_def_id(), FnKind::Fn, 0)\n@@ -310,7 +303,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                                     && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n                             }) =>\n                         {\n-                            if let Some(idx) = std::iter::once(receiver).chain(args.iter()).position(|arg| arg.hir_id == child_id) {\n+                            if let Some(idx) = iter::once(receiver).chain(args).position(|arg| arg.hir_id == child_id) {\n                                 param.uses.push(Usage::new(span, idx));\n                             }\n                             return;"}, {"sha": "800cf249f5c78433a7b64bc1f686a40bd4123704", "filename": "clippy_lints/src/operators/arithmetic.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/854f751b263dfac06dc3f635f8a9f92b8bc51da6/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854f751b263dfac06dc3f635f8a9f92b8bc51da6/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs?ref=854f751b263dfac06dc3f635f8a9f92b8bc51da6", "patch": "@@ -1,119 +0,0 @@\n-#![allow(\n-    // False positive\n-    clippy::match_same_arms\n-)]\n-\n-use super::ARITHMETIC;\n-use clippy_utils::{consts::constant_simple, diagnostics::span_lint};\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::impl_lint_pass;\n-use rustc_span::source_map::Span;\n-\n-const HARD_CODED_ALLOWED: &[&str] = &[\"std::num::Saturating\", \"std::string::String\", \"std::num::Wrapping\"];\n-\n-#[derive(Debug)]\n-pub struct Arithmetic {\n-    allowed: FxHashSet<String>,\n-    // Used to check whether expressions are constants, such as in enum discriminants and consts\n-    const_span: Option<Span>,\n-    expr_span: Option<Span>,\n-}\n-\n-impl_lint_pass!(Arithmetic => [ARITHMETIC]);\n-\n-impl Arithmetic {\n-    #[must_use]\n-    pub fn new(mut allowed: FxHashSet<String>) -> Self {\n-        allowed.extend(HARD_CODED_ALLOWED.iter().copied().map(String::from));\n-        Self {\n-            allowed,\n-            const_span: None,\n-            expr_span: None,\n-        }\n-    }\n-\n-    /// Checks if the given `expr` has any of the inner `allowed` elements.\n-    fn is_allowed_ty(&self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n-        self.allowed.contains(\n-            cx.typeck_results()\n-                .expr_ty(expr)\n-                .to_string()\n-                .split('<')\n-                .next()\n-                .unwrap_or_default(),\n-        )\n-    }\n-\n-    fn issue_lint(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        span_lint(cx, ARITHMETIC, expr.span, \"arithmetic detected\");\n-        self.expr_span = Some(expr.span);\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if self.expr_span.is_some() {\n-            return;\n-        }\n-        if let Some(span) = self.const_span && span.contains(expr.span) {\n-            return;\n-        }\n-        match &expr.kind {\n-            hir::ExprKind::Binary(op, lhs, rhs) | hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                let (\n-                    hir::BinOpKind::Add\n-                    | hir::BinOpKind::Sub\n-                    | hir::BinOpKind::Mul\n-                    | hir::BinOpKind::Div\n-                    | hir::BinOpKind::Rem\n-                    | hir::BinOpKind::Shl\n-                    | hir::BinOpKind::Shr\n-                ) = op.node else {\n-                    return;\n-                };\n-                if self.is_allowed_ty(cx, lhs) || self.is_allowed_ty(cx, rhs) {\n-                    return;\n-                }\n-                self.issue_lint(cx, expr);\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Neg, _) => {\n-                // CTFE already takes care of things like `-1` that do not overflow.\n-                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-                    self.issue_lint(cx, expr);\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n-        match cx.tcx.hir().body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                let body_span = cx.tcx.def_span(body_owner);\n-                if let Some(span) = self.const_span && span.contains(body_span) {\n-                    return;\n-                }\n-                self.const_span = Some(body_span);\n-            },\n-            hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => {},\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner(body.id());\n-        let body_span = cx.tcx.hir().span(body_owner);\n-        if let Some(span) = self.const_span && span.contains(body_span) {\n-            return;\n-        }\n-        self.const_span = None;\n-    }\n-\n-    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if Some(expr.span) == self.expr_span {\n-            self.expr_span = None;\n-        }\n-    }\n-}"}, {"sha": "83b69fbb3116466f3799a5f9b3d81bb3bb8ae000", "filename": "clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,173 @@\n+#![allow(\n+    // False positive\n+    clippy::match_same_arms\n+)]\n+\n+use super::ARITHMETIC_SIDE_EFFECTS;\n+use clippy_utils::{consts::constant_simple, diagnostics::span_lint};\n+use rustc_ast as ast;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_session::impl_lint_pass;\n+use rustc_span::source_map::{Span, Spanned};\n+\n+const HARD_CODED_ALLOWED: &[&str] = &[\n+    \"f32\",\n+    \"f64\",\n+    \"std::num::Saturating\",\n+    \"std::string::String\",\n+    \"std::num::Wrapping\",\n+];\n+\n+#[derive(Debug)]\n+pub struct ArithmeticSideEffects {\n+    allowed: FxHashSet<String>,\n+    // Used to check whether expressions are constants, such as in enum discriminants and consts\n+    const_span: Option<Span>,\n+    expr_span: Option<Span>,\n+}\n+\n+impl_lint_pass!(ArithmeticSideEffects => [ARITHMETIC_SIDE_EFFECTS]);\n+\n+impl ArithmeticSideEffects {\n+    #[must_use]\n+    pub fn new(mut allowed: FxHashSet<String>) -> Self {\n+        allowed.extend(HARD_CODED_ALLOWED.iter().copied().map(String::from));\n+        Self {\n+            allowed,\n+            const_span: None,\n+            expr_span: None,\n+        }\n+    }\n+\n+    /// Checks assign operators (+=, -=, *=, /=) of integers in a non-constant environment that\n+    /// won't overflow.\n+    fn has_valid_assign_op(op: &Spanned<hir::BinOpKind>, rhs: &hir::Expr<'_>, rhs_refs: Ty<'_>) -> bool {\n+        if !Self::is_literal_integer(rhs, rhs_refs) {\n+            return false;\n+        }\n+        if let hir::BinOpKind::Div | hir::BinOpKind::Mul = op.node\n+            && let hir::ExprKind::Lit(ref lit) = rhs.kind\n+            && let ast::LitKind::Int(1, _) = lit.node\n+        {\n+            return true;\n+        }\n+        false\n+    }\n+\n+    /// Checks \"raw\" binary operators (+, -, *, /) of integers in a non-constant environment\n+    /// already handled by the CTFE.\n+    fn has_valid_bin_op(lhs: &hir::Expr<'_>, lhs_refs: Ty<'_>, rhs: &hir::Expr<'_>, rhs_refs: Ty<'_>) -> bool {\n+        Self::is_literal_integer(lhs, lhs_refs) && Self::is_literal_integer(rhs, rhs_refs)\n+    }\n+\n+    /// Checks if the given `expr` has any of the inner `allowed` elements.\n+    fn is_allowed_ty(&self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+        self.allowed.contains(\n+            cx.typeck_results()\n+                .expr_ty(expr)\n+                .to_string()\n+                .split('<')\n+                .next()\n+                .unwrap_or_default(),\n+        )\n+    }\n+\n+    /// Explicit integers like `1` or `i32::MAX`. Does not take into consideration references.\n+    fn is_literal_integer(expr: &hir::Expr<'_>, expr_refs: Ty<'_>) -> bool {\n+        let is_integral = expr_refs.is_integral();\n+        let is_literal = matches!(expr.kind, hir::ExprKind::Lit(_));\n+        is_integral && is_literal\n+    }\n+\n+    fn issue_lint(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n+        span_lint(cx, ARITHMETIC_SIDE_EFFECTS, expr.span, \"arithmetic detected\");\n+        self.expr_span = Some(expr.span);\n+    }\n+\n+    /// Manages when the lint should be triggered. Operations in constant environments, hard coded\n+    /// types, custom allowed types and non-constant operations that won't overflow are ignored.\n+    fn manage_bin_ops(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        op: &Spanned<hir::BinOpKind>,\n+        lhs: &hir::Expr<'_>,\n+        rhs: &hir::Expr<'_>,\n+    ) {\n+        if constant_simple(cx, cx.typeck_results(), expr).is_some() {\n+            return;\n+        }\n+        if !matches!(\n+            op.node,\n+            hir::BinOpKind::Add\n+                | hir::BinOpKind::Sub\n+                | hir::BinOpKind::Mul\n+                | hir::BinOpKind::Div\n+                | hir::BinOpKind::Rem\n+                | hir::BinOpKind::Shl\n+                | hir::BinOpKind::Shr\n+        ) {\n+            return;\n+        };\n+        if self.is_allowed_ty(cx, lhs) || self.is_allowed_ty(cx, rhs) {\n+            return;\n+        }\n+        let lhs_refs = cx.typeck_results().expr_ty(lhs).peel_refs();\n+        let rhs_refs = cx.typeck_results().expr_ty(rhs).peel_refs();\n+        let has_valid_assign_op = Self::has_valid_assign_op(op, rhs, rhs_refs);\n+        if has_valid_assign_op || Self::has_valid_bin_op(lhs, lhs_refs, rhs, rhs_refs) {\n+            return;\n+        }\n+        self.issue_lint(cx, expr);\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ArithmeticSideEffects {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if self.expr_span.is_some() || self.const_span.map_or(false, |sp| sp.contains(expr.span)) {\n+            return;\n+        }\n+        match &expr.kind {\n+            hir::ExprKind::Binary(op, lhs, rhs) | hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+                self.manage_bin_ops(cx, expr, op, lhs, rhs);\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::Neg, _) => {\n+                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n+                    self.issue_lint(cx, expr);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_owner_def_id = cx.tcx.hir().local_def_id(body_owner);\n+        let body_owner_kind = cx.tcx.hir().body_owner_kind(body_owner_def_id);\n+        if let hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) = body_owner_kind {\n+            let body_span = cx.tcx.hir().span_with_body(body_owner);\n+            if let Some(span) = self.const_span && span.contains(body_span) {\n+                return;\n+            }\n+            self.const_span = Some(body_span);\n+        }\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n+        if let Some(span) = self.const_span && span.contains(body_span) {\n+            return;\n+        }\n+        self.const_span = None;\n+    }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if Some(expr.span) == self.expr_span {\n+            self.expr_span = None;\n+        }\n+    }\n+}"}, {"sha": "c32b4df4f75c1f3daebf4911ac70332160aa6935", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -21,7 +21,7 @@ mod ptr_eq;\n mod self_assignment;\n mod verbose_bit_mask;\n \n-pub(crate) mod arithmetic;\n+pub(crate) mod arithmetic_side_effects;\n \n use rustc_hir::{Body, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -61,25 +61,29 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for any kind of arithmetic operation of any type.\n+    /// Checks any kind of arithmetic operation of any type.\n     ///\n     /// Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n     /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or can panic (`/`, `%`). Known safe built-in types like `Wrapping` or `Saturing` are filtered\n-    /// away.\n+    /// or can panic (`/`, `%`).\n+    ///\n+    /// Known safe built-in types like `Wrapping` or `Saturing`, floats, operations in constant\n+    /// environments, allowed types and non-constant operations that won't overflow are ignored.\n     ///\n     /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    /// For integers, overflow will trigger a panic in debug builds or wrap the result in\n+    /// release mode; division by zero will cause a panic in either mode. As a result, it is\n+    /// desirable to explicitly call checked, wrapping or saturating arithmetic methods.\n     ///\n     /// #### Example\n     /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n+    /// // `n` can be any number, including `i32::MAX`.\n+    /// fn foo(n: i32) -> i32 {\n+    ///   n + 1\n+    /// }\n     /// ```\n     ///\n-    /// Third-party types also tend to overflow.\n+    /// Third-party types can also overflow or present unwanted side-effects.\n     ///\n     /// #### Example\n     /// ```ignore,rust\n@@ -88,11 +92,11 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// ### Allowed types\n-    /// Custom allowed types can be specified through the \"arithmetic-allowed\" filter.\n+    /// Custom allowed types can be specified through the \"arithmetic-side-effects-allowed\" filter.\n     #[clippy::version = \"1.64.0\"]\n-    pub ARITHMETIC,\n+    pub ARITHMETIC_SIDE_EFFECTS,\n     restriction,\n-    \"any arithmetic expression that could overflow or panic\"\n+    \"any arithmetic expression that can cause side effects like overflows or panics\"\n }\n \n declare_clippy_lint! {\n@@ -785,7 +789,7 @@ pub struct Operators {\n }\n impl_lint_pass!(Operators => [\n     ABSURD_EXTREME_COMPARISONS,\n-    ARITHMETIC,\n+    ARITHMETIC_SIDE_EFFECTS,\n     INTEGER_ARITHMETIC,\n     FLOAT_ARITHMETIC,\n     ASSIGN_OP_PATTERN,"}, {"sha": "4aa0d9227abadd80aba8b0811f8f893e0a7965ac", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -69,7 +69,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir\n         }\n         true\n     })\n-    .visit_expr(&body.value);\n+    .visit_expr(body.value);\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "41d1baba64f851ffa6409bef6e1c6f3f62575ca4", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -507,7 +507,7 @@ fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Optio\n         if let Some(args) = args\n             && !args.is_empty()\n             && body.map_or(true, |body| {\n-                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, &body.value)\n+                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, body.value)\n             })\n         {\n             span_lint_and_then(\n@@ -664,7 +664,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n         results,\n         skip_count,\n     };\n-    v.visit_expr(&body.value);\n+    v.visit_expr(body.value);\n     v.results\n }\n "}, {"sha": "918d624eec6fa852da2d6767b4c2eef29f5cb7ed", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -350,21 +350,15 @@ fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<R\n // exclusive range plus one: `x..(y+1)`\n fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n+        if expr.span.can_be_used_for_suggestions();\n         if let Some(higher::Range {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n         }) = higher::Range::hir(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n-            let span = if expr.span.from_expansion() {\n-                expr.span\n-                    .ctxt()\n-                    .outer_expn_data()\n-                    .call_site\n-            } else {\n-                expr.span\n-            };\n+            let span = expr.span;\n             span_lint_and_then(\n                 cx,\n                 RANGE_PLUS_ONE,\n@@ -399,6 +393,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n+        if expr.span.can_be_used_for_suggestions();\n         if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::Range::hir(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {"}, {"sha": "91553240e3c910fa4a25d4222a9c315a6ca0dad3", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 } else {\n                     RetReplacement::Empty\n                 };\n-                check_final_expr(cx, &body.value, Some(body.value.span), replacement);\n+                check_final_expr(cx, body.value, Some(body.value.span), replacement);\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 if let ExprKind::Block(block, _) = body.value.kind {"}, {"sha": "6add20c1fb712dcad9575e7b2b278bc4125f1412", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n             ]\n                 .iter()\n                 .find(|&(ts, _)| ts.iter().any(|&t| Ok(trait_id) == cx.tcx.lang_items().require(t)));\n-            if count_binops(&body.value) == 1;\n+            if count_binops(body.value) == 1;\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "c0a4f3fbacd6487521ae0b9ca0777545176e1e51", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n             let args = std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>();\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {\n-                    match check_arg(cx, &args[i]) {\n+                    match check_arg(cx, args[i]) {\n                         Some((span, None)) => {\n                             span_lint(\n                                 cx,"}, {"sha": "a6f777abc6e942aaf0259f83314b859ba569efb0", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -50,7 +50,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         })\n         .collect::<Vec<_>>();\n     if !args_to_recover.is_empty() && !is_from_proc_macro(cx, expr) {\n-        lint_unit_args(cx, expr, &args_to_recover.as_slice());\n+        lint_unit_args(cx, expr, args_to_recover.as_slice());\n     }\n }\n "}, {"sha": "2c40827db0e75677800317cf9af9e397028e8b35", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n \n         // Check if all return expression respect the following condition and collect them.\n         let mut suggs = Vec::new();\n-        let can_sugg = find_all_ret_expressions(cx, &body.value, |ret_expr| {\n+        let can_sugg = find_all_ret_expressions(cx, body.value, |ret_expr| {\n             if_chain! {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call."}, {"sha": "7e451b7b7a419239c5c136541ab74222e54fce8e", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -160,7 +160,7 @@ fn collect_unwrap_info<'tcx>(\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, name) || is_relevant_result_call(cx, ty, name);\n             then {\n-                assert!(args.len() == 0);\n+                assert!(args.is_empty());\n                 let unwrappable = match name {\n                     \"is_some\" | \"is_ok\" => true,\n                     \"is_err\" | \"is_none\" => false,"}, {"sha": "46020adcaa2caae66e67974e86f0f17f08543c44", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n \n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(&arglists[0].0).peel_refs();\n+            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n             if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n                 || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n             {\n@@ -114,7 +114,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tc\n             typeck_results: cx.tcx.typeck(impl_item.def_id),\n             result: Vec::new(),\n         };\n-        fpu.visit_expr(&body.value);\n+        fpu.visit_expr(body.value);\n \n         // if we've found one, lint\n         if !fpu.result.is_empty() {"}, {"sha": "4003fff27c006a7d5956aa6094406fc4f1f735eb", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -142,7 +142,7 @@ fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n     let hir = cx.tcx.hir();\n     if let Some(body_id) = hir.maybe_body_owned_by(hir_id.expect_owner()) {\n         check_node(cx, hir_id, |v| {\n-            v.expr(&v.bind(\"expr\", &hir.body(body_id).value));\n+            v.expr(&v.bind(\"expr\", hir.body(body_id).value));\n         });\n     }\n }"}, {"sha": "a8500beb25747aa9d95516cd24bbeaffac094e79", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -208,7 +208,7 @@ define_Conf! {\n     /// Lint: Arithmetic.\n     ///\n     /// Suppress checking of the passed type names.\n-    (arithmetic_allowed: rustc_data_structures::fx::FxHashSet<String> = <_>::default()),\n+    (arithmetic_side_effects_allowed: rustc_data_structures::fx::FxHashSet<String> = <_>::default()),\n     /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UNUSED_SELF, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates."}, {"sha": "17d9a041857678adfe81e0d950defc3e6a417431", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -505,7 +505,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                             .hir_id(),\n                     ),\n                 );\n-                collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n+                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n             }\n         }\n     }\n@@ -653,7 +653,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, [self_arg, ..], _) = &expr.kind;\n+            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(fn_name.as_str());\n             let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n@@ -685,9 +685,8 @@ impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n         let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n         if_chain! {\n             if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n-            let args = arg_lists[1];\n-            if args.len() == 1;\n-            let self_arg = &args.0;\n+            let (self_arg, args)= arg_lists[1];\n+            if args.is_empty();\n             let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n             if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n             then {\n@@ -734,30 +733,30 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(body);\n-            let only_expr = peel_blocks_with_stmt(&body.value);\n-            if let ExprKind::MethodCall(ps, span_call_args, _) = &only_expr.kind;\n-            if let ExprKind::Path(..) = span_call_args[0].kind;\n+            let only_expr = peel_blocks_with_stmt(body.value);\n+            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = recv.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n                 let mut sle = SpanlessEq::new(cx).deny_side_effects();\n                 match ps.ident.as_str() {\n-                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n+                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n                         suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n                     },\n-                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n-                        let help_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n+                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n                         suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n                     },\n-                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n-                        let note_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n+                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n                         suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n                     },\n                     \"help\" => {\n-                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n                         suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n                     }\n                     \"note\" => {\n-                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n                         suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n                     }\n                     _  => (),\n@@ -798,9 +797,9 @@ fn span_suggestion_snippets<'a, 'hir>(\n     cx: &LateContext<'_>,\n     span_call_args: &'hir [Expr<'hir>],\n ) -> SpanSuggestionSnippets<'a> {\n-    let help_snippet = snippet(cx, span_call_args[2].span, r#\"\"...\"\"#);\n-    let sugg_snippet = snippet(cx, span_call_args[3].span, \"..\");\n-    let applicability_snippet = snippet(cx, span_call_args[4].span, \"Applicability::MachineApplicable\");\n+    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n+    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n \n     SpanSuggestionSnippets {\n         help: help_snippet,\n@@ -954,7 +953,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n                 if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n                     if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n                         let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, &body.value);\n+                        return path_to_matched_type(cx, body.value);\n                     }\n                 }\n             },\n@@ -1046,7 +1045,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n             if el_ty.is_str();\n             let body = cx.tcx.hir().body(body_id);\n             let typeck_results = cx.tcx.typeck_body(body_id);\n-            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, &body.value);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n             let path: Vec<&str> = path.iter().map(|x| {\n                     if let Constant::Str(s) = x {\n                         s.as_str()\n@@ -1177,7 +1176,7 @@ impl InterningDefinedSymbol {\n         };\n         if_chain! {\n             // is a method call\n-            if let ExprKind::MethodCall(_, [item], _) = call.kind;\n+            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n             if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n             let ty = cx.typeck_results().expr_ty(item);\n             // ...on either an Ident or a Symbol"}, {"sha": "342f627e38275ce925c224595542abadfef9b2e3", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1145,8 +1145,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n                     self.add_single_span_suggestion();\n                 }\n             },\n-            ExprKind::MethodCall(path, arg, _arg_span) => {\n-                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n+            ExprKind::MethodCall(path, recv, _, _arg_span) => {\n+                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(recv));\n                 if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n                     let called_method = path.ident.name.as_str().to_string();\n                     for (method_name, is_multi_part) in &SUGGESTION_DIAGNOSTIC_BUILDER_METHODS {"}, {"sha": "bd5be0c9d7eda70d5db3c9e973c7471c034d47ee", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -86,7 +86,7 @@ impl VecPushSearcher {\n                 },\n                 ExprKind::Unary(UnOp::Deref, _) | ExprKind::Index(..) if !needs_mut => {\n                     let mut last_place = parent;\n-                    while let Some(parent) = get_parent_expr(cx, parent) {\n+                    while let Some(parent) = get_parent_expr(cx, last_place) {\n                         if matches!(parent.kind, ExprKind::Unary(UnOp::Deref, _) | ExprKind::Field(..))\n                             || matches!(parent.kind, ExprKind::Index(e, _) if e.hir_id == last_place.hir_id)\n                         {"}, {"sha": "640a09a7a912347396816d4fec4c0b41c5f09c55", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -805,7 +805,11 @@ fn check_newlines(fmtstr: &StrLit) -> bool {\n     let contents = fmtstr.symbol.as_str();\n \n     let mut cb = |r: Range<usize>, c: Result<char, EscapeError>| {\n-        let c = c.unwrap();\n+        let c = match c {\n+            Ok(c) => c,\n+            Err(e) if !e.is_fatal() => return,\n+            Err(e) => panic!(\"{:?}\", e),\n+        };\n \n         if r.end == contents.len() && c == '\\n' && !last_was_cr && !has_internal_newline {\n             should_lint = true;"}, {"sha": "7a8d4e8068ed6dc514031623c55a5d2e47333c07", "filename": "clippy_utils/src/check_proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcheck_proc_macro.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -140,7 +140,7 @@ fn expr_search_pat(tcx: TyCtxt<'_>, e: &Expr<'_>) -> (Pat, Pat) {\n         ExprKind::Match(e, _, MatchSource::AwaitDesugar) | ExprKind::Yield(e, YieldSource::Await { .. }) => {\n             (expr_search_pat(tcx, e).0, Pat::Str(\"await\"))\n         },\n-        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, &tcx.hir().body(body).value).1),\n+        ExprKind::Closure(&Closure { body, .. }) => (Pat::Str(\"\"), expr_search_pat(tcx, tcx.hir().body(body).value).1),\n         ExprKind::Block(\n             Block {\n                 rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n@@ -254,7 +254,7 @@ fn fn_kind_pat(tcx: TyCtxt<'_>, kind: &FnKind<'_>, body: &Body<'_>, hir_id: HirI\n     let (start_pat, end_pat) = match kind {\n         FnKind::ItemFn(.., header) => (fn_header_search_pat(*header), Pat::Str(\"\")),\n         FnKind::Method(.., sig) => (fn_header_search_pat(sig.header), Pat::Str(\"\")),\n-        FnKind::Closure => return (Pat::Str(\"\"), expr_search_pat(tcx, &body.value).1),\n+        FnKind::Closure => return (Pat::Str(\"\"), expr_search_pat(tcx, body.value).1),\n     };\n     let start_pat = match tcx.hir().get(hir_id) {\n         Node::Item(Item { vis_span, .. }) | Node::ImplItem(ImplItem { vis_span, .. }) => {"}, {"sha": "91c9c382c236bcbc87c535976c33944fba629bf8", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -45,7 +45,7 @@ impl ops::BitOrAssign for EagernessSuggestion {\n }\n \n /// Determine the eagerness of the given function call.\n-fn fn_eagerness<'tcx>(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, have_one_arg: bool) -> EagernessSuggestion {\n+fn fn_eagerness(cx: &LateContext<'_>, fn_id: DefId, name: Symbol, have_one_arg: bool) -> EagernessSuggestion {\n     use EagernessSuggestion::{Eager, Lazy, NoChange};\n     let name = name.as_str();\n "}, {"sha": "7212d9cd744510fb8ba8763d6a4e9570b7bc4036", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -201,8 +201,8 @@ impl HirEqInterExpr<'_, '_, '_> {\n             self.inner.cx.tcx.typeck_body(right),\n         ));\n         let res = self.eq_expr(\n-            &self.inner.cx.tcx.hir().body(left).value,\n-            &self.inner.cx.tcx.hir().body(right).value,\n+            self.inner.cx.tcx.hir().body(left).value,\n+            self.inner.cx.tcx.hir().body(right).value,\n         );\n         self.inner.maybe_typeck_results = old_maybe_typeck_results;\n         res\n@@ -649,7 +649,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             }) => {\n                 std::mem::discriminant(&capture_clause).hash(&mut self.s);\n                 // closures inherit TypeckResults\n-                self.hash_expr(&self.cx.tcx.hir().body(body).value);\n+                self.hash_expr(self.cx.tcx.hir().body(body).value);\n             },\n             ExprKind::Field(e, ref f) => {\n                 self.hash_expr(e);\n@@ -1011,15 +1011,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_body(&mut self, body_id: BodyId) {\n         // swap out TypeckResults when hashing a body\n         let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body_id));\n-        self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n+        self.hash_expr(self.cx.tcx.hir().body(body_id).value);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n     }\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n         for arg in arg_list {\n             match *arg {\n                 GenericArg::Lifetime(l) => self.hash_lifetime(l),\n-                GenericArg::Type(ref ty) => self.hash_ty(ty),\n+                GenericArg::Type(ty) => self.hash_ty(ty),\n                 GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n                 GenericArg::Infer(ref inf) => self.hash_ty(&inf.to_ty()),\n             }"}, {"sha": "bdb858e1f9384b307172f2802f92d7ce4001b0ff", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1031,12 +1031,12 @@ pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'\n     v.allow_closure.then_some(v.captures)\n }\n \n+/// Arguments of a method: the receiver and all the additional arguments.\n+pub type MethodArguments<'tcx> = Vec<(&'tcx Expr<'tcx>, &'tcx [Expr<'tcx>])>;\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n-pub fn method_calls<'tcx>(\n-    expr: &'tcx Expr<'tcx>,\n-    max_depth: usize,\n-) -> (Vec<Symbol>, Vec<(&'tcx Expr<'tcx>, &'tcx [Expr<'tcx>])>, Vec<Span>) {\n+pub fn method_calls<'tcx>(expr: &'tcx Expr<'tcx>, max_depth: usize) -> (Vec<Symbol>, MethodArguments<'tcx>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);\n     let mut spans = Vec::with_capacity(max_depth);"}, {"sha": "bd89ff977f87791dd6deacaf193b34e7781ffd62", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -389,8 +389,10 @@ impl FormatString {\n         };\n \n         let mut unescaped = String::with_capacity(inner.len());\n-        unescape_literal(inner, mode, &mut |_, ch| {\n-            unescaped.push(ch.unwrap());\n+        unescape_literal(inner, mode, &mut |_, ch| match ch {\n+            Ok(ch) => unescaped.push(ch),\n+            Err(e) if !e.is_fatal() => (),\n+            Err(e) => panic!(\"{:?}\", e),\n         });\n \n         let mut parts = Vec::new();"}, {"sha": "d5f64e5118f563b97cc2c497b1d1fa2dd7429d78", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -6,8 +6,8 @@\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n-    Body, CastKind, NullOp, Operand, Place, ProjectionElem, Rvalue, Statement, StatementKind, Terminator,\n-    TerminatorKind, NonDivergingIntrinsic\n+    Body, CastKind, NonDivergingIntrinsic, NullOp, Operand, Place, ProjectionElem, Rvalue, Statement, StatementKind,\n+    Terminator, TerminatorKind,\n };\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n@@ -212,9 +212,7 @@ fn check_statement<'tcx>(\n             check_place(tcx, **place, span, body)\n         },\n \n-        StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => {\n-            check_operand(tcx, op, span, body)\n-        },\n+        StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => check_operand(tcx, op, span, body),\n \n         StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n             rustc_middle::mir::CopyNonOverlapping { dst, src, count },"}, {"sha": "232d571902b6c20a8f84684e7ca1ca5e88206f47", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -274,7 +274,7 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n         }\n         !found\n     })\n-    .visit_expr(&cx.tcx.hir().body(body).value);\n+    .visit_expr(cx.tcx.hir().body(body).value);\n     found\n }\n \n@@ -568,6 +568,7 @@ pub fn for_each_local_use_after_expr<'tcx, B>(\n // Calls the given function for every unconsumed temporary created by the expression. Note the\n // function is only guaranteed to be called for types which need to be dropped, but it may be called\n // for other types.\n+#[allow(clippy::too_many_lines)]\n pub fn for_each_unconsumed_temporary<'tcx, B>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'tcx>,"}, {"sha": "ebbe9c9ae675f0039510d8e736cc2a79fbadf59c", "filename": "lintcheck/lintcheck_crates.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/lintcheck%2Flintcheck_crates.toml", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/lintcheck%2Flintcheck_crates.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Flintcheck_crates.toml?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,6 +1,6 @@\n [crates]\n # some of these are from cargotest\n-cargo = {name = \"cargo\", versions = ['0.49.0']}\n+cargo = {name = \"cargo\", versions = ['0.64.0']}\n iron = {name = \"iron\", versions = ['0.6.1']}\n ripgrep = {name = \"ripgrep\", versions = ['12.1.1']}\n xsv = {name = \"xsv\", versions = ['0.13.0']}"}, {"sha": "b6976366dafc9c66287a30ac986407e9865998eb", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-27\"\n+channel = \"nightly-2022-09-08\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "f3a5048e7fa824994f367ea83ee09805c27dec3b", "filename": "src/docs.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,596 @@\n+// autogenerated. Please look at /clippy_dev/src/update_lints.rs\n+\n+macro_rules! include_lint {\n+    ($file_name: expr) => {\n+        include_str!($file_name)\n+    };\n+}\n+\n+macro_rules! docs {\n+    ($($lint_name: expr,)*) => {\n+        pub fn explain(lint: &str) {\n+            println!(\"{}\", match lint {\n+                $(\n+                    $lint_name => include_lint!(concat!(\"docs/\", concat!($lint_name, \".txt\"))),\n+                )*\n+                _ => \"unknown lint\",\n+            })\n+        }\n+    }\n+}\n+\n+docs! {\n+    \"absurd_extreme_comparisons\",\n+    \"alloc_instead_of_core\",\n+    \"allow_attributes_without_reason\",\n+    \"almost_complete_letter_range\",\n+    \"almost_swapped\",\n+    \"approx_constant\",\n+    \"arithmetic_side_effects\",\n+    \"as_conversions\",\n+    \"as_underscore\",\n+    \"assertions_on_constants\",\n+    \"assertions_on_result_states\",\n+    \"assign_op_pattern\",\n+    \"async_yields_async\",\n+    \"await_holding_invalid_type\",\n+    \"await_holding_lock\",\n+    \"await_holding_refcell_ref\",\n+    \"bad_bit_mask\",\n+    \"bind_instead_of_map\",\n+    \"blanket_clippy_restriction_lints\",\n+    \"blocks_in_if_conditions\",\n+    \"bool_assert_comparison\",\n+    \"bool_comparison\",\n+    \"bool_to_int_with_if\",\n+    \"borrow_as_ptr\",\n+    \"borrow_deref_ref\",\n+    \"borrow_interior_mutable_const\",\n+    \"borrowed_box\",\n+    \"box_collection\",\n+    \"boxed_local\",\n+    \"branches_sharing_code\",\n+    \"builtin_type_shadow\",\n+    \"bytes_count_to_len\",\n+    \"bytes_nth\",\n+    \"cargo_common_metadata\",\n+    \"case_sensitive_file_extension_comparisons\",\n+    \"cast_abs_to_unsigned\",\n+    \"cast_enum_constructor\",\n+    \"cast_enum_truncation\",\n+    \"cast_lossless\",\n+    \"cast_possible_truncation\",\n+    \"cast_possible_wrap\",\n+    \"cast_precision_loss\",\n+    \"cast_ptr_alignment\",\n+    \"cast_ref_to_mut\",\n+    \"cast_sign_loss\",\n+    \"cast_slice_different_sizes\",\n+    \"cast_slice_from_raw_parts\",\n+    \"char_lit_as_u8\",\n+    \"chars_last_cmp\",\n+    \"chars_next_cmp\",\n+    \"checked_conversions\",\n+    \"clone_double_ref\",\n+    \"clone_on_copy\",\n+    \"clone_on_ref_ptr\",\n+    \"cloned_instead_of_copied\",\n+    \"cmp_nan\",\n+    \"cmp_null\",\n+    \"cmp_owned\",\n+    \"cognitive_complexity\",\n+    \"collapsible_else_if\",\n+    \"collapsible_if\",\n+    \"collapsible_match\",\n+    \"collapsible_str_replace\",\n+    \"comparison_chain\",\n+    \"comparison_to_empty\",\n+    \"copy_iterator\",\n+    \"crate_in_macro_def\",\n+    \"create_dir\",\n+    \"crosspointer_transmute\",\n+    \"dbg_macro\",\n+    \"debug_assert_with_mut_call\",\n+    \"decimal_literal_representation\",\n+    \"declare_interior_mutable_const\",\n+    \"default_instead_of_iter_empty\",\n+    \"default_numeric_fallback\",\n+    \"default_trait_access\",\n+    \"default_union_representation\",\n+    \"deprecated_cfg_attr\",\n+    \"deprecated_semver\",\n+    \"deref_addrof\",\n+    \"deref_by_slicing\",\n+    \"derivable_impls\",\n+    \"derive_hash_xor_eq\",\n+    \"derive_ord_xor_partial_ord\",\n+    \"derive_partial_eq_without_eq\",\n+    \"disallowed_methods\",\n+    \"disallowed_names\",\n+    \"disallowed_script_idents\",\n+    \"disallowed_types\",\n+    \"diverging_sub_expression\",\n+    \"doc_link_with_quotes\",\n+    \"doc_markdown\",\n+    \"double_comparisons\",\n+    \"double_must_use\",\n+    \"double_neg\",\n+    \"double_parens\",\n+    \"drop_copy\",\n+    \"drop_non_drop\",\n+    \"drop_ref\",\n+    \"duplicate_mod\",\n+    \"duplicate_underscore_argument\",\n+    \"duration_subsec\",\n+    \"else_if_without_else\",\n+    \"empty_drop\",\n+    \"empty_enum\",\n+    \"empty_line_after_outer_attr\",\n+    \"empty_loop\",\n+    \"empty_structs_with_brackets\",\n+    \"enum_clike_unportable_variant\",\n+    \"enum_glob_use\",\n+    \"enum_variant_names\",\n+    \"eq_op\",\n+    \"equatable_if_let\",\n+    \"erasing_op\",\n+    \"err_expect\",\n+    \"excessive_precision\",\n+    \"exhaustive_enums\",\n+    \"exhaustive_structs\",\n+    \"exit\",\n+    \"expect_fun_call\",\n+    \"expect_used\",\n+    \"expl_impl_clone_on_copy\",\n+    \"explicit_auto_deref\",\n+    \"explicit_counter_loop\",\n+    \"explicit_deref_methods\",\n+    \"explicit_into_iter_loop\",\n+    \"explicit_iter_loop\",\n+    \"explicit_write\",\n+    \"extend_with_drain\",\n+    \"extra_unused_lifetimes\",\n+    \"fallible_impl_from\",\n+    \"field_reassign_with_default\",\n+    \"filetype_is_file\",\n+    \"filter_map_identity\",\n+    \"filter_map_next\",\n+    \"filter_next\",\n+    \"flat_map_identity\",\n+    \"flat_map_option\",\n+    \"float_arithmetic\",\n+    \"float_cmp\",\n+    \"float_cmp_const\",\n+    \"float_equality_without_abs\",\n+    \"fn_address_comparisons\",\n+    \"fn_params_excessive_bools\",\n+    \"fn_to_numeric_cast\",\n+    \"fn_to_numeric_cast_any\",\n+    \"fn_to_numeric_cast_with_truncation\",\n+    \"for_kv_map\",\n+    \"for_loops_over_fallibles\",\n+    \"forget_copy\",\n+    \"forget_non_drop\",\n+    \"forget_ref\",\n+    \"format_in_format_args\",\n+    \"format_push_string\",\n+    \"from_iter_instead_of_collect\",\n+    \"from_over_into\",\n+    \"from_str_radix_10\",\n+    \"future_not_send\",\n+    \"get_first\",\n+    \"get_last_with_len\",\n+    \"get_unwrap\",\n+    \"identity_op\",\n+    \"if_let_mutex\",\n+    \"if_not_else\",\n+    \"if_same_then_else\",\n+    \"if_then_some_else_none\",\n+    \"ifs_same_cond\",\n+    \"implicit_clone\",\n+    \"implicit_hasher\",\n+    \"implicit_return\",\n+    \"implicit_saturating_sub\",\n+    \"imprecise_flops\",\n+    \"inconsistent_digit_grouping\",\n+    \"inconsistent_struct_constructor\",\n+    \"index_refutable_slice\",\n+    \"indexing_slicing\",\n+    \"ineffective_bit_mask\",\n+    \"inefficient_to_string\",\n+    \"infallible_destructuring_match\",\n+    \"infinite_iter\",\n+    \"inherent_to_string\",\n+    \"inherent_to_string_shadow_display\",\n+    \"init_numbered_fields\",\n+    \"inline_always\",\n+    \"inline_asm_x86_att_syntax\",\n+    \"inline_asm_x86_intel_syntax\",\n+    \"inline_fn_without_body\",\n+    \"inspect_for_each\",\n+    \"int_plus_one\",\n+    \"integer_arithmetic\",\n+    \"integer_division\",\n+    \"into_iter_on_ref\",\n+    \"invalid_null_ptr_usage\",\n+    \"invalid_regex\",\n+    \"invalid_upcast_comparisons\",\n+    \"invalid_utf8_in_unchecked\",\n+    \"invisible_characters\",\n+    \"is_digit_ascii_radix\",\n+    \"items_after_statements\",\n+    \"iter_cloned_collect\",\n+    \"iter_count\",\n+    \"iter_next_loop\",\n+    \"iter_next_slice\",\n+    \"iter_not_returning_iterator\",\n+    \"iter_nth\",\n+    \"iter_nth_zero\",\n+    \"iter_on_empty_collections\",\n+    \"iter_on_single_items\",\n+    \"iter_overeager_cloned\",\n+    \"iter_skip_next\",\n+    \"iter_with_drain\",\n+    \"iterator_step_by_zero\",\n+    \"just_underscores_and_digits\",\n+    \"large_const_arrays\",\n+    \"large_digit_groups\",\n+    \"large_enum_variant\",\n+    \"large_include_file\",\n+    \"large_stack_arrays\",\n+    \"large_types_passed_by_value\",\n+    \"len_without_is_empty\",\n+    \"len_zero\",\n+    \"let_and_return\",\n+    \"let_underscore_drop\",\n+    \"let_underscore_lock\",\n+    \"let_underscore_must_use\",\n+    \"let_unit_value\",\n+    \"linkedlist\",\n+    \"lossy_float_literal\",\n+    \"macro_use_imports\",\n+    \"main_recursion\",\n+    \"manual_assert\",\n+    \"manual_async_fn\",\n+    \"manual_bits\",\n+    \"manual_filter_map\",\n+    \"manual_find\",\n+    \"manual_find_map\",\n+    \"manual_flatten\",\n+    \"manual_instant_elapsed\",\n+    \"manual_map\",\n+    \"manual_memcpy\",\n+    \"manual_non_exhaustive\",\n+    \"manual_ok_or\",\n+    \"manual_range_contains\",\n+    \"manual_rem_euclid\",\n+    \"manual_retain\",\n+    \"manual_saturating_arithmetic\",\n+    \"manual_split_once\",\n+    \"manual_str_repeat\",\n+    \"manual_string_new\",\n+    \"manual_strip\",\n+    \"manual_swap\",\n+    \"manual_unwrap_or\",\n+    \"many_single_char_names\",\n+    \"map_clone\",\n+    \"map_collect_result_unit\",\n+    \"map_entry\",\n+    \"map_err_ignore\",\n+    \"map_flatten\",\n+    \"map_identity\",\n+    \"map_unwrap_or\",\n+    \"match_as_ref\",\n+    \"match_bool\",\n+    \"match_like_matches_macro\",\n+    \"match_on_vec_items\",\n+    \"match_overlapping_arm\",\n+    \"match_ref_pats\",\n+    \"match_result_ok\",\n+    \"match_same_arms\",\n+    \"match_single_binding\",\n+    \"match_str_case_mismatch\",\n+    \"match_wild_err_arm\",\n+    \"match_wildcard_for_single_variants\",\n+    \"maybe_infinite_iter\",\n+    \"mem_forget\",\n+    \"mem_replace_option_with_none\",\n+    \"mem_replace_with_default\",\n+    \"mem_replace_with_uninit\",\n+    \"min_max\",\n+    \"mismatched_target_os\",\n+    \"mismatching_type_param_order\",\n+    \"misrefactored_assign_op\",\n+    \"missing_const_for_fn\",\n+    \"missing_docs_in_private_items\",\n+    \"missing_enforced_import_renames\",\n+    \"missing_errors_doc\",\n+    \"missing_inline_in_public_items\",\n+    \"missing_panics_doc\",\n+    \"missing_safety_doc\",\n+    \"missing_spin_loop\",\n+    \"mistyped_literal_suffixes\",\n+    \"mixed_case_hex_literals\",\n+    \"mixed_read_write_in_expression\",\n+    \"mod_module_files\",\n+    \"module_inception\",\n+    \"module_name_repetitions\",\n+    \"modulo_arithmetic\",\n+    \"modulo_one\",\n+    \"multi_assignments\",\n+    \"multiple_crate_versions\",\n+    \"multiple_inherent_impl\",\n+    \"must_use_candidate\",\n+    \"must_use_unit\",\n+    \"mut_from_ref\",\n+    \"mut_mut\",\n+    \"mut_mutex_lock\",\n+    \"mut_range_bound\",\n+    \"mutable_key_type\",\n+    \"mutex_atomic\",\n+    \"mutex_integer\",\n+    \"naive_bytecount\",\n+    \"needless_arbitrary_self_type\",\n+    \"needless_bitwise_bool\",\n+    \"needless_bool\",\n+    \"needless_borrow\",\n+    \"needless_borrowed_reference\",\n+    \"needless_collect\",\n+    \"needless_continue\",\n+    \"needless_doctest_main\",\n+    \"needless_for_each\",\n+    \"needless_late_init\",\n+    \"needless_lifetimes\",\n+    \"needless_match\",\n+    \"needless_option_as_deref\",\n+    \"needless_option_take\",\n+    \"needless_parens_on_range_literals\",\n+    \"needless_pass_by_value\",\n+    \"needless_question_mark\",\n+    \"needless_range_loop\",\n+    \"needless_return\",\n+    \"needless_splitn\",\n+    \"needless_update\",\n+    \"neg_cmp_op_on_partial_ord\",\n+    \"neg_multiply\",\n+    \"negative_feature_names\",\n+    \"never_loop\",\n+    \"new_ret_no_self\",\n+    \"new_without_default\",\n+    \"no_effect\",\n+    \"no_effect_replace\",\n+    \"no_effect_underscore_binding\",\n+    \"non_ascii_literal\",\n+    \"non_octal_unix_permissions\",\n+    \"non_send_fields_in_send_ty\",\n+    \"nonminimal_bool\",\n+    \"nonsensical_open_options\",\n+    \"nonstandard_macro_braces\",\n+    \"not_unsafe_ptr_arg_deref\",\n+    \"obfuscated_if_else\",\n+    \"octal_escapes\",\n+    \"ok_expect\",\n+    \"only_used_in_recursion\",\n+    \"op_ref\",\n+    \"option_as_ref_deref\",\n+    \"option_env_unwrap\",\n+    \"option_filter_map\",\n+    \"option_if_let_else\",\n+    \"option_map_or_none\",\n+    \"option_map_unit_fn\",\n+    \"option_option\",\n+    \"or_fun_call\",\n+    \"or_then_unwrap\",\n+    \"out_of_bounds_indexing\",\n+    \"overflow_check_conditional\",\n+    \"overly_complex_bool_expr\",\n+    \"panic\",\n+    \"panic_in_result_fn\",\n+    \"panicking_unwrap\",\n+    \"partialeq_ne_impl\",\n+    \"partialeq_to_none\",\n+    \"path_buf_push_overwrite\",\n+    \"pattern_type_mismatch\",\n+    \"positional_named_format_parameters\",\n+    \"possible_missing_comma\",\n+    \"precedence\",\n+    \"print_in_format_impl\",\n+    \"print_literal\",\n+    \"print_stderr\",\n+    \"print_stdout\",\n+    \"print_with_newline\",\n+    \"println_empty_string\",\n+    \"ptr_arg\",\n+    \"ptr_as_ptr\",\n+    \"ptr_eq\",\n+    \"ptr_offset_with_cast\",\n+    \"pub_use\",\n+    \"question_mark\",\n+    \"range_minus_one\",\n+    \"range_plus_one\",\n+    \"range_zip_with_len\",\n+    \"rc_buffer\",\n+    \"rc_clone_in_vec_init\",\n+    \"rc_mutex\",\n+    \"read_zero_byte_vec\",\n+    \"recursive_format_impl\",\n+    \"redundant_allocation\",\n+    \"redundant_clone\",\n+    \"redundant_closure\",\n+    \"redundant_closure_call\",\n+    \"redundant_closure_for_method_calls\",\n+    \"redundant_else\",\n+    \"redundant_feature_names\",\n+    \"redundant_field_names\",\n+    \"redundant_pattern\",\n+    \"redundant_pattern_matching\",\n+    \"redundant_pub_crate\",\n+    \"redundant_slicing\",\n+    \"redundant_static_lifetimes\",\n+    \"ref_binding_to_reference\",\n+    \"ref_option_ref\",\n+    \"repeat_once\",\n+    \"rest_pat_in_fully_bound_structs\",\n+    \"result_large_err\",\n+    \"result_map_or_into_option\",\n+    \"result_map_unit_fn\",\n+    \"result_unit_err\",\n+    \"return_self_not_must_use\",\n+    \"reversed_empty_ranges\",\n+    \"same_functions_in_if_condition\",\n+    \"same_item_push\",\n+    \"same_name_method\",\n+    \"search_is_some\",\n+    \"self_assignment\",\n+    \"self_named_constructors\",\n+    \"self_named_module_files\",\n+    \"semicolon_if_nothing_returned\",\n+    \"separated_literal_suffix\",\n+    \"serde_api_misuse\",\n+    \"shadow_reuse\",\n+    \"shadow_same\",\n+    \"shadow_unrelated\",\n+    \"short_circuit_statement\",\n+    \"should_implement_trait\",\n+    \"significant_drop_in_scrutinee\",\n+    \"similar_names\",\n+    \"single_char_add_str\",\n+    \"single_char_lifetime_names\",\n+    \"single_char_pattern\",\n+    \"single_component_path_imports\",\n+    \"single_element_loop\",\n+    \"single_match\",\n+    \"single_match_else\",\n+    \"size_of_in_element_count\",\n+    \"skip_while_next\",\n+    \"slow_vector_initialization\",\n+    \"stable_sort_primitive\",\n+    \"std_instead_of_alloc\",\n+    \"std_instead_of_core\",\n+    \"str_to_string\",\n+    \"string_add\",\n+    \"string_add_assign\",\n+    \"string_extend_chars\",\n+    \"string_from_utf8_as_bytes\",\n+    \"string_lit_as_bytes\",\n+    \"string_slice\",\n+    \"string_to_string\",\n+    \"strlen_on_c_strings\",\n+    \"struct_excessive_bools\",\n+    \"suboptimal_flops\",\n+    \"suspicious_arithmetic_impl\",\n+    \"suspicious_assignment_formatting\",\n+    \"suspicious_else_formatting\",\n+    \"suspicious_map\",\n+    \"suspicious_op_assign_impl\",\n+    \"suspicious_operation_groupings\",\n+    \"suspicious_splitn\",\n+    \"suspicious_to_owned\",\n+    \"suspicious_unary_op_formatting\",\n+    \"swap_ptr_to_ref\",\n+    \"tabs_in_doc_comments\",\n+    \"temporary_assignment\",\n+    \"to_digit_is_some\",\n+    \"to_string_in_format_args\",\n+    \"todo\",\n+    \"too_many_arguments\",\n+    \"too_many_lines\",\n+    \"toplevel_ref_arg\",\n+    \"trailing_empty_array\",\n+    \"trait_duplication_in_bounds\",\n+    \"transmute_bytes_to_str\",\n+    \"transmute_float_to_int\",\n+    \"transmute_int_to_bool\",\n+    \"transmute_int_to_char\",\n+    \"transmute_int_to_float\",\n+    \"transmute_num_to_bytes\",\n+    \"transmute_ptr_to_ptr\",\n+    \"transmute_ptr_to_ref\",\n+    \"transmute_undefined_repr\",\n+    \"transmutes_expressible_as_ptr_casts\",\n+    \"transmuting_null\",\n+    \"trim_split_whitespace\",\n+    \"trivial_regex\",\n+    \"trivially_copy_pass_by_ref\",\n+    \"try_err\",\n+    \"type_complexity\",\n+    \"type_repetition_in_bounds\",\n+    \"undocumented_unsafe_blocks\",\n+    \"undropped_manually_drops\",\n+    \"unicode_not_nfc\",\n+    \"unimplemented\",\n+    \"uninit_assumed_init\",\n+    \"uninit_vec\",\n+    \"unit_arg\",\n+    \"unit_cmp\",\n+    \"unit_hash\",\n+    \"unit_return_expecting_ord\",\n+    \"unnecessary_cast\",\n+    \"unnecessary_filter_map\",\n+    \"unnecessary_find_map\",\n+    \"unnecessary_fold\",\n+    \"unnecessary_join\",\n+    \"unnecessary_lazy_evaluations\",\n+    \"unnecessary_mut_passed\",\n+    \"unnecessary_operation\",\n+    \"unnecessary_owned_empty_strings\",\n+    \"unnecessary_self_imports\",\n+    \"unnecessary_sort_by\",\n+    \"unnecessary_to_owned\",\n+    \"unnecessary_unwrap\",\n+    \"unnecessary_wraps\",\n+    \"unneeded_field_pattern\",\n+    \"unneeded_wildcard_pattern\",\n+    \"unnested_or_patterns\",\n+    \"unreachable\",\n+    \"unreadable_literal\",\n+    \"unsafe_derive_deserialize\",\n+    \"unsafe_removed_from_name\",\n+    \"unseparated_literal_suffix\",\n+    \"unsound_collection_transmute\",\n+    \"unused_async\",\n+    \"unused_io_amount\",\n+    \"unused_peekable\",\n+    \"unused_rounding\",\n+    \"unused_self\",\n+    \"unused_unit\",\n+    \"unusual_byte_groupings\",\n+    \"unwrap_in_result\",\n+    \"unwrap_or_else_default\",\n+    \"unwrap_used\",\n+    \"upper_case_acronyms\",\n+    \"use_debug\",\n+    \"use_self\",\n+    \"used_underscore_binding\",\n+    \"useless_asref\",\n+    \"useless_attribute\",\n+    \"useless_conversion\",\n+    \"useless_format\",\n+    \"useless_let_if_seq\",\n+    \"useless_transmute\",\n+    \"useless_vec\",\n+    \"vec_box\",\n+    \"vec_init_then_push\",\n+    \"vec_resize_to_zero\",\n+    \"verbose_bit_mask\",\n+    \"verbose_file_reads\",\n+    \"vtable_address_comparisons\",\n+    \"while_immutable_condition\",\n+    \"while_let_loop\",\n+    \"while_let_on_iterator\",\n+    \"wildcard_dependencies\",\n+    \"wildcard_enum_match_arm\",\n+    \"wildcard_imports\",\n+    \"wildcard_in_or_patterns\",\n+    \"write_literal\",\n+    \"write_with_newline\",\n+    \"writeln_empty_string\",\n+    \"wrong_self_convention\",\n+    \"wrong_transmute\",\n+    \"zero_divided_by_zero\",\n+    \"zero_prefixed_literal\",\n+    \"zero_ptr\",\n+    \"zero_sized_map_values\",\n+    \"zst_offset\",\n+\n+}"}, {"sha": "590bee28aa2376be4492aa4c9a53e918ec63805b", "filename": "src/docs/absurd_extreme_comparisons.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fabsurd_extreme_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fabsurd_extreme_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fabsurd_extreme_comparisons.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for comparisons where one side of the relation is\n+either the minimum or maximum value for its type and warns if it involves a\n+case that is always true or always false. Only integer and boolean types are\n+checked.\n+\n+### Why is this bad?\n+An expression like `min <= x` may misleadingly imply\n+that it is possible for `x` to be less than the minimum. Expressions like\n+`max < x` are probably mistakes.\n+\n+### Known problems\n+For `usize` the size of the current compile target will\n+be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+a comparison to detect target pointer width will trigger this lint. One can\n+use `mem::sizeof` and compare its value or conditional compilation\n+attributes\n+like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+\n+### Example\n+```\n+let vec: Vec<isize> = Vec::new();\n+if vec.len() <= 0 {}\n+if 100 > i32::MAX {}\n+```\n\\ No newline at end of file"}, {"sha": "488a36e9276c24d1bd1ded86983a6c423b39c9cb", "filename": "src/docs/alloc_instead_of_core.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falloc_instead_of_core.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falloc_instead_of_core.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falloc_instead_of_core.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+\n+Finds items imported through `alloc` when available through `core`.\n+\n+### Why is this bad?\n+\n+Crates which have `no_std` compatibility and may optionally require alloc may wish to ensure types are\n+imported from core to ensure disabling `alloc` does not cause the crate to fail to compile. This lint\n+is also useful for crates migrating to become `no_std` compatible.\n+\n+### Example\n+```\n+use alloc::slice::from_ref;\n+```\n+Use instead:\n+```\n+use core::slice::from_ref;\n+```\n\\ No newline at end of file"}, {"sha": "fcc4f49b08b37be204fdc034de517c8ba7f1f747", "filename": "src/docs/allow_attributes_without_reason.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fallow_attributes_without_reason.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fallow_attributes_without_reason.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fallow_attributes_without_reason.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for attributes that allow lints without a reason.\n+\n+(This requires the `lint_reasons` feature)\n+\n+### Why is this bad?\n+Allowing a lint should always have a reason. This reason should be documented to\n+ensure that others understand the reasoning\n+\n+### Example\n+```\n+#![feature(lint_reasons)]\n+\n+#![allow(clippy::some_lint)]\n+```\n+\n+Use instead:\n+```\n+#![feature(lint_reasons)]\n+\n+#![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n+```\n\\ No newline at end of file"}, {"sha": "01cbaf9eae259e26155ea29a65fd71addcbd1825", "filename": "src/docs/almost_complete_letter_range.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falmost_complete_letter_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falmost_complete_letter_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falmost_complete_letter_range.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for ranges which almost include the entire range of letters from 'a' to 'z', but\n+don't because they're a half open range.\n+\n+### Why is this bad?\n+This (`'a'..'z'`) is almost certainly a typo meant to include all letters.\n+\n+### Example\n+```\n+let _ = 'a'..'z';\n+```\n+Use instead:\n+```\n+let _ = 'a'..='z';\n+```\n\\ No newline at end of file"}, {"sha": "cd10a8d5409b10afab8778ac88d91e4e5bbdbbfb", "filename": "src/docs/almost_swapped.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falmost_swapped.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Falmost_swapped.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Falmost_swapped.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for `foo = bar; bar = foo` sequences.\n+\n+### Why is this bad?\n+This looks like a failed attempt to swap.\n+\n+### Example\n+```\n+a = b;\n+b = a;\n+```\n+If swapping is intended, use `swap()` instead:\n+```\n+std::mem::swap(&mut a, &mut b);\n+```\n\\ No newline at end of file"}, {"sha": "393fa4b5ef7ecd6734a6a78c64694646c45505be", "filename": "src/docs/approx_constant.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fapprox_constant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fapprox_constant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fapprox_constant.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for floating point literals that approximate\n+constants which are defined in\n+[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n+or\n+[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n+respectively, suggesting to use the predefined constant.\n+\n+### Why is this bad?\n+Usually, the definition in the standard library is more\n+precise than what people come up with. If you find that your definition is\n+actually more precise, please [file a Rust\n+issue](https://github.com/rust-lang/rust/issues).\n+\n+### Example\n+```\n+let x = 3.14;\n+let y = 1_f64 / x;\n+```\n+Use instead:\n+```\n+let x = std::f32::consts::PI;\n+let y = std::f64::consts::FRAC_1_PI;\n+```\n\\ No newline at end of file"}, {"sha": "6c7d51a4989e0b34f54d89c444399be3f502e8f2", "filename": "src/docs/arithmetic_side_effects.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Farithmetic_side_effects.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Farithmetic_side_effects.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Farithmetic_side_effects.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks any kind of arithmetic operation of any type.\n+\n+Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n+Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+or can panic (`/`, `%`).\n+\n+Known safe built-in types like `Wrapping` or `Saturing`, floats, operations in constant\n+environments, allowed types and non-constant operations that won't overflow are ignored.\n+\n+### Why is this bad?\n+For integers, overflow will trigger a panic in debug builds or wrap the result in\n+release mode; division by zero will cause a panic in either mode. As a result, it is\n+desirable to explicitly call checked, wrapping or saturating arithmetic methods.\n+\n+#### Example\n+```\n+// `n` can be any number, including `i32::MAX`.\n+fn foo(n: i32) -> i32 {\n+  n + 1\n+}\n+```\n+\n+Third-party types can also overflow or present unwanted side-effects.\n+\n+#### Example\n+```\n+use rust_decimal::Decimal;\n+let _n = Decimal::MAX + Decimal::MAX;\n+```\n+\n+### Allowed types\n+Custom allowed types can be specified through the \"arithmetic-side-effects-allowed\" filter.\n\\ No newline at end of file"}, {"sha": "4af479bd8111cd213e98fc7a7b14a172a9714b87", "filename": "src/docs/as_conversions.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fas_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fas_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fas_conversions.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for usage of `as` conversions.\n+\n+Note that this lint is specialized in linting *every single* use of `as`\n+regardless of whether good alternatives exist or not.\n+If you want more precise lints for `as`, please consider using these separate lints:\n+`unnecessary_cast`, `cast_lossless/cast_possible_truncation/cast_possible_wrap/cast_precision_loss/cast_sign_loss`,\n+`fn_to_numeric_cast(_with_truncation)`, `char_lit_as_u8`, `ref_to_mut` and `ptr_as_ptr`.\n+There is a good explanation the reason why this lint should work in this way and how it is useful\n+[in this issue](https://github.com/rust-lang/rust-clippy/issues/5122).\n+\n+### Why is this bad?\n+`as` conversions will perform many kinds of\n+conversions, including silently lossy conversions and dangerous coercions.\n+There are cases when it makes sense to use `as`, so the lint is\n+Allow by default.\n+\n+### Example\n+```\n+let a: u32;\n+...\n+f(a as u16);\n+```\n+\n+Use instead:\n+```\n+f(a.try_into()?);\n+\n+// or\n+\n+f(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n+```\n\\ No newline at end of file"}, {"sha": "2d9b0c358936bc7c04d4c708da7a0bf72641cecf", "filename": "src/docs/as_underscore.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fas_underscore.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fas_underscore.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fas_underscore.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Check for the usage of `as _` conversion using inferred type.\n+\n+### Why is this bad?\n+The conversion might include lossy conversion and dangerous cast that might go\n+undetected due to the type being inferred.\n+\n+The lint is allowed by default as using `_` is less wordy than always specifying the type.\n+\n+### Example\n+```\n+fn foo(n: usize) {}\n+let n: u16 = 256;\n+foo(n as _);\n+```\n+Use instead:\n+```\n+fn foo(n: usize) {}\n+let n: u16 = 256;\n+foo(n as usize);\n+```\n\\ No newline at end of file"}, {"sha": "270c1e3b639d96fe496986e003eb62b3dae41f0c", "filename": "src/docs/assertions_on_constants.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassertions_on_constants.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassertions_on_constants.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassertions_on_constants.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `assert!(true)` and `assert!(false)` calls.\n+\n+### Why is this bad?\n+Will be optimized out by the compiler or should probably be replaced by a\n+`panic!()` or `unreachable!()`\n+\n+### Example\n+```\n+assert!(false)\n+assert!(true)\n+const B: bool = false;\n+assert!(B)\n+```\n\\ No newline at end of file"}, {"sha": "0889084fd3ad61447b36aaf81a7fde499afd3577", "filename": "src/docs/assertions_on_result_states.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassertions_on_result_states.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassertions_on_result_states.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassertions_on_result_states.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `assert!(r.is_ok())` or `assert!(r.is_err())` calls.\n+\n+### Why is this bad?\n+An assertion failure cannot output an useful message of the error.\n+\n+### Known problems\n+The suggested replacement decreases the readability of code and log output.\n+\n+### Example\n+```\n+assert!(r.is_ok());\n+assert!(r.is_err());\n+```\n\\ No newline at end of file"}, {"sha": "f355c0cc18d37d69bf4563727d65ce09c28f5a4c", "filename": "src/docs/assign_op_pattern.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassign_op_pattern.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fassign_op_pattern.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fassign_op_pattern.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for `a = a op b` or `a = b commutative_op a`\n+patterns.\n+\n+### Why is this bad?\n+These can be written as the shorter `a op= b`.\n+\n+### Known problems\n+While forbidden by the spec, `OpAssign` traits may have\n+implementations that differ from the regular `Op` impl.\n+\n+### Example\n+```\n+let mut a = 5;\n+let b = 0;\n+// ...\n+\n+a = a + b;\n+```\n+\n+Use instead:\n+```\n+let mut a = 5;\n+let b = 0;\n+// ...\n+\n+a += b;\n+```\n\\ No newline at end of file"}, {"sha": "a40de6d2e473642505f16e46054228bf658eb885", "filename": "src/docs/async_yields_async.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fasync_yields_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fasync_yields_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fasync_yields_async.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for async blocks that yield values of types\n+that can themselves be awaited.\n+\n+### Why is this bad?\n+An await is likely missing.\n+\n+### Example\n+```\n+async fn foo() {}\n+\n+fn bar() {\n+  let x = async {\n+    foo()\n+  };\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo() {}\n+\n+fn bar() {\n+  let x = async {\n+    foo().await\n+  };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e9c768772ff6b8ec4485802bb64d4fe9db265598", "filename": "src/docs/await_holding_invalid_type.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_invalid_type.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_invalid_type.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_invalid_type.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Allows users to configure types which should not be held across `await`\n+suspension points.\n+\n+### Why is this bad?\n+There are some types which are perfectly \"safe\" to be used concurrently\n+from a memory access perspective but will cause bugs at runtime if they\n+are held in such a way.\n+\n+### Example\n+\n+```\n+await-holding-invalid-types = [\n+  # You can specify a type name\n+  \"CustomLockType\",\n+  # You can (optionally) specify a reason\n+  { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n+]\n+```\n+\n+```\n+struct CustomLockType;\n+struct OtherCustomLockType;\n+async fn foo() {\n+  let _x = CustomLockType;\n+  let _y = OtherCustomLockType;\n+  baz().await; // Lint violation\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0f450a11160ccca10c011e7fef781770c421a372", "filename": "src/docs/await_holding_lock.txt", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_lock.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_lock.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_lock.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,51 @@\n+### What it does\n+Checks for calls to await while holding a non-async-aware MutexGuard.\n+\n+### Why is this bad?\n+The Mutex types found in std::sync and parking_lot\n+are not designed to operate in an async context across await points.\n+\n+There are two potential solutions. One is to use an async-aware Mutex\n+type. Many asynchronous foundation crates provide such a Mutex type. The\n+other solution is to ensure the mutex is unlocked before calling await,\n+either by introducing a scope or an explicit call to Drop::drop.\n+\n+### Known problems\n+Will report false positive for explicitly dropped guards\n+([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n+to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n+\n+### Example\n+```\n+async fn foo(x: &Mutex<u32>) {\n+  let mut guard = x.lock().unwrap();\n+  *guard += 1;\n+  baz().await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+  let mut guard = x.lock().unwrap();\n+  *guard += 1;\n+  drop(guard); // explicit drop\n+  baz().await;\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo(x: &Mutex<u32>) {\n+  {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+  }\n+  baz().await;\n+}\n+\n+async fn bar(x: &Mutex<u32>) {\n+  {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+  } // guard dropped here at end of scope\n+  baz().await;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "226a261b9cc5208dcf26ea386ac9898f77685fdb", "filename": "src/docs/await_holding_refcell_ref.txt", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_refcell_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fawait_holding_refcell_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fawait_holding_refcell_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,47 @@\n+### What it does\n+Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n+\n+### Why is this bad?\n+`RefCell` refs only check for exclusive mutable access\n+at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+risks panics from a mutable ref shared while other refs are outstanding.\n+\n+### Known problems\n+Will report false positive for explicitly dropped refs\n+([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n+to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n+\n+### Example\n+```\n+async fn foo(x: &RefCell<u32>) {\n+  let mut y = x.borrow_mut();\n+  *y += 1;\n+  baz().await;\n+}\n+\n+async fn bar(x: &RefCell<u32>) {\n+  let mut y = x.borrow_mut();\n+  *y += 1;\n+  drop(y); // explicit drop\n+  baz().await;\n+}\n+```\n+\n+Use instead:\n+```\n+async fn foo(x: &RefCell<u32>) {\n+  {\n+     let mut y = x.borrow_mut();\n+     *y += 1;\n+  }\n+  baz().await;\n+}\n+\n+async fn bar(x: &RefCell<u32>) {\n+  {\n+    let mut y = x.borrow_mut();\n+    *y += 1;\n+  } // y dropped here at end of scope\n+  baz().await;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d40024ee56209f060cf84cb763ac9aa8911a1f7e", "filename": "src/docs/bad_bit_mask.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbad_bit_mask.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbad_bit_mask.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbad_bit_mask.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Checks for incompatible bit masks in comparisons.\n+\n+The formula for detecting if an expression of the type `_ <bit_op> m\n+<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+table:\n+\n+|Comparison  |Bit Op|Example      |is always|Formula               |\n+|------------|------|-------------|---------|----------------------|\n+|`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n+|`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n+|`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n+|`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n+|`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n+|`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n+\n+### Why is this bad?\n+If the bits that the comparison cares about are always\n+set to zero or one by the bit mask, the comparison is constant `true` or\n+`false` (depending on mask, compared value, and operators).\n+\n+So the code is actively misleading, and the only reason someone would write\n+this intentionally is to win an underhanded Rust contest or create a\n+test-case for this lint.\n+\n+### Example\n+```\n+if (x & 1 == 2) { }\n+```\n\\ No newline at end of file"}, {"sha": "148575803d389de69b51e7e832d713d792c957df", "filename": "src/docs/bind_instead_of_map.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbind_instead_of_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbind_instead_of_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbind_instead_of_map.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n+`_.or_else(|x| Err(y))`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.map(|x| y)` or `_.map_err(|x| y)`.\n+\n+### Example\n+```\n+let _ = opt().and_then(|s| Some(s.len()));\n+let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\n+let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n+```\n+\n+The correct use would be:\n+\n+```\n+let _ = opt().map(|s| s.len());\n+let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n+let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n+```\n\\ No newline at end of file"}, {"sha": "28a4ebf7169bfa744c691d707c06f0cbce55bfaf", "filename": "src/docs/blanket_clippy_restriction_lints.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fblanket_clippy_restriction_lints.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n+\n+### Why is this bad?\n+Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\n+These lints should only be enabled on a lint-by-lint basis and with careful consideration.\n+\n+### Example\n+```\n+#![deny(clippy::restriction)]\n+```\n+\n+Use instead:\n+```\n+#![deny(clippy::as_conversions)]\n+```\n\\ No newline at end of file"}, {"sha": "3afa14853fd216139e4ff8d891fcfab8b57e1eaf", "filename": "src/docs/blocks_in_if_conditions.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fblocks_in_if_conditions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fblocks_in_if_conditions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fblocks_in_if_conditions.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for `if` conditions that use blocks containing an\n+expression, statements or conditions that use closures with blocks.\n+\n+### Why is this bad?\n+Style, using blocks in the condition makes it hard to read.\n+\n+### Examples\n+```\n+if { true } { /* ... */ }\n+\n+if { let x = somefunc(); x } { /* ... */ }\n+```\n+\n+Use instead:\n+```\n+if true { /* ... */ }\n+\n+let res = { let x = somefunc(); x };\n+if res { /* ... */ }\n+```\n\\ No newline at end of file"}, {"sha": "df7ca00cc2ba497488c8e5b8ffcb2696e6eee7bb", "filename": "src/docs/bool_assert_comparison.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_assert_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_assert_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_assert_comparison.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+This lint warns about boolean comparisons in assert-like macros.\n+\n+### Why is this bad?\n+It is shorter to use the equivalent.\n+\n+### Example\n+```\n+assert_eq!(\"a\".is_empty(), false);\n+assert_ne!(\"a\".is_empty(), true);\n+```\n+\n+Use instead:\n+```\n+assert!(!\"a\".is_empty());\n+```\n\\ No newline at end of file"}, {"sha": "0996f60cec44ca3dc32c65c5810e743d146a3129", "filename": "src/docs/bool_comparison.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_comparison.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for expressions of the form `x == true`,\n+`x != true` and order comparisons such as `x < true` (or vice versa) and\n+suggest using the variable directly.\n+\n+### Why is this bad?\n+Unnecessary code.\n+\n+### Example\n+```\n+if x == true {}\n+if y == false {}\n+```\n+use `x` directly:\n+```\n+if x {}\n+if !y {}\n+```\n\\ No newline at end of file"}, {"sha": "63535b454c9f12b961a6f1e0ed3de83335f80bb0", "filename": "src/docs/bool_to_int_with_if.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_to_int_with_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbool_to_int_with_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbool_to_int_with_if.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Instead of using an if statement to convert a bool to an int,\n+this lint suggests using a `from()` function or an `as` coercion.\n+\n+### Why is this bad?\n+Coercion or `from()` is idiomatic way to convert bool to a number.\n+Both methods are guaranteed to return 1 for true, and 0 for false.\n+\n+See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E\n+\n+### Example\n+```\n+if condition {\n+    1_i64\n+} else {\n+    0\n+};\n+```\n+Use instead:\n+```\n+i64::from(condition);\n+```\n+or\n+```\n+condition as i64;\n+```\n\\ No newline at end of file"}, {"sha": "0be865abd578095f3ec4c54651d234eb40d382ae", "filename": "src/docs/borrow_as_ptr.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_as_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_as_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_as_ptr.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for the usage of `&expr as *const T` or\n+`&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n+`ptr::addr_of_mut` instead.\n+\n+### Why is this bad?\n+This would improve readability and avoid creating a reference\n+that points to an uninitialized value or unaligned place.\n+Read the `ptr::addr_of` docs for more information.\n+\n+### Example\n+```\n+let val = 1;\n+let p = &val as *const i32;\n+\n+let mut val_mut = 1;\n+let p_mut = &mut val_mut as *mut i32;\n+```\n+Use instead:\n+```\n+let val = 1;\n+let p = std::ptr::addr_of!(val);\n+\n+let mut val_mut = 1;\n+let p_mut = std::ptr::addr_of_mut!(val_mut);\n+```\n\\ No newline at end of file"}, {"sha": "352480d3f26a723cab9c783a631cab10c5f91e65", "filename": "src/docs/borrow_deref_ref.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_deref_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_deref_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_deref_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for `&*(&T)`.\n+\n+### Why is this bad?\n+Dereferencing and then borrowing a reference value has no effect in most cases.\n+\n+### Known problems\n+False negative on such code:\n+```\n+let x = &12;\n+let addr_x = &x as *const _ as usize;\n+let addr_y = &&*x as *const _ as usize; // assert ok now, and lint triggered.\n+                                        // But if we fix it, assert will fail.\n+assert_ne!(addr_x, addr_y);\n+```\n+\n+### Example\n+```\n+let s = &String::new();\n+\n+let a: &String = &* s;\n+```\n+\n+Use instead:\n+```\n+let a: &String = s;\n+```\n\\ No newline at end of file"}, {"sha": "e55b6a77e6667aa7679e1e35c5b033f24be3b1a1", "filename": "src/docs/borrow_interior_mutable_const.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrow_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrow_interior_mutable_const.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Checks if `const` items which is interior mutable (e.g.,\n+contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n+\n+### Why is this bad?\n+Consts are copied everywhere they are referenced, i.e.,\n+every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+these types in the first place.\n+\n+The `const` value should be stored inside a `static` item.\n+\n+### Known problems\n+When an enum has variants with interior mutability, use of its non\n+interior mutable variants can generate false positives. See issue\n+[#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n+\n+Types that have underlying or potential interior mutability trigger the lint whether\n+the interior mutable field is used or not. See issues\n+[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n+[#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n+\n+### Example\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+\n+CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+```\n+\n+Use instead:\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+\n+static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n+STATIC_ATOM.store(9, SeqCst);\n+assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+```\n\\ No newline at end of file"}, {"sha": "d7089be662a581bd9cf9718b2be607eb172d259f", "filename": "src/docs/borrowed_box.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrowed_box.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fborrowed_box.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fborrowed_box.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for use of `&Box<T>` anywhere in the code.\n+Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n+\n+### Why is this bad?\n+A `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\n+Using `&T` defines a concrete type for the parameter and generalizes the function, this would also\n+auto-deref to `&T` at the function call site if passed a `&Box<T>`.\n+\n+### Example\n+```\n+fn foo(bar: &Box<T>) { ... }\n+```\n+\n+Better:\n+\n+```\n+fn foo(bar: &T) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "053f24c46281d397f8a1fbbe661a1cfdd1037a3e", "filename": "src/docs/box_collection.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbox_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbox_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbox_collection.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\n+Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n+\n+### Why is this bad?\n+Collections already keeps their contents in a separate area on\n+the heap. So if you `Box` them, you just add another level of indirection\n+without any benefit whatsoever.\n+\n+### Example\n+```\n+struct X {\n+    values: Box<Vec<Foo>>,\n+}\n+```\n+\n+Better:\n+\n+```\n+struct X {\n+    values: Vec<Foo>,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "8b1febf1455fdc359e520db3c9f95f5c14bdb282", "filename": "src/docs/boxed_local.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fboxed_local.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fboxed_local.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fboxed_local.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for usage of `Box<T>` where an unboxed `T` would\n+work fine.\n+\n+### Why is this bad?\n+This is an unnecessary allocation, and bad for\n+performance. It is only necessary to allocate if you wish to move the box\n+into something.\n+\n+### Example\n+```\n+fn foo(x: Box<u32>) {}\n+```\n+\n+Use instead:\n+```\n+fn foo(x: u32) {}\n+```\n\\ No newline at end of file"}, {"sha": "79be6124798a254ec8db803b30ea7ba4e9676168", "filename": "src/docs/branches_sharing_code.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbranches_sharing_code.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbranches_sharing_code.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbranches_sharing_code.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks if the `if` and `else` block contain shared code that can be\n+moved out of the blocks.\n+\n+### Why is this bad?\n+Duplicate code is less maintainable.\n+\n+### Known problems\n+* The lint doesn't check if the moved expressions modify values that are being used in\n+  the if condition. The suggestion can in that case modify the behavior of the program.\n+  See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n+\n+### Example\n+```\n+let foo = if \u2026 {\n+    println!(\"Hello World\");\n+    13\n+} else {\n+    println!(\"Hello World\");\n+    42\n+};\n+```\n+\n+Use instead:\n+```\n+println!(\"Hello World\");\n+let foo = if \u2026 {\n+    13\n+} else {\n+    42\n+};\n+```\n\\ No newline at end of file"}, {"sha": "15b1c9df7baab0738c2bb707218955b11d4db60f", "filename": "src/docs/builtin_type_shadow.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbuiltin_type_shadow.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbuiltin_type_shadow.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbuiltin_type_shadow.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Warns if a generic shadows a built-in type.\n+\n+### Why is this bad?\n+This gives surprising type errors.\n+\n+### Example\n+\n+```\n+impl<u32> Foo<u32> {\n+    fn impl_func(&self) -> u32 {\n+        42\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "ca7bf9a38da8e25262eb0b4f761bcb622a3db13d", "filename": "src/docs/bytes_count_to_len.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbytes_count_to_len.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbytes_count_to_len.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbytes_count_to_len.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+It checks for `str::bytes().count()` and suggests replacing it with\n+`str::len()`.\n+\n+### Why is this bad?\n+`str::bytes().count()` is longer and may not be as performant as using\n+`str::len()`.\n+\n+### Example\n+```\n+\"hello\".bytes().count();\n+String::from(\"hello\").bytes().count();\n+```\n+Use instead:\n+```\n+\"hello\".len();\n+String::from(\"hello\").len();\n+```\n\\ No newline at end of file"}, {"sha": "260de343353d8d3c1807cf47e79d5dbfad8640cd", "filename": "src/docs/bytes_nth.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbytes_nth.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fbytes_nth.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbytes_nth.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for the use of `.bytes().nth()`.\n+\n+### Why is this bad?\n+`.as_bytes().get()` is more efficient and more\n+readable.\n+\n+### Example\n+```\n+\"Hello\".bytes().nth(3);\n+```\n+\n+Use instead:\n+```\n+\"Hello\".as_bytes().get(3);\n+```\n\\ No newline at end of file"}, {"sha": "1998647a92740b7ad0f99d6c2d42cc5424c4f9d3", "filename": "src/docs/cargo_common_metadata.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcargo_common_metadata.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcargo_common_metadata.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcargo_common_metadata.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks to see if all common metadata is defined in\n+`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n+\n+### Why is this bad?\n+It will be more difficult for users to discover the\n+purpose of the crate, and key information related to it.\n+\n+### Example\n+```\n+[package]\n+name = \"clippy\"\n+version = \"0.0.212\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+```\n+\n+Should include a description field like:\n+\n+```\n+[package]\n+name = \"clippy\"\n+version = \"0.0.212\"\n+description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+keywords = [\"clippy\", \"lint\", \"plugin\"]\n+categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+```\n\\ No newline at end of file"}, {"sha": "8e6e18ed4e23a94da0e12c6a38c3064871fcc723", "filename": "src/docs/case_sensitive_file_extension_comparisons.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for calls to `ends_with` with possible file extensions\n+and suggests to use a case-insensitive approach instead.\n+\n+### Why is this bad?\n+`ends_with` is case-sensitive and may not detect files with a valid extension.\n+\n+### Example\n+```\n+fn is_rust_file(filename: &str) -> bool {\n+    filename.ends_with(\".rs\")\n+}\n+```\n+Use instead:\n+```\n+fn is_rust_file(filename: &str) -> bool {\n+    let filename = std::path::Path::new(filename);\n+    filename.extension()\n+        .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c5d8ee034ce596d89a8ce62ae83d5962d7f892dc", "filename": "src/docs/cast_abs_to_unsigned.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_abs_to_unsigned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_abs_to_unsigned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_abs_to_unsigned.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for uses of the `abs()` method that cast the result to unsigned.\n+\n+### Why is this bad?\n+The `unsigned_abs()` method avoids panic when called on the MIN value.\n+\n+### Example\n+```\n+let x: i32 = -42;\n+let y: u32 = x.abs() as u32;\n+```\n+Use instead:\n+```\n+let x: i32 = -42;\n+let y: u32 = x.unsigned_abs();\n+```\n\\ No newline at end of file"}, {"sha": "675c03a42bc23679e2132be6d00b43a1735c188a", "filename": "src/docs/cast_enum_constructor.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_enum_constructor.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_enum_constructor.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_enum_constructor.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for casts from an enum tuple constructor to an integer.\n+\n+### Why is this bad?\n+The cast is easily confused with casting a c-like enum value to an integer.\n+\n+### Example\n+```\n+enum E { X(i32) };\n+let _ = E::X as usize;\n+```\n\\ No newline at end of file"}, {"sha": "abe32a8296da228ff5447d8f715aa6425abcfbe9", "filename": "src/docs/cast_enum_truncation.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_enum_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_enum_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_enum_truncation.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for casts from an enum type to an integral type which will definitely truncate the\n+value.\n+\n+### Why is this bad?\n+The resulting integral value will not match the value of the variant it came from.\n+\n+### Example\n+```\n+enum E { X = 256 };\n+let _ = E::X as u8;\n+```\n\\ No newline at end of file"}, {"sha": "c3a61dd470fc9b4feabd4d4db2612e8ca8c71f4f", "filename": "src/docs/cast_lossless.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_lossless.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_lossless.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_lossless.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for casts between numerical types that may\n+be replaced by safe conversion functions.\n+\n+### Why is this bad?\n+Rust's `as` keyword will perform many kinds of\n+conversions, including silently lossy conversions. Conversion functions such\n+as `i32::from` will only perform lossless conversions. Using the conversion\n+functions prevents conversions from turning into silent lossy conversions if\n+the types of the input expressions ever change, and make it easier for\n+people reading the code to know that the conversion is lossless.\n+\n+### Example\n+```\n+fn as_u64(x: u8) -> u64 {\n+    x as u64\n+}\n+```\n+\n+Using `::from` would look like this:\n+\n+```\n+fn as_u64(x: u8) -> u64 {\n+    u64::from(x)\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0b164848cc7c23647a27ac5138e5f82346c876bb", "filename": "src/docs/cast_possible_truncation.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_possible_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_possible_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_possible_truncation.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for casts between numerical types that may\n+truncate large values. This is expected behavior, so the cast is `Allow` by\n+default.\n+\n+### Why is this bad?\n+In some problem domains, it is good practice to avoid\n+truncation. This lint can be activated to help assess where additional\n+checks could be beneficial.\n+\n+### Example\n+```\n+fn as_u8(x: u64) -> u8 {\n+    x as u8\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f883fc9cfb994793e5520453df94f183d2230319", "filename": "src/docs/cast_possible_wrap.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_possible_wrap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_possible_wrap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_possible_wrap.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for casts from an unsigned type to a signed type of\n+the same size. Performing such a cast is a 'no-op' for the compiler,\n+i.e., nothing is changed at the bit level, and the binary representation of\n+the value is reinterpreted. This can cause wrapping if the value is too big\n+for the target signed type. However, the cast works as defined, so this lint\n+is `Allow` by default.\n+\n+### Why is this bad?\n+While such a cast is not bad in itself, the results can\n+be surprising when this is not the intended behavior, as demonstrated by the\n+example below.\n+\n+### Example\n+```\n+u32::MAX as i32; // will yield a value of `-1`\n+```\n\\ No newline at end of file"}, {"sha": "f915d9f8a6d0d2bd191bfd7ea43e3b17fa36c22c", "filename": "src/docs/cast_precision_loss.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_precision_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_precision_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_precision_loss.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for casts from any numerical to a float type where\n+the receiving type cannot store all values from the original type without\n+rounding errors. This possible rounding is to be expected, so this lint is\n+`Allow` by default.\n+\n+Basically, this warns on casting any integer with 32 or more bits to `f32`\n+or any 64-bit integer to `f64`.\n+\n+### Why is this bad?\n+It's not bad at all. But in some applications it can be\n+helpful to know where precision loss can take place. This lint can help find\n+those places in the code.\n+\n+### Example\n+```\n+let x = u64::MAX;\n+x as f64;\n+```\n\\ No newline at end of file"}, {"sha": "6a6d4dcaa2ae5ecdce3d53b2cc2f9f51d59e2281", "filename": "src/docs/cast_ptr_alignment.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_ptr_alignment.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_ptr_alignment.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_ptr_alignment.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for casts, using `as` or `pointer::cast`,\n+from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n+\n+### Why is this bad?\n+Dereferencing the resulting pointer may be undefined\n+behavior.\n+\n+### Known problems\n+Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n+on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n+u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n+\n+### Example\n+```\n+let _ = (&1u8 as *const u8) as *const u16;\n+let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+\n+(&1u8 as *const u8).cast::<u16>();\n+(&mut 1u8 as *mut u8).cast::<u16>();\n+```\n\\ No newline at end of file"}, {"sha": "fb5b4dbb62d82386ab073958a1a97ded27bddeb9", "filename": "src/docs/cast_ref_to_mut.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_ref_to_mut.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_ref_to_mut.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_ref_to_mut.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for casts of `&T` to `&mut T` anywhere in the code.\n+\n+### Why is this bad?\n+It\u2019s basically guaranteed to be undefined behavior.\n+`UnsafeCell` is the only way to obtain aliasable data that is considered\n+mutable.\n+\n+### Example\n+```\n+fn x(r: &i32) {\n+    unsafe {\n+        *(r as *const _ as *mut _) += 1;\n+    }\n+}\n+```\n+\n+Instead consider using interior mutability types.\n+\n+```\n+use std::cell::UnsafeCell;\n+\n+fn x(r: &UnsafeCell<i32>) {\n+    unsafe {\n+        *r.get() += 1;\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d64fe1b07f46932d14dc2569ee8dab845a9b62ab", "filename": "src/docs/cast_sign_loss.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_sign_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_sign_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_sign_loss.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for casts from a signed to an unsigned numerical\n+type. In this case, negative values wrap around to large positive values,\n+which can be quite surprising in practice. However, as the cast works as\n+defined, this lint is `Allow` by default.\n+\n+### Why is this bad?\n+Possibly surprising results. You can activate this lint\n+as a one-time check to see where numerical wrapping can arise.\n+\n+### Example\n+```\n+let y: i8 = -1;\n+y as u128; // will return 18446744073709551615\n+```\n\\ No newline at end of file"}, {"sha": "c01ef0ba92c03d0c66381a52e5506f7b9bfddeec", "filename": "src/docs/cast_slice_different_sizes.txt", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_slice_different_sizes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_slice_different_sizes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_slice_different_sizes.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,38 @@\n+### What it does\n+Checks for `as` casts between raw pointers to slices with differently sized elements.\n+\n+### Why is this bad?\n+The produced raw pointer to a slice does not update its length metadata. The produced\n+pointer will point to a different number of bytes than the original pointer because the\n+length metadata of a raw slice pointer is in elements rather than bytes.\n+Producing a slice reference from the raw pointer will either create a slice with\n+less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.\n+\n+### Example\n+// Missing data\n+```\n+let a = [1_i32, 2, 3, 4];\n+let p = &a as *const [i32] as *const [u8];\n+unsafe {\n+    println!(\"{:?}\", &*p);\n+}\n+```\n+// Undefined Behavior (note: also potential alignment issues)\n+```\n+let a = [1_u8, 2, 3, 4];\n+let p = &a as *const [u8] as *const [u32];\n+unsafe {\n+    println!(\"{:?}\", &*p);\n+}\n+```\n+Instead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n+```\n+let a = [1_i32, 2, 3, 4];\n+let old_ptr = &a as *const [i32];\n+// The data pointer is cast to a pointer to the target `u8` not `[u8]`\n+// The length comes from the known length of 4 i32s times the 4 bytes per i32\n+let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\n+unsafe {\n+    println!(\"{:?}\", &*new_ptr);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "b58c739766aab1d482014b8b69f882151ea5da41", "filename": "src/docs/cast_slice_from_raw_parts.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_slice_from_raw_parts.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcast_slice_from_raw_parts.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_slice_from_raw_parts.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for a raw slice being cast to a slice pointer\n+\n+### Why is this bad?\n+This can result in multiple `&mut` references to the same location when only a pointer is\n+required.\n+`ptr::slice_from_raw_parts` is a safe alternative that doesn't require\n+the same [safety requirements] to be upheld.\n+\n+### Example\n+```\n+let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\n+let _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n+```\n+Use instead:\n+```\n+let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\n+let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n+```\n+[safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\n\\ No newline at end of file"}, {"sha": "00d60b9a451b9f4b82be87cded214d1a7b930b55", "filename": "src/docs/char_lit_as_u8.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchar_lit_as_u8.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchar_lit_as_u8.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchar_lit_as_u8.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for expressions where a character literal is cast\n+to `u8` and suggests using a byte literal instead.\n+\n+### Why is this bad?\n+In general, casting values to smaller types is\n+error-prone and should be avoided where possible. In the particular case of\n+converting a character literal to u8, it is easy to avoid by just using a\n+byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+than `'a' as u8`.\n+\n+### Example\n+```\n+'x' as u8\n+```\n+\n+A better version, using the byte literal:\n+\n+```\n+b'x'\n+```\n\\ No newline at end of file"}, {"sha": "4c1d8838973a73d2c2699b68787cfe55d062901c", "filename": "src/docs/chars_last_cmp.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchars_last_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchars_last_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchars_last_cmp.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for usage of `_.chars().last()` or\n+`_.chars().next_back()` on a `str` to check if it ends with a given char.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.ends_with(_)`.\n+\n+### Example\n+```\n+name.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n+```\n+\n+Use instead:\n+```\n+name.ends_with('_') || name.ends_with('-');\n+```\n\\ No newline at end of file"}, {"sha": "77cbce2de00f91f65298aacf0daddc3d3f6613d8", "filename": "src/docs/chars_next_cmp.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchars_next_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchars_next_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchars_next_cmp.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for usage of `.chars().next()` on a `str` to check\n+if it starts with a given char.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.starts_with(_)`.\n+\n+### Example\n+```\n+let name = \"foo\";\n+if name.chars().next() == Some('_') {};\n+```\n+\n+Use instead:\n+```\n+let name = \"foo\";\n+if name.starts_with('_') {};\n+```\n\\ No newline at end of file"}, {"sha": "536b01294ee170493d4c6f6acee6813dbe79a9a6", "filename": "src/docs/checked_conversions.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchecked_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fchecked_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fchecked_conversions.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for explicit bounds checking when casting.\n+\n+### Why is this bad?\n+Reduces the readability of statements & is error prone.\n+\n+### Example\n+```\n+foo <= i32::MAX as u32;\n+```\n+\n+Use instead:\n+```\n+i32::try_from(foo).is_ok();\n+```\n\\ No newline at end of file"}, {"sha": "2729635bd246f0710c1c2b8cbd9a4f4a35165023", "filename": "src/docs/clone_double_ref.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_double_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_double_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_double_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `.clone()` on an `&&T`.\n+\n+### Why is this bad?\n+Cloning an `&&T` copies the inner `&T`, instead of\n+cloning the underlying `T`.\n+\n+### Example\n+```\n+fn main() {\n+    let x = vec![1];\n+    let y = &&x;\n+    let z = y.clone();\n+    println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n+}\n+```\n\\ No newline at end of file"}, {"sha": "99a0bdb4c4ac0f668c16d2e650b66af7289c4b07", "filename": "src/docs/clone_on_copy.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_on_copy.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for usage of `.clone()` on a `Copy` type.\n+\n+### Why is this bad?\n+The only reason `Copy` types implement `Clone` is for\n+generics, not for using the `clone` method on a concrete type.\n+\n+### Example\n+```\n+42u64.clone();\n+```\n\\ No newline at end of file"}, {"sha": "2d83f8fefc12239c201a135679543a418f9ed02b", "filename": "src/docs/clone_on_ref_ptr.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_on_ref_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fclone_on_ref_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fclone_on_ref_ptr.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usage of `.clone()` on a ref-counted pointer,\n+(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n+function syntax instead (e.g., `Rc::clone(foo)`).\n+\n+### Why is this bad?\n+Calling '.clone()' on an Rc, Arc, or Weak\n+can obscure the fact that only the pointer is being cloned, not the underlying\n+data.\n+\n+### Example\n+```\n+let x = Rc::new(1);\n+\n+x.clone();\n+```\n+\n+Use instead:\n+```\n+Rc::clone(&x);\n+```\n\\ No newline at end of file"}, {"sha": "2f2014d5fd2990e7d559cf95e675d8d4fa1a9a17", "filename": "src/docs/cloned_instead_of_copied.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcloned_instead_of_copied.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcloned_instead_of_copied.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcloned_instead_of_copied.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usages of `cloned()` on an `Iterator` or `Option` where\n+`copied()` could be used instead.\n+\n+### Why is this bad?\n+`copied()` is better because it guarantees that the type being cloned\n+implements `Copy`.\n+\n+### Example\n+```\n+[1, 2, 3].iter().cloned();\n+```\n+Use instead:\n+```\n+[1, 2, 3].iter().copied();\n+```\n\\ No newline at end of file"}, {"sha": "e2ad04d932359aa55e6cf5b1e0fd03e93aeeb8ec", "filename": "src/docs/cmp_nan.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_nan.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_nan.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_nan.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for comparisons to NaN.\n+\n+### Why is this bad?\n+NaN does not compare meaningfully to anything \u2013 not\n+even itself \u2013 so those comparisons are simply wrong.\n+\n+### Example\n+```\n+if x == f32::NAN { }\n+```\n+\n+Use instead:\n+```\n+if x.is_nan() { }\n+```\n\\ No newline at end of file"}, {"sha": "02fd15124f0389b6e7c0ba637fddb737d39f8df2", "filename": "src/docs/cmp_null.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_null.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_null.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_null.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+This lint checks for equality comparisons with `ptr::null`\n+\n+### Why is this bad?\n+It's easier and more readable to use the inherent\n+`.is_null()`\n+method instead\n+\n+### Example\n+```\n+use std::ptr;\n+\n+if x == ptr::null {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+if x.is_null() {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f8d4956ff1d4b7b010df92dffb8ccc7a16dc1684", "filename": "src/docs/cmp_owned.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_owned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcmp_owned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcmp_owned.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for conversions to owned values just for the sake\n+of a comparison.\n+\n+### Why is this bad?\n+The comparison can operate on a reference, so creating\n+an owned value effectively throws it away directly afterwards, which is\n+needlessly consuming code and heap space.\n+\n+### Example\n+```\n+if x.to_owned() == y {}\n+```\n+\n+Use instead:\n+```\n+if x == y {}\n+```\n\\ No newline at end of file"}, {"sha": "fdd75f6479cd00cf24d503b37b9f3d48c38249da", "filename": "src/docs/cognitive_complexity.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcognitive_complexity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcognitive_complexity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcognitive_complexity.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for methods with high cognitive complexity.\n+\n+### Why is this bad?\n+Methods of high cognitive complexity tend to be hard to\n+both read and maintain. Also LLVM will tend to optimize small methods better.\n+\n+### Known problems\n+Sometimes it's hard to find a way to reduce the\n+complexity.\n+\n+### Example\n+You'll see it when you get the warning.\n\\ No newline at end of file"}, {"sha": "4ddfca17731f7b95a2622c2255e8c75ff16ea89e", "filename": "src/docs/collapsible_else_if.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_else_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_else_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_else_if.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for collapsible `else { if ... }` expressions\n+that can be collapsed to `else if ...`.\n+\n+### Why is this bad?\n+Each `if`-statement adds one level of nesting, which\n+makes code look more complex than it really is.\n+\n+### Example\n+```\n+\n+if x {\n+    \u2026\n+} else {\n+    if y {\n+        \u2026\n+    }\n+}\n+```\n+\n+Should be written:\n+\n+```\n+if x {\n+    \u2026\n+} else if y {\n+    \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e1264ee062e955437c7199981de2dd21a2eaa135", "filename": "src/docs/collapsible_if.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_if.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for nested `if` statements which can be collapsed\n+by `&&`-combining their conditions.\n+\n+### Why is this bad?\n+Each `if`-statement adds one level of nesting, which\n+makes code look more complex than it really is.\n+\n+### Example\n+```\n+if x {\n+    if y {\n+        // \u2026\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+if x && y {\n+    // \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0d59594a03a27c2f1957912613c548ec7cde34dd", "filename": "src/docs/collapsible_match.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_match.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+without adding any branches.\n+\n+Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+cases where merging would most likely make the code more readable.\n+\n+### Why is this bad?\n+It is unnecessarily verbose and complex.\n+\n+### Example\n+```\n+fn func(opt: Option<Result<u64, String>>) {\n+    let n = match opt {\n+        Some(n) => match n {\n+            Ok(n) => n,\n+            _ => return,\n+        }\n+        None => return,\n+    };\n+}\n+```\n+Use instead:\n+```\n+fn func(opt: Option<Result<u64, String>>) {\n+    let n = match opt {\n+        Some(Ok(n)) => n,\n+        _ => return,\n+    };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c24c25a3028a5d5dce4806d16b028aa46125c7e2", "filename": "src/docs/collapsible_str_replace.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_str_replace.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcollapsible_str_replace.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcollapsible_str_replace.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for consecutive calls to `str::replace` (2 or more)\n+that can be collapsed into a single call.\n+\n+### Why is this bad?\n+Consecutive `str::replace` calls scan the string multiple times\n+with repetitive code.\n+\n+### Example\n+```\n+let hello = \"hesuo worpd\"\n+    .replace('s', \"l\")\n+    .replace(\"u\", \"l\")\n+    .replace('p', \"l\");\n+```\n+Use instead:\n+```\n+let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n+```\n\\ No newline at end of file"}, {"sha": "43b09f31ff4aa7a6596db9d2456d6c19f63185fa", "filename": "src/docs/comparison_chain.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcomparison_chain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcomparison_chain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcomparison_chain.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,36 @@\n+### What it does\n+Checks comparison chains written with `if` that can be\n+rewritten with `match` and `cmp`.\n+\n+### Why is this bad?\n+`if` is not guaranteed to be exhaustive and conditionals can get\n+repetitive\n+\n+### Known problems\n+The match statement may be slower due to the compiler\n+not inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n+\n+### Example\n+```\n+fn f(x: u8, y: u8) {\n+    if x > y {\n+        a()\n+    } else if x < y {\n+        b()\n+    } else {\n+        c()\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::cmp::Ordering;\n+fn f(x: u8, y: u8) {\n+     match x.cmp(&y) {\n+         Ordering::Greater => a(),\n+         Ordering::Less => b(),\n+         Ordering::Equal => c()\n+     }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "db6f74fe2706b5bbca627b24980f86865d219bc7", "filename": "src/docs/comparison_to_empty.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcomparison_to_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcomparison_to_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcomparison_to_empty.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for comparing to an empty slice such as `\"\"` or `[]`,\n+and suggests using `.is_empty()` where applicable.\n+\n+### Why is this bad?\n+Some structures can answer `.is_empty()` much faster\n+than checking for equality. So it is good to get into the habit of using\n+`.is_empty()`, and having it is cheap.\n+Besides, it makes the intent clearer than a manual comparison in some contexts.\n+\n+### Example\n+\n+```\n+if s == \"\" {\n+    ..\n+}\n+\n+if arr == [] {\n+    ..\n+}\n+```\n+Use instead:\n+```\n+if s.is_empty() {\n+    ..\n+}\n+\n+if arr.is_empty() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "5f9a2a015b86c7bd9bd2c3956bfeff4fe6702e31", "filename": "src/docs/copy_iterator.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcopy_iterator.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcopy_iterator.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcopy_iterator.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for types that implement `Copy` as well as\n+`Iterator`.\n+\n+### Why is this bad?\n+Implicit copies can be confusing when working with\n+iterator combinators.\n+\n+### Example\n+```\n+#[derive(Copy, Clone)]\n+struct Countdown(u8);\n+\n+impl Iterator for Countdown {\n+    // ...\n+}\n+\n+let a: Vec<_> = my_iterator.take(1).collect();\n+let b: Vec<_> = my_iterator.collect();\n+```\n\\ No newline at end of file"}, {"sha": "047e986dee71fae10dd59b6faf35eabbbff50db7", "filename": "src/docs/crate_in_macro_def.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcrate_in_macro_def.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcrate_in_macro_def.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcrate_in_macro_def.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for use of `crate` as opposed to `$crate` in a macro definition.\n+\n+### Why is this bad?\n+`crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\n+crate. Rarely is the former intended. See:\n+https://doc.rust-lang.org/reference/macros-by-example.html#hygiene\n+\n+### Example\n+```\n+#[macro_export]\n+macro_rules! print_message {\n+    () => {\n+        println!(\"{}\", crate::MESSAGE);\n+    };\n+}\n+pub const MESSAGE: &str = \"Hello!\";\n+```\n+Use instead:\n+```\n+#[macro_export]\n+macro_rules! print_message {\n+    () => {\n+        println!(\"{}\", $crate::MESSAGE);\n+    };\n+}\n+pub const MESSAGE: &str = \"Hello!\";\n+```\n+\n+Note that if the use of `crate` is intentional, an `allow` attribute can be applied to the\n+macro definition, e.g.:\n+```\n+#[allow(clippy::crate_in_macro_def)]\n+macro_rules! ok { ... crate::foo ... }\n+```\n\\ No newline at end of file"}, {"sha": "e4e7937684e6efebae130aed520866705fda8e77", "filename": "src/docs/create_dir.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcreate_dir.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcreate_dir.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcreate_dir.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n+\n+### Why is this bad?\n+Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n+\n+### Example\n+```\n+std::fs::create_dir(\"foo\");\n+```\n+\n+Use instead:\n+```\n+std::fs::create_dir_all(\"foo\");\n+```\n\\ No newline at end of file"}, {"sha": "49dea154970e50ab216792d52a157dfd24e2f960", "filename": "src/docs/crosspointer_transmute.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcrosspointer_transmute.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fcrosspointer_transmute.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcrosspointer_transmute.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for transmutes between a type `T` and `*T`.\n+\n+### Why is this bad?\n+It's easy to mistakenly transmute between a type and a\n+pointer to that type.\n+\n+### Example\n+```\n+core::intrinsics::transmute(t) // where the result type is the same as\n+                               // `*t` or `&t`'s\n+```\n\\ No newline at end of file"}, {"sha": "3e1a9a043f9f41617cefd86d3b2c044620856525", "filename": "src/docs/dbg_macro.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdbg_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdbg_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdbg_macro.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of dbg!() macro.\n+\n+### Why is this bad?\n+`dbg!` macro is intended as a debugging tool. It\n+should not be in version control.\n+\n+### Example\n+```\n+dbg!(true)\n+```\n+\n+Use instead:\n+```\n+true\n+```\n\\ No newline at end of file"}, {"sha": "2c44abe1f05c806108d329d07ccb021a0011a20b", "filename": "src/docs/debug_assert_with_mut_call.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdebug_assert_with_mut_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdebug_assert_with_mut_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdebug_assert_with_mut_call.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for function/method calls with a mutable\n+parameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.\n+\n+### Why is this bad?\n+In release builds `debug_assert!` macros are optimized out by the\n+compiler.\n+Therefore mutating something in a `debug_assert!` macro results in different behavior\n+between a release and debug build.\n+\n+### Example\n+```\n+debug_assert_eq!(vec![3].pop(), Some(3));\n+\n+// or\n+\n+debug_assert!(takes_a_mut_parameter(&mut x));\n+```\n\\ No newline at end of file"}, {"sha": "daca9bbb3a848c7dd2b9314b952ee68760230ae5", "filename": "src/docs/decimal_literal_representation.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdecimal_literal_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdecimal_literal_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdecimal_literal_representation.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Warns if there is a better representation for a numeric literal.\n+\n+### Why is this bad?\n+Especially for big powers of 2 a hexadecimal representation is more\n+readable than a decimal representation.\n+\n+### Example\n+```\n+`255` => `0xFF`\n+`65_535` => `0xFFFF`\n+`4_042_322_160` => `0xF0F0_F0F0`\n+```\n\\ No newline at end of file"}, {"sha": "2801b5ccff8028aaa4dc0c8899e28bf01915d3ca", "filename": "src/docs/declare_interior_mutable_const.txt", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeclare_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeclare_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeclare_interior_mutable_const.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,46 @@\n+### What it does\n+Checks for declaration of `const` items which is interior\n+mutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n+\n+### Why is this bad?\n+Consts are copied everywhere they are referenced, i.e.,\n+every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n+or `AtomicXxxx` will be created, which defeats the whole purpose of using\n+these types in the first place.\n+\n+The `const` should better be replaced by a `static` item if a global\n+variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n+\n+### Known problems\n+A \"non-constant\" const item is a legacy way to supply an\n+initialized value to downstream `static` items (e.g., the\n+`std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n+and this lint should be suppressed.\n+\n+Even though the lint avoids triggering on a constant whose type has enums that have variants\n+with interior mutability, and its value uses non interior mutable variants (see\n+[#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n+[#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\n+it complains about associated constants without default values only based on its types;\n+which might not be preferable.\n+There're other enums plus associated constants cases that the lint cannot handle.\n+\n+Types that have underlying or potential interior mutability trigger the lint whether\n+the interior mutable field is used or not. See issues\n+[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n+\n+### Example\n+```\n+use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n+CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n+assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n+```\n+\n+Use instead:\n+```\n+static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n+STATIC_ATOM.store(9, SeqCst);\n+assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n+```\n\\ No newline at end of file"}, {"sha": "b63ef3d18fc411d16f22e1f70f801b50d87a443f", "filename": "src/docs/default_instead_of_iter_empty.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_instead_of_iter_empty.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+It checks for `std::iter::Empty::default()` and suggests replacing it with\n+`std::iter::empty()`.\n+### Why is this bad?\n+`std::iter::empty()` is the more idiomatic way.\n+### Example\n+```\n+let _ = std::iter::Empty::<usize>::default();\n+let iter: std::iter::Empty<usize> = std::iter::Empty::default();\n+```\n+Use instead:\n+```\n+let _ = std::iter::empty::<usize>();\n+let iter: std::iter::Empty<usize> = std::iter::empty();\n+```\n\\ No newline at end of file"}, {"sha": "15076a0a68bf6717c884c45cd79bb90f076b1700", "filename": "src/docs/default_numeric_fallback.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_numeric_fallback.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_numeric_fallback.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_numeric_fallback.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n+inference.\n+\n+Default numeric fallback means that if numeric types have not yet been bound to concrete\n+types at the end of type inference, then integer type is bound to `i32`, and similarly\n+floating type is bound to `f64`.\n+\n+See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n+\n+### Why is this bad?\n+For those who are very careful about types, default numeric fallback\n+can be a pitfall that cause unexpected runtime behavior.\n+\n+### Known problems\n+This lint can only be allowed at the function level or above.\n+\n+### Example\n+```\n+let i = 10;\n+let f = 1.23;\n+```\n+\n+Use instead:\n+```\n+let i = 10i32;\n+let f = 1.23f64;\n+```\n\\ No newline at end of file"}, {"sha": "e69298969c8ed807f08c6023713ede2b5d5c4af2", "filename": "src/docs/default_trait_access.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_trait_access.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_trait_access.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_trait_access.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for literal calls to `Default::default()`.\n+\n+### Why is this bad?\n+It's easier for the reader if the name of the type is used, rather than the\n+generic `Default`.\n+\n+### Example\n+```\n+let s: String = Default::default();\n+```\n+\n+Use instead:\n+```\n+let s = String::default();\n+```\n\\ No newline at end of file"}, {"sha": "f79ff9760e57ebaf1dfea011d14fb91cdf3d837c", "filename": "src/docs/default_union_representation.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_union_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdefault_union_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdefault_union_representation.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,36 @@\n+### What it does\n+Displays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).\n+\n+### Why is this bad?\n+Unions in Rust have unspecified layout by default, despite many people thinking that they\n+lay out each field at the start of the union (like C does). That is, there are no guarantees\n+about the offset of the fields for unions with multiple non-ZST fields without an explicitly\n+specified layout. These cases may lead to undefined behavior in unsafe blocks.\n+\n+### Example\n+```\n+union Foo {\n+    a: i32,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let _x: u32 = unsafe {\n+        Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n+    };\n+}\n+```\n+Use instead:\n+```\n+#[repr(C)]\n+union Foo {\n+    a: i32,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let _x: u32 = unsafe {\n+        Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n+    };\n+}\n+```\n\\ No newline at end of file"}, {"sha": "9f264887a057e3c4eb347abef608a7ab7dcc8c73", "filename": "src/docs/deprecated_cfg_attr.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeprecated_cfg_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeprecated_cfg_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeprecated_cfg_attr.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n+with `#[rustfmt::skip]`.\n+\n+### Why is this bad?\n+Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n+are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n+\n+### Known problems\n+This lint doesn't detect crate level inner attributes, because they get\n+processed before the PreExpansionPass lints get executed. See\n+[#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n+\n+### Example\n+```\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn main() { }\n+```\n+\n+Use instead:\n+```\n+#[rustfmt::skip]\n+fn main() { }\n+```\n\\ No newline at end of file"}, {"sha": "c9574a99b2bec22abdd5b766a55f04b1dd41b494", "filename": "src/docs/deprecated_semver.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeprecated_semver.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdeprecated_semver.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdeprecated_semver.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for `#[deprecated]` annotations with a `since`\n+field that is not a valid semantic version.\n+\n+### Why is this bad?\n+For checking the version of the deprecation, it must be\n+a valid semver. Failing that, the contained information is useless.\n+\n+### Example\n+```\n+#[deprecated(since = \"forever\")]\n+fn something_else() { /* ... */ }\n+```\n\\ No newline at end of file"}, {"sha": "fa711b924d48015fd81c79f45f0a4303f9ffb2fb", "filename": "src/docs/deref_addrof.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderef_addrof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderef_addrof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderef_addrof.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `*&` and `*&mut` in expressions.\n+\n+### Why is this bad?\n+Immediately dereferencing a reference is no-op and\n+makes the code less clear.\n+\n+### Known problems\n+Multiple dereference/addrof pairs are not handled so\n+the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n+\n+### Example\n+```\n+let a = f(*&mut b);\n+let c = *&d;\n+```\n+\n+Use instead:\n+```\n+let a = f(b);\n+let c = d;\n+```\n\\ No newline at end of file"}, {"sha": "4dad24ac00cad9ae2532af665ccb2516d939c1bb", "filename": "src/docs/deref_by_slicing.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderef_by_slicing.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderef_by_slicing.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderef_by_slicing.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for slicing expressions which are equivalent to dereferencing the\n+value.\n+\n+### Why is this bad?\n+Some people may prefer to dereference rather than slice.\n+\n+### Example\n+```\n+let vec = vec![1, 2, 3];\n+let slice = &vec[..];\n+```\n+Use instead:\n+```\n+let vec = vec![1, 2, 3];\n+let slice = &*vec;\n+```\n\\ No newline at end of file"}, {"sha": "5cee43956cc360eb5ca0af1d7767fc390d24625c", "filename": "src/docs/derivable_impls.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderivable_impls.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderivable_impls.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderivable_impls.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Detects manual `std::default::Default` implementations that are identical to a derived implementation.\n+\n+### Why is this bad?\n+It is less concise.\n+\n+### Example\n+```\n+struct Foo {\n+    bar: bool\n+}\n+\n+impl Default for Foo {\n+    fn default() -> Self {\n+        Self {\n+            bar: false\n+        }\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+#[derive(Default)]\n+struct Foo {\n+    bar: bool\n+}\n+```\n+\n+### Known problems\n+Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n+in generic types and the user defined `impl` may be more generalized or\n+specialized than what derive will produce. This lint can't detect the manual `impl`\n+has exactly equal bounds, and therefore this lint is disabled for types with\n+generic parameters.\n\\ No newline at end of file"}, {"sha": "fbf623d5adbc10a0fa3890059c1522cca9f51940", "filename": "src/docs/derive_hash_xor_eq.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_hash_xor_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_hash_xor_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_hash_xor_eq.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for deriving `Hash` but implementing `PartialEq`\n+explicitly or vice versa.\n+\n+### Why is this bad?\n+The implementation of these traits must agree (for\n+example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n+default-generated `Hash` implementation with an explicitly defined\n+`PartialEq`. In particular, the following must hold for any type:\n+\n+```\n+k1 == k2 \u21d2 hash(k1) == hash(k2)\n+```\n+\n+### Example\n+```\n+#[derive(Hash)]\n+struct Foo;\n+\n+impl PartialEq for Foo {\n+    ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f2107a5f69eea93e87e2c7544940bf5020407629", "filename": "src/docs/derive_ord_xor_partial_ord.txt", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_ord_xor_partial_ord.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,44 @@\n+### What it does\n+Checks for deriving `Ord` but implementing `PartialOrd`\n+explicitly or vice versa.\n+\n+### Why is this bad?\n+The implementation of these traits must agree (for\n+example for use with `sort`) so it\u2019s probably a bad idea to use a\n+default-generated `Ord` implementation with an explicitly defined\n+`PartialOrd`. In particular, the following must hold for any type\n+implementing `Ord`:\n+\n+```\n+k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n+```\n+\n+### Example\n+```\n+#[derive(Ord, PartialEq, Eq)]\n+struct Foo;\n+\n+impl PartialOrd for Foo {\n+    ...\n+}\n+```\n+Use instead:\n+```\n+#[derive(PartialEq, Eq)]\n+struct Foo;\n+\n+impl PartialOrd for Foo {\n+    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+       Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Foo {\n+    ...\n+}\n+```\n+or, if you don't need a custom ordering:\n+```\n+#[derive(Ord, PartialOrd, PartialEq, Eq)]\n+struct Foo;\n+```\n\\ No newline at end of file"}, {"sha": "932fabad666c3431d3fdd39c3168cda2d418b900", "filename": "src/docs/derive_partial_eq_without_eq.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_partial_eq_without_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fderive_partial_eq_without_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fderive_partial_eq_without_eq.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for types that derive `PartialEq` and could implement `Eq`.\n+\n+### Why is this bad?\n+If a type `T` derives `PartialEq` and all of its members implement `Eq`,\n+then `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\n+in APIs that require `Eq` types. It also allows structs containing `T` to derive\n+`Eq` themselves.\n+\n+### Example\n+```\n+#[derive(PartialEq)]\n+struct Foo {\n+    i_am_eq: i32,\n+    i_am_eq_too: Vec<String>,\n+}\n+```\n+Use instead:\n+```\n+#[derive(PartialEq, Eq)]\n+struct Foo {\n+    i_am_eq: i32,\n+    i_am_eq_too: Vec<String>,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d8ad5b6a6674cd2c4bb0a79f3b13ca391b1e06ce", "filename": "src/docs/disallowed_methods.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_methods.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,41 @@\n+### What it does\n+Denies the configured methods and functions in clippy.toml\n+\n+Note: Even though this lint is warn-by-default, it will only trigger if\n+methods are defined in the clippy.toml file.\n+\n+### Why is this bad?\n+Some methods are undesirable in certain contexts, and it's beneficial to\n+lint for them as needed.\n+\n+### Example\n+An example clippy.toml configuration:\n+```\n+disallowed-methods = [\n+    # Can use a string as the path of the disallowed method.\n+    \"std::boxed::Box::new\",\n+    # Can also use an inline table with a `path` key.\n+    { path = \"std::time::Instant::now\" },\n+    # When using an inline table, can add a `reason` for why the method\n+    # is disallowed.\n+    { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n+]\n+```\n+\n+```\n+// Example code where clippy issues a warning\n+let xs = vec![1, 2, 3, 4];\n+xs.leak(); // Vec::leak is disallowed in the config.\n+// The diagnostic contains the message \"no leaking memory\".\n+\n+let _now = Instant::now(); // Instant::now is disallowed in the config.\n+\n+let _box = Box::new(3); // Box::new is disallowed in the config.\n+```\n+\n+Use instead:\n+```\n+// Example code which does not raise clippy warning\n+let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\n+xs.push(123); // Vec::push is _not_ disallowed in the config.\n+```\n\\ No newline at end of file"}, {"sha": "f4aaee9c77b7baed6014435108a093d22b4cb55f", "filename": "src/docs/disallowed_names.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_names.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for usage of disallowed names for variables, such\n+as `foo`.\n+\n+### Why is this bad?\n+These names are usually placeholder names and should be\n+avoided.\n+\n+### Example\n+```\n+let foo = 3.14;\n+```\n\\ No newline at end of file"}, {"sha": "2151b7a20dedc0bd92841cdc550c96f1c05b45ba", "filename": "src/docs/disallowed_script_idents.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_script_idents.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_script_idents.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_script_idents.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for usage of unicode scripts other than those explicitly allowed\n+by the lint config.\n+\n+This lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\n+It also ignores the `Common` script type.\n+While configuring, be sure to use official script name [aliases] from\n+[the list of supported scripts][supported_scripts].\n+\n+See also: [`non_ascii_idents`].\n+\n+[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n+[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n+\n+### Why is this bad?\n+It may be not desired to have many different scripts for\n+identifiers in the codebase.\n+\n+Note that if you only want to allow plain English, you might want to use\n+built-in [`non_ascii_idents`] lint instead.\n+\n+[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents\n+\n+### Example\n+```\n+// Assuming that `clippy.toml` contains the following line:\n+// allowed-locales = [\"Latin\", \"Cyrillic\"]\n+let counter = 10; // OK, latin is allowed.\n+let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n+let z\u00e4hler = 10; // OK, it's still latin.\n+let \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n+```\n\\ No newline at end of file"}, {"sha": "2bcbcddee5666d10d749568713f34c185e057afb", "filename": "src/docs/disallowed_types.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_types.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdisallowed_types.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdisallowed_types.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Denies the configured types in clippy.toml.\n+\n+Note: Even though this lint is warn-by-default, it will only trigger if\n+types are defined in the clippy.toml file.\n+\n+### Why is this bad?\n+Some types are undesirable in certain contexts.\n+\n+### Example:\n+An example clippy.toml configuration:\n+```\n+disallowed-types = [\n+    # Can use a string as the path of the disallowed type.\n+    \"std::collections::BTreeMap\",\n+    # Can also use an inline table with a `path` key.\n+    { path = \"std::net::TcpListener\" },\n+    # When using an inline table, can add a `reason` for why the type\n+    # is disallowed.\n+    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n+]\n+```\n+\n+```\n+use std::collections::BTreeMap;\n+// or its use\n+let x = std::collections::BTreeMap::new();\n+```\n+Use instead:\n+```\n+// A similar type that is allowed by the config\n+use std::collections::HashMap;\n+```\n\\ No newline at end of file"}, {"sha": "19436221802512d51c30904ba06904eada8a8de0", "filename": "src/docs/diverging_sub_expression.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdiverging_sub_expression.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdiverging_sub_expression.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdiverging_sub_expression.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for diverging calls that are not match arms or\n+statements.\n+\n+### Why is this bad?\n+It is often confusing to read. In addition, the\n+sub-expression evaluation order for Rust is not well documented.\n+\n+### Known problems\n+Someone might want to use `some_bool || panic!()` as a\n+shorthand.\n+\n+### Example\n+```\n+let a = b() || panic!() || c();\n+// `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+let x = (a, b, c, panic!());\n+// can simply be replaced by `panic!()`\n+```\n\\ No newline at end of file"}, {"sha": "107c8ac116d93bb836d29cacbff9d86f46b2fb96", "filename": "src/docs/doc_link_with_quotes.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdoc_link_with_quotes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdoc_link_with_quotes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdoc_link_with_quotes.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\n+outside of code blocks\n+### Why is this bad?\n+It is likely a typo when defining an intra-doc link\n+\n+### Example\n+```\n+/// See also: ['foo']\n+fn bar() {}\n+```\n+Use instead:\n+```\n+/// See also: [`foo`]\n+fn bar() {}\n+```\n\\ No newline at end of file"}, {"sha": "94f54c587e3021ab81cfe05aa1b5834cc3e2ad97", "filename": "src/docs/doc_markdown.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdoc_markdown.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdoc_markdown.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdoc_markdown.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for the presence of `_`, `::` or camel-case words\n+outside ticks in documentation.\n+\n+### Why is this bad?\n+*Rustdoc* supports markdown formatting, `_`, `::` and\n+camel-case probably indicates some code which should be included between\n+ticks. `_` can also be used for emphasis in markdown, this lint tries to\n+consider that.\n+\n+### Known problems\n+Lots of bad docs won\u2019t be fixed, what the lint checks\n+for is limited, and there are still false positives. HTML elements and their\n+content are not linted.\n+\n+In addition, when writing documentation comments, including `[]` brackets\n+inside a link text would trip the parser. Therefore, documenting link with\n+`[`SmallVec<[T; INLINE_CAPACITY]>`]` and then [`SmallVec<[T; INLINE_CAPACITY]>`]: SmallVec\n+would fail.\n+\n+### Examples\n+```\n+/// Do something with the foo_bar parameter. See also\n+/// that::other::module::foo.\n+// ^ `foo_bar` and `that::other::module::foo` should be ticked.\n+fn doit(foo_bar: usize) {}\n+```\n+\n+```\n+// Link text with `[]` brackets should be written as following:\n+/// Consume the array and return the inner\n+/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n+/// [SmallVec]: SmallVec\n+fn main() {}\n+```\n\\ No newline at end of file"}, {"sha": "7dc6818779f4b168e9e6d38e7b58fc75d074c53a", "filename": "src/docs/double_comparisons.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_comparisons.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for double comparisons that could be simplified to a single expression.\n+\n+\n+### Why is this bad?\n+Readability.\n+\n+### Example\n+```\n+if x == y || x < y {}\n+```\n+\n+Use instead:\n+\n+```\n+if x <= y {}\n+```\n\\ No newline at end of file"}, {"sha": "0017d10d40d339344e8c1f4a7aec32fa2227a818", "filename": "src/docs/double_must_use.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_must_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_must_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_must_use.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for a `#[must_use]` attribute without\n+further information on functions and methods that return a type already\n+marked as `#[must_use]`.\n+\n+### Why is this bad?\n+The attribute isn't needed. Not using the result\n+will already be reported. Alternatively, one can add some text to the\n+attribute to improve the lint message.\n+\n+### Examples\n+```\n+#[must_use]\n+fn double_must_use() -> Result<(), ()> {\n+    unimplemented!();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a07f67496d7ccec92f2b90254a8bb68bd0632a1c", "filename": "src/docs/double_neg.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_neg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_neg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_neg.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Detects expressions of the form `--x`.\n+\n+### Why is this bad?\n+It can mislead C/C++ programmers to think `x` was\n+decremented.\n+\n+### Example\n+```\n+let mut x = 3;\n+--x;\n+```\n\\ No newline at end of file"}, {"sha": "260d7dd575e55049891e8cdd4aae82da7675e507", "filename": "src/docs/double_parens.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_parens.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdouble_parens.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdouble_parens.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for unnecessary double parentheses.\n+\n+### Why is this bad?\n+This makes code harder to read and might indicate a\n+mistake.\n+\n+### Example\n+```\n+fn simple_double_parens() -> i32 {\n+    ((0))\n+}\n+\n+foo((0));\n+```\n+\n+Use instead:\n+```\n+fn simple_no_parens() -> i32 {\n+    0\n+}\n+\n+foo(0);\n+```\n\\ No newline at end of file"}, {"sha": "f917ca8ed21a69592c822db3bb9ca07dc863a006", "filename": "src/docs/drop_copy.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_copy.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a value\n+that derives the Copy trait\n+\n+### Why is this bad?\n+Calling `std::mem::drop` [does nothing for types that\n+implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n+value will be copied and moved into the function on invocation.\n+\n+### Example\n+```\n+let x: i32 = 42; // i32 implements Copy\n+std::mem::drop(x) // A copy of x is passed to the function, leaving the\n+                  // original unaffected\n+```\n\\ No newline at end of file"}, {"sha": "ee1e3a6c216efc33146496d279267cddb3f1e148", "filename": "src/docs/drop_non_drop.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_non_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_non_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_non_drop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a value that does not implement `Drop`.\n+\n+### Why is this bad?\n+Calling `std::mem::drop` is no different than dropping such a type. A different value may\n+have been intended.\n+\n+### Example\n+```\n+struct Foo;\n+let x = Foo;\n+std::mem::drop(x);\n+```\n\\ No newline at end of file"}, {"sha": "c4f7adf0cfa33d9359bfa54fa878950b62da84da", "filename": "src/docs/drop_ref.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fdrop_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fdrop_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for calls to `std::mem::drop` with a reference\n+instead of an owned value.\n+\n+### Why is this bad?\n+Calling `drop` on a reference will only drop the\n+reference itself, which is a no-op. It will not call the `drop` method (from\n+the `Drop` trait implementation) on the underlying referenced value, which\n+is likely what was intended.\n+\n+### Example\n+```\n+let mut lock_guard = mutex.lock();\n+std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n+// still locked\n+operation_that_requires_mutex_to_be_unlocked();\n+```\n\\ No newline at end of file"}, {"sha": "709a9aba03ad29d1519993a1fd689e6c9855da9c", "filename": "src/docs/duplicate_mod.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduplicate_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduplicate_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduplicate_mod.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for files that are included as modules multiple times.\n+\n+### Why is this bad?\n+Loading a file as a module more than once causes it to be compiled\n+multiple times, taking longer and putting duplicate content into the\n+module tree.\n+\n+### Example\n+```\n+// lib.rs\n+mod a;\n+mod b;\n+```\n+```\n+// a.rs\n+#[path = \"./b.rs\"]\n+mod b;\n+```\n+\n+Use instead:\n+\n+```\n+// lib.rs\n+mod a;\n+mod b;\n+```\n+```\n+// a.rs\n+use crate::b;\n+```\n\\ No newline at end of file"}, {"sha": "a8fcd6a9fbe680cc7cd987ac16ff2d733879a15f", "filename": "src/docs/duplicate_underscore_argument.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduplicate_underscore_argument.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduplicate_underscore_argument.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduplicate_underscore_argument.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for function arguments having the similar names\n+differing by an underscore.\n+\n+### Why is this bad?\n+It affects code readability.\n+\n+### Example\n+```\n+fn foo(a: i32, _a: i32) {}\n+```\n+\n+Use instead:\n+```\n+fn bar(a: i32, _b: i32) {}\n+```\n\\ No newline at end of file"}, {"sha": "e7e0ca88745ee1e616baf3b40734906fd72f05cb", "filename": "src/docs/duration_subsec.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduration_subsec.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fduration_subsec.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fduration_subsec.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for calculation of subsecond microseconds or milliseconds\n+from other `Duration` methods.\n+\n+### Why is this bad?\n+It's more concise to call `Duration::subsec_micros()` or\n+`Duration::subsec_millis()` than to calculate them.\n+\n+### Example\n+```\n+let micros = duration.subsec_nanos() / 1_000;\n+let millis = duration.subsec_nanos() / 1_000_000;\n+```\n+\n+Use instead:\n+```\n+let micros = duration.subsec_micros();\n+let millis = duration.subsec_millis();\n+```\n\\ No newline at end of file"}, {"sha": "33f5d0f9185920519b53728ed28ad90ee8dff1d0", "filename": "src/docs/else_if_without_else.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Felse_if_without_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Felse_if_without_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Felse_if_without_else.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for usage of if expressions with an `else if` branch,\n+but without a final `else` branch.\n+\n+### Why is this bad?\n+Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n+\n+### Example\n+```\n+if x.is_positive() {\n+    a();\n+} else if x.is_negative() {\n+    b();\n+}\n+```\n+\n+Use instead:\n+\n+```\n+if x.is_positive() {\n+    a();\n+} else if x.is_negative() {\n+    b();\n+} else {\n+    // We don't care about zero.\n+}\n+```\n\\ No newline at end of file"}, {"sha": "d0c0c24a9c8802460603c23d738cf4dfda2be435", "filename": "src/docs/empty_drop.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_drop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for empty `Drop` implementations.\n+\n+### Why is this bad?\n+Empty `Drop` implementations have no effect when dropping an instance of the type. They are\n+most likely useless. However, an empty `Drop` implementation prevents a type from being\n+destructured, which might be the intention behind adding the implementation as a marker.\n+\n+### Example\n+```\n+struct S;\n+\n+impl Drop for S {\n+    fn drop(&mut self) {}\n+}\n+```\n+Use instead:\n+```\n+struct S;\n+```\n\\ No newline at end of file"}, {"sha": "f7b41c41ee5a1c146475336cd786ef70038120ae", "filename": "src/docs/empty_enum.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_enum.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_enum.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_enum.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for `enum`s with no variants.\n+\n+As of this writing, the `never_type` is still a\n+nightly-only experimental API. Therefore, this lint is only triggered\n+if the `never_type` is enabled.\n+\n+### Why is this bad?\n+If you want to introduce a type which\n+can't be instantiated, you should use `!` (the primitive type \"never\"),\n+or a wrapper around it, because `!` has more extensive\n+compiler support (type inference, etc...) and wrappers\n+around it are the conventional way to define an uninhabited type.\n+For further information visit [never type documentation](https://doc.rust-lang.org/std/primitive.never.html)\n+\n+\n+### Example\n+```\n+enum Test {}\n+```\n+\n+Use instead:\n+```\n+#![feature(never_type)]\n+\n+struct Test(!);\n+```\n\\ No newline at end of file"}, {"sha": "c85242bbee0ec503c806db781256ea270c6a166a", "filename": "src/docs/empty_line_after_outer_attr.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_line_after_outer_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_line_after_outer_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_line_after_outer_attr.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for empty lines after outer attributes\n+\n+### Why is this bad?\n+Most likely the attribute was meant to be an inner attribute using a '!'.\n+If it was meant to be an outer attribute, then the following item\n+should not be separated by empty lines.\n+\n+### Known problems\n+Can cause false positives.\n+\n+From the clippy side it's difficult to detect empty lines between an attributes and the\n+following item because empty lines and comments are not part of the AST. The parsing\n+currently works for basic cases but is not perfect.\n+\n+### Example\n+```\n+#[allow(dead_code)]\n+\n+fn not_quite_good_code() { }\n+```\n+\n+Use instead:\n+```\n+// Good (as inner attribute)\n+#![allow(dead_code)]\n+\n+fn this_is_fine() { }\n+\n+// or\n+\n+// Good (as outer attribute)\n+#[allow(dead_code)]\n+fn this_is_fine_too() { }\n+```\n\\ No newline at end of file"}, {"sha": "fea49a74d04e0cfebe15598e7848293327f02527", "filename": "src/docs/empty_loop.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_loop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks for empty `loop` expressions.\n+\n+### Why is this bad?\n+These busy loops burn CPU cycles without doing\n+anything. It is _almost always_ a better idea to `panic!` than to have\n+a busy loop.\n+\n+If panicking isn't possible, think of the environment and either:\n+  - block on something\n+  - sleep the thread for some microseconds\n+  - yield or pause the thread\n+\n+For `std` targets, this can be done with\n+[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+\n+For `no_std` targets, doing this is more complicated, especially because\n+`#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+probably need to invoke some target-specific intrinsic. Examples include:\n+  - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+  - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n+\n+### Example\n+```\n+loop {}\n+```\n\\ No newline at end of file"}, {"sha": "ab5e35ae2ada8c475775f307275790b1bd7e16a2", "filename": "src/docs/empty_structs_with_brackets.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_structs_with_brackets.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fempty_structs_with_brackets.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fempty_structs_with_brackets.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Finds structs without fields (a so-called \"empty struct\") that are declared with brackets.\n+\n+### Why is this bad?\n+Empty brackets after a struct declaration can be omitted.\n+\n+### Example\n+```\n+struct Cookie {}\n+```\n+Use instead:\n+```\n+struct Cookie;\n+```\n\\ No newline at end of file"}, {"sha": "d30a973a5a1357eab121909c688ad05f160de47e", "filename": "src/docs/enum_clike_unportable_variant.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_clike_unportable_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_clike_unportable_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_clike_unportable_variant.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for C-like enumerations that are\n+`repr(isize/usize)` and have values that don't fit into an `i32`.\n+\n+### Why is this bad?\n+This will truncate the variant value on 32 bit\n+architectures, but works fine on 64 bit.\n+\n+### Example\n+```\n+#[repr(usize)]\n+enum NonPortable {\n+    X = 0x1_0000_0000,\n+    Y = 0,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3776822c35b0c21a9d6330c1b7a374c14cf8d232", "filename": "src/docs/enum_glob_use.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_glob_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_glob_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_glob_use.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `use Enum::*`.\n+\n+### Why is this bad?\n+It is usually better style to use the prefixed name of\n+an enumeration variant, rather than importing variants.\n+\n+### Known problems\n+Old-style enumerations that prefix the variants are\n+still around.\n+\n+### Example\n+```\n+use std::cmp::Ordering::*;\n+\n+foo(Less);\n+```\n+\n+Use instead:\n+```\n+use std::cmp::Ordering;\n+\n+foo(Ordering::Less)\n+```\n\\ No newline at end of file"}, {"sha": "e726925edda82ca777546cf7e613ee78304c10a0", "filename": "src/docs/enum_variant_names.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_variant_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fenum_variant_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fenum_variant_names.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Detects enumeration variants that are prefixed or suffixed\n+by the same characters.\n+\n+### Why is this bad?\n+Enumeration variant names should specify their variant,\n+not repeat the enumeration name.\n+\n+### Limitations\n+Characters with no casing will be considered when comparing prefixes/suffixes\n+This applies to numbers and non-ascii characters without casing\n+e.g. `Foo1` and `Foo2` is considered to have different prefixes\n+(the prefixes are `Foo1` and `Foo2` respectively), as also `Bar\u8783`, `Bar\u87f9`\n+\n+### Example\n+```\n+enum Cake {\n+    BlackForestCake,\n+    HummingbirdCake,\n+    BattenbergCake,\n+}\n+```\n+Use instead:\n+```\n+enum Cake {\n+    BlackForest,\n+    Hummingbird,\n+    Battenberg,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "2d75a0ec546e72043fb085d8cdfa4406311bc856", "filename": "src/docs/eq_op.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Feq_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Feq_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Feq_op.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for equal operands to comparison, logical and\n+bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+`||`, `&`, `|`, `^`, `-` and `/`).\n+\n+### Why is this bad?\n+This is usually just a typo or a copy and paste error.\n+\n+### Known problems\n+False negatives: We had some false positives regarding\n+calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+of `x.pop() && x.pop()`), so we removed matching any function or method\n+calls. We may introduce a list of known pure functions in the future.\n+\n+### Example\n+```\n+if x + 1 == x + 1 {}\n+\n+// or\n+\n+assert_eq!(a, a);\n+```\n\\ No newline at end of file"}, {"sha": "9997046954c20d3779fe82a2384579dfc6ca8be0", "filename": "src/docs/equatable_if_let.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fequatable_if_let.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fequatable_if_let.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fequatable_if_let.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for pattern matchings that can be expressed using equality.\n+\n+### Why is this bad?\n+\n+* It reads better and has less cognitive load because equality won't cause binding.\n+* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\n+criticized for increasing the cognitive load of reading the code.\n+* Equality is a simple bool expression and can be merged with `&&` and `||` and\n+reuse if blocks\n+\n+### Example\n+```\n+if let Some(2) = x {\n+    do_thing();\n+}\n+```\n+Use instead:\n+```\n+if x == Some(2) {\n+    do_thing();\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3d285a6d86e48f8e7e7ebbebd97b83ad5489c6f5", "filename": "src/docs/erasing_op.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ferasing_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ferasing_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ferasing_op.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for erasing operations, e.g., `x * 0`.\n+\n+### Why is this bad?\n+The whole expression can be replaced by zero.\n+This is most likely not the intended outcome and should probably be\n+corrected\n+\n+### Example\n+```\n+let x = 1;\n+0 / x;\n+0 * x;\n+x & 0;\n+```\n\\ No newline at end of file"}, {"sha": "1dc83c5ce0ee05ded2a906da263f6f2cdbedcfe2", "filename": "src/docs/err_expect.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ferr_expect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ferr_expect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ferr_expect.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for `.err().expect()` calls on the `Result` type.\n+\n+### Why is this bad?\n+`.expect_err()` can be called directly to avoid the extra type conversion from `err()`.\n+\n+### Example\n+```\n+let x: Result<u32, &str> = Ok(10);\n+x.err().expect(\"Testing err().expect()\");\n+```\n+Use instead:\n+```\n+let x: Result<u32, &str> = Ok(10);\n+x.expect_err(\"Testing expect_err\");\n+```\n\\ No newline at end of file"}, {"sha": "517879c47152b20fb30798b191cb0d627e403ca3", "filename": "src/docs/excessive_precision.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexcessive_precision.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexcessive_precision.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexcessive_precision.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for float literals with a precision greater\n+than that supported by the underlying type.\n+\n+### Why is this bad?\n+Rust will truncate the literal silently.\n+\n+### Example\n+```\n+let v: f32 = 0.123_456_789_9;\n+println!(\"{}\", v); //  0.123_456_789\n+```\n+\n+Use instead:\n+```\n+let v: f64 = 0.123_456_789_9;\n+println!(\"{}\", v); //  0.123_456_789_9\n+```\n\\ No newline at end of file"}, {"sha": "d1032a7a29aa04d68b3384edfc0dcc9dd4b310a2", "filename": "src/docs/exhaustive_enums.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexhaustive_enums.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexhaustive_enums.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexhaustive_enums.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Warns on any exported `enum`s that are not tagged `#[non_exhaustive]`\n+\n+### Why is this bad?\n+Exhaustive enums are typically fine, but a project which does\n+not wish to make a stability commitment around exported enums may wish to\n+disable them by default.\n+\n+### Example\n+```\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+```\n+Use instead:\n+```\n+#[non_exhaustive]\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+```\n\\ No newline at end of file"}, {"sha": "fd6e4f5caf1f257b04d4f0712b064fe44eb40ff6", "filename": "src/docs/exhaustive_structs.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexhaustive_structs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexhaustive_structs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexhaustive_structs.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Warns on any exported `structs`s that are not tagged `#[non_exhaustive]`\n+\n+### Why is this bad?\n+Exhaustive structs are typically fine, but a project which does\n+not wish to make a stability commitment around exported structs may wish to\n+disable them by default.\n+\n+### Example\n+```\n+struct Foo {\n+    bar: u8,\n+    baz: String,\n+}\n+```\n+Use instead:\n+```\n+#[non_exhaustive]\n+struct Foo {\n+    bar: u8,\n+    baz: String,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1e6154d43e0538550a3c6b40f984d79d4bb259ea", "filename": "src/docs/exit.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexit.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexit.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexit.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+`exit()`  terminates the program and doesn't provide a\n+stack trace.\n+\n+### Why is this bad?\n+Ideally a program is terminated by finishing\n+the main function.\n+\n+### Example\n+```\n+std::process::exit(0)\n+```\n\\ No newline at end of file"}, {"sha": "d82d9aa9baff240c08aa50ceb41107973ffb44a9", "filename": "src/docs/expect_fun_call.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpect_fun_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpect_fun_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpect_fun_call.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+etc., and suggests to use `unwrap_or_else` instead\n+\n+### Why is this bad?\n+The function will always be called.\n+\n+### Known problems\n+If the function has side-effects, not calling it will\n+change the semantics of the program, but you shouldn't rely on that anyway.\n+\n+### Example\n+```\n+foo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n+\n+// or\n+\n+foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n+```\n+\n+Use instead:\n+```\n+foo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n+```\n\\ No newline at end of file"}, {"sha": "4a6981e334fd368b1b2d521d395506c8d7fdb494", "filename": "src/docs/expect_used.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpect_used.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpect_used.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpect_used.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.\n+\n+### Why is this bad?\n+Usually it is better to handle the `None` or `Err` case.\n+Still, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\n+this lint is `Allow` by default.\n+\n+`result.expect()` will let the thread panic on `Err`\n+values. Normally, you want to implement more sophisticated error handling,\n+and propagate errors upwards with `?` operator.\n+\n+### Examples\n+```\n+option.expect(\"one\");\n+result.expect(\"one\");\n+```\n+\n+Use instead:\n+```\n+option?;\n+\n+// or\n+\n+result?;\n+```\n\\ No newline at end of file"}, {"sha": "391d93b6713cca2005d7d14b2b97fd24c48e8098", "filename": "src/docs/expl_impl_clone_on_copy.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexpl_impl_clone_on_copy.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for explicit `Clone` implementations for `Copy`\n+types.\n+\n+### Why is this bad?\n+To avoid surprising behavior, these traits should\n+agree and the behavior of `Copy` cannot be overridden. In almost all\n+situations a `Copy` type should have a `Clone` implementation that does\n+nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n+gets you.\n+\n+### Example\n+```\n+#[derive(Copy)]\n+struct Foo;\n+\n+impl Clone for Foo {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "65b256317725288a2f95142e309ca0effd3db921", "filename": "src/docs/explicit_auto_deref.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_auto_deref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_auto_deref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_auto_deref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for dereferencing expressions which would be covered by auto-deref.\n+\n+### Why is this bad?\n+This unnecessarily complicates the code.\n+\n+### Example\n+```\n+let x = String::new();\n+let y: &str = &*x;\n+```\n+Use instead:\n+```\n+let x = String::new();\n+let y: &str = &x;\n+```\n\\ No newline at end of file"}, {"sha": "2661a43e10341f95851551e53b0b7695bc308cf4", "filename": "src/docs/explicit_counter_loop.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_counter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_counter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_counter_loop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks `for` loops over slices with an explicit counter\n+and suggests the use of `.enumerate()`.\n+\n+### Why is this bad?\n+Using `.enumerate()` makes the intent more clear,\n+declutters the code and may be faster in some instances.\n+\n+### Example\n+```\n+let mut i = 0;\n+for item in &v {\n+    bar(i, *item);\n+    i += 1;\n+}\n+```\n+\n+Use instead:\n+```\n+for (i, item) in v.iter().enumerate() { bar(i, *item); }\n+```\n\\ No newline at end of file"}, {"sha": "e14e981c7073bee00239c22eb5420c6ca87669a3", "filename": "src/docs/explicit_deref_methods.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_deref_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_deref_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_deref_methods.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for explicit `deref()` or `deref_mut()` method calls.\n+\n+### Why is this bad?\n+Dereferencing by `&*x` or `&mut *x` is clearer and more concise,\n+when not part of a method chain.\n+\n+### Example\n+```\n+use std::ops::Deref;\n+let a: &mut String = &mut String::from(\"foo\");\n+let b: &str = a.deref();\n+```\n+\n+Use instead:\n+```\n+let a: &mut String = &mut String::from(\"foo\");\n+let b = &*a;\n+```\n+\n+This lint excludes:\n+```\n+let _ = d.unwrap().deref();\n+```\n\\ No newline at end of file"}, {"sha": "3931dfd69a318d74f9112bd2ea4b7baff6757b7a", "filename": "src/docs/explicit_into_iter_loop.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_into_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_into_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_into_iter_loop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for loops on `y.into_iter()` where `y` will do, and\n+suggests the latter.\n+\n+### Why is this bad?\n+Readability.\n+\n+### Example\n+```\n+// with `y` a `Vec` or slice:\n+for x in y.into_iter() {\n+    // ..\n+}\n+```\n+can be rewritten to\n+```\n+for x in y {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "cabe72e91d04f6395df2a64f5180c9ec0ebe15e9", "filename": "src/docs/explicit_iter_loop.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_iter_loop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for loops on `x.iter()` where `&x` will do, and\n+suggests the latter.\n+\n+### Why is this bad?\n+Readability.\n+\n+### Known problems\n+False negatives. We currently only warn on some known\n+types.\n+\n+### Example\n+```\n+// with `y` a `Vec` or slice:\n+for x in y.iter() {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+for x in &y {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "eafed5d39e5c63e48783ae846b87de9c1c901ffe", "filename": "src/docs/explicit_write.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_write.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fexplicit_write.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fexplicit_write.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for usage of `write!()` / `writeln()!` which can be\n+replaced with `(e)print!()` / `(e)println!()`\n+\n+### Why is this bad?\n+Using `(e)println! is clearer and more concise\n+\n+### Example\n+```\n+writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n+writeln!(&mut std::io::stdout(), \"foo: {:?}\", bar).unwrap();\n+```\n+\n+Use instead:\n+```\n+eprintln!(\"foo: {:?}\", bar);\n+println!(\"foo: {:?}\", bar);\n+```\n\\ No newline at end of file"}, {"sha": "2f31dcf5f74013c933a071068115a2de1a20945e", "filename": "src/docs/extend_with_drain.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fextend_with_drain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fextend_with_drain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fextend_with_drain.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for occurrences where one vector gets extended instead of append\n+\n+### Why is this bad?\n+Using `append` instead of `extend` is more concise and faster\n+\n+### Example\n+```\n+let mut a = vec![1, 2, 3];\n+let mut b = vec![4, 5, 6];\n+\n+a.extend(b.drain(..));\n+```\n+\n+Use instead:\n+```\n+let mut a = vec![1, 2, 3];\n+let mut b = vec![4, 5, 6];\n+\n+a.append(&mut b);\n+```\n\\ No newline at end of file"}, {"sha": "bc1814aa4752dae2cf7574f3fa00b98553edd2ad", "filename": "src/docs/extra_unused_lifetimes.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fextra_unused_lifetimes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fextra_unused_lifetimes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fextra_unused_lifetimes.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for lifetimes in generics that are never used\n+anywhere else.\n+\n+### Why is this bad?\n+The additional lifetimes make the code look more\n+complicated, while there is nothing out of the ordinary going on. Removing\n+them leads to more readable code.\n+\n+### Example\n+```\n+// unnecessary lifetimes\n+fn unused_lifetime<'a>(x: u8) {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+fn no_lifetime(x: u8) {\n+    // ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "588a5bb103d46e8cccd30f84c1982069c9c1d5e7", "filename": "src/docs/fallible_impl_from.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffallible_impl_from.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffallible_impl_from.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffallible_impl_from.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n+\n+### Why is this bad?\n+`TryFrom` should be used if there's a possibility of failure.\n+\n+### Example\n+```\n+struct Foo(i32);\n+\n+impl From<String> for Foo {\n+    fn from(s: String) -> Self {\n+        Foo(s.parse().unwrap())\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+struct Foo(i32);\n+\n+impl TryFrom<String> for Foo {\n+    type Error = ();\n+    fn try_from(s: String) -> Result<Self, Self::Error> {\n+        if let Ok(parsed) = s.parse() {\n+            Ok(Foo(parsed))\n+        } else {\n+            Err(())\n+        }\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "e58b7239fde9e039676d3208a95a8ebbcf991cce", "filename": "src/docs/field_reassign_with_default.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffield_reassign_with_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffield_reassign_with_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffield_reassign_with_default.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for immediate reassignment of fields initialized\n+with Default::default().\n+\n+### Why is this bad?\n+It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n+\n+### Known problems\n+Assignments to patterns that are of tuple type are not linted.\n+\n+### Example\n+```\n+let mut a: A = Default::default();\n+a.i = 42;\n+```\n+\n+Use instead:\n+```\n+let a = A {\n+    i: 42,\n+    .. Default::default()\n+};\n+```\n\\ No newline at end of file"}, {"sha": "ad14bd62c4de483b76e3d6d04f85a6120614996d", "filename": "src/docs/filetype_is_file.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffiletype_is_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffiletype_is_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffiletype_is_file.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for `FileType::is_file()`.\n+\n+### Why is this bad?\n+When people testing a file type with `FileType::is_file`\n+they are testing whether a path is something they can get bytes from. But\n+`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\n+symlink in windows. Using `!FileType::is_dir()` is a better way to that intention.\n+\n+### Example\n+```\n+let metadata = std::fs::metadata(\"foo.txt\")?;\n+let filetype = metadata.file_type();\n+\n+if filetype.is_file() {\n+    // read file\n+}\n+```\n+\n+should be written as:\n+\n+```\n+let metadata = std::fs::metadata(\"foo.txt\")?;\n+let filetype = metadata.file_type();\n+\n+if !filetype.is_dir() {\n+    // read file\n+}\n+```\n\\ No newline at end of file"}, {"sha": "83b666f2e27820a7493ace384d6e5676dc81ed6d", "filename": "src/docs/filter_map_identity.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_map_identity.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for usage of `filter_map(|x| x)`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely by using `flatten`.\n+\n+### Example\n+```\n+iter.filter_map(|x| x);\n+```\n+Use instead:\n+```\n+iter.flatten();\n+```\n\\ No newline at end of file"}, {"sha": "b38620b56a50fecc0abeb311a07f30a84c2a6bae", "filename": "src/docs/filter_map_next.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_map_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_map_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_map_next.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `_.filter_map(_).next()`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.find_map(_)`.\n+\n+### Example\n+```\n+ (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n+```\n+Can be written as\n+\n+```\n+ (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n+```\n\\ No newline at end of file"}, {"sha": "898a74166dc14649f0faa4fb561968049f14bc9a", "filename": "src/docs/filter_next.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffilter_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffilter_next.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `_.filter(_).next()`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely as\n+`_.find(_)`.\n+\n+### Example\n+```\n+vec.iter().filter(|x| **x == 0).next();\n+```\n+\n+Use instead:\n+```\n+vec.iter().find(|x| **x == 0);\n+```\n\\ No newline at end of file"}, {"sha": "a5ee79b4982fb753d1d99c77b40491d9b26c0013", "filename": "src/docs/flat_map_identity.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fflat_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fflat_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fflat_map_identity.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for usage of `flat_map(|x| x)`.\n+\n+### Why is this bad?\n+Readability, this can be written more concisely by using `flatten`.\n+\n+### Example\n+```\n+iter.flat_map(|x| x);\n+```\n+Can be written as\n+```\n+iter.flatten();\n+```\n\\ No newline at end of file"}, {"sha": "d50b9156d3654c19262e8460e2ddf1f3d22a5483", "filename": "src/docs/flat_map_option.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fflat_map_option.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fflat_map_option.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fflat_map_option.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usages of `Iterator::flat_map()` where `filter_map()` could be\n+used instead.\n+\n+### Why is this bad?\n+When applicable, `filter_map()` is more clear since it shows that\n+`Option` is used to produce 0 or 1 items.\n+\n+### Example\n+```\n+let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n+```\n+Use instead:\n+```\n+let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n+```\n\\ No newline at end of file"}, {"sha": "1f9bce5abd59fdd52e2210a73ea648687a55c1ce", "filename": "src/docs/float_arithmetic.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_arithmetic.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for float arithmetic.\n+\n+### Why is this bad?\n+For some embedded systems or kernel development, it\n+can be useful to rule out floating-point numbers.\n+\n+### Example\n+```\n+a + 1.0;\n+```\n\\ No newline at end of file"}, {"sha": "c19907c903e9df1d6592666ddc5f07bf58977841", "filename": "src/docs/float_cmp.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_cmp.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for (in-)equality comparisons on floating-point\n+values (apart from zero), except in functions called `*eq*` (which probably\n+implement equality for a type involving floats).\n+\n+### Why is this bad?\n+Floating point calculations are usually imprecise, so\n+asking if two values are *exactly* equal is asking for trouble. For a good\n+guide on what to do, see [the floating point\n+guide](http://www.floating-point-gui.de/errors/comparison).\n+\n+### Example\n+```\n+let x = 1.2331f64;\n+let y = 1.2332f64;\n+\n+if y == 1.23f64 { }\n+if y != x {} // where both are floats\n+```\n+\n+Use instead:\n+```\n+let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+// let error_margin = std::f64::EPSILON;\n+if (y - 1.23f64).abs() < error_margin { }\n+if (y - x).abs() > error_margin { }\n+```\n\\ No newline at end of file"}, {"sha": "9208feaacd81011198713479d3f80d72b33a2c41", "filename": "src/docs/float_cmp_const.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_cmp_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_cmp_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_cmp_const.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for (in-)equality comparisons on floating-point\n+value and constant, except in functions called `*eq*` (which probably\n+implement equality for a type involving floats).\n+\n+### Why is this bad?\n+Floating point calculations are usually imprecise, so\n+asking if two values are *exactly* equal is asking for trouble. For a good\n+guide on what to do, see [the floating point\n+guide](http://www.floating-point-gui.de/errors/comparison).\n+\n+### Example\n+```\n+let x: f64 = 1.0;\n+const ONE: f64 = 1.00;\n+\n+if x == ONE { } // where both are floats\n+```\n+\n+Use instead:\n+```\n+let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+// let error_margin = std::f64::EPSILON;\n+if (x - ONE).abs() < error_margin { }\n+```\n\\ No newline at end of file"}, {"sha": "556b574e15d303a4b8c6774b1f9e94ec6b3c89dd", "filename": "src/docs/float_equality_without_abs.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_equality_without_abs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffloat_equality_without_abs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffloat_equality_without_abs.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for statements of the form `(a - b) < f32::EPSILON` or\n+`(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+\n+### Why is this bad?\n+The code without `.abs()` is more likely to have a bug.\n+\n+### Known problems\n+If the user can ensure that b is larger than a, the `.abs()` is\n+technically unnecessary. However, it will make the code more robust and doesn't have any\n+large performance implications. If the abs call was deliberately left out for performance\n+reasons, it is probably better to state this explicitly in the code, which then can be done\n+with an allow.\n+\n+### Example\n+```\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b) < f32::EPSILON\n+}\n+```\n+Use instead:\n+```\n+pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    (a - b).abs() < f32::EPSILON\n+}\n+```\n\\ No newline at end of file"}, {"sha": "7d2b7b681deb15ff2edf37bf9b60d9b3cd60a3b7", "filename": "src/docs/fn_address_comparisons.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_address_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_address_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_address_comparisons.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for comparisons with an address of a function item.\n+\n+### Why is this bad?\n+Function item address is not guaranteed to be unique and could vary\n+between different code generation units. Furthermore different function items could have\n+the same address after being merged together.\n+\n+### Example\n+```\n+type F = fn();\n+fn a() {}\n+let f: F = a;\n+if f == a {\n+    // ...\n+}\n+```\n\\ No newline at end of file"}, {"sha": "2eae0563368c1adb6e91dc7080d1c839e5c07141", "filename": "src/docs/fn_params_excessive_bools.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_params_excessive_bools.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_params_excessive_bools.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_params_excessive_bools.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,31 @@\n+### What it does\n+Checks for excessive use of\n+bools in function definitions.\n+\n+### Why is this bad?\n+Calls to such functions\n+are confusing and error prone, because it's\n+hard to remember argument order and you have\n+no type system support to back you up. Using\n+two-variant enums instead of bools often makes\n+API easier to use.\n+\n+### Example\n+```\n+fn f(is_round: bool, is_hot: bool) { ... }\n+```\n+\n+Use instead:\n+```\n+enum Shape {\n+    Round,\n+    Spiky,\n+}\n+\n+enum Temperature {\n+    Hot,\n+    IceCold,\n+}\n+\n+fn f(shape: Shape, temperature: Temperature) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "1f587f6d7176891c2999504b86bc80923eddf3ae", "filename": "src/docs/fn_to_numeric_cast.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for casts of function pointers to something other than usize\n+\n+### Why is this bad?\n+Casting a function pointer to anything other than usize/isize is not portable across\n+architectures, because you end up losing bits if the target type is too small or end up with a\n+bunch of extra bits that waste space and add more instructions to the final binary than\n+strictly necessary for the problem\n+\n+Casting to isize also doesn't make sense since there are no signed addresses.\n+\n+### Example\n+```\n+fn fun() -> i32 { 1 }\n+let _ = fun as i64;\n+```\n+\n+Use instead:\n+```\n+let _ = fun as usize;\n+```\n\\ No newline at end of file"}, {"sha": "ee3c33d237255999c8332a1722c1a2e2248527d8", "filename": "src/docs/fn_to_numeric_cast_any.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast_any.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast_any.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast_any.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,35 @@\n+### What it does\n+Checks for casts of a function pointer to any integer type.\n+\n+### Why is this bad?\n+Casting a function pointer to an integer can have surprising results and can occur\n+accidentally if parentheses are omitted from a function call. If you aren't doing anything\n+low-level with function pointers then you can opt-out of casting functions to integers in\n+order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n+pointer casts in your code.\n+\n+### Example\n+```\n+// fn1 is cast as `usize`\n+fn fn1() -> u16 {\n+    1\n+};\n+let _ = fn1 as usize;\n+```\n+\n+Use instead:\n+```\n+// maybe you intended to call the function?\n+fn fn2() -> u16 {\n+    1\n+};\n+let _ = fn2() as usize;\n+\n+// or\n+\n+// maybe you intended to cast it to a function type?\n+fn fn3() -> u16 {\n+    1\n+}\n+let _ = fn3 as fn() -> u16;\n+```\n\\ No newline at end of file"}, {"sha": "69f12fa319f184c12807d8f7037ba971a0c441b0", "filename": "src/docs/fn_to_numeric_cast_with_truncation.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for casts of a function pointer to a numeric type not wide enough to\n+store address.\n+\n+### Why is this bad?\n+Such a cast discards some bits of the function's address. If this is intended, it would be more\n+clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+a comment) to perform the truncation.\n+\n+### Example\n+```\n+fn fn1() -> i16 {\n+    1\n+};\n+let _ = fn1 as i32;\n+```\n+\n+Use instead:\n+```\n+// Cast to usize first, then comment with the reason for the truncation\n+fn fn1() -> i16 {\n+    1\n+};\n+let fn_ptr = fn1 as usize;\n+let fn_ptr_truncated = fn_ptr as i32;\n+```\n\\ No newline at end of file"}, {"sha": "a9a2ffee9c743dc99302ab5af63bdb465d1d6f37", "filename": "src/docs/for_kv_map.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffor_kv_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffor_kv_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffor_kv_map.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+ignoring either the keys or values.\n+\n+### Why is this bad?\n+Readability. There are `keys` and `values` methods that\n+can be used to express that don't need the values or keys.\n+\n+### Example\n+```\n+for (k, _) in &map {\n+    ..\n+}\n+```\n+\n+could be replaced by\n+\n+```\n+for k in map.keys() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "c5a7508e45d40e58cef17a27e3f92a855dd0b398", "filename": "src/docs/for_loops_over_fallibles.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffor_loops_over_fallibles.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffor_loops_over_fallibles.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffor_loops_over_fallibles.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,32 @@\n+### What it does\n+Checks for `for` loops over `Option` or `Result` values.\n+\n+### Why is this bad?\n+Readability. This is more clearly expressed as an `if\n+let`.\n+\n+### Example\n+```\n+for x in opt {\n+    // ..\n+}\n+\n+for x in &res {\n+    // ..\n+}\n+\n+for x in res.iter() {\n+    // ..\n+}\n+```\n+\n+Use instead:\n+```\n+if let Some(x) = opt {\n+    // ..\n+}\n+\n+if let Ok(x) = res {\n+    // ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1d100912e9a4858152077e45ecee4223f5ef154e", "filename": "src/docs/forget_copy.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_copy.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a value that\n+derives the Copy trait\n+\n+### Why is this bad?\n+Calling `std::mem::forget` [does nothing for types that\n+implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\n+value will be copied and moved into the function on invocation.\n+\n+An alternative, but also valid, explanation is that Copy types do not\n+implement\n+the Drop trait, which means they have no destructors. Without a destructor,\n+there\n+is nothing for `std::mem::forget` to ignore.\n+\n+### Example\n+```\n+let x: i32 = 42; // i32 implements Copy\n+std::mem::forget(x) // A copy of x is passed to the function, leaving the\n+                    // original unaffected\n+```\n\\ No newline at end of file"}, {"sha": "3307d654c17f2bd860f740606bf29b5aa91b4085", "filename": "src/docs/forget_non_drop.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_non_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_non_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_non_drop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a value that does not implement `Drop`.\n+\n+### Why is this bad?\n+Calling `std::mem::forget` is no different than dropping such a type. A different value may\n+have been intended.\n+\n+### Example\n+```\n+struct Foo;\n+let x = Foo;\n+std::mem::forget(x);\n+```\n\\ No newline at end of file"}, {"sha": "874fb8786068d635fa10e65e5bce43bf27d6947b", "filename": "src/docs/forget_ref.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fforget_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fforget_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for calls to `std::mem::forget` with a reference\n+instead of an owned value.\n+\n+### Why is this bad?\n+Calling `forget` on a reference will only forget the\n+reference itself, which is a no-op. It will not forget the underlying\n+referenced\n+value, which is likely what was intended.\n+\n+### Example\n+```\n+let x = Box::new(1);\n+std::mem::forget(&x) // Should have been forget(x), x will still be dropped\n+```\n\\ No newline at end of file"}, {"sha": "ac498472f017f04a35c2a7017e599dc40f3034d9", "filename": "src/docs/format_in_format_args.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fformat_in_format_args.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fformat_in_format_args.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fformat_in_format_args.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Detects `format!` within the arguments of another macro that does\n+formatting such as `format!` itself, `write!` or `println!`. Suggests\n+inlining the `format!` call.\n+\n+### Why is this bad?\n+The recommended code is both shorter and avoids a temporary allocation.\n+\n+### Example\n+```\n+println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+```\n+Use instead:\n+```\n+println!(\"error: something failed at {}\", Location::caller());\n+```\n\\ No newline at end of file"}, {"sha": "ca409ebc7ec2634e5befc04cdda49e710dd6c8dd", "filename": "src/docs/format_push_string.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fformat_push_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fformat_push_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fformat_push_string.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Detects cases where the result of a `format!` call is\n+appended to an existing `String`.\n+\n+### Why is this bad?\n+Introduces an extra, avoidable heap allocation.\n+\n+### Known problems\n+`format!` returns a `String` but `write!` returns a `Result`.\n+Thus you are forced to ignore the `Err` variant to achieve the same API.\n+\n+While using `write!` in the suggested way should never fail, this isn't necessarily clear to the programmer.\n+\n+### Example\n+```\n+let mut s = String::new();\n+s += &format!(\"0x{:X}\", 1024);\n+s.push_str(&format!(\"0x{:X}\", 1024));\n+```\n+Use instead:\n+```\n+use std::fmt::Write as _; // import without risk of name clashing\n+\n+let mut s = String::new();\n+let _ = write!(s, \"0x{:X}\", 1024);\n+```\n\\ No newline at end of file"}, {"sha": "f3fd275972645c87168c6c141eb4eb95616e8fc9", "filename": "src/docs/from_iter_instead_of_collect.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_iter_instead_of_collect.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for `from_iter()` function calls on types that implement the `FromIterator`\n+trait.\n+\n+### Why is this bad?\n+It is recommended style to use collect. See\n+[FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)\n+\n+### Example\n+```\n+let five_fives = std::iter::repeat(5).take(5);\n+\n+let v = Vec::from_iter(five_fives);\n+\n+assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+```\n+Use instead:\n+```\n+let five_fives = std::iter::repeat(5).take(5);\n+\n+let v: Vec<i32> = five_fives.collect();\n+\n+assert_eq!(v, vec![5, 5, 5, 5, 5]);\n+```\n\\ No newline at end of file"}, {"sha": "0770bcc42c2704e2a6e0335fd71dd4f5330dd798", "filename": "src/docs/from_over_into.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_over_into.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_over_into.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_over_into.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Searches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.\n+\n+### Why is this bad?\n+According the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true.\n+\n+### Example\n+```\n+struct StringWrapper(String);\n+\n+impl Into<StringWrapper> for String {\n+    fn into(self) -> StringWrapper {\n+        StringWrapper(self)\n+    }\n+}\n+```\n+Use instead:\n+```\n+struct StringWrapper(String);\n+\n+impl From<String> for StringWrapper {\n+    fn from(s: String) -> StringWrapper {\n+        StringWrapper(s)\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f6f319d3eaa1811b7ef308a538757da595320b1f", "filename": "src/docs/from_str_radix_10.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_str_radix_10.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffrom_str_radix_10.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffrom_str_radix_10.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+\n+Checks for function invocations of the form `primitive::from_str_radix(s, 10)`\n+\n+### Why is this bad?\n+\n+This specific common use case can be rewritten as `s.parse::<primitive>()`\n+(and in most cases, the turbofish can be removed), which reduces code length\n+and complexity.\n+\n+### Known problems\n+\n+This lint may suggest using (&<expression>).parse() instead of <expression>.parse() directly\n+in some cases, which is correct but adds unnecessary complexity to the code.\n+\n+### Example\n+```\n+let input: &str = get_input();\n+let num = u16::from_str_radix(input, 10)?;\n+```\n+Use instead:\n+```\n+let input: &str = get_input();\n+let num: u16 = input.parse()?;\n+```\n\\ No newline at end of file"}, {"sha": "0aa048d273551a3af129d5246c8a8a15a0f087c4", "filename": "src/docs/future_not_send.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffuture_not_send.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Ffuture_not_send.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Ffuture_not_send.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+This lint requires Future implementations returned from\n+functions and methods to implement the `Send` marker trait. It is mostly\n+used by library authors (public and internal) that target an audience where\n+multithreaded executors are likely to be used for running these Futures.\n+\n+### Why is this bad?\n+A Future implementation captures some state that it\n+needs to eventually produce its final value. When targeting a multithreaded\n+executor (which is the norm on non-embedded devices) this means that this\n+state may need to be transported to other threads, in other words the\n+whole Future needs to implement the `Send` marker trait. If it does not,\n+then the resulting Future cannot be submitted to a thread pool in the\n+end user\u2019s code.\n+\n+Especially for generic functions it can be confusing to leave the\n+discovery of this problem to the end user: the reported error location\n+will be far from its cause and can in many cases not even be fixed without\n+modifying the library where the offending Future implementation is\n+produced.\n+\n+### Example\n+```\n+async fn not_send(bytes: std::rc::Rc<[u8]>) {}\n+```\n+Use instead:\n+```\n+async fn is_send(bytes: std::sync::Arc<[u8]>) {}\n+```\n\\ No newline at end of file"}, {"sha": "c905a737ddf3ff4ff2e27faf5f502b9e69a93c50", "filename": "src/docs/get_first.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_first.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_first.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_first.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for using `x.get(0)` instead of\n+`x.first()`.\n+\n+### Why is this bad?\n+Using `x.first()` is easier to read and has the same\n+result.\n+\n+### Example\n+```\n+let x = vec![2, 3, 5];\n+let first_element = x.get(0);\n+```\n+\n+Use instead:\n+```\n+let x = vec![2, 3, 5];\n+let first_element = x.first();\n+```\n\\ No newline at end of file"}, {"sha": "31c7f269586ab148b329ab5cd6146139d686d2cf", "filename": "src/docs/get_last_with_len.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_last_with_len.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_last_with_len.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_last_with_len.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for using `x.get(x.len() - 1)` instead of\n+`x.last()`.\n+\n+### Why is this bad?\n+Using `x.last()` is easier to read and has the same\n+result.\n+\n+Note that using `x[x.len() - 1]` is semantically different from\n+`x.last()`.  Indexing into the array will panic on out-of-bounds\n+accesses, while `x.get()` and `x.last()` will return `None`.\n+\n+There is another lint (get_unwrap) that covers the case of using\n+`x.get(index).unwrap()` instead of `x[index]`.\n+\n+### Example\n+```\n+let x = vec![2, 3, 5];\n+let last_element = x.get(x.len() - 1);\n+```\n+\n+Use instead:\n+```\n+let x = vec![2, 3, 5];\n+let last_element = x.last();\n+```\n\\ No newline at end of file"}, {"sha": "8defc2224416957864a017e09222554cdf5d1fcc", "filename": "src/docs/get_unwrap.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_unwrap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fget_unwrap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fget_unwrap.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,30 @@\n+### What it does\n+Checks for use of `.get().unwrap()` (or\n+`.get_mut().unwrap`) on a standard library type which implements `Index`\n+\n+### Why is this bad?\n+Using the Index trait (`[]`) is more clear and more\n+concise.\n+\n+### Known problems\n+Not a replacement for error handling: Using either\n+`.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\n+if the value being accessed is `None`. If the use of `.get().unwrap()` is a\n+temporary placeholder for dealing with the `Option` type, then this does\n+not mitigate the need for error handling. If there is a chance that `.get()`\n+will be `None` in your program, then it is advisable that the `None` case\n+is handled in a future refactor instead of using `.unwrap()` or the Index\n+trait.\n+\n+### Example\n+```\n+let mut some_vec = vec![0, 1, 2, 3];\n+let last = some_vec.get(3).unwrap();\n+*some_vec.get_mut(0).unwrap() = 1;\n+```\n+The correct use would be:\n+```\n+let mut some_vec = vec![0, 1, 2, 3];\n+let last = some_vec[3];\n+some_vec[0] = 1;\n+```\n\\ No newline at end of file"}, {"sha": "a8e40bb43e9d51b2d528bde622560da8a60175c4", "filename": "src/docs/identity_op.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fidentity_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fidentity_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fidentity_op.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,11 @@\n+### What it does\n+Checks for identity operations, e.g., `x + 0`.\n+\n+### Why is this bad?\n+This code can be removed without changing the\n+meaning. So it just obscures what's going on. Delete it mercilessly.\n+\n+### Example\n+```\n+x / 1 + 0 * 1 - 0 | 0;\n+```\n\\ No newline at end of file"}, {"sha": "4d873ade9ace346cfe7303717e3a4e1fe0d4810d", "filename": "src/docs/if_let_mutex.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_let_mutex.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_let_mutex.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_let_mutex.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for `Mutex::lock` calls in `if let` expression\n+with lock calls in any of the else blocks.\n+\n+### Why is this bad?\n+The Mutex lock remains held for the whole\n+`if let ... else` block and deadlocks.\n+\n+### Example\n+```\n+if let Ok(thing) = mutex.lock() {\n+    do_thing();\n+} else {\n+    mutex.lock();\n+}\n+```\n+Should be written\n+```\n+let locked = mutex.lock();\n+if let Ok(thing) = locked {\n+    do_thing(thing);\n+} else {\n+    use_locked(locked);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "0e5ac4ce6bb8047f8174bf2a1107f16646b347ef", "filename": "src/docs/if_not_else.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_not_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_not_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_not_else.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for usage of `!` or `!=` in an if condition with an\n+else branch.\n+\n+### Why is this bad?\n+Negations reduce the readability of statements.\n+\n+### Example\n+```\n+if !v.is_empty() {\n+    a()\n+} else {\n+    b()\n+}\n+```\n+\n+Could be written:\n+\n+```\n+if v.is_empty() {\n+    b()\n+} else {\n+    a()\n+}\n+```\n\\ No newline at end of file"}, {"sha": "75127016bb8c18d0e8992b000e7436725a8e1ffa", "filename": "src/docs/if_same_then_else.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_same_then_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_same_then_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_same_then_else.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for `if/else` with the same body as the *then* part\n+and the *else* part.\n+\n+### Why is this bad?\n+This is probably a copy & paste error.\n+\n+### Example\n+```\n+let foo = if \u2026 {\n+    42\n+} else {\n+    42\n+};\n+```\n\\ No newline at end of file"}, {"sha": "13744f920e36237bc28e7fbf5daba8da93b8563e", "filename": "src/docs/if_then_some_else_none.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_then_some_else_none.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fif_then_some_else_none.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fif_then_some_else_none.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for if-else that could be written using either `bool::then` or `bool::then_some`.\n+\n+### Why is this bad?\n+Looks a little redundant. Using `bool::then` is more concise and incurs no loss of clarity.\n+For simple calculations and known values, use `bool::then_some`, which is eagerly evaluated\n+in comparison to `bool::then`.\n+\n+### Example\n+```\n+let a = if v.is_empty() {\n+    println!(\"true!\");\n+    Some(42)\n+} else {\n+    None\n+};\n+```\n+\n+Could be written:\n+\n+```\n+let a = v.is_empty().then(|| {\n+    println!(\"true!\");\n+    42\n+});\n+```\n\\ No newline at end of file"}, {"sha": "024ba5df93a63a7a1651bb6075f95ab275493c54", "filename": "src/docs/ifs_same_cond.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fifs_same_cond.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fifs_same_cond.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fifs_same_cond.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for consecutive `if`s with the same condition.\n+\n+### Why is this bad?\n+This is probably a copy & paste error.\n+\n+### Example\n+```\n+if a == b {\n+    \u2026\n+} else if a == b {\n+    \u2026\n+}\n+```\n+\n+Note that this lint ignores all conditions with a function call as it could\n+have side effects:\n+\n+```\n+if foo() {\n+    \u2026\n+} else if foo() { // not linted\n+    \u2026\n+}\n+```\n\\ No newline at end of file"}, {"sha": "f5aa112c52c36b98c8e1f92022001cddb04b8047", "filename": "src/docs/implicit_clone.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_clone.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_clone.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_clone.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for the usage of `_.to_owned()`, `vec.to_vec()`, or similar when calling `_.clone()` would be clearer.\n+\n+### Why is this bad?\n+These methods do the same thing as `_.clone()` but may be confusing as\n+to why we are calling `to_vec` on something that is already a `Vec` or calling `to_owned` on something that is already owned.\n+\n+### Example\n+```\n+let a = vec![1, 2, 3];\n+let b = a.to_vec();\n+let c = a.to_owned();\n+```\n+Use instead:\n+```\n+let a = vec![1, 2, 3];\n+let b = a.clone();\n+let c = a.clone();\n+```\n\\ No newline at end of file"}, {"sha": "0c1f76620f51d5ff79516b1b274b6ae62a6e7ab5", "filename": "src/docs/implicit_hasher.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_hasher.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_hasher.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_hasher.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Checks for public `impl` or `fn` missing generalization\n+over different hashers and implicitly defaulting to the default hashing\n+algorithm (`SipHash`).\n+\n+### Why is this bad?\n+`HashMap` or `HashSet` with custom hashers cannot be\n+used with them.\n+\n+### Known problems\n+Suggestions for replacing constructors can contain\n+false-positives. Also applying suggestions can require modification of other\n+pieces of code, possibly including external crates.\n+\n+### Example\n+```\n+impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n+\n+pub fn foo(map: &mut HashMap<i32, i32>) { }\n+```\n+could be rewritten as\n+```\n+impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n+\n+pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n+```\n\\ No newline at end of file"}, {"sha": "ee65a636b38c5aa4d2640074d7887bc82ee7b4f5", "filename": "src/docs/implicit_return.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_return.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_return.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_return.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for missing return statements at the end of a block.\n+\n+### Why is this bad?\n+Actually omitting the return keyword is idiomatic Rust code. Programmers\n+coming from other languages might prefer the expressiveness of `return`. It's possible to miss\n+the last returning statement because the only difference is a missing `;`. Especially in bigger\n+code with multiple return paths having a `return` keyword makes it easier to find the\n+corresponding statements.\n+\n+### Example\n+```\n+fn foo(x: usize) -> usize {\n+    x\n+}\n+```\n+add return\n+```\n+fn foo(x: usize) -> usize {\n+    return x;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "03b47905a2118dc9e267293da15fed814ddabc42", "filename": "src/docs/implicit_saturating_sub.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_saturating_sub.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimplicit_saturating_sub.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimplicit_saturating_sub.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for implicit saturating subtraction.\n+\n+### Why is this bad?\n+Simplicity and readability. Instead we can easily use an builtin function.\n+\n+### Example\n+```\n+let mut i: u32 = end - start;\n+\n+if i != 0 {\n+    i -= 1;\n+}\n+```\n+\n+Use instead:\n+```\n+let mut i: u32 = end - start;\n+\n+i = i.saturating_sub(1);\n+```\n\\ No newline at end of file"}, {"sha": "e84d81cea98e0b70abb9cfb7e93e7c95d526bf28", "filename": "src/docs/imprecise_flops.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimprecise_flops.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fimprecise_flops.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fimprecise_flops.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Looks for floating-point expressions that\n+can be expressed using built-in methods to improve accuracy\n+at the cost of performance.\n+\n+### Why is this bad?\n+Negatively impacts accuracy.\n+\n+### Example\n+```\n+let a = 3f32;\n+let _ = a.powf(1.0 / 3.0);\n+let _ = (1.0 + a).ln();\n+let _ = a.exp() - 1.0;\n+```\n+\n+Use instead:\n+```\n+let a = 3f32;\n+let _ = a.cbrt();\n+let _ = a.ln_1p();\n+let _ = a.exp_m1();\n+```\n\\ No newline at end of file"}, {"sha": "aa0b072de1c4080303ccfe7f86ae3e07e3cde095", "filename": "src/docs/inconsistent_digit_grouping.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finconsistent_digit_grouping.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finconsistent_digit_grouping.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finconsistent_digit_grouping.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Warns if an integral or floating-point constant is\n+grouped inconsistently with underscores.\n+\n+### Why is this bad?\n+Readers may incorrectly interpret inconsistently\n+grouped digits.\n+\n+### Example\n+```\n+618_64_9189_73_511\n+```\n+\n+Use instead:\n+```\n+61_864_918_973_511\n+```\n\\ No newline at end of file"}, {"sha": "eb682109a54ee74cec3f50cf35b13600f8c534a2", "filename": "src/docs/inconsistent_struct_constructor.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finconsistent_struct_constructor.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finconsistent_struct_constructor.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finconsistent_struct_constructor.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,40 @@\n+### What it does\n+Checks for struct constructors where all fields are shorthand and\n+the order of the field init shorthand in the constructor is inconsistent\n+with the order in the struct definition.\n+\n+### Why is this bad?\n+Since the order of fields in a constructor doesn't affect the\n+resulted instance as the below example indicates,\n+\n+```\n+#[derive(Debug, PartialEq, Eq)]\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+let x = 1;\n+let y = 2;\n+\n+// This assertion never fails:\n+assert_eq!(Foo { x, y }, Foo { y, x });\n+```\n+\n+inconsistent order can be confusing and decreases readability and consistency.\n+\n+### Example\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+let x = 1;\n+let y = 2;\n+\n+Foo { y, x };\n+```\n+\n+Use instead:\n+```\n+Foo { x, y };\n+```\n\\ No newline at end of file"}, {"sha": "8a7d52761af816657c32bee2884c333b81b153e1", "filename": "src/docs/index_refutable_slice.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Findex_refutable_slice.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Findex_refutable_slice.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Findex_refutable_slice.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+The lint checks for slice bindings in patterns that are only used to\n+access individual slice values.\n+\n+### Why is this bad?\n+Accessing slice values using indices can lead to panics. Using refutable\n+patterns can avoid these. Binding to individual values also improves the\n+readability as they can be named.\n+\n+### Limitations\n+This lint currently only checks for immutable access inside `if let`\n+patterns.\n+\n+### Example\n+```\n+let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+\n+if let Some(slice) = slice {\n+    println!(\"{}\", slice[0]);\n+}\n+```\n+Use instead:\n+```\n+let slice: Option<&[u32]> = Some(&[1, 2, 3]);\n+\n+if let Some(&[first, ..]) = slice {\n+    println!(\"{}\", first);\n+}\n+```\n\\ No newline at end of file"}, {"sha": "76ca6ed318b38b88ecbe7320e2c9c5d7eff761c3", "filename": "src/docs/indexing_slicing.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Findexing_slicing.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Findexing_slicing.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Findexing_slicing.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,33 @@\n+### What it does\n+Checks for usage of indexing or slicing. Arrays are special cases, this lint\n+does report on arrays if we can tell that slicing operations are in bounds and does not\n+lint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n+\n+### Why is this bad?\n+Indexing and slicing can panic at runtime and there are\n+safe alternatives.\n+\n+### Example\n+```\n+// Vector\n+let x = vec![0; 5];\n+\n+x[2];\n+&x[2..100];\n+\n+// Array\n+let y = [0, 1, 2, 3];\n+\n+&y[10..100];\n+&y[10..];\n+```\n+\n+Use instead:\n+```\n+\n+x.get(2);\n+x.get(2..100);\n+\n+y.get(10);\n+y.get(10..100);\n+```\n\\ No newline at end of file"}, {"sha": "f6e7ef556215b891e29665cb7f080ed4cdab315c", "filename": "src/docs/ineffective_bit_mask.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fineffective_bit_mask.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fineffective_bit_mask.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fineffective_bit_mask.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+Checks for bit masks in comparisons which can be removed\n+without changing the outcome. The basic structure can be seen in the\n+following table:\n+\n+|Comparison| Bit Op   |Example     |equals |\n+|----------|----------|------------|-------|\n+|`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n+|`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n+\n+### Why is this bad?\n+Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+but still a bit misleading, because the bit mask is ineffective.\n+\n+### Known problems\n+False negatives: This lint will only match instances\n+where we have figured out the math (which is for a power-of-two compared\n+value). This means things like `x | 1 >= 7` (which would be better written\n+as `x >= 6`) will not be reported (but bit masks like this are fairly\n+uncommon).\n+\n+### Example\n+```\n+if (x | 1 > 3) {  }\n+```\n\\ No newline at end of file"}, {"sha": "f7061d1ce7b082c10f14302b673f5b5d783c1669", "filename": "src/docs/inefficient_to_string.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finefficient_to_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finefficient_to_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finefficient_to_string.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for usage of `.to_string()` on an `&&T` where\n+`T` implements `ToString` directly (like `&&str` or `&&String`).\n+\n+### Why is this bad?\n+This bypasses the specialized implementation of\n+`ToString` and instead goes through the more expensive string formatting\n+facilities.\n+\n+### Example\n+```\n+// Generic implementation for `T: Display` is used (slow)\n+[\"foo\", \"bar\"].iter().map(|s| s.to_string());\n+\n+// OK, the specialized impl is used\n+[\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n+```\n\\ No newline at end of file"}, {"sha": "4b5d3c4ba6c40c1b0657fa0195b977bacdb09453", "filename": "src/docs/infallible_destructuring_match.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finfallible_destructuring_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finfallible_destructuring_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finfallible_destructuring_match.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for matches being used to destructure a single-variant enum\n+or tuple struct where a `let` will suffice.\n+\n+### Why is this bad?\n+Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+\n+### Example\n+```\n+enum Wrapper {\n+    Data(i32),\n+}\n+\n+let wrapper = Wrapper::Data(42);\n+\n+let data = match wrapper {\n+    Wrapper::Data(i) => i,\n+};\n+```\n+\n+The correct use would be:\n+```\n+enum Wrapper {\n+    Data(i32),\n+}\n+\n+let wrapper = Wrapper::Data(42);\n+let Wrapper::Data(data) = wrapper;\n+```\n\\ No newline at end of file"}, {"sha": "8a22fabc5492c4f87689a75dbe149dafba04951a", "filename": "src/docs/infinite_iter.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finfinite_iter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finfinite_iter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finfinite_iter.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for iteration that is guaranteed to be infinite.\n+\n+### Why is this bad?\n+While there may be places where this is acceptable\n+(e.g., in event streams), in most cases this is simply an error.\n+\n+### Example\n+```\n+use std::iter;\n+\n+iter::repeat(1_u8).collect::<Vec<_>>();\n+```\n\\ No newline at end of file"}, {"sha": "b18e600e9e67b056254eb92a07fec2dd9bd34faa", "filename": "src/docs/inherent_to_string.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finherent_to_string.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finherent_to_string.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finherent_to_string.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for the definition of inherent methods with a signature of `to_string(&self) -> String`.\n+\n+### Why is this bad?\n+This method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred.\n+\n+### Example\n+```\n+pub struct A;\n+\n+impl A {\n+    pub fn to_string(&self) -> String {\n+        \"I am A\".to_string()\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A\")\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a4bd0b622c4f5833f59494a7999cd2d44d64a301", "filename": "src/docs/inherent_to_string_shadow_display.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finherent_to_string_shadow_display.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finherent_to_string_shadow_display.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finherent_to_string_shadow_display.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,37 @@\n+### What it does\n+Checks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.\n+\n+### Why is this bad?\n+This method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`.\n+\n+### Example\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl A {\n+    pub fn to_string(&self) -> String {\n+        \"I am A\".to_string()\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A, too\")\n+    }\n+}\n+```\n+\n+Use instead:\n+```\n+use std::fmt;\n+\n+pub struct A;\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"I am A\")\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "ba40af6a5fa555df8eb9843ed1bc9202711ad1e0", "filename": "src/docs/init_numbered_fields.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finit_numbered_fields.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finit_numbered_fields.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finit_numbered_fields.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for tuple structs initialized with field syntax.\n+It will however not lint if a base initializer is present.\n+The lint will also ignore code in macros.\n+\n+### Why is this bad?\n+This may be confusing to the uninitiated and adds no\n+benefit as opposed to tuple initializers\n+\n+### Example\n+```\n+struct TupleStruct(u8, u16);\n+\n+let _ = TupleStruct {\n+    0: 1,\n+    1: 23,\n+};\n+\n+// should be written as\n+let base = TupleStruct(1, 23);\n+\n+// This is OK however\n+let _ = TupleStruct { 0: 42, ..base };\n+```\n\\ No newline at end of file"}, {"sha": "7721da4c4cc71a26c26b6db49ef11516610c416c", "filename": "src/docs/inline_always.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_always.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_always.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_always.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for items annotated with `#[inline(always)]`,\n+unless the annotated function is empty or simply panics.\n+\n+### Why is this bad?\n+While there are valid uses of this annotation (and once\n+you know when to use it, by all means `allow` this lint), it's a common\n+newbie-mistake to pepper one's code with it.\n+\n+As a rule of thumb, before slapping `#[inline(always)]` on a function,\n+measure if that additional function call really affects your runtime profile\n+sufficiently to make up for the increase in compile time.\n+\n+### Known problems\n+False positives, big time. This lint is meant to be\n+deactivated by everyone doing serious performance work. This means having\n+done the measurement.\n+\n+### Example\n+```\n+#[inline(always)]\n+fn not_quite_hot_code(..) { ... }\n+```\n\\ No newline at end of file"}, {"sha": "8eb49d122d89962e0e09afa804554b4eb94e7552", "filename": "src/docs/inline_asm_x86_att_syntax.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_asm_x86_att_syntax.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_asm_x86_att_syntax.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_asm_x86_att_syntax.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of AT&T x86 assembly syntax.\n+\n+### Why is this bad?\n+The lint has been enabled to indicate a preference\n+for Intel x86 assembly syntax.\n+\n+### Example\n+\n+```\n+asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n+```\n+Use instead:\n+```\n+asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n+```\n\\ No newline at end of file"}, {"sha": "5aa22c8ed235780c05515903fa8119d0e5e2465d", "filename": "src/docs/inline_asm_x86_intel_syntax.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_asm_x86_intel_syntax.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of Intel x86 assembly syntax.\n+\n+### Why is this bad?\n+The lint has been enabled to indicate a preference\n+for AT&T x86 assembly syntax.\n+\n+### Example\n+\n+```\n+asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n+```\n+Use instead:\n+```\n+asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n+```\n\\ No newline at end of file"}, {"sha": "127c161aaa25063e2f3f7fc89a602a2cb743c810", "filename": "src/docs/inline_fn_without_body.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_fn_without_body.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finline_fn_without_body.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finline_fn_without_body.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks for `#[inline]` on trait methods without bodies\n+\n+### Why is this bad?\n+Only implementations of trait methods may be inlined.\n+The inline attribute is ignored for trait methods without bodies.\n+\n+### Example\n+```\n+trait Animal {\n+    #[inline]\n+    fn name(&self) -> &'static str;\n+}\n+```\n\\ No newline at end of file"}, {"sha": "01a46d6c451f4536989dd60becd9d42536cbfa96", "filename": "src/docs/inspect_for_each.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finspect_for_each.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finspect_for_each.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finspect_for_each.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,23 @@\n+### What it does\n+Checks for usage of `inspect().for_each()`.\n+\n+### Why is this bad?\n+It is the same as performing the computation\n+inside `inspect` at the beginning of the closure in `for_each`.\n+\n+### Example\n+```\n+[1,2,3,4,5].iter()\n+.inspect(|&x| println!(\"inspect the number: {}\", x))\n+.for_each(|&x| {\n+    assert!(x >= 0);\n+});\n+```\n+Can be written as\n+```\n+[1,2,3,4,5].iter()\n+.for_each(|&x| {\n+    println!(\"inspect the number: {}\", x);\n+    assert!(x >= 0);\n+});\n+```\n\\ No newline at end of file"}, {"sha": "1b68f3eeb64b44f709db8fdb51c607ebf4552ca1", "filename": "src/docs/int_plus_one.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fint_plus_one.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fint_plus_one.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fint_plus_one.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n+\n+### Why is this bad?\n+Readability -- better to use `> y` instead of `>= y + 1`.\n+\n+### Example\n+```\n+if x >= y + 1 {}\n+```\n+\n+Use instead:\n+```\n+if x > y {}\n+```\n\\ No newline at end of file"}, {"sha": "ea57a2ef97bf5e0ca5c61aae77d878c22d41ed28", "filename": "src/docs/integer_arithmetic.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finteger_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finteger_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finteger_arithmetic.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for integer arithmetic operations which could overflow or panic.\n+\n+Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+of overflowing according to the [Rust\n+Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+attempted.\n+\n+### Why is this bad?\n+Integer overflow will trigger a panic in debug builds or will wrap in\n+release mode. Division by zero will cause a panic in either mode. In some applications one\n+wants explicitly checked, wrapping or saturating arithmetic.\n+\n+### Example\n+```\n+a + 1;\n+```\n\\ No newline at end of file"}, {"sha": "f6d3349810ed86f7e0b7b07fa2a0d61e6b450250", "filename": "src/docs/integer_division.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finteger_division.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finteger_division.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finteger_division.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for division of integers\n+\n+### Why is this bad?\n+When outside of some very specific algorithms,\n+integer division is very often a mistake because it discards the\n+remainder.\n+\n+### Example\n+```\n+let x = 3 / 2;\n+println!(\"{}\", x);\n+```\n+\n+Use instead:\n+```\n+let x = 3f32 / 2f32;\n+println!(\"{}\", x);\n+```\n\\ No newline at end of file"}, {"sha": "acb6bd474ebf31bbc3d1954d9f293d261d43b7ad", "filename": "src/docs/into_iter_on_ref.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finto_iter_on_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finto_iter_on_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finto_iter_on_ref.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for `into_iter` calls on references which should be replaced by `iter`\n+or `iter_mut`.\n+\n+### Why is this bad?\n+Readability. Calling `into_iter` on a reference will not move out its\n+content into the resulting iterator, which is confusing. It is better just call `iter` or\n+`iter_mut` directly.\n+\n+### Example\n+```\n+(&vec).into_iter();\n+```\n+\n+Use instead:\n+```\n+(&vec).iter();\n+```\n\\ No newline at end of file"}, {"sha": "6fb3fa3f83d6672fa5cc8f84b418b2a0a484b42f", "filename": "src/docs/invalid_null_ptr_usage.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_null_ptr_usage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_null_ptr_usage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_null_ptr_usage.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+This lint checks for invalid usages of `ptr::null`.\n+\n+### Why is this bad?\n+This causes undefined behavior.\n+\n+### Example\n+```\n+// Undefined behavior\n+unsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n+```\n+\n+Use instead:\n+```\n+unsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n+```\n\\ No newline at end of file"}, {"sha": "6c9969b6e1a335a8672de9d225ccf60d497d3308", "filename": "src/docs/invalid_regex.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_regex.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_regex.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_regex.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks [regex](https://crates.io/crates/regex) creation\n+(with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`) for correct\n+regex syntax.\n+\n+### Why is this bad?\n+This will lead to a runtime panic.\n+\n+### Example\n+```\n+Regex::new(\"(\")\n+```\n\\ No newline at end of file"}, {"sha": "77cb033080372924a3e379db7da01212cc265c6e", "filename": "src/docs/invalid_upcast_comparisons.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_upcast_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_upcast_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_upcast_comparisons.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for comparisons where the relation is always either\n+true or false, but where one side has been upcast so that the comparison is\n+necessary. Only integer types are checked.\n+\n+### Why is this bad?\n+An expression like `let x : u8 = ...; (x as u32) > 300`\n+will mistakenly imply that it is possible for `x` to be outside the range of\n+`u8`.\n+\n+### Known problems\n+https://github.com/rust-lang/rust-clippy/issues/886\n+\n+### Example\n+```\n+let x: u8 = 1;\n+(x as u32) > 300;\n+```\n\\ No newline at end of file"}, {"sha": "afb5acbe9c51cf079e6498acd2bba609712a239b", "filename": "src/docs/invalid_utf8_in_unchecked.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvalid_utf8_in_unchecked.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Checks for `std::str::from_utf8_unchecked` with an invalid UTF-8 literal\n+\n+### Why is this bad?\n+Creating such a `str` would result in undefined behavior\n+\n+### Example\n+```\n+unsafe {\n+    std::str::from_utf8_unchecked(b\"cl\\x82ippy\");\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3dda380911f91589d5b496967bb64b21badf592d", "filename": "src/docs/invisible_characters.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvisible_characters.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Finvisible_characters.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Finvisible_characters.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,10 @@\n+### What it does\n+Checks for invisible Unicode characters in the code.\n+\n+### Why is this bad?\n+Having an invisible character in the code makes for all\n+sorts of April fools, but otherwise is very much frowned upon.\n+\n+### Example\n+You don't see it, but there may be a zero-width space or soft hyphen\n+some\u00adwhere in this text.\n\\ No newline at end of file"}, {"sha": "9f11cf43054feddbe543d066c02597c7f392d233", "filename": "src/docs/is_digit_ascii_radix.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fis_digit_ascii_radix.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fis_digit_ascii_radix.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fis_digit_ascii_radix.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Finds usages of [`char::is_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\n+can be replaced with [`is_ascii_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n+[`is_ascii_hexdigit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).\n+\n+### Why is this bad?\n+`is_digit(..)` is slower and requires specifying the radix.\n+\n+### Example\n+```\n+let c: char = '6';\n+c.is_digit(10);\n+c.is_digit(16);\n+```\n+Use instead:\n+```\n+let c: char = '6';\n+c.is_ascii_digit();\n+c.is_ascii_hexdigit();\n+```\n\\ No newline at end of file"}, {"sha": "6fdfff50d20e40844dfd35f78c55b945b9af6661", "filename": "src/docs/items_after_statements.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fitems_after_statements.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fitems_after_statements.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fitems_after_statements.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,37 @@\n+### What it does\n+Checks for items declared after some statement in a block.\n+\n+### Why is this bad?\n+Items live for the entire scope they are declared\n+in. But statements are processed in order. This might cause confusion as\n+it's hard to figure out which item is meant in a statement.\n+\n+### Example\n+```\n+fn foo() {\n+    println!(\"cake\");\n+}\n+\n+fn main() {\n+    foo(); // prints \"foo\"\n+    fn foo() {\n+        println!(\"foo\");\n+    }\n+    foo(); // prints \"foo\"\n+}\n+```\n+\n+Use instead:\n+```\n+fn foo() {\n+    println!(\"cake\");\n+}\n+\n+fn main() {\n+    fn foo() {\n+        println!(\"foo\");\n+    }\n+    foo(); // prints \"foo\"\n+    foo(); // prints \"foo\"\n+}\n+```\n\\ No newline at end of file"}, {"sha": "90dc9ebb40f0b595825eb718cd380c1603613f69", "filename": "src/docs/iter_cloned_collect.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_cloned_collect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_cloned_collect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_cloned_collect.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for the use of `.cloned().collect()` on slice to\n+create a `Vec`.\n+\n+### Why is this bad?\n+`.to_vec()` is clearer\n+\n+### Example\n+```\n+let s = [1, 2, 3, 4, 5];\n+let s2: Vec<isize> = s[..].iter().cloned().collect();\n+```\n+The better use would be:\n+```\n+let s = [1, 2, 3, 4, 5];\n+let s2: Vec<isize> = s.to_vec();\n+```\n\\ No newline at end of file"}, {"sha": "f3db4a26c2997f42ab673bf3112c6e1a448031f6", "filename": "src/docs/iter_count.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_count.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_count.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_count.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for the use of `.iter().count()`.\n+\n+### Why is this bad?\n+`.len()` is more efficient and more\n+readable.\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+\n+some_vec.iter().count();\n+&some_vec[..].iter().count();\n+```\n+\n+Use instead:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+\n+some_vec.len();\n+&some_vec[..].len();\n+```\n\\ No newline at end of file"}, {"sha": "b33eb39d6e1d37529ed4969f94d4cf2c107d5042", "filename": "src/docs/iter_next_loop.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_next_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_next_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_next_loop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for loops on `x.next()`.\n+\n+### Why is this bad?\n+`next()` returns either `Some(value)` if there was a\n+value, or `None` otherwise. The insidious thing is that `Option<_>`\n+implements `IntoIterator`, so that possibly one value will be iterated,\n+leading to some hard to find bugs. No one will want to write such code\n+[except to win an Underhanded Rust\n+Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+\n+### Example\n+```\n+for x in y.next() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "1cea25eaf3017a7d5f6b8024ac886cad194182e2", "filename": "src/docs/iter_next_slice.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_next_slice.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_next_slice.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_next_slice.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for usage of `iter().next()` on a Slice or an Array\n+\n+### Why is this bad?\n+These can be shortened into `.get()`\n+\n+### Example\n+```\n+a[2..].iter().next();\n+b.iter().next();\n+```\n+should be written as:\n+```\n+a.get(2);\n+b.get(0);\n+```\n\\ No newline at end of file"}, {"sha": "0ca862910a6f072a8199956be2a29db0ecfdc13d", "filename": "src/docs/iter_not_returning_iterator.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_not_returning_iterator.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_not_returning_iterator.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_not_returning_iterator.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,26 @@\n+### What it does\n+Detects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\n+\n+### Why is this bad?\n+Methods named `iter` or `iter_mut` conventionally return an `Iterator`.\n+\n+### Example\n+```\n+// `String` does not implement `Iterator`\n+struct Data {}\n+impl Data {\n+    fn iter(&self) -> String {\n+        todo!()\n+    }\n+}\n+```\n+Use instead:\n+```\n+use std::str::Chars;\n+struct Data {}\n+impl Data {\n+   fn iter(&self) -> Chars<'static> {\n+       todo!()\n+   }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "3d67d583ffde387ca67137aec43d074eeccdfb92", "filename": "src/docs/iter_nth.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_nth.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_nth.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_nth.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,20 @@\n+### What it does\n+Checks for use of `.iter().nth()` (and the related\n+`.iter_mut().nth()`) on standard library types with *O*(1) element access.\n+\n+### Why is this bad?\n+`.get()` and `.get_mut()` are more efficient and more\n+readable.\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().nth(3);\n+let bad_slice = &some_vec[..].iter().nth(3);\n+```\n+The correct use would be:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.get(3);\n+let bad_slice = &some_vec[..].get(3);\n+```\n\\ No newline at end of file"}, {"sha": "8efe47a16a100ab2b193b58f1a7d52747b3a2e57", "filename": "src/docs/iter_nth_zero.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_nth_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_nth_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_nth_zero.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for the use of `iter.nth(0)`.\n+\n+### Why is this bad?\n+`iter.next()` is equivalent to\n+`iter.nth(0)`, as they both consume the next element,\n+ but is more readable.\n+\n+### Example\n+```\n+let x = s.iter().nth(0);\n+```\n+\n+Use instead:\n+```\n+let x = s.iter().next();\n+```\n\\ No newline at end of file"}, {"sha": "87c4ec12afae71b4592015e135452701cf64f0c1", "filename": "src/docs/iter_on_empty_collections.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_on_empty_collections.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_on_empty_collections.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_on_empty_collections.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,25 @@\n+### What it does\n+\n+Checks for calls to `iter`, `iter_mut` or `into_iter` on empty collections\n+\n+### Why is this bad?\n+\n+It is simpler to use the empty function from the standard library:\n+\n+### Example\n+\n+```\n+use std::{slice, option};\n+let a: slice::Iter<i32> = [].iter();\n+let f: option::IntoIter<i32> = None.into_iter();\n+```\n+Use instead:\n+```\n+use std::iter;\n+let a: iter::Empty<i32> = iter::empty();\n+let b: iter::Empty<i32> = iter::empty();\n+```\n+\n+### Known problems\n+\n+The type of the resulting iterator might become incompatible with its usage\n\\ No newline at end of file"}, {"sha": "d0388f25d045e709a953550443b5fe6feac8a119", "filename": "src/docs/iter_on_single_items.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_on_single_items.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_on_single_items.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_on_single_items.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+\n+Checks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item\n+\n+### Why is this bad?\n+\n+It is simpler to use the once function from the standard library:\n+\n+### Example\n+\n+```\n+let a = [123].iter();\n+let b = Some(123).into_iter();\n+```\n+Use instead:\n+```\n+use std::iter;\n+let a = iter::once(&123);\n+let b = iter::once(123);\n+```\n+\n+### Known problems\n+\n+The type of the resulting iterator might become incompatible with its usage\n\\ No newline at end of file"}, {"sha": "2f902a0c2db4d1c6295ef59e3a05f977eb07377e", "filename": "src/docs/iter_overeager_cloned.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_overeager_cloned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_overeager_cloned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_overeager_cloned.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,22 @@\n+### What it does\n+Checks for usage of `_.cloned().<func>()` where call to `.cloned()` can be postponed.\n+\n+### Why is this bad?\n+It's often inefficient to clone all elements of an iterator, when eventually, only some\n+of them will be consumed.\n+\n+### Known Problems\n+This `lint` removes the side of effect of cloning items in the iterator.\n+A code that relies on that side-effect could fail.\n+\n+### Examples\n+```\n+vec.iter().cloned().take(10);\n+vec.iter().cloned().last();\n+```\n+\n+Use instead:\n+```\n+vec.iter().take(10).cloned();\n+vec.iter().last().cloned();\n+```\n\\ No newline at end of file"}, {"sha": "da226b041cf23aaa89e417a05505015fc472a1e8", "filename": "src/docs/iter_skip_next.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_skip_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_skip_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_skip_next.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,18 @@\n+### What it does\n+Checks for use of `.skip(x).next()` on iterators.\n+\n+### Why is this bad?\n+`.nth(x)` is cleaner\n+\n+### Example\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().skip(3).next();\n+let bad_slice = &some_vec[..].iter().skip(3).next();\n+```\n+The correct use would be:\n+```\n+let some_vec = vec![0, 1, 2, 3];\n+let bad_vec = some_vec.iter().nth(3);\n+let bad_slice = &some_vec[..].iter().nth(3);\n+```\n\\ No newline at end of file"}, {"sha": "2c52b99f7a5c5aceb533a8c43ba3594054767a20", "filename": "src/docs/iter_with_drain.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_with_drain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiter_with_drain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiter_with_drain.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,16 @@\n+### What it does\n+Checks for use of `.drain(..)` on `Vec` and `VecDeque` for iteration.\n+\n+### Why is this bad?\n+`.into_iter()` is simpler with better performance.\n+\n+### Example\n+```\n+let mut foo = vec![0, 1, 2, 3];\n+let bar: HashSet<usize> = foo.drain(..).collect();\n+```\n+Use instead:\n+```\n+let foo = vec![0, 1, 2, 3];\n+let bar: HashSet<usize> = foo.into_iter().collect();\n+```\n\\ No newline at end of file"}, {"sha": "73ecc99acfcbcb53b8328d4f8f4ce551313dc9d1", "filename": "src/docs/iterator_step_by_zero.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiterator_step_by_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fiterator_step_by_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fiterator_step_by_zero.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,13 @@\n+### What it does\n+Checks for calling `.step_by(0)` on iterators which panics.\n+\n+### Why is this bad?\n+This very much looks like an oversight. Use `panic!()` instead if you\n+actually intend to panic.\n+\n+### Example\n+```\n+for x in (0..100).step_by(0) {\n+    //..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "a8790bcf25be6175547827c0908cd0bce21616ad", "filename": "src/docs/just_underscores_and_digits.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fjust_underscores_and_digits.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Fjust_underscores_and_digits.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fjust_underscores_and_digits.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,14 @@\n+### What it does\n+Checks if you have variables whose name consists of just\n+underscores and digits.\n+\n+### Why is this bad?\n+It's hard to memorize what a variable means without a\n+descriptive name.\n+\n+### Example\n+```\n+let _1 = 1;\n+let ___1 = 1;\n+let __1___2 = 11;\n+```\n\\ No newline at end of file"}, {"sha": "71f67854f2a1afcd3dc1bb0e961000ca3059e8f3", "filename": "src/docs/large_const_arrays.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_const_arrays.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_const_arrays.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_const_arrays.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,17 @@\n+### What it does\n+Checks for large `const` arrays that should\n+be defined as `static` instead.\n+\n+### Why is this bad?\n+Performance: const variables are inlined upon use.\n+Static items result in only one instance and has a fixed location in memory.\n+\n+### Example\n+```\n+pub const a = [0u32; 1_000_000];\n+```\n+\n+Use instead:\n+```\n+pub static a = [0u32; 1_000_000];\n+```\n\\ No newline at end of file"}, {"sha": "f60b19345af44e86e6f74564c80d17d654f9311b", "filename": "src/docs/large_digit_groups.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_digit_groups.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_digit_groups.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_digit_groups.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,12 @@\n+### What it does\n+Warns if the digits of an integral or floating-point\n+constant are grouped into groups that\n+are too large.\n+\n+### Why is this bad?\n+Negatively impacts readability.\n+\n+### Example\n+```\n+let x: u64 = 6186491_8973511;\n+```\n\\ No newline at end of file"}, {"sha": "1f95430790d292b8fc2a574417597921bcac0acf", "filename": "src/docs/large_enum_variant.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_enum_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_enum_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_enum_variant.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,41 @@\n+### What it does\n+Checks for large size differences between variants on\n+`enum`s.\n+\n+### Why is this bad?\n+Enum size is bounded by the largest variant. Having one\n+large variant can penalize the memory layout of that enum.\n+\n+### Known problems\n+This lint obviously cannot take the distribution of\n+variants in your running program into account. It is possible that the\n+smaller variants make up less than 1% of all instances, in which case\n+the overhead is negligible and the boxing is counter-productive. Always\n+measure the change this lint suggests.\n+\n+For types that implement `Copy`, the suggestion to `Box` a variant's\n+data would require removing the trait impl. The types can of course\n+still be `Clone`, but that is worse ergonomically. Depending on the\n+use case it may be possible to store the large data in an auxiliary\n+structure (e.g. Arena or ECS).\n+\n+The lint will ignore the impact of generic types to the type layout by\n+assuming every type parameter is zero-sized. Depending on your use case,\n+this may lead to a false positive.\n+\n+### Example\n+```\n+enum Test {\n+    A(i32),\n+    B([i32; 8000]),\n+}\n+```\n+\n+Use instead:\n+```\n+// Possibly better\n+enum Test2 {\n+    A(i32),\n+    B(Box<[i32; 8000]>),\n+}\n+```\n\\ No newline at end of file"}, {"sha": "b2a54bd2eb5ca0f8f5ab0ffdc43e25e89ea58acb", "filename": "src/docs/large_include_file.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_include_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_include_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_include_file.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for the inclusion of large files via `include_bytes!()`\n+and `include_str!()`\n+\n+### Why is this bad?\n+Including large files can increase the size of the binary\n+\n+### Example\n+```\n+let included_str = include_str!(\"very_large_file.txt\");\n+let included_bytes = include_bytes!(\"very_large_file.txt\");\n+```\n+\n+Use instead:\n+```\n+use std::fs;\n+\n+// You can load the file at runtime\n+let string = fs::read_to_string(\"very_large_file.txt\")?;\n+let bytes = fs::read(\"very_large_file.txt\")?;\n+```\n\\ No newline at end of file"}, {"sha": "4a6f34785b0ef802748ff039f44578ff4dda2ea4", "filename": "src/docs/large_stack_arrays.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_stack_arrays.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_stack_arrays.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_stack_arrays.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,10 @@\n+### What it does\n+Checks for local arrays that may be too large.\n+\n+### Why is this bad?\n+Large local arrays may cause stack overflow.\n+\n+### Example\n+```\n+let a = [0u32; 1_000_000];\n+```\n\\ No newline at end of file"}, {"sha": "bca07f3ac61bbe56b2916ba79e839cad046d9b4a", "filename": "src/docs/large_types_passed_by_value.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_types_passed_by_value.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flarge_types_passed_by_value.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flarge_types_passed_by_value.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Checks for functions taking arguments by value, where\n+the argument type is `Copy` and large enough to be worth considering\n+passing by reference. Does not trigger if the function is being exported,\n+because that might induce API breakage, if the parameter is declared as mutable,\n+or if the argument is a `self`.\n+\n+### Why is this bad?\n+Arguments passed by value might result in an unnecessary\n+shallow copy, taking up more space in the stack and requiring a call to\n+`memcpy`, which can be expensive.\n+\n+### Example\n+```\n+#[derive(Clone, Copy)]\n+struct TooLarge([u8; 2048]);\n+\n+fn foo(v: TooLarge) {}\n+```\n+\n+Use instead:\n+```\n+fn foo(v: &TooLarge) {}\n+```\n\\ No newline at end of file"}, {"sha": "47a2e8575228542722423914d378f5d4cdbe436f", "filename": "src/docs/len_without_is_empty.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flen_without_is_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flen_without_is_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flen_without_is_empty.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for items that implement `.len()` but not\n+`.is_empty()`.\n+\n+### Why is this bad?\n+It is good custom to have both methods, because for\n+some data structures, asking about the length will be a costly operation,\n+whereas `.is_empty()` can usually answer in constant time. Also it used to\n+lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\n+lint will ignore such entities.\n+\n+### Example\n+```\n+impl X {\n+    pub fn len(&self) -> usize {\n+        ..\n+    }\n+}\n+```\n\\ No newline at end of file"}, {"sha": "664124bd391dfc719ed24e3220e7ee9407e8414d", "filename": "src/docs/len_zero.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flen_zero.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flen_zero.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flen_zero.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,28 @@\n+### What it does\n+Checks for getting the length of something via `.len()`\n+just to compare to zero, and suggests using `.is_empty()` where applicable.\n+\n+### Why is this bad?\n+Some structures can answer `.is_empty()` much faster\n+than calculating their length. So it is good to get into the habit of using\n+`.is_empty()`, and having it is cheap.\n+Besides, it makes the intent clearer than a manual comparison in some contexts.\n+\n+### Example\n+```\n+if x.len() == 0 {\n+    ..\n+}\n+if y.len() != 0 {\n+    ..\n+}\n+```\n+instead use\n+```\n+if x.is_empty() {\n+    ..\n+}\n+if !y.is_empty() {\n+    ..\n+}\n+```\n\\ No newline at end of file"}, {"sha": "eba5a90ddd66c57846806913fd0a81cb024df7ea", "filename": "src/docs/let_and_return.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flet_and_return.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flet_and_return.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_and_return.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for `let`-bindings, which are subsequently\n+returned.\n+\n+### Why is this bad?\n+It is just extraneous code. Remove it to make your code\n+more rusty.\n+\n+### Example\n+```\n+fn foo() -> String {\n+    let x = String::new();\n+    x\n+}\n+```\n+instead, use\n+```\n+fn foo() -> String {\n+    String::new()\n+}\n+```\n\\ No newline at end of file"}, {"sha": "29ce9bf50ce6a61254591e93ee7dadb8a0bfdd9d", "filename": "src/docs/let_underscore_drop.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flet_underscore_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c/src%2Fdocs%2Flet_underscore_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Flet_underscore_drop.txt?ref=98bf99e2f8cf8b357d63a67ce67d5fc5ceef8b3c", "patch": "@@ -0,0 +1,29 @@\n+### What it does\n+Checks for `let _ = <expr>`\n+where expr has a type that implements `Drop`\n+\n+### Why is this bad?\n+This statement immediately drops the initializer\n+expression instead of extending its lifetime to the end of the scope, which\n+is often not intended. To extend the expression's lifetime to the end of the\n+scope, use an underscore-prefixed name instead (i.e. _var). If you want to\n+explicitly drop the expression, `std::mem::drop` conveys your intention\n+better and is less error-prone.\n+\n+### Example\n+```\n+{\n+    let _ = DroppableItem;\n+    //                   ^ dropped here\n+    /* more code */\n+}\n+```\n+\n+Use instead:\n+```\n+{\n+    let _droppable = DroppableItem;\n+    /* more code */\n+    // dropped at end of scope\n+}\n+```\n\\ No newline at end of file"}]}