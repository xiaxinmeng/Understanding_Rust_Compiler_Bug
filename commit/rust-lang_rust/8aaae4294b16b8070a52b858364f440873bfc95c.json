{"sha": "8aaae4294b16b8070a52b858364f440873bfc95c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYWFlNDI5NGIxNmI4MDcwYTUyYjg1ODM2NGY0NDA4NzNiZmM5NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-19T20:15:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-19T20:15:11Z"}, "message": "Auto merge of #59981 - estebank:recover-struct-lit, r=petrochenkov\n\nEmit specific error for struct literal in conditions\n\nFix #59962, fix #51311.", "tree": {"sha": "f5a111e9d7c6f22094470312420842e9de67b423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5a111e9d7c6f22094470312420842e9de67b423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aaae4294b16b8070a52b858364f440873bfc95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aaae4294b16b8070a52b858364f440873bfc95c", "html_url": "https://github.com/rust-lang/rust/commit/8aaae4294b16b8070a52b858364f440873bfc95c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aaae4294b16b8070a52b858364f440873bfc95c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "130dc3e7dac132cf30272ccf4541b512828e2108", "url": "https://api.github.com/repos/rust-lang/rust/commits/130dc3e7dac132cf30272ccf4541b512828e2108", "html_url": "https://github.com/rust-lang/rust/commit/130dc3e7dac132cf30272ccf4541b512828e2108"}, {"sha": "aa393b0cde881c612379d90ca300396cd7ce2e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa393b0cde881c612379d90ca300396cd7ce2e96", "html_url": "https://github.com/rust-lang/rust/commit/aa393b0cde881c612379d90ca300396cd7ce2e96"}], "stats": {"total": 623, "additions": 341, "deletions": 282}, "files": [{"sha": "a2f6d9713f02632fa6c76c3df108330996ea9edb", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -897,8 +897,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n-                        span_bug!(err.span,\n-                            \"err_mutbl with a closure invocation\");\n+                        span_bug!(err.span, \"err_mutbl with a closure invocation\");\n                     }\n                 };\n \n@@ -1096,7 +1095,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             BorrowViolation(euv::MatchDiscriminant) => {\n                 \"cannot borrow data mutably\"\n             }\n-\n             BorrowViolation(euv::ClosureInvocation) => {\n                 is_closure = true;\n                 \"closure invocation\""}, {"sha": "c89c222ad57fce9b8c6c61085fdba9d59d3eb499", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 76, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -240,6 +240,56 @@ impl<'a> Resolver<'a> {\n         (err, candidates)\n     }\n \n+    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n+        // HACK(estebank): find a better way to figure out that this was a\n+        // parser issue where a struct literal is being used on an expression\n+        // where a brace being opened means a block is being started. Look\n+        // ahead for the next text to see if `span` is followed by a `{`.\n+        let sm = self.session.source_map();\n+        let mut sp = span;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        let followed_by_brace = match sm.span_to_snippet(sp) {\n+            Ok(ref snippet) if snippet == \"{\" => true,\n+            _ => false,\n+        };\n+        // In case this could be a struct literal that needs to be surrounded\n+        // by parenthesis, find the appropriate span.\n+        let mut i = 0;\n+        let mut closing_brace = None;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet == \"}\" {\n+                        let sp = span.to(sp);\n+                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                            closing_brace = Some((sp, snippet));\n+                        }\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+            i += 1;\n+            // The bigger the span, the more likely we're incorrect --\n+            // bound it to 100 chars long.\n+            if i > 100 {\n+                break;\n+            }\n+        }\n+        return (followed_by_brace, closing_brace)\n+    }\n+\n     /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n     /// function.\n     /// Returns `true` if able to provide context-dependent help.\n@@ -278,6 +328,39 @@ impl<'a> Resolver<'a> {\n             _ => false,\n         };\n \n+        let mut bad_struct_syntax_suggestion = || {\n+            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+            let mut suggested = false;\n+            match source {\n+                PathSource::Expr(Some(parent)) => {\n+                    suggested = path_sep(err, &parent);\n+                }\n+                PathSource::Expr(None) if followed_by_brace == true => {\n+                    if let Some((sp, snippet)) = closing_brace {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"surround the struct literal with parenthesis\",\n+                            format!(\"({})\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_label(\n+                            span,  // Note the parenthesis surrounding the suggestion below\n+                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                        );\n+                    }\n+                    suggested = true;\n+                },\n+                _ => {}\n+            }\n+            if !suggested {\n+                err.span_label(\n+                    span,\n+                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                );\n+            }\n+        };\n+\n         match (def, source) {\n             (Def::Macro(..), _) => {\n                 err.span_suggestion(\n@@ -331,87 +414,13 @@ impl<'a> Resolver<'a> {\n                         );\n                     }\n                 } else {\n-                    // HACK(estebank): find a better way to figure out that this was a\n-                    // parser issue where a struct literal is being used on an expression\n-                    // where a brace being opened means a block is being started. Look\n-                    // ahead for the next text to see if `span` is followed by a `{`.\n-                    let sm = self.session.source_map();\n-                    let mut sp = span;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                    }\n-                    let followed_by_brace = match sm.span_to_snippet(sp) {\n-                        Ok(ref snippet) if snippet == \"{\" => true,\n-                        _ => false,\n-                    };\n-                    // In case this could be a struct literal that needs to be surrounded\n-                    // by parenthesis, find the appropriate span.\n-                    let mut i = 0;\n-                    let mut closing_brace = None;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet == \"}\" {\n-                                    let sp = span.to(sp);\n-                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                                        closing_brace = Some((sp, snippet));\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                        i += 1;\n-                        // The bigger the span, the more likely we're incorrect --\n-                        // bound it to 100 chars long.\n-                        if i > 100 {\n-                            break;\n-                        }\n-                    }\n-                    match source {\n-                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        }\n-                        PathSource::Expr(None) if followed_by_brace == true => {\n-                            if let Some((sp, snippet)) = closing_brace {\n-                                err.span_suggestion(\n-                                    sp,\n-                                    \"surround the struct literal with parenthesis\",\n-                                    format!(\"({})\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                                );\n-                            }\n-                        },\n-                        _ => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        },\n-                    }\n+                    bad_struct_syntax_suggestion();\n                 }\n             }\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n             (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n-                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n+                bad_struct_syntax_suggestion();\n             }\n             (Def::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);"}, {"sha": "8feab373e710271ca99ad6b55cbc60dd79208667", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -2855,11 +2855,13 @@ impl<'a> Parser<'a> {\n                         let (delim, tts) = self.expect_delimited_token_tree()?;\n                         hi = self.prev_span;\n                         ex = ExprKind::Mac(respan(lo.to(hi), Mac_ { path, tts, delim }));\n-                    } else if self.check(&token::OpenDelim(token::Brace)) &&\n-                              !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL) {\n-                        // This is a struct literal, unless we're prohibited\n-                        // from parsing struct literals here.\n-                        return self.parse_struct_expr(lo, path, attrs);\n+                    } else if self.check(&token::OpenDelim(token::Brace)) {\n+                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n+                            return expr;\n+                        } else {\n+                            hi = path.span;\n+                            ex = ExprKind::Path(None, path);\n+                        }\n                     } else {\n                         hi = path.span;\n                         ex = ExprKind::Path(None, path);\n@@ -2902,6 +2904,47 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    fn maybe_parse_struct_expr(\n+        &mut self,\n+        lo: Span,\n+        path: &ast::Path,\n+        attrs: &ThinVec<Attribute>,\n+    ) -> Option<PResult<'a, P<Expr>>> {\n+        let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+        let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n+            // `{ ident, ` cannot start a block\n+            self.look_ahead(2, |t| t == &token::Comma) ||\n+            self.look_ahead(2, |t| t == &token::Colon) && (\n+                // `{ ident: token, ` cannot start a block\n+                self.look_ahead(4, |t| t == &token::Comma) ||\n+                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`\n+                self.look_ahead(3, |t| !t.can_begin_type())\n+            )\n+        );\n+\n+        if struct_allowed || certainly_not_a_block() {\n+            // This is a struct literal, but we don't can't accept them here\n+            let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n+            if let (Ok(expr), false) = (&expr, struct_allowed) {\n+                let mut err = self.diagnostic().struct_span_err(\n+                    expr.span,\n+                    \"struct literals are not allowed here\",\n+                );\n+                err.multipart_suggestion(\n+                    \"surround the struct literal with parenthesis\",\n+                    vec![\n+                        (lo.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+            }\n+            return Some(expr);\n+        }\n+        None\n+    }\n+\n     fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n                          -> PResult<'a, P<Expr>> {\n         let struct_sp = lo.to(self.prev_span);"}, {"sha": "5080a5e0599875ac88ae0acb9b735d87af6518fd", "filename": "src/test/ui/error-codes/E0423.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Ferror-codes%2FE0423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Ferror-codes%2FE0423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -10,15 +10,13 @@ fn bar() {\n     struct T {}\n \n     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n-    //~^ ERROR E0423\n-    //~|  expected type, found `1`\n+    //~^ ERROR struct literals are not allowed here\n     if T {} == T {} { println!(\"Ok\"); }\n     //~^ ERROR E0423\n     //~| ERROR expected expression, found `==`\n }\n \n fn foo() {\n     for _ in std::ops::Range { start: 0, end: 10 } {}\n-    //~^ ERROR E0423\n-    //~| ERROR expected type, found `0`\n+    //~^ ERROR struct literals are not allowed here\n }"}, {"sha": "5cb7121a0d1c38e0731fddfb569223922d8df9cd", "filename": "src/test/ui/error-codes/E0423.stderr", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,36 +1,28 @@\n-error: expected type, found `1`\n-  --> $DIR/E0423.rs:12:39\n+error: struct literals are not allowed here\n+  --> $DIR/E0423.rs:12:32\n    |\n LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n-   |                                       ^ expecting a type here because of type ascription\n-   |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/E0423.rs:12:36\n+   |                                ^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n    |\n-LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n-   |                                    ^\n-   = help: this might be indicative of a syntax error elsewhere\n+LL |     if let S { x: _x, y: 2 } = (S { x: 1, y: 2 }) { println!(\"Ok\"); }\n+   |                                ^                ^\n \n error: expected expression, found `==`\n-  --> $DIR/E0423.rs:15:13\n+  --> $DIR/E0423.rs:14:13\n    |\n LL |     if T {} == T {} { println!(\"Ok\"); }\n    |             ^^ expected expression\n \n-error: expected type, found `0`\n-  --> $DIR/E0423.rs:21:39\n+error: struct literals are not allowed here\n+  --> $DIR/E0423.rs:20:14\n    |\n LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n-   |                                       ^ expecting a type here because of type ascription\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n    |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/E0423.rs:21:32\n-   |\n-LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n-   |                                ^^^^^\n-   = help: this might be indicative of a syntax error elsewhere\n+LL |     for _ in (std::ops::Range { start: 0, end: 10 }) {}\n+   |              ^                                     ^\n \n error[E0423]: expected function, found struct `Foo`\n   --> $DIR/E0423.rs:4:13\n@@ -41,30 +33,14 @@ LL |     let f = Foo();\n    |             did you mean `Foo { /* fields */ }`?\n    |             help: a function with a similar name exists: `foo`\n \n-error[E0423]: expected value, found struct `S`\n-  --> $DIR/E0423.rs:12:32\n-   |\n-LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n-   |                                ^---------------\n-   |                                |\n-   |                                help: surround the struct literal with parenthesis: `(S { x: 1, y: 2 })`\n-\n error[E0423]: expected value, found struct `T`\n-  --> $DIR/E0423.rs:15:8\n+  --> $DIR/E0423.rs:14:8\n    |\n LL |     if T {} == T {} { println!(\"Ok\"); }\n    |        ^---\n    |        |\n    |        help: surround the struct literal with parenthesis: `(T {})`\n \n-error[E0423]: expected value, found struct `std::ops::Range`\n-  --> $DIR/E0423.rs:21:14\n-   |\n-LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n-   |              ^^^^^^^^^^^^^^^----------------------\n-   |              |\n-   |              help: surround the struct literal with parenthesis: `(std::ops::Range { start: 0, end: 10 })`\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0423`."}, {"sha": "3227ae37bfd0520b7451dc69fb371e5619934300", "filename": "src/test/ui/parser/struct-literal-in-for.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -9,9 +9,9 @@ impl Foo {\n }\n \n fn main() {\n-    for x in Foo { //~ ERROR expected value, found struct `Foo`\n-        x: 3    //~ ERROR expected type, found `3`\n-    }.hi() { //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n+    for x in Foo { //~ ERROR struct literals are not allowed here\n+        x: 3       //~^ ERROR `bool` is not an iterator\n+    }.hi() {\n         println!(\"yo\");\n     }\n }"}, {"sha": "3c3f6e7f032f6edb6e8b6812e51c93b65b516492", "filename": "src/test/ui/parser/struct-literal-in-for.stderr", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,29 +1,30 @@\n-error: expected type, found `3`\n-  --> $DIR/struct-literal-in-for.rs:13:12\n-   |\n-LL |         x: 3\n-   |            ^ expecting a type here because of type ascription\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-in-for.rs:12:14\n    |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/struct-literal-in-for.rs:13:9\n+LL |       for x in Foo {\n+   |  ______________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |_____^\n+help: surround the struct literal with parenthesis\n    |\n+LL |     for x in (Foo {\n LL |         x: 3\n-   |         ^\n-   = help: this might be indicative of a syntax error elsewhere\n-\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-  --> $DIR/struct-literal-in-for.rs:14:12\n+LL |     }).hi() {\n    |\n-LL |     }.hi() {\n-   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator here\n \n-error[E0423]: expected value, found struct `Foo`\n+error[E0277]: `bool` is not an iterator\n   --> $DIR/struct-literal-in-for.rs:12:14\n    |\n-LL |     for x in Foo {\n-   |              ^^^ did you mean `(Foo { /* fields */ })`?\n+LL |       for x in Foo {\n+   |  ______________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |__________^ `bool` is not an iterator\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `bool`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0423`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2ce2c8f189944d5441383d4b27c8047360bb7eae", "filename": "src/test/ui/parser/struct-literal-in-if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -9,9 +9,9 @@ impl Foo {\n }\n \n fn main() {\n-    if Foo { //~ ERROR expected value, found struct `Foo`\n-        x: 3    //~ ERROR expected type, found `3`\n-    }.hi() { //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n+    if Foo { //~ ERROR struct literals are not allowed here\n+        x: 3\n+    }.hi() {\n         println!(\"yo\");\n     }\n }"}, {"sha": "851c495abb4b0cea865e2da2c1cbb624b5c00307", "filename": "src/test/ui/parser/struct-literal-in-if.stderr", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,29 +1,17 @@\n-error: expected type, found `3`\n-  --> $DIR/struct-literal-in-if.rs:13:12\n-   |\n-LL |         x: 3\n-   |            ^ expecting a type here because of type ascription\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-in-if.rs:12:8\n    |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/struct-literal-in-if.rs:13:9\n+LL |       if Foo {\n+   |  ________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |_____^\n+help: surround the struct literal with parenthesis\n    |\n+LL |     if (Foo {\n LL |         x: 3\n-   |         ^\n-   = help: this might be indicative of a syntax error elsewhere\n-\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-  --> $DIR/struct-literal-in-if.rs:14:12\n-   |\n-LL |     }.hi() {\n-   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator here\n-\n-error[E0423]: expected value, found struct `Foo`\n-  --> $DIR/struct-literal-in-if.rs:12:8\n+LL |     }).hi() {\n    |\n-LL |     if Foo {\n-   |        ^^^ did you mean `(Foo { /* fields */ })`?\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0423`."}, {"sha": "ce132df5a888b9fe4fd226232905e951e87f80de", "filename": "src/test/ui/parser/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -3,11 +3,11 @@ struct Foo {\n }\n \n fn main() {\n-    match Foo { //~ ERROR expected value, found struct `Foo`\n-        x: 3    //~ ERROR expected one of `=>`, `@`, `if`, or `|`, found `:`\n+    match Foo { //~ ERROR struct literals are not allowed here\n+        x: 3\n     } {\n-        Foo { //~ ERROR mismatched types\n-            x: x //~ ERROR cannot find value `x` in this scope\n-        } => {} //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n+        Foo {\n+            x: x\n+        } => {}\n     }\n }"}, {"sha": "0058e8981cd25685e98bb3b44290bcef103d0162", "filename": "src/test/ui/parser/struct-literal-in-match-discriminant.stderr", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-match-discriminant.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,42 +1,17 @@\n-error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n-  --> $DIR/struct-literal-in-match-discriminant.rs:7:10\n-   |\n-LL |         x: 3\n-   |          ^ expected one of `=>`, `@`, `if`, or `|` here\n-\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n-  --> $DIR/struct-literal-in-match-discriminant.rs:11:11\n-   |\n-LL |         } => {}\n-   |           ^^ expected one of `.`, `;`, `?`, `}`, or an operator here\n-\n-error[E0423]: expected value, found struct `Foo`\n+error: struct literals are not allowed here\n   --> $DIR/struct-literal-in-match-discriminant.rs:6:11\n    |\n-LL |     match Foo {\n-   |           ^^^ did you mean `(Foo { /* fields */ })`?\n-\n-error[E0425]: cannot find value `x` in this scope\n-  --> $DIR/struct-literal-in-match-discriminant.rs:10:16\n-   |\n-LL |             x: x\n-   |                ^ not found in this scope\n-\n-error[E0308]: mismatched types\n-  --> $DIR/struct-literal-in-match-discriminant.rs:9:9\n+LL |       match Foo {\n+   |  ___________^\n+LL | |         x: 3\n+LL | |     } {\n+   | |_____^\n+help: surround the struct literal with parenthesis\n    |\n-LL |   fn main() {\n-   |             - expected `()` because of default return type\n-...\n-LL | /         Foo {\n-LL | |             x: x\n-LL | |         } => {}\n-   | |_________^ expected (), found struct `Foo`\n+LL |     match (Foo {\n+LL |         x: 3\n+LL |     }) {\n    |\n-   = note: expected type `()`\n-              found type `Foo`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0423, E0425.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "5000ce85b7f7150e08865b7f3078a0b75fd202e2", "filename": "src/test/ui/parser/struct-literal-in-while.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -9,10 +9,9 @@ impl Foo {\n }\n \n fn main() {\n-    while Foo { //~ ERROR expected value, found struct `Foo`\n-        x: 3    //~ ERROR expected type, found `3`\n-    }.hi() { //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-             //~| ERROR no method named `hi` found for type `()` in the current scope\n+    while Foo { //~ ERROR struct literals are not allowed here\n+        x: 3\n+    }.hi() {\n         println!(\"yo\");\n     }\n }"}, {"sha": "9959a57be8596a6d6b43b8b8cad7421121577d2e", "filename": "src/test/ui/parser/struct-literal-in-while.stderr", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,36 +1,17 @@\n-error: expected type, found `3`\n-  --> $DIR/struct-literal-in-while.rs:13:12\n-   |\n-LL |         x: 3\n-   |            ^ expecting a type here because of type ascription\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-in-while.rs:12:11\n    |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/struct-literal-in-while.rs:13:9\n+LL |       while Foo {\n+   |  ___________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |_____^\n+help: surround the struct literal with parenthesis\n    |\n+LL |     while (Foo {\n LL |         x: 3\n-   |         ^\n-   = help: this might be indicative of a syntax error elsewhere\n-\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-  --> $DIR/struct-literal-in-while.rs:14:12\n-   |\n-LL |     }.hi() {\n-   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator here\n-\n-error[E0423]: expected value, found struct `Foo`\n-  --> $DIR/struct-literal-in-while.rs:12:11\n-   |\n-LL |     while Foo {\n-   |           ^^^ did you mean `(Foo { /* fields */ })`?\n-\n-error[E0599]: no method named `hi` found for type `()` in the current scope\n-  --> $DIR/struct-literal-in-while.rs:14:7\n+LL |     }).hi() {\n    |\n-LL |     }.hi() {\n-   |       ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0423, E0599.\n-For more information about an error, try `rustc --explain E0423`."}, {"sha": "e185153dcf62a04c62714d53ec3add473bc04919", "filename": "src/test/ui/parser/struct-literal-restrictions-in-lamda.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -9,10 +9,9 @@ impl Foo {\n }\n \n fn main() {\n-    while || Foo { //~ ERROR expected value, found struct `Foo`\n-        x: 3    //~ ERROR expected type, found `3`\n-    }.hi() { //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-             //~| ERROR no method named `hi` found for type `()` in the current scope\n+    while || Foo { //~ ERROR struct literals are not allowed here\n+        x: 3       //~^ ERROR mismatched types\n+    }.hi() {\n         println!(\"yo\");\n     }\n }"}, {"sha": "81f7a91ddb38ad2ce56c23d8ef5f37b05700b4d5", "filename": "src/test/ui/parser/struct-literal-restrictions-in-lamda.stderr", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -1,36 +1,30 @@\n-error: expected type, found `3`\n-  --> $DIR/struct-literal-restrictions-in-lamda.rs:13:12\n-   |\n-LL |         x: 3\n-   |            ^ expecting a type here because of type ascription\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-restrictions-in-lamda.rs:12:14\n    |\n-   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n-note: this expression expects an ascribed type after the colon\n-  --> $DIR/struct-literal-restrictions-in-lamda.rs:13:9\n+LL |       while || Foo {\n+   |  ______________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |_____^\n+help: surround the struct literal with parenthesis\n    |\n+LL |     while || (Foo {\n LL |         x: 3\n-   |         ^\n-   = help: this might be indicative of a syntax error elsewhere\n-\n-error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n-  --> $DIR/struct-literal-restrictions-in-lamda.rs:14:12\n+LL |     }).hi() {\n    |\n-LL |     }.hi() {\n-   |            ^ expected one of `.`, `;`, `?`, `}`, or an operator here\n \n-error[E0423]: expected value, found struct `Foo`\n-  --> $DIR/struct-literal-restrictions-in-lamda.rs:12:14\n+error[E0308]: mismatched types\n+  --> $DIR/struct-literal-restrictions-in-lamda.rs:12:11\n    |\n-LL |     while || Foo {\n-   |              ^^^ did you mean `(Foo { /* fields */ })`?\n-\n-error[E0599]: no method named `hi` found for type `()` in the current scope\n-  --> $DIR/struct-literal-restrictions-in-lamda.rs:14:7\n+LL |       while || Foo {\n+   |  ___________^\n+LL | |         x: 3\n+LL | |     }.hi() {\n+   | |__________^ expected bool, found closure\n    |\n-LL |     }.hi() {\n-   |       ^^\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/struct-literal-restrictions-in-lamda.rs:12:11: 14:11]`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0423, E0599.\n-For more information about an error, try `rustc --explain E0423`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4ef8effaf1f5f36ec2e33d66c5f8de371b5dd7e6", "filename": "src/test/ui/struct-literal-variant-in-if.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.rs?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -0,0 +1,25 @@\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum E {\n+    V { field: bool },\n+    I { field1: bool, field2: usize },\n+    J { field: isize },\n+    K { field: &'static str},\n+}\n+fn test_E(x: E) {\n+    let field = true;\n+    if x == E::V { field } {}\n+    //~^ ERROR expected value, found struct variant `E::V`\n+    //~| ERROR mismatched types\n+    if x == E::I { field1: true, field2: 42 } {}\n+    //~^ ERROR struct literals are not allowed here\n+    if x == E::V { field: false } {}\n+    //~^ ERROR struct literals are not allowed here\n+    if x == E::J { field: -42 } {}\n+    //~^ ERROR struct literals are not allowed here\n+    if x == E::K { field: \"\" } {}\n+    //~^ ERROR struct literals are not allowed here\n+    let y: usize = ();\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "55f23baea7aa8831c65d5bddad33d3e0563e07b2", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8aaae4294b16b8070a52b858364f440873bfc95c/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=8aaae4294b16b8070a52b858364f440873bfc95c", "patch": "@@ -0,0 +1,73 @@\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:13:13\n+   |\n+LL |     if x == E::I { field1: true, field2: 42 } {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::I { field1: true, field2: 42 }) {}\n+   |             ^                                 ^\n+\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:15:13\n+   |\n+LL |     if x == E::V { field: false } {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::V { field: false }) {}\n+   |             ^                     ^\n+\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:17:13\n+   |\n+LL |     if x == E::J { field: -42 } {}\n+   |             ^^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::J { field: -42 }) {}\n+   |             ^                   ^\n+\n+error: struct literals are not allowed here\n+  --> $DIR/struct-literal-variant-in-if.rs:19:13\n+   |\n+LL |     if x == E::K { field: \"\" } {}\n+   |             ^^^^^^^^^^^^^^^^^^\n+help: surround the struct literal with parenthesis\n+   |\n+LL |     if x == (E::K { field: \"\" }) {}\n+   |             ^                  ^\n+\n+error[E0423]: expected value, found struct variant `E::V`\n+  --> $DIR/struct-literal-variant-in-if.rs:10:13\n+   |\n+LL |     if x == E::V { field } {}\n+   |             ^^^^----------\n+   |             |\n+   |             help: surround the struct literal with parenthesis: `(E::V { field })`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/struct-literal-variant-in-if.rs:10:20\n+   |\n+LL | fn test_E(x: E) {\n+   |                 - help: try adding a return type: `-> bool`\n+LL |     let field = true;\n+LL |     if x == E::V { field } {}\n+   |                    ^^^^^ expected (), found bool\n+   |\n+   = note: expected type `()`\n+              found type `bool`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/struct-literal-variant-in-if.rs:21:20\n+   |\n+LL |     let y: usize = ();\n+   |                    ^^ expected usize, found ()\n+   |\n+   = note: expected type `usize`\n+              found type `()`\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0308, E0423.\n+For more information about an error, try `rustc --explain E0308`."}]}