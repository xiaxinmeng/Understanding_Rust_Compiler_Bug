{"sha": "d7da9e64d1563363c35821a54a412482180d39d7", "node_id": "C_kwDOAAsO6NoAKGQ3ZGE5ZTY0ZDE1NjMzNjNjMzU4MjFhNTRhNDEyNDgyMTgwZDM5ZDc", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-14T08:45:16Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-14T08:45:16Z"}, "message": "Add storage dead for let bindings without initializer", "tree": {"sha": "0eceb9f03ad05ec798881cf30dcd2af62a58b33b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eceb9f03ad05ec798881cf30dcd2af62a58b33b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7da9e64d1563363c35821a54a412482180d39d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7da9e64d1563363c35821a54a412482180d39d7", "html_url": "https://github.com/rust-lang/rust/commit/d7da9e64d1563363c35821a54a412482180d39d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7da9e64d1563363c35821a54a412482180d39d7/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cbb940cc48c0f785e9766867a44362b1a4a647a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbb940cc48c0f785e9766867a44362b1a4a647a", "html_url": "https://github.com/rust-lang/rust/commit/4cbb940cc48c0f785e9766867a44362b1a4a647a"}], "stats": {"total": 123, "additions": 79, "deletions": 44}, "files": [{"sha": "b70e658efd79cd6a64df12a14f37dcbe8f4f0b1f", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=d7da9e64d1563363c35821a54a412482180d39d7", "patch": "@@ -24,7 +24,9 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{\n+        dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n+    },\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -432,6 +434,44 @@ impl Body {\n         pats.shrink_to_fit();\n         bindings.shrink_to_fit();\n     }\n+\n+    pub fn walk_bindings_in_pat(&self, pat_id: PatId, mut f: impl FnMut(BindingId)) {\n+        self.walk_pats(pat_id, &mut |pat| {\n+            if let Pat::Bind { id, .. } = pat {\n+                f(*id);\n+            }\n+        });\n+    }\n+\n+    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+        let pat = &self[pat_id];\n+        f(pat);\n+        match pat {\n+            Pat::Range { .. }\n+            | Pat::Lit(..)\n+            | Pat::Path(..)\n+            | Pat::ConstBlock(..)\n+            | Pat::Wild\n+            | Pat::Missing => {}\n+            &Pat::Bind { subpat, .. } => {\n+                if let Some(subpat) = subpat {\n+                    self.walk_pats(subpat, f);\n+                }\n+            }\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Ref { pat, .. } => self.walk_pats(*pat, f),\n+            Pat::Slice { prefix, slice, suffix } => {\n+                let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().for_each(|RecordFieldPat { pat, .. }| self.walk_pats(*pat, f));\n+            }\n+            Pat::Box { inner } => self.walk_pats(*inner, f),\n+        }\n+    }\n }\n \n impl Default for Body {"}, {"sha": "5f839fc307aabf79191f9b27c81d513f0f77d696", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=d7da9e64d1563363c35821a54a412482180d39d7", "patch": "@@ -5,10 +5,7 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{\n-        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n-        RecordFieldPat,\n-    },\n+    expr::{Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -439,38 +436,8 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n \n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n-    walk_pats(body, pat_id, &mut |pat| {\n+    body.walk_pats(pat_id, &mut |pat| {\n         res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n     });\n     res\n }\n-\n-fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n-    let pat = &body[pat_id];\n-    f(pat);\n-    match pat {\n-        Pat::Range { .. }\n-        | Pat::Lit(..)\n-        | Pat::Path(..)\n-        | Pat::ConstBlock(..)\n-        | Pat::Wild\n-        | Pat::Missing => {}\n-        &Pat::Bind { subpat, .. } => {\n-            if let Some(subpat) = subpat {\n-                walk_pats(body, subpat, f);\n-            }\n-        }\n-        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n-            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n-        Pat::Slice { prefix, slice, suffix } => {\n-            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n-            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Record { args, .. } => {\n-            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n-        }\n-        Pat::Box { inner } => walk_pats(body, *inner, f),\n-    }\n-}"}, {"sha": "c4dd7c0ace46c150663cb5641c72d21d630a6dcf", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=d7da9e64d1563363c35821a54a412482180d39d7", "patch": "@@ -1113,7 +1113,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n-                self.push_storage_live(*id, current)?;\n+                self.push_storage_live(*id, current);\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -1327,8 +1327,9 @@ impl MirLowerCtx<'_> {\n         is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n     }\n \n-    /// This function push `StorageLive` statements for each binding in the pattern.\n-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n+    /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n+    /// the appropriated places.\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1356,7 +1357,6 @@ impl MirLowerCtx<'_> {\n         let l = self.result.binding_locals[b];\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n-        Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n@@ -1381,10 +1381,10 @@ impl MirLowerCtx<'_> {\n                     if let Some(expr_id) = initializer {\n                         let else_block;\n                         let Some((init_place, c)) =\n-                        self.lower_expr_as_place(current, *expr_id, true)?\n-                    else {\n-                        return Ok(None);\n-                    };\n+                            self.lower_expr_as_place(current, *expr_id, true)?\n+                        else {\n+                            return Ok(None);\n+                        };\n                         current = c;\n                         (current, else_block) = self.pattern_match(\n                             current,\n@@ -1407,6 +1407,10 @@ impl MirLowerCtx<'_> {\n                                 }\n                             }\n                         }\n+                    } else {\n+                        self.body.walk_bindings_in_pat(*pat, |b| {\n+                            self.push_storage_live(b, current);\n+                        });\n                     }\n                 }\n                 hir_def::expr::Statement::Expr { expr, has_semi: _ } => {"}, {"sha": "96470265d11d1f67644f8782b0060474308c5d7f", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7da9e64d1563363c35821a54a412482180d39d7/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=d7da9e64d1563363c35821a54a412482180d39d7", "patch": "@@ -505,6 +505,30 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn initialization_is_not_mutation_in_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let a;\n+    loop {\n+        let c @ (\n+            mut b,\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            mut d\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        );\n+        a = 1;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+        b = 1;\n+        c = (2, 3);\n+        d = 3;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn function_arguments_are_initialized() {\n         check_diagnostics("}]}