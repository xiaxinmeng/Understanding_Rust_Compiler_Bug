{"sha": "9cf8d325a21f31acf026084e0c67b3af983dddfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZjhkMzI1YTIxZjMxYWNmMDI2MDg0ZTBjNjdiM2FmOTgzZGRkZmI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-08T23:36:06Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-08T23:36:06Z"}, "message": "Precompute macro fragment kind", "tree": {"sha": "4aaaf71f3fec62114752bc732960b7e7c3cf8ba8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aaaf71f3fec62114752bc732960b7e7c3cf8ba8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf8d325a21f31acf026084e0c67b3af983dddfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf8d325a21f31acf026084e0c67b3af983dddfb", "html_url": "https://github.com/rust-lang/rust/commit/9cf8d325a21f31acf026084e0c67b3af983dddfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf8d325a21f31acf026084e0c67b3af983dddfb/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "html_url": "https://github.com/rust-lang/rust/commit/cf4d4f646b6227242b2d4e216e8e30b5e111e02e"}], "stats": {"total": 187, "additions": 113, "deletions": 74}, "files": [{"sha": "cad8a7479a0d8d516e952dee7ac6b64a1219c8ec", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -18,7 +18,7 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    HirFileId, InFile,\n+    FragmentKind, HirFileId, InFile,\n };\n use la_arena::{Arena, Idx, RawIdx};\n use profile::Count;\n@@ -656,6 +656,7 @@ pub struct MacroCall {\n     /// Path to the called macro.\n     pub path: Interned<ModPath>,\n     pub ast_id: FileAstId<ast::MacroCall>,\n+    pub fragment: FragmentKind,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]"}, {"sha": "fe348091d0913b275e07448b992a3e5c9159cf39", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -624,7 +624,8 @@ impl<'a> Ctx<'a> {\n     fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n         let path = Interned::new(ModPath::from_src(self.db, m.path()?, &self.hygiene)?);\n         let ast_id = self.source_ast_id_map.ast_id(m);\n-        let res = MacroCall { path, ast_id };\n+        let fragment = hir_expand::to_fragment_kind(m);\n+        let res = MacroCall { path, ast_id, fragment };\n         Some(id(self.data().macro_calls.alloc(res)))\n     }\n "}, {"sha": "e96ca953ff704e5ed94ebd5386cd06e7e8365422", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -62,7 +62,8 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n-    AstId, AttrId, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    AstId, AttrId, FragmentKind, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n+    MacroDefKind,\n };\n use la_arena::Idx;\n use nameres::DefMap;\n@@ -652,6 +653,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n         mut error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+        let fragment = hir_expand::to_fragment_kind(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n         let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n@@ -667,6 +669,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n \n         macro_call_as_call_id(\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n+            fragment,\n             db,\n             krate,\n             resolver,\n@@ -695,6 +698,7 @@ pub struct UnresolvedMacro {\n \n fn macro_call_as_call_id(\n     call: &AstIdWithPath<ast::MacroCall>,\n+    fragment: FragmentKind,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n@@ -718,7 +722,11 @@ fn macro_call_as_call_id(\n         .map(MacroCallId::from)\n     } else {\n         Ok(def\n-            .as_lazy_macro(db.upcast(), krate, MacroCallKind::FnLike { ast_id: call.ast_id })\n+            .as_lazy_macro(\n+                db.upcast(),\n+                krate,\n+                MacroCallKind::FnLike { ast_id: call.ast_id, fragment },\n+            )\n             .into())\n     };\n     Ok(res)"}, {"sha": "249af6fc806ba4275915296de6b15e099807485f", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -629,7 +629,7 @@ mod diagnostics {\n                 DiagnosticKind::UnresolvedProcMacro { ast } => {\n                     let mut precise_location = None;\n                     let (file, ast, name) = match ast {\n-                        MacroCallKind::FnLike { ast_id } => {\n+                        MacroCallKind::FnLike { ast_id, .. } => {\n                             let node = ast_id.to_node(db.upcast());\n                             (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)), None)\n                         }"}, {"sha": "e89136ed1dc3482a1ad288c88cfd05b33ed23980", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -13,7 +13,7 @@ use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    AttrId, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    AttrId, FragmentKind, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -215,7 +215,7 @@ struct MacroDirective {\n \n #[derive(Clone, Debug, Eq, PartialEq)]\n enum MacroDirectiveKind {\n-    FnLike { ast_id: AstIdWithPath<ast::MacroCall> },\n+    FnLike { ast_id: AstIdWithPath<ast::MacroCall>, fragment: FragmentKind },\n     Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n }\n \n@@ -807,9 +807,10 @@ impl DefCollector<'_> {\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n             match &directive.kind {\n-                MacroDirectiveKind::FnLike { ast_id } => {\n+                MacroDirectiveKind::FnLike { ast_id, fragment } => {\n                     match macro_call_as_call_id(\n                         ast_id,\n+                        *fragment,\n                         self.db,\n                         self.def_map.krate,\n                         |path| {\n@@ -926,8 +927,9 @@ impl DefCollector<'_> {\n \n         for directive in &self.unexpanded_macros {\n             match &directive.kind {\n-                MacroDirectiveKind::FnLike { ast_id, .. } => match macro_call_as_call_id(\n+                MacroDirectiveKind::FnLike { ast_id, fragment } => match macro_call_as_call_id(\n                     ast_id,\n+                    *fragment,\n                     self.db,\n                     self.def_map.krate,\n                     |path| {\n@@ -1496,6 +1498,7 @@ impl ModCollector<'_, '_> {\n         let mut error = None;\n         match macro_call_as_call_id(\n             &ast_id,\n+            mac.fragment,\n             self.def_collector.db,\n             self.def_collector.def_map.krate,\n             |path| {\n@@ -1524,9 +1527,14 @@ impl ModCollector<'_, '_> {\n             }\n             Ok(Err(_)) => {\n                 // Built-in macro failed eager expansion.\n+\n+                // FIXME: don't parse the file here\n+                let fragment = hir_expand::to_fragment_kind(\n+                    &ast_id.ast_id.to_node(self.def_collector.db.upcast()),\n+                );\n                 self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n                     self.module_id,\n-                    MacroCallKind::FnLike { ast_id: ast_id.ast_id },\n+                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, fragment },\n                     error.unwrap().to_string(),\n                 ));\n                 return;\n@@ -1543,7 +1551,7 @@ impl ModCollector<'_, '_> {\n         self.def_collector.unexpanded_macros.push(MacroDirective {\n             module_id: self.module_id,\n             depth: self.macro_depth + 1,\n-            kind: MacroDirectiveKind::FnLike { ast_id },\n+            kind: MacroDirectiveKind::FnLike { ast_id, fragment: mac.fragment },\n         });\n     }\n "}, {"sha": "0dd725ec31e96294e01cdcf43d638afec3cfab21", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -578,6 +578,7 @@ mod tests {\n                     krate,\n                     kind: MacroCallKind::FnLike {\n                         ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call)),\n+                        fragment: FragmentKind::Expr,\n                     },\n                 };\n "}, {"sha": "6647e57e7dc19ac41751ae3e103c4db23ffe5f4e", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 11, "deletions": 60, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -8,9 +8,7 @@ use parser::FragmentKind;\n use syntax::{\n     algo::diff,\n     ast::{self, NameOwner},\n-    AstNode, GreenNode, Parse,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxToken,\n+    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken,\n };\n \n use crate::{\n@@ -160,7 +158,7 @@ pub fn expand_hypothetical(\n \n     let hypothetical_expansion = macro_def.expand(db, lazy_id, &tt);\n \n-    let fragment_kind = to_fragment_kind(db, actual_macro_call);\n+    let fragment_kind = macro_fragment_kind(db, actual_macro_call);\n \n     let (node, tmap_2) =\n         mbe::token_tree_to_syntax_node(&hypothetical_expansion.value, fragment_kind).ok()?;\n@@ -226,7 +224,7 @@ fn parse_macro_expansion(\n         None => return ExpandResult { value: None, err: result.err },\n     };\n \n-    let fragment_kind = to_fragment_kind(db, macro_file.macro_call_id);\n+    let fragment_kind = macro_fragment_kind(db, macro_file.macro_call_id);\n \n     log::debug!(\"expanded = {}\", tt.as_debug_string());\n     log::debug!(\"kind = {:?}\", fragment_kind);\n@@ -427,62 +425,15 @@ fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame>\n     Arc::new(HygieneFrame::new(db, file_id))\n }\n \n-/// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n-/// FIXME: Not completed\n-fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n-    let lazy_id = match id {\n-        MacroCallId::LazyMacro(id) => id,\n-        MacroCallId::EagerMacro(id) => {\n-            return db.lookup_intern_eager_expansion(id).fragment;\n-        }\n-    };\n-    let syn = db.lookup_intern_macro(lazy_id).kind.node(db).value;\n-\n-    let parent = match syn.parent() {\n-        Some(it) => it,\n-        None => return FragmentKind::Statements,\n-    };\n-\n-    match parent.kind() {\n-        MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n-        MACRO_STMTS => FragmentKind::Statements,\n-        MACRO_PAT => FragmentKind::Pattern,\n-        MACRO_TYPE => FragmentKind::Type,\n-        ITEM_LIST => FragmentKind::Items,\n-        LET_STMT => {\n-            // FIXME: Handle LHS Pattern\n-            FragmentKind::Expr\n+fn macro_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n+    match id {\n+        MacroCallId::LazyMacro(id) => {\n+            let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+            loc.kind.fragment_kind()\n         }\n-        EXPR_STMT => FragmentKind::Statements,\n-        BLOCK_EXPR => FragmentKind::Statements,\n-        ARG_LIST => FragmentKind::Expr,\n-        TRY_EXPR => FragmentKind::Expr,\n-        TUPLE_EXPR => FragmentKind::Expr,\n-        PAREN_EXPR => FragmentKind::Expr,\n-        ARRAY_EXPR => FragmentKind::Expr,\n-        FOR_EXPR => FragmentKind::Expr,\n-        PATH_EXPR => FragmentKind::Expr,\n-        CLOSURE_EXPR => FragmentKind::Expr,\n-        CONDITION => FragmentKind::Expr,\n-        BREAK_EXPR => FragmentKind::Expr,\n-        RETURN_EXPR => FragmentKind::Expr,\n-        MATCH_EXPR => FragmentKind::Expr,\n-        MATCH_ARM => FragmentKind::Expr,\n-        MATCH_GUARD => FragmentKind::Expr,\n-        RECORD_EXPR_FIELD => FragmentKind::Expr,\n-        CALL_EXPR => FragmentKind::Expr,\n-        INDEX_EXPR => FragmentKind::Expr,\n-        METHOD_CALL_EXPR => FragmentKind::Expr,\n-        FIELD_EXPR => FragmentKind::Expr,\n-        AWAIT_EXPR => FragmentKind::Expr,\n-        CAST_EXPR => FragmentKind::Expr,\n-        REF_EXPR => FragmentKind::Expr,\n-        PREFIX_EXPR => FragmentKind::Expr,\n-        RANGE_EXPR => FragmentKind::Expr,\n-        BIN_EXPR => FragmentKind::Expr,\n-        _ => {\n-            // Unknown , Just guess it is `Items`\n-            FragmentKind::Items\n+        MacroCallId::EagerMacro(id) => {\n+            let loc: EagerCallLoc = db.lookup_intern_eager_expansion(id);\n+            loc.fragment\n         }\n     }\n }"}, {"sha": "85491fe8be46851ff9ccae2fa4824e2ea4dfded2", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -175,8 +175,13 @@ fn lazy_expand(\n ) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n+    let fragment = crate::to_fragment_kind(&macro_call.value);\n     let id: MacroCallId = def\n-        .as_lazy_macro(db, krate, MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id) })\n+        .as_lazy_macro(\n+            db,\n+            krate,\n+            MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id), fragment },\n+        )\n         .into();\n \n     let err = db.macro_expand_error(id);"}, {"sha": "80ab3aeee7e5c0c6ae8c3eb7d3497131ffce6a0e", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf8d325a21f31acf026084e0c67b3af983dddfb/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=9cf8d325a21f31acf026084e0c67b3af983dddfb", "patch": "@@ -16,7 +16,9 @@ pub mod quote;\n pub mod eager;\n \n use either::Either;\n+\n pub use mbe::{ExpandError, ExpandResult};\n+pub use parser::FragmentKind;\n \n use std::hash::Hash;\n use std::sync::Arc;\n@@ -290,7 +292,7 @@ pub struct MacroCallLoc {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n-    FnLike { ast_id: AstId<ast::MacroCall> },\n+    FnLike { ast_id: AstId<ast::MacroCall>, fragment: FragmentKind },\n     Derive { ast_id: AstId<ast::Item>, derive_name: String, derive_attr: AttrId },\n }\n \n@@ -324,6 +326,13 @@ impl MacroCallKind {\n             MacroCallKind::Derive { ast_id, .. } => Some(ast_id.to_node(db).syntax().clone()),\n         }\n     }\n+\n+    fn fragment_kind(&self) -> FragmentKind {\n+        match self {\n+            MacroCallKind::FnLike { fragment, .. } => *fragment,\n+            MacroCallKind::Derive { .. } => FragmentKind::Items,\n+        }\n+    }\n }\n \n impl MacroCallId {\n@@ -357,7 +366,6 @@ pub struct ExpansionInfo {\n }\n \n pub use mbe::Origin;\n-use parser::FragmentKind;\n \n impl ExpansionInfo {\n     pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {\n@@ -562,3 +570,59 @@ impl<N: AstNode> InFile<N> {\n         self.with_value(self.value.syntax())\n     }\n }\n+\n+/// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n+/// FIXME: Not completed\n+pub fn to_fragment_kind(call: &ast::MacroCall) -> FragmentKind {\n+    use syntax::SyntaxKind::*;\n+\n+    let syn = call.syntax();\n+\n+    let parent = match syn.parent() {\n+        Some(it) => it,\n+        None => return FragmentKind::Statements,\n+    };\n+\n+    match parent.kind() {\n+        MACRO_ITEMS | SOURCE_FILE => FragmentKind::Items,\n+        MACRO_STMTS => FragmentKind::Statements,\n+        MACRO_PAT => FragmentKind::Pattern,\n+        MACRO_TYPE => FragmentKind::Type,\n+        ITEM_LIST => FragmentKind::Items,\n+        LET_STMT => {\n+            // FIXME: Handle LHS Pattern\n+            FragmentKind::Expr\n+        }\n+        EXPR_STMT => FragmentKind::Statements,\n+        BLOCK_EXPR => FragmentKind::Statements,\n+        ARG_LIST => FragmentKind::Expr,\n+        TRY_EXPR => FragmentKind::Expr,\n+        TUPLE_EXPR => FragmentKind::Expr,\n+        PAREN_EXPR => FragmentKind::Expr,\n+        ARRAY_EXPR => FragmentKind::Expr,\n+        FOR_EXPR => FragmentKind::Expr,\n+        PATH_EXPR => FragmentKind::Expr,\n+        CLOSURE_EXPR => FragmentKind::Expr,\n+        CONDITION => FragmentKind::Expr,\n+        BREAK_EXPR => FragmentKind::Expr,\n+        RETURN_EXPR => FragmentKind::Expr,\n+        MATCH_EXPR => FragmentKind::Expr,\n+        MATCH_ARM => FragmentKind::Expr,\n+        MATCH_GUARD => FragmentKind::Expr,\n+        RECORD_EXPR_FIELD => FragmentKind::Expr,\n+        CALL_EXPR => FragmentKind::Expr,\n+        INDEX_EXPR => FragmentKind::Expr,\n+        METHOD_CALL_EXPR => FragmentKind::Expr,\n+        FIELD_EXPR => FragmentKind::Expr,\n+        AWAIT_EXPR => FragmentKind::Expr,\n+        CAST_EXPR => FragmentKind::Expr,\n+        REF_EXPR => FragmentKind::Expr,\n+        PREFIX_EXPR => FragmentKind::Expr,\n+        RANGE_EXPR => FragmentKind::Expr,\n+        BIN_EXPR => FragmentKind::Expr,\n+        _ => {\n+            // Unknown , Just guess it is `Items`\n+            FragmentKind::Items\n+        }\n+    }\n+}"}]}