{"sha": "928955296e28cea5045fb726d6e3fb47780f8c48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyODk1NTI5NmUyOGNlYTUwNDVmYjcyNmQ2ZTNmYjQ3NzgwZjhjNDg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-06T18:27:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:57:57Z"}, "message": "Define the `wf` and `outlives` relation separately, unlike the existing\n`implicator`. These definitions are also in accordance with RFC 1214 (or\nmore so), and hence somewhat different from the implicator. This commit\nalso modifies the implicator to remove the older rules for projections,\nwhich can easily trigger infinite loops.", "tree": {"sha": "92b9d95032bdf61038f3b258483e2df3ff954f75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92b9d95032bdf61038f3b258483e2df3ff954f75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/928955296e28cea5045fb726d6e3fb47780f8c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/928955296e28cea5045fb726d6e3fb47780f8c48", "html_url": "https://github.com/rust-lang/rust/commit/928955296e28cea5045fb726d6e3fb47780f8c48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/928955296e28cea5045fb726d6e3fb47780f8c48/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4561607403e1595d5ecbf36716711bc0076506f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4561607403e1595d5ecbf36716711bc0076506f0", "html_url": "https://github.com/rust-lang/rust/commit/4561607403e1595d5ecbf36716711bc0076506f0"}], "stats": {"total": 879, "additions": 817, "deletions": 62}, "files": [{"sha": "f48a28965c685e37bf922550b6a786c97383a12b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -130,6 +130,7 @@ pub mod middle {\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;\n+    pub mod outlives;\n     pub mod pat_util;\n     pub mod privacy;\n     pub mod reachable;\n@@ -144,6 +145,7 @@ pub mod middle {\n     pub mod ty_match;\n     pub mod ty_relate;\n     pub mod ty_walk;\n+    pub mod wf;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "9a5f03672316a6a54330f1c1da2624d8caa218d8", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -10,7 +10,7 @@\n \n //! This file defines\n \n-use middle::implicator::Implication;\n+use middle::wf::ImpliedBound;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n@@ -30,18 +30,19 @@ impl FreeRegionMap {\n         FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n     }\n \n-    pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n-                                                       implications: &[Implication<'tcx>])\n+    pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n+                                                        implied_bounds: &[ImpliedBound<'tcx>])\n     {\n-        for implication in implications {\n-            debug!(\"implication: {:?}\", implication);\n-            match *implication {\n-                Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n+        debug!(\"relate_free_regions_from_implied_bounds()\");\n+        for implied_bound in implied_bounds {\n+            debug!(\"implied bound: {:?}\", implied_bound);\n+            match *implied_bound {\n+                ImpliedBound::RegionSubRegion(ty::ReFree(free_a), ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n-                Implication::RegionSubRegion(..) |\n-                Implication::RegionSubGeneric(..) |\n-                Implication::Predicate(..) => {\n+                ImpliedBound::RegionSubRegion(..) |\n+                ImpliedBound::RegionSubParam(..) |\n+                ImpliedBound::RegionSubProjection(..) => {\n                 }\n             }\n         }"}, {"sha": "21f09574a3fc884e38447b1a6b9e5fb9d6d5acf7", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -278,9 +278,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n         for predicate in predicates.predicates.as_slice() {\n             match *predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    self.accumulate_from_assoc_types_transitive(data);\n-                }\n+                ty::Predicate::Trait(..) => { }\n                 ty::Predicate::Equate(..) => { }\n                 ty::Predicate::Projection(..) => { }\n                 ty::Predicate::RegionOutlives(ref data) => {\n@@ -349,53 +347,6 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         }\n     }\n \n-    /// Given that there is a requirement that `Foo<X> : 'a`, where\n-    /// `Foo` is declared like `struct Foo<T> where T : SomeTrait`,\n-    /// this code finds all the associated types defined in\n-    /// `SomeTrait` (and supertraits) and adds a requirement that `<X\n-    /// as SomeTrait>::N : 'a` (where `N` is some associated type\n-    /// defined in `SomeTrait`). This rule only applies to\n-    /// trait-bounds that are not higher-ranked, because we cannot\n-    /// project out of a HRTB. This rule helps code using associated\n-    /// types to compile, see Issue #22246 for an example.\n-    fn accumulate_from_assoc_types_transitive(&mut self,\n-                                              data: &ty::PolyTraitPredicate<'tcx>)\n-    {\n-        debug!(\"accumulate_from_assoc_types_transitive({:?})\",\n-               data);\n-\n-        for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n-            match self.tcx().no_late_bound_regions(&poly_trait_ref) {\n-                Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n-                None => { }\n-            }\n-        }\n-    }\n-\n-    fn accumulate_from_assoc_types(&mut self,\n-                                   trait_ref: ty::TraitRef<'tcx>)\n-    {\n-        debug!(\"accumulate_from_assoc_types({:?})\",\n-               trait_ref);\n-\n-        let trait_def_id = trait_ref.def_id;\n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-        let assoc_type_projections: Vec<_> =\n-            trait_def.associated_type_names\n-                     .iter()\n-                     .map(|&name| self.tcx().mk_projection(trait_ref.clone(), name))\n-                     .collect();\n-        debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n-               assoc_type_projections);\n-        let tys = match self.fully_normalize(&assoc_type_projections) {\n-            Ok(tys) => { tys }\n-            Err(ErrorReported) => { return; }\n-        };\n-        for ty in tys {\n-            self.accumulate_from_ty(ty);\n-        }\n-    }\n-\n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n                                  region_bound: ty::Region,"}, {"sha": "fa2b78b330d8ba1c463c8d43a7ab20183dfd9c98", "filename": "src/librustc/middle/outlives.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Foutlives.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The outlines relation `T: 'a` or `'a: 'b`.\n+\n+use middle::infer::InferCtxt;\n+use middle::ty::{self, RegionEscape, Ty};\n+\n+#[derive(Debug)]\n+pub enum Component<'tcx> {\n+    Region(ty::Region),\n+    Param(ty::ParamTy),\n+    UnresolvedInferenceVariable(ty::InferTy),\n+\n+    // Projections like `T::Foo` are tricky because a constraint like\n+    // `T::Foo: 'a` can be satisfied in so many ways. There may be a\n+    // where-clause that says `T::Foo: 'a`, or the defining trait may\n+    // include a bound like `type Foo: 'static`, or -- in the most\n+    // conservative way -- we can prove that `T: 'a` (more generally,\n+    // that all components in the projection outlive `'a`). This code\n+    // is not in a position to judge which is the best technique, so\n+    // we just product the projection as a component and leave it to\n+    // the consumer to decide (but see `EscapingProjection` below).\n+    Projection(ty::ProjectionTy<'tcx>),\n+\n+    // In the case where a projection has escaping regions -- meaning\n+    // regions bound within the type itself -- we always use\n+    // the most conservative rule, which requires that all components\n+    // outlive the bound. So for example if we had a type like this:\n+    //\n+    //     for<'a> Trait1<  <T as Trait2<'a,'b>>::Foo  >\n+    //                      ~~~~~~~~~~~~~~~~~~~~~~~~~\n+    //\n+    // then the inner projection (underlined) has an escaping region\n+    // `'a`. We consider that outer trait `'c` to meet a bound if `'b`\n+    // outlives `'b: 'c`, and we don't consider whether the trait\n+    // declares that `Foo: 'static` etc. Therefore, we just return the\n+    // free components of such a projection (in this case, `'b`).\n+    //\n+    // However, in the future, we may want to get smarter, and\n+    // actually return a \"higher-ranked projection\" here. Therefore,\n+    // we mark that these components are part of an escaping\n+    // projection, so that implied bounds code can avoid relying on\n+    // them. This gives us room to improve the regionck reasoning in\n+    // the future without breaking backwards compat.\n+    EscapingProjection(Vec<Component<'tcx>>),\n+\n+    RFC1214(Vec<Component<'tcx>>),\n+}\n+\n+/// Returns all the things that must outlive `'a` for the condition\n+/// `ty0: 'a` to hold.\n+pub fn components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                           ty0: Ty<'tcx>)\n+                           -> Vec<Component<'tcx>> {\n+    let mut components = vec![];\n+    compute_components(infcx, ty0, &mut components);\n+    debug!(\"outlives({:?}) = {:?}\", ty0, components);\n+    components\n+}\n+\n+fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                               ty0: Ty<'tcx>,\n+                               out: &mut Vec<Component<'tcx>>) {\n+    // Descend through the types, looking for the various \"base\"\n+    // components and collecting them into `out`. This is not written\n+    // with `collect()` because of the need to sometimes skip subtrees\n+    // in the `subtys` iterator (e.g., when encountering a\n+    // projection).\n+    let mut subtys = ty0.walk();\n+    while let Some(ty) = subtys.next() {\n+        match ty.sty {\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerced\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n+\n+                for &upvar_ty in &substs.upvar_tys {\n+                    compute_components(infcx, upvar_ty, out);\n+                }\n+                subtys.skip_current_subtree();\n+            }\n+            ty::TyBareFn(..) | ty::TyTrait(..) => {\n+                subtys.skip_current_subtree();\n+                let temp = capture_components(infcx, ty);\n+                out.push(Component::RFC1214(temp));\n+            }\n+            ty::TyParam(p) => {\n+                out.push(Component::Param(p));\n+                subtys.skip_current_subtree();\n+            }\n+            ty::TyProjection(ref data) => {\n+                // For projections, we prefer to generate an\n+                // obligation like `<P0 as Trait<P1...Pn>>::Foo: 'a`,\n+                // because this gives the regionck more ways to prove\n+                // that it holds. However, regionck is not (at least\n+                // currently) prepared to deal with higher-ranked\n+                // regions that may appear in the\n+                // trait-ref. Therefore, if we see any higher-ranke\n+                // regions, we simply fallback to the most restrictive\n+                // rule, which requires that `Pi: 'a` for all `i`.\n+\n+                if !data.has_escaping_regions() {\n+                    // best case: no escaping reions, so push the\n+                    // projection and skip the subtree (thus\n+                    // generating no constraints for Pi).\n+                    out.push(Component::Projection(*data));\n+                } else {\n+                    // fallback case: continue walking through and\n+                    // constrain Pi.\n+                    let temp = capture_components(infcx, ty);\n+                    out.push(Component::EscapingProjection(temp));\n+                }\n+                subtys.skip_current_subtree();\n+            }\n+            ty::TyInfer(_) => {\n+                let ty = infcx.resolve_type_vars_if_possible(&ty);\n+                if let ty::TyInfer(infer_ty) = ty.sty {\n+                    out.push(Component::UnresolvedInferenceVariable(infer_ty));\n+                } else {\n+                    compute_components(infcx, ty, out);\n+                }\n+            }\n+            _ => {\n+                // for all other types, just constrain the regions and\n+                // keep walking to find any other types.\n+                push_region_constraints(out, ty.regions());\n+            }\n+        }\n+    }\n+}\n+\n+fn capture_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                               ty: Ty<'tcx>)\n+                               -> Vec<Component<'tcx>> {\n+    let mut temp = vec![];\n+    push_region_constraints(&mut temp, ty.regions());\n+    for subty in ty.walk_shallow() {\n+        compute_components(infcx, subty, &mut temp);\n+    }\n+    temp\n+}\n+\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {\n+    for r in regions {\n+        if !r.is_bound() {\n+            out.push(Component::Region(r));\n+        }\n+    }\n+}\n+"}, {"sha": "7d807bf2431ff0adc39cba8cf270c5214c60efd0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -1670,6 +1670,13 @@ impl Region {\n         }\n     }\n \n+    pub fn needs_infer(&self) -> bool {\n+        match *self {\n+            ty::ReInfer(..) => true,\n+            _ => false\n+        }\n+    }\n+\n     pub fn escapes_depth(&self, depth: u32) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n@@ -2567,7 +2574,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: ty::TraitRef<'tcx>,\n@@ -4144,6 +4151,49 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Returns the regions directly referenced from this type (but\n+    /// not types reachable from this type via `walk_tys`). This\n+    /// ignores late-bound regions binders.\n+    pub fn regions(&self) -> Vec<ty::Region> {\n+        match self.sty {\n+            TyRef(region, _) => {\n+                vec![*region]\n+            }\n+            TyTrait(ref obj) => {\n+                let mut v = vec![obj.bounds.region_bound];\n+                v.push_all(obj.principal.skip_binder().substs.regions().as_slice());\n+                v\n+            }\n+            TyEnum(_, substs) |\n+            TyStruct(_, substs) => {\n+                substs.regions().as_slice().to_vec()\n+            }\n+            TyClosure(_, ref substs) => {\n+                substs.func_substs.regions().as_slice().to_vec()\n+            }\n+            TyProjection(ref data) => {\n+                data.trait_ref.substs.regions().as_slice().to_vec()\n+            }\n+            TyBareFn(..) |\n+            TyBool |\n+            TyChar |\n+            TyInt(_) |\n+            TyUint(_) |\n+            TyFloat(_) |\n+            TyBox(_) |\n+            TyStr |\n+            TyArray(_, _) |\n+            TySlice(_) |\n+            TyRawPtr(_) |\n+            TyTuple(_) |\n+            TyParam(_) |\n+            TyInfer(_) |\n+            TyError => {\n+                vec![]\n+            }\n+        }\n+    }\n+\n     /// Walks `ty` and any types appearing within `ty`, invoking the\n     /// callback `f` on each type. If the callback returns false, then the\n     /// children of the current type are ignored.\n@@ -6951,6 +7001,20 @@ impl<'tcx> RegionEscape for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for TraitTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.principal.has_regions_escaping_depth(depth) ||\n+            self.bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ExistentialBounds<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_bound.has_regions_escaping_depth(depth) ||\n+            self.projection_bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for Substs<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.types.has_regions_escaping_depth(depth) ||"}, {"sha": "d7808599895f573fa3812a4331c02660b71d8e12", "filename": "src/librustc/middle/wf.rs", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc%2Fmiddle%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fwf.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -0,0 +1,546 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::infer::InferCtxt;\n+use middle::outlives::{self, Component};\n+use middle::subst::Substs;\n+use middle::traits;\n+use middle::ty::{self, RegionEscape, ToPredicate, Ty};\n+use std::iter::once;\n+use std::mem;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::common::ErrorReported;\n+\n+/// Returns the set of obligations needed to make `ty` well-formed.\n+/// If `ty` contains unresolved inference variables, this may include\n+/// further WF obligations. However, if `ty` IS an unresolved\n+/// inference variable, returns `None`, because we are not able to\n+/// make any progress at all. This is to prevent \"livelock\" where we\n+/// say \"$0 is WF if $0 is WF\".\n+pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                            body_id: ast::NodeId,\n+                            ty: Ty<'tcx>,\n+                            span: Span,\n+                            rfc1214: bool)\n+                            -> Option<Vec<traits::PredicateObligation<'tcx>>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx,\n+                                body_id: body_id,\n+                                span: span,\n+                                out: vec![],\n+                                rfc1214: rfc1214 };\n+    if wf.compute(ty) {\n+        debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n+        let result = wf.normalize();\n+        debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n+        Some(result)\n+    } else {\n+        None // no progress made, return None\n+    }\n+}\n+\n+/// Returns the obligations that make this trait reference\n+/// well-formed.  For example, if there is a trait `Set` defined like\n+/// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n+/// if `Bar: Eq`.\n+pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                  body_id: ast::NodeId,\n+                                  trait_ref: &ty::TraitRef<'tcx>,\n+                                  span: Span,\n+                                  rfc1214: bool)\n+                                  -> Vec<traits::PredicateObligation<'tcx>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n+                                out: vec![], rfc1214: rfc1214 };\n+    wf.compute_trait_ref(trait_ref);\n+    wf.normalize()\n+}\n+\n+pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      body_id: ast::NodeId,\n+                                      predicate: &ty::Predicate<'tcx>,\n+                                      span: Span,\n+                                      rfc1214: bool)\n+                                      -> Vec<traits::PredicateObligation<'tcx>>\n+{\n+    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span,\n+                                out: vec![], rfc1214: rfc1214 };\n+\n+    // (*) ok to skip binders, because wf code is prepared for it\n+    match *predicate {\n+        ty::Predicate::Trait(ref t) => {\n+            wf.compute_trait_ref(&t.skip_binder().trait_ref); // (*)\n+        }\n+        ty::Predicate::Equate(ref t) => {\n+            wf.compute(t.skip_binder().0);\n+            wf.compute(t.skip_binder().1);\n+        }\n+        ty::Predicate::RegionOutlives(..) => {\n+        }\n+        ty::Predicate::TypeOutlives(ref t) => {\n+            wf.compute(t.skip_binder().0);\n+        }\n+        ty::Predicate::Projection(ref t) => {\n+            let t = t.skip_binder(); // (*)\n+            wf.compute_projection(t.projection_ty);\n+            wf.compute(t.ty);\n+        }\n+        ty::Predicate::WellFormed(t) => {\n+            wf.compute(t);\n+        }\n+        ty::Predicate::ObjectSafe(_) => {\n+        }\n+    }\n+\n+    wf.normalize()\n+}\n+\n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+pub enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region, ty::Region),\n+    RegionSubParam(ty::Region, ty::ParamTy),\n+    RegionSubProjection(ty::Region, ty::ProjectionTy<'tcx>),\n+}\n+\n+/// This routine computes the full set of well-formedness constraints\n+/// that must hold for the type `ty` to appear in a context with\n+/// lifetime `outer_region`.\n+pub fn implied_bounds<'a,'tcx>(\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    body_id: ast::NodeId,\n+    ty: Ty<'tcx>,\n+    span: Span)\n+    -> Vec<ImpliedBound<'tcx>>\n+{\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Currently (at least) these resulting\n+    // predicates are always guaranteed to be a subset of the original\n+    // type, so we need not fear non-termination.\n+    let mut wf_types = vec![ty];\n+\n+    let mut implied_bounds = vec![];\n+\n+    while let Some(ty) = wf_types.pop() {\n+        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        let obligations = obligations(infcx, body_id, ty, span, false).unwrap_or(vec![]);\n+\n+        // From the full set of obligations, just filter down to the\n+        // region relationships.\n+        implied_bounds.extend(\n+            obligations\n+            .into_iter()\n+            .flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ObjectSafe(..) =>\n+                        vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) =>\n+                        match infcx.tcx.no_late_bound_regions(data) {\n+                            None =>\n+                                vec![],\n+                            Some(ty::OutlivesPredicate(r_a, r_b)) =>\n+                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n+                        },\n+\n+                    ty::Predicate::TypeOutlives(ref data) =>\n+                        match infcx.tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                let components = outlives::components(infcx, ty_a);\n+                                implied_bounds_from_components(r_b, components)\n+                            }\n+                        },\n+                }}));\n+    }\n+\n+    implied_bounds\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n+                                        sup_components: Vec<Component<'tcx>>)\n+                                        -> Vec<ImpliedBound<'tcx>>\n+{\n+    sup_components\n+        .into_iter()\n+        .flat_map(|component| {\n+            match component {\n+                Component::Region(r) =>\n+                    vec!(ImpliedBound::RegionSubRegion(sub_region, r)),\n+                Component::Param(p) =>\n+                    vec!(ImpliedBound::RegionSubParam(sub_region, p)),\n+                Component::Projection(p) =>\n+                    vec!(ImpliedBound::RegionSubProjection(sub_region, p)),\n+                Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                    vec!(),\n+                Component::UnresolvedInferenceVariable(..) =>\n+                    vec!(),\n+                Component::RFC1214(components) =>\n+                    implied_bounds_from_components(sub_region, components),\n+            }\n+        })\n+        .collect()\n+}\n+\n+struct WfPredicates<'a,'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    body_id: ast::NodeId,\n+    span: Span,\n+    out: Vec<traits::PredicateObligation<'tcx>>,\n+    rfc1214: bool\n+}\n+\n+impl<'a,'tcx> WfPredicates<'a,'tcx> {\n+    fn rfc1214<R,F:FnOnce(&mut WfPredicates<'a,'tcx>) -> R>(&mut self, f: F) -> R {\n+        let b = mem::replace(&mut self.rfc1214, true);\n+        let r = f(self);\n+        self.rfc1214 = b;\n+        r\n+    }\n+\n+    fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n+        if !self.rfc1214 {\n+            traits::ObligationCause::new(self.span, self.body_id, code)\n+        } else {\n+            let code = traits::ObligationCauseCode::RFC1214(Rc::new(code));\n+            traits::ObligationCause::new(self.span, self.body_id, code)\n+        }\n+    }\n+\n+    fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        let cause = self.cause(traits::MiscObligation);\n+        let infcx = &mut self.infcx;\n+        self.out.iter()\n+                .inspect(|pred| assert!(!pred.has_escaping_regions()))\n+                .flat_map(|pred| {\n+                    let mut selcx = traits::SelectionContext::new(infcx);\n+                    let pred = traits::normalize(&mut selcx, cause.clone(), pred);\n+                    once(pred.value).chain(pred.obligations)\n+                })\n+                .collect()\n+    }\n+\n+    fn compute_rfc1214(&mut self, ty: Ty<'tcx>) {\n+        let b = mem::replace(&mut self.rfc1214, true);\n+        for subty in ty.walk().skip(1) {\n+            self.compute(subty);\n+        }\n+        self.rfc1214 = b;\n+    }\n+\n+    /// Pushes the obligations required for `trait_ref` to be WF into\n+    /// `self.out`.\n+    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+        let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n+        self.out.extend(obligations);\n+\n+        let cause = self.cause(traits::MiscObligation);\n+        self.out.extend(\n+            trait_ref.substs.types\n+                            .as_slice()\n+                            .iter()\n+                            .filter(|ty| !ty.has_escaping_regions())\n+                            .map(|ty| traits::Obligation::new(cause.clone(),\n+                                                              ty::Predicate::WellFormed(ty))));\n+    }\n+\n+    /// Pushes the obligations required for `trait_ref::Item` to be WF\n+    /// into `self.out`.\n+    fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n+        // A projection is well-formed if (a) the trait ref itself is\n+        // WF WF and (b) the trait-ref holds.  (It may also be\n+        // normalizable and be WF that way.)\n+\n+        self.compute_trait_ref(&data.trait_ref);\n+\n+        if !data.has_escaping_regions() {\n+            let predicate = data.trait_ref.to_predicate();\n+            let cause = self.cause(traits::ProjectionWf(data));\n+            self.out.push(traits::Obligation::new(cause, predicate));\n+        }\n+    }\n+\n+    /// Push new obligations into `out`. Returns true if it was able\n+    /// to generate all the predicates needed to validate that `ty0`\n+    /// is WF. Returns false if `ty0` is an unresolved type variable,\n+    /// in which case we are not able to simplify at all.\n+    fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n+        let mut subtys = ty0.walk();\n+        while let Some(ty) = subtys.next() {\n+            match ty.sty {\n+                ty::TyBool |\n+                ty::TyChar |\n+                ty::TyInt(..) |\n+                ty::TyUint(..) |\n+                ty::TyFloat(..) |\n+                ty::TyError |\n+                ty::TyStr |\n+                ty::TyParam(_) => {\n+                    // WfScalar, WfParameter, etc\n+                }\n+\n+                ty::TySlice(subty) |\n+                ty::TyArray(subty, _) => {\n+                    self.rfc1214(|this| {\n+                        if !subty.has_escaping_regions() {\n+                            let cause = this.cause(traits::SliceOrArrayElem);\n+                            match traits::trait_ref_for_builtin_bound(this.infcx.tcx,\n+                                                                      ty::BoundSized,\n+                                                                      subty) {\n+                                Ok(trait_ref) => {\n+                                    this.out.push(\n+                                        traits::Obligation::new(cause,\n+                                                                trait_ref.to_predicate()));\n+                                }\n+                                Err(ErrorReported) => { }\n+                            }\n+                        }\n+                    })\n+                }\n+\n+                ty::TyBox(_) |\n+                ty::TyTuple(_) |\n+                ty::TyRawPtr(_) => {\n+                    // simple cases that are WF if their type args are WF\n+                }\n+\n+                ty::TyProjection(data) => {\n+                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    self.compute_projection(data);\n+                }\n+\n+                ty::TyEnum(def, substs) |\n+                ty::TyStruct(def, substs) => {\n+                    // WfNominalType\n+                    let obligations = self.nominal_obligations(def.did, substs);\n+                    self.out.extend(obligations);\n+                }\n+\n+                ty::TyRef(r, mt) => {\n+                    // WfReference\n+                    if !r.has_escaping_regions() && !mt.ty.has_escaping_regions() {\n+                        let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                        self.out.push(\n+                            traits::Obligation::new(\n+                                cause,\n+                                ty::Predicate::TypeOutlives(\n+                                    ty::Binder(\n+                                        ty::OutlivesPredicate(mt.ty, *r)))));\n+                    }\n+                }\n+\n+                ty::TyClosure(..) => {\n+                    // the types in a closure are always the types of\n+                    // local variables (or possibly references to local\n+                    // variables), which are separately checked w/r/t\n+                    // WFedness.\n+                }\n+\n+                ty::TyBareFn(..) => {\n+                    // process the bound types; because the old implicator\n+                    // did not do this, go into RFC1214 mode.\n+                    subtys.skip_current_subtree();\n+                    self.compute_rfc1214(ty);\n+                }\n+\n+                ty::TyTrait(ref data) => {\n+                    // WfObject\n+                    //\n+                    // Here, we defer WF checking due to higher-ranked\n+                    // regions. This is perhaps not ideal.\n+                    self.from_object_ty(ty, data);\n+\n+                    // FIXME(#27579) RFC also considers adding trait\n+                    // obligations that don't refer to Self and\n+                    // checking those\n+\n+                    let cause = self.cause(traits::MiscObligation);\n+                    self.out.push(\n+                        traits::Obligation::new(\n+                            cause,\n+                            ty::Predicate::ObjectSafe(data.principal_def_id())));\n+\n+                    // process the bound types; because the old implicator\n+                    // did not do this, go into RFC1214 mode.\n+                    subtys.skip_current_subtree();\n+                    self.compute_rfc1214(ty);\n+                }\n+\n+                // Inference variables are the complicated case, since we don't\n+                // know what type they are. We do two things:\n+                //\n+                // 1. Check if they have been resolved, and if so proceed with\n+                //    THAT type.\n+                // 2. If not, check whether this is the type that we\n+                //    started with (ty0). In that case, we've made no\n+                //    progress at all, so return false. Otherwise,\n+                //    we've at least simplified things (i.e., we went\n+                //    from `Vec<$0>: WF` to `$0: WF`, so we can\n+                //    register a pending obligation and keep\n+                //    moving. (Goal is that an \"inductive hypothesis\"\n+                //    is satisfied to ensure termination.)\n+                ty::TyInfer(_) => {\n+                    let ty = self.infcx.shallow_resolve(ty);\n+                    if let ty::TyInfer(_) = ty.sty { // not yet resolved...\n+                        if ty == ty0 { // ...this is the type we started from! no progress.\n+                            return false;\n+                        }\n+\n+                        let cause = self.cause(traits::MiscObligation);\n+                        self.out.push( // ...not the type we started from, so we made progress.\n+                            traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+                    } else {\n+                        // Yes, resolved, proceed with the\n+                        // result. Should never return false because\n+                        // `ty` is not a TyInfer.\n+                        assert!(self.compute(ty));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // if we made it through that loop above, we made progress!\n+        return true;\n+    }\n+\n+    fn nominal_obligations(&mut self,\n+                           def_id: ast::DefId,\n+                           substs: &Substs<'tcx>)\n+                           -> Vec<traits::PredicateObligation<'tcx>>\n+    {\n+        let predicates =\n+            self.infcx.tcx.lookup_predicates(def_id)\n+                          .instantiate(self.infcx.tcx, substs);\n+        let cause = self.cause(traits::ItemObligation(def_id));\n+        predicates.predicates\n+                  .into_iter()\n+                  .map(|pred| traits::Obligation::new(cause.clone(), pred))\n+                  .filter(|pred| !pred.has_escaping_regions())\n+                  .collect()\n+    }\n+\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitTy<'tcx>) {\n+        // Imagine a type like this:\n+        //\n+        //     trait Foo { }\n+        //     trait Bar<'c> : 'c { }\n+        //\n+        //     &'b (Foo+'c+Bar<'d>)\n+        //         ^\n+        //\n+        // In this case, the following relationships must hold:\n+        //\n+        //     'b <= 'c\n+        //     'd <= 'c\n+        //\n+        // The first conditions is due to the normal region pointer\n+        // rules, which say that a reference cannot outlive its\n+        // referent.\n+        //\n+        // The final condition may be a bit surprising. In particular,\n+        // you may expect that it would have been `'c <= 'd`, since\n+        // usually lifetimes of outer things are conservative\n+        // approximations for inner things. However, it works somewhat\n+        // differently with trait objects: here the idea is that if the\n+        // user specifies a region bound (`'c`, in this case) it is the\n+        // \"master bound\" that *implies* that bounds from other traits are\n+        // all met. (Remember that *all bounds* in a type like\n+        // `Foo+Bar+Zed` must be met, not just one, hence if we write\n+        // `Foo<'x>+Bar<'y>`, we know that the type outlives *both* 'x and\n+        // 'y.)\n+        //\n+        // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n+        // am looking forward to the future here.\n+\n+        if !data.has_escaping_regions() {\n+            let implicit_bounds =\n+                object_region_bounds(self.infcx.tcx,\n+                                     &data.principal,\n+                                     data.bounds.builtin_bounds);\n+\n+            let explicit_bound = data.bounds.region_bound;\n+\n+            for implicit_bound in implicit_bounds {\n+                let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n+                self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n+            }\n+        }\n+    }\n+}\n+\n+/// Given an object type like `SomeTrait+Send`, computes the lifetime\n+/// bounds that must hold on the elided self type. These are derived\n+/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n+/// they declare `trait SomeTrait : 'static`, for example, then\n+/// `'static` would appear in the list. The hard work is done by\n+/// `ty::required_region_bounds`, see that for more information.\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    principal: &ty::PolyTraitRef<'tcx>,\n+    others: ty::BuiltinBounds)\n+    -> Vec<ty::Region>\n+{\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n+\n+    // Note that we preserve the overall binding levels here.\n+    assert!(!open_ty.has_escaping_regions());\n+    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n+\n+    let mut predicates = others.to_predicates(tcx, open_ty);\n+    predicates.extend(trait_refs.iter().map(|t| t.to_predicate()));\n+\n+    tcx.required_region_bounds(open_ty, predicates)\n+}\n+"}, {"sha": "64cde0fccabaad9f49070d454260428e2b842916", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928955296e28cea5045fb726d6e3fb47780f8c48/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=928955296e28cea5045fb726d6e3fb47780f8c48", "patch": "@@ -52,7 +52,7 @@ use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def;\n-use middle::implicator::object_region_bounds;\n+use middle::wf::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};"}]}