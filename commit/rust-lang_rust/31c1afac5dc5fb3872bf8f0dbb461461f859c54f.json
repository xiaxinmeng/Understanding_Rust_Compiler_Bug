{"sha": "31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYzFhZmFjNWRjNWZiMzg3MmJmOGYwZGJiNDYxNDYxZjg1OWM1NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T15:30:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-09T15:30:50Z"}, "message": "Auto merge of #1797 - atsmtat:env-isolation, r=RalfJung\n\nfix: avoid stopping machine upon running env operations in isolation\n\nget and set current dir operations used to halt the machine by\nthrowing an exception in isolation mode. This change updates them to\nreturn a dummy `NotFound` error instead, and keep the machine running.\n\nI started with a custom error using `ErrorKind::Other`, but since it\ncan't be mapped to a raw OS error, I dropped it. `NotFound` kind of make\nsense for get operations, but not much for set operations. But that's\nthe only error supported for windows currently.", "tree": {"sha": "89be9509fc00abf77fdaa75d1d8c8dfe2de2d9ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89be9509fc00abf77fdaa75d1d8c8dfe2de2d9ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "html_url": "https://github.com/rust-lang/rust/commit/31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f73db5ce6b4666a1663fe674d20ed541ce860b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f73db5ce6b4666a1663fe674d20ed541ce860b0e", "html_url": "https://github.com/rust-lang/rust/commit/f73db5ce6b4666a1663fe674d20ed541ce860b0e"}, {"sha": "ba64f485c881052c980648bed0b4ce29fb6dc19c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba64f485c881052c980648bed0b4ce29fb6dc19c", "html_url": "https://github.com/rust-lang/rust/commit/ba64f485c881052c980648bed0b4ce29fb6dc19c"}], "stats": {"total": 275, "additions": 215, "deletions": 60}, "files": [{"sha": "f6b46ce3a95c56ab922334c296281cc0123ba71a", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -219,6 +219,13 @@ environment variable:\n * `-Zmiri-disable-isolation` disables host isolation.  As a consequence,\n   the program has access to host resources such as environment variables, file\n   systems, and randomness.\n+* `-Zmiri-isolation-error=<action>` configures Miri's response to operations\n+  requiring host access while isolation is enabled. `abort`, `hide`, `warn`,\n+  and `warn-nobacktrace` are the supported actions. Default action is `abort`\n+  which halts the machine. Rest of the actions configure it to return an error\n+  code for the op and continue executing. `warn` prints backtrace that could\n+  be used to trace the call. `warn-nobacktrace` is less verbose without\n+  backtrace. `hide` hides the warning.\n * `-Zmiri-env-exclude=<var>` keeps the `var` environment variable isolated from\n   the host so that it cannot be accessed by the program.  Can be used multiple\n   times to exclude several variables.  On Windows, the `TERM` environment"}, {"sha": "677836d7e9725f5e0a55ff0d5717f3e5c2b7c330", "filename": "src/bin/miri.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -263,6 +263,9 @@ fn main() {\n     let mut miri_config = miri::MiriConfig::default();\n     let mut rustc_args = vec![];\n     let mut after_dashdash = false;\n+\n+    // If user has explicitly enabled/disabled isolation\n+    let mut isolation_enabled: Option<bool> = None;\n     for arg in env::args() {\n         if rustc_args.is_empty() {\n             // Very first arg: binary name.\n@@ -291,7 +294,37 @@ fn main() {\n                     miri_config.check_abi = false;\n                 }\n                 \"-Zmiri-disable-isolation\" => {\n-                    miri_config.communicate = true;\n+                    if matches!(isolation_enabled, Some(true)) {\n+                        panic!(\n+                            \"-Zmiri-disable-isolation cannot be used along with -Zmiri-isolation-error\"\n+                        );\n+                    } else {\n+                        isolation_enabled = Some(false);\n+                    }\n+                    miri_config.isolated_op = miri::IsolatedOp::Allow;\n+                }\n+                arg if arg.starts_with(\"-Zmiri-isolation-error=\") => {\n+                    if matches!(isolation_enabled, Some(false)) {\n+                        panic!(\n+                            \"-Zmiri-isolation-error cannot be used along with -Zmiri-disable-isolation\"\n+                        );\n+                    } else {\n+                        isolation_enabled = Some(true);\n+                    }\n+\n+                    miri_config.isolated_op = match arg\n+                        .strip_prefix(\"-Zmiri-isolation-error=\")\n+                        .unwrap()\n+                    {\n+                        \"abort\" => miri::IsolatedOp::Reject(miri::RejectOpWith::Abort),\n+                        \"hide\" => miri::IsolatedOp::Reject(miri::RejectOpWith::NoWarning),\n+                        \"warn\" => miri::IsolatedOp::Reject(miri::RejectOpWith::Warning),\n+                        \"warn-nobacktrace\" =>\n+                            miri::IsolatedOp::Reject(miri::RejectOpWith::WarningWithoutBacktrace),\n+                        _ => panic!(\n+                            \"-Zmiri-isolation-error must be `abort`, `hide`, `warn`, or `warn-nobacktrace`\"\n+                        ),\n+                    };\n                 }\n                 \"-Zmiri-ignore-leaks\" => {\n                     miri_config.ignore_leaks = true;"}, {"sha": "2b17e83bee69897a33373cff29dcbfca08ae15e1", "filename": "src/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -52,6 +52,14 @@ pub enum NonHaltingDiagnostic {\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),\n+    RejectedIsolatedOp(String),\n+}\n+\n+/// Level of Miri specific diagnostics\n+enum DiagLevel {\n+    Error,\n+    Warning,\n+    Note,\n }\n \n /// Emit a custom diagnostic without going through the miri-engine machinery\n@@ -76,7 +84,7 @@ pub fn report_error<'tcx, 'mir>(\n             #[rustfmt::skip]\n             let helps = match info {\n                 UnsupportedInIsolation(_) =>\n-                    vec![(None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation\"))],\n+                    vec![(None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation; or pass `-Zmiri-isolation-error=warn to configure Miri to return an error code from isolated operations and continue with a warning\"))],\n                 ExperimentalUb { url, .. } =>\n                     vec![\n                         (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\")),\n@@ -137,7 +145,7 @@ pub fn report_error<'tcx, 'mir>(\n     let msg = e.to_string();\n     report_msg(\n         *ecx.tcx,\n-        /*error*/ true,\n+        DiagLevel::Error,\n         &if let Some(title) = title { format!(\"{}: {}\", title, msg) } else { msg.clone() },\n         msg,\n         helps,\n@@ -174,18 +182,19 @@ pub fn report_error<'tcx, 'mir>(\n /// Also emits a full stacktrace of the interpreter stack.\n fn report_msg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    error: bool,\n+    diag_level: DiagLevel,\n     title: &str,\n     span_msg: String,\n     mut helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n-    let mut err = if error {\n-        tcx.sess.struct_span_err(span, title)\n-    } else {\n-        tcx.sess.diagnostic().span_note_diag(span, title)\n+    let mut err = match diag_level {\n+        DiagLevel::Error => tcx.sess.struct_span_err(span, title),\n+        DiagLevel::Warning => tcx.sess.struct_span_warn(span, title),\n+        DiagLevel::Note => tcx.sess.diagnostic().span_note_diag(span, title),\n     };\n+\n     // Show main message.\n     if span != DUMMY_SP {\n         err.span_label(span, span_msg);\n@@ -303,15 +312,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     CreatedCallId(id) => format!(\"function call with id {}\", id),\n                     CreatedAlloc(AllocId(id)) => format!(\"created allocation with id {}\", id),\n                     FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {}\", id),\n+                    RejectedIsolatedOp(ref op) =>\n+                        format!(\"`{}` was made to return an error due to isolation\", op),\n                 };\n-                report_msg(\n-                    *this.tcx,\n-                    /*error*/ false,\n-                    \"tracking was triggered\",\n-                    msg,\n-                    vec![],\n-                    &stacktrace,\n-                );\n+\n+                let (title, diag_level) = match e {\n+                    RejectedIsolatedOp(_) =>\n+                        (\"operation rejected by isolation\", DiagLevel::Warning),\n+                    _ => (\"tracking was triggered\", DiagLevel::Note),\n+                };\n+\n+                report_msg(*this.tcx, diag_level, title, msg, vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "f1fbeafd3cd78c74bf33e8f0757a1f1e2b6dda01", "filename": "src/eval.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -22,6 +22,35 @@ pub enum AlignmentCheck {\n     Int,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum RejectOpWith {\n+    /// Isolated op is rejected with an abort of the machine.\n+    Abort,\n+\n+    /// If not Abort, miri returns an error for an isolated op.\n+    /// Following options determine if user should be warned about such error.\n+    /// Do not print warning about rejected isolated op.\n+    NoWarning,\n+\n+    /// Print a warning about rejected isolated op, with backtrace.\n+    Warning,\n+\n+    /// Print a warning about rejected isolated op, without backtrace.\n+    WarningWithoutBacktrace,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum IsolatedOp {\n+    /// Reject an op requiring communication with the host. By\n+    /// default, miri rejects the op with an abort. If not, it returns\n+    /// an error code, and prints a warning about it. Warning levels\n+    /// are controlled by `RejectOpWith` enum.\n+    Reject(RejectOpWith),\n+\n+    /// Execute op requiring communication with the host, i.e. disable isolation.\n+    Allow,\n+}\n+\n /// Configuration needed to spawn a Miri instance.\n #[derive(Clone)]\n pub struct MiriConfig {\n@@ -33,8 +62,8 @@ pub struct MiriConfig {\n     pub check_alignment: AlignmentCheck,\n     /// Controls function [ABI](Abi) checking.\n     pub check_abi: bool,\n-    /// Determines if communication with the host environment is enabled.\n-    pub communicate: bool,\n+    /// Action for an op requiring communication with the host.\n+    pub isolated_op: IsolatedOp,\n     /// Determines if memory leaks should be ignored.\n     pub ignore_leaks: bool,\n     /// Environment variables that should always be isolated from the host.\n@@ -68,7 +97,7 @@ impl Default for MiriConfig {\n             stacked_borrows: true,\n             check_alignment: AlignmentCheck::Int,\n             check_abi: true,\n-            communicate: false,\n+            isolated_op: IsolatedOp::Reject(RejectOpWith::Abort),\n             ignore_leaks: false,\n             excluded_env_vars: vec![],\n             args: vec![],\n@@ -233,7 +262,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n                     assert!(\n-                        ecx.machine.communicate,\n+                        ecx.machine.communicate(),\n                         \"scheduler callbacks require disabled isolation, but the code \\\n                         that created the callback did not check it\"\n                     );"}, {"sha": "8bfc65111d4926f36ff6d2ff9a08f42044490dbe", "filename": "src/helpers.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -140,7 +140,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let mut data = vec![0; usize::try_from(len).unwrap()];\n \n-        if this.machine.communicate {\n+        if this.machine.communicate() {\n             // Fill the buffer using the host's rng.\n             getrandom::getrandom(&mut data)\n                 .map_err(|err| err_unsup_format!(\"host getrandom failed: {}\", err))?;\n@@ -391,12 +391,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// disabled. It returns an error using the `name` of the foreign function if this is not the\n     /// case.\n     fn check_no_isolation(&self, name: &str) -> InterpResult<'tcx> {\n-        if !self.eval_context_ref().machine.communicate {\n-            isolation_error(name)?;\n+        if !self.eval_context_ref().machine.communicate() {\n+            self.reject_in_isolation(name, RejectOpWith::Abort)?;\n         }\n         Ok(())\n     }\n \n+    /// Helper function used inside the shims of foreign functions which reject the op\n+    /// when isolation is enabled. It is used to print a warning/backtrace about the rejection.\n+    fn reject_in_isolation(&self, op_name: &str, reject_with: RejectOpWith) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        match reject_with {\n+            RejectOpWith::Abort => isolation_abort_error(op_name),\n+            RejectOpWith::WarningWithoutBacktrace => {\n+                this.tcx\n+                    .sess\n+                    .warn(&format!(\"`{}` was made to return an error due to isolation\", op_name));\n+                Ok(())\n+            }\n+            RejectOpWith::Warning => {\n+                register_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n+                Ok(())\n+            }\n+            RejectOpWith::NoWarning => Ok(()), // no warning\n+        }\n+    }\n+\n     /// Helper function used inside the shims of foreign functions to assert that the target OS\n     /// is `target_os`. It panics showing a message with the `name` of the foreign function\n     /// if this is not the case.\n@@ -440,15 +460,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.read_scalar(&errno_place.into())?.check_init()\n     }\n \n-    /// Sets the last OS error using a `std::io::Error`. This function tries to produce the most\n+    /// Sets the last OS error using a `std::io::ErrorKind`. This function tries to produce the most\n     /// similar OS error from the `std::io::ErrorKind` and sets it as the last OS error.\n-    fn set_last_error_from_io_error(&mut self, e: std::io::Error) -> InterpResult<'tcx> {\n+    fn set_last_error_from_io_error(&mut self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx> {\n         use std::io::ErrorKind::*;\n         let this = self.eval_context_mut();\n         let target = &this.tcx.sess.target;\n         let target_os = &target.os;\n         let last_error = if target.families.contains(&\"unix\".to_owned()) {\n-            this.eval_libc(match e.kind() {\n+            this.eval_libc(match err_kind {\n                 ConnectionRefused => \"ECONNREFUSED\",\n                 ConnectionReset => \"ECONNRESET\",\n                 PermissionDenied => \"EPERM\",\n@@ -464,18 +484,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 AlreadyExists => \"EEXIST\",\n                 WouldBlock => \"EWOULDBLOCK\",\n                 _ => {\n-                    throw_unsup_format!(\"io error {} cannot be transformed into a raw os error\", e)\n+                    throw_unsup_format!(\n+                        \"io error {:?} cannot be transformed into a raw os error\",\n+                        err_kind\n+                    )\n                 }\n             })?\n         } else if target.families.contains(&\"windows\".to_owned()) {\n             // FIXME: we have to finish implementing the Windows equivalent of this.\n             this.eval_windows(\n                 \"c\",\n-                match e.kind() {\n+                match err_kind {\n                     NotFound => \"ERROR_FILE_NOT_FOUND\",\n                     _ => throw_unsup_format!(\n-                        \"io error {} cannot be transformed into a raw os error\",\n-                        e\n+                        \"io error {:?} cannot be transformed into a raw os error\",\n+                        err_kind\n                     ),\n                 },\n             )?\n@@ -501,7 +524,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match result {\n             Ok(ok) => Ok(ok),\n             Err(e) => {\n-                self.eval_context_mut().set_last_error_from_io_error(e)?;\n+                self.eval_context_mut().set_last_error_from_io_error(e.kind())?;\n                 Ok((-1).into())\n             }\n         }\n@@ -651,7 +674,7 @@ where\n     throw_ub_format!(\"incorrect number of arguments: got {}, expected {}\", args.len(), N)\n }\n \n-pub fn isolation_error(name: &str) -> InterpResult<'static> {\n+pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n     throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n         \"{} not available when isolation is enabled\",\n         name,"}, {"sha": "8c0a19b6dfbdc713ca1689b422b1a920ea41e0e8", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -59,7 +59,9 @@ pub use crate::diagnostics::{\n     register_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n     NonHaltingDiagnostic, TerminationInfo,\n };\n-pub use crate::eval::{create_ecx, eval_main, AlignmentCheck, MiriConfig};\n+pub use crate::eval::{\n+    create_ecx, eval_main, AlignmentCheck, IsolatedOp, MiriConfig, RejectOpWith,\n+};\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{\n     AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,"}, {"sha": "752d21344825043a77a8bff3af6ae97c16b149c9", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -263,9 +263,10 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n \n-    /// If enabled, the `env_vars` field is populated with the host env vars during initialization\n-    /// and random number generation is delegated to the host.\n-    pub(crate) communicate: bool,\n+    /// What should Miri do when an op requires communicating with the host,\n+    /// such as accessing host env vars, random number generation, and\n+    /// file system access.\n+    pub(crate) isolated_op: IsolatedOp,\n \n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n@@ -314,7 +315,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             argv: None,\n             cmd_line: None,\n             tls: TlsData::default(),\n-            communicate: config.communicate,\n+            isolated_op: config.isolated_op,\n             validate: config.validate,\n             enforce_abi: config.check_abi,\n             file_handler: Default::default(),\n@@ -328,6 +329,10 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             exported_symbols_cache: FxHashMap::default(),\n         }\n     }\n+\n+    pub(crate) fn communicate(&self) -> bool {\n+        self.isolated_op == IsolatedOp::Allow\n+    }\n }\n \n /// A rustc InterpCx for Miri."}, {"sha": "2ce0fbfdc949c7733a2c96f4c79e36f86631bee3", "filename": "src/shims/env.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -1,6 +1,7 @@\n use std::convert::TryFrom;\n use std::env;\n use std::ffi::{OsStr, OsString};\n+use std::io::ErrorKind;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_mir::interpret::Pointer;\n@@ -45,7 +46,7 @@ impl<'tcx> EnvVars<'tcx> {\n             excluded_env_vars.push(\"TERM\".to_owned());\n         }\n \n-        if ecx.machine.communicate {\n+        if ecx.machine.communicate() {\n             for (name, value) in env::vars() {\n                 if !excluded_env_vars.contains(&name) {\n                     let var_ptr = match target_os {\n@@ -321,7 +322,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`getcwd` is only available for the UNIX target family\"\n         );\n \n-        this.check_no_isolation(\"`getcwd`\")?;\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"getcwd\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::NotFound)?;\n+            return Ok(Scalar::null_ptr(&*this.tcx));\n+        }\n \n         let buf = this.read_scalar(&buf_op)?.check_init()?;\n         let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n@@ -334,8 +339,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let erange = this.eval_libc(\"ERANGE\")?;\n                 this.set_last_error(erange)?;\n             }\n-            Err(e) => this.set_last_error_from_io_error(e)?,\n+            Err(e) => this.set_last_error_from_io_error(e.kind())?,\n         }\n+\n         Ok(Scalar::null_ptr(&*this.tcx))\n     }\n \n@@ -348,7 +354,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n \n-        this.check_no_isolation(\"`GetCurrentDirectoryW`\")?;\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"GetCurrentDirectoryW\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::NotFound)?;\n+            return Ok(0);\n+        }\n \n         let size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n         let buf = this.read_scalar(buf_op)?.check_init()?;\n@@ -357,7 +367,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match env::current_dir() {\n             Ok(cwd) =>\n                 return Ok(windows_check_buffer_size(this.write_path_to_wide_str(&cwd, buf, size)?)),\n-            Err(e) => this.set_last_error_from_io_error(e)?,\n+            Err(e) => this.set_last_error_from_io_error(e.kind())?,\n         }\n         Ok(0)\n     }\n@@ -370,14 +380,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`getcwd` is only available for the UNIX target family\"\n         );\n \n-        this.check_no_isolation(\"`chdir`\")?;\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"chdir\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::NotFound)?;\n+\n+            return Ok(-1);\n+        }\n \n         let path = this.read_path_from_c_str(this.read_scalar(path_op)?.check_init()?)?;\n \n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),\n             Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n+                this.set_last_error_from_io_error(e.kind())?;\n                 Ok(-1)\n             }\n         }\n@@ -393,14 +408,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n \n-        this.check_no_isolation(\"`SetCurrentDirectoryW`\")?;\n+        if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n+            this.reject_in_isolation(\"SetCurrentDirectoryW\", reject_with)?;\n+            this.set_last_error_from_io_error(ErrorKind::NotFound)?;\n+\n+            return Ok(0);\n+        }\n \n         let path = this.read_path_from_wide_str(this.read_scalar(path_op)?.check_init()?)?;\n \n         match env::set_current_dir(path) {\n             Ok(()) => Ok(1),\n             Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n+                this.set_last_error_from_io_error(e.kind())?;\n                 Ok(0)\n             }\n         }"}, {"sha": "fbef9f304071328f58ac429d59d2ad16ce3eeb6e", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -127,7 +127,7 @@ impl FileDescriptor for io::Stdin {\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         if !communicate_allowed {\n             // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n-            helpers::isolation_error(\"`read` from stdin\")?;\n+            helpers::isolation_abort_error(\"`read` from stdin\")?;\n         }\n         Ok(Read::read(self, bytes))\n     }\n@@ -634,7 +634,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     match dup_result {\n                         Ok(dup_fd) => Ok(fh.insert_fd_with_min_fd(dup_fd, start)),\n                         Err(e) => {\n-                            this.set_last_error_from_io_error(e)?;\n+                            this.set_last_error_from_io_error(e.kind())?;\n                             Ok(-1)\n                         }\n                     }\n@@ -662,7 +662,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.remove(&fd) {\n-            let result = file_descriptor.close(this.machine.communicate)?;\n+            let result = file_descriptor.close(this.machine.communicate())?;\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -687,6 +687,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We cap the number of read bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n+        let communicate = this.machine.communicate();\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             trace!(\"read: FD mapped to {:?}\", file_descriptor);\n@@ -696,9 +697,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let mut bytes = vec![0; count as usize];\n             // `File::read` never returns a value larger than `count`,\n             // so this cannot fail.\n-            let result = file_descriptor\n-                .read(this.machine.communicate, &mut bytes)?\n-                .map(|c| i64::try_from(c).unwrap());\n+            let result =\n+                file_descriptor.read(communicate, &mut bytes)?.map(|c| i64::try_from(c).unwrap());\n \n             match result {\n                 Ok(read_bytes) => {\n@@ -707,7 +707,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     Ok(read_bytes)\n                 }\n                 Err(e) => {\n-                    this.set_last_error_from_io_error(e)?;\n+                    this.set_last_error_from_io_error(e.kind())?;\n                     Ok(-1)\n                 }\n             }\n@@ -733,12 +733,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We cap the number of written bytes to the largest value that we are able to fit in both the\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n+        let communicate = this.machine.communicate();\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-            let result = file_descriptor\n-                .write(this.machine.communicate, &bytes)?\n-                .map(|c| i64::try_from(c).unwrap());\n+            let result =\n+                file_descriptor.write(communicate, &bytes)?.map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -771,9 +771,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         };\n \n+        let communicate = this.machine.communicate();\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             let result = file_descriptor\n-                .seek(this.machine.communicate, seek_from)?\n+                .seek(communicate, seek_from)?\n                 .map(|offset| i64::try_from(offset).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n@@ -1117,7 +1118,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(Scalar::from_machine_usize(id, this))\n             }\n             Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n+                this.set_last_error_from_io_error(e.kind())?;\n                 Ok(Scalar::null_ptr(this))\n             }\n         }\n@@ -1461,7 +1462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(path_bytes.len().try_into().unwrap())\n             }\n             Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n+                this.set_last_error_from_io_error(e.kind())?;\n                 Ok(-1)\n             }\n         }\n@@ -1525,7 +1526,7 @@ impl FileMetadata {\n         let metadata = match metadata {\n             Ok(metadata) => metadata,\n             Err(e) => {\n-                ecx.set_last_error_from_io_error(e)?;\n+                ecx.set_last_error_from_io_error(e.kind())?;\n                 return Ok(None);\n             }\n         };"}, {"sha": "ea891c8998342f258cbbd79b70c17d365cd8bc17", "filename": "tests/run-pass/current_dir_with_isolation.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/tests%2Frun-pass%2Fcurrent_dir_with_isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/tests%2Frun-pass%2Fcurrent_dir_with_isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcurrent_dir_with_isolation.rs?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n+// normalize-stderr-test \"(getcwd|GetCurrentDirectoryW)\" -> \"$$GET\"\n+// normalize-stderr-test \"(chdir|SetCurrentDirectoryW)\" -> \"$$SET\"\n+\n+use std::env;\n+use std::io::ErrorKind;\n+\n+fn main() {\n+    // Test that current dir operations return a proper error instead\n+    // of stopping the machine in isolation mode\n+    assert_eq!(env::current_dir().unwrap_err().kind(), ErrorKind::NotFound);\n+    for _i in 0..3 {\n+        assert_eq!(env::current_dir().unwrap_err().kind(), ErrorKind::NotFound);\n+    }\n+\n+    assert_eq!(env::set_current_dir(\"..\").unwrap_err().kind(), ErrorKind::NotFound);\n+    for _i in 0..3 {\n+        assert_eq!(env::set_current_dir(\"..\").unwrap_err().kind(), ErrorKind::NotFound);\n+    }\n+}"}, {"sha": "cc0975230de68a51a13a9babc0b70f0378d52ef0", "filename": "tests/run-pass/current_dir_with_isolation.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/tests%2Frun-pass%2Fcurrent_dir_with_isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c1afac5dc5fb3872bf8f0dbb461461f859c54f/tests%2Frun-pass%2Fcurrent_dir_with_isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcurrent_dir_with_isolation.stderr?ref=31c1afac5dc5fb3872bf8f0dbb461461f859c54f", "patch": "@@ -0,0 +1,4 @@\n+warning: `$GET` was made to return an error due to isolation\n+\n+warning: `$SET` was made to return an error due to isolation\n+"}]}