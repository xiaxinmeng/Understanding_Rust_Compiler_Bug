{"sha": "325c31e578210d0c72d8d5f1612074ddcbe514bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNWMzMWU1NzgyMTBkMGM3MmQ4ZDVmMTYxMjA3NGRkY2JlNTE0YmI=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-16T04:25:12Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Address some of the reviewers comments.", "tree": {"sha": "9fd72a258723738e591a4ddeb231da289f6fc5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd72a258723738e591a4ddeb231da289f6fc5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/325c31e578210d0c72d8d5f1612074ddcbe514bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/325c31e578210d0c72d8d5f1612074ddcbe514bb", "html_url": "https://github.com/rust-lang/rust/commit/325c31e578210d0c72d8d5f1612074ddcbe514bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/325c31e578210d0c72d8d5f1612074ddcbe514bb/comments", "author": null, "committer": null, "parents": [{"sha": "51b16e56cd297afd308aea5b258a677901c7b45e", "url": "https://api.github.com/repos/rust-lang/rust/commits/51b16e56cd297afd308aea5b258a677901c7b45e", "html_url": "https://github.com/rust-lang/rust/commit/51b16e56cd297afd308aea5b258a677901c7b45e"}], "stats": {"total": 175, "additions": 101, "deletions": 74}, "files": [{"sha": "d83039e475684b361ee9a64be8fd39e43ebd1564", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -206,7 +206,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n     let res: InterpResult<'_, i64> = (|| {\n         // Main loop.\n         while ecx.schedule()? {\n-            assert!(ecx.step()?);\n+            assert!(ecx.step()?, \"Bug: a terminated thread was scheduled for execution.\");\n             ecx.process_diagnostics();\n         }\n         // Read the return code pointer *before* we run TLS destructors, to assert"}, {"sha": "0920364a44a8ed28cb41a61ee380e958b26a510f", "filename": "src/machine.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -428,41 +428,37 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n                 let alloc_id = ptr.alloc_id;\n                 let alloc = ecx.tcx.alloc_map.lock().get(alloc_id);\n+                let tcx = ecx.tcx;\n+                let is_thread_local = |def_id| {\n+                    tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                };\n                 match alloc {\n-                    Some(GlobalAlloc::Static(def_id))\n-                        if ecx\n-                            .tcx\n-                            .codegen_fn_attrs(def_id)\n-                            .flags\n-                            .contains(CodegenFnAttrFlags::THREAD_LOCAL) =>\n-                    {\n-                        // We have a thread-local static.\n+                    Some(GlobalAlloc::Static(def_id)) if is_thread_local(def_id) => {\n                         let new_alloc_id = if let Some(new_alloc_id) =\n                             ecx.get_thread_local_alloc_id(alloc_id)\n                         {\n                             new_alloc_id\n                         } else {\n-                            if ecx.tcx.is_foreign_item(def_id) {\n+                            if tcx.is_foreign_item(def_id) {\n                                 throw_unsup_format!(\n                                     \"Foreign thread-local statics are not supported.\"\n                                 )\n                             }\n-                            let instance = Instance::mono(ecx.tcx.tcx, def_id);\n+                            let instance = Instance::mono(tcx.tcx, def_id);\n                             let gid = GlobalId { instance, promoted: None };\n-                            let raw_const = ecx\n-                                .tcx\n+                            let raw_const = tcx\n                                 .const_eval_raw(ty::ParamEnv::reveal_all().and(gid))\n                                 .map_err(|err| {\n                                     // no need to report anything, the const_eval call takes care of that\n                                     // for statics\n-                                    assert!(ecx.tcx.is_static(def_id));\n+                                    assert!(tcx.is_static(def_id));\n                                     match err {\n                                         ErrorHandled::Reported => err_inval!(ReferencedConstant),\n                                         ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n                                     }\n                                 })?;\n                             let id = raw_const.alloc_id;\n-                            let mut alloc_map = ecx.tcx.alloc_map.lock();\n+                            let mut alloc_map = tcx.alloc_map.lock();\n                             let allocation = alloc_map.unwrap_memory(id);\n                             let new_alloc_id = alloc_map.create_memory_alloc(allocation);\n                             ecx.set_thread_local_alloc_id(alloc_id, new_alloc_id);"}, {"sha": "5bb556aaa50b035d50d4e0d9b31c0bc1d7dab1ab", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -293,26 +293,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n-            // Miscellaneous\n-            \"isatty\" => {\n-                let _fd = this.read_scalar(args[0])?.to_i32()?;\n-                // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n-                // FIXME: we just say nothing is a terminal.\n-                let enotty = this.eval_libc(\"ENOTTY\")?;\n-                this.set_last_error(enotty)?;\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_atfork\" => {\n-                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n-                let _parent = this.read_scalar(args[1])?.not_undef()?;\n-                let _child = this.read_scalar(args[1])?.not_undef()?;\n-                // We do not support forking, so there is nothing to do here.\n-                this.write_null(dest)?;\n-            }\n-            \"sched_yield\" => {\n-                this.write_null(dest)?;\n-            }\n-\n             // Threading\n             \"pthread_create\" => {\n                 assert_eq!(args.len(), 4);\n@@ -339,20 +319,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n-            \"pthread_attr_getguardsize\" => {\n-                assert_eq!(args.len(), 2);\n-\n-                let guard_size = this.deref_operand(args[1])?;\n-                let guard_size_type = args[1].layout.ty\n-                    .builtin_deref(true)\n-                    .ok_or_else(|| err_ub_format!(\n-                        \"wrong signature used for `pthread_attr_getguardsize`: first argument must be a raw pointer.\"\n-                    ))?\n-                    .ty;\n-                let guard_size_layout = this.layout_of(guard_size_type)?;\n-                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), guard_size.into())?;\n-\n-                // Return success (`0`).\n+            // Miscellaneous\n+            \"isatty\" => {\n+                let _fd = this.read_scalar(args[0])?.to_i32()?;\n+                // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n+                // FIXME: we just say nothing is a terminal.\n+                let enotty = this.eval_libc(\"ENOTTY\")?;\n+                this.set_last_error(enotty)?;\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_atfork\" => {\n+                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n+                let _parent = this.read_scalar(args[1])?.not_undef()?;\n+                let _child = this.read_scalar(args[1])?.not_undef()?;\n+                // We do not support forking, so there is nothing to do here.\n                 this.write_null(dest)?;\n             }\n \n@@ -369,6 +349,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             => {\n                 this.write_null(dest)?;\n             }\n+            \"pthread_attr_getguardsize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n+            => {\n+                let guard_size = this.deref_operand(args[1])?;\n+                let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n+                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), guard_size.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n \n             | \"signal\"\n             | \"sigaction\""}, {"sha": "d8ba11d267f39e3697521cc63df4de28e41a98b1", "filename": "src/shims/threads.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fshims%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fshims%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthreads.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -11,13 +11,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         start_routine: OpTy<'tcx, Tag>,\n         arg: OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n-        println!(\n-            \"WARNING: The thread support is experimental. \\\n-                  For example, Miri does not detect data races yet.\"\n-        );\n-\n         let this = self.eval_context_mut();\n \n+        this.tcx.sess.warn(\n+            \"The thread support is experimental. \\\n+             For example, Miri does not detect data races yet.\",\n+        );\n+\n         let new_thread_id = this.create_thread()?;\n         let old_thread_id = this.set_active_thread(new_thread_id)?;\n \n@@ -57,6 +57,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n     fn pthread_join(\n         &mut self,\n         thread: OpTy<'tcx, Tag>,\n@@ -73,6 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n     fn pthread_detach(&mut self, thread: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -81,12 +83,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n     fn pthread_self(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread()?;\n         this.write_scalar(Scalar::from_uint(thread_id.index() as u128, dest.layout.size), dest)\n     }\n+\n     fn prctl(\n         &mut self,\n         option: OpTy<'tcx, Tag>,"}, {"sha": "c623fcae817dd3f1cddec4ae1b66efced183a074", "filename": "src/threads.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/src%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthreads.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -2,6 +2,7 @@\n \n use std::cell::RefCell;\n use std::convert::TryFrom;\n+use std::num::NonZeroU32;\n \n use log::trace;\n \n@@ -42,21 +43,18 @@ impl ThreadId {\n }\n \n /// An identifier of a set of blocked threads.\n-///\n-/// Note: 0 is not a valid identifier.\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n-pub struct BlockSetId(u32);\n+pub struct BlockSetId(NonZeroU32);\n \n impl From<u32> for BlockSetId {\n     fn from(id: u32) -> Self {\n-        assert_ne!(id, 0, \"0 is not a valid blockset id\");\n-        Self(id)\n+        Self(NonZeroU32::new(id).expect(\"0 is not a valid blockset id\"))\n     }\n }\n \n impl BlockSetId {\n     pub fn to_u32_scalar<'tcx>(&self) -> Scalar<Tag> {\n-        Scalar::from_u32(self.0)\n+        Scalar::from_u32(self.0.get())\n     }\n }\n \n@@ -150,6 +148,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     pub fn get_thread_local_alloc_id(&self, static_alloc_id: AllocId) -> Option<AllocId> {\n         self.thread_local_alloc_ids.borrow().get(&(static_alloc_id, self.active_thread)).cloned()\n     }\n+\n     /// Set the allocation id as the allocation id of the given thread local\n     /// static for the active thread.\n     pub fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, new_alloc_id: AllocId) {\n@@ -161,40 +160,48 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             \"Bug: a thread local initialized twice for the same thread.\"\n         );\n     }\n+\n     /// Borrow the stack of the active thread.\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n+\n     /// Mutably borrow the stack of the active thread.\n     fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n         &mut self.threads[self.active_thread].stack\n     }\n+\n     /// Create a new thread and returns its id.\n     fn create_thread(&mut self) -> ThreadId {\n         let new_thread_id = ThreadId::new(self.threads.len());\n         self.threads.push(Default::default());\n         new_thread_id\n     }\n+\n     /// Set an active thread and return the id of the thread that was active before.\n     fn set_active_thread_id(&mut self, id: ThreadId) -> ThreadId {\n         let active_thread_id = self.active_thread;\n         self.active_thread = id;\n         assert!(self.active_thread.index() < self.threads.len());\n         active_thread_id\n     }\n+\n     /// Get the id of the currently active thread.\n     fn get_active_thread_id(&self) -> ThreadId {\n         self.active_thread\n     }\n+\n     /// Get the borrow of the currently active thread.\n     fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n         &mut self.threads[self.active_thread]\n     }\n+\n     /// Mark the thread as detached, which means that no other thread will try\n     /// to join it and the thread is responsible for cleaning up.\n     fn detach_thread(&mut self, id: ThreadId) {\n         self.threads[id].detached = true;\n     }\n+\n     /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n     fn join_thread(&mut self, joined_thread_id: ThreadId) {\n         assert!(!self.threads[joined_thread_id].detached, \"Bug: trying to join a detached thread.\");\n@@ -215,23 +222,32 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             );\n         }\n     }\n+\n     /// Set the name of the active thread.\n     fn set_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         self.active_thread_mut().thread_name = Some(new_thread_name);\n     }\n+\n     /// Get ids and states of all threads ever allocated.\n     fn get_all_thread_ids_with_states(&self) -> Vec<(ThreadId, ThreadState)> {\n         self.threads.iter_enumerated().map(|(id, thread)| (id, thread.state)).collect()\n     }\n+\n+    /// Allocate a new blockset id.\n     fn create_blockset(&mut self) -> BlockSetId {\n         self.blockset_counter = self.blockset_counter.checked_add(1).unwrap();\n         self.blockset_counter.into()\n     }\n+\n+    /// Block the currently active thread and put it into the given blockset.\n     fn block_active_thread(&mut self, set: BlockSetId) {\n         let state = &mut self.active_thread_mut().state;\n         assert_eq!(*state, ThreadState::Enabled);\n         *state = ThreadState::Blocked(set);\n     }\n+\n+    /// Unblock any one thread from the given blockset if it contains at least\n+    /// one. Return the id of the unblocked thread.\n     fn unblock_random_thread(&mut self, set: BlockSetId) -> Option<ThreadId> {\n         for (id, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::Blocked(set) {\n@@ -242,6 +258,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         }\n         None\n     }\n+\n     /// Decide which thread to run next.\n     ///\n     /// Returns `false` if all threads terminated.\n@@ -278,60 +295,74 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n         this.machine.threads.get_thread_local_alloc_id(static_alloc_id)\n     }\n+\n     fn set_thread_local_alloc_id(&self, static_alloc_id: AllocId, thread_local_alloc_id: AllocId) {\n         let this = self.eval_context_ref();\n         this.machine.threads.set_thread_local_alloc_id(static_alloc_id, thread_local_alloc_id)\n     }\n+\n     fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.create_thread())\n     }\n+\n     fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.machine.threads.detach_thread(thread_id);\n         Ok(())\n     }\n+\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.machine.threads.join_thread(joined_thread_id);\n         Ok(())\n     }\n+\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.set_active_thread_id(thread_id))\n     }\n+\n     fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_ref();\n         Ok(this.machine.threads.get_active_thread_id())\n     }\n+\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         let this = self.eval_context_ref();\n         this.machine.threads.active_thread_stack()\n     }\n+\n     fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }\n+\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) -> InterpResult<'tcx, ()> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.set_thread_name(new_thread_name))\n     }\n+\n     fn get_all_thread_ids_with_states(&mut self) -> Vec<(ThreadId, ThreadState)> {\n         let this = self.eval_context_mut();\n         this.machine.threads.get_all_thread_ids_with_states()\n     }\n+\n     fn create_blockset(&mut self) -> InterpResult<'tcx, BlockSetId> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.create_blockset())\n     }\n+\n     fn block_active_thread(&mut self, set: BlockSetId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.block_active_thread(set))\n     }\n+\n     fn unblock_random_thread(&mut self, set: BlockSetId) -> InterpResult<'tcx, Option<ThreadId>> {\n         let this = self.eval_context_mut();\n         Ok(this.machine.threads.unblock_random_thread(set))\n     }\n+\n     /// Decide which thread to run next.\n     ///\n     /// Returns `false` if all threads terminated."}, {"sha": "4b9073f3a73ee8566bfdde508d7d036d5242b7a8", "filename": "tests/compile-fail/thread-spawn.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Fcompile-fail%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Fcompile-fail%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fthread-spawn.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -0,0 +1,9 @@\n+// ignore-linux\n+// ignore-macos\n+use std::thread;\n+\n+// error-pattern: Miri does not support threading\n+\n+fn main() {\n+    thread::spawn(|| {});\n+}"}, {"sha": "49935db91bd943fb13dc419f1b6d0a02fd70f784", "filename": "tests/run-pass/concurrency/locks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -1,3 +1,5 @@\n+// ignore-windows\n+\n //! This test just calls the relevant APIs to check if Miri crashes.\n \n use std::sync::{Arc, Mutex};"}, {"sha": "20a2bf3eeb878aa5e2149fb6c634368fbe915a3a", "filename": "tests/run-pass/concurrency/locks.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.stderr?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -0,0 +1,2 @@\n+warning: The thread support is experimental. For example, Miri does not detect data races yet.\n+"}, {"sha": "2486b320db18f0f36113c5daf939c11d21a60468", "filename": "tests/run-pass/concurrency/locks.stdout", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Flocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Flocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flocks.stdout?ref=51b16e56cd297afd308aea5b258a677901c7b45e", "patch": "@@ -1,3 +0,0 @@\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet."}, {"sha": "5adc521f59c22423f0c8be9abc1dddab85816a6e", "filename": "tests/run-pass/concurrency/simple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -1,3 +1,5 @@\n+// ignore-windows\n+\n use std::thread;\n \n fn create_and_detach() {"}, {"sha": "20a2bf3eeb878aa5e2149fb6c634368fbe915a3a", "filename": "tests/run-pass/concurrency/simple.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -0,0 +1,2 @@\n+warning: The thread support is experimental. For example, Miri does not detect data races yet.\n+"}, {"sha": "0506b7bdf83c02ee0294d5df4382eafcea9f3c0c", "filename": "tests/run-pass/concurrency/simple.stdout", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Fsimple.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Fsimple.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.stdout?ref=51b16e56cd297afd308aea5b258a677901c7b45e", "patch": "@@ -1,10 +0,0 @@\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet.\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet."}, {"sha": "1805a1da3d0bf74d13676eecd54bac2add922fb1", "filename": "tests/run-pass/concurrency/thread_locals.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.rs?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -1,3 +1,5 @@\n+// ignore-windows\n+\n #![feature(thread_local)]\n \n use std::thread;"}, {"sha": "20a2bf3eeb878aa5e2149fb6c634368fbe915a3a", "filename": "tests/run-pass/concurrency/thread_locals.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/325c31e578210d0c72d8d5f1612074ddcbe514bb/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr?ref=325c31e578210d0c72d8d5f1612074ddcbe514bb", "patch": "@@ -0,0 +1,2 @@\n+warning: The thread support is experimental. For example, Miri does not detect data races yet.\n+"}, {"sha": "9a53b4a5c913b49107245073949dbaf1065058a9", "filename": "tests/run-pass/concurrency/thread_locals.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/51b16e56cd297afd308aea5b258a677901c7b45e/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stdout?ref=51b16e56cd297afd308aea5b258a677901c7b45e", "patch": "@@ -1 +0,0 @@\n-WARNING: The thread support is experimental. For example, Miri does not detect data races yet."}]}