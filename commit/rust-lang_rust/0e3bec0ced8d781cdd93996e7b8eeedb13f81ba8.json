{"sha": "0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlM2JlYzBjZWQ4ZDc4MWNkZDkzOTk2ZTdiOGVlZWRiMTNmODFiYTg=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-06T18:15:18Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-06T18:15:18Z"}, "message": "Merge remote-tracking branch 'original/incoming' into incoming", "tree": {"sha": "4738dcf131910061f5253ee5ef42960b9aef35f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4738dcf131910061f5253ee5ef42960b9aef35f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "html_url": "https://github.com/rust-lang/rust/commit/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a54837d4ab28219727e1f1e0c131ba6033ba94", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a54837d4ab28219727e1f1e0c131ba6033ba94", "html_url": "https://github.com/rust-lang/rust/commit/d4a54837d4ab28219727e1f1e0c131ba6033ba94"}, {"sha": "f96a2a2ca16a44f869336f7e28fc261551c1184c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f96a2a2ca16a44f869336f7e28fc261551c1184c", "html_url": "https://github.com/rust-lang/rust/commit/f96a2a2ca16a44f869336f7e28fc261551c1184c"}], "stats": {"total": 3666, "additions": 2005, "deletions": 1661}, "files": [{"sha": "4a0bd86b544193fba829dfbc4f4646dd32d58ca6", "filename": "AUTHORS.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -9,9 +9,11 @@ Aleksander Balicki <balicki.aleksander@gmail.com>\n Alex R\u00f8nne Petersen <alex@lycus.org>\n Alexander Stavonin <a.stavonin@gmail.com>\n Andreas Gal <gal@mozilla.com>\n+Andrew Paseltiner <apaseltiner@gmail.com>\n Arkaitz Jimenez <arkaitzj@gmail.com>\n Armin Ronacher <armin.ronacher@active-4.com>\n Austin Seipp <mad.one@gmail.com>\n+auREAX <mark@xn--hwg34fba.ws>\n Ben Blum <bblum@andrew.cmu.edu>\n Ben Striegel <ben.striegel@gmail.com>\n Benjamin Herr <ben@0x539.de>\n@@ -41,6 +43,7 @@ Evan McClanahan <evan@evanmcc.com>\n Francisco Souza <f@souza.cc>\n Gareth Daniel Smith <garethdanielsmith@gmail.com>\n Glenn Willen <gwillen@nerdnet.org>\n+Gon\u00e7alo Cabrita <_@gmcabrita.com>\n Graham Fawcett <fawcett@uwindsor.ca>\n Grahame Bowland <grahame@angrygoats.net>\n Haitao Li <lihaitao@gmail.com>\n@@ -103,4 +106,5 @@ Tomoki Aonuma <uasi@99cm.org>\n Tycho Sci <tychosci@gmail.com>\n Vincent Belliard <vincent@famillebelliard.fr>\n Wade Mealing <wmealing@gmail.com>\n+Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n Zack Corr <zackcorr95@gmail.com>"}, {"sha": "e67ea3af5f382a80ef7305e93aa50a9f566bfc0f", "filename": "configure", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -295,6 +295,7 @@ opt manage-submodules 1 \"let the build manage the git submodules\"\n opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n opt clang 0 \"prefer clang to gcc for building the runtime\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n+opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched kernels)\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n valopt local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt llvm-root \"\" \"set LLVM root\"\n@@ -343,6 +344,11 @@ probe CFG_PDFLATEX         pdflatex\n probe CFG_XETEX            xetex\n probe CFG_LUATEX           luatex\n probe CFG_NODE             nodejs node\n+if [ \"$CFG_OSTYPE\" = \"unknown-linux-gnu\" ]\n+then\n+    probe CFG_PAXCTL           paxctl /sbin/paxctl\n+    probe CFG_ZCAT             zcat\n+fi\n \n if [ ! -z \"$CFG_PANDOC\" ]\n then\n@@ -354,6 +360,51 @@ then\n     fi\n fi\n \n+if [ \"$CFG_OSTYPE\" = \"unknown-linux-gnu\" ]\n+then\n+    if [ ! -z \"$CFG_ENABLE_PAX_FLAGS\" -a -z \"$CFG_PAXCTL\" ]\n+    then\n+        err \"enabled PaX markings but no paxctl binary found\"\n+    fi\n+\n+    if [ -z \"$CFG_DISABLE_PAX_FLAGS\" ]\n+    then\n+        # GRSecurity/PaX detection. This can be very flaky.\n+        GRSEC_DETECTED=\n+\n+        # /dev/grsec only exists if CONFIG_GRKERNSEC_NO_RBAC is not set.\n+        # /proc/sys/kernel/grsecurity is not available if \u00c7ONFIG_GRKERNSEC_SYSCTL is not set.\n+        if [ -e /dev/grsec -o -d /proc/sys/kernel/grsecurity ]\n+        then\n+            GRSEC_DETECTED=1\n+        # /proc/config.gz is normally only available to root, and only if CONFIG_IKCONFIG_PROC has been set.\n+        elif [ -r /proc/config.gz -a ! -z \"$CFG_ZCAT\" ]\n+        then\n+            if \"$CFG_ZCAT\" /proc/config.gz | grep --quiet \"CONFIG_GRKERNSEC=y\"\n+            then\n+                GRSEC_DETECTED=1\n+            fi\n+        # Flaky.\n+        elif grep --quiet grsec /proc/version\n+        then\n+            GRSEC_DETECTED=1\n+        fi\n+\n+        if [ ! -z \"$GRSEC_DETECTED\" ]\n+        then\n+            step_msg \"GRSecurity: yes\"\n+            if [ ! -z \"$CFG_PAXCTL\" ]\n+            then\n+                CFG_ENABLE_PAX_FLAGS=1\n+            else\n+                warn \"GRSecurity kernel detected but no paxctl binary found: not setting CFG_ENABLE_PAX_FLAGS\"\n+            fi\n+        else\n+            step_msg \"GRSecurity: no\"\n+        fi\n+    fi\n+fi\n+\n if [ ! -z \"$CFG_ENABLE_LOCAL_RUST\" ]\n then\n     if [ ! -f ${CFG_LOCAL_RUST_ROOT}/bin/rustc ]\n@@ -523,15 +574,23 @@ then\n     msg \"git: submodule sync\"\n     \"${CFG_GIT}\" submodule --quiet sync\n \n+    msg \"git: submodule update\"\n+    \"${CFG_GIT}\" submodule --quiet update --init\n+    need_ok \"git failed\"\n+\n+    msg \"git: submodule foreach sync\"\n+    \"${CFG_GIT}\" submodule --quiet foreach --recursive git submodule sync\n+    need_ok \"git failed\"\n+\n+    msg \"git: submodule foreach update\"\n+    \"${CFG_GIT}\" submodule --quiet update --init --recursive\n+    need_ok \"git failed\"\n+\n     # NB: this is just for the sake of getting the submodule SHA1 values\n     # and status written into the build log.\n     msg \"git: submodule status\"\n     \"${CFG_GIT}\" submodule status --recursive\n \n-    msg \"git: submodule update\"\n-    \"${CFG_GIT}\" submodule --quiet update --init --recursive\n-    need_ok \"git failed\"\n-\n     msg \"git: submodule clobber\"\n     \"${CFG_GIT}\" submodule --quiet foreach --recursive git clean -dxf\n     need_ok \"git failed\"\n@@ -699,6 +758,12 @@ putvar CFG_C_COMPILER\n putvar CFG_LIBDIR\n putvar CFG_DISABLE_MANAGE_SUBMODULES\n \n+if [ ! -z \"$CFG_ENABLE_PAX_FLAGS\" ]\n+then\n+    putvar CFG_ENABLE_PAX_FLAGS\n+    putvar CFG_PAXCTL\n+fi\n+\n if [ ! -z $BAD_PANDOC ]\n then\n     CFG_PANDOC="}, {"sha": "3a1e60ec42311f91da90401ddbdda2fb74ade2cd", "filename": "doc/prep.js", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Fprep.js", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Fprep.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fprep.js?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -60,9 +60,10 @@ while ((line = lines[cur++]) != null) {\n       var html = '<pre class=\"cm-s-default\">', curstr = \"\", curstyle = null;\n       function add(str, style) {\n         if (style != curstyle) {\n-          if (curstyle) html += '<span class=\"cm-' + curstyle + '\">' + curstr\n-            + \"</span>\";\n-          else if (curstr) html += curstr;\n+          if (curstyle) html +=\n+            '<span class=\"cm-' + CodeMirror.htmlEscape(curstyle) + '\">' +\n+            CodeMirror.htmlEscape(curstr) + \"</span>\";\n+          else if (curstr) html += CodeMirror.htmlEscape(curstr);\n           curstr = str; curstyle = style;\n         } else curstr += str;\n       }"}, {"sha": "66552c29017fd5cc1393ad0bbbfe903f0480117a", "filename": "doc/rust.md", "status": "modified", "additions": 144, "deletions": 133, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -773,8 +773,8 @@ A view item manages the namespace of a module; it does not define new items\n but simply changes the visibility of other items. There are several kinds of\n view item:\n \n- * [extern mod declarations](#extern-mod-declarations)\n- * [use declarations](#use-declarations)\n+ * [`extern mod` declarations](#extern-mod-declarations)\n+ * [`use` declarations](#use-declarations)\n \n ##### Extern mod declarations\n \n@@ -784,7 +784,7 @@ link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n ~~~~~~~~\n \n-An _extern mod declaration_ specifies a dependency on an external crate.\n+An _`extern mod` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident` provided in the `extern_mod_decl`.\n \n The external crate is resolved to a specific `soname` at compile time, and a\n@@ -960,24 +960,12 @@ pure fn pure_length<T>(ls: List<T>) -> uint { ... }\n pure fn nonempty_list<T>(ls: List<T>) -> bool { pure_length(ls) > 0u }\n ~~~~\n \n-*TODO:* should actually define referential transparency.\n-\n-The effect checking rules previously enumerated are a restricted set\n-of typechecking rules meant to approximate the universe of observably\n-referentially transparent Rust procedures conservatively. Sometimes,\n-these rules are *too* restrictive. Rust allows programmers to violate\n-these rules by writing pure functions that the compiler cannot prove\n-to be referentially transparent, using \"unsafe blocks\". When writing\n-code that uses unsafe blocks, programmers should always be aware that\n-they have an obligation to show that the code *behaves* referentially\n-transparently at all times, even if the compiler cannot *prove*\n-automatically that the code is referentially transparent. In the\n-presence of unsafe blocks, the compiler provides no static guarantee\n-that the code will behave as expected at runtime. Rather, the\n-programmer has an independent obligation to verify the semantics of\n-the pure functions they write.\n-\n-*TODO:* last two sentences are vague.\n+These purity-checking rules approximate the concept of referential transparency:\n+that a call-expression could be rewritten with the literal-expression of its return value, without changing the meaning of the program.\n+Since they are an approximation, sometimes these rules are *too* restrictive.\n+Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks).\n+As with any `unsafe` block, those that violate static purity carry transfer the burden of safety-proof from the compiler to the programmer.\n+Programmers should exercise caution when breaking such rules.\n \n An example of a pure function that uses an unsafe block:\n \n@@ -1045,6 +1033,28 @@ Similarly, [trait](#traits) bounds can be specified for type\n parameters to allow methods with that trait to be called on values\n of that type.\n \n+#### Unsafe functions\n+\n+Unsafe functions are those containing unsafe operations that are not contained in an [`unsafe` block](#unsafe-blocks).\n+\n+Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.\n+Specifically, the following operations are considered unsafe:\n+\n+  - Dereferencing a [raw pointer](#pointer-types)\n+  - Casting a [raw pointer](#pointer-types) to a safe pointer type\n+  - Breaking the [purity-checking rules](#pure-functions)\n+  - Calling an unsafe function\n+\n+##### Unsafe blocks\n+\n+A block of code can also be prefixed with the `unsafe` keyword,\n+to permit a sequence of unsafe operations in an otherwise-safe function.\n+This facility exists because the static semantics of a Rust are a necessary approximation of the dynamic semantics.\n+When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe,\n+they can encapsulate that sequence (taken as a whole) within an `unsafe` block.\n+The compiler will consider uses of such code \"safe\", to the surrounding context.\n+\n+\n #### Extern functions\n \n Extern functions are part of Rust's foreign function interface, providing\n@@ -1059,7 +1069,7 @@ extern fn new_vec() -> ~[int] { ~[] }\n ~~~\n \n Extern functions may not be called from Rust code, but their value\n-may be taken as an unsafe `u8` pointer.\n+may be taken as a raw `u8` pointer.\n \n ~~~\n # extern fn new_vec() -> ~[int] { ~[] }\n@@ -1468,6 +1478,25 @@ structure of expressions. Blocks themselves are expressions, so the nesting\n sequence of block, statement, expression, and block can repeatedly nest to an\n arbitrary depth.\n \n+#### Lvalues, rvalues and temporaries\n+\n+Expressions are divided into two main categories: _lvalues_ and _rvalues_.\n+Likewise within each expression, sub-expressions may occur in _lvalue context_ or _rvalue context_.\n+The evaluation of an expression depends both on its own category and the context it occurs within.\n+\n+Path, field and index expressions are lvalues.\n+All other expressions are rvalues.\n+\n+The left operand of an assignment expression and the operand of the borrow operator are lvalue contexts.\n+All other expression contexts are rvalue contexts.\n+\n+When an lvalue is evaluated in an _lvalue context_, it denotes a memory location;\n+when evaluated in an _rvalue context_, it denotes the value held _in_ that memory location.\n+\n+When an rvalue is used in lvalue context, a temporary un-named lvalue is created and used instead.\n+A temporary's lifetime equals the largest lifetime of any borrowed pointer that points to it.\n+\n+\n ### Literal expressions\n \n A _literal expression_ consists of one of the [literal](#literals)\n@@ -1708,9 +1737,9 @@ A type cast expression is denoted with the binary operator `as`.\n Executing an `as` expression casts the value on the left-hand side to the type\n on the right-hand side.\n \n-A numeric value can be cast to any numeric type.  An unsafe pointer value can\n-be cast to or from any integral type or unsafe pointer type.  Any other cast\n-is unsupported and will fail to compile.\n+A numeric value can be cast to any numeric type.\n+A raw pointer value can be cast to or from any integral type or raw pointer type.\n+Any other cast is unsupported and will fail to compile.\n \n An example of an `as` expression:\n \n@@ -2277,30 +2306,25 @@ logging level:\n // Full version, logging a value.\n log(core::error, ~\"file not found: \" + filename);\n \n-// Log-level abbreviated, since core::* is imported by default.\n+// Log-level abbreviated, since core::* is used by default.\n log(error, ~\"file not found: \" + filename);\n \n-// Formatting the message using a format-string and #fmt\n+// Formatting the message using a format-string and fmt!\n log(error, fmt!(\"file not found: %s\", filename));\n \n-// Using the #error macro, that expands to the previous call.\n+// Using the error! macro, that expands to the previous call.\n error!(\"file not found: %s\", filename);\n ~~~~\n \n-A `log` expression is *not evaluated* when logging at the specified\n-logging-level, module or task is disabled at runtime. This makes inactive\n-`log` expressions very cheap; they should be used extensively in Rust\n-code, as diagnostic aids, as they add little overhead beyond a single\n-integer-compare and branch at runtime.\n+A `log` expression is *not evaluated* when logging at the specified logging-level, module or task is disabled at runtime.\n+This makes inactive `log` expressions very cheap;\n+they should be used extensively in Rust code, as diagnostic aids,\n+as they add little overhead beyond a single integer-compare and branch at runtime.\n \n-Logging is presently implemented as a language built-in feature, as it makes\n-use of compiler-provided logic for allocating the associated per-module\n-logging-control structures visible to the runtime, and lazily evaluating\n-arguments. In the future, as more of the supporting compiler-provided logic is\n-moved into libraries, logging is likely to move to a component of the core\n-library. It is best to use the macro forms of logging (*#error*,\n-*#debug*, etc.) to minimize disruption to code using the logging facility\n-when it is changed.\n+Logging is presently implemented as a language built-in feature,\n+as it makes use of compiler-provided, per-module data tables and flags.\n+In the future, logging will move into a library, and will no longer be a core expression type.\n+It is therefore recommended to use the macro forms of logging (`error!`, `debug!`, etc.) to minimize disruption in code that uses logging.\n \n \n ### Assert expressions\n@@ -2481,27 +2505,53 @@ tuple of arguments.\n Enumerated types cannot be denoted *structurally* as types, but must be\n denoted by named reference to an [*enumeration* item](#enumerations).\n \n-### Box types\n-\n-Box types are represented as pointers. There are three flavours of\n-pointers:\n-\n-Shared boxes (`@`)\n-  : These are reference-counted boxes. Their type is written\n-    `@content`, for example `@int` means a shared box containing an\n-    integer. Copying a value of such a type means copying the pointer\n-    and increasing the reference count.\n-\n-Unique boxes (`~`)\n-  : Unique boxes have only a single owner, and are freed when their\n-    owner releases them. They are written `~content`. Copying a\n-    unique box involves copying the contents into a new box.\n-\n-Unsafe pointers (`*`)\n-  : Unsafe pointers are pointers without safety guarantees or\n-    language-enforced semantics. Their type is written `*content`.\n-    They can be copied and dropped freely. Dereferencing an unsafe\n-    pointer is part of the unsafe sub-dialect of Rust.\n+### Pointer types\n+\n+All pointers in Rust are explicit first-class values.\n+They can be copied, stored into data structures, and returned from functions.\n+There are four varieties of pointer in Rust:\n+\n+Managed pointers (`@`)\n+  : These point to managed heap allocations (or \"boxes\") in the task-local, managed heap.\n+    Managed pointers are written `@content`,\n+    for example `@int` means a managed pointer to a managed box containing an integer.\n+    Copying a managed pointer is a \"shallow\" operation:\n+    it involves only copying the pointer itself\n+    (as well as any reference-count or GC-barriers required by the managed heap).\n+    Dropping a managed pointer does not necessarily release the box it points to;\n+    the lifecycles of managed boxes are subject to an unspecified garbage collection algorithm.\n+\n+Owning pointers (`~`)\n+  : These point to owned heap allocations (or \"boxes\") in the shared, inter-task heap.\n+    Each owned box has a single owning pointer; pointer and pointee retain a 1:1 relationship at all times.\n+    Owning pointers are written `~content`,\n+    for example `~int` means an owning pointer to an owned box containing an integer.\n+    Copying an owned box is a \"deep\" operation:\n+    it involves allocating a new owned box and copying the contents of the old box into the new box.\n+    Releasing an owning pointer immediately releases its corresponding owned box.\n+\n+Borrowed pointers (`&`)\n+  : These point to memory _owned by some other value_.\n+    Borrowed pointers arise by (automatic) conversion from owning pointers, managed pointers,\n+    or by applying the borrowing operator `&` to some other value,\n+    including [lvalues, rvalues or temporaries](#lvalues-rvalues-and-temporaries).\n+    Borrowed pointers are written `&content`, or in some cases `&f/content` for some lifetime-variable `f`,\n+    for example `&int` means a borrowed pointer to an integer.\n+    Copying a borrowed pointer is a \"shallow\" operation:\n+    it involves only copying the pointer itself.\n+    Releasing a borrowed pointer typically has no effect on the value it points to,\n+    with the exception of temporary values,\n+    which are released when the last borrowed pointer to them is released.\n+\n+Raw pointers (`*`)\n+  : Raw pointers are pointers without safety or liveness guarantees.\n+    Raw pointers are written `*content`,\n+    for example `*int` means a raw pointer to an integer.\n+    Copying or dropping a raw pointer is has no effect on the lifecycle of any other value.\n+    Dereferencing a raw pointer or converting it to any other pointer type is an [`unsafe` operation](#unsafe-functions).\n+    Raw pointers are generally discouraged in Rust code;\n+    they exist to support interoperability with foreign code,\n+    and writing performance-critical or low-level functions.\n \n ### Function types\n \n@@ -2678,20 +2728,17 @@ the box values pointing to it. Since box values may themselves be passed in\n and out of frames, or stored in the heap, heap allocations may outlive the\n frame they are allocated within.\n \n-\n ### Memory ownership\n \n A task owns all memory it can *safely* reach through local variables,\n-shared or unique boxes, and/or references. Sharing memory between tasks can\n-only be accomplished using *unsafe* constructs, such as raw pointer\n-operations or calling C code.\n+as well as managed, owning and borrowed pointers.\n \n-When a task sends a value that has the `send` trait over a channel, it\n-loses ownership of the value sent and can no longer refer to it. This is\n-statically guaranteed by the combined use of \"move semantics\" and the\n-compiler-checked _meaning_ of the `send` trait: it is only instantiated\n-for (transitively) unique kinds of data constructor and pointers, never shared\n-pointers.\n+When a task sends a value that has the `Send` trait to another task,\n+it loses ownership of the value sent and can no longer refer to it.\n+This is statically guaranteed by the combined use of \"move semantics\",\n+and the compiler-checked _meaning_ of the `Send` trait:\n+it is only instantiated for (transitively) sendable kinds of data constructor and pointers,\n+never including managed or borrowed pointers.\n \n When a stack frame is exited, its local allocations are all released, and its\n references to boxes (both shared and owned) are dropped.\n@@ -2737,14 +2784,12 @@ aside a copy of that value to refer to. If this is not semantically safe (for\n example, if the referred-to value contains mutable fields), it will reject the\n program. If the compiler deems copying the value expensive, it will warn.\n \n-A function can be declared to take an argument by mutable reference. This\n-allows the function to write to the slot that the reference refers to.\n-\n-An example function that accepts an value by mutable reference:\n+A function with an argument of type `&mut T`, for some type `T`, can write to\n+the slot that its argument refers to. An example of such a function is:\n \n ~~~~~~~~\n-fn incr(&i: int) {\n-    i = i + 1;\n+fn incr(i: &mut int) {\n+    *i = *i + 1;\n }\n ~~~~~~~~\n \n@@ -2832,54 +2877,21 @@ exploiting.]\n \n ### Communication between tasks\n \n-With the exception of *unsafe* blocks, Rust tasks are isolated from\n-interfering with one another's memory directly. Instead of manipulating shared\n-storage, Rust tasks communicate with one another using a typed, asynchronous,\n-simplex message-passing system.\n-\n-A _port_ is a communication endpoint that can *receive* messages. Ports\n-receive messages from channels.\n-\n-A _channel_ is a communication endpoint that can *send* messages. Channels\n-send messages to ports.\n-\n-Each port is implicitly boxed and mutable; as such a port has a unique\n-per-task identity and cannot be replicated or transmitted. If a port value is\n-copied, both copies refer to the *same* port. New ports can be\n-constructed dynamically and stored in data structures.\n-\n-Each channel is bound to a port when the channel is constructed, so the\n-destination port for a channel must exist before the channel itself. A channel\n-cannot be rebound to a different port from the one it was constructed with.\n-\n-Channels are weak: a channel does not keep the port it is bound to\n-alive. Ports are owned by their allocating task and cannot be sent over\n-channels; if a task dies its ports die with it, and all channels bound to\n-those ports no longer function. Messages sent to a channel connected to a dead\n-port will be dropped.\n-\n-Channels are immutable types with meaning known to the runtime; channels can\n-be sent over channels.\n-\n-Many channels can be bound to the same port, but each channel is bound to a\n-single port. In other words, channels and ports exist in an N:1 relationship,\n-N channels to 1 port. ^[It may help to remember nautical terminology\n-when differentiating channels from ports.  Many different waterways --\n-channels -- may lead to the same port.]\n-\n-Each port and channel can carry only one type of message. The message type is\n-encoded as a parameter of the channel or port type. The message type of a\n-channel is equal to the message type of the port it is bound to. The types of\n-messages must satisfy the `send` built-in trait.\n+Rust tasks are isolated and generally unable to interfere with one another's memory directly,\n+except through [`unsafe` code](#unsafe-functions).\n+All contact between tasks is mediated by safe forms of ownership transfer,\n+and data races on memory are prohibited by the type system.\n \n-Messages are generally sent asynchronously, with optional\n-rate-limiting on the transmit side.  Each port contains a message\n-queue and sending a message over a channel merely means inserting it\n-into the associated port's queue; message receipt is the\n-responsibility of the receiving task.\n+Inter-task communication and co-ordination facilities are provided in the standard library.\n+These include:\n+  - synchronous and asynchronous communication channels with various communication topologies\n+  - read-only and read-write shared variables with various safe mutual exclusion patterns\n+  - simple locks and semaphores\n \n-Messages are sent on channels and received on ports using standard library\n-functions.\n+When such facilities carry values, the values are restricted to the [`Send` type-kind](#type-kinds).\n+Restricting communication interfaces to this kind ensures that no borrowed or managed pointers move between tasks.\n+Thus access to an entire data structure can be mediated through its owning \"root\" value;\n+no further locking or copying is required to avoid data races within the substructure of such a value.\n \n \n ### Task lifecycle\n@@ -2896,12 +2908,11 @@ A task begins its lifecycle -- once it has been spawned -- in the *running*\n state. In this state it executes the statements of its entry function, and any\n functions called by the entry function.\n \n-A task may transition from the *running* state to the *blocked* state any time\n-it makes a blocking receive call on a port, or attempts a rate-limited\n-blocking send on a channel. When the communication expression can be completed\n--- when a message arrives at a sender, or a queue drains sufficiently to\n-complete a rate-limited send -- then the blocked task will unblock and\n-transition back to *running*.\n+A task may transition from the *running* state to the *blocked*\n+state any time it makes a blocking communication call. When the\n+call can be completed -- when a message arrives at a sender, or a\n+buffer opens to receive a message -- then the blocked task will\n+unblock and transition back to *running*.\n \n A task may transition to the *failing* state at any time, due being\n killed by some external event or internally, from the evaluation of a\n@@ -2952,7 +2963,7 @@ An example of a `spawn` call:\n \n ~~~~\n let po = comm::Port();\n-let ch = comm::Chan(po);\n+let ch = comm::Chan(&po);\n \n do task::spawn {\n     // let task run, do other things\n@@ -2974,7 +2985,7 @@ An example of a send:\n \n ~~~~\n let po = comm::Port();\n-let ch = comm::Chan(po);\n+let ch = comm::Chan(&po);\n comm::send(ch, ~\"hello, world\");\n ~~~~\n \n@@ -2990,7 +3001,7 @@ An example of a *receive*:\n \n ~~~~~~~~\n # let po = comm::Port();\n-# let ch = comm::Chan(po);\n+# let ch = comm::Chan(&po);\n # comm::send(ch, ~\"\");\n let s = comm::recv(po);\n ~~~~~~~~"}, {"sha": "8202fbe8dc53f100e6e9ac1ae7b6e6c668683d4e", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -65,7 +65,7 @@ forbidden.\n To take as an argument a fragment of Rust code, write `$` followed by a name\n  (for use on the right-hand side), followed by a `:`, followed by the sort of\n fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n-`block`). Anything not preceeded by a `$` is taken literally. The standard\n+`block`). Anything not preceded by a `$` is taken literally. The standard\n rules of tokenization apply,\n \n So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n@@ -88,7 +88,7 @@ position).\n \n Going back to the motivating example, suppose that we wanted each invocation\n of `early_return` to potentially accept multiple \"special\" identifiers. The\n-syntax `$(...)*` accepts zero or more occurences of its contents, much like\n+syntax `$(...)*` accepts zero or more occurrences of its contents, much like\n the Kleene star operator in regular expressions. It also supports a separator\n token (a comma-separated list could be written `$(...),*`), and `+` instead of\n `*` to mean \"at least one\"."}, {"sha": "8b9d0c0c2a7d9bc9144d3a5a060e4eb5a77fad24", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -47,7 +47,7 @@ In particular, there are currently two independent modules that provide\n a message passing interface to Rust code: `core::comm` and `core::pipes`.\n `core::comm` is an older, less efficient system that is being phased out\n in favor of `pipes`. At some point the existing `core::comm` API will\n-be romoved and the user-facing portions of `core::pipes` will be moved\n+be removed and the user-facing portions of `core::pipes` will be moved\n to `core::comm`. In this tutorial we will discuss `pipes` and ignore\n the `comm` API.\n \n@@ -58,7 +58,7 @@ concurrency at the moment.\n * [`core::comm`] - The deprecated message passing API\n * [`core::pipes`] - The new message passing infrastructure and API\n * [`std::comm`] - Higher level messaging types based on `core::pipes`\n-* [`std::sync`] - More exotic synchronization tools, including locks \n+* [`std::sync`] - More exotic synchronization tools, including locks\n * [`std::arc`] - The ARC type, for safely sharing immutable data\n * [`std::par`] - Some basic tools for implementing parallel algorithms\n \n@@ -151,7 +151,7 @@ commonly used, which we will cover presently.\n \n The simplest way to create a pipe is to use the `pipes::stream`\n function to create a `(Chan, Port)` pair. In Rust parlance a 'channel'\n-is a sending endpoint of a pipe, and a 'port' is the recieving\n+is a sending endpoint of a pipe, and a 'port' is the receiving\n endpoint. Consider the following example of performing two calculations\n concurrently.\n \n@@ -183,7 +183,7 @@ let (chan, port): (Chan<int>, Port<int>) = stream();\n ~~~~\n \n The channel will be used by the child task to send data to the parent task,\n-which will wait to recieve the data on the port. The next statement\n+which will wait to receive the data on the port. The next statement\n spawns the child task.\n \n ~~~~\n@@ -307,7 +307,7 @@ unrecoverable within a single task - once a task fails there is no way\n to \"catch\" the exception.\n \n All tasks are, by default, _linked_ to each other, meaning their fate\n-is interwined, and if one fails so do all of them.\n+is intertwined, and if one fails so do all of them.\n \n ~~~\n # use task::spawn;"}, {"sha": "bf262105f6e4953467e5fb961d4b986fb8a271f8", "filename": "doc/tutorial.md", "status": "modified", "additions": 313, "deletions": 170, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -152,22 +152,17 @@ example, by changing `io::println` to some nonexistent function), and\n then compile it, you'll see an error message like this:\n \n ~~~~ {.notrust}\n-hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n-hello.rs:2     io::print_it(\"hello? yes, this is rust\");\n-               ^~~~~~~~~~~~\n+hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns\n+hello.rs:2     io::print_with_unicorns(\"hello? yes, this is rust\");\n+               ^~~~~~~~~~~~~~~~~~~~~~~\n ~~~~\n \n In its simplest form, a Rust program is a `.rs` file with some types\n and functions defined in it. If it has a `main` function, it can be\n compiled to an executable. Rust does not allow code that's not a\n declaration to appear at the top level of the file\u2014all statements must\n live inside a function.  Rust programs can also be compiled as\n-libraries, and included in other programs. The `extern mod std`\n-directive that appears at the top of many examples imports the\n-[standard library][std], described in more detail [later\n-on](#modules-and-crates).\n-\n-[std]: http://doc.rust-lang.org/doc/std\n+libraries, and included in other programs.\n \n ## Editing Rust code\n \n@@ -178,9 +173,11 @@ included in that directory. In particular, if you are running emacs\n 24, then using emacs's internal package manager to install `rust-mode`\n is the easiest way to keep it up to date. There is also a package for\n Sublime Text 2, available both [standalone][sublime] and through\n-[Sublime Package Control][sublime-pkg].\n+[Sublime Package Control][sublime-pkg], and support for Kate\n+under `src/etc/kate`.\n \n-Other editors are not provided for yet. If you end up writing a Rust\n+There is ctags support via `src/etc/ctags.rust`, but many other\n+tools and editors are not provided for yet. If you end up writing a Rust\n mode for your favorite editor, let us know so that we can link to it.\n \n [sublime]: http://github.com/dbp/sublime-rust\n@@ -191,7 +188,7 @@ mode for your favorite editor, let us know so that we can link to it.\n Assuming you've programmed in any C-family language (C++, Java,\n JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged\n in blocks delineated by curly braces; there are control structures\n-for branching and looping, like the familiar `if` and `when`; function\n+for branching and looping, like the familiar `if` and `while`; function\n calls are written `myfunc(arg1, arg2)`; operators are written the same\n and mostly have the same precedence as in C; comments are again like C.\n \n@@ -227,18 +224,24 @@ while count < 10 {\n }\n ~~~~\n \n-Although Rust can almost always infer the types of local variables, it\n-can help readability to specify a variable's type by following it with\n-a colon, then the type name. \n+Although Rust can almost always infer the types of local variables, you\n+can specify a variable's type by following it with a colon, then the type\n+name. \n \n ~~~~\n-let my_favorite_value: float = 57.8;\n-let my_favorite_value: int = my_favorite_value as int;\n+let monster_size: float = 57.8;\n+let imaginary_size = monster_size * 10.0;\n+let monster_size: int = 50;\n ~~~~\n \n Local variables may shadow earlier declarations, as in the previous\n-example in which `my_favorite_value` is first declared as a `float`\n-then a second `my_favorite_value` is declared as an int.\n+example in which `monster_size` is first declared as a `float`\n+then a second `monster_size` is declared as an int. If you were to actually\n+compile this example though, the compiler will see that the second\n+`monster_size` is unused, assume that you have made a mistake, and issue\n+a warning. For occasions where unused variables are intentional, their\n+name may be prefixed with an underscore to silence the warning, like\n+`let _monster_size = 50;`.\n \n Rust identifiers follow the same rules as C; they start with an alphabetic\n character or an underscore, and after that may contain any sequence of\n@@ -248,14 +251,14 @@ underscores where they help readability, while writing types in camel case.\n \n ~~~\n let my_variable = 100;\n-type MyType = int; // built-in types though are _not_ camel case\n+type MyType = int;     // some built-in types are _not_ camel case\n ~~~\n \n ## Expression syntax\n \n Though it isn't apparent in all code, there is a fundamental\n-difference between Rust's syntax and its predecessors in this family\n-of languages. Many constructs that are statements in C are expressions\n+difference between Rust's syntax and predecessors like C.\n+Many constructs that are statements in C are expressions\n in Rust, allowing code to be more concise. For example, you might\n write a piece of code like this:\n \n@@ -275,24 +278,25 @@ But, in Rust, you don't have to repeat the name `price`:\n \n ~~~~\n # let item = \"salad\";\n-let price = if item == \"salad\" {\n-    3.50\n-} else if item == \"muffin\" {\n-    2.25\n-} else {\n-    2.00\n-};\n+let price =\n+    if item == \"salad\" {\n+        3.50\n+    } else if item == \"muffin\" {\n+        2.25\n+    } else {\n+        2.00\n+    };\n ~~~~\n \n Both pieces of code are exactly equivalent\u2014they assign a value to\n-`price` depending on the condition that holds. Note that the\n-semicolons are omitted from the blocks in the second snippet. This is\n+`price` depending on the condition that holds. Note that there\n+are not semicolons in the blocks of the second snippet. This is\n important; the lack of a semicolon after the last statement in a\n braced block gives the whole block the value of that last expression.\n \n Put another way, the semicolon in Rust *ignores the value of an expression*.\n Thus, if the branches of the `if` had looked like `{ 4; }`, the above example\n-would simply assign nil (void) to `price`. But without the semicolon, each\n+would simply assign `()` (nil or void) to `price`. But without the semicolon, each\n branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n@@ -320,7 +324,6 @@ something\u2014in which case you'll have embedded it in a bigger statement.\n # fn foo() -> bool { true }\n # fn bar() -> bool { true }\n # fn baz() -> bool { true }\n-\n // `let` is not an expression, so it is semi-colon terminated;\n let x = foo();\n \n@@ -346,12 +349,11 @@ if x {\n let y = if x { foo() } else { bar() };\n ~~~\n \n-This may sound a bit intricate, but it is super-useful, and it will\n-grow on you (hopefully).\n+This may sound intricate, but it is super-useful and will grow on you.\n \n ## Types\n \n-The basic types include the usual boolean, integral, and floating point types.\n+The basic types include the usual boolean, integral, and floating-point types.\n \n ------------------------- -----------------------------------------------\n `()`                      Nil, the type that has only a single value\n@@ -360,17 +362,18 @@ The basic types include the usual boolean, integral, and floating point types.\n `i8`, `i16`, `i32`, `i64` Signed integers with a specific size (in bits)\n `u8`, `u16`, `u32`, `u64` Unsigned integers with a specific size\n `float`                   The largest floating-point type efficiently supported on the target machine\n-`f32`, `f64`              Floating-point types with a specific size.\n-`char`                    A Unicode character (32 bits).\n+`f32`, `f64`              Floating-point types with a specific size\n+`char`                    A Unicode character (32 bits)\n ------------------------- -----------------------------------------------\n \n These can be combined in composite types, which will be described in\n-more detail later on (the `T`s here stand for any other type):\n+more detail later on (the `T`s here stand for any other type,\n+while N should be a literal number):\n \n ------------------------- -----------------------------------------------\n `[T * N]`                 Vector (like an array in other languages) with N elements\n `[mut T * N]`             Mutable vector with N elements\n-`(T1, T2)`                Tuple type. Any arity above 1 is supported\n+`(T1, T2)`                Tuple type; any arity above 1 is supported\n `&T`, `~T`, `@T`          [Pointer types](#boxes-and-pointers)\n ------------------------- -----------------------------------------------\n \n@@ -392,7 +395,7 @@ the type `fn() -> bool` or the function declaration `fn foo() -> bool\n optionally write `-> ()`, but usually the return annotation is simply\n left off, as in `fn main() { ... }`.\n \n-Types can be given names with `type` declarations:\n+Types can be given names or aliases with `type` declarations:\n \n ~~~~\n type MonsterSize = uint;\n@@ -401,9 +404,25 @@ type MonsterSize = uint;\n This will provide a synonym, `MonsterSize`, for unsigned integers. It will not\n actually create a new, incompatible type\u2014`MonsterSize` and `uint` can be used\n interchangeably, and using one where the other is expected is not a type\n-error. Read about [single-variant enums](#single_variant_enum)\n-further on if you need to create a type name that's not just a\n-synonym.\n+error.\n+\n+To create data types which are not synonyms, `struct` and `enum`\n+can be used. They're described in more detail below, but they look like this:\n+\n+~~~~\n+enum HidingPlaces {\n+   Closet(uint),\n+   UnderTheBed(uint)\n+}\n+\n+struct HeroicBabysitter {\n+   bedtime_stories: uint,\n+   sharpened_stakes: uint\n+}\n+\n+struct BabysitterSize(uint);  // a single-variant struct\n+enum MonsterSize = uint;      // a single-variant enum\n+~~~~\n \n ## Literals\n \n@@ -435,10 +454,38 @@ The nil literal is written just like the type: `()`. The keywords\n \n Character literals are written between single quotes, as in `'x'`. Just as in\n C, Rust understands a number of character escapes, using the backslash\n-character, `\\n`, `\\r`, and `\\t` being the most common. String literals,\n+character, such as `\\n`, `\\r`, and `\\t`. String literals,\n written between double quotes, allow the same escape sequences. Rust strings\n may contain newlines.\n \n+## Constants\n+\n+Compile-time constants are declared with `const`. All scalar types,\n+like integers and floats, may be declared `const`, as well as fixed\n+length vectors, static strings (more on this later), and structs.\n+Constants may be declared in any scope and may refer to other\n+constants. Constant declarations are not type inferred, so must always\n+have a type annotation.  By convention they are written in all capital\n+letters.\n+\n+~~~\n+// Scalars can be constants\n+const MY_PASSWORD: int = 12345;\n+\n+// Scalar constants can be combined with other constants\n+const MY_DOGGIES_PASSWORD: int = MY_PASSWORD + 1;\n+\n+// Fixed-length vectors\n+const MY_VECTORY_PASSWORD: [int * 5] = [1, 2, 3, 4, 5];\n+\n+// Static strings\n+const MY_STRINGY_PASSWORD: &static/str = \"12345\";\n+\n+// Structs\n+struct Password { value: int }\n+const MY_STRUCTY_PASSWORD: Password = Password { value: MY_PASSWORD };\n+~~~\n+\n ## Operators\n \n Rust's set of operators contains very few surprises. Arithmetic is done with\n@@ -466,8 +513,8 @@ assert y == 4u;\n \n The main difference with C is that `++` and `--` are missing, and that\n the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n-comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n-more likely to be what you expect (unless you are a C veteran).\n+means `x & (2 > 0)`, but in Rust, it means `(x & 2) > 0`, which is\n+more likely what a novice expects.\n \n ## Syntax extensions\n \n@@ -556,18 +603,14 @@ underscore (`_`) is a wildcard pattern that matches everything.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n-convenient to use a block expression for a case, in which case the\n+convenient to use a block expression for each case, in which case the\n commas are optional.\n \n ~~~\n # let my_number = 1;\n match my_number {\n-  0 => {\n-    io::println(\"zero\")\n-  }\n-  _ => {\n-    io::println(\"something else\")\n-  }\n+  0 => { io::println(\"zero\") }\n+  _ => { io::println(\"something else\") }\n }\n ~~~\n \n@@ -686,19 +729,49 @@ omitted from the type, such an assignment would result in a type error.\n \n Structs can be destructured in `match` patterns. The basic syntax is\n `Name {fieldname: pattern, ...}`:\n+\n ~~~~\n # struct Point { x: float, y: float }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    Point { x: 0.0, y: y } => { io::println(y.to_str());                    }\n-    Point { x: x, y: y }   => { io::println(x.to_str() + \" \" + y.to_str()); }\n+    Point { x: 0.0, y: yy } => { io::println(yy.to_str());                     }\n+    Point { x: xx,  y: yy } => { io::println(xx.to_str() + \" \" + yy.to_str()); }\n }\n ~~~~\n \n In general, the field names of a struct do not have to appear in the same\n order they appear in the type. When you are not interested in all\n the fields of a struct, a struct pattern may end with `, _` (as in\n `Name {field1, _}`) to indicate that you're ignoring all other fields.\n+Additionally, struct fields have a shorthand matching form that simply\n+reuses the field name as the binding name.\n+\n+~~~\n+# struct Point { x: float, y: float }\n+# let mypoint = Point { x: 0.0, y: 0.0 };\n+match mypoint {\n+    Point { x, _ } => { io::println(x.to_str()) }\n+}\n+~~~\n+\n+Structs are the only type in Rust that may have user-defined destructors,\n+using `drop` blocks, inside of which the struct's value may be referred\n+to with the name `self`.\n+\n+~~~\n+struct TimeBomb {\n+    explosivity: uint,\n+\n+    drop {\n+        for iter::repeat(self.explosivity) {\n+            io::println(fmt!(\"blam!\"));\n+        }\n+    }\n+}\n+~~~\n+\n+> ***Note***: This destructor syntax is temporary. Eventually destructors\n+> will be defined for any type using [traits](#traits).\n \n ## Enums\n \n@@ -781,7 +854,7 @@ dereference (`*`) unary operator:\n \n ~~~~\n # enum GizmoId = int;\n-let my_gizmo_id = GizmoId(10);\n+let my_gizmo_id: GizmoId = GizmoId(10);\n let id_int: int = *my_gizmo_id;\n ~~~~\n \n@@ -842,12 +915,8 @@ back to [later](#modules-and-crates)). They are introduced with the\n the return type follows the arrow.\n \n ~~~~\n-fn repeat(string: &str, count: int) -> ~str {\n-    let mut result = ~\"\";\n-    for count.times {\n-        result += string;\n-    }\n-    return result;\n+fn line(a: int, b: int, x: int) -> int {\n+    return a * x + b;\n }\n ~~~~\n \n@@ -857,21 +926,8 @@ also return a value by having its top level block produce an\n expression.\n \n ~~~~\n-# const copernicus: int = 0;\n-fn int_to_str(i: int) -> ~str {\n-    if i == copernicus {\n-        return ~\"tube sock\";\n-    } else {\n-        return ~\"violin\";\n-    }\n-}\n-~~~~\n-\n-~~~~\n-# const copernicus: int = 0;\n-fn int_to_str(i: int) -> ~str {\n-    if i == copernicus { ~\"tube sock\" }\n-    else { ~\"violin\" }\n+fn line(a: int, b: int, x: int) -> int {\n+    a * x + b\n }\n ~~~~\n \n@@ -885,6 +941,16 @@ fn do_nothing_the_hard_way() -> () { return (); }\n fn do_nothing_the_easy_way() { }\n ~~~~\n \n+Ending the function with a semicolon like so is equivalent to returning `()`.\n+\n+~~~~\n+fn line(a: int, b: int, x: int) -> int { a * x + b  }\n+fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }\n+\n+assert 8  == line(5, 3, 1);\n+assert () == oops(5, 3, 1);\n+~~~~\n+\n Methods are like functions, except that they are defined for a specific\n 'self' type (like 'this' in C++). Calling a method is done with\n dot notation, as in `my_vec.len()`. Methods may be defined on most\n@@ -984,7 +1050,7 @@ easy for programmers to reason about. Heap isolation has the\n additional benefit that garbage collection must only be done\n per-heap. Rust never \"stops the world\" to reclaim memory.\n \n-Complete isolation of heaps between tasks implies that any data\n+Complete isolation of heaps between tasks would, however, mean that any data\n transferred between tasks must be copied. While this is a fine and\n useful way to implement communication between tasks, it is also very\n inefficient for large data structures.  Because of this, Rust also\n@@ -1096,6 +1162,9 @@ If you really want to copy a unique box you must say so explicitly.\n ~~~~\n let x = ~10;\n let y = copy x;\n+\n+let z = *x + *y;\n+assert z == 20;\n ~~~~\n \n This is where the 'move' operator comes in. It is similar to\n@@ -1104,9 +1173,11 @@ from `x` to `y`, without violating the constraint that it only has a\n single owner (if you used assignment instead of the move operator, the\n box would, in principle, be copied).\n \n-~~~~\n+~~~~ {.xfail-test}\n let x = ~10;\n let y = move x;\n+\n+let z = *x + *y; // would cause an error: use of moved variable: `x`\n ~~~~\n \n Owned boxes, when they do not contain any managed boxes, can be sent\n@@ -1208,6 +1279,73 @@ For a more in-depth explanation of borrowed pointers, read the\n \n [borrowtut]: tutorial-borrowed-ptr.html\n \n+## Dereferencing pointers\n+\n+Rust uses the unary star operator (`*`) to access the contents of a\n+box or pointer, similarly to C.\n+\n+~~~\n+let managed = @10;\n+let owned = ~20;\n+let borrowed = &30;\n+\n+let sum = *managed + *owned + *borrowed;\n+~~~\n+\n+Dereferenced mutable pointers may appear on the left hand side of\n+assignments, in which case the value they point to is modified.\n+\n+~~~\n+let managed = @mut 10;\n+let owned = ~mut 20;\n+\n+let mut value = 30;\n+let borrowed = &mut value;\n+\n+*managed = *owned + 10;\n+*owned = *borrowed + 100;\n+*borrowed = *managed + 1000;\n+~~~\n+\n+Pointers have high operator precedence, but lower precedence than the\n+dot operator used for field and method access. This can lead to some\n+awkward code filled with parenthesis.\n+\n+~~~\n+# struct Point { x: float, y: float }\n+# enum Shape { Rectangle(Point, Point) }\n+# impl Shape { fn area() -> int { 0 } }\n+let start = @Point { x: 10f, y: 20f };\n+let end = ~Point { x: (*start).x + 100f, y: (*start).y + 100f };\n+let rect = &Rectangle(*start, *end);\n+let area = (*rect).area();\n+~~~\n+\n+To combat this ugliness the dot operator performs _automatic pointer\n+dereferencing_ on the receiver (the value on the left hand side of the\n+dot), so in most cases dereferencing the receiver is not necessary.\n+\n+~~~\n+# struct Point { x: float, y: float }\n+# enum Shape { Rectangle(Point, Point) }\n+# impl Shape { fn area() -> int { 0 } }\n+let start = @Point { x: 10f, y: 20f };\n+let end = ~Point { x: start.x + 100f, y: start.y + 100f };\n+let rect = &Rectangle(*start, *end);\n+let area = rect.area();\n+~~~\n+\n+Auto-dereferencing is performed through any number of pointers. If you\n+felt inclined you could write something silly like\n+\n+~~~\n+# struct Point { x: float, y: float }\n+let point = &@~Point { x: 10f, y: 20f };\n+io::println(fmt!(\"%f\", point.x));\n+~~~\n+\n+The indexing operator (`[]`) is also auto-dereferencing.\n+\n # Vectors and strings\n \n Vectors are a contiguous section of memory containing zero or more\n@@ -1219,108 +1357,120 @@ pointers to vectors are also called 'slices'.\n enum Crayon {\n     Almond, AntiqueBrass, Apricot,\n     Aquamarine, Asparagus, AtomicTangerine,\n-    BananaMania, Beaver, Bittersweet\n+    BananaMania, Beaver, Bittersweet,\n+    Black, BlizzardBlue, Blue\n }\n \n // A fixed-size stack vector\n let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n \n // A borrowed pointer to stack allocated vector\n-let stack_crayons: &[Crayon] = &[Almond, AntiqueBrass, Apricot];\n+let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];\n \n // A local heap (managed) vector of crayons\n-let local_crayons: @[Crayon] = @[Aquamarine, Asparagus, AtomicTangerine];\n+let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];\n \n // An exchange heap (owned) vector of crayons\n-let exchange_crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n+let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];\n ~~~\n \n-Vector literals are enclosed in square brackets and dereferencing is\n-also done with square brackets (zero-based):\n+The `+` operator means concatenation when applied to vector types.\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n-# fn draw_scene(c: Crayon) { }\n \n-let crayons = [BananaMania, Beaver, Bittersweet];\n-match crayons[0] {\n-    Bittersweet => draw_scene(crayons[0]),\n-    _ => ()\n-}\n+let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n+let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n+\n+// Add two vectors to create a new one\n+let our_crayons = my_crayons + your_crayons;\n+\n+// += will append to a vector, provided it leves\n+// in a mutable slot\n+let mut my_crayons = move my_crayons;\n+my_crayons += your_crayons;\n ~~~~\n \n-By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `[mut T]` is a vector with mutable\n-elements. Mutable vector literals are written `[mut]` (empty) or `[mut\n-1, 2, 3]` (with elements).\n+> ***Note:*** The above examples of vector addition use owned\n+> vectors. Some operations on slices and stack vectors are\n+> not well supported yet, owned vectors are often the most\n+> usable.\n+\n+Indexing into vectors is done with square brackets:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n-\n-let crayons = [mut BananaMania, Beaver, Bittersweet];\n-crayons[0] = AtomicTangerine;\n+# fn draw_scene(c: Crayon) { }\n+let crayons: [Crayon * 3] = [BananaMania, Beaver, Bittersweet];\n+match crayons[0] {\n+    Bittersweet => draw_scene(crayons[0]),\n+    _ => ()\n+}\n ~~~~\n \n-The `+` operator means concatenation when applied to vector types.\n+The elements of a vector _inherit the mutability of the vector_,\n+and as such individual elements may not be reassigned when the\n+vector lives in an immutable slot.\n \n-~~~~\n+~~~ {.xfail-test}\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n+let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n \n-let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n-let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n-\n-let our_crayons = my_crayons + your_crayons;\n-~~~~\n+crayons[0] = Apricot; // ERROR: Can't assign to immutable vector\n+~~~\n \n-The `+=` operator also works as expected, provided the assignee\n-lives in a mutable slot.\n+Moving it into a mutable slot makes the elements assignable.\n \n-~~~~\n+~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n+let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n \n-let mut my_crayons = ~[Almond, AntiqueBrass, Apricot];\n-let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n+// Put the vector into a mutable slot\n+let mut mutable_crayons = move crayons;\n \n-my_crayons += your_crayons;\n-~~~~\n+// Now it's mutable to the bone\n+mutable_crayons[0] = Apricot;\n+~~~\n \n-> ***Note:*** The above examples of vector addition use owned\n-> vectors. Some operations on slices and stack vectors are\n-> not well supported yet, owned vectors are often the most\n-> usable.\n+This is a simple example of Rust's _dual-mode data structures_, also\n+referred to as _freezing and thawing_.\n \n-Strings are simply vectors of `[u8]`, though they have a distinct\n-type. They support most of the same allocation aptions as\n+Strings are implemented with vectors of `u8`, though they have a distinct\n+type. They support most of the same allocation options as\n vectors, though the string literal without a storage sigil, e.g.\n `\"foo\"` is treated differently than a comparable vector (`[foo]`).\n-Where\n+Whereas plain vectors are stack-allocated fixed-length vectors,\n+plain strings are region pointers to read-only memory. Strings\n+are always immutable.\n \n ~~~\n // A plain string is a slice to read-only (static) memory\n let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";\n \n-// The same thing, but without\n-let stack_crayons: &str = &\"Almond, AntiqueBrass, Apricot\";\n+// The same thing, but with the `&`\n+let stack_crayons: &str = &\"Aquamarine, Asparagus, AtomicTangerine\";\n \n // A local heap (managed) string\n-let local_crayons: @str = @\"Aquamarine, Asparagus, AtomicTangerine\";\n+let local_crayons: @str = @\"BananMania, Beaver, Bittersweet\";\n \n // An exchange heap (owned) string\n-let exchange_crayons: ~str = ~\"BananaMania, Beaver, Bittersweet\";\n+let exchange_crayons: ~str = ~\"Black, BlizzardBlue, Blue\";\n ~~~\n \n Both vectors and strings support a number of useful\n-[methods](#implementation).  While we haven't covered methods yet,\n-most vector functionality is provided by methods, so let's have a\n-brief look at a few common ones.\n+[methods](#functions-and-methods), defined in [`core::vec`]\n+and [`core::str`]. Here are some examples.\n+\n+[`core::vec`]: core/vec.html\n+[`core::str`]: core/str.html\n \n ~~~\n # use io::println;\n@@ -1403,7 +1553,7 @@ access local variables in the enclosing scope.\n \n ~~~~\n let mut max = 0;\n-(~[1, 2, 3]).map(|x| if *x > max { max = *x });\n+[1, 2, 3].map(|x| if *x > max { max = *x });\n ~~~~\n \n Stack closures are very efficient because their environment is\n@@ -1431,8 +1581,7 @@ This code creates a closure that adds a given string to its argument,\n returns it from a function, and then calls it:\n \n ~~~~\n-extern mod std;\n-\n+# extern mod std;\n fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n     return fn@(s: ~str) -> ~str { s + suffix };\n }\n@@ -1479,7 +1628,7 @@ fn call_twice(f: fn()) { f(); f(); }\n call_twice(|| { ~\"I am an inferred stack closure\"; } );\n call_twice(fn&() { ~\"I am also a stack closure\"; } );\n call_twice(fn@() { ~\"I am a managed closure\"; });\n-call_twice(fn~() { ~\"I am a owned closure\"; });\n+call_twice(fn~() { ~\"I am an owned closure\"; });\n fn bare_function() { ~\"I am a plain function\"; }\n call_twice(bare_function);\n ~~~~\n@@ -1490,9 +1639,12 @@ call_twice(bare_function);\n \n ## Do syntax\n \n-Closures in Rust are frequently used in combination with higher-order\n-functions to simulate control structures like `if` and\n-`loop`. Consider this function that iterates over a vector of\n+The `do` expression is syntactic sugar for use with functions which\n+take a closure as a final argument, because closures in Rust\n+are so frequently used in combination with higher-order\n+functions.\n+\n+Consider this function which iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n@@ -1537,8 +1689,7 @@ do each(&[1, 2, 3]) |n| {\n The call is prefixed with the keyword `do` and, instead of writing the\n final closure inside the argument list it is moved outside of the\n parenthesis where it looks visually more like a typical block of\n-code. The `do` expression is purely syntactic sugar for a call that\n-takes a final closure argument.\n+code.\n \n `do` is often used for task spawning.\n \n@@ -1632,6 +1783,10 @@ fn contains(v: &[int], elt: int) -> bool {\n \n `for` syntax only works with stack closures.\n \n+> ***Note:*** This is, essentially, a special loop protocol:\n+> the keywords `break`, `loop`, and `return` work, in varying degree,\n+> with `while`, `loop`, `do`, and `for` constructs.\n+\n # Generics\n \n Throughout this tutorial, we've been defining functions that act only on\n@@ -2036,6 +2191,9 @@ The compiler will now look for `poultry/chicken.rs` and\n and `poultry::turkey`. You can also provide a `poultry.rs` to add\n content to the `poultry` module itself.\n \n+The compiler then builds the crate as a platform-specific shared library or\n+executable which can be distributed.\n+\n ## Using other crates\n \n Having compiled a crate that contains the `#[crate_type = \"lib\"]`\n@@ -2082,30 +2240,30 @@ Rust program.\n \n This library is documented [here][core].\n \n-[core]: http://doc.rust-lang.org/doc/core\n+[core]: core/index.html\n \n ## A minimal example\n \n Now for something that you can actually compile yourself. We have\n these two files:\n \n ~~~~\n-// mylib.rs\n-#[link(name = \"mylib\", vers = \"1.0\")];\n-fn world() -> ~str { ~\"world\" }\n+// world.rs\n+#[link(name = \"world\", vers = \"1.0\")];\n+fn explore() -> ~str { ~\"world\" }\n ~~~~\n \n ~~~~ {.ignore}\n // main.rs\n-extern mod mylib;\n-fn main() { io::println(~\"hello \" + mylib::world()); }\n+extern mod world;\n+fn main() { io::println(~\"hello \" + world::explore()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n \n ~~~~ {.notrust}\n-> rustc --lib mylib.rs\n-> rustc main.rs -L .\n+> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\n+> rustc main.rs -L .    # compiles main\n > ./main\n \"hello world\"\n ~~~~\n@@ -2125,12 +2283,14 @@ fn main() {\n }\n ~~~~\n \n+\n It is also possible to import just the name of a module (`use\n std::list;`, then use `list::find`), to import all identifiers exported\n by a given module (`use io::*`), or to import a specific set\n of identifiers (`use math::{min, max, pi}`).\n \n-You can rename an identifier when importing using the `=` operator:\n+Rust uses different namespaces for modules, types, and values.  You\n+can also rename an identifier when importing using the `=` operator:\n \n ~~~~\n use prnt = io::println;\n@@ -2154,27 +2314,6 @@ This defines a rock-solid encryption algorithm. Code outside of the\n module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n just fine, but it does not have access to `enc::super_secret_number`.\n \n-## Namespaces\n-\n-Rust uses three different namespaces: one for modules, one for types,\n-and one for values. This means that this code is valid:\n-\n-~~~~\n-#[legacy_exports]\n-mod buffalo {\n-    type buffalo = int;\n-    fn buffalo<buffalo>(+buffalo: buffalo) -> buffalo { buffalo }\n-}\n-fn main() {\n-    let buffalo: buffalo::buffalo = 1;\n-    buffalo::buffalo::<buffalo::buffalo>(buffalo::buffalo(buffalo));\n-}\n-~~~~\n-\n-You don't want to write things like that, but it *is* very practical\n-to not have to worry about name clashes between types, values, and\n-modules.\n-\n ## Resolution\n \n The resolution process in Rust simply goes up the chain of contexts,\n@@ -2190,21 +2329,25 @@ Identifiers can shadow each other. In this program, `x` is of type\n type MyType = ~str;\n fn main() {\n     type MyType = int;\n-    let x: MyType;\n+    let x: MyType = 17;\n }\n ~~~~\n \n An `use` directive will only import into the namespaces for which\n identifiers are actually found. Consider this example:\n \n ~~~~\n-mod foo { fn bar() {} }\n-fn baz() {\n-    let bar = 10u;\n+mod foo {\n+   fn bar() {}\n+}\n+\n+fn main() {\n+    let bar = 10;\n \n     {\n         use foo::bar;\n         let quux = bar;\n+        assert quux == 10;\n     }\n }\n ~~~~"}, {"sha": "b64f5df9ca038b8a6042bce78e2665d29d8e539f", "filename": "mk/stage0.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -12,6 +12,10 @@ ifdef CFG_ENABLE_LOCAL_RUST\n \t$(Q)$(S)src/etc/local_stage0.sh $(CFG_HOST_TRIPLE) $(CFG_LOCAL_RUST_ROOT)\n else \n \t$(Q)$(S)src/etc/get-snapshot.py $(CFG_HOST_TRIPLE) $(SNAPSHOT_FILE)\n+ifdef CFG_ENABLE_PAX_FLAGS\n+\t@$(call E, apply PaX flags: $@)\n+\t@\"$(CFG_PAXCTL)\" -cm \"$@\"\n+endif\n endif \n \t$(Q)touch $@\n "}, {"sha": "967191ab745095878a44634bf4d986d566c82010", "filename": "mk/target.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -29,6 +29,10 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X):\t\t\t\t\\\n \t\t$$(TLIBRUSTC_DEFAULT$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$<\n+ifdef CFG_ENABLE_PAX_FLAGS\n+\t@$$(call E, apply PaX flags: $$@)\n+\t@\"$(CFG_PAXCTL)\" -cm \"$$@\"\n+endif\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC):\t\t\\\n \t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS)\t\t\\"}, {"sha": "5e0d9bd0e84144cbcd5974956e31d9718c424577", "filename": "src/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-This is preliminary version of the Rust compiler, libraries and tools\n+This is a preliminary version of the Rust compiler, libraries and tools\n \n Source layout:\n "}, {"sha": "179a8941587fa25cd0d7cd5ac682b0a8d123980e", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1889,7 +1889,8 @@ Commands:\n     set-method      Change the method for a source.\");\n }\n \n-fn main(argv: ~[~str]) {\n+fn main() {\n+    let argv = os::args();\n     let o = build_cargo_options(argv);\n \n     if vec::len(o.free) < 2u {"}, {"sha": "55fa6740268740901c5ef2207a64db50743b4d8d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -12,7 +12,8 @@ use common::mode_pretty;\n use common::mode;\n use util::logv;\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);"}, {"sha": "1e3c0bcfbfc3ea98e5540a8ec6914e43be83462b", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -19,7 +19,6 @@ def scrub(b):\n run_pass = os.path.join(src_dir, \"src\", \"test\", \"run-pass\")\n run_pass = os.path.abspath(run_pass)\n stage2_tests = []\n-take_args = {}\n \n for t in os.listdir(run_pass):\n     if t.endswith(\".rs\") and not (\n@@ -30,8 +29,6 @@ def scrub(b):\n                 \"xfail-fast\" in s or\n                 \"xfail-win32\" in s):\n             stage2_tests.append(t)\n-            if \"fn main(args:\" in s or \"fn main(++args:\" in s:\n-                take_args[t] = True\n         f.close()\n \n stage2_tests.sort()\n@@ -64,9 +61,6 @@ def scrub(b):\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n     d.write(\"    out.write_str(~\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n-    if t in take_args:\n-        d.write(\"    t_%d::main(~[~\\\"arg0\\\"]);\\n\" % i)\n-    else:\n-        d.write(\"    t_%d::main();\\n\" % i)\n+    d.write(\"    t_%d::main();\\n\" % i)\n     i += 1\n d.write(\"}\\n\")"}, {"sha": "3e31287e3cd19b49f7ef0d691819f0115b3efe08", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -599,7 +599,8 @@ fn check_variants(files: &[Path], cx: context) {\n     }\n }\n \n-fn main(args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     if vec::len(args) != 2u {\n         error!(\"usage: %s <testdir>\", args[0]);\n         return;"}, {"sha": "ce3dec89e418582802c63146226743bcfbb5123a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,7 +1,7 @@\n //! Managed vectors\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cast::transmute;\n@@ -21,7 +21,7 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn move_val_init<T>(&dst: T, -src: T);\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n@@ -176,15 +176,15 @@ pub mod raw {\n             push_slow(v, move initval);\n         }\n     }\n-    // This doesn't bother to make sure we have space.\n+\n     #[inline(always)] // really pretty please\n     pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));\n         let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(*p, move initval);\n+        rusti::move_val_init(&mut(*p), move initval);\n     }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {"}, {"sha": "030f05c6eeaeb0448823c858197ee6ce50ec945f", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,5 @@\n //! Unsafe operations\n+#[forbid(deprecated_mode)]\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n@@ -18,7 +19,7 @@ pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * The forget function will take ownership of the provided value but neglect\n  * to run any required cleanup or memory-management operations on it. This\n  * can be used for various acts of magick, particularly when using\n- * reinterpret_cast on managed pointer types.\n+ * reinterpret_cast on pointer types.\n  */\n #[inline(always)]\n pub unsafe fn forget<T>(thing: T) { rusti::forget(move thing); }"}, {"sha": "b0aeb78afaa836e2fd8667da0522001d935300da", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -40,15 +40,15 @@ pub extern mod c_double {\n     #[link_name=\"fmax\"] pure fn fmax(a: c_double, b: c_double) -> c_double;\n     #[link_name=\"fmin\"] pure fn fmin(a: c_double, b: c_double) -> c_double;\n     pure fn nextafter(x: c_double, y: c_double) -> c_double;\n-    pure fn frexp(n: c_double, &value: c_int) -> c_double;\n+    pure fn frexp(n: c_double, value: &mut c_int) -> c_double;\n     pure fn hypot(x: c_double, y: c_double) -> c_double;\n     pure fn ldexp(x: c_double, n: c_int) -> c_double;\n     #[cfg(unix)]\n     #[link_name=\"lgamma_r\"] pure fn lgamma(n: c_double,\n-                                           &sign: c_int) -> c_double;\n+                                           sign: &mut c_int) -> c_double;\n     #[cfg(windows)]\n     #[link_name=\"__lgamma_r\"] pure fn lgamma(n: c_double,\n-                                             &sign: c_int) -> c_double;\n+                                             sign: &mut c_int) -> c_double;\n     // renamed: log is a reserved keyword; ln seems more natural, too\n     #[link_name=\"log\"] pure fn ln(n: c_double) -> c_double;\n     // renamed: \"logb\" /often/ is confused for log2 by beginners\n@@ -58,7 +58,7 @@ pub extern mod c_double {\n     pure fn log10(n: c_double) -> c_double;\n     pure fn log2(n: c_double) -> c_double;\n     #[link_name=\"ilogb\"] pure fn ilog_radix(n: c_double) -> c_int;\n-    pure fn modf(n: c_double, &iptr: c_double) -> c_double;\n+    pure fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n     pure fn pow(n: c_double, e: c_double) -> c_double;\n // FIXME (#1379): enable when rounding modes become available\n //    pure fn rint(n: c_double) -> c_double;\n@@ -110,7 +110,7 @@ pub extern mod c_float {\n     #[link_name=\"fdimf\"] pure fn abs_sub(a: c_float, b: c_float) -> c_float;\n     #[link_name=\"floorf\"] pure fn floor(n: c_float) -> c_float;\n     #[link_name=\"frexpf\"] pure fn frexp(n: c_float,\n-                                        &value: c_int) -> c_float;\n+                                        value: &mut c_int) -> c_float;\n     #[link_name=\"fmaf\"] pure fn mul_add(a: c_float,\n                                         b: c_float, c: c_float) -> c_float;\n     #[link_name=\"fmaxf\"] pure fn fmax(a: c_float, b: c_float) -> c_float;\n@@ -122,11 +122,11 @@ pub extern mod c_float {\n \n     #[cfg(unix)]\n     #[link_name=\"lgammaf_r\"] pure fn lgamma(n: c_float,\n-                                            &sign: c_int) -> c_float;\n+                                            sign: &mut c_int) -> c_float;\n \n     #[cfg(windows)]\n     #[link_name=\"__lgammaf_r\"] pure fn lgamma(n: c_float,\n-                                              &sign: c_int) -> c_float;\n+                                              sign: &mut c_int) -> c_float;\n \n     #[link_name=\"logf\"] pure fn ln(n: c_float) -> c_float;\n     #[link_name=\"logbf\"] pure fn log_radix(n: c_float) -> c_float;\n@@ -135,7 +135,7 @@ pub extern mod c_float {\n     #[link_name=\"log10f\"] pure fn log10(n: c_float) -> c_float;\n     #[link_name=\"ilogbf\"] pure fn ilog_radix(n: c_float) -> c_int;\n     #[link_name=\"modff\"] pure fn modf(n: c_float,\n-                                      &iptr: c_float) -> c_float;\n+                                      iptr: &mut c_float) -> c_float;\n     #[link_name=\"powf\"] pure fn pow(n: c_float, e: c_float) -> c_float;\n // FIXME (#1379): enable when rounding modes become available\n //    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;"}, {"sha": "c9cd1a21b454ceaf2ea305942ac8dc7513708232", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -32,8 +32,8 @@ will once again be the preferred module for intertask communication.\n \n */\n \n-// NB: transitionary, de-mode-ing\n-// tjc: re-forbid deprecated modes after snapshot\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use either::Either;\n@@ -74,7 +74,7 @@ pub fn Port<T: Send>() -> Port<T> {\n \n impl<T: Send> Port<T> {\n \n-    fn chan() -> Chan<T> { Chan(self) }\n+    fn chan() -> Chan<T> { Chan(&self) }\n     fn send(v: T) { self.chan().send(move v) }\n     fn recv() -> T { recv(self) }\n     fn peek() -> bool { peek(self) }\n@@ -166,7 +166,7 @@ fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n-pub fn Chan<T: Send>(&&p: Port<T>) -> Chan<T> {\n+pub fn Chan<T: Send>(p: &Port<T>) -> Chan<T> {\n     Chan_(rustrt::get_port_id((**p).po))\n }\n \n@@ -304,51 +304,51 @@ extern mod rusti {\n \n \n #[test]\n-fn create_port_and_chan() { let p = Port::<int>(); Chan(p); }\n+fn create_port_and_chan() { let p = Port::<int>(); Chan(&p); }\n \n #[test]\n fn send_int() {\n     let p = Port::<int>();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     send(c, 22);\n }\n \n #[test]\n fn send_recv_fn() {\n     let p = Port::<int>();\n-    let c = Chan::<int>(p);\n+    let c = Chan::<int>(&p);\n     send(c, 42);\n     assert (recv(p) == 42);\n }\n \n #[test]\n fn send_recv_fn_infer() {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     send(c, 42);\n     assert (recv(p) == 42);\n }\n \n #[test]\n fn chan_chan_infer() {\n     let p = Port(), p2 = Port::<int>();\n-    let c = Chan(p);\n-    send(c, Chan(p2));\n+    let c = Chan(&p);\n+    send(c, Chan(&p2));\n     recv(p);\n }\n \n #[test]\n fn chan_chan() {\n     let p = Port::<Chan<int>>(), p2 = Port::<int>();\n-    let c = Chan(p);\n-    send(c, Chan(p2));\n+    let c = Chan(&p);\n+    send(c, Chan(&p2));\n     recv(p);\n }\n \n #[test]\n fn test_peek() {\n     let po = Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n     assert !peek(po);\n     send(ch, ());\n     assert peek(po);\n@@ -360,8 +360,8 @@ fn test_peek() {\n fn test_select2_available() {\n     let po_a = Port();\n     let po_b = Port();\n-    let ch_a = Chan(po_a);\n-    let ch_b = Chan(po_b);\n+    let ch_a = Chan(&po_a);\n+    let ch_b = Chan(&po_b);\n \n     send(ch_a, ~\"a\");\n \n@@ -376,8 +376,8 @@ fn test_select2_available() {\n fn test_select2_rendezvous() {\n     let po_a = Port();\n     let po_b = Port();\n-    let ch_a = Chan(po_a);\n-    let ch_b = Chan(po_b);\n+    let ch_a = Chan(&po_a);\n+    let ch_b = Chan(&po_b);\n \n     for iter::repeat(10) {\n         do task::spawn {\n@@ -400,8 +400,8 @@ fn test_select2_rendezvous() {\n fn test_select2_stress() {\n     let po_a = Port();\n     let po_b = Port();\n-    let ch_a = Chan(po_a);\n-    let ch_b = Chan(po_b);\n+    let ch_a = Chan(&po_a);\n+    let ch_b = Chan(&po_b);\n \n     let msgs = 100;\n     let times = 4u;\n@@ -436,7 +436,7 @@ fn test_select2_stress() {\n #[test]\n fn test_recv_chan() {\n     let po = Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n     send(ch, ~\"flower\");\n     assert recv_chan(ch) == ~\"flower\";\n }\n@@ -445,7 +445,7 @@ fn test_recv_chan() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_recv_chan_dead() {\n-    let ch = Chan(Port());\n+    let ch = Chan(&Port());\n     send(ch, ~\"flower\");\n     recv_chan(ch);\n }\n@@ -454,7 +454,7 @@ fn test_recv_chan_dead() {\n #[ignore(cfg(windows))]\n fn test_recv_chan_wrong_task() {\n     let po = Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n     send(ch, ~\"flower\");\n     assert result::is_err(&task::try(||\n         recv_chan(ch)"}, {"sha": "94e6decc4ca8f9b2c39e5e8f1fa0baf4e0ce58ce", "filename": "src/libcore/core.rc", "status": "modified", "additions": 78, "deletions": 120, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -36,227 +36,185 @@ Implicitly, all crates behave as if they included the following prologue:\n // Don't link to core. We are core.\n #[no_core];\n \n-#[legacy_exports];\n-\n #[warn(deprecated_mode)];\n #[warn(deprecated_pattern)];\n \n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n \n-export int, i8, i16, i32, i64;\n-export uint, u8, u16, u32, u64;\n-export float, f32, f64;\n-export box, char, str, ptr, vec, at_vec, bool;\n-export either, option, result, iter;\n-export gc, io, libc, os, run, rand, sys, cast, logging;\n-export comm, task, future, pipes;\n-export extfmt;\n-// The test harness links against core, so don't include runtime in tests.\n-// FIXME (#2861): Uncomment this after snapshot gets updated.\n-//#[cfg(notest)]\n-export rt;\n-export tuple;\n-export to_str, to_bytes;\n-export from_str;\n-export util;\n-export dvec, dvec_iter;\n-export dlist, dlist_iter;\n-export send_map;\n-export hash;\n-export cmp;\n-export num;\n-export path;\n-export mutable;\n-export flate;\n-export unit;\n-export uniq;\n-export repr;\n-export cleanup;\n-export reflect;\n-\n-// NDM seems to be necessary for resolve to work\n-export option_iter;\n-\n-// This creates some APIs that I do not want to commit to, but it must be\n-// exported from core in order for uv to remain in std (see #2648).\n-export private;\n-\n-\n // Built-in-type support modules\n \n /// Operations and constants for `int`\n #[path = \"int-template\"]\n-mod int {\n+pub mod int {\n     pub use inst::{ pow };\n     #[path = \"int.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `i8`\n #[path = \"int-template\"]\n-mod i8 {\n+pub mod i8 {\n     #[path = \"i8.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `i16`\n #[path = \"int-template\"]\n-mod i16 {\n+pub mod i16 {\n     #[path = \"i16.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `i32`\n #[path = \"int-template\"]\n-mod i32 {\n+pub mod i32 {\n     #[path = \"i32.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `i64`\n #[path = \"int-template\"]\n-mod i64 {\n+pub mod i64 {\n     #[path = \"i64.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `uint`\n #[path = \"uint-template\"]\n-mod uint {\n+pub mod uint {\n     pub use inst::{\n         div_ceil, div_round, div_floor, iterate,\n         next_power_of_two\n     };\n     #[path = \"uint.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `u8`\n #[path = \"uint-template\"]\n-mod u8 {\n+pub mod u8 {\n     pub use inst::is_ascii;\n     #[path = \"u8.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `u16`\n #[path = \"uint-template\"]\n-mod u16 {\n+pub mod u16 {\n     #[path = \"u16.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `u32`\n #[path = \"uint-template\"]\n-mod u32 {\n+pub mod u32 {\n     #[path = \"u32.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n /// Operations and constants for `u64`\n #[path = \"uint-template\"]\n-mod u64 {\n+pub mod u64 {\n     #[path = \"u64.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n \n \n-mod box;\n-mod char;\n-mod float;\n-mod f32;\n-mod f64;\n-mod str;\n-mod ptr;\n-mod vec;\n-mod at_vec;\n-mod bool;\n-mod tuple;\n-mod unit;\n-mod uniq;\n+pub mod box;\n+pub mod char;\n+pub mod float;\n+pub mod f32;\n+pub mod f64;\n+pub mod str;\n+pub mod ptr;\n+pub mod vec;\n+pub mod at_vec;\n+pub mod bool;\n+pub mod tuple;\n+pub mod unit;\n+pub mod uniq;\n \n // Ubiquitous-utility-type modules\n \n #[cfg(notest)]\n-mod ops;\n-mod cmp;\n-mod num;\n-mod hash;\n-mod either;\n-mod iter;\n-mod logging;\n-mod option;\n+pub mod ops;\n+pub mod cmp;\n+pub mod num;\n+pub mod hash;\n+pub mod either;\n+pub mod iter;\n+pub mod logging;\n+pub mod option;\n #[path=\"iter-trait\"]\n-mod option_iter {\n+pub mod option_iter {\n     #[path = \"option.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n-mod result;\n-mod to_str;\n-mod to_bytes;\n-mod from_str;\n-mod util;\n+pub mod result;\n+pub mod to_str;\n+pub mod to_bytes;\n+pub mod from_str;\n+pub mod util;\n \n // Data structure modules\n \n-mod dvec;\n+pub mod dvec;\n #[path=\"iter-trait\"]\n-mod dvec_iter {\n+pub mod dvec_iter {\n     #[path = \"dvec.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n-mod dlist;\n+pub mod dlist;\n #[path=\"iter-trait\"]\n-mod dlist_iter {\n+pub mod dlist_iter {\n     #[path =\"dlist.rs\"]\n-    mod inst;\n+    pub mod inst;\n }\n-mod send_map;\n+pub mod send_map;\n \n // Concurrency\n-mod comm;\n-mod task {\n+pub mod comm;\n+pub mod task {\n     pub mod local_data;\n     mod local_data_priv;\n     pub mod spawn;\n     pub mod rt;\n }\n-mod future;\n-mod pipes;\n+pub mod future;\n+pub mod pipes;\n \n // Runtime and language-primitive support\n \n-mod gc;\n-mod io;\n-mod libc;\n-mod os;\n-mod path;\n-mod rand;\n-mod run;\n-mod sys;\n-mod cast;\n-mod mutable;\n-mod flate;\n-mod repr;\n-mod cleanup;\n-mod reflect;\n+pub mod gc;\n+pub mod io;\n+pub mod libc;\n+pub mod os;\n+pub mod path;\n+pub mod rand;\n+pub mod run;\n+pub mod sys;\n+pub mod cast;\n+pub mod mutable;\n+pub mod flate;\n+pub mod repr;\n+pub mod cleanup;\n+pub mod reflect;\n \n // Modules supporting compiler-generated code\n // Exported but not part of the public interface\n \n-#[legacy_exports]\n-mod extfmt;\n+pub mod extfmt;\n // The test harness links against core, so don't include runtime in tests.\n #[cfg(notest)]\n #[legacy_exports]\n-mod rt;\n-\n+pub mod rt;\n \n-// For internal use, not exported\n+// Ideally not exported, but currently is.\n+pub mod private;\n \n+// For internal use, not exported.\n mod unicode;\n-mod private;\n mod cmath;\n mod stackwalk;\n "}, {"sha": "a14b67b40f13d899123eb10b76139f0437a23c0b", "filename": "src/libcore/core.rs", "status": "modified", "additions": 34, "deletions": 59, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,101 +2,76 @@\n \n // Export various ubiquitous types, constructors, methods.\n \n-use option::{Some, None};\n-use Option = option::Option;\n-use result::{Result, Ok, Err};\n+pub use option::{Some, None};\n+pub use Option = option::Option;\n+pub use result::{Result, Ok, Err};\n \n-use Path = path::Path;\n-use GenericPath = path::GenericPath;\n-use WindowsPath = path::WindowsPath;\n-use PosixPath = path::PosixPath;\n+pub use Path = path::Path;\n+pub use GenericPath = path::GenericPath;\n+pub use WindowsPath = path::WindowsPath;\n+pub use PosixPath = path::PosixPath;\n \n-use tuple::{TupleOps, ExtendedTupleOps};\n-use str::{StrSlice, UniqueStr};\n-use vec::{ConstVector, CopyableVector, ImmutableVector};\n-use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-use vec::{MutableVector, MutableCopyableVector};\n-use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-use iter::{CopyableOrderedIter, Times, TimesIx};\n-use num::Num;\n-use ptr::Ptr;\n-use to_str::ToStr;\n-\n-export Path, WindowsPath, PosixPath, GenericPath;\n-export Option, Some, None;\n-export Result, Ok, Err;\n-export extensions;\n-// The following exports are the extension impls for numeric types\n-export Num, Times, TimesIx;\n-// The following exports are the common traits\n-export StrSlice, UniqueStr;\n-export ConstVector, CopyableVector, ImmutableVector;\n-export ImmutableEqVector, ImmutableCopyableVector, IterTraitExtensions;\n-export MutableVector, MutableCopyableVector;\n-export BaseIter, CopyableIter, CopyableOrderedIter, ExtendedIter, EqIter;\n-export TupleOps, ExtendedTupleOps;\n-export Ptr;\n-export ToStr;\n+pub use tuple::{TupleOps, ExtendedTupleOps};\n+pub use str::{StrSlice, UniqueStr};\n+pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{MutableVector, MutableCopyableVector};\n+pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{CopyableOrderedIter, Times, TimesIx};\n+pub use num::Num;\n+pub use ptr::Ptr;\n+pub use to_str::ToStr;\n \n // The following exports are the core operators and kinds\n // The compiler has special knowlege of these so we must not duplicate them\n // when compiling for testing\n #[cfg(notest)]\n-use ops::{Const, Copy, Send, Owned};\n+pub use ops::{Const, Copy, Send, Owned};\n #[cfg(notest)]\n-use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n+pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n #[cfg(notest)]\n-use ops::{Shl, Shr, Index};\n-\n-#[cfg(notest)]\n-export Const, Copy, Send, Owned;\n-#[cfg(notest)]\n-export Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor;\n-#[cfg(notest)]\n-export Shl, Shr, Index;\n+pub use ops::{Shl, Shr, Index};\n \n #[cfg(test)]\n extern mod coreops(name = \"core\", vers = \"0.4\");\n \n #[cfg(test)]\n-use coreops::ops::{Const, Copy, Send, Owned};\n+pub use coreops::ops::{Const, Copy, Send, Owned};\n+#[cfg(test)]\n+pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n #[cfg(test)]\n-use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n+pub use coreops::ops::{BitXor};\n #[cfg(test)]\n-use coreops::ops::{Shl, Shr, Index};\n+pub use coreops::ops::{Shl, Shr, Index};\n \n \n // Export the log levels as global constants. Higher levels mean\n // more-verbosity. Error is the bottom level, default logging level is\n // warn-and-below.\n \n-export error, warn, info, debug;\n-\n /// The error log level\n-const error : u32 = 0_u32;\n+pub const error : u32 = 0_u32;\n /// The warning log level\n-const warn : u32 = 1_u32;\n+pub const warn : u32 = 1_u32;\n /// The info log level\n-const info : u32 = 2_u32;\n+pub const info : u32 = 2_u32;\n /// The debug log level\n-const debug : u32 = 3_u32;\n+pub const debug : u32 = 3_u32;\n \n // A curious inner-module that's not exported that contains the binding\n // 'core' so that macro-expanded references to core::error and such\n // can be resolved within libcore.\n #[doc(hidden)] // FIXME #3538\n mod core {\n-    #[legacy_exports];\n-    const error : u32 = 0_u32;\n-    const warn : u32 = 1_u32;\n-    const info : u32 = 2_u32;\n-    const debug : u32 = 3_u32;\n+    pub const error : u32 = 0_u32;\n+    pub const warn : u32 = 1_u32;\n+    pub const info : u32 = 2_u32;\n+    pub const debug : u32 = 3_u32;\n }\n \n // Similar to above. Some magic to make core testable.\n #[cfg(test)]\n mod std {\n-    #[legacy_exports];\n     extern mod std(vers = \"0.4\");\n-    use std::test;\n+    pub use std::test;\n }"}, {"sha": "3bcf486ef7e0d29a4c27fd214425c250773d7780", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -9,7 +9,7 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n */\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n type DListLink<T> = Option<DListNode<T>>;"}, {"sha": "1540eb30fe5a41b76427296ff69e698dd3e84da6", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,7 +10,7 @@ Note that recursive use is not permitted.\n */\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;"}, {"sha": "7500ff409a41fa45ef1ec1599dbd5c71aab5edd1", "filename": "src/libcore/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n //! A type that represents one of two alternatives"}, {"sha": "de2e91b2e3268fefdd74bc1c5c58d35c14c2687f", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 46, "deletions": 239, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,7 @@\n #[doc(hidden)];\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n /*\n Syntax Extension: fmt\n@@ -41,11 +44,10 @@ use option::{Some, None};\n  */\n \n // Functions used by the fmt extension at compile time\n-mod ct {\n-    #[legacy_exports];\n-    enum Signedness { Signed, Unsigned, }\n-    enum Caseness { CaseUpper, CaseLower, }\n-    enum Ty {\n+pub mod ct {\n+    pub enum Signedness { Signed, Unsigned, }\n+    pub enum Caseness { CaseUpper, CaseLower, }\n+    pub enum Ty {\n         TyBool,\n         TyStr,\n         TyChar,\n@@ -56,22 +58,22 @@ mod ct {\n         TyFloat,\n         TyPoly,\n     }\n-    enum Flag {\n+    pub enum Flag {\n         FlagLeftJustify,\n         FlagLeftZeroPad,\n         FlagSpaceForSign,\n         FlagSignAlways,\n         FlagAlternate,\n     }\n-    enum Count {\n+    pub enum Count {\n         CountIs(int),\n         CountIsParam(int),\n         CountIsNextParam,\n         CountImplied,\n     }\n \n     // A formatted conversion from an expression to a string\n-    type Conv =\n+    pub type Conv =\n         {param: Option<int>,\n          flags: ~[Flag],\n          width: Count,\n@@ -80,10 +82,10 @@ mod ct {\n \n \n     // A fragment of the output sequence\n-    enum Piece { PieceString(~str), PieceConv(Conv), }\n-    type ErrorFn = fn@(&str) -> ! ;\n+    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n+    pub type ErrorFn = fn@(&str) -> ! ;\n \n-    fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n@@ -118,7 +120,7 @@ mod ct {\n         flush_buf(move buf, &mut pieces);\n         move pieces\n     }\n-    fn peek_num(s: &str, i: uint, lim: uint) ->\n+    pub fn peek_num(s: &str, i: uint, lim: uint) ->\n        Option<{num: uint, next: uint}> {\n         let mut j = i;\n         let mut accum = 0u;\n@@ -140,7 +142,8 @@ mod ct {\n             None\n         }\n     }\n-    fn parse_conversion(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n+    pub fn parse_conversion(s: &str, i: uint, lim: uint,\n+                            error: ErrorFn) ->\n        {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -155,7 +158,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<int>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -170,7 +173,7 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_flags(s: &str, i: uint, lim: uint) ->\n        {flags: ~[Flag], next: uint} {\n         let noflags: ~[Flag] = ~[];\n         if i >= lim { return {flags: move noflags, next: i}; }\n@@ -198,7 +201,7 @@ mod ct {\n                 more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n-    fn parse_count(s: &str, i: uint, lim: uint)\n+    pub fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -220,7 +223,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: &str, i: uint, lim: uint) ->\n+    pub fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -236,7 +239,7 @@ mod ct {\n                 }\n             } else { {count: CountImplied, next: i} };\n     }\n-    fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n+    pub fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {ty: Ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n@@ -274,21 +277,20 @@ mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-mod rt {\n-    #[legacy_exports];\n-    const flag_none : u32 = 0u32;\n-    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n-    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n-    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n-    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n-    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+pub mod rt {\n+    pub const flag_none : u32 = 0u32;\n+    pub const flag_left_justify   : u32 = 0b00000000000001u32;\n+    pub const flag_left_zero_pad  : u32 = 0b00000000000010u32;\n+    pub const flag_space_for_sign : u32 = 0b00000000000100u32;\n+    pub const flag_sign_always    : u32 = 0b00000000001000u32;\n+    pub const flag_alternate      : u32 = 0b00000000010000u32;\n \n-    enum Count { CountIs(int), CountImplied, }\n-    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+    pub enum Count { CountIs(int), CountImplied, }\n+    pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n-    pure fn conv_int(cv: Conv, i: int) -> ~str {\n+    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -301,7 +303,7 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -313,17 +315,17 @@ mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -336,7 +338,7 @@ mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n@@ -351,14 +353,14 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+    pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n+    pub pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         return if num < 0 {\n                 ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n@@ -367,7 +369,8 @@ mod rt {\n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n+    pub pure fn uint_to_str_prec(num: uint, radix: uint,\n+                                 prec: uint) -> ~str {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n@@ -380,16 +383,16 @@ mod rt {\n                 } else { move s }\n             };\n     }\n-    pure fn get_int_precision(cv: Conv) -> uint {\n+    pub pure fn get_int_precision(cv: Conv) -> uint {\n         return match cv.precision {\n               CountIs(c) => c as uint,\n               CountImplied => 1u\n             };\n     }\n \n-    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n+    pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    impl PadMode : Eq {\n+    pub impl PadMode : Eq {\n         pure fn eq(other: &PadMode) -> bool {\n             match (self, (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -405,7 +408,7 @@ mod rt {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n+    pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n           CountImplied => return s,\n@@ -458,209 +461,13 @@ mod rt {\n         }\n         return padstr + s;\n     }\n-    pure fn have_flag(flags: u32, f: u32) -> bool {\n-        flags & f != 0\n-    }\n-}\n-\n-// Remove after snapshot\n-\n-// Functions used by the fmt extension at runtime. For now there are a lot of\n-// decisions made a runtime. If it proves worthwhile then some of these\n-// conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it 0this way, I think.\n-mod rt2 {\n-    #[legacy_exports];\n-    const flag_none : u32 = 0u32;\n-    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n-    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n-    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n-    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n-    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n-\n-    enum Count { CountIs(int), CountImplied, }\n-    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n-\n-    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    pure fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10;\n-        let prec = get_int_precision(cv);\n-        let mut s : ~str = int_to_str_prec(i, radix, prec);\n-        if 0 <= i {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                unsafe { str::unshift_char(&mut s, '+') };\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                unsafe { str::unshift_char(&mut s, ' ') };\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadSigned) };\n-    }\n-    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n-        let prec = get_int_precision(cv);\n-        let mut rs =\n-            match cv.ty {\n-              TyDefault => uint_to_str_prec(u, 10u, prec),\n-              TyHexLower => uint_to_str_prec(u, 16u, prec),\n-              TyHexUpper => str::to_upper(uint_to_str_prec(u, 16u, prec)),\n-              TyBits => uint_to_str_prec(u, 2u, prec),\n-              TyOctal => uint_to_str_prec(u, 8u, prec)\n-            };\n-        return unsafe { pad(cv, rs, PadUnsigned) };\n-    }\n-    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n-        let s = if b { ~\"true\" } else { ~\"false\" };\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        return conv_str(cv, s);\n-    }\n-    pure fn conv_char(cv: Conv, c: char) -> ~str {\n-        let mut s = str::from_char(c);\n-        return unsafe { pad(cv, s, PadNozero) };\n-    }\n-    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n-        // For strings, precision is the maximum characters\n-        // displayed\n-        let mut unpadded = match cv.precision {\n-          CountImplied => s.to_unique(),\n-          CountIs(max) => if max as uint < str::char_len(s) {\n-            str::substr(s, 0u, max as uint)\n-          } else {\n-            s.to_unique()\n-          }\n-        };\n-        return unsafe { pad(cv, unpadded, PadNozero) };\n-    }\n-    pure fn conv_float(cv: Conv, f: float) -> ~str {\n-        let (to_str, digits) = match cv.precision {\n-              CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str, 6u)\n-        };\n-        let mut s = unsafe { to_str(f, digits) };\n-        if 0.0 <= f {\n-            if have_flag(cv.flags, flag_sign_always) {\n-                s = ~\"+\" + s;\n-            } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = ~\" \" + s;\n-            }\n-        }\n-        return unsafe { pad(cv, s, PadFloat) };\n-    }\n-    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n-        let s = sys::log_str(v);\n-        return conv_str(cv, s);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    pure fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n-        return if num < 0 {\n-                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n-            } else { uint_to_str_prec(num as uint, radix, prec) };\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to uint: but it doesn't seem all that useful.\n-    pure fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n-        return if prec == 0u && num == 0u {\n-                ~\"\"\n-            } else {\n-                let s = uint::to_str(num, radix);\n-                let len = str::char_len(s);\n-                if len < prec {\n-                    let diff = prec - len;\n-                    let pad = str::from_chars(vec::from_elem(diff, '0'));\n-                    pad + s\n-                } else { move s }\n-            };\n-    }\n-    pure fn get_int_precision(cv: Conv) -> uint {\n-        return match cv.precision {\n-              CountIs(c) => c as uint,\n-              CountImplied => 1u\n-            };\n-    }\n-\n-    enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n-\n-    impl PadMode : Eq {\n-        pure fn eq(other: &PadMode) -> bool {\n-            match (self, (*other)) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n-    }\n-\n-    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n-        let mut s = move s; // sadtimes\n-        let uwidth : uint = match cv.width {\n-          CountImplied => return s,\n-          CountIs(width) => {\n-              // FIXME: width should probably be uint (see Issue #1996)\n-              width as uint\n-          }\n-        };\n-        let strlen = str::char_len(s);\n-        if uwidth <= strlen { return s; }\n-        let mut padchar = ' ';\n-        let diff = uwidth - strlen;\n-        if have_flag(cv.flags, flag_left_justify) {\n-            let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-            return s + padstr;\n-        }\n-        let {might_zero_pad, signed} = match mode {\n-          PadNozero => {might_zero_pad:false, signed:false},\n-          PadSigned => {might_zero_pad:true,  signed:true },\n-          PadFloat => {might_zero_pad:true,  signed:true},\n-          PadUnsigned => {might_zero_pad:true,  signed:false}\n-        };\n-        pure fn have_precision(cv: Conv) -> bool {\n-            return match cv.precision { CountImplied => false, _ => true };\n-        }\n-        let zero_padding = {\n-            if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&\n-                (!have_precision(cv) || mode == PadFloat) {\n-                padchar = '0';\n-                true\n-            } else {\n-                false\n-            }\n-        };\n-        let padstr = str::from_chars(vec::from_elem(diff, padchar));\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-\n-        if signed && zero_padding && s.len() > 0 {\n-            let head = str::shift_char(&mut s);\n-            if head == '+' || head == '-' || head == ' ' {\n-                let headstr = str::from_chars(vec::from_elem(1u, head));\n-                return headstr + padstr + s;\n-            }\n-            else {\n-                str::unshift_char(&mut s, head);\n-            }\n-        }\n-        return padstr + s;\n-    }\n-    pure fn have_flag(flags: u32, f: u32) -> bool {\n+    pub pure fn have_flag(flags: u32, f: u32) -> bool {\n         flags & f != 0\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     #[test]\n     fn fmt_slice() {\n         let s = \"abc\";"}, {"sha": "efd5ff65aa5f1cee5ff5ff0ec2c98a9047a53553", "filename": "src/libcore/future.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,6 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+// tjc: allowing deprecated modes due to function issue.\n+// can re-forbid them after snapshot\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -86,7 +87,7 @@ pub fn from_port<A:Send>(port: future_pipe::client::waiting<A>) ->\n     }\n }\n \n-pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n+pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -98,7 +99,7 @@ pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(move f)}\n }\n \n-pub fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *"}, {"sha": "8cb689fd286abd091c08dbdab549e6eddb62e975", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use T = inst::T;"}, {"sha": "865b8013fb0432c9e99a0c643efbaa949e3b3670", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,6 +4,9 @@ Basic input/output\n \n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use result::Result;\n \n use cmp::Eq;"}, {"sha": "6de6633f5f8aab48463d7949b9aa510e09c033a2", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,7 +2,8 @@\n // workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n // how this file is used.\n \n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n use cmp::{Eq, Ord};\n use inst::{IMPL_T, EACH, SIZE_HINT};"}, {"sha": "322012db135ba673205416b2293e26a305ee3e8f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,6 +4,9 @@ The iteration traits and common implementation\n \n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use cmp::{Eq, Ord};\n \n /// A function used to initialize the elements of a sequence"}, {"sha": "b314ad61ee2a114ab4b45a13060c28e8e7c8a23d", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,7 @@ dynamic checks: your program will fail if you attempt to perform\n mutation when the data structure should be immutable.\n \n */\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use util::with;"}, {"sha": "7c6bcf5bd51fbeed608ea86c97061bf8b87825f5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,8 @@\n // Core operators and kinds.\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n #[lang=\"const\"]\n pub trait Const {\n     // Empty."}, {"sha": "c60b7b401cc8cbbb1b3fcd1b4482acd0617aa927", "filename": "src/libcore/option.rs", "status": "modified", "additions": 109, "deletions": 36, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,15 +1,37 @@\n /*!\n- * Operations on the ubiquitous `option` type.\n- *\n- * Type `option` represents an optional value.\n- *\n- * Every `Option<T>` value can either be `Some(T)` or `none`. Where in other\n- * languages you might use a nullable type, in Rust you would use an option\n- * type.\n- */\n-\n-// NB: transitionary, de-mode-ing.\n-#[warn(deprecated_mode)];\n+\n+Operations on the ubiquitous `Option` type.\n+\n+Type `Option` represents an optional value.\n+\n+Every `Option<T>` value can either be `Some(T)` or `None`. Where in other\n+languages you might use a nullable type, in Rust you would use an option\n+type.\n+\n+Options are most commonly used with pattern matching to query the presence\n+of a value and take action, always accounting for the `None` case.\n+\n+# Example\n+\n+~~~\n+let msg = Some(~\"howdy\");\n+\n+// Take a reference to the contained string\n+match msg {\n+    Some(ref m) => io::println(m),\n+    None => ()\n+}\n+\n+// Remove the contained string, destroying the Option\n+let unwrapped_msg = match move msg {\n+    Some(move m) => m,\n+    None => ~\"default message\"\n+};\n+~~~\n+\n+*/\n+\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n@@ -22,12 +44,19 @@ pub enum Option<T> {\n \n pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     /*!\n-     * Gets the value out of an option\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n+    Gets the value out of an option\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+    */\n \n     match *opt {\n       Some(copy x) => return x,\n@@ -37,11 +66,18 @@ pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n \n pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n-     * Gets an immutable reference to the value inside an option.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n      */\n     match *opt {\n         Some(ref x) => x,\n@@ -154,20 +190,37 @@ pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n #[inline(always)]\n pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n-     * Moves a value out of an option type and returns it.\n-     *\n-     * Useful primarily for getting strings, vectors and unique pointers out\n-     * of option types without copying them.\n+    Moves a value out of an option type and returns it.\n+\n+    Useful primarily for getting strings, vectors and unique pointers out\n+    of option types without copying them.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`.\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged.\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n      */\n     match move opt {\n         Some(move x) => move x,\n         None => fail ~\"option::unwrap none\"\n     }\n }\n \n-/// The ubiquitous option dance.\n #[inline(always)]\n pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n+    /*!\n+    The option dance. Moves a value out of an option type and returns it,\n+    replacing the original with `None`.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`.\n+     */\n     if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n     unwrap(util::replace(opt, None))\n }\n@@ -201,18 +254,38 @@ impl<T> &Option<T> {\n     pure fn iter(f: fn(x: &T)) { iter(self, f) }\n     /// Maps a `some` value from one type to another by reference\n     pure fn map<U>(f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n-    /// Gets an immutable reference to the value inside a `some`.\n+    /**\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }\n \n impl<T: Copy> Option<T> {\n     /**\n-     * Gets the value out of an option\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n+    Gets the value out of an option\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+    */\n     pure fn get() -> T { get(&self) }\n     pure fn get_default(def: T) -> T { get_default(&self, def) }\n     /**\n@@ -252,10 +325,10 @@ impl<T: Eq> Option<T> : Eq {\n #[test]\n fn test_unwrap_ptr() {\n     let x = ~0;\n-    let addr_x = ptr::p2::addr_of(&(*x));\n+    let addr_x = ptr::addr_of(&(*x));\n     let opt = Some(x);\n     let y = unwrap(opt);\n-    let addr_y = ptr::p2::addr_of(&(*y));\n+    let addr_y = ptr::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n "}, {"sha": "3fd98e7f2987b6995890f7d5c02111b6a1ff4581", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -132,7 +132,7 @@ mod global_env {\n         let env_ch = get_global_env_chan();\n         let po = comm::Port();\n         comm::send(env_ch, MsgGetEnv(str::from_slice(n),\n-                                     comm::Chan(po)));\n+                                     comm::Chan(&po)));\n         comm::recv(po)\n     }\n \n@@ -141,14 +141,14 @@ mod global_env {\n         let po = comm::Port();\n         comm::send(env_ch, MsgSetEnv(str::from_slice(n),\n                                      str::from_slice(v),\n-                                     comm::Chan(po)));\n+                                     comm::Chan(&po)));\n         comm::recv(po)\n     }\n \n     pub fn env() -> ~[(~str,~str)] {\n         let env_ch = get_global_env_chan();\n         let po = comm::Port();\n-        comm::send(env_ch, MsgEnv(comm::Chan(po)));\n+        comm::send(env_ch, MsgEnv(comm::Chan(&po)));\n         comm::recv(po)\n     }\n "}, {"sha": "791c6bccde8c49b9f63ebc6cc78ecdf61fe37e64", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -73,7 +73,8 @@ bounded and unbounded protocols allows for less code duplication.\n */\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+// tjc: allowing deprecated modes due to function issue,\n+// re-forbid after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n@@ -859,7 +860,7 @@ endpoint is passed to the new task.\n pub fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n-    +service: fn~(v: RecvPacketBuffered<T, Tb>))\n+    service: fn~(v: RecvPacketBuffered<T, Tb>))\n     -> SendPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -883,7 +884,7 @@ receive state.\n pub fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n-    +service: fn~(v: SendPacketBuffered<T, Tb>))\n+    service: fn~(v: SendPacketBuffered<T, Tb>))\n     -> RecvPacketBuffered<T, Tb>\n {\n     let (client, server) = init();"}, {"sha": "c4ef136a592e68893a6d76408626e088f9e6a680", "filename": "src/libcore/private.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,6 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+// tjc: Re-forbid deprecated modes once a snapshot fixes the\n+// function problem\n #[forbid(deprecated_pattern)];\n \n #[doc(hidden)];\n@@ -45,7 +46,7 @@ type GlobalPtr = *libc::uintptr_t;\n pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n-    +f: fn~(comm::Port<T>)\n+    f: fn~(comm::Port<T>)\n ) -> comm::Chan<T> {\n \n     enum Msg {\n@@ -63,7 +64,7 @@ pub unsafe fn chan_from_global_ptr<T: Send>(\n         let (setup_po, setup_ch) = do task_fn().spawn_conversation\n             |move f, setup_po, setup_ch| {\n             let po = comm::Port::<T>();\n-            let ch = comm::Chan(po);\n+            let ch = comm::Chan(&po);\n             comm::send(setup_ch, ch);\n \n             // Wait to hear if we are the official instance of\n@@ -109,7 +110,7 @@ pub fn test_from_global_chan1() {\n \n     // The global channel\n     let globchan = 0;\n-    let globchanp = ptr::p2::addr_of(&globchan);\n+    let globchanp = ptr::addr_of(&globchan);\n \n     // Create the global channel, attached to a new task\n     let ch = unsafe {\n@@ -122,7 +123,7 @@ pub fn test_from_global_chan1() {\n     };\n     // Talk to it\n     let po = comm::Port();\n-    comm::send(ch, comm::Chan(po));\n+    comm::send(ch, comm::Chan(&po));\n     assert comm::recv(po) == true;\n \n     // This one just reuses the previous channel\n@@ -135,7 +136,7 @@ pub fn test_from_global_chan1() {\n \n     // Talk to the original global task\n     let po = comm::Port();\n-    comm::send(ch, comm::Chan(po));\n+    comm::send(ch, comm::Chan(&po));\n     assert comm::recv(po) == true;\n }\n \n@@ -145,10 +146,10 @@ pub fn test_from_global_chan2() {\n     for iter::repeat(100) {\n         // The global channel\n         let globchan = 0;\n-        let globchanp = ptr::p2::addr_of(&globchan);\n+        let globchanp = ptr::addr_of(&globchan);\n \n         let resultpo = comm::Port();\n-        let resultch = comm::Chan(resultpo);\n+        let resultch = comm::Chan(&resultpo);\n \n         // Spawn a bunch of tasks that all want to compete to\n         // create the global channel\n@@ -165,7 +166,7 @@ pub fn test_from_global_chan2() {\n                     }\n                 };\n                 let po = comm::Port();\n-                comm::send(ch, comm::Chan(po));\n+                comm::send(ch, comm::Chan(&po));\n                 // We are The winner if our version of the\n                 // task was installed\n                 let winner = comm::recv(po);\n@@ -203,7 +204,7 @@ pub fn test_from_global_chan2() {\n  */\n pub unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     unsafe {\n         rustrt::rust_task_weaken(cast::reinterpret_cast(&ch));\n     }"}, {"sha": "ffa11dcfc754bec76d4668c48cf5c1a20bf03858", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,8 @@\n //! Unsafe pointer utility functions\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use cmp::{Eq, Ord};\n use libc::{c_void, size_t};\n \n@@ -28,12 +31,6 @@ extern mod rusti {\n #[inline(always)]\n pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n \n-pub mod p2 {\n-    /// Get an unsafe pointer to a value\n-    #[inline(always)]\n-    pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n-}\n-\n /// Get an unsafe mut pointer to a value\n #[inline(always)]\n pub pure fn mut_addr_of<T>(val: &T) -> *mut T {"}, {"sha": "786fed88de97073c5bbaad2f626d4f0d6a7d938e", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,7 +1,7 @@\n //! Random number generation\n \n // NB: transitional, de-mode-ing.\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n #[allow(non_camel_case_types)] // runtime type\n@@ -310,7 +310,7 @@ pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n \n \n // used to make space in TLS for a random number generator\n-fn tls_rng_state(+_v: @RandRes) {}\n+fn tls_rng_state(_v: @RandRes) {}\n \n /**\n  * Gives back a lazily initialized task-local random number generator,"}, {"sha": "505804b3da827bb49fe7c2e9bb012b1d21a15754", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,6 +4,9 @@ Runtime type reflection\n \n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n use libc::c_void;\n "}, {"sha": "0501b032d2d5ca67b4c3cc0623dd39d7566ec863", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,6 +4,9 @@ More runtime type reflection\n \n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use dvec::DVec;\n use io::{Writer, WriterUtil};\n use libc::c_void;"}, {"sha": "39fae8905f9223e38e48d60e50ba87927a24bb52", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,7 +1,8 @@\n //! A type representing either success or failure\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;"}, {"sha": "0ff9174920919bb3f6c268a351603ecf76aa22d1", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n //! Process spawning\n@@ -296,7 +296,7 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n     // or the other. FIXME (#2625): Surely there's a much more\n     // clever way to do this.\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     do task::spawn_sched(task::SingleThreaded) {\n         let errput = readclose(pipe_err.in);\n         comm::send(ch, (2, move errput));"}, {"sha": "a88a44701ce8e078d5cd9444bbd94e2c4e5a1ad4", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -3,8 +3,8 @@\n #[legacy_modes]; // tjc: remove after snapshot\n \n // NB: transitionary, de-mode-ing.\n-// XXX: Can't do this because frame_address needs a deprecated mode.\n-//#[forbid(deprecated_mode)];\n+// XXX: Can't forbid this because frame_address needs a deprecated mode.\n+#[allow(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;"}, {"sha": "285b61149577a90f1cd5ad1abc0283e8fb874bd7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -7,8 +7,8 @@\n  * some heavy-duty uses, try std::rope.\n  */\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n use cmp::{Eq, Ord};\n use libc::size_t;"}, {"sha": "8d7791d18d90658344da2af94912b132fca13643", "filename": "src/libcore/task.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,6 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+// tjc: Deprecated modes allowed because of function arg issue\n+// in task::spawn. Re-forbid after snapshot.\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -219,7 +220,7 @@ pub type TaskOpts = {\n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n pub enum TaskBuilder = {\n     opts: TaskOpts,\n-    gen_body: fn@(+v: fn~()) -> fn~(),\n+    gen_body: fn@(v: fn~()) -> fn~(),\n     can_not_copy: Option<util::NonCopyable>,\n     mut consumed: bool,\n };\n@@ -232,7 +233,7 @@ pub enum TaskBuilder = {\n pub fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n-        gen_body: |+body| move body, // Identity function\n+        gen_body: |body| move body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     })\n@@ -409,7 +410,7 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(wrapper: fn@(+v: fn~()) -> fn~()) -> TaskBuilder {\n+    fn add_wrapper(wrapper: fn@(v: fn~()) -> fn~()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         let notify_chan = if self.opts.notify_chan.is_none() {\n             None\n@@ -441,7 +442,7 @@ impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(+f: fn~()) {\n+    fn spawn(f: fn~()) {\n         let notify_chan = if self.opts.notify_chan.is_none() {\n             None\n         } else {\n@@ -459,7 +460,7 @@ impl TaskBuilder {\n         spawn::spawn_raw(move opts, x.gen_body(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(arg: A, +f: fn~(+v: A)) {\n+    fn spawn_with<A: Send>(arg: A, f: fn~(v: A)) {\n         let arg = ~mut Some(move arg);\n         do self.spawn |move arg, move f| {\n             f(option::swap_unwrap(arg))\n@@ -477,12 +478,12 @@ impl TaskBuilder {\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n-    fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    fn spawn_listener<A: Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n         let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(setup_po);\n+        let setup_ch = comm::Chan(&setup_po);\n         do self.spawn |move f| {\n             let po = comm::Port();\n-            let ch = comm::Chan(po);\n+            let ch = comm::Chan(&po);\n             comm::send(setup_ch, ch);\n             f(move po);\n         }\n@@ -493,10 +494,10 @@ impl TaskBuilder {\n      * Runs a new task, setting up communication in both directions\n      */\n     fn spawn_conversation<A: Send, B: Send>\n-        (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+        (f: fn~(comm::Port<A>, comm::Chan<B>))\n         -> (comm::Port<B>, comm::Chan<A>) {\n         let from_child = comm::Port();\n-        let to_parent = comm::Chan(from_child);\n+        let to_parent = comm::Chan(&from_child);\n         let to_child = do self.spawn_listener |move f, from_parent| {\n             f(from_parent, to_parent)\n         };\n@@ -516,9 +517,9 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T: Send>(+f: fn~() -> T) -> Result<T,()> {\n+    fn try<T: Send>(f: fn~() -> T) -> Result<T,()> {\n         let po = comm::Port();\n-        let ch = comm::Chan(po);\n+        let ch = comm::Chan(&po);\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n@@ -555,7 +556,7 @@ pub fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n-pub fn spawn(+f: fn~()) {\n+pub fn spawn(f: fn~()) {\n     /*!\n      * Creates and executes a new child task\n      *\n@@ -568,7 +569,7 @@ pub fn spawn(+f: fn~()) {\n     task().spawn(move f)\n }\n \n-pub fn spawn_unlinked(+f: fn~()) {\n+pub fn spawn_unlinked(f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -577,7 +578,7 @@ pub fn spawn_unlinked(+f: fn~()) {\n     task().unlinked().spawn(move f)\n }\n \n-pub fn spawn_supervised(+f: fn~()) {\n+pub fn spawn_supervised(f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -586,7 +587,7 @@ pub fn spawn_supervised(+f: fn~()) {\n     task().supervised().spawn(move f)\n }\n \n-pub fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n+pub fn spawn_with<A:Send>(arg: A, f: fn~(v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -600,7 +601,7 @@ pub fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n     task().spawn_with(move arg, move f)\n }\n \n-pub fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+pub fn spawn_listener<A:Send>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -611,7 +612,7 @@ pub fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n }\n \n pub fn spawn_conversation<A: Send, B: Send>\n-    (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+    (f: fn~(comm::Port<A>, comm::Chan<B>))\n     -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n      * Runs a new task, setting up communication in both directions\n@@ -622,7 +623,7 @@ pub fn spawn_conversation<A: Send, B: Send>\n     task().spawn_conversation(move f)\n }\n \n-pub fn spawn_sched(mode: SchedMode, +f: fn~()) {\n+pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n      *\n@@ -639,7 +640,7 @@ pub fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     task().sched_mode(mode).spawn(move f)\n }\n \n-pub fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n+pub fn try<T:Send>(f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -772,7 +773,7 @@ fn test_cant_dup_task_builder() {\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     do spawn_unlinked {\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n@@ -802,7 +803,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     let po = comm::Port::<()>();\n-    let _ch = comm::Chan(po);\n+    let _ch = comm::Chan(&po);\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n@@ -845,7 +846,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     let po = comm::Port::<()>();\n-    let _ch = comm::Chan(po);\n+    let _ch = comm::Chan(&po);\n     // Default options are to spawn linked & unsupervised.\n     do spawn { fail; }\n     comm::recv(po); // We should get punted awake\n@@ -917,7 +918,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n #[test]\n fn test_run_basic() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     do task().spawn {\n         comm::send(ch, ());\n     }\n@@ -927,7 +928,7 @@ fn test_run_basic() {\n #[test]\n fn test_add_wrapper() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n         fn~() {\n@@ -961,7 +962,7 @@ fn test_back_to_the_future_result() {\n #[test]\n fn test_spawn_listiner_bidi() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     let ch = do spawn_listener |po| {\n         // Now the child has a port called 'po' to read from and\n         // an environment-captured channel called 'ch'.\n@@ -1017,7 +1018,7 @@ fn test_spawn_sched_no_threads() {\n #[test]\n fn test_spawn_sched() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n \n     fn f(i: int, ch: comm::Chan<()>) {\n         let parent_sched_id = rt::rust_get_sched_id();\n@@ -1041,7 +1042,7 @@ fn test_spawn_sched() {\n #[test]\n fn test_spawn_sched_childs_on_same_sched() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n \n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = rt::rust_get_sched_id();\n@@ -1075,9 +1076,9 @@ fn test_spawn_sched_blocking() {\n     for iter::repeat(20u) {\n \n         let start_po = comm::Port();\n-        let start_ch = comm::Chan(start_po);\n+        let start_ch = comm::Chan(&start_po);\n         let fin_po = comm::Port();\n-        let fin_ch = comm::Chan(fin_po);\n+        let fin_ch = comm::Chan(&fin_po);\n \n         let lock = testrt::rust_dbg_lock_create();\n \n@@ -1105,12 +1106,12 @@ fn test_spawn_sched_blocking() {\n         }\n \n         let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(setup_po);\n+        let setup_ch = comm::Chan(&setup_po);\n         let parent_po = comm::Port();\n-        let parent_ch = comm::Chan(parent_po);\n+        let parent_ch = comm::Chan(&parent_po);\n         do spawn {\n             let child_po = comm::Port();\n-            comm::send(setup_ch, comm::Chan(child_po));\n+            comm::send(setup_ch, comm::Chan(&child_po));\n             pingpong(child_po, parent_ch);\n         };\n \n@@ -1126,15 +1127,15 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: fn(+v: fn~())) {\n+fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let p = comm::Port::<uint>();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n \n     let x = ~1;\n-    let x_in_parent = ptr::p2::addr_of(&(*x)) as uint;\n+    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n     do spawnfn {\n-        let x_in_child = ptr::p2::addr_of(&(*x)) as uint;\n+        let x_in_child = ptr::addr_of(&(*x)) as uint;\n         comm::send(ch, x_in_child);\n     }\n \n@@ -1149,7 +1150,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |+f| {\n+    do avoid_copying_the_body |f| {\n         spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n@@ -1167,7 +1168,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |+f| {\n+    do avoid_copying_the_body |f| {\n         task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n@@ -1195,7 +1196,7 @@ fn test_avoid_copying_the_body_unlinked() {\n #[test]\n fn test_platform_thread() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     do task().sched_mode(PlatformThread).spawn {\n         comm::send(ch, ());\n     }"}, {"sha": "991011893152c3da8559c9f4f99d6a0caa305541", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -78,7 +78,7 @@ pub unsafe fn local_data_modify<T: Owned>(\n }\n \n #[test]\n-pub fn test_tls_multitask() unsafe {\n+fn test_tls_multitask() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n@@ -94,15 +94,15 @@ pub fn test_tls_multitask() unsafe {\n }\n \n #[test]\n-pub fn test_tls_overwrite() unsafe {\n+fn test_tls_overwrite() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"first data\");\n     local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n-pub fn test_tls_pop() unsafe {\n+fn test_tls_pop() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n@@ -111,7 +111,7 @@ pub fn test_tls_pop() unsafe {\n }\n \n #[test]\n-pub fn test_tls_modify() unsafe {\n+fn test_tls_modify() unsafe {\n     fn my_key(_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n@@ -130,7 +130,7 @@ pub fn test_tls_modify() unsafe {\n }\n \n #[test]\n-pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // This might result in a stack-canary clobber if the runtime fails to set\n     // sp_limit to 0 when calling the cleanup extern - it might automatically\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n@@ -143,7 +143,7 @@ pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n }\n \n #[test]\n-pub fn test_tls_multiple_types() unsafe {\n+fn test_tls_multiple_types() unsafe {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }\n@@ -155,7 +155,7 @@ pub fn test_tls_multiple_types() unsafe {\n }\n \n #[test]\n-pub fn test_tls_overwrite_multiple_types() {\n+fn test_tls_overwrite_multiple_types() {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }\n@@ -171,7 +171,7 @@ pub fn test_tls_overwrite_multiple_types() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-pub fn test_tls_cleanup_on_failure() unsafe {\n+fn test_tls_cleanup_on_failure() unsafe {\n     fn str_key(_x: @~str) { }\n     fn box_key(_x: @@()) { }\n     fn int_key(_x: @int) { }"}, {"sha": "e84e4dad164f3ac911227c05f45821491b06de7f", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -17,19 +17,19 @@ impl LocalData: Eq {\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-pub type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-pub type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n-pub extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n     let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n@@ -52,7 +52,7 @@ pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-pub unsafe fn key_to_key_value<T: Owned>(\n+unsafe fn key_to_key_value<T: Owned>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -62,7 +62,7 @@ pub unsafe fn key_to_key_value<T: Owned>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-pub unsafe fn local_data_lookup<T: Owned>(\n+unsafe fn local_data_lookup<T: Owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n@@ -80,7 +80,7 @@ pub unsafe fn local_data_lookup<T: Owned>(\n     }\n }\n \n-pub unsafe fn local_get_helper<T: Owned>(\n+unsafe fn local_get_helper<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n "}, {"sha": "6eaace1fa1a1d54df33761a8a5fbba97611e4088", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -61,6 +61,7 @@\n  ****************************************************************************/\n \n #[doc(hidden)]; // FIXME #3538\n+#[warn(deprecated_mode)];\n \n use rt::rust_task;\n use rt::rust_closure;\n@@ -69,16 +70,16 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of(&($x)); move y } }\n )\n \n-pub type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n+type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n-pub fn new_taskset() -> TaskSet {\n+fn new_taskset() -> TaskSet {\n     send_map::linear::LinearMap()\n }\n-pub fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n+fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());\n     assert didnt_overwrite;\n }\n-pub fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n+fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n@@ -87,20 +88,20 @@ pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n }\n \n // One of these per group of linked-failure tasks.\n-pub type TaskGroupData = {\n+type TaskGroupData = {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n     mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n     mut descendants: TaskSet,\n };\n-pub type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n+type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n \n-pub type TaskGroupInner = &mut Option<TaskGroupData>;\n+type TaskGroupInner = &mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&tg.members).is_empty()\n }\n \n@@ -111,7 +112,7 @@ pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-pub type AncestorNode = {\n+type AncestorNode = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -124,16 +125,16 @@ pub type AncestorNode = {\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n };\n-pub enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n+enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-pub fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n-pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n+fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -146,7 +147,7 @@ pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n // FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n-pub fn each_ancestor(list:        &mut AncestorList,\n+fn each_ancestor(list:        &mut AncestorList,\n                      bail_opt:    Option<fn@(TaskGroupInner)>,\n                      forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n@@ -271,7 +272,7 @@ pub fn each_ancestor(list:        &mut AncestorList,\n }\n \n // One of these per task.\n-pub struct TCB {\n+struct TCB {\n     me:            *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n     tasks:         TaskGroupArc, // 'none' means the group has failed.\n@@ -303,7 +304,7 @@ pub struct TCB {\n     }\n }\n \n-pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n+fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n        is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n     let notifier = move notifier;\n@@ -318,7 +319,7 @@ pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n     }\n }\n \n-pub struct AutoNotify {\n+struct AutoNotify {\n     notify_chan: Chan<Notification>,\n     mut failed:  bool,\n     drop {\n@@ -327,14 +328,14 @@ pub struct AutoNotify {\n     }\n }\n \n-pub fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n+fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n \n-pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n                            is_member: bool) -> bool {\n     let newstate = util::replace(state, None);\n     // If 'None', the group was failing. Can't enlist.\n@@ -350,7 +351,7 @@ pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n                        is_member: bool) {\n     let newstate = util::replace(state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n@@ -363,7 +364,7 @@ pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-pub fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n+fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -405,7 +406,7 @@ macro_rules! taskgroup_key (\n     () => (cast::transmute((-2 as uint, 0u)))\n )\n \n-pub fn gen_child_taskgroup(linked: bool, supervised: bool)\n+fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> (TaskGroupArc, AncestorList, bool) {\n     let spawner = rt::rust_get_task();\n     /*######################################################################*\n@@ -487,7 +488,7 @@ pub fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n+pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -532,7 +533,7 @@ pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n     fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<Notification>>,\n-                          +f: fn~()) -> fn~() {\n+                          f: fn~()) -> fn~() {\n         let child_data = ~mut Some((move child_arc, move ancestors));\n         return fn~(move notify_chan, move child_data, move f) {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -636,7 +637,7 @@ pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n #[test]\n fn test_spawn_raw_simple() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     do spawn_raw(default_task_opts()) {\n         comm::send(ch, ());\n     }"}, {"sha": "6c633f16abf2b91628ab43cb91dca1dd81233649", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -5,7 +5,7 @@ Miscellaneous helpers for common patterns.\n */\n \n // NB: transitionary, de-mode-ing.\n-// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;"}, {"sha": "3a2b73f5b5b4ebef63cc2e5af8c0a7fed1018357", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,7 +1,7 @@\n //! Vectors\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n #[warn(non_camel_case_types)];\n \n use cmp::{Eq, Ord};\n@@ -18,9 +18,10 @@ extern mod rustrt {\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    fn move_val_init<T>(&dst: T, -src: T);\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n }\n \n+\n /// Returns true if a vector contains no elements\n pub pure fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n@@ -104,7 +105,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n         do as_mut_buf(v) |p, _len| {\n             let mut i: uint = 0u;\n             while i < n_elts {\n-                rusti::move_val_init(*ptr::mut_offset(p, i), op(i));\n+                rusti::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n                 i += 1u;\n             }\n         }\n@@ -489,7 +490,7 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     (**repr).unboxed.fill += sys::size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(*p, move initval);\n+    rusti::move_val_init(&mut(*p), move initval);\n }\n \n #[inline(never)]\n@@ -1769,7 +1770,7 @@ pub mod raw {\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n             box2 <-> box;\n-            rusti::move_val_init(*ptr::mut_offset(p, i),\n+            rusti::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                  option::unwrap(move box2));\n         }\n     }\n@@ -1918,10 +1919,9 @@ impl<A: Copy> &[A]: iter::CopyableIter<A> {\n     }\n     pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n \n-    // FIXME--bug in resolve prevents this from working (#2611)\n-    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> ~[B] {\n-    //     iter::flat_map_to_vec(self, op)\n-    // }\n+    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n+        iter::flat_map_to_vec(&self, op)\n+    }\n \n     pub pure fn find(p: fn(a: A) -> bool) -> Option<A> {\n         iter::find(&self, p)"}, {"sha": "addabb2ddb9b3558af47441d00e7b471a5ed02d9", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks."}, {"sha": "6a2ac88f71435d7565cb13c62a069ba2833d92ac", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -31,9 +31,10 @@ use libc::size_t;\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    fn move_val_init<T>(&dst: T, -src: T);\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n     fn needs_drop<T>() -> bool;\n }\n+\n extern mod rustrt {\n     #[rust_stack]\n     fn rust_call_tydesc_glue(root: *u8, tydesc: *TypeDesc, field: size_t);\n@@ -127,7 +128,6 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (reinterpret_cast(&(p & !1)), p & 1 == 1)\n }\n \n-// The duplication between the POD and non-POD functions is annoying.\n impl &Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n@@ -166,7 +166,7 @@ impl &Arena {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n             let ptr: *mut T = reinterpret_cast(&ptr);\n-            rusti::move_val_init(*ptr, op());\n+            rusti::move_val_init(&mut (*ptr), op());\n             return reinterpret_cast(&ptr);\n         }\n     }\n@@ -217,7 +217,7 @@ impl &Arena {\n             // has *not* been initialized yet.\n             *ty_ptr = reinterpret_cast(&tydesc);\n             // Actually initialize it\n-            rusti::move_val_init(*ptr, op());\n+            rusti::move_val_init(&mut(*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);"}, {"sha": "91af4a3d653187e1e31d72fcfc76e33b08148506", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use vec::{to_mut, from_elem};\n \n@@ -553,7 +553,7 @@ pure fn land(w0: uint, w1: uint) -> uint { return w0 & w1; }\n pure fn right(_w0: uint, w1: uint) -> uint { return w1; }\n \n impl Bitv: ops::Index<uint,bool> {\n-    pure fn index(+i: uint) -> bool {\n+    pure fn index(i: uint) -> bool {\n         self.get(i)\n     }\n }"}, {"sha": "06d56ed1ae529c5d2322c5d23971ba5506b49b63", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -25,6 +25,7 @@\n  * great care must be taken to ensure that a reference to the c_vec::t is\n  * still held if needed.\n  */\n+#[forbid(deprecated_mode)];\n \n /**\n  * The type representing a foreign chunk of memory\n@@ -111,7 +112,7 @@ pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-pub fn set<T: Copy>(t: CVec<T>, ofs: uint, +v: T) {\n+pub fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }"}, {"sha": "c888957728a33dc221505ed612fd33167d3ae810", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /// A dynamic, mutable location.\n ///\n /// Similar to a mutable option type, but friendlier."}, {"sha": "1a897a2c2fa9a6af3c3e6b0bfc40da40c6500180", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -16,11 +16,11 @@ pub struct DuplexStream<T: Send, U: Send> {\n }\n \n impl<T: Send, U: Send> DuplexStream<T, U> : Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         self.chan.send(move x)\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         self.chan.try_send(move x)\n     }\n }"}, {"sha": "f141a028e652001f840b73076c99a275de78af3a", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n //! Unsafe debugging functions for inspecting values.\n \n use cast::reinterpret_cast;"}, {"sha": "37798d9a6273362f2e74629960569b0278ba7744", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n //! A deque. Untested as of yet. Likely buggy\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use option::{Some, None};\n@@ -200,7 +200,7 @@ mod tests {\n         assert (deq.get(3) == d);\n     }\n \n-    fn test_parameterized<T: Copy Eq Owned>(a: T, +b: T, +c: T, +d: T) {\n+    fn test_parameterized<T: Copy Eq Owned>(a: T, b: T, c: T, d: T) {\n         let deq: deque::Deque<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);"}, {"sha": "3df5a70a0c1f9d9dd13aa41f418abd4b3ddd5cde", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,4 @@\n+#[forbid(deprecated_mode)];\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -17,7 +18,7 @@ pub type Doc = {data: @~[u8], start: uint, end: uint};\n type TaggedDoc = {tag: uint, doc: Doc};\n \n impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(+tag: uint) -> Doc {\n+    pure fn index(tag: uint) -> Doc {\n         unsafe {\n             get_doc(self, tag)\n         }\n@@ -563,11 +564,11 @@ impl EbmlDeserializer: serialization::Deserializer {\n \n #[test]\n fn test_option_int() {\n-    fn serialize_1<S: serialization::Serializer>(&&s: S, v: int) {\n+    fn serialize_1<S: serialization::Serializer>(s: &S, v: int) {\n         s.emit_i64(v as i64);\n     }\n \n-    fn serialize_0<S: serialization::Serializer>(&&s: S, v: Option<int>) {\n+    fn serialize_0<S: serialization::Serializer>(s: &S, v: Option<int>) {\n         do s.emit_enum(~\"core::option::t\") {\n             match v {\n               None => s.emit_enum_variant(\n@@ -581,11 +582,11 @@ fn test_option_int() {\n         }\n     }\n \n-    fn deserialize_1<S: serialization::Deserializer>(&&s: S) -> int {\n+    fn deserialize_1<S: serialization::Deserializer>(s: &S) -> int {\n         s.read_i64() as int\n     }\n \n-    fn deserialize_0<S: serialization::Deserializer>(&&s: S) -> Option<int> {\n+    fn deserialize_0<S: serialization::Deserializer>(s: &S) -> Option<int> {\n         do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n                 match i {\n@@ -608,11 +609,11 @@ fn test_option_int() {\n         debug!(\"v == %?\", v);\n         let bytes = do io::with_bytes_writer |wr| {\n             let ebml_w = ebml::Writer(wr);\n-            serialize_0(ebml_w, v);\n+            serialize_0(&ebml_w, v);\n         };\n         let ebml_doc = ebml::Doc(@bytes);\n         let deser = ebml_deserializer(ebml_doc);\n-        let v1 = deserialize_0(deser);\n+        let v1 = deserialize_0(&deser);\n         debug!(\"v1 == %?\", v1);\n         assert v == v1;\n     }"}, {"sha": "f88aad1ac633afdbe51f01fb999f2f21d5f73213", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,4 @@\n+#[forbid(deprecated_mode)];\n use serialization2;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n@@ -31,7 +32,7 @@ struct TaggedDoc {\n }\n \n impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(+tag: uint) -> Doc {\n+    pure fn index(tag: uint) -> Doc {\n         unsafe {\n             get_doc(self, tag)\n         }"}, {"sha": "a1e29b03b4559e1c9772213fc5708566178ecef8", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n /*!\n  * A functional key,value store that works on anything.\n@@ -26,7 +26,7 @@ enum TreeNode<K, V> {\n pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, k: K, v: V)\n   -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n@@ -41,7 +41,7 @@ pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n }\n \n /// Find a value based on the key\n-pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n+pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@ref kk, @copy v, left, right) => {"}, {"sha": "6da51571e34a21cedea89c608ec53ac1f4778b09", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -61,8 +61,7 @@\n  *         do_work(input, output);\n  *     }\n  */\n-\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::result::{Err, Ok};\n@@ -162,7 +161,7 @@ fn name_str(nm: &Name) -> ~str {\n     };\n }\n \n-fn find_opt(opts: &[Opt], +nm: Name) -> Option<uint> {\n+fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n@@ -214,7 +213,7 @@ pub type Result = result::Result<Matches, Fail_>;\n  */\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let n_opts = vec::len::<Opt>(opts);\n-    fn f(+_x: uint) -> ~[Optval] { return ~[]; }\n+    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n     let l = vec::len(args);"}, {"sha": "09d00216209383fa90abe08c7dff15f57a41b3d5", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,6 +1,6 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n //! json serialization\n@@ -399,7 +399,7 @@ priv impl Parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: &str, +value: Json) -> Result<Json, Error> {\n+    fn parse_ident(ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(move value)"}, {"sha": "396edb548850d590b827224685d577fe97fa54ef", "filename": "src/libstd/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n //! A standard linked list\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::option;\n@@ -56,7 +56,7 @@ pub fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-pub fn has<T: Copy Eq>(ls: @List<T>, +elt: T) -> bool {\n+pub fn has<T: Copy Eq>(ls: @List<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if *e == elt { return true; }\n     }\n@@ -114,7 +114,7 @@ pub pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T: Copy>(ll: &mut @list<T>, +vv: T) {\n+pure fn push<T: Copy>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */"}, {"sha": "765d40339d3c0fdb57e7e6374ee2af31414cf9d4", "filename": "src/libstd/map.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,6 +1,5 @@\n //! A map type\n-\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use io::WriterUtil;\n use to_str::ToStr;\n@@ -28,7 +27,7 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n      *\n      * Returns true if the key did not already exist in the map\n      */\n-    fn insert(v: K, +v: V) -> bool;\n+    fn insert(v: K, v: V) -> bool;\n \n     /// Returns true if the map contains a value for the specified key\n     fn contains_key(key: K) -> bool;\n@@ -59,7 +58,7 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n     fn clear();\n \n     /// Iterate over all the key/value pairs in the map by value\n-    pure fn each(fn(key: K, +value: V) -> bool);\n+    pure fn each(fn(key: K, value: V) -> bool);\n \n     /// Iterate over all the keys in the map by value\n     pure fn each_key(fn(key: K) -> bool);\n@@ -213,7 +212,7 @@ pub mod chained {\n             }\n         }\n \n-        fn insert(k: K, +v: V) -> bool {\n+        fn insert(k: K, v: V) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n@@ -294,7 +293,7 @@ pub mod chained {\n             self.chains = chains(initial_capacity);\n         }\n \n-        pure fn each(blk: fn(key: K, +value: V) -> bool) {\n+        pure fn each(blk: fn(key: K, value: V) -> bool) {\n             self.each_ref(|k, v| blk(*k, *v))\n         }\n \n@@ -348,7 +347,7 @@ pub mod chained {\n     }\n \n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n-        pure fn index(+k: K) -> V {\n+        pure fn index(k: K) -> V {\n             unsafe {\n                 self.get(k)\n             }\n@@ -382,7 +381,7 @@ pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, key: K) -> bool {\n }\n \n /// Convert a set into a vector.\n-pub fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n+pub pure fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.size()) |push| {\n         for s.each_key() |k| {\n             push(k);\n@@ -459,7 +458,7 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n         }\n     }\n \n-    pure fn each(op: fn(key: K, +value: V) -> bool) {\n+    pure fn each(op: fn(key: K, value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n                 p.each(|k, v| op(*k, *v))"}, {"sha": "249551fbb7dfc7ae35bc64bfcfc8d3471c84652d", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,6 @@\n //! High-level interface to libuv's TCP functionality\n+// XXX Need FFI fixes\n+#[allow(deprecated_mode)];\n \n use ip = net_ip;\n use uv::iotask;\n@@ -121,16 +123,16 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n     let result_po = core::comm::Port::<ConnAttempt>();\n     let closed_signal_po = core::comm::Port::<()>();\n     let conn_data = {\n-        result_ch: core::comm::Chan(result_po),\n-        closed_signal_ch: core::comm::Chan(closed_signal_po)\n+        result_ch: core::comm::Chan(&result_po),\n+        closed_signal_ch: core::comm::Chan(&closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(&conn_data);\n     let reader_po = core::comm::Port::<result::Result<~[u8], TcpErrData>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n         reader_po: reader_po,\n-        reader_ch: core::comm::Chan(reader_po),\n+        reader_ch: core::comm::Chan(&reader_po),\n         stream_handle_ptr: stream_handle_ptr,\n         connect_req: uv::ll::connect_t(),\n         write_req: uv::ll::write_t(),\n@@ -324,7 +326,7 @@ pub fn read_start(sock: &TcpSocket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket,\n-             +read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+             read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(&(*sock.socket_data));\n@@ -471,7 +473,7 @@ pub fn accept(new_conn: TcpNewConnection)\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let client_socket_data = @{\n             reader_po: reader_po,\n-            reader_ch: core::comm::Chan(reader_po),\n+            reader_ch: core::comm::Chan(&reader_po),\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n@@ -482,7 +484,7 @@ pub fn accept(new_conn: TcpNewConnection)\n             (*client_socket_data_ptr).stream_handle_ptr;\n \n         let result_po = core::comm::Port::<Option<TcpErrData>>();\n-        let result_ch = core::comm::Chan(result_po);\n+        let result_ch = core::comm::Chan(&result_po);\n \n         // UNSAFE LIBUV INTERACTION BEGIN\n         // .. normally this happens within the context of\n@@ -558,8 +560,8 @@ pub fn accept(new_conn: TcpNewConnection)\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n-          +new_connect_cb: fn~(TcpNewConnection,\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     do listen_common(move host_ip, port, backlog, iotask, on_establish_cb)\n@@ -575,17 +577,17 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n-          +on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     let stream_closed_po = core::comm::Port::<()>();\n     let kill_po = core::comm::Port::<Option<TcpErrData>>();\n-    let kill_ch = core::comm::Chan(kill_po);\n+    let kill_ch = core::comm::Chan(&kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(&server_stream);\n     let server_data = {\n         server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: core::comm::Chan(stream_closed_po),\n+        stream_closed_ch: core::comm::Chan(&stream_closed_po),\n         kill_ch: kill_ch,\n         on_connect_cb: move on_connect_cb,\n         iotask: iotask,\n@@ -749,7 +751,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(buf: &[mut u8], +len: uint) -> uint {\n+    fn read(buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n             let read_result = read(&self.data.sock, 0u);\n@@ -785,13 +787,13 @@ impl TcpSocketBuf: io::Reader {\n         let mut bytes = ~[0];\n         if self.read(bytes, 1u) == 0 { fail } else { bytes[0] as int }\n     }\n-    fn unread_byte(+amt: int) {\n+    fn unread_byte(amt: int) {\n         self.data.buf.unshift(amt as u8);\n     }\n     fn eof() -> bool {\n         false // noop\n     }\n-    fn seek(+dist: int, +seek: io::SeekStyle) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n         log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n@@ -813,7 +815,7 @@ impl TcpSocketBuf: io::Writer {\n                              err_data.err_name, err_data.err_msg));\n         }\n     }\n-    fn seek(+dist: int, +seek: io::SeekStyle) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n       log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n         // noop\n     }\n@@ -832,7 +834,7 @@ impl TcpSocketBuf: io::Writer {\n \n fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n     let closed_po = core::comm::Port::<()>();\n-    let closed_ch = core::comm::Chan(closed_po);\n+    let closed_ch = core::comm::Chan(&closed_po);\n     let close_data = {\n         closed_ch: closed_ch\n     };\n@@ -895,7 +897,7 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n     result::Result<(), TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = core::comm::Port::<Option<TcpErrData>>();\n-    let stop_ch = core::comm::Chan(stop_po);\n+    let stop_ch = core::comm::Chan(&stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n@@ -922,7 +924,7 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n         result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = core::comm::Port::<Option<uv::ll::uv_err_data>>();\n-    let start_ch = core::comm::Chan(start_po);\n+    let start_ch = core::comm::Chan(&start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n@@ -961,7 +963,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n     let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n     let result_po = core::comm::Port::<TcpWriteResult>();\n     let write_data = {\n-        result_ch: core::comm::Chan(result_po)\n+        result_ch: core::comm::Chan(&result_po)\n     };\n     let write_data_ptr = ptr::addr_of(&write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| unsafe {\n@@ -1277,10 +1279,10 @@ mod test {\n         let expected_resp = ~\"pong\";\n \n         let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(server_result_po);\n+        let server_result_ch = core::comm::Chan(&server_result_po);\n \n         let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(cont_po);\n+        let cont_ch = core::comm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n@@ -1343,10 +1345,10 @@ mod test {\n         let expected_resp = ~\"pong\";\n \n         let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(server_result_po);\n+        let server_result_ch = core::comm::Chan(&server_result_po);\n \n         let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(cont_po);\n+        let cont_ch = core::comm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n@@ -1474,7 +1476,7 @@ mod test {\n         str::from_bytes(new_bytes)\n     }\n \n-    fn run_tcp_test_server(server_ip: &str, server_port: uint, +resp: ~str,\n+    fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n                           server_ch: comm::Chan<~str>,\n                           cont_ch: comm::Chan<()>,\n                           iotask: IoTask) -> ~str {"}, {"sha": "0ab4d89f363598c1c890fc5be5f31ca8e27efaef", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n //! Types/fns concerning URLs (see RFC 3986)\n-// tjc: forbid deprecated modes again after a snapshot\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use map::HashMap;\n@@ -27,15 +27,15 @@ type UserInfo = {\n \n pub type Query = ~[(~str, ~str)];\n \n-pub fn Url(scheme: ~str, +user: Option<UserInfo>, +host: ~str,\n-       +port: Option<~str>, +path: ~str, +query: Query,\n-       +fragment: Option<~str>) -> Url {\n+pub fn Url(scheme: ~str, user: Option<UserInfo>, host: ~str,\n+       port: Option<~str>, path: ~str, query: Query,\n+       fragment: Option<~str>) -> Url {\n     Url { scheme: move scheme, user: move user, host: move host,\n          port: move port, path: move path, query: move query,\n          fragment: move fragment }\n }\n \n-fn UserInfo(user: ~str, +pass: Option<~str>) -> UserInfo {\n+fn UserInfo(user: ~str, pass: Option<~str>) -> UserInfo {\n     {user: move user, pass: move pass}\n }\n \n@@ -726,7 +726,7 @@ impl Url : Eq {\n }\n \n impl Url: IterBytes {\n-    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         unsafe { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "e5336b7204d2977863bfa1aa442682146c9d9e16", "filename": "src/libstd/par.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_mode)];\n+\n use future_spawn = future::spawn;\n \n \n@@ -72,7 +74,7 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n }\n \n /// A parallel version of map.\n-pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], +f: fn~((&A)) -> B) -> ~[B] {\n+pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], f: fn~((&A)) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::map(slice, |x| f(x))\n@@ -82,7 +84,7 @@ pub fn map<A: Copy Send, B: Copy Send>(xs: &[A], +f: fn~((&A)) -> B) -> ~[B] {\n \n /// A parallel version of mapi.\n pub fn mapi<A: Copy Send, B: Copy Send>(xs: &[A],\n-                                    +f: fn~(uint, (&A)) -> B) -> ~[B] {\n+                                    f: fn~(uint, (&A)) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n@@ -119,7 +121,7 @@ pub fn mapi_factory<A: Copy Send, B: Copy Send>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Send>(xs: &[A], +f: fn~(uint, (&A)) -> bool) -> bool {\n+pub fn alli<A: Copy Send>(xs: &[A], f: fn~(uint, (&A)) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n@@ -130,7 +132,7 @@ pub fn alli<A: Copy Send>(xs: &[A], +f: fn~(uint, (&A)) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Send>(xs: &[A], +f: fn~(&(A)) -> bool) -> bool {\n+pub fn any<A: Copy Send>(xs: &[A], f: fn~(&(A)) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))"}, {"sha": "8ba00e65dec97537076b3abca99a54e8c54e243a", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,10 +1,12 @@\n //! Support code for serialization.\n \n+#[allow(deprecated_mode)];\n+\n /*\n Core serialization interfaces.\n */\n \n-trait Serializer {\n+pub trait Serializer {\n     // Primitive types:\n     fn emit_nil();\n     fn emit_uint(v: uint);\n@@ -37,7 +39,7 @@ trait Serializer {\n     fn emit_tup_elt(idx: uint, f: fn());\n }\n \n-trait Deserializer {\n+pub trait Deserializer {\n     // Primitive types:\n     fn read_nil() -> ();\n \n@@ -81,7 +83,7 @@ trait Deserializer {\n //\n // In some cases, these should eventually be coded as traits.\n \n-fn emit_from_vec<S: Serializer, T>(&&s: S, &&v: ~[T], f: fn(&&x: T)) {\n+pub fn emit_from_vec<S: Serializer, T>(&&s: S, &&v: ~[T], f: fn(&&x: T)) {\n     do s.emit_vec(vec::len(v)) {\n         for vec::eachi(v) |i,e| {\n             do s.emit_vec_elt(i) {\n@@ -91,15 +93,15 @@ fn emit_from_vec<S: Serializer, T>(&&s: S, &&v: ~[T], f: fn(&&x: T)) {\n     }\n }\n \n-fn read_to_vec<D: Deserializer, T: Copy>(&&d: D, f: fn() -> T) -> ~[T] {\n+pub fn read_to_vec<D: Deserializer, T: Copy>(&&d: D, f: fn() -> T) -> ~[T] {\n     do d.read_vec |len| {\n         do vec::from_fn(len) |i| {\n             d.read_vec_elt(i, || f())\n         }\n     }\n }\n \n-trait SerializerHelpers {\n+pub trait SerializerHelpers {\n     fn emit_from_vec<T>(&&v: ~[T], f: fn(&&x: T));\n }\n \n@@ -109,7 +111,7 @@ impl<S: Serializer> S: SerializerHelpers {\n     }\n }\n \n-trait DeserializerHelpers {\n+pub trait DeserializerHelpers {\n     fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n }\n \n@@ -119,127 +121,128 @@ impl<D: Deserializer> D: DeserializerHelpers {\n     }\n }\n \n-fn serialize_uint<S: Serializer>(&&s: S, v: uint) {\n+pub fn serialize_uint<S: Serializer>(&&s: S, v: uint) {\n     s.emit_uint(v);\n }\n \n-fn deserialize_uint<D: Deserializer>(&&d: D) -> uint {\n+pub fn deserialize_uint<D: Deserializer>(&&d: D) -> uint {\n     d.read_uint()\n }\n \n-fn serialize_u8<S: Serializer>(&&s: S, v: u8) {\n+pub fn serialize_u8<S: Serializer>(&&s: S, v: u8) {\n     s.emit_u8(v);\n }\n \n-fn deserialize_u8<D: Deserializer>(&&d: D) -> u8 {\n+pub fn deserialize_u8<D: Deserializer>(&&d: D) -> u8 {\n     d.read_u8()\n }\n \n-fn serialize_u16<S: Serializer>(&&s: S, v: u16) {\n+pub fn serialize_u16<S: Serializer>(&&s: S, v: u16) {\n     s.emit_u16(v);\n }\n \n-fn deserialize_u16<D: Deserializer>(&&d: D) -> u16 {\n+pub fn deserialize_u16<D: Deserializer>(&&d: D) -> u16 {\n     d.read_u16()\n }\n \n-fn serialize_u32<S: Serializer>(&&s: S, v: u32) {\n+pub fn serialize_u32<S: Serializer>(&&s: S, v: u32) {\n     s.emit_u32(v);\n }\n \n-fn deserialize_u32<D: Deserializer>(&&d: D) -> u32 {\n+pub fn deserialize_u32<D: Deserializer>(&&d: D) -> u32 {\n     d.read_u32()\n }\n \n-fn serialize_u64<S: Serializer>(&&s: S, v: u64) {\n+pub fn serialize_u64<S: Serializer>(&&s: S, v: u64) {\n     s.emit_u64(v);\n }\n \n-fn deserialize_u64<D: Deserializer>(&&d: D) -> u64 {\n+pub fn deserialize_u64<D: Deserializer>(&&d: D) -> u64 {\n     d.read_u64()\n }\n \n-fn serialize_int<S: Serializer>(&&s: S, v: int) {\n+pub fn serialize_int<S: Serializer>(&&s: S, v: int) {\n     s.emit_int(v);\n }\n \n-fn deserialize_int<D: Deserializer>(&&d: D) -> int {\n+pub fn deserialize_int<D: Deserializer>(&&d: D) -> int {\n     d.read_int()\n }\n \n-fn serialize_i8<S: Serializer>(&&s: S, v: i8) {\n+pub fn serialize_i8<S: Serializer>(&&s: S, v: i8) {\n     s.emit_i8(v);\n }\n \n-fn deserialize_i8<D: Deserializer>(&&d: D) -> i8 {\n+pub fn deserialize_i8<D: Deserializer>(&&d: D) -> i8 {\n     d.read_i8()\n }\n \n-fn serialize_i16<S: Serializer>(&&s: S, v: i16) {\n+pub fn serialize_i16<S: Serializer>(&&s: S, v: i16) {\n     s.emit_i16(v);\n }\n \n-fn deserialize_i16<D: Deserializer>(&&d: D) -> i16 {\n+pub fn deserialize_i16<D: Deserializer>(&&d: D) -> i16 {\n     d.read_i16()\n }\n \n-fn serialize_i32<S: Serializer>(&&s: S, v: i32) {\n+pub fn serialize_i32<S: Serializer>(&&s: S, v: i32) {\n     s.emit_i32(v);\n }\n \n-fn deserialize_i32<D: Deserializer>(&&d: D) -> i32 {\n+pub fn deserialize_i32<D: Deserializer>(&&d: D) -> i32 {\n     d.read_i32()\n }\n \n-fn serialize_i64<S: Serializer>(&&s: S, v: i64) {\n+pub fn serialize_i64<S: Serializer>(&&s: S, v: i64) {\n     s.emit_i64(v);\n }\n \n-fn deserialize_i64<D: Deserializer>(&&d: D) -> i64 {\n+pub fn deserialize_i64<D: Deserializer>(&&d: D) -> i64 {\n     d.read_i64()\n }\n \n-fn serialize_str<S: Serializer>(&&s: S, v: &str) {\n+pub fn serialize_str<S: Serializer>(&&s: S, v: &str) {\n     s.emit_str(v);\n }\n \n-fn deserialize_str<D: Deserializer>(&&d: D) -> ~str {\n+pub fn deserialize_str<D: Deserializer>(&&d: D) -> ~str {\n     d.read_str()\n }\n \n-fn serialize_float<S: Serializer>(&&s: S, v: float) {\n+pub fn serialize_float<S: Serializer>(&&s: S, v: float) {\n     s.emit_float(v);\n }\n \n-fn deserialize_float<D: Deserializer>(&&d: D) -> float {\n+pub fn deserialize_float<D: Deserializer>(&&d: D) -> float {\n     d.read_float()\n }\n \n-fn serialize_f32<S: Serializer>(&&s: S, v: f32) {\n+pub fn serialize_f32<S: Serializer>(&&s: S, v: f32) {\n     s.emit_f32(v);\n }\n \n-fn deserialize_f32<D: Deserializer>(&&d: D) -> f32 {\n+pub fn deserialize_f32<D: Deserializer>(&&d: D) -> f32 {\n     d.read_f32()\n }\n \n-fn serialize_f64<S: Serializer>(&&s: S, v: f64) {\n+pub fn serialize_f64<S: Serializer>(&&s: S, v: f64) {\n     s.emit_f64(v);\n }\n \n-fn deserialize_f64<D: Deserializer>(&&d: D) -> f64 {\n+pub fn deserialize_f64<D: Deserializer>(&&d: D) -> f64 {\n     d.read_f64()\n }\n \n-fn serialize_bool<S: Serializer>(&&s: S, v: bool) {\n+pub fn serialize_bool<S: Serializer>(&&s: S, v: bool) {\n     s.emit_bool(v);\n }\n \n-fn deserialize_bool<D: Deserializer>(&&d: D) -> bool {\n+pub fn deserialize_bool<D: Deserializer>(&&d: D) -> bool {\n     d.read_bool()\n }\n \n-fn serialize_Option<S: Serializer,T>(&&s: S, &&v: Option<T>, st: fn(&&x: T)) {\n+pub fn serialize_Option<S: Serializer,T>(&&s: S, &&v: Option<T>,\n+                                         st: fn(&&x: T)) {\n     do s.emit_enum(~\"option\") {\n         match v {\n           None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n@@ -254,7 +257,7 @@ fn serialize_Option<S: Serializer,T>(&&s: S, &&v: Option<T>, st: fn(&&x: T)) {\n     }\n }\n \n-fn deserialize_Option<D: Deserializer,T: Copy>(&&d: D, st: fn() -> T)\n+pub fn deserialize_Option<D: Deserializer,T: Copy>(&&d: D, st: fn() -> T)\n     -> Option<T> {\n     do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {"}, {"sha": "1582d90ce2d629037c2f8c7cb70a6c7ca763aad1", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,7 +2,7 @@\n  * A simple map based on a vector for small integer keys. Space requirements\n  * are O(highest integer key).\n  */\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::option;\n use core::option::{Some, None};\n@@ -103,7 +103,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     pure fn find(key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n \n-    pure fn each(it: fn(key: uint, +value: V) -> bool) {\n+    pure fn each(it: fn(key: uint, value: V) -> bool) {\n         self.each_ref(|k, v| it(*k, *v))\n     }\n     pure fn each_key(it: fn(key: uint) -> bool) {\n@@ -131,7 +131,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n }\n \n impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n-    pure fn index(+key: uint) -> V {\n+    pure fn index(key: uint) -> V {\n         unsafe {\n             get(self, key)\n         }"}, {"sha": "7fc3004bbcfa608bb414e2fe9e961df32dfa4eba", "filename": "src/libstd/std.rc", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -18,97 +18,82 @@ not required in or otherwise suitable for the core library.\n \n #[no_core];\n \n-#[legacy_exports];\n-\n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n+// XXX this is set to allow because there are two methods in serialization\n+// that can't be silenced otherwise. Most every module is set to forbid\n+#[allow(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n extern mod core(vers = \"0.4\");\n use core::*;\n \n-export net, net_tcp, net_ip, net_url;\n-export uv, uv_ll, uv_iotask, uv_global_loop;\n-export c_vec, timer;\n-export sync, arc, comm;\n-export bitv, deque, fun_treemap, list, map;\n-export smallintmap, sort, treemap;\n-export rope, arena, par;\n-export ebml, ebml2;\n-export dbg, getopts, json, rand, sha1, term, time;\n-export prettyprint, prettyprint2;\n-export test, tempfile, serialization, serialization2;\n-export cmp;\n-export base64;\n-export cell;\n-\n // General io and system-services modules\n \n-mod net;\n-mod net_ip;\n-mod net_tcp;\n-mod net_url;\n+pub mod net;\n+pub mod net_ip;\n+pub mod net_tcp;\n+pub mod net_url;\n \n // libuv modules\n-mod uv;\n-mod uv_ll;\n-mod uv_iotask;\n-mod uv_global_loop;\n+pub mod uv;\n+pub mod uv_ll;\n+pub mod uv_iotask;\n+pub mod uv_global_loop;\n \n \n // Utility modules\n \n-mod c_vec;\n-mod timer;\n-mod cell;\n+pub mod c_vec;\n+pub mod timer;\n+pub mod cell;\n \n // Concurrency\n \n-mod sync;\n-mod arc;\n-mod comm;\n+pub mod sync;\n+pub mod arc;\n+pub mod comm;\n \n // Collections\n \n-mod bitv;\n-mod deque;\n-mod fun_treemap;\n-mod list;\n-mod map;\n-mod rope;\n-mod smallintmap;\n-mod sort;\n-mod treemap;\n+pub mod bitv;\n+pub mod deque;\n+pub mod fun_treemap;\n+pub mod list;\n+pub mod map;\n+pub mod rope;\n+pub mod smallintmap;\n+pub mod sort;\n+pub mod treemap;\n \n // And ... other stuff\n \n-mod ebml;\n-mod ebml2;\n-mod dbg;\n-mod getopts;\n-mod json;\n-mod sha1;\n-mod md4;\n-mod tempfile;\n-mod term;\n-mod time;\n-mod prettyprint;\n-mod prettyprint2;\n-mod arena;\n-mod par;\n-mod cmp;\n-mod base64;\n+pub mod ebml;\n+pub mod ebml2;\n+pub mod dbg;\n+pub mod getopts;\n+pub mod json;\n+pub mod sha1;\n+pub mod md4;\n+pub mod tempfile;\n+pub mod term;\n+pub mod time;\n+pub mod prettyprint;\n+pub mod prettyprint2;\n+pub mod arena;\n+pub mod par;\n+pub mod cmp;\n+pub mod base64;\n \n #[cfg(unicode)]\n mod unicode;\n \n \n // Compiler support modules\n \n-mod test;\n-#[legacy_exports]\n-mod serialization;\n-mod serialization2;\n+pub mod test;\n+pub mod serialization;\n+pub mod serialization2;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "908f3936f4e1f1bed3fcb4e991b8cc8bcc20d572", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n /**\n  * The concurrency primitives you know and love.\n  *\n@@ -773,7 +773,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::p2::addr_of(&(*sharedstate));\n+        let ptr = ptr::addr_of(&(*sharedstate));\n         do task::spawn {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n@@ -1045,7 +1045,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::p2::addr_of(&(*sharedstate));\n+        let ptr = ptr::addr_of(&(*sharedstate));\n         do task::spawn {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };"}, {"sha": "9790622332a2b95838db2fec1e67191187370080", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -5,7 +5,7 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use either::Either;\n@@ -286,7 +286,7 @@ fn run_tests(opts: &TestOpts, tests: &[TestDesc],\n     let mut done_idx = 0;\n \n     let p = core::comm::Port();\n-    let ch = core::comm::Chan(p);\n+    let ch = core::comm::Chan(&p);\n \n     while done_idx < total {\n         while wait_idx < concurrency && run_idx < total {\n@@ -421,7 +421,7 @@ mod tests {\n             should_fail: false\n         };\n         let p = core::comm::Port();\n-        let ch = core::comm::Chan(p);\n+        let ch = core::comm::Chan(&p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n         assert res != TrOk;\n@@ -437,7 +437,7 @@ mod tests {\n             should_fail: false\n         };\n         let p = core::comm::Port();\n-        let ch = core::comm::Chan(p);\n+        let ch = core::comm::Chan(&p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n         assert res == TrIgnored;\n@@ -454,7 +454,7 @@ mod tests {\n             should_fail: true\n         };\n         let p = core::comm::Port();\n-        let ch = core::comm::Chan(p);\n+        let ch = core::comm::Chan(&p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n         assert res == TrOk;\n@@ -470,7 +470,7 @@ mod tests {\n             should_fail: true\n         };\n         let p = core::comm::Port();\n-        let ch = core::comm::Chan(p);\n+        let ch = core::comm::Chan(&p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n         assert res == TrFailed;"}, {"sha": "65872a013aba8247aae88528600a5f62832e5a7a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,4 @@\n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use libc::{c_char, c_int, c_long, size_t, time_t};\n@@ -7,16 +7,17 @@ use result::{Result, Ok, Err};\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n-    fn get_time(&sec: i64, &nsec: i32);\n-    fn precise_time_ns(&ns: u64);\n+    #[legacy_exports]\n+    fn get_time(sec: &mut i64, nsec: &mut i32);\n+\n+    fn precise_time_ns(ns: &mut u64);\n \n     fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n     fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n     fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    fn rust_timegm(&&tm: Tm, &sec: i64);\n-    fn rust_mktime(&&tm: Tm, &sec: i64);\n+    fn rust_timegm(&&tm: Tm, sec: &mut i64);\n+    fn rust_mktime(&&tm: Tm, sec: &mut i64);\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n@@ -36,20 +37,22 @@ impl Timespec : Eq {\n pub fn get_time() -> Timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n-    rustrt::get_time(sec, nsec);\n+    rustrt::get_time(&mut sec, &mut nsec);\n     return {sec: sec, nsec: nsec};\n }\n \n+\n /**\n  * Returns the current value of a high-resolution performance counter\n  * in nanoseconds since an unspecified epoch.\n  */\n pub fn precise_time_ns() -> u64 {\n     let mut ns = 0u64;\n-    rustrt::precise_time_ns(ns);\n+    rustrt::precise_time_ns(&mut ns);\n     ns\n }\n \n+\n /**\n  * Returns the current value of a high-resolution performance counter\n  * in seconds since an unspecified epoch.\n@@ -762,9 +765,9 @@ impl Tm {\n     fn to_timespec() -> Timespec {\n         let mut sec = 0i64;\n         if self.tm_gmtoff == 0_i32 {\n-            rustrt::rust_timegm(self, sec);\n+            rustrt::rust_timegm(self, &mut sec);\n         } else {\n-            rustrt::rust_mktime(self, sec);\n+            rustrt::rust_mktime(self, &mut sec);\n         }\n         { sec: sec, nsec: self.tm_nsec }\n     }"}, {"sha": "c9c28c4e1f0888f49a681bb954757d1c0fb7d13b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,6 +1,6 @@\n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-// tjc: forbid deprecated modes again after snap\n+#[forbid(deprecated_mode)];\n \n use uv = uv;\n use uv::iotask;\n@@ -27,7 +27,7 @@ pub fn delayed_send<T: Copy Send>(iotask: IoTask,\n                                   msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n-            let timer_done_ch = core::comm::Chan(timer_done_po);\n+            let timer_done_ch = core::comm::Chan(&timer_done_po);\n             let timer_done_ch_ptr = ptr::addr_of(&timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(&timer);\n@@ -74,7 +74,7 @@ pub fn delayed_send<T: Copy Send>(iotask: IoTask,\n  */\n pub fn sleep(iotask: IoTask, msecs: uint) {\n     let exit_po = core::comm::Port::<()>();\n-    let exit_ch = core::comm::Chan(exit_po);\n+    let exit_ch = core::comm::Chan(&exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n     core::comm::recv(exit_po);\n }\n@@ -103,7 +103,7 @@ pub fn recv_timeout<T: Copy Send>(iotask: IoTask,\n                               msecs: uint,\n                               wait_po: comm::Port<T>) -> Option<T> {\n     let timeout_po = comm::Port::<()>();\n-    let timeout_ch = comm::Chan(timeout_po);\n+    let timeout_ch = comm::Chan(&timeout_po);\n     delayed_send(iotask, msecs, timeout_ch, ());\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n@@ -162,7 +162,7 @@ mod test {\n     #[test]\n     fn test_gl_timer_sleep_stress2() {\n         let po = core::comm::Port();\n-        let ch = core::comm::Chan(po);\n+        let ch = core::comm::Chan(&po);\n         let hl_loop = uv::global_loop::get();\n \n         let repeat = 20u;\n@@ -240,7 +240,7 @@ mod test {\n         for iter::repeat(times as uint) {\n             let expected = rand::Rng().gen_str(16u);\n             let test_po = core::comm::Port::<~str>();\n-            let test_ch = core::comm::Chan(test_po);\n+            let test_ch = core::comm::Chan(&test_po);\n \n             do task::spawn() {\n                 delayed_send(hl_loop, 50u, test_ch, expected);"}, {"sha": "8ab0dc7f2e7da5c4101b5b3c75d97d0912f6b833", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -5,7 +5,7 @@\n  * very naive algorithm, but it will probably be updated to be a\n  * red-black tree or something else.\n  */\n-#[warn(deprecated_mode)];\n+#[forbid(deprecated_mode)];\n \n use core::cmp::{Eq, Ord};\n use core::option::{Some, None};\n@@ -26,7 +26,7 @@ enum TreeNode<K, V> = {\n pub fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n \n /// Insert a value into the map\n-pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, k: K, v: V) {\n     match copy *m {\n       None => {\n         *m = Some(@TreeNode({key: k,\n@@ -48,7 +48,7 @@ pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, +k: K, +v: V) {\n }\n \n /// Find a value based on the key\n-pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, +k: K)\n+pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, k: K)\n                               -> Option<V> {\n     match copy *m {\n       None => None,\n@@ -121,7 +121,7 @@ mod tests {\n         insert(m, 1, ());\n \n         let n = @mut 0;\n-        fn t(n: @mut int, +k: int, +_v: ()) {\n+        fn t(n: @mut int, k: int, _v: ()) {\n             assert (*n == k); *n += 1;\n         }\n         traverse(m, |x,y| t(n, *x, *y));"}, {"sha": "79f6bafb4a488095c00fdee20eec0121f632ca4b", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -133,12 +133,12 @@ mod test {\n \n     fn impl_uv_hl_simple_timer(iotask: IoTask) unsafe {\n         let exit_po = core::comm::Port::<bool>();\n-        let exit_ch = core::comm::Chan(exit_po);\n-        let exit_ch_ptr = ptr::p2::addr_of(&exit_ch);\n+        let exit_ch = core::comm::Chan(&exit_po);\n+        let exit_ch_ptr = ptr::addr_of(&exit_ch);\n         log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                        exit_ch_ptr));\n         let timer_handle = ll::timer_t();\n-        let timer_ptr = ptr::p2::addr_of(&timer_handle);\n+        let timer_ptr = ptr::addr_of(&timer_handle);\n         do iotask::interact(iotask) |loop_ptr| unsafe {\n             log(debug, ~\"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n@@ -166,7 +166,7 @@ mod test {\n     fn test_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n         let exit_po = comm::Port::<()>();\n-        let exit_ch = comm::Chan(exit_po);\n+        let exit_ch = comm::Chan(&exit_po);\n         task::spawn_sched(task::ManualThreads(1u), || {\n             impl_uv_hl_simple_timer(hl_loop);\n             core::comm::send(exit_ch, ());\n@@ -182,7 +182,7 @@ mod test {\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n         let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(exit_po);\n+        let exit_ch = core::comm::Chan(&exit_po);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n             task::spawn_sched(task::ManualThreads(1u), || {"}, {"sha": "ad40d96e4f77b28ed32290f721be492526071188", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,11 +4,10 @@\n  * The I/O task runs in its own single-threaded scheduler.  By using the\n  * `interact` function you can execute code in a uv callback.\n  */\n-\n-// tjc: forbid deprecated modes again after a snapshot\n+#[forbid(deprecated_mode)];\n \n use libc::c_void;\n-use ptr::p2::addr_of;\n+use ptr::addr_of;\n use comm = core::comm;\n use comm::{Port, Chan, listen};\n use task::TaskBuilder;\n@@ -60,7 +59,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * via ports/chans.\n  */\n pub unsafe fn interact(iotask: IoTask,\n-                   +cb: fn~(*c_void)) {\n+                   cb: fn~(*c_void)) {\n     send_msg(iotask, Interaction(move cb));\n }\n \n@@ -125,7 +124,7 @@ type IoTaskLoopData = {\n };\n \n fn send_msg(iotask: IoTask,\n-            +msg: IoTaskMsg) unsafe {\n+            msg: IoTaskMsg) unsafe {\n     iotask.op_chan.send(move msg);\n     ll::async_send(iotask.async_handle);\n }\n@@ -184,7 +183,7 @@ mod test {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(&async_handle);\n         let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(exit_po);\n+        let exit_ch = core::comm::Chan(&exit_po);\n         let ah_data = {\n             iotask: iotask,\n             exit_ch: exit_ch\n@@ -202,7 +201,7 @@ mod test {\n     // high_level_loop\n     unsafe fn spawn_test_loop(exit_ch: comm::Chan<()>) -> IoTask {\n         let iotask_port = comm::Port::<IoTask>();\n-        let iotask_ch = comm::Chan(iotask_port);\n+        let iotask_ch = comm::Chan(&iotask_port);\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n@@ -223,7 +222,7 @@ mod test {\n     #[test]\n     fn test_uv_iotask_async() unsafe {\n         let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(exit_po);\n+        let exit_ch = core::comm::Chan(&exit_po);\n         let iotask = spawn_test_loop(exit_ch);\n \n         // using this handle to manage the lifetime of the high_level_loop,\n@@ -233,7 +232,7 @@ mod test {\n         // lives until, at least, all of the impl_uv_hl_async() runs have been\n         // called, at least.\n         let work_exit_po = core::comm::Port::<()>();\n-        let work_exit_ch = core::comm::Chan(work_exit_po);\n+        let work_exit_ch = core::comm::Chan(&work_exit_po);\n         for iter::repeat(7u) {\n             do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_iotask_async(iotask);"}, {"sha": "f8c3882d15eb173cfb7ae0a11225c4309183f910", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1466,12 +1466,12 @@ pub mod test {\n         let kill_server_msg = ~\"does a dog have buddha nature?\";\n         let server_resp_msg = ~\"mu!\";\n         let client_port = core::comm::Port::<~str>();\n-        let client_chan = core::comm::Chan::<~str>(client_port);\n+        let client_chan = core::comm::Chan::<~str>(&client_port);\n         let server_port = core::comm::Port::<~str>();\n-        let server_chan = core::comm::Chan::<~str>(server_port);\n+        let server_chan = core::comm::Chan::<~str>(&server_port);\n \n         let continue_port = core::comm::Port::<bool>();\n-        let continue_chan = core::comm::Chan::<bool>(continue_port);\n+        let continue_chan = core::comm::Chan::<bool>(&continue_port);\n         let continue_chan_ptr = ptr::addr_of(&continue_chan);\n \n         do task::spawn_sched(task::ManualThreads(1)) {"}, {"sha": "a50189cf5989a701b22fdf9a6fdb2e979ac99a76", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -574,7 +574,7 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n \n // \"resolved\" mode: the real modes.\n #[auto_serialize]\n-enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n+enum rmode { by_ref, by_val, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {"}, {"sha": "4da9992b0dd36916396fa5677c53409d8e3b9fa8", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -48,7 +48,6 @@ trait ext_ctxt_ast_builder {\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n     fn arg(name: ident, ty: @ast::ty) -> ast::arg;\n-    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg;\n     fn expr_block(e: @ast::expr) -> ast::blk;\n     fn fn_decl(+inputs: ~[ast::arg], output: @ast::ty) -> ast::fn_decl;\n     fn item(name: ident, span: span, +node: ast::item_) -> @ast::item;\n@@ -177,13 +176,6 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n          id: self.next_id()}\n     }\n \n-    fn arg_mode(name: ident, ty: @ast::ty, mode: ast::rmode) -> ast::arg {\n-        {mode: ast::expl(mode),\n-         ty: ty,\n-         ident: name,\n-         id: self.next_id()}\n-    }\n-\n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = {view_items: ~[],\n                    stmts: stmts,"}, {"sha": "874ea01e9b01d1a2d4fe444b82751e20a40e7ae9", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -47,16 +47,15 @@ impl message: gen_send {\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg_mode(*n, *t, ast::by_copy)\n+                |n, t| cx.arg(*n, *t)\n             );\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n                 .add_tys(cx.ty_vars(this.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n-                              pipe_ty,\n-                              ast::by_copy)],\n+                ~[cx.arg(cx.ident_of(~\"pipe\"),\n+                              pipe_ty)],\n                 args_ast);\n \n             let mut body = ~\"{\\n\";\n@@ -129,15 +128,14 @@ impl message: gen_send {\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg_mode(cx.ident_of(*n), *t, ast::by_copy)\n+                    |n, t| cx.arg(cx.ident_of(*n), *t)\n                 );\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n+                    ~[cx.arg(cx.ident_of(~\"pipe\"),\n                                   cx.ty_path_ast_builder(\n                                       path(~[this.data_name()], span)\n-                                      .add_tys(cx.ty_vars(this.ty_params))),\n-                                  ast::by_copy)],\n+                                      .add_tys(cx.ty_vars(this.ty_params))))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {"}, {"sha": "4f265e1919c2eee2b34a9dc6b01fe51e9d863934", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -127,14 +127,14 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: string_reader, &comments: ~[cmnt]) {\n+fn push_blank_line_comment(rdr: string_reader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     comments.push({style: blank_line, lines: v, pos: rdr.chpos});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n-                                           &comments: ~[cmnt]) {\n+                                           comments: &mut ~[cmnt]) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) {\n         if rdr.col == 0u && rdr.curr == '\\n' {\n             push_blank_line_comment(rdr, comments);\n@@ -145,7 +145,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n \n \n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: ~[cmnt]) {\n+                                            comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.chpos;\n     debug!(\"<<< shebang comment\");\n@@ -157,7 +157,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n }\n \n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: ~[cmnt]) {\n+                                          comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n@@ -188,8 +188,8 @@ fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n     return true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n-                                        s: ~str, col: uint) unsafe {\n+fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n+                                        s: ~str, col: uint) {\n     let mut s1;\n     let len = str::len(s);\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n@@ -202,7 +202,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: ~[cmnt]) {\n+                                          comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n@@ -228,7 +228,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n         debug!(\"=== block comment level %d\", level);\n         if is_eof(rdr) {(rdr as reader).fatal(~\"unterminated block comment\");}\n         if rdr.curr == '\\n' {\n-            trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+            trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n             curr_line = ~\"\";\n             bump(rdr);\n         } else {\n@@ -248,8 +248,8 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n             }\n         }\n     }\n-    if str::len(curr_line) != 0u {\n-        trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+    if str::len(curr_line) != 0 {\n+        trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n     }\n     let mut style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n@@ -267,7 +267,7 @@ fn peeking_at_comment(rdr: string_reader) -> bool {\n }\n \n fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n-                   &comments: ~[cmnt]) {\n+                   comments: &mut ~[cmnt]) {\n     debug!(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n@@ -299,11 +299,11 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n             consume_non_eol_whitespace(rdr);\n             if rdr.curr == '\\n' {\n                 code_to_the_left = false;\n-                consume_whitespace_counting_blank_lines(rdr, comments);\n+                consume_whitespace_counting_blank_lines(rdr, &mut comments);\n             }\n             while peeking_at_comment(rdr) {\n-                consume_comment(rdr, code_to_the_left, comments);\n-                consume_whitespace_counting_blank_lines(rdr, comments);\n+                consume_comment(rdr, code_to_the_left, &mut comments);\n+                consume_whitespace_counting_blank_lines(rdr, &mut comments);\n             }\n             break;\n         }"}, {"sha": "c91060284910fda1eaf66293271dbe6b7b0c18aa", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,8 +10,8 @@ type ctx =\n fn eval_crate_directives(cx: ctx,\n                          cdirs: ~[@ast::crate_directive],\n                          prefix: &Path,\n-                         &view_items: ~[@ast::view_item],\n-                         &items: ~[@ast::item]) {\n+                         view_items: &mut~[@ast::view_item],\n+                         items: &mut~[@ast::item]) {\n     for cdirs.each |sub_cdir| {\n         eval_crate_directive(cx, *sub_cdir, prefix, view_items, items);\n     }\n@@ -24,7 +24,7 @@ fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n         = parse_companion_mod(cx, prefix, suffix);\n     let mut view_items: ~[@ast::view_item] = ~[];\n     let mut items: ~[@ast::item] = ~[];\n-    eval_crate_directives(cx, cdirs, prefix, view_items, items);\n+    eval_crate_directives(cx, cdirs, prefix, &mut view_items, &mut items);\n     return ({view_items: vec::append(view_items, cview_items),\n           items: vec::append(items, citems)},\n          cattrs);\n@@ -82,8 +82,8 @@ fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n }\n \n fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n-                        &view_items: ~[@ast::view_item],\n-                        &items: ~[@ast::item]) {\n+                        view_items: &mut ~[@ast::view_item],\n+                        items: &mut ~[@ast::item]) {\n     match cdir.node {\n       ast::cdir_src_mod(vis, id, attrs) => {\n         let file_path = Path(cdir_path_opt("}, {"sha": "828d498ca3c236d047f1fc27d2916c4129cb8711", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -22,7 +22,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteClassMethod,\n     ObsoleteClassTraits,\n     ObsoletePrivSection,\n-    ObsoleteModeInFnType\n+    ObsoleteModeInFnType,\n+    ObsoleteByMutRefMode\n }\n \n impl ObsoleteSyntax : cmp::Eq {\n@@ -94,6 +95,10 @@ impl parser : ObsoleteReporter {\n                 \"to use a (deprecated) mode in a fn type, you should \\\n                  give the argument an explicit name (like `&&v: int`)\"\n             ),\n+            ObsoleteByMutRefMode => (\n+                \"by-mutable-reference mode\",\n+                \"Declare an argument of type &mut T instead\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "22c25186c91826d6280b5d9c7599d9c3f89b82fc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -20,13 +20,13 @@ use obsolete::{\n     ObsoleteLowerCaseKindBounds, ObsoleteLet,\n     ObsoleteFieldTerminator, ObsoleteStructCtor,\n     ObsoleteWith, ObsoleteClassMethod, ObsoleteClassTraits,\n-    ObsoleteModeInFnType\n+    ObsoleteModeInFnType, ObsoleteByMutRefMode\n };\n use ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              bind_by_ref, bind_by_implicit_ref, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n              bound_copy, bound_send, bound_trait, bound_owned, box, by_copy,\n-             by_move, by_mutbl_ref, by_ref, by_val, capture_clause,\n+             by_move, by_ref, by_val, capture_clause,\n              capture_item, cdir_dir_mod, cdir_src_mod, cdir_view_item,\n              class_immutable, class_mutable,\n              crate, crate_cfg, crate_directive, decl, decl_item, decl_local,\n@@ -570,7 +570,10 @@ impl parser {\n \n     fn parse_arg_mode() -> mode {\n         if self.eat(token::BINOP(token::AND)) {\n-            expl(by_mutbl_ref)\n+            self.obsolete(copy self.span,\n+                          ObsoleteByMutRefMode);\n+            // Bogus mode, but doesn't matter since it's an error\n+            expl(by_ref)\n         } else if self.eat(token::BINOP(token::MINUS)) {\n             expl(by_move)\n         } else if self.eat(token::ANDAND) {\n@@ -1275,7 +1278,8 @@ impl parser {\n \n         return match self.token {\n           token::LPAREN | token::LBRACE | token::LBRACKET => {\n-            let ket = token::flip_delimiter(self.token);\n+              // tjc: ??????\n+            let ket = token::flip_delimiter(copy self.token);\n             tt_delim(vec::append(\n                 ~[parse_tt_tok(self, true)],\n                 vec::append(\n@@ -1296,7 +1300,8 @@ impl parser {\n         return match self.token {\n           token::LBRACE | token::LPAREN | token::LBRACKET => {\n             self.parse_matcher_subseq(name_idx, copy self.token,\n-                                      token::flip_delimiter(self.token))\n+                                      // tjc: not sure why we need a copy\n+                                      token::flip_delimiter(copy self.token))\n           }\n           _ => self.fatal(~\"expected open delimiter\")\n         }"}, {"sha": "99b789cf63fc7bbe01d9612711a8cdcc77c6cf88", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -230,7 +230,7 @@ pure fn can_begin_expr(t: token) -> bool {\n }\n \n /// what's the opposite delimiter?\n-fn flip_delimiter(&t: token::token) -> token::token {\n+fn flip_delimiter(t: token::token) -> token::token {\n     match t {\n       token::LPAREN => token::RPAREN,\n       token::LBRACE => token::RBRACE,"}, {"sha": "bff356e5cb72751a8a28821c1dc00fa51d4e1cb9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1688,7 +1688,6 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n \n fn mode_to_str(m: ast::mode) -> ~str {\n     match m {\n-      ast::expl(ast::by_mutbl_ref) => ~\"&\",\n       ast::expl(ast::by_move) => ~\"-\",\n       ast::expl(ast::by_ref) => ~\"&&\",\n       ast::expl(ast::by_val) => ~\"++\","}, {"sha": "dc4cdbf052288794ac418f310e7f5cfa609f5902", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1 +1 @@\n-Subproject commit c51053bf71de475df6a91204acd9ad78f4747c38\n+Subproject commit dc4cdbf052288794ac418f310e7f5cfa609f5902"}, {"sha": "805ec37bfeaed16700b02b6069f451f5cfbf7942", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -67,11 +67,6 @@ command_line_args : public kernel_owned<command_line_args>\n     }\n };\n \n-// A global that indicates whether Rust typestate claim statements should be\n-// executed Generated code will read this variable directly (I think).\n-// FIXME (#2670): This belongs somewhere else\n-int check_claims = 0;\n-\n void* global_crate_map = NULL;\n \n /**\n@@ -94,9 +89,6 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n     update_log_settings(crate_map, env->logspec);\n \n-    // Maybe turn on typestate claim checking\n-    check_claims = env->check_claims;\n-\n     rust_kernel *kernel = new rust_kernel(env);\n \n     // Create the main scheduler and the main task"}, {"sha": "268aca965d70012a74b117d8135c7cab2fbb4f24", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,7 +10,6 @@\n #define RUST_MIN_STACK \"RUST_MIN_STACK\"\n #define RUST_MAX_STACK \"RUST_MAX_STACK\"\n #define RUST_LOG \"RUST_LOG\"\n-#define CHECK_CLAIMS \"CHECK_CLAIMS\"\n #define DETAILED_LEAKS \"DETAILED_LEAKS\"\n #define RUST_SEED \"RUST_SEED\"\n #define RUST_POISON_ON_FREE \"RUST_POISON_ON_FREE\"\n@@ -114,7 +113,6 @@ load_env(int argc, char **argv) {\n     env->min_stack_size = get_min_stk_size();\n     env->max_stack_size = get_max_stk_size();\n     env->logspec = copyenv(RUST_LOG);\n-    env->check_claims = getenv(CHECK_CLAIMS) != NULL;\n     env->detailed_leaks = getenv(DETAILED_LEAKS) != NULL;\n     env->rust_seed = copyenv(RUST_SEED);\n     env->poison_on_free = getenv(RUST_POISON_ON_FREE) != NULL;"}, {"sha": "8a0ff4d1df1884a1fde8c69f015544c11b4c08a5", "filename": "src/rt/rust_env.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_env.h", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_env.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.h?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -9,7 +9,6 @@ struct rust_env {\n     size_t min_stack_size;\n     size_t max_stack_size;\n     char* logspec;\n-    bool check_claims;\n     bool detailed_leaks;\n     char* rust_seed;\n     bool poison_on_free;"}, {"sha": "ec60af87b6b2ba7047fe9e55f53af7ae5ebe3c2e", "filename": "src/rt/rust_globals.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_globals.h", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frust_globals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_globals.h?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -69,10 +69,6 @@ extern \"C\" {\n #define FASTCALL\n #endif\n \n-/* Controls whether claims are turned into checks */\n-/* Variable name must be kept consistent with trans.rs */\n-extern \"C\" int check_claims;\n-\n #define CHECKED(call)                                               \\\n     {                                                               \\\n     int res = (call);                                               \\"}, {"sha": "890aa352c927deec2371fdac00161f5ca59c8012", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,3 @@\n-check_claims\n debug_box\n debug_fn\n debug_opaque"}, {"sha": "c60904419d5f390f755032e17f5cb693f80da8dd", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -22,15 +22,15 @@ use syntax::diagnostic;\n use rustc::driver::session;\n use rustc::middle::lint;\n \n-fn version(argv0: ~str) {\n+fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n-    if str::len(env_vers) != 0u { vers = env_vers; }\n+    if env_vers.len() != 0 { vers = env_vers; }\n     io::println(fmt!(\"%s %s\", argv0, vers));\n     io::println(fmt!(\"host: %s\", host_triple()));\n }\n \n-fn usage(argv0: ~str) {\n+fn usage(argv0: &str) {\n     io::println(fmt!(\"Usage: %s [options] <input>\\n\", argv0) +\n                  ~\"\n Options:\n@@ -86,7 +86,7 @@ fn describe_warnings() {\n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n     for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n-    fn padded(max: uint, s: ~str) -> ~str {\n+    fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n     io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n@@ -117,14 +117,14 @@ fn describe_debug_flags() {\n     }\n }\n \n-fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n+fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n-    let mut args = args;\n+    let mut args = *args;\n     let binary = args.shift();\n \n-    if vec::len(args) == 0u { usage(binary); return; }\n+    if args.is_empty() { usage(binary); return; }\n \n     let matches =\n         match getopts::getopts(args, opts()) {\n@@ -229,7 +229,7 @@ bug and need to present an error.\n */\n fn monitor(+f: fn~(diagnostic::emitter)) {\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n \n     match do task::try |move f| {\n \n@@ -277,9 +277,10 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n     }\n }\n \n-fn main(args: ~[~str]) {\n-    do monitor |demitter| {\n-        run_compiler(args, demitter);\n+fn main() {\n+    let mut args = os::args();\n+    do monitor |move args, demitter| {\n+        run_compiler(&args, demitter);\n     }\n }\n "}, {"sha": "1a6cc6dd895e03f71f37d51a2143cf34d901e6ac", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -415,34 +415,12 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let str_pt = path_node(~[cx.sess.ident_of(~\"str\")]);\n-    let str_ty_inner = @{id: cx.sess.next_node_id(),\n-                         node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n-                         span: dummy_sp()};\n-    let str_ty = @{id: cx.sess.next_node_id(),\n-                   node: ast::ty_uniq({ty: str_ty_inner, mutbl: ast::m_imm}),\n-                   span: dummy_sp()};\n-    let args_mt = {ty: str_ty, mutbl: ast::m_imm};\n-    let args_ty_inner = @{id: cx.sess.next_node_id(),\n-                          node: ast::ty_vec(args_mt),\n-                          span: dummy_sp()};\n-    let args_ty = {id: cx.sess.next_node_id(),\n-                   node: ast::ty_uniq({ty: args_ty_inner, mutbl: ast::m_imm}),\n-                   span: dummy_sp()};\n-\n-\n-    let args_arg: ast::arg =\n-        {mode: ast::expl(ast::by_val),\n-         ty: @args_ty,\n-         ident: cx.sess.ident_of(~\"args\"),\n-         id: cx.sess.next_node_id()};\n-\n     let ret_ty = {id: cx.sess.next_node_id(),\n                   node: ast::ty_nil,\n                   span: dummy_sp()};\n \n     let decl: ast::fn_decl =\n-        {inputs: ~[args_arg],\n+        {inputs: ~[],\n          output: @ret_ty,\n          cf: ast::return_val};\n \n@@ -465,16 +443,24 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n }\n \n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n-\n-    // Get the args passed to main so we can pass the to test_main\n-    let args_path = path_node(~[cx.sess.ident_of(~\"args\")]);\n+    // Call os::args to generate the vector of test_descs\n+    let args_path = path_node(~[\n+        cx.sess.ident_of(~\"os\"),\n+        cx.sess.ident_of(~\"args\")\n+    ]);\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),\n          node: args_path_expr_, span: dummy_sp()};\n \n+    let args_call_expr_ = ast::expr_call(@args_path_expr, ~[], false);\n+\n+    let args_call_expr: ast::expr =\n+        {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),\n+         node: args_call_expr_, span: dummy_sp()};\n+\n     // Call __test::test to generate the vector of test_descs\n     let test_path = path_node(~[cx.sess.ident_of(~\"tests\")]);\n \n@@ -503,7 +489,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     let test_main_call_expr_: ast::expr_ =\n         ast::expr_call(@test_main_path_expr,\n-                       ~[@args_path_expr, @test_call_expr], false);\n+                       ~[@args_call_expr, @test_call_expr], false);\n \n     let test_main_call_expr: ast::expr =\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),"}, {"sha": "a65c25a46eff1d010476fd150a2ce6cb37d4873f", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -34,6 +34,7 @@ export metadata_encoding_version;\n export def_to_str;\n export encode_ctxt;\n export write_type;\n+export write_vstore;\n export encode_def_id;\n \n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n@@ -116,7 +117,7 @@ fn encode_mutability(ebml_w: ebml::Writer, mt: class_mutability) {\n type entry<T> = {val: T, pos: uint};\n \n fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: &[ident],\n-                &index: ~[entry<~str>], name: ident) {\n+                index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n     full_path.push(name);\n@@ -180,6 +181,16 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n+fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Writer, vstore: ty::vstore) {\n+    let ty_str_ctxt =\n+        @{diag: ecx.diag,\n+          ds: def_to_str,\n+          tcx: ecx.tcx,\n+          reachable: |a| reachable(ecx, a),\n+          abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n+}\n+\n fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);"}, {"sha": "1375ff2d0be08d14a2f2cf3e393e6186abfafb96", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -394,7 +394,6 @@ fn parse_arg(st: @pstate, conv: conv_did) -> ty::arg {\n \n fn parse_mode(st: @pstate) -> ast::mode {\n     let m = ast::expl(match next(st) {\n-        '&' => ast::by_mutbl_ref,\n         '-' => ast::by_move,\n         '+' => ast::by_copy,\n         '=' => ast::by_ref,"}, {"sha": "69689b16e15423dd90a7c1cd859650138b2bb722", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -16,6 +16,7 @@ export enc_ty;\n export enc_bounds;\n export enc_mode;\n export enc_arg;\n+export enc_vstore;\n \n type ctxt = {\n     diag: span_handler,\n@@ -332,7 +333,6 @@ fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n \n fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n-      by_mutbl_ref => w.write_char('&'),\n       by_move => w.write_char('-'),\n       by_copy => w.write_char('+'),\n       by_ref => w.write_char('='),"}, {"sha": "a364c1d75d430729fb33b5e8bbfc4fa43f1bfe2c", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -490,8 +490,11 @@ impl method_origin: tr {\n           typeck::method_param(mp) => {\n             typeck::method_param({trait_id:mp.trait_id.tr(xcx),.. mp})\n           }\n-          typeck::method_trait(did, m) => {\n-            typeck::method_trait(did.tr(xcx), m)\n+          typeck::method_trait(did, m, vstore) => {\n+            typeck::method_trait(did.tr(xcx), m, vstore)\n+          }\n+          typeck::method_self(did, m) => {\n+            typeck::method_self(did.tr(xcx), m)\n           }\n         }\n     }\n@@ -631,6 +634,7 @@ impl @e::encode_ctxt: get_ty_str_ctxt {\n trait ebml_writer_helpers {\n     fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg);\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t);\n+    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore);\n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]);\n     fn emit_bounds(ecx: @e::encode_ctxt, bs: ty::param_bounds);\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n@@ -643,6 +647,12 @@ impl ebml::Writer: ebml_writer_helpers {\n         }\n     }\n \n+    fn emit_vstore(ecx: @e::encode_ctxt, vstore: ty::vstore) {\n+        do self.emit_opaque {\n+            e::write_vstore(ecx, self, vstore)\n+        }\n+    }\n+\n     fn emit_arg(ecx: @e::encode_ctxt, arg: ty::arg) {\n         do self.emit_opaque {\n             tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);"}, {"sha": "e2f7ba20642aaf23563b83f7b06c257bf33fca49", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -396,10 +396,10 @@ type req_maps = {\n     pure_map: HashMap<ast::node_id, bckerr>\n };\n \n-fn save_and_restore<T:Copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n-    let old_save_and_restore_t = save_and_restore_t;\n+fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n+    let old_save_and_restore_t = *save_and_restore_t;\n     let u <- f();\n-    save_and_restore_t = old_save_and_restore_t;\n+    *save_and_restore_t = old_save_and_restore_t;\n     move u\n }\n "}, {"sha": "cc8d89a8ace76873dd5cf2ae355580cf3c64c80b", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -529,7 +529,7 @@ impl check_loan_ctxt {\n                 ast::by_move => {\n                     self.check_move_out(*arg);\n                 }\n-                ast::by_mutbl_ref | ast::by_ref |\n+                ast::by_ref |\n                 ast::by_copy | ast::by_val => {\n                 }\n             }\n@@ -542,9 +542,9 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore(self.in_ctor) {\n-        do save_and_restore(self.declared_purity) {\n-            do save_and_restore(self.fn_args) {\n+    do save_and_restore(&mut(self.in_ctor)) {\n+        do save_and_restore(&mut(self.declared_purity)) {\n+            do save_and_restore(&mut(self.fn_args)) {\n                 let is_stack_closure = self.is_stack_closure(id);\n                 let fty = ty::node_id_to_type(self.tcx(), id);\n                 self.declared_purity = ty::determine_inherited_purity(\n@@ -667,7 +667,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n fn check_loans_in_block(blk: ast::blk,\n                         &&self: check_loan_ctxt,\n                         vt: visit::vt<check_loan_ctxt>) {\n-    do save_and_restore(self.declared_purity) {\n+    do save_and_restore(&mut(self.declared_purity)) {\n         self.check_for_conflicting_loans(blk.node.id);\n \n         match blk.node.rules {"}, {"sha": "5dfde8c9af649c4844c240e6439b786226a2640d", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -115,10 +115,6 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let scope_r = ty::re_scope(ex.id);\n         for vec::each2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_mutbl_ref => {\n-                let arg_cmt = self.bccx.cat_expr(*arg);\n-                self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n-              }\n               ast::by_ref => {\n                 let arg_cmt = self.bccx.cat_expr(*arg);\n                 self.guarantee_valid(arg_cmt, m_imm,  scope_r);"}, {"sha": "e2b85441a8fda17657dbd5f01544369d27ccac8d", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -323,7 +323,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n             match ty::arg_mode(cx.tcx, *arg_t) {\n               by_copy => maybe_copy(cx, args[i], None),\n-              by_ref | by_val | by_mutbl_ref | by_move => ()\n+              by_ref | by_val | by_move => ()\n             }\n             i += 1u;\n         }\n@@ -335,7 +335,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             Some(ref mme) => {\n                 match ty::arg_mode(cx.tcx, mme.self_arg) {\n                     by_copy => maybe_copy(cx, lhs, None),\n-                    by_ref | by_val | by_mutbl_ref | by_move => ()\n+                    by_ref | by_val | by_move => ()\n                 }\n             }\n             _ => ()\n@@ -465,14 +465,7 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n             cx.tcx.sess.span_err(sp, msg);\n         }\n       }\n-      def_arg(_, mode) => {\n-        match ty::resolved_mode(cx.tcx, mode) {\n-          by_ref | by_val | by_move | by_copy => { /* ok */ }\n-          by_mutbl_ref => {\n-            cx.tcx.sess.span_err(sp, msg);\n-          }\n-        }\n-      }\n+      def_arg(*) => { /* ok */ }\n       def_upvar(_, def1, _, _) => {\n         check_imm_free_var(cx, *def1, sp);\n       }"}, {"sha": "12d63cdacbf6729f4506d4e628014d076477dd15", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -398,7 +398,7 @@ impl IrMaps {\n \n             (*v).push(id);\n           }\n-          Arg(_, _, by_ref) | Arg(_, _, by_mutbl_ref) |\n+          Arg(_, _, by_ref) |\n           Arg(_, _, by_val) | Self | Field(_) | ImplicitRet |\n           Local(LocalInfo {kind: FromMatch(bind_by_implicit_ref), _}) => {\n             debug!(\"--but it is not owned\");\n@@ -831,9 +831,9 @@ impl Liveness {\n         let mut changed = false;\n         do self.indices2(ln, succ_ln) |idx, succ_idx| {\n             changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n-                                       self.users[idx].reader);\n+                                       &mut self.users[idx].reader);\n             changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n-                                       self.users[idx].writer);\n+                                       &mut self.users[idx].writer);\n             if self.users[succ_idx].used && !self.users[idx].used {\n                 self.users[idx].used = true;\n                 changed = true;\n@@ -844,10 +844,10 @@ impl Liveness {\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n-        fn copy_if_invalid(src: LiveNode, &dst: LiveNode) -> bool {\n+        fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n             if src.is_valid() {\n                 if !dst.is_valid() {\n-                    dst = src;\n+                    *dst = src;\n                     return true;\n                 }\n             }\n@@ -919,7 +919,7 @@ impl Liveness {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n             match ty::resolved_mode(self.tcx, arg.mode) {\n-              by_mutbl_ref | by_ref | by_val => {\n+              by_ref | by_val => {\n                 // These are \"non-owned\" modes, so register a read at\n                 // the end.  This will prevent us from moving out of\n                 // such variables but also prevent us from registering\n@@ -1573,7 +1573,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n         let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n         for vec::each2(args, targs) |arg_expr, arg_ty| {\n             match ty::resolved_mode(self.tcx, arg_ty.mode) {\n-                by_val | by_copy | by_ref | by_mutbl_ref => {}\n+                by_val | by_copy | by_ref => {}\n                 by_move => {\n                     self.check_move_from_expr(*arg_expr, vt);\n                 }\n@@ -1865,24 +1865,7 @@ impl @Liveness {\n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             let var = self.variable(arg.id, arg.ty.span);\n-            match ty::resolved_mode(self.tcx, arg.mode) {\n-              by_mutbl_ref => {\n-                // for mutable reference arguments, something like\n-                //    x = 1;\n-                // is not worth warning about, as it has visible\n-                // side effects outside the fn.\n-                match self.assigned_on_entry(entry_ln, var) {\n-                  Some(_) => { /*ok*/ }\n-                  None => {\n-                    // but if it is not written, it ought to be used\n-                    self.warn_about_unused(sp, entry_ln, var);\n-                  }\n-                }\n-              }\n-              by_val | by_ref | by_move | by_copy => {\n-                self.warn_about_unused(sp, entry_ln, var);\n-              }\n-            }\n+            self.warn_about_unused(sp, entry_ln, var);\n         }\n     }\n "}, {"sha": "dc5874ea2cfaebe2e19149a2b10f0d9553cbe94d", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -523,9 +523,6 @@ impl &mem_categorization_ctxt {\n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n             let {m,lp} = match ty::resolved_mode(self.tcx, mode) {\n-              ast::by_mutbl_ref => {\n-                {m: m_mutbl, lp: None}\n-              }\n               ast::by_move | ast::by_copy => {\n                 {m: m_imm, lp: Some(@lp_arg(vid))}\n               }"}, {"sha": "98260a0d0819b75f1b718dca4e9c5b494ed313e6", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,8 +8,8 @@ use syntax::ast::{item_trait, local_crate, node_id, pat_struct, private};\n use syntax::ast::{provided, required};\n use syntax::ast_map::{node_item, node_method};\n use ty::ty_class;\n-use typeck::{method_map, method_origin, method_param, method_static};\n-use typeck::{method_trait};\n+use typeck::{method_map, method_origin, method_param, method_self};\n+use typeck::{method_static, method_trait};\n \n use core::util::ignore;\n use dvec::DVec;\n@@ -81,7 +81,8 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                 }\n             }\n             method_param({trait_id: trait_id, method_num: method_num, _}) |\n-            method_trait(trait_id, method_num) => {\n+            method_trait(trait_id, method_num, _) |\n+            method_self(trait_id, method_num) => {\n                 if trait_id.crate == local_crate {\n                     match tcx.items.find(trait_id.node) {\n                         Some(node_item(item, _)) => {"}, {"sha": "5f30346a28e8f90fff6f4d1d84b9655cf5ed040e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4181,9 +4181,9 @@ impl Resolver {\n         }\n \n         return self.resolve_identifier(path.idents.last(),\n-                                    namespace,\n-                                    check_ribs,\n-                                    path.span);\n+                                       namespace,\n+                                       check_ribs,\n+                                       path.span);\n     }\n \n     fn resolve_identifier(identifier: ident,"}, {"sha": "95711f8da36a73112f04505ec39c744a55925d97", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -21,7 +21,7 @@ use session::session;\n use syntax::attr;\n use back::{link, abi, upcall};\n use syntax::{ast, ast_util, codemap, ast_map};\n-use ast_util::{local_def, path_to_ident};\n+use ast_util::{def_id_of_def, local_def, path_to_ident};\n use syntax::visit;\n use syntax::codemap::span;\n use syntax::print::pprust::{expr_to_str, stmt_to_str, path_to_str};\n@@ -1503,7 +1503,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt,\n         // the event it's not truly needed.\n         let llarg;\n         match ty::resolved_mode(tcx, arg_ty.mode) {\n-            ast::by_ref | ast::by_mutbl_ref => {\n+            ast::by_ref => {\n                 llarg = raw_llarg;\n             }\n             ast::by_move | ast::by_copy => {\n@@ -1847,8 +1847,48 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms) => {\n-        meth::trans_impl(ccx, *path, item.ident, ms, tps);\n+      ast::item_impl(tps, trait_refs, self_ast_ty, ms) => {\n+        meth::trans_impl(ccx, *path, item.ident, ms, tps, None);\n+\n+        // Translate any methods that have provided implementations.\n+        for trait_refs.each |trait_ref_ptr| {\n+            let trait_def = ccx.tcx.def_map.get(trait_ref_ptr.ref_id);\n+\n+            // XXX: Cross-crate default methods.\n+            let trait_id = def_id_of_def(trait_def);\n+            if trait_id.crate != ast::local_crate {\n+                loop;\n+            }\n+\n+            // Get the self type.\n+            let self_ty;\n+            match ccx.tcx.ast_ty_to_ty_cache.get(self_ast_ty) {\n+                ty::atttce_resolved(self_type) => self_ty = self_type,\n+                ty::atttce_unresolved => {\n+                    ccx.tcx.sess.impossible_case(item.span,\n+                                                 ~\"didn't cache self ast ty\");\n+                }\n+            }\n+\n+            match ccx.tcx.items.get(trait_id.node) {\n+                ast_map::node_item(trait_item, _) => {\n+                    match trait_item.node {\n+                        ast::item_trait(tps, _, trait_methods) => {\n+                            trans_trait(ccx, tps, trait_methods, path,\n+                                        item.ident, self_ty);\n+                        }\n+                        _ => {\n+                            ccx.tcx.sess.impossible_case(item.span,\n+                                                         ~\"trait item not a \\\n+                                                           trait\");\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    ccx.tcx.sess.impossible_case(item.span, ~\"no trait item\");\n+                }\n+            }\n+        }\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);\n@@ -1873,9 +1913,6 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_class(struct_def, tps) => {\n         trans_struct_def(ccx, struct_def, tps, path, item.ident, item.id);\n       }\n-      ast::item_trait(tps, _, trait_methods) => {\n-        trans_trait(ccx, tps, trait_methods, path, item.ident);\n-      }\n       _ => {/* fall through */ }\n     }\n }\n@@ -1900,15 +1937,16 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     // If there are ty params, the ctor will get monomorphized\n \n     // Translate methods\n-    meth::trans_impl(ccx, *path, ident, struct_def.methods, tps);\n+    meth::trans_impl(ccx, *path, ident, struct_def.methods, tps, None);\n }\n \n fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n                trait_methods: ~[ast::trait_method],\n-               path: @ast_map::path, ident: ast::ident) {\n+               path: @ast_map::path, ident: ast::ident,\n+               self_ty: ty::t) {\n     // Translate any methods that have provided implementations\n     let (_, provided_methods) = ast_util::split_trait_methods(trait_methods);\n-    meth::trans_impl(ccx, *path, ident, provided_methods, tps);\n+    meth::trans_impl(ccx, *path, ident, provided_methods, tps, Some(self_ty));\n }\n \n // Translate a module. Doing this amounts to translating the items in the\n@@ -1953,32 +1991,23 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n \n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n-    if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n+    if is_main { create_main_wrapper(ccx, sp, llfn); }\n     llfn\n }\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n-                       main_node_type: ty::t) {\n+fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n \n     if ccx.main_fn != None::<ValueRef> {\n         ccx.sess.span_fatal(sp, ~\"multiple 'main' functions\");\n     }\n \n-    let main_takes_argv =\n-        // invariant!\n-        match ty::get(main_node_type).sty {\n-          ty::ty_fn(ref fn_ty) => fn_ty.sig.inputs.len() != 0u,\n-          _ => ccx.sess.span_fatal(sp, ~\"main has a non-function type\")\n-        };\n-\n-    let llfn = create_main(ccx, main_llfn, main_takes_argv);\n+    let llfn = create_main(ccx, main_llfn);\n     ccx.main_fn = Some(llfn);\n     create_entry_fn(ccx, llfn);\n \n-    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef,\n-                   takes_argv: bool) -> ValueRef {\n+    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef) -> ValueRef {\n         let unit_ty = ty::mk_estr(ccx.tcx, ty::vstore_uniq);\n         let vecarg_ty: ty::arg =\n             {mode: ast::expl(ast::by_val),\n@@ -1998,9 +2027,6 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n         let mut args = ~[lloutputarg, llenvarg];\n-        if takes_argv {\n-            args.push(llvm::LLVMGetParam(llfdecl, 2 as c_uint));\n-        }\n         Call(bcx, main_llfn, args);\n \n         build_return(bcx);"}, {"sha": "c851c5bc7250823432bc5d90e2742b4d88a07e22", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -592,7 +592,7 @@ fn trans_arg_expr(bcx: block,\n             DoAutorefArg => { val = arg_datum.to_ref_llval(bcx); }\n             DontAutorefArg => {\n                 match arg_mode {\n-                    ast::by_ref | ast::by_mutbl_ref => {\n+                    ast::by_ref => {\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n "}, {"sha": "68e957bfe709974e05faf000a46e6ff29d18fd92", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -963,8 +963,13 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_trait(cx: @crate_ctxt) -> TypeRef {\n-    T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n+fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n+    match vstore {\n+        ty::vstore_box =>\n+            T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)]),\n+        _ =>\n+            T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n+    }\n }\n \n fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }"}, {"sha": "d60a5a0bd7dfd222132ed562a7dffa229d146251", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -477,10 +477,13 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_fn(_) => {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, _) => {\n+      ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n+      ty::ty_trait(_, _, ty::vstore_uniq) => {\n+        ccx.tcx.sess.unimpl(~\"drop of unique trait\");\n+      }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n       }"}, {"sha": "d8a2fda4d14bef4a492dae00bc51ab6c85d172c5", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -27,15 +27,16 @@ be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n-              methods: ~[@ast::method], tps: ~[ast::ty_param]) {\n+              methods: ~[@ast::method], tps: ~[ast::ty_param],\n+              self_ty: Option<ty::t>) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |method| {\n         if method.tps.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path, path_name(method.ident));\n-            trans_method(ccx, path, *method, None, llfn);\n+            trans_method(ccx, path, *method, None, self_ty, llfn);\n         }\n     }\n }\n@@ -49,12 +50,16 @@ Translates a (possibly monomorphized) method body.\n - `method`: the AST node for the method\n - `param_substs`: if this is a generic method, the current values for\n   type parameters and so forth, else none\n+- `base_self_ty`: optionally, the explicit self type for this method. This\n+  will be none if this is not a default method and must always be present\n+  if this is a default method.\n - `llfn`: the LLVM ValueRef for the method\n */\n fn trans_method(ccx: @crate_ctxt,\n                 path: path,\n                 method: &ast::method,\n                 param_substs: Option<param_substs>,\n+                base_self_ty: Option<ty::t>,\n                 llfn: ValueRef) {\n \n     // figure out how self is being passed\n@@ -65,7 +70,11 @@ fn trans_method(ccx: @crate_ctxt,\n       _ => {\n         // determine the (monomorphized) type that `self` maps to for\n         // this method\n-        let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n+        let self_ty;\n+        match base_self_ty {\n+            None => self_ty = ty::node_id_to_type(ccx.tcx, method.self_id),\n+            Some(provided_self_ty) => self_ty = provided_self_ty\n+        }\n         let self_ty = match param_substs {\n           None => self_ty,\n           Some({tys: ref tys, _}) => ty::subst_tps(ccx.tcx, *tys, self_ty)\n@@ -142,8 +151,11 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                 None => fail ~\"trans_method_callee: missing param_substs\"\n             }\n         }\n-        typeck::method_trait(_, off) => {\n-            trans_trait_callee(bcx, callee_id, off, self)\n+        typeck::method_trait(_, off, vstore) => {\n+            trans_trait_callee(bcx, callee_id, off, self, vstore)\n+        }\n+        typeck::method_self(*) => {\n+            bcx.tcx().sess.span_bug(self.span, ~\"self method call\");\n         }\n     }\n }\n@@ -288,8 +300,8 @@ fn trans_monomorphized_callee(bcx: block,\n               })\n           }\n       }\n-      typeck::vtable_trait(*) => {\n-          trans_trait_callee(bcx, callee_id, n_method, base)\n+      typeck::vtable_trait(_, _) => {\n+          trans_trait_callee(bcx, callee_id, n_method, base, ty::vstore_box)\n       }\n       typeck::vtable_param(*) => {\n           fail ~\"vtable_param left in monomorphized function's vtable substs\";\n@@ -390,30 +402,32 @@ fn combine_impl_and_methods_origins(bcx: block,\n fn trans_trait_callee(bcx: block,\n                       callee_id: ast::node_id,\n                       n_method: uint,\n-                      self_expr: @ast::expr)\n+                      self_expr: @ast::expr,\n+                      vstore: ty::vstore)\n     -> Callee\n {\n     //!\n     //\n     // Create a method callee where the method is coming from a trait\n     // instance (e.g., @Trait type).  In this case, we must pull the\n     // fn pointer out of the vtable that is packaged up with the\n-    // @Trait instance.  @Traits are represented as a pair, so we first\n-    // evaluate the self expression (expected a by-ref result) and then\n+    // @/~/&Trait instance.  @/~/&Traits are represented as a pair, so we\n+    // first evaluate the self expression (expected a by-ref result) and then\n     // extract the self data and vtable out of the pair.\n \n     let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let mut bcx = bcx;\n     let self_datum = unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr));\n     let llpair = self_datum.to_ref_llval(bcx);\n     let callee_ty = node_id_type(bcx, callee_id);\n-    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair)\n+    trans_trait_callee_from_llval(bcx, callee_ty, n_method, llpair, vstore)\n }\n \n fn trans_trait_callee_from_llval(bcx: block,\n                                  callee_ty: ty::t,\n                                  n_method: uint,\n-                                 llpair: ValueRef)\n+                                 llpair: ValueRef,\n+                                 vstore: ty::vstore)\n     -> Callee\n {\n     //!\n@@ -431,9 +445,21 @@ fn trans_trait_callee_from_llval(bcx: block,\n                                   GEPi(bcx, llpair, [0u, 0u]),\n                                   T_ptr(T_ptr(T_vtable()))));\n \n-    // Load the box from the @Trait pair and GEP over the box header:\n+    // Load the box from the @Trait pair and GEP over the box header if\n+    // necessary:\n+    let llself;\n     let llbox = Load(bcx, GEPi(bcx, llpair, [0u, 1u]));\n-    let llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+    match vstore {\n+        ty::vstore_box | ty::vstore_uniq => {\n+            llself = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n+        }\n+        ty::vstore_slice(_) => {\n+            llself = llbox;\n+        }\n+        ty::vstore_fixed(*) => {\n+            bcx.tcx().sess.bug(~\"vstore_fixed trait\");\n+        }\n+    }\n \n     // Load the function from the vtable and cast it to the expected type.\n     let llcallee_ty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n@@ -503,7 +529,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     // XXX: This should support multiple traits.\n     let trt_id = driver::session::expect(\n         tcx.sess,\n-        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id)[0]),\n+        ty::ty_to_def_id(ty::impl_traits(tcx, impl_id, ty::vstore_box)[0]),\n         || ~\"make_impl_vtable: non-trait-type implemented\");\n \n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;"}, {"sha": "17eaf591c9f3469aca2c614e27260b07b50e784d", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -156,9 +156,10 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         d\n       }\n       ast_map::node_method(mth, _, _) => {\n+        // XXX: What should the self type be here?\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(mth.attrs, d);\n-        meth::trans_method(ccx, pt, mth, psubsts, d);\n+        meth::trans_method(ccx, pt, mth, psubsts, None, d);\n         d\n       }\n       ast_map::node_ctor(_, tps, ctor, parent_id, _) => {"}, {"sha": "c105caecaebbe36dccb9dceb5dd932c9739c636f", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -70,10 +70,12 @@ impl reflector {\n         }\n         let bool_ty = ty::mk_bool(tcx);\n         let scratch = scratch_datum(bcx, bool_ty, false);\n+        // XXX: Should not be vstore_box!\n         let bcx = callee::trans_call_inner(\n             self.bcx, None, mth_ty, bool_ty,\n             |bcx| meth::trans_trait_callee_from_llval(bcx, mth_ty,\n-                                                      mth_idx, v),\n+                                                      mth_idx, v,\n+                                                      ty::vstore_box),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n         let next_bcx = sub_block(bcx, ~\"next\");\n@@ -208,7 +210,6 @@ impl reflector {\n                   ast::expl(e) => match e {\n                     ast::by_ref => 1u,\n                     ast::by_val => 2u,\n-                    ast::by_mutbl_ref => 3u,\n                     ast::by_move => 4u,\n                     ast::by_copy => 5u\n                   }"}, {"sha": "127af438807394f025005b27b3b1049ef6bf0568", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -49,12 +49,16 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     return {mut next_tag_id: 0u16, pad: 0u16, pad2: 0u32};\n }\n \n-fn add_u16(&dest: ~[u8], val: u16) {\n-    dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n+/*\n+Although these two functions are never called, they are here\n+for a VERY GOOD REASON. See #3670\n+*/\n+fn add_u16(dest: &mut ~[u8], val: u16) {\n+    *dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n }\n \n-fn add_substr(&dest: ~[u8], src: ~[u8]) {\n+fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n     add_u16(dest, vec::len(src) as u16);\n-    dest += src;\n+    *dest += src;\n }\n "}, {"sha": "7b5a912ed7f239b199174a0f0dd6babfbdca8f90", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -159,7 +159,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(~[T_struct(tys)])\n       }\n       ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n-      ty::ty_trait(_, _, _) => T_opaque_trait(cx),\n+      ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(elts) => {\n         let mut tys = ~[];"}, {"sha": "ee247eb5db79f8c4a7f5338780633eac7f769a37", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -53,7 +53,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                     by_val | by_move | by_copy => {\n                         type_needs(cx, use_repr, arg.ty);\n                     }\n-                    by_ref | by_mutbl_ref => {}\n+                    by_ref => {}\n                 }\n             }\n         }\n@@ -247,7 +247,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               typeck::method_param({param_num: param, _}) => {\n                 cx.uses[param] |= use_tydesc;\n               }\n-              typeck::method_trait(_, _) => (),\n+              typeck::method_trait(*) | typeck::method_self(*) => (),\n             }\n         }\n       }"}, {"sha": "50ea363ace2accb96b0e5907f0fa076bec977f15", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -3,7 +3,6 @@ use lib::llvm::ValueRef;\n use common::*;\n use build::*;\n use base::*;\n-use shape::llsize_of;\n use datum::immediate_rvalue;\n \n export make_free_glue, autoderef, duplicate;"}, {"sha": "f2f7b32b670626a303eaf2882837ca8ae78c3af7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -90,6 +90,7 @@ export ty_estr, mk_estr, type_is_str;\n export ty_evec, mk_evec, type_is_vec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n+export serialize_vstore, deserialize_vstore;\n export ty_nil, mk_nil, type_is_nil;\n export ty_trait, mk_trait;\n export ty_param, mk_param, ty_params_to_tys;\n@@ -217,6 +218,7 @@ type method = {ident: ast::ident,\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n+#[auto_serialize]\n enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -1624,7 +1626,10 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_evec(_, vstore_uniq) |\n       ty_evec(_, vstore_box) => true,\n \n-      ty_trait(*) => true,\n+      ty_trait(_, _, vstore_box) |\n+      ty_trait(_, _, vstore_uniq) => true,\n+      ty_trait(_, _, vstore_fixed(_)) |\n+      ty_trait(_, _, vstore_slice(_)) => false,\n \n       ty_param(*) | ty_infer(*) => true,\n \n@@ -2821,7 +2826,8 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n           }\n           typeck::method_param({trait_id:trt_id,\n                                 method_num:n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth) => {\n+          typeck::method_trait(trt_id, n_mth, _) |\n+          typeck::method_self(trt_id, n_mth) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -3362,7 +3368,15 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n /*\n   Could this return a list of (def_id, substs) pairs?\n  */\n-fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n+fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n+    fn vstoreify(cx: ctxt, ty: t, vstore: vstore) -> t {\n+        match ty::get(ty).sty {\n+            ty::ty_trait(_, _, trait_vstore) if vstore == trait_vstore => ty,\n+            ty::ty_trait(did, substs, _) => mk_trait(cx, did, substs, vstore),\n+            _ => cx.sess.bug(~\"impl_traits: not a trait\")\n+        }\n+    }\n+\n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n         match cx.items.find(id.node) {\n@@ -3372,19 +3386,23 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n                     _)) => {\n \n                do option::map_default(&opt_trait, ~[]) |trait_ref| {\n-                       ~[node_id_to_type(cx, trait_ref.ref_id)]\n+                       ~[vstoreify(cx,\n+                                   node_id_to_type(cx, trait_ref.ref_id),\n+                                   vstore)]\n                    }\n            }\n            Some(ast_map::node_item(@{node: ast::item_class(sd,_),\n                            _},_)) => {\n                do vec::map(sd.traits) |trait_ref| {\n-                    node_id_to_type(cx, trait_ref.ref_id)\n+                    vstoreify(cx, node_id_to_type(cx, trait_ref.ref_id),\n+                              vstore)\n                 }\n            }\n            _ => ~[]\n         }\n     } else {\n-        csearch::get_impl_traits(cx, id)\n+        vec::map(csearch::get_impl_traits(cx, id),\n+                 |x| vstoreify(cx, *x, vstore))\n     }\n }\n "}, {"sha": "514fc2cfbb32ca548ad3283ca8b239ae6dc1d521", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -73,7 +73,7 @@ export deserialize_method_map_entry;\n export vtable_map;\n export vtable_res;\n export vtable_origin;\n-export method_static, method_param, method_trait;\n+export method_static, method_param, method_trait, method_self;\n export vtable_static, vtable_param, vtable_trait;\n export provided_methods_map;\n \n@@ -86,7 +86,10 @@ enum method_origin {\n     method_param(method_param),\n \n     // method invoked on a trait instance\n-    method_trait(ast::def_id, uint),\n+    method_trait(ast::def_id, uint, ty::vstore),\n+\n+    // method invoked on \"self\" inside a default method\n+    method_self(ast::def_id, uint),\n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n@@ -301,14 +304,12 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n             }\n             let mut ok = ty::type_is_nil(fn_ty.sig.output);\n             let num_args = vec::len(fn_ty.sig.inputs);\n-            ok &= num_args == 0u || num_args == 1u &&\n-                arg_is_argv_ty(tcx, fn_ty.sig.inputs[0]);\n+            ok &= num_args == 0u;\n             if !ok {\n                 tcx.sess.span_err(\n                     main_span,\n                     fmt!(\"Wrong type in main function: found `%s`, \\\n-                          expected `extern fn(++v: ~[~str]) -> ()` \\\n-                          or `extern fn() -> ()`\",\n+                          expected `fn() -> ()`\",\n                          ty_to_str(tcx, main_t)));\n             }\n         }"}, {"sha": "14797fcdd6bb1c38e8675f3cc09c82a3d0492959", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -189,16 +189,19 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n                                                        type_def_id, path);\n                 match ty::get(result.ty).sty {\n                     ty::ty_trait(trait_def_id, substs, _) => {\n-                        if vst != ty::vstore_box {\n-                            tcx.sess.span_unimpl(path.span,\n-                                                 ~\"`~trait` and `&trait` are \\\n-                                                   unimplemented; use \\\n-                                                   `@trait` instead for now\");\n+                        match vst {\n+                            ty::vstore_box | ty::vstore_slice(*) => {}\n+                            _ => {\n+                                tcx.sess.span_unimpl(path.span,\n+                                                     ~\"`~trait` is \\\n+                                                       unimplemented; use \\\n+                                                       `@trait` instead for \\\n+                                                       now\");\n+                            }\n                         }\n                         return ty::mk_trait(tcx, trait_def_id, substs, vst);\n                     }\n-                    _ =>\n-                        {}\n+                    _ => {}\n                 }\n               }\n               _ => ()"}, {"sha": "7cc2c8b0ad767a9d898942cbe561b6e0cccea2df", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2601,7 +2601,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"addr_of\" => (1u, ~[arg(ast::by_ref, param(ccx, 0u))],\n                       ty::mk_imm_ptr(tcx, param(ccx, 0u))),\n       ~\"move_val\" | ~\"move_val_init\" => {\n-        (1u, ~[arg(ast::by_mutbl_ref, param(ccx, 0u)),\n+          (1u, ~[arg(ast::by_copy,\n+                     ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n+                                     param(ccx, 0u))),\n                arg(ast::by_move, param(ccx, 0u))],\n          ty::mk_nil(tcx))\n       }"}, {"sha": "f3b2c8f1b7ed55bbf1fae2d8cbb6d2f82e567f99", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -221,9 +221,9 @@ impl LookupContext {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(p);\n                 }\n-                ty_trait(did, ref substs, _) => {\n+                ty_trait(did, ref substs, vstore) => {\n                     self.push_inherent_candidates_from_trait(\n-                        self_ty, did, substs);\n+                        self_ty, did, substs, vstore);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n                 ty_self => {\n@@ -232,7 +232,7 @@ impl LookupContext {\n                     let self_did = self.fcx.self_impl_def_id.expect(\n                         ~\"unexpected `none` for self_impl_def_id\");\n                     let substs = {self_r: None, self_ty: None, tps: ~[]};\n-                    self.push_inherent_candidates_from_trait(\n+                    self.push_inherent_candidates_from_self(\n                         self_ty, self_did, &substs);\n                 }\n                 ty_enum(did, _) | ty_class(did, _) => {\n@@ -347,7 +347,8 @@ impl LookupContext {\n     fn push_inherent_candidates_from_trait(&self,\n                                            self_ty: ty::t,\n                                            did: def_id,\n-                                           substs: &ty::substs)\n+                                           substs: &ty::substs,\n+                                           vstore: ty::vstore)\n     {\n         debug!(\"push_inherent_candidates_from_trait(did=%s, substs=%s)\",\n                self.did_to_str(did),\n@@ -391,7 +392,34 @@ impl LookupContext {\n             rcvr_substs: move rcvr_substs,\n             num_method_tps: method.tps.len(),\n             self_mode: get_mode_from_self_type(method.self_ty),\n-            origin: method_trait(did, index)\n+            origin: method_trait(did, index, vstore)\n+        });\n+    }\n+\n+    fn push_inherent_candidates_from_self(&self,\n+                                          self_ty: ty::t,\n+                                          did: def_id,\n+                                          substs: &ty::substs) {\n+        let tcx = self.tcx();\n+        let methods = ty::trait_methods(tcx, did);  // XXX: Inherited methods.\n+        let index;\n+        match vec::position(*methods, |m| m.ident == self.m_name) {\n+            Some(i) => index = i,\n+            None => return\n+        }\n+        let method = &methods[index];\n+\n+        let rcvr_substs = { self_ty: Some(self_ty), ..*substs };\n+        let (rcvr_ty, rcvr_substs) =\n+            self.create_rcvr_ty_and_substs_for_method(\n+                method.self_ty, self_ty, move rcvr_substs);\n+\n+        self.inherent_candidates.push(Candidate {\n+            rcvr_ty: rcvr_ty,\n+            rcvr_substs: move rcvr_substs,\n+            num_method_tps: method.tps.len(),\n+            self_mode: get_mode_from_self_type(method.self_ty),\n+            origin: method_self(did, index)\n         });\n     }\n \n@@ -735,7 +763,7 @@ impl LookupContext {\n          * vtable and hence cannot be monomorphized. */\n \n         match candidate.origin {\n-            method_static(*) | method_param(*) => {\n+            method_static(*) | method_param(*) | method_self(*) => {\n                 return; // not a call to a trait instance\n             }\n             method_trait(*) => {}\n@@ -770,7 +798,7 @@ impl LookupContext {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx) => {\n+            method_trait(did, idx, _) | method_self(did, idx) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -791,7 +819,7 @@ impl LookupContext {\n             method_param(mp) => {\n                 self.report_param_candidate(idx, mp.trait_id)\n             }\n-            method_trait(trait_did, _) => {\n+            method_trait(trait_did, _, _) | method_self(trait_did, _) => {\n                 self.report_param_candidate(idx, trait_did)\n             }\n         }"}, {"sha": "0b258da5672dbdfa0df9e2512e42292e930d0529", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -221,11 +221,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n                 result::Err(_) => { return; /*typeck will fail anyhow*/ }\n                 result::Ok(target_ty) => {\n                     match ty::get(target_ty).sty {\n-                        ty::ty_trait(_, substs, _) => {\n-                            let trait_region = match substs.self_r {\n-                                Some(r) => {r}\n-                                None => {ty::re_static}\n-                            };\n+                        ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n                             let source_ty = rcx.fcx.expr_ty(source);\n                             constrain_regions_in_type(rcx, trait_region,\n                                                       expr.span, source_ty);"}, {"sha": "00fb134f2be556b71f8b4f4419b73abac181d24e", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 143, "deletions": 45, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -51,8 +51,8 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                match lookup_vtable(fcx, expr, *ty, i_ty, allow_unsafe,\n-                                    is_early) {\n+                match lookup_vtable_covariant(fcx, expr, *ty, i_ty,\n+                                              allow_unsafe, is_early) {\n                     Some(vtable) => result.push(vtable),\n                     None => {\n                         fcx.tcx().sess.span_fatal(\n@@ -91,28 +91,75 @@ fn relate_trait_tys(fcx: @fn_ctxt, expr: @ast::expr,\n     demand::suptype(fcx, expr.span, exp_trait_ty, act_trait_ty)\n }\n \n-/*\n-Look up the vtable to use when treating an item of type <t>\n-as if it has type <trait_ty>\n-*/\n-fn lookup_vtable(fcx: @fn_ctxt,\n-                 expr: @ast::expr,\n-                 ty: ty::t,\n-                 trait_ty: ty::t,\n-                 allow_unsafe: bool,\n-                 is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+// Look up the vtable to use when treating an item of type `t` as if it has\n+// type `trait_ty`. This does allow subtraits.\n+fn lookup_vtable_covariant(fcx: @fn_ctxt,\n+                           expr: @ast::expr,\n+                           ty: ty::t,\n+                           trait_ty: ty::t,\n+                           allow_unsafe: bool,\n+                           is_early: bool)\n+                        -> Option<vtable_origin> {\n+    let worklist = dvec::DVec();\n+    worklist.push(trait_ty);\n+    while worklist.len() > 0 {\n+        let trait_ty = worklist.pop();\n+        let result = lookup_vtable_invariant(fcx, expr, ty, trait_ty,\n+                                             allow_unsafe, is_early);\n+        if result.is_some() {\n+            return result;\n+        }\n+\n+        // Add subtraits to the worklist, if applicable.\n+        match ty::get(trait_ty).sty {\n+            ty::ty_trait(trait_id, _, _) => {\n+                let table = fcx.ccx.coherence_info.supertrait_to_subtraits;\n+                match table.find(trait_id) {\n+                    None => {}\n+                    Some(subtraits) => {\n+                        for subtraits.each |subtrait_id| {\n+                            // XXX: This is wrong; subtraits should themselves\n+                            // have substs.\n+                            let substs =\n+                                { self_r: None, self_ty: None, tps: ~[] };\n+                            let trait_ty = ty::mk_trait(fcx.ccx.tcx,\n+                                                        *subtrait_id,\n+                                                        substs,\n+                                                        ty::vstore_box);\n+                            worklist.push(trait_ty);\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {\n+                fcx.ccx.tcx.sess.impossible_case(expr.span,\n+                                                 \"lookup_vtable_covariant: \\\n+                                                  non-trait in worklist\");\n+            }\n+        }\n+    }\n \n-    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n+    return None;\n+}\n+\n+// Look up the vtable to use when treating an item of type `t` as if it has\n+// type `trait_ty`. This does not allow subtraits.\n+fn lookup_vtable_invariant(fcx: @fn_ctxt,\n+                           expr: @ast::expr,\n+                           ty: ty::t,\n+                           trait_ty: ty::t,\n+                           allow_unsafe: bool,\n+                           is_early: bool)\n+                        -> Option<vtable_origin> {\n+    debug!(\"lookup_vtable_invariant(ty=%s, trait_ty=%s)\",\n            fcx.infcx().ty_to_str(ty), fcx.inh.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n-    let (trait_id, trait_substs) = match ty::get(trait_ty).sty {\n-        ty::ty_trait(did, substs, _) => (did, substs),\n+    let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n+        ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n         _ => tcx.sess.impossible_case(expr.span,\n-                                      \"lookup_vtable: \\\n+                                      \"lookup_vtable_invariant: \\\n                                        don't know how to handle a non-trait\")\n     };\n     let ty = match fixup_ty(fcx, expr, ty, is_early) {\n@@ -150,7 +197,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             }\n                             _ => tcx.sess.impossible_case(\n                                 expr.span,\n-                                \"lookup_vtable: in loop, \\\n+                                \"lookup_vtable_invariant: in loop, \\\n                                  don't know how to handle a non-trait ity\")\n                         }\n                         n_bound += 1u;\n@@ -223,7 +270,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         // it's the same trait as trait_ty, we need to\n                         // unify it with trait_ty in order to get all\n                         // the ty vars sorted out.\n-                        for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                        for vec::each(ty::impl_traits(tcx, im.did,\n+                                                      trait_vstore)) |of_ty| {\n                             match ty::get(*of_ty).sty {\n                                 ty::ty_trait(id, _, _) => {\n                                     // Not the trait we're looking for\n@@ -331,7 +379,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             // lists of types to unify pairwise.\n \n                             connect_trait_tps(fcx, expr, substs_f.tps,\n-                                              trait_tps, im.did);\n+                                              trait_tps, im.did,\n+                                              trait_vstore);\n                             let subres = lookup_vtables(\n                                 fcx, expr, im_bs, &substs_f,\n                                 false, is_early);\n@@ -389,11 +438,12 @@ fn fixup_ty(fcx: @fn_ctxt,\n }\n \n fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n-                     trait_tys: ~[ty::t], impl_did: ast::def_id) {\n+                     trait_tys: ~[ty::t], impl_did: ast::def_id,\n+                     vstore: ty::vstore) {\n     let tcx = fcx.ccx.tcx;\n \n     // XXX: This should work for multiple traits.\n-    let ity = ty::impl_traits(tcx, impl_did)[0];\n+    let ity = ty::impl_traits(tcx, impl_did, vstore)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).sty, impl_did);\n@@ -461,37 +511,85 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_cast(src, _) => {\n         let target_ty = fcx.expr_ty(ex);\n         match ty::get(target_ty).sty {\n-          ty::ty_trait(*) => {\n-            /*\n-            Look up vtables for the type we're casting to,\n-            passing in the source and target type\n-            */\n+          ty::ty_trait(_, _, vstore) => {\n+            // Look up vtables for the type we're casting to, passing in the\n+            // source and target type.\n+            //\n+            // XXX: This is invariant and shouldn't be. --pcw\n+\n             let ty = fcx.expr_ty(src);\n-            let vtable_opt = lookup_vtable(fcx, ex, ty, target_ty, true,\n-                                           is_early);\n+            let vtable_opt = lookup_vtable_invariant(fcx, ex, ty, target_ty,\n+                                                     true, is_early);\n             match vtable_opt {\n                 None => {\n                     // Try the new-style boxed trait; \"@int as @Trait\".\n+                    // Or the new-style region trait; \"&int as &Trait\".\n                     let mut err = false;\n                     let ty = structurally_resolved_type(fcx, ex.span, ty);\n                     match ty::get(ty).sty {\n-                        ty::ty_box(boxed_ty) => {\n-                            let vtable_opt = lookup_vtable(fcx, ex,\n-                                                           boxed_ty.ty,\n-                                                           target_ty, true,\n-                                                           is_early);\n-                            match vtable_opt {\n-                                Some(vtable) => {\n-                                    /*\n-                                    Map this expression to that vtable (that\n-                                    is: \"ex has vtable <vtable>\")\n-                                    */\n-                                    if !is_early {\n-                                        cx.vtable_map.insert(ex.id,\n-                                                             @~[vtable]);\n+                        ty::ty_box(mt) | ty::ty_rptr(_, mt) => {\n+                            // Ensure that the trait vstore and the pointer\n+                            // type match.\n+                            match (ty::get(ty).sty, vstore) {\n+                                (ty::ty_box(_), ty::vstore_box) |\n+                                (ty::ty_rptr(*), ty::vstore_slice(*)) => {\n+                                    let vtable_opt =\n+                                        lookup_vtable_invariant(fcx,\n+                                                                ex,\n+                                                                mt.ty,\n+                                                                target_ty,\n+                                                                true,\n+                                                                is_early);\n+                                    match vtable_opt {\n+                                        Some(vtable) => {\n+                                            // Map this expression to that\n+                                            // vtable (that is: \"ex has vtable\n+                                            // <vtable>\")\n+                                            if !is_early {\n+                                                cx.vtable_map.insert(\n+                                                    ex.id, @~[vtable]);\n+                                            }\n+                                        }\n+                                        None => err = true\n                                     }\n+\n+                                    // Now, if this is &trait, we need to link\n+                                    // the regions.\n+                                    match (ty::get(ty).sty, vstore) {\n+                                        (ty::ty_rptr(ra, _),\n+                                         ty::vstore_slice(rb)) => {\n+                                            infer::mk_subr(fcx.infcx(),\n+                                                           false,\n+                                                           ex.span,\n+                                                           rb,\n+                                                           ra);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                (ty::ty_box(_), _) => {\n+                                    fcx.ccx.tcx.sess.span_err(ex.span,\n+                                                              ~\"must cast \\\n+                                                                a boxed \\\n+                                                                pointer to \\\n+                                                                a boxed\n+                                                                trait\");\n+                                    err = true;\n+                                }\n+                                (ty::ty_rptr(*), _) => {\n+                                    fcx.ccx.tcx.sess.span_err(ex.span,\n+                                                              ~\"must cast \\\n+                                                                a borrowed \\\n+                                                                pointer to \\\n+                                                                a borrowed \\\n+                                                                trait\");\n+                                }\n+                                _ => {\n+                                    fcx.ccx.tcx.sess.impossible_case(\n+                                        ex.span,\n+                                        ~\"impossible combination of type and \\\n+                                          trait vstore\");\n                                 }\n-                                None => err = true\n                             }\n                         }\n                         _ => err = true"}, {"sha": "89cd696eb6fbdbdce4e9767213706d421f5af5cb", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -126,12 +126,16 @@ struct CoherenceInfo {\n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n     extension_methods: HashMap<def_id,@DVec<@Impl>>,\n+\n+    // A mapping from a supertrait to its subtraits.\n+    supertrait_to_subtraits: HashMap<def_id,@DVec<def_id>>\n }\n \n fn CoherenceInfo() -> CoherenceInfo {\n     CoherenceInfo {\n         inherent_methods: HashMap(),\n-        extension_methods: HashMap()\n+        extension_methods: HashMap(),\n+        supertrait_to_subtraits: HashMap()\n     }\n }\n \n@@ -161,7 +165,6 @@ struct CoherenceChecker {\n }\n \n impl CoherenceChecker {\n-\n     // Create a mapping containing a MethodInfo for every provided\n     // method in every trait.\n     fn build_provided_methods_map(crate: @crate) {\n@@ -225,9 +228,9 @@ impl CoherenceChecker {\n     }\n \n     fn check_coherence(crate: @crate) {\n-\n-        // Check implementations. This populates the tables containing the\n-        // inherent methods and extension methods.\n+        // Check implementations and traits. This populates the tables\n+        // containing the inherent methods and extension methods. It also\n+        // builds up the trait inheritance table.\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n                 debug!(\"(checking coherence) item '%s'\",\n@@ -240,6 +243,9 @@ impl CoherenceChecker {\n                     item_class(struct_def, _) => {\n                         self.check_implementation(item, struct_def.traits);\n                     }\n+                    item_trait(_, supertraits, _) => {\n+                        self.register_inherited_trait(item, supertraits);\n+                    }\n                     _ => {\n                         // Nothing to do.\n                     }\n@@ -324,6 +330,27 @@ impl CoherenceChecker {\n         }\n     }\n \n+    fn register_inherited_trait(item: @item, supertraits: ~[@trait_ref]) {\n+        // XXX: This is wrong. We need to support substitutions; e.g.\n+        // trait Foo : Bar<int>.\n+        let supertrait_to_subtraits =\n+            self.crate_context.coherence_info.supertrait_to_subtraits;\n+        let subtrait_id = local_def(item.id);\n+        for supertraits.each |supertrait| {\n+            let supertrait_id = self.trait_ref_to_trait_def_id(*supertrait);\n+            match supertrait_to_subtraits.find(supertrait_id) {\n+                None => {\n+                    let new_vec = @dvec::DVec();\n+                    new_vec.push(subtrait_id);\n+                    supertrait_to_subtraits.insert(supertrait_id, new_vec);\n+                }\n+                Some(existing_vec) => {\n+                    existing_vec.push(subtrait_id);\n+                }\n+            }\n+        }\n+    }\n+\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods"}, {"sha": "2e6cbf579c8e9768318a62025c44eb5d41b2a7d3", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -93,7 +93,7 @@ fn exec<T:Send>(\n     +f: fn~(ctxt: Ctxt) -> T\n ) -> T {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     let msg = HandleRequest(fn~(move f, ctxt: Ctxt) {\n         comm::send(ch, f(ctxt))\n     });"}, {"sha": "f505f9d0b9938a868b2b36fe36df96c32991404e", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -109,14 +109,14 @@ fn pandoc_writer(\n         os::close(pipe_in.out);\n \n         let stdout_po = comm::Port();\n-        let stdout_ch = comm::Chan(stdout_po);\n+        let stdout_ch = comm::Chan(&stdout_po);\n         do task::spawn_sched(task::SingleThreaded) {\n             comm::send(stdout_ch, readclose(pipe_out.in));\n         }\n         let stdout = comm::recv(stdout_po);\n \n         let stderr_po = comm::Port();\n-        let stderr_ch = comm::Chan(stderr_po);\n+        let stderr_ch = comm::Chan(&stderr_po);\n         do task::spawn_sched(task::SingleThreaded) {\n             comm::send(stderr_ch, readclose(pipe_err.in));\n         }\n@@ -268,10 +268,10 @@ fn write_file(path: &Path, s: ~str) {\n fn future_writer_factory(\n ) -> (WriterFactory, comm::Port<(doc::Page, ~str)>) {\n     let markdown_po = comm::Port();\n-    let markdown_ch = comm::Chan(markdown_po);\n+    let markdown_ch = comm::Chan(&markdown_po);\n     let writer_factory = fn~(page: doc::Page) -> Writer {\n         let writer_po = comm::Port();\n-        let writer_ch = comm::Chan(writer_po);\n+        let writer_ch = comm::Chan(&writer_po);\n         do task::spawn {\n             let (writer, future) = future_writer();\n             comm::send(writer_ch, writer);"}, {"sha": "b79b6ba218994cdf317e5bf5f54861473b9c0bb7", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -3,7 +3,8 @@ use doc::Item;\n use pass::Pass;\n use config::Config;\n \n-fn main(args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n \n     if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n         config::usage();"}, {"sha": "e1469d99d2b7f4995f02bca13c9085bce30069f8", "filename": "src/snapshots.txt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,19 @@\n+S 2012-10-05 937f8f4\n+  macos-i386 8b5ddc78b3004e539c6fbe224e492e4a6a1bc867\n+  macos-x86_64 03793e0136512c644edfb5f13cc5bb7d67fb24e5\n+  freebsd-x86_64 f7f4b402f06b9344fe327a9aa0282aa4ac18fcb0\n+  linux-i386 789223cb3db37f6f81f48dff5fa202311fae6c2b\n+  linux-x86_64 b5f1ada95528ac5b24d2b3dd3c817b8bcfc3302e\n+  winnt-i386 e984437412dc4450931e0bb7ed140652bd66443c\n+\n+S 2012-10-03 5585514\n+  macos-i386 c910d42405e66b444b7870ea66b93e1135776df3\n+  macos-x86_64 e0dfa93e8d0d25b91c9684d4f6e92dec521e2d74\n+  freebsd-x86_64 228e68ac17ca104554dd8a39a466d20f1b68de24\n+  linux-i386 0a2760b24d5bc3cabcc9321b92a08796f95da377\n+  linux-x86_64 eace8a5c46f7525355e85b3b570dbd7f4b3b6471\n+  winnt-i386 25680d15a358cf4163e08f4e56e54fb497de5eb4\n+\n S 2012-10-02 4d30b34\n   macos-i386 2bcce3cde8a7e53df202972cda85b0b59ce4e50d \n   macos-x86_64 fc5592828392f9eabe8b51cc59639be6d709cc26"}, {"sha": "b25605852571177d43029c80bda4147b82a4b590", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -6,7 +6,7 @@ use comm::*;\n \n fn foo<T: Send Copy>(x: T) -> Port<T> {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     do task::spawn() |copy c, copy x| {\n         c.send(x);\n     }"}, {"sha": "09a5415823ce621a92581f6aa25429963673265d", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -142,7 +142,8 @@ fn empty_results() -> Results {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let num_keys = {\n         if args.len() == 2 {\n             uint::from_str(args[1]).get()"}, {"sha": "6f90a2c99e810660cbb924bc3ab89a0bdeb76a95", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,8 @@ use std::map::{Map, HashMap};\n \n use io::{Reader, ReaderUtil};\n \n-fn main(++argv: ~[~str]) {\n+fn main() {\n+    let argv = os::args();\n     #macro[\n         [#bench[id],\n          maybe_run_test(argv, #stringify(id), id)"}, {"sha": "4b1e9519715ee4ec75d039afd199019823412695", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,4 +1,5 @@\n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"10000000\"]\n     } else if args.len() <= 1u {"}, {"sha": "1adbd20f4cdec03036c396ce904db9dc566e6604", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -20,7 +20,8 @@ fn collect_dvec(num: uint) -> ~[uint] {\n     return dvec::unwrap(move result);\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"50000000\"]\n     } else if args.len() <= 1u {"}, {"sha": "5acde71c6fd6d35143fe8d2e0476999abdb010ce", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -384,7 +384,8 @@ fn validate(edges: ~[(node_id, node_id)],\n     true\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"15\", ~\"48\"]\n     } else if args.len() <= 1u {"}, {"sha": "d60937af13c8b45ccc14085d3909b4001c275017", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -90,7 +90,8 @@ fn run(args: &[~str]) {\n     assert result == num_bytes * size;\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"1000000\", ~\"10000\"]\n     } else if args.len() <= 1u {"}, {"sha": "e2d115600eff91588a6b58eb3e39d884c8fbf647", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -87,7 +87,8 @@ fn run(args: &[~str]) {\n     assert result == num_bytes * size;\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"1000000\", ~\"8\"]\n     } else if args.len() <= 1u {"}, {"sha": "f657884eeef816829bdff0bb0b92c80cdcc24bee", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -56,7 +56,8 @@ fn thread_ring(i: uint,\n     };\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100\", ~\"10000\"]\n     } else if args.len() <= 1u {"}, {"sha": "73942d4ddf8f0e6ecafc44577b342d3c78a88208", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -52,7 +52,8 @@ fn thread_ring(i: uint,\n     };\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100\", ~\"10000\"]\n     } else if args.len() <= 1u {"}, {"sha": "386496f459d8eed001df23dcab1b6e708f73e983", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -56,7 +56,8 @@ fn thread_ring(i: uint,\n     };\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100\", ~\"10000\"]\n     } else if args.len() <= 1u {"}, {"sha": "1dfcd241b83b94e19f05a9e2d300584663c753de", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -21,7 +21,8 @@ fn thread_ring(i: uint,\n     };\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100\", ~\"10000\"]\n     } else if args.len() <= 1u {\n@@ -34,7 +35,7 @@ fn main(++args: ~[~str]) {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let num_port = Port();\n-    let mut num_chan = Chan(num_port);\n+    let mut num_chan = Chan(&num_port);\n \n     let start = time::precise_time_s();\n \n@@ -43,12 +44,12 @@ fn main(++args: ~[~str]) {\n \n     for uint::range(1u, num_tasks) |i| {\n         let get_chan = Port();\n-        let get_chan_chan = Chan(get_chan);\n+        let get_chan_chan = Chan(&get_chan);\n \n         let new_future = do future::spawn\n             |copy num_chan, move get_chan_chan| {\n             let p = Port();\n-            get_chan_chan.send(Chan(p));\n+            get_chan_chan.send(Chan(&p));\n             thread_ring(i, msg_per_task, num_chan,  p)\n         };\n         futures.push(new_future);"}, {"sha": "8564adaab72909cf15e786d9aa4211ee1473c9b4", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -57,7 +57,8 @@ fn run(args: ~[~str]) {\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"1000000\", ~\"10000\"]\n     } else if args.len() <= 1u {"}, {"sha": "edccf15a44015dfe40e5168e056e9f44a4c0a67f", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -12,7 +12,8 @@ fn ack(m: int, n: int) -> int {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"12\"]\n     } else if args.len() <= 1u {"}, {"sha": "be58bc0595e94efe2b401f4a873b459849a7058f", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -25,7 +25,8 @@ fn bottom_up_tree(arena: &r/arena::Arena,\n     return arena.alloc(|| nil);\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"17\"]\n     } else if args.len() <= 1u {"}, {"sha": "1e3c51d825481b12c96bbcff0818057490b61efd", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -126,8 +126,8 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     let from_creatures_log: comm::Port<~str> = comm::Port();\n \n     // these channels will be passed to the creatures so they can talk to us\n-    let to_rendezvous     = comm::Chan(from_creatures);\n-    let to_rendezvous_log = comm::Chan(from_creatures_log);\n+    let to_rendezvous     = comm::Chan(&from_creatures);\n+    let to_rendezvous_log = comm::Chan(&from_creatures_log);\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let to_creature: ~[comm::Chan<Option<creature_info>>] =\n@@ -178,7 +178,8 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     io::println(show_number(creatures_met));\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"200000\"]\n     } else if args.len() <= 1u {"}, {"sha": "1fbdaddaead8af2c1c2455be5ca4482d0e45ec1c", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -56,7 +56,8 @@ fn fannkuch(n: int) -> int {\n     return flips;\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"10\"]\n     } else if args.len() <= 1u {"}, {"sha": "f230664495f16be0a48cb0516e6e85313ed3f4d8", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -70,7 +70,8 @@ fn make_repeat_fasta(wr: io::Writer, id: ~str, desc: ~str, s: ~str, n: int) unsa\n \n fn acid(ch: char, prob: u32) -> aminoacids { return {ch: ch, prob: prob}; }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         // alioth tests k-nucleotide with this data at 25,000,000\n         ~[~\"\", ~\"5000000\"]"}, {"sha": "548dd1e7d79dfebb2772a2df6c32d32711e74337", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,8 @@ fn fib(n: int) -> int {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"40\"]\n     } else if args.len() <= 1u {"}, {"sha": "a68b345cbc556bd88b1dfea9c65b7b693586def5", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -128,7 +128,8 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n }\n \n // given a FASTA file on stdin, process sequence THREE\n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n    let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)"}, {"sha": "e4373d55c1792ff066132be61aef1f4fef7fdcc6", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -125,7 +125,8 @@ fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n }\n \n // given a FASTA file on stdin, process sequence THREE\n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n    let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n@@ -141,7 +142,7 @@ fn main(++args: ~[~str]) {\n    // initialize each sequence sorter\n    let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n    let from_child = vec::map (sizes, |_sz| comm::Port() );\n-   let to_parent  = vec::mapi(sizes, |ii, _sz| comm::Chan(from_child[ii]) );\n+   let to_parent  = vec::mapi(sizes, |ii, _sz| comm::Chan(&from_child[ii]) );\n    let to_child   = vec::mapi(sizes, |ii, sz| {\n        let ii = ii;\n        let sz = *sz;"}, {"sha": "b30e04a4ca7dbd75192a7acb141a58affc9d2707", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -103,7 +103,7 @@ impl devnull: io::Writer {\n fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n {\n     let p: comm::Port<line> = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     comm::send(writech, ch);\n     let cout: io::Writer = match path {\n         ~\"\" => {\n@@ -151,7 +151,8 @@ fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"4000\", ~\"10\"]\n     } else {\n@@ -168,7 +169,7 @@ fn main(++args: ~[~str]) {\n     else { uint::from_str(args[1]).get() };\n \n     let writep = comm::Port();\n-    let writech = comm::Chan(writep);\n+    let writech = comm::Chan(&writep);\n     do task::spawn {\n         writer(path, writech, size);\n     };"}, {"sha": "a1199511907c760e0d85b1e0149c3f181676c4b3", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -14,7 +14,8 @@ extern mod libc {\n     fn sqrt(n: float) -> float;\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"4000000\"]\n     } else if args.len() <= 1u {"}, {"sha": "fa97e796bd1c832d2f0ca29a864bbd47b4de93f0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -81,7 +81,8 @@ fn stress(num_tasks: int) {\n     for results.each |r| { future::get(r); }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"20\"]\n     } else if args.len() <= 1u {"}, {"sha": "781ecce7ff72d80a1a48788d64a407558ebec88c", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -40,7 +40,8 @@ fn eval_AtA_times_u(u: ~[const float], AtAu: ~[mut float]) {\n     eval_At_times_u(v, AtAu);\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"2000\"]\n     } else if args.len() <= 1u {"}, {"sha": "7ac45863c5b4735806e0ae720f6b8678ae81621b", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -7,7 +7,7 @@ fn start(+token: int) {\n     use iter::*;\n \n     let p = comm::Port();\n-    let mut ch = comm::Chan(p);\n+    let mut ch = comm::Chan(&p);\n     for int::range(2, n_threads + 1) |i| {\n         let id = n_threads + 2 - i;\n         let to_child = do task::spawn_listener::<int> |p, copy ch| {\n@@ -37,7 +37,8 @@ fn roundtrip(id: int, p: comm::Port<int>, ch: comm::Chan<int>) {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"2000000\"]\n     } else if args.len() <= 1u {"}, {"sha": "2ac651862213b4bf991739a868d9cc4656c38b3a", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -17,7 +17,8 @@ fn check_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100000\", ~\"100\"]\n     } else if args.len() <= 1u {"}, {"sha": "2e8ef0bac5827748e2f99b90c768b7c7681fc54c", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -126,7 +126,8 @@ fn write_grid(f: io::Writer, g: grid_t) {\n      }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let grid = if vec::len(args) == 1u {\n         // FIXME create sudoku inline since nested vec consts dont work yet\n         // (#571)"}, {"sha": "2055993d441e20c684ae54d3e8b3f5e52831f2de", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -23,7 +23,8 @@ fn child_generation(gens_left: uint, -c: pipes::Chan<()>) {\n     }\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100000\"]\n     } else if args.len() <= 1u {"}, {"sha": "a692b2f3011e14f3603a6ca29a59eedf9d8f834b", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -11,7 +11,7 @@\n // Doesn't return until all such tasks are ready, but doesn't block forever itself.\n fn grandchild_group(num_tasks: uint) {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n \n     for num_tasks.times {\n         do task::spawn { // linked\n@@ -37,7 +37,8 @@ fn spawn_supervised_blocking(myname: &str, +f: fn~()) {\n     assert x == task::Success;\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100000\"]\n     } else if args.len() <= 1u {"}, {"sha": "7a30c5e2325beb300dcd85a56331ed8bf6a60bd9", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,7 @@ enum msg {\n \n fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n     let port = comm::Port();\n-    let chan = comm::Chan(port);\n+    let chan = comm::Chan(&port);\n     let mut child_chs = ~[];\n     let mut sum = 0;\n \n@@ -48,7 +48,8 @@ fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n     comm::send(parent_ch, done(sum + 1));\n }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"100000\"]\n     } else if args.len() <= 1u {\n@@ -59,7 +60,7 @@ fn main(++args: ~[~str]) {\n \n     let children = uint::from_str(args[1]).get();\n     let port = comm::Port();\n-    let chan = comm::Chan(port);\n+    let chan = comm::Chan(&port);\n     do task::spawn {\n         calc(children, chan);\n     };"}, {"sha": "dfa53c3328b5e98133f977ffa7821617adf58f4a", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,8 @@ fn f(&&n: uint) {\n \n fn g() { }\n \n-fn main(++args: ~[~str]) {\n+fn main() {\n+    let args = os::args();\n     let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n         ~[~\"\", ~\"400\"]\n     } else if args.len() <= 1u {"}, {"sha": "30add8c730c72dc28a4283cd44a38b34708c0c36", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,8 +10,6 @@\n \n // xfail-pretty\n \n-#[legacy_modes];\n-\n extern mod std;\n \n use option = option;\n@@ -43,7 +41,7 @@ trait word_reader {\n type joinable_task = Port<()>;\n fn spawn_joinable(+f: fn~()) -> joinable_task {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     do task::spawn() |move f| {\n         f();\n         c.send(());\n@@ -70,18 +68,18 @@ fn map(f: fn~() -> word_reader, emit: map_reduce::putter<~str, int>) {\n     let f = f();\n     loop {\n         match f.read_word() {\n-          Some(w) => { emit(w, 1); }\n+          Some(w) => { emit(&w, 1); }\n           None => { break; }\n         }\n     }\n }\n \n-fn reduce(&&word: ~str, get: map_reduce::getter<int>) {\n+fn reduce(word: &~str, get: map_reduce::getter<int>) {\n     let mut count = 0;\n \n     loop { match get() { Some(_) => { count += 1; } None => { break; } } }\n \n-    io::println(fmt!(\"%s\\t%?\", word, count));\n+    io::println(fmt!(\"%s\\t%?\", *word, count));\n }\n \n struct box<T> {\n@@ -116,13 +114,13 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<K: Send, V: Send> = fn(K, V);\n+    type putter<K: Send, V: Send> = fn(&K, V);\n \n     type mapper<K1: Send, K2: Send, V: Send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: Send> = fn() -> Option<V>;\n \n-    type reducer<K: Copy Send, V: Copy Send> = fn~(K, getter<V>);\n+    type reducer<K: Copy Send, V: Copy Send> = fn~(&K, getter<V>);\n \n     enum ctrl_proto<K: Copy Send, V: Copy Send> {\n         find_reducer(K, Chan<Chan<reduce_proto<V>>>),\n@@ -145,46 +143,49 @@ mod map_reduce {\n \n     fn start_mappers<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send,\n                      V: Copy Send>(\n-        map: mapper<K1, K2, V>,\n-        &ctrls: ~[ctrl_proto::server::open<K2, V>],\n-        inputs: ~[K1])\n+        map: &mapper<K1, K2, V>,\n+        ctrls: &mut ~[ctrl_proto::server::open<K2, V>],\n+        inputs: &~[K1])\n         -> ~[joinable_task]\n     {\n         let mut tasks = ~[];\n         for inputs.each |i| {\n             let (ctrl, ctrl_server) = ctrl_proto::init();\n             let ctrl = box(ctrl);\n             let i = copy *i;\n-            tasks.push(spawn_joinable(|move i| map_task(map, ctrl, i)));\n+            let m = copy *map;\n+            tasks.push(spawn_joinable(|move i| map_task(m, &ctrl, i)));\n             ctrls.push(ctrl_server);\n         }\n         return tasks;\n     }\n \n     fn map_task<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n         map: mapper<K1, K2, V>,\n-        ctrl: box<ctrl_proto::client::open<K2, V>>,\n+        ctrl: &box<ctrl_proto::client::open<K2, V>>,\n         input: K1)\n     {\n         // log(error, \"map_task \" + input);\n-        let intermediates = map::HashMap();\n+        let intermediates: HashMap<K2, Chan<reduce_proto<V>>>\n+            = map::HashMap();\n \n-        do map(input) |key, val| {\n+        do map(input) |key: &K2, val| {\n             let mut c = None;\n-            let found = intermediates.find(key);\n+            let found: Option<Chan<reduce_proto<V>>>\n+                = intermediates.find(*key);\n             match found {\n               Some(_c) => { c = Some(_c); }\n               None => {\n                 do ctrl.swap |ctrl| {\n-                    let ctrl = ctrl_proto::client::find_reducer(ctrl, key);\n+                    let ctrl = ctrl_proto::client::find_reducer(ctrl, *key);\n                     match pipes::recv(ctrl) {\n                       ctrl_proto::reducer(c_, ctrl) => {\n                         c = Some(c_);\n                         move_out!(ctrl)\n                       }\n                     }\n                 }\n-                intermediates.insert(key, c.get());\n+                intermediates.insert(*key, c.get());\n                 send(c.get(), addref);\n               }\n             }\n@@ -200,38 +201,38 @@ mod map_reduce {\n     }\n \n     fn reduce_task<K: Copy Send, V: Copy Send>(\n-        reduce: reducer<K, V>, \n+        reduce: ~reducer<K, V>, \n         key: K,\n         out: Chan<Chan<reduce_proto<V>>>)\n     {\n         let p = Port();\n \n-        send(out, Chan(p));\n+        send(out, Chan(&p));\n \n         let mut ref_count = 0;\n         let mut is_done = false;\n \n         fn get<V: Copy Send>(p: Port<reduce_proto<V>>,\n-                             &ref_count: int, &is_done: bool)\n+                             ref_count: &mut int, is_done: &mut bool)\n            -> Option<V> {\n-            while !is_done || ref_count > 0 {\n+            while !*is_done || *ref_count > 0 {\n                 match recv(p) {\n                   emit_val(v) => {\n                     // error!(\"received %d\", v);\n                     return Some(v);\n                   }\n                   done => {\n                     // error!(\"all done\");\n-                    is_done = true;\n+                    *is_done = true;\n                   }\n-                  addref => { ref_count += 1; }\n-                  release => { ref_count -= 1; }\n+                  addref => { *ref_count += 1; }\n+                  release => { *ref_count -= 1; }\n                 }\n             }\n             return None;\n         }\n \n-        reduce(key, || get(p, ref_count, is_done) );\n+        (*reduce)(&key, || get(p, &mut ref_count, &mut is_done) );\n     }\n \n     fn map_reduce<K1: Copy Send, K2: Hash IterBytes Eq Const Copy Send, V: Copy Send>(\n@@ -245,7 +246,7 @@ mod map_reduce {\n         // to do the rest.\n \n         let reducers = map::HashMap();\n-        let mut tasks = start_mappers(map, ctrl, inputs);\n+        let mut tasks = start_mappers(&map, &mut ctrl, &inputs);\n         let mut num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n@@ -268,9 +269,9 @@ mod map_reduce {\n                   None => {\n                     // log(error, \"creating new reducer for \" + k);\n                     let p = Port();\n-                    let ch = Chan(p);\n+                    let ch = Chan(&p);\n                     let r = reduce, kk = k;\n-                    tasks.push(spawn_joinable(|| reduce_task(r, kk, ch) ));\n+                    tasks.push(spawn_joinable(|| reduce_task(~r, kk, ch) ));\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }\n@@ -288,7 +289,8 @@ mod map_reduce {\n     }\n }\n \n-fn main(++argv: ~[~str]) {\n+fn main() {\n+    let argv = os::args();\n     if vec::len(argv) < 2u && !os::getenv(~\"RUST_BENCH\").is_some() {\n         let out = io::stdout();\n "}, {"sha": "3bd1f47307b7e276ece113da6fe696e44d86d805", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:expected `extern fn(++v: ~[~str])\n+// error-pattern:expected `fn()\n \n fn main(x: int) { }"}, {"sha": "79f52b93612a4755538053e85ef916fe1c0dce78", "filename": "src/test/compile-fail/borrowck-lend-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-args.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,8 +4,8 @@ fn borrow_from_arg_imm_ref(&&v: ~int) {\n     borrow(v);\n }\n \n-fn borrow_from_arg_mut_ref(&v: ~int) {\n-    borrow(v); //~ ERROR illegal borrow unless pure\n+fn borrow_from_arg_mut_ref(v: &mut ~int) {\n+    borrow(*v); //~ ERROR illegal borrow unless pure\n     //~^ NOTE impure due to access to impure function\n }\n "}, {"sha": "bb466e2c00b807d37db9277b5e5b11f9424967a0", "filename": "src/test/compile-fail/deprecated-mode-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-mode-fn-arg.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,9 +1,9 @@\n #[forbid(deprecated_mode)];\n \n-fn foo(_f: fn(&i: int)) { //~ ERROR explicit mode\n+fn foo(_f: fn(&i: int)) { //~ ERROR by-mutable-reference mode\n }\n \n-type Bar = fn(&i: int); //~ ERROR explicit mode\n+type Bar = fn(&i: int); //~ ERROR by-mutable-reference mode\n \n fn main() {\n }\n\\ No newline at end of file"}, {"sha": "dd8f341b93553dcde76c936a921cbf1fd3a1ea67", "filename": "src/test/compile-fail/issue-3096-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,6 +1,6 @@\n enum bottom { } \n \n fn main() {\n-    let x = ptr::p2::addr_of(&()) as *bottom;\n+    let x = ptr::addr_of(&()) as *bottom;\n     match x { } //~ ERROR non-exhaustive patterns\n }"}, {"sha": "02a3082dc10dd9fa2ba6cd2b82e6d7716500efee", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,11 +1,11 @@\n extern mod std;\n use cmp::Eq;\n \n-fn f<T:Eq>(&o: Option<T>) {\n-    assert o == option::None;\n+fn f<T:Eq>(o: &mut Option<T>) {\n+    assert *o == option::None;\n }\n \n fn main() {\n-    f::<int>(option::None);\n+    f::<int>(&mut option::None);\n     //~^ ERROR illegal borrow: creating mutable alias to static item\n }"}, {"sha": "834457940bec1e961c63dea6e022c611bf6467cd", "filename": "src/test/compile-fail/liveness-dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-dead.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n-fn f1(&x: int) {\n-    x = 1; // no error\n+fn f1(x: &mut int) {\n+    *x = 1; // no error\n }\n \n fn f2() {"}, {"sha": "27e9d3b60dc9d28ab801d7cc464ead39cb84fa6b", "filename": "src/test/compile-fail/liveness-move-from-args.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,10 +4,6 @@ fn from_by_value_arg(++x: int) {\n     take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }\n \n-fn from_by_mut_ref_arg(&x: int) {\n-    take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n-}\n-\n fn from_by_ref_arg(&&x: int) {\n     take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }"}, {"sha": "8b2fef7cd350353f67e2f06f97fb7cce3e4758d6", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,7 +2,7 @@ fn f1(x: int) {\n     //~^ WARNING unused variable: `x`\n }\n \n-fn f1b(&x: int) {\n+fn f1b(x: &mut int) {\n     //~^ WARNING unused variable: `x`\n }\n "}, {"sha": "d84c9401e2577104bf8b2310d32cba437912b4d9", "filename": "src/test/compile-fail/mutable-arguments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,28 +1,28 @@\n // Note: it would be nice to give fewer warnings in these cases.\n \n-fn mutate_by_mut_ref(&x: uint) {\n-    x = 0u;\n+fn mutate_by_mut_ref(x: &mut uint) {\n+    *x = 0;\n }\n \n fn mutate_by_ref(&&x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n }\n \n fn mutate_by_val(++x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n }\n \n fn mutate_by_copy(+x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n     //~^ WARNING value assigned to `x` is never read\n }\n \n fn mutate_by_move(-x: uint) {\n     //~^ WARNING unused variable: `x`\n-    x = 0u; //~ ERROR assigning to argument\n+    x = 0; //~ ERROR assigning to argument\n     //~^ WARNING value assigned to `x` is never read\n }\n "}, {"sha": "eaba1d8611967f078150d4f0ea16d9ec56191b68", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x : *~[int] = ptr::p2::addr_of(&~[1,2,3]);\n+    let x : *~[int] = ptr::addr_of(&~[1,2,3]);\n     let y : *libc::c_void = x as *libc::c_void;\n     unsafe {\n         let _z = *y;"}, {"sha": "77d40aae6a2738203e91cc7ed047a22b12c39070", "filename": "src/test/compile-fail/unnamed_argument_mode.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Funnamed_argument_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Funnamed_argument_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnamed_argument_mode.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,11 +1,8 @@\n-//error-pattern: mismatched types\n+//error-pattern: by-mutable-reference mode\n \n fn bad(&a: int) {\n }\n \n-// unnamed argument &int is now parsed x: &int\n-// it's not parsed &x: int anymore\n-\n fn called(f: fn(&int)) {\n }\n "}, {"sha": "a47a8b76e56a98f170b2f973569772fdce49b56a", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -16,6 +16,6 @@ fn foo(i:int, j: @~str) -> foo {\n fn main() {\n   let cat = ~\"kitty\";\n   let po = comm::Port();         //~ ERROR missing `send`\n-  let ch = comm::Chan(po);       //~ ERROR missing `send`\n+  let ch = comm::Chan(&po);       //~ ERROR missing `send`\n   comm::send(ch, foo(42, @cat)); //~ ERROR missing `send`\n }"}, {"sha": "8032c199bf099f619ad0dc4193a6c40271c15477", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -14,7 +14,7 @@ impl int: TraitB {\n \n fn call_it<B: TraitB>(b: B)  -> int {\n     let y = 4u;\n-    b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait @TraitA for uint\n+    b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait @TraitA\n }\n \n fn main() {"}, {"sha": "30714413c5376df2a08b1d730bdd66284951d0db", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -9,7 +9,7 @@ fn echo<T: Send>(c: Chan<T>, oc: Chan<Chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = Port::<T>();\n-    send(oc, Chan(p));\n+    send(oc, Chan(&p));\n \n     let x = recv(p);\n     send(c, x);"}, {"sha": "e8aaf88374f94f99fcc363e57002cea8ede1d5a3", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,18 +1,18 @@\n // xfail-fast\n #[legacy_modes];\n \n-fn f1(a: {mut x: int}, &b: int, -c: int) -> int {\n-    let r = a.x + b + c;\n+fn f1(a: {mut x: int}, b: &mut int, -c: int) -> int {\n+    let r = a.x + *b + c;\n     a.x = 0;\n-    b = 10;\n+    *b = 10;\n     return r;\n }\n \n fn f2(a: int, f: fn(int)) -> int { f(1); return a; }\n \n fn main() {\n     let mut a = {mut x: 1}, b = 2, c = 3;\n-    assert (f1(a, b, c) == 6);\n+    assert (f1(a, &mut b, c) == 6);\n     assert (a.x == 0);\n     assert (b == 10);\n     assert (f2(a.x, |x| a.x = 50 ) == 0);"}, {"sha": "a697e0f73dcb470dfde028ceb80b195a56064e8d", "filename": "src/test/run-pass/argv.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=d4a54837d4ab28219727e1f1e0c131ba6033ba94", "patch": "@@ -1,5 +0,0 @@\n-fn main(++args: ~[~str]) {\n-    let vs: ~[~str] = ~[~\"hi\", ~\"there\", ~\"this\", ~\"is\", ~\"a\", ~\"vec\"];\n-    let vvs: ~[~[~str]] = ~[args, vs];\n-    for vvs.each |vs| { for vs.each |s| { log(debug, *s); } }\n-}"}, {"sha": "1f0bfe93ab28fb70122b38d7bd84613d9428f4e6", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,7 +10,7 @@ fn a(c: Chan<int>) { send(c, 10); }\n \n fn main() {\n     let p = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| a(ch) );\n     let mut n: int = 0;"}, {"sha": "7a81bfc3fc5293c71222c2e3bbd55847b18a92fd", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -10,7 +10,7 @@ fn a(c: Chan<int>) { debug!(\"task a0\"); debug!(\"task a1\"); send(c, 10); }\n \n fn main() {\n     let p = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| b(ch) );\n     let mut n: int = 0;"}, {"sha": "6f8fa6e3e70ff7f64e443f3404397c52260d1d4c", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     let mut n: int = 2 + 3 * 7;\n     let s: ~str = ~\"hello there\";\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| b(ch) );\n     let mut x: int = 10;"}, {"sha": "60f2430770965aaea16e7d9feeeb66cf5594fada", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -17,7 +17,7 @@ use comm::*;\n \n fn foo(&&x: ()) -> Port<()> {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     do task::spawn() |copy c, copy x| {\n         c.send(x);\n     }"}, {"sha": "f834b1b3519596c684f69f6fe36c7936ce614c18", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -12,7 +12,7 @@ type ctx = Chan<request>;\n \n fn request_task(c: Chan<ctx>) {\n     let p = Port();\n-    send(c, Chan(p));\n+    send(c, Chan(&p));\n     let mut req: request;\n     req = recv(p);\n     // Need to drop req before receiving it again\n@@ -21,7 +21,7 @@ fn request_task(c: Chan<ctx>) {\n \n fn new_cx() -> ctx {\n     let p = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     let t = task::spawn(|| request_task(ch) );\n     let mut cx: ctx;\n     cx = recv(p);\n@@ -32,6 +32,6 @@ fn main() {\n     let cx = new_cx();\n \n     let p = Port::<bool>();\n-    send(cx, close(Chan(p)));\n+    send(cx, close(Chan(&p)));\n     send(cx, quit);\n }"}, {"sha": "003b7c830934df4f920c26c1249cc97f808e5ab3", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -7,7 +7,7 @@ use comm::recv;\n \n fn main() {\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     let t = task::spawn(|| child(ch) );\n     let y = recv(p);\n     error!(\"received\");"}, {"sha": "242392ccbe1726bf45dda3b0439835f96178588f", "filename": "src/test/run-pass/command-line-args.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs?ref=d4a54837d4ab28219727e1f1e0c131ba6033ba94", "patch": "@@ -1,3 +0,0 @@\n-\n-\n-fn main(++args: ~[~str]) { log(debug, args[0]); }"}, {"sha": "b594e5334c46ae0f49d70415131e0f3123e785e4", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,7 @@ use comm::recv;\n \n fn main() {\n     let po = Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n     send(ch, 10);\n     let i = recv(po);\n     assert (i == 10);"}, {"sha": "71996552d0cceb1c597a5375c73286500e9c5fe1", "filename": "src/test/run-pass/fn-bare-assign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ffn-bare-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ffn-bare-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-assign.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,15 +1,15 @@\n-fn f(i: int, &called: bool) {\n+fn f(i: int, called: &mut bool) {\n     assert i == 10;\n-    called = true;\n+    *called = true;\n }\n \n-fn g(f: extern fn(int, &v: bool), &called: bool) {\n+fn g(f: extern fn(int, v: &mut bool), called: &mut bool) {\n     f(10, called);\n }\n \n fn main() {\n     let mut called = false;\n     let h = f;\n-    g(h, called);\n+    g(h, &mut called);\n     assert called == true;\n }\n\\ No newline at end of file"}, {"sha": "50b88693f39f24c3e7ff6fe1be81439900ce1332", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -47,7 +47,7 @@ mod map_reduce {\n               None => {\n                 let p = Port();\n                 error!(\"sending find_reducer\");\n-                send(ctrl, find_reducer(str::to_bytes(key), Chan(p)));\n+                send(ctrl, find_reducer(str::to_bytes(key), Chan(&p)));\n                 error!(\"receiving\");\n                 c = recv(p);\n                 log(error, c);\n@@ -70,7 +70,7 @@ mod map_reduce {\n \n         reducers = map::HashMap();\n \n-        start_mappers(Chan(ctrl), inputs);\n+        start_mappers(Chan(&ctrl), inputs);\n \n         let mut num_mappers = vec::len(inputs) as int;\n "}, {"sha": "683321aac3d09fd82c1946c13271cfe3ac10fc76", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,13 +1,13 @@\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn move_val_init<T>(&dst: T, -src: T);\n-    fn move_val<T>(&dst: T, -src: T);\n+    fn move_val_init<T>(dst: &mut T, -src: T);\n+    fn move_val<T>(dst: &mut T, -src: T);\n }\n \n fn main() {\n     let mut x = @1;\n     let mut y = @2;\n-    rusti::move_val(y, x);\n+    rusti::move_val(&mut y, x);\n     assert *y == 1;\n }\n\\ No newline at end of file"}, {"sha": "0baa0aca7ade032182fa1ac1bec9707648359a85", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -20,7 +20,7 @@ fn child(c: Chan<int>) {\n \n fn main() {\n     let p = comm::Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n \n     task::spawn(|| child(ch) );\n "}, {"sha": "4ed94c5778491ddf032a83db4aafc75150ca1f6c", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -14,7 +14,7 @@ fn producer(c: Chan<~[u8]>) {\n \n fn packager(cb: Chan<Chan<~[u8]>>, msg: Chan<msg>) {\n     let p: Port<~[u8]> = Port();\n-    send(cb, Chan(p));\n+    send(cb, Chan(&p));\n     loop {\n         debug!(\"waiting for bytes\");\n         let data = recv(p);\n@@ -35,9 +35,9 @@ fn packager(cb: Chan<Chan<~[u8]>>, msg: Chan<msg>) {\n \n fn main() {\n     let p: Port<msg> = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     let recv_reader: Port<Chan<~[u8]>> = Port();\n-    let recv_reader_chan = Chan(recv_reader);\n+    let recv_reader_chan = Chan(&recv_reader);\n     let pack = task::spawn(|| packager(recv_reader_chan, ch) );\n \n     let source_chan: Chan<~[u8]> = recv(recv_reader);"}, {"sha": "50fadefa46437fa5a00aed7d40d5e568105f2e58", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -6,10 +6,10 @@ fn a() {\n     fn doit() {\n         fn b(c: Chan<Chan<int>>) {\n             let p = Port();\n-            send(c, Chan(p));\n+            send(c, Chan(&p));\n         }\n         let p = Port();\n-        let ch = Chan(p);\n+        let ch = Chan(&p);\n         spawn(|| b(ch) );\n         recv(p);\n     }"}, {"sha": "b92d20bbe40c106091c05d44d54283872f665308", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -13,7 +13,7 @@ fn producer(c: Chan<~[u8]>) {\n \n fn main() {\n     let p: Port<~[u8]> = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     let prod = task::spawn(|| producer(ch) );\n \n     let data: ~[u8] = recv(p);"}, {"sha": "3e84c9f6f726adce7255ac28687c30c467f5b094", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,12 +1,12 @@\n \n \n-fn incr(&x: int) -> bool { x += 1; assert (false); return false; }\n+fn incr(x: &mut int) -> bool { *x += 1; assert (false); return false; }\n \n fn main() {\n     let x = 1 == 2 || 3 == 3;\n     assert (x);\n     let mut y: int = 10;\n-    log(debug, x || incr(y));\n+    log(debug, x || incr(&mut y));\n     assert (y == 10);\n     if true && x { assert (true); } else { assert (false); }\n }"}, {"sha": "06e89a298a9762992ccd34b748e671cdedf21b13", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -5,7 +5,7 @@ use comm::*;\n \n fn main() {\n     let p = Port();\n-    let ch = Chan(p);\n+    let ch = Chan(&p);\n     let mut y: int;\n \n     task::spawn(|| child(ch) );"}, {"sha": "39bbd07c66b12ce0aa4de9fbf59494af3cd6b849", "filename": "src/test/run-pass/main-ivec.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a54837d4ab28219727e1f1e0c131ba6033ba94/src%2Ftest%2Frun-pass%2Fmain-ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmain-ivec.rs?ref=d4a54837d4ab28219727e1f1e0c131ba6033ba94", "patch": "@@ -1 +0,0 @@\n-fn main(++args: ~[~str]) { for args.each |s| { log(debug, *s); } }"}, {"sha": "83ebc0ef844b01aa72aa44a00412ce190ca32783", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -7,7 +7,7 @@ fn sub(parent: comm::Chan<int>, id: int) {\n         comm::send(parent, 0);\n     } else {\n         let p = comm::Port();\n-        let ch = comm::Chan(p);\n+        let ch = comm::Chan(&p);\n         let child = task::spawn(|| sub(ch, id - 1) );\n         let y = comm::recv(p);\n         comm::send(parent, y + 1);\n@@ -16,7 +16,7 @@ fn sub(parent: comm::Chan<int>, id: int) {\n \n fn main() {\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     let child = task::spawn(|| sub(ch, 200) );\n     let y = comm::recv(p);\n     debug!(\"transmission complete\");"}, {"sha": "d5b1eef993e1d4538fb454028b0f61ad98f2990a", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -3,13 +3,13 @@\n // -*- rust -*-\n extern mod std;\n \n-fn grow(&v: ~[int]) { v += ~[1]; }\n+fn grow(v: &mut ~[int]) { *v += ~[1]; }\n \n fn main() {\n     let mut v: ~[int] = ~[];\n-    grow(v);\n-    grow(v);\n-    grow(v);\n+    grow(&mut v);\n+    grow(&mut v);\n+    grow(&mut v);\n     let len = vec::len::<int>(v);\n     log(debug, len);\n     assert (len == 3 as uint);"}, {"sha": "daa8d9d67964f7ba342aa0fb20bef36dcb5c3fc0", "filename": "src/test/run-pass/reexport-star.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Freexport-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Freexport-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-star.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,3 +1,6 @@\n+// xfail-pretty\n+// FIXME #3654\n+\n mod a {\n     pub fn f() {}\n     pub fn g() {}"}, {"sha": "2af5535ad2805ff599c50a55a30073392ab79caf", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -18,7 +18,7 @@ type record = {val1: u32, val2: u32, val3: u32};\n // assertions.\n fn test_init() {\n     let myport = Port();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n     send(mychan, val);\n }\n@@ -28,7 +28,7 @@ fn test_init() {\n // Don't trigger any assertions.\n fn test_grow() {\n     let myport = Port();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     for uint::range(0u, 100u) |i| {\n         let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n         comm::send(mychan, val);\n@@ -39,14 +39,14 @@ fn test_grow() {\n // Don't allow the buffer to shrink below it's original size\n fn test_shrink1() {\n     let myport = Port();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     send(mychan, 0i8);\n     let x = recv(myport);\n }\n \n fn test_shrink2() {\n     let myport = Port();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     for uint::range(0u, 100u) |_i| {\n         let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n         send(mychan, val);\n@@ -58,7 +58,7 @@ fn test_shrink2() {\n // Test rotating the buffer when the unit size is not a power of two\n fn test_rotate() {\n     let myport = Port();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     for uint::range(0u, 100u) |i| {\n         let val = {val1: i as u32, val2: i as u32, val3: i as u32};\n         send(mychan, val);\n@@ -74,7 +74,7 @@ fn test_rotate() {\n // the unit size is not a power of two\n fn test_rotate_grow() {\n     let myport = Port::<record>();\n-    let mychan = Chan(myport);\n+    let mychan = Chan(&myport);\n     for uint::range(0u, 10u) |j| {\n         for uint::range(0u, 10u) |i| {\n             let val: record ="}, {"sha": "690d93172ebcfb3abe6492966d52bcb2e2b63485", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -18,7 +18,7 @@ extern mod rustrt {\n \n fn main() unsafe {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     let parent_sched_id = rustrt::rust_get_sched_id();\n     error!(\"parent %?\", parent_sched_id);\n     let num_threads = 1u;"}, {"sha": "b0003e8b5b18be4a157d125b981a10af5d1a884e", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,7 +8,7 @@ fn die() {\n fn iloop() {\n     task::spawn(|| die() );\n     let p = comm::Port::<()>();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     loop {\n         // Sending and receiving here because these actions yield,\n         // at which point our child can kill us"}, {"sha": "a2ef71b14124404f32ebf1b506c58adb24311ac2", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -14,11 +14,11 @@ fn test(f: int) -> test {\n \n fn main() {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n \n     do spawn() {\n         let p = Port();\n-        c.send(Chan(p));\n+        c.send(Chan(&p));\n \n         let _r = p.recv();\n     }"}, {"sha": "8bca78807871b4a0bbc8451edfc846330026c890", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -8,6 +8,6 @@ type command<K: Send, V: Send> = {key: K, val: V};\n \n fn cache_server<K: Send, V: Send>(c: Chan<Chan<command<K, V>>>) {\n     let ctrl = Port();\n-    send(c, Chan(ctrl));\n+    send(c, Chan(&ctrl));\n }\n fn main() { }"}, {"sha": "d9b0ec336432ab95747d1f037ac4de35d9ed7c5c", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -14,6 +14,6 @@ fn foo(i:int, j: char) -> foo {\n \n fn main() {\n   let po = comm::Port::<foo>();\n-  let ch = comm::Chan(po);\n+  let ch = comm::Chan(&po);\n   comm::send(ch, foo(42, 'c'));\n }\n\\ No newline at end of file"}, {"sha": "043bf125532eb01dd6706b5e5e383f643427a7fe", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -15,6 +15,6 @@ fn iotask(cx: ctx, ip: ~str) {\n \n fn main() {\n     let p = comm::Port::<int>();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     task::spawn(|| iotask(ch, ~\"localhost\") );\n }"}, {"sha": "b81f001c00d57d8fb84e9048a71471ff98e7d5d7", "filename": "src/test/run-pass/task-comm-chan-cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,6 +2,6 @@ extern mod std;\n \n fn main() {\n     let p = comm::Port();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     comm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "b81f001c00d57d8fb84e9048a71471ff98e7d5d7", "filename": "src/test/run-pass/task-comm-chan-cleanup2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,6 +2,6 @@ extern mod std;\n \n fn main() {\n     let p = comm::Port();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     comm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "14cb272b62f3116b9c23b88c157d7894e3e5170d", "filename": "src/test/run-pass/task-comm-chan-cleanup3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -3,7 +3,7 @@ extern mod std;\n fn main() {\n     let c = {\n         let p = comm::Port();\n-        comm::Chan(p)\n+        comm::Chan(&p)\n     };\n     comm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "852f0e5607d82f443bdc857af4ca62348a0701d2", "filename": "src/test/run-pass/task-comm-chan-cleanup4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -12,7 +12,7 @@ fn starship(&&ch: comm::Chan<~str>) {\n fn starbase() {\n     for int::range(0, 10) |_i| {\n         let p = comm::Port();\n-        let c = comm::Chan(p);\n+        let c = comm::Chan(&p);\n         task::spawn(|| starship(c) );\n         task::yield();\n     }"}, {"sha": "7cbd24844fe5a6039987836d367e8f91a2a2da9b", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -7,7 +7,7 @@ extern mod std;\n // or not this is desirable I don't know, but here's a regression test.\n fn main() {\n     let po = comm::Port();\n-    let ch = comm::Chan(po);\n+    let ch = comm::Chan(&po);\n     comm::send(ch, ());\n     let n: () = comm::recv(po);\n     assert (n == ());"}, {"sha": "c88b556fd53f793265b4fc12facbcf0d1a9e5086", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n     debug!(\"Creating tasks\");\n \n     let po = Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n \n     let mut i: int = 0;\n \n@@ -69,7 +69,7 @@ fn test01() {\n \n fn test02() {\n     let p = Port();\n-    let c = Chan(p);\n+    let c = Chan(&p);\n     debug!(\"Writing to a local task channel.\");\n     send(c, 42);\n     debug!(\"Reading from a local task port.\");\n@@ -101,7 +101,7 @@ fn test05_start(ch: Chan<int>) {\n \n fn test05() {\n     let po = comm::Port();\n-    let ch = Chan(po);\n+    let ch = Chan(&po);\n     task::spawn(|| test05_start(ch) );\n     let mut value: int;\n     value = recv(po);"}, {"sha": "1cea7d61f8c4ba77e994337638e6e35141011daf", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -36,7 +36,7 @@ fn joinable(+f: fn~()) -> comm::Port<bool> {\n         *b = true;\n     }\n     let p = comm::Port();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     do task::spawn_unlinked { wrapper(c, copy f) };\n     p\n }"}, {"sha": "09c880d489c263dc6f40d03f3c7310eef81b6047", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let p = comm::Port::<uint>();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n \n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;"}, {"sha": "37dd11aadc48284e6f6d04912f0a09d2684bb474", "filename": "src/test/run-pass/trait-inheritance-simple.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -0,0 +1,31 @@\n+// xfail-fast\n+// xfail-test\n+\n+// Broken on 32 bit, I guess?\n+\n+trait Foo {\n+    fn f();\n+}\n+\n+trait Bar : Foo {\n+    fn g();\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Bar {\n+    fn g() { io::println(\"in g\"); }\n+    fn f() { io::println(\"in f\"); }\n+}\n+\n+fn h<T:Foo>(a: &T) {\n+    a.f();\n+}\n+\n+fn main() {\n+    let a = A { x: 3 };\n+    h(&a);\n+}\n+"}, {"sha": "dfcbfc3993f16dbcf8216df174c72f77410994c4", "filename": "src/test/run-pass/trait-region-pointer-simple.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-region-pointer-simple.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -0,0 +1,21 @@\n+trait Foo {\n+    fn f() -> int;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn f() -> int {\n+        io::println(~\"Today's number is \" + self.x.to_str());\n+        return self.x;\n+    }\n+}\n+\n+fn main() {\n+    let a = A { x: 3 };\n+    let b = (&a) as &Foo;\n+    assert b.f() == 3;\n+}\n+"}, {"sha": "36d1d689f5fb824cc4e0be350e3d8d7c7ed8723f", "filename": "src/test/run-pass/unique-fn-arg-mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-fn-arg-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-fn-arg-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-fn-arg-mut.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -1,9 +1,9 @@\n-fn f(&i: ~int) {\n-    i = ~200;\n+fn f(i: &mut ~int) {\n+    *i = ~200;\n }\n \n fn main() {\n     let mut i = ~100;\n-    f(i);\n+    f(&mut i);\n     assert *i == 200;\n }\n\\ No newline at end of file"}, {"sha": "70d58ea6cc3b37b80dfb45098ea8b401f1232205", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -6,7 +6,7 @@ fn child(c: comm::Chan<~uint>, i: uint) {\n \n fn main() {\n     let p = comm::Port();\n-    let ch = comm::Chan(p);\n+    let ch = comm::Chan(&p);\n     let n = 100u;\n     let mut expected = 0u;\n     for uint::range(0u, n) |i| {"}, {"sha": "cf06a55ae7a5bd64e380ab4fc67d231895570082", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -2,7 +2,7 @@ extern mod std;\n \n fn main() {\n     let p = comm::Port();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     comm::send(c, ~100);\n     let v = comm::recv(p);\n     assert v == ~100;"}, {"sha": "a602a2716026ec7b1d652dbfd0a4106870c9d41b", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -22,7 +22,7 @@ fn f(c: comm::Chan<bool>) {\n \n fn main() {\n     let p = comm::Port();\n-    let c = comm::Chan(p);\n+    let c = comm::Chan(&p);\n     task::spawn_unlinked(|| f(c) );\n     error!(\"hiiiiiiiii\");\n     assert comm::recv(p);"}, {"sha": "eb3fa602f12ac78b0a12426ef71db0c808b478bc", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=0e3bec0ced8d781cdd93996e7b8eeedb13f81ba8", "patch": "@@ -4,10 +4,10 @@\n // -*- rust -*-\n type point = {x: int, y: int, mut z: int};\n \n-fn f(&p: point) { p.z = 13; }\n+fn f(p: &mut point) { p.z = 13; }\n \n fn main() {\n     let mut x: point = {x: 10, y: 11, mut z: 12};\n-    f(x);\n+    f(&mut x);\n     assert (x.z == 13);\n }"}]}