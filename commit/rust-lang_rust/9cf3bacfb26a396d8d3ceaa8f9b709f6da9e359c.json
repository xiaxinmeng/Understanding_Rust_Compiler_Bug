{"sha": "9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "node_id": "C_kwDOAAsO6NoAKDljZjNiYWNmYjI2YTM5NmQ4ZDNjZWFhOGY5YjcwOWY2ZGE5ZTM1OWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-21T14:54:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-21T14:54:04Z"}, "message": "Rollup merge of #100761 - lcnr:mir-typeck-cleanup, r=compiler-errors\n\nsome general mir typeck cleanup\n\nthis pr contains the parts of #95763 which already work correctly.\n\nthe remaining commits of that PR have some issues which are more complex to fix.\n\nr? types", "tree": {"sha": "ff13bb18a6996a6b835f90d686d50275ddc28a43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff13bb18a6996a6b835f90d686d50275ddc28a43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAkcMCRBK7hj4Ov3rIwAAAdkIAJuD6PSqx+SWvWwZBh2hOPc+\ne+I9h0iX3BB761FBcgByY9jnUoRLWB7P1tJXYNRuR56RUAksRHNeSeLbsEFejOUm\nTJgIrV5Js5cFfXGhju21qkvRUl1ZQL+/bbHco9Ey054KFE84PTxbS5lNVtWptuw/\n94lpk8q2RbgZTHb8ShK8CJh3wqgYkx7Hk//D3ihbiwcHL2rbwK9grB/8a+WiRgUj\nhwNus3dSIRE8kQEOBanWvOzPLC6cIC320p1SUPlMoyRE19zP8dIY6hqOTtxPg23e\nyfSLt3ROD5dNDfBw4LWd1WfJ7vsZ1a2ROnlLatHJv2hu9A4likGgLKdi6TtuSho=\n=6Ick\n-----END PGP SIGNATURE-----\n", "payload": "tree ff13bb18a6996a6b835f90d686d50275ddc28a43\nparent 938ebf9a838f602b59b309b5af9ea846d48f8d08\nparent 56b5ec83f2ade19fc601ad44a7366d3e5215401a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661093644 +0200\ncommitter GitHub <noreply@github.com> 1661093644 +0200\n\nRollup merge of #100761 - lcnr:mir-typeck-cleanup, r=compiler-errors\n\nsome general mir typeck cleanup\n\nthis pr contains the parts of #95763 which already work correctly.\n\nthe remaining commits of that PR have some issues which are more complex to fix.\n\nr? types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "html_url": "https://github.com/rust-lang/rust/commit/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "938ebf9a838f602b59b309b5af9ea846d48f8d08", "url": "https://api.github.com/repos/rust-lang/rust/commits/938ebf9a838f602b59b309b5af9ea846d48f8d08", "html_url": "https://github.com/rust-lang/rust/commit/938ebf9a838f602b59b309b5af9ea846d48f8d08"}, {"sha": "56b5ec83f2ade19fc601ad44a7366d3e5215401a", "url": "https://api.github.com/repos/rust-lang/rust/commits/56b5ec83f2ade19fc601ad44a7366d3e5215401a", "html_url": "https://github.com/rust-lang/rust/commit/56b5ec83f2ade19fc601ad44a7366d3e5215401a"}], "stats": {"total": 148, "additions": 58, "deletions": 90}, "files": [{"sha": "451b82c5c18700f07f1967ab571f604ebc9cf584", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "patch": "@@ -90,12 +90,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {\n-        self.prove_predicates(\n-            Some(ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n+        self.prove_predicate(\n+            ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n                 polarity: ty::ImplPolarity::Positive,\n-            }))),\n+            }))\n+            .to_predicate(self.tcx()),\n             locations,\n             category,\n         );"}, {"sha": "bb28622edf931b98b00bdeb27db1aab5d4a6e1c8", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "patch": "@@ -268,7 +268,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 // }\n                 // impl Foo for () {\n                 //   type Bar = ();\n-                //   fn foo(&self) ->&() {}\n+                //   fn foo(&self) -> &() {}\n                 // }\n                 // ```\n                 // Both &Self::Bar and &() are WF"}, {"sha": "293d847ec9ab7aafdc3be14fae88a2b6c286ee01", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 53, "deletions": 86, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "patch": "@@ -178,97 +178,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         upvars,\n     };\n \n-    let opaque_type_values = type_check_internal(\n+    let mut checker = TypeChecker::new(\n         infcx,\n-        param_env,\n         body,\n-        promoted,\n+        param_env,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n-        |mut cx| {\n-            debug!(\"inside extra closure of type_check_internal\");\n-            cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(\n-                &mut cx,\n-                body,\n-                elements,\n-                flow_inits,\n-                move_data,\n-                location_table,\n-                use_polonius,\n-            );\n-\n-            translate_outlives_facts(&mut cx);\n-            let opaque_type_values =\n-                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-            opaque_type_values\n-                .into_iter()\n-                .map(|(opaque_type_key, decl)| {\n-                    cx.fully_perform_op(\n-                        Locations::All(body.span),\n-                        ConstraintCategory::OpaqueType,\n-                        CustomTypeOp::new(\n-                            |infcx| {\n-                                infcx.register_member_constraints(\n-                                    param_env,\n-                                    opaque_type_key,\n-                                    decl.hidden_type.ty,\n-                                    decl.hidden_type.span,\n-                                );\n-                                Ok(InferOk { value: (), obligations: vec![] })\n-                            },\n-                            || \"opaque_type_map\".to_string(),\n-                        ),\n-                    )\n-                    .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n-                    trace!(\n-                        \"finalized opaque type {:?} to {:#?}\",\n-                        opaque_type_key,\n-                        hidden_type.ty.kind()\n-                    );\n-                    if hidden_type.has_infer_types_or_consts() {\n-                        infcx.tcx.sess.delay_span_bug(\n-                            decl.hidden_type.span,\n-                            &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n-                        );\n-                        hidden_type.ty = infcx.tcx.ty_error();\n-                    }\n-\n-                    (opaque_type_key, (hidden_type, decl.origin))\n-                })\n-                .collect()\n-        },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n-}\n-\n-#[instrument(\n-    skip(infcx, body, promoted, region_bound_pairs, borrowck_context, extra),\n-    level = \"debug\"\n-)]\n-fn type_check_internal<'a, 'tcx, R>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n-    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: ty::Region<'tcx>,\n-    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n-) -> R {\n-    debug!(\"body: {:#?}\", body);\n-    let mut checker = TypeChecker::new(\n-        infcx,\n-        body,\n-        param_env,\n-        region_bound_pairs,\n-        implicit_region_bound,\n-        borrowck_context,\n-    );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n@@ -280,7 +198,56 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(checker)\n+    checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    liveness::generate(\n+        &mut checker,\n+        body,\n+        elements,\n+        flow_inits,\n+        move_data,\n+        location_table,\n+        use_polonius,\n+    );\n+\n+    translate_outlives_facts(&mut checker);\n+    let opaque_type_values = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+    let opaque_type_values = opaque_type_values\n+        .into_iter()\n+        .map(|(opaque_type_key, decl)| {\n+            checker\n+                .fully_perform_op(\n+                    Locations::All(body.span),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |infcx| {\n+                            infcx.register_member_constraints(\n+                                param_env,\n+                                opaque_type_key,\n+                                decl.hidden_type.ty,\n+                                decl.hidden_type.span,\n+                            );\n+                            Ok(InferOk { value: (), obligations: vec![] })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )\n+                .unwrap();\n+            let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n+            trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n+            if hidden_type.has_infer_types_or_consts() {\n+                infcx.tcx.sess.delay_span_bug(\n+                    decl.hidden_type.span,\n+                    &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n+                );\n+                hidden_type.ty = infcx.tcx.ty_error();\n+            }\n+\n+            (opaque_type_key, (hidden_type, decl.origin))\n+        })\n+        .collect();\n+\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n@@ -1911,7 +1878,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            &Rvalue::NullaryOp(_, ty) => {\n+            &Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, ty) => {\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),"}]}