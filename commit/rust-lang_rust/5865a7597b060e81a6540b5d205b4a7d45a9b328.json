{"sha": "5865a7597b060e81a6540b5d205b4a7d45a9b328", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NjVhNzU5N2IwNjBlODFhNjU0MGI1ZDIwNWI0YTdkNDVhOWIzMjg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-04T20:22:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-04T22:45:16Z"}, "message": "Remove trailing null from strings", "tree": {"sha": "d344bbaa99d685e53df4153dd0e266b2e8221596", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d344bbaa99d685e53df4153dd0e266b2e8221596"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5865a7597b060e81a6540b5d205b4a7d45a9b328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5865a7597b060e81a6540b5d205b4a7d45a9b328", "html_url": "https://github.com/rust-lang/rust/commit/5865a7597b060e81a6540b5d205b4a7d45a9b328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5865a7597b060e81a6540b5d205b4a7d45a9b328/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17e0089856de145b10485c9a96bcf4f39e5b7f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e0089856de145b10485c9a96bcf4f39e5b7f71", "html_url": "https://github.com/rust-lang/rust/commit/17e0089856de145b10485c9a96bcf4f39e5b7f71"}], "stats": {"total": 587, "additions": 544, "deletions": 43}, "files": [{"sha": "d95e5d8d6d8e3cba2dfc80605af5d6f29abfa018", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -476,6 +476,7 @@ impl FormatOp {\n     }\n }\n \n+#[cfg(stage0)]\n priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n@@ -545,8 +546,103 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n         String(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = s.to_bytes_with_null();\n-                    s.pop(); // remove the null\n+                    let mut s = s.as_bytes().to_owned();\n+                    if flags.precision > 0 && flags.precision < s.len() {\n+                        s.truncate(flags.precision);\n+                    }\n+                    s\n+                }\n+                _ => {\n+                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                }\n+            }\n+        }\n+    };\n+    if flags.width > s.len() {\n+        let n = flags.width - s.len();\n+        if flags.left {\n+            s.grow(n, &(' ' as u8));\n+        } else {\n+            let mut s_ = vec::with_capacity(flags.width);\n+            s_.grow(n, &(' ' as u8));\n+            s_.push_all_move(s);\n+            s = s_;\n+        }\n+    }\n+    Ok(s)\n+}\n+\n+#[cfg(not(stage0))]\n+priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+    let mut s = match val {\n+        Number(d) => {\n+            match op {\n+                FormatString => {\n+                    return Err(~\"non-number on stack with %s\")\n+                }\n+                _ => {\n+                    let radix = match op {\n+                        FormatDigit => 10,\n+                        FormatOctal => 8,\n+                        FormatHex|FormatHEX => 16,\n+                        FormatString => util::unreachable()\n+                    };\n+                    let mut s = ~[];\n+                    match op {\n+                        FormatDigit => {\n+                            let sign = if flags.sign { SignAll } else { SignNeg };\n+                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                        _ => {\n+                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                                s.push(c);\n+                            }\n+                        }\n+                    };\n+                    if flags.precision > s.len() {\n+                        let mut s_ = vec::with_capacity(flags.precision);\n+                        let n = flags.precision - s.len();\n+                        s_.grow(n, &('0' as u8));\n+                        s_.push_all_move(s);\n+                        s = s_;\n+                    }\n+                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n+                    match op {\n+                        FormatDigit => {\n+                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                                s.unshift(' ' as u8);\n+                            }\n+                        }\n+                        FormatOctal => {\n+                            if flags.alternate && s[0] != '0' as u8 {\n+                                s.unshift('0' as u8);\n+                            }\n+                        }\n+                        FormatHex => {\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatHEX => {\n+                            s = s.into_ascii().to_upper().into_bytes();\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatString => util::unreachable()\n+                    }\n+                    s\n+                }\n+            }\n+        }\n+        String(s) => {\n+            match op {\n+                FormatString => {\n+                    let mut s = s.as_bytes().to_owned();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }"}, {"sha": "2bd1b34f84c69423263befae61a95a07d6e50e25", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -780,7 +780,7 @@ pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len + 1u /* +1 for null */)])\n+        C_struct([cs, C_uint(cx, len)])\n     }\n }\n "}, {"sha": "2487d481c0deae3505c75b74d41edd98af2251a0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -870,7 +870,6 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n         let _icx = push_ctxt(\"trans_index\");\n         let ccx = bcx.ccx();\n-        let base_ty = expr_ty(bcx, base);\n         let mut bcx = bcx;\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n@@ -900,12 +899,6 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         let (bcx, base, len) =\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n                                             index_expr.id, 0);\n-        let mut len = len;\n-\n-        if ty::type_is_str(base_ty) {\n-            // acccount for null terminator in the case of string\n-            len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n-        }\n \n         debug!(\"trans_index: base %s\", bcx.val_to_str(base));\n         debug!(\"trans_index: len %s\", bcx.val_to_str(len));"}, {"sha": "032bbd1be3a84c87f024f64a076f2cc7f749f67b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -58,7 +58,7 @@ impl Reflector {\n         let str_vstore = ty::vstore_slice(ty::re_static);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n-        let len = C_uint(bcx.ccx(), s.len() + 1);\n+        let len = C_uint(bcx.ccx(), s.len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));"}, {"sha": "58a242c53ec1f838140040c022b9c2e32f14491d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -265,7 +265,7 @@ pub fn trans_lit_str(bcx: @mut Block,\n         Ignore => bcx,\n         SaveIn(lldest) => {\n             unsafe {\n-                let bytes = str_lit.len() + 1; // count null-terminator too\n+                let bytes = str_lit.len(); // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n@@ -363,7 +363,7 @@ pub fn write_content(bcx: @mut Block,\n                     return bcx;\n                 }\n                 SaveIn(lldest) => {\n-                    let bytes = s.len() + 1; // copy null-terminator too\n+                    let bytes = s.len();\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n                     let llcstr = C_cstr(bcx.ccx(), s);\n                     base::call_memcpy(bcx, lldest, llcstr, llbytes, 1);\n@@ -491,7 +491,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::expr) -> uint {\n \n     match content_expr.node {\n         ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n-            s.len() + 1\n+            s.len()\n         },\n         ast::expr_vec(ref es, _) => es.len(),\n         ast::expr_repeat(_, count_expr, _) => {\n@@ -524,7 +524,6 @@ pub fn get_base_and_len(bcx: @mut Block,\n     match vstore {\n         ty::vstore_fixed(n) => {\n             let base = GEPi(bcx, llval, [0u, 0u]);\n-            let n = if ty::type_is_str(vec_ty) { n + 1u } else { n };\n             let len = Mul(bcx, C_uint(ccx, n), vt.llunit_size);\n             (base, len)\n         }"}, {"sha": "ff9057afb55fc47dfb1b10f88d8b7b958d757f34", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -165,10 +165,20 @@ mod tests {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n             assert_eq!(~[76u8, 0u8], transmute(~\"L\"));\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[test]\n+    fn test_transmute2() {\n+        unsafe {\n+            assert_eq!(~[76u8], transmute(~\"L\"));\n+        }\n+    }\n+\n }"}, {"sha": "f0d4c3a737596f93857da3b6837f39011a9d3666", "filename": "src/libstd/io.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -1707,6 +1707,7 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     (*bytes).clone()\n }\n \n+#[cfg(stage0)]\n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n@@ -1719,6 +1720,11 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     }\n }\n \n+#[cfg(not(stage0))]\n+pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n+    str::from_bytes(with_bytes_writer(f))\n+}\n+\n // Utility functions\n pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {"}, {"sha": "d0f7f307088c4e6ca835e350d507cf4f161b7ce6", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -758,7 +758,8 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n \n             foreach pair in env.iter() {\n                 let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-                blk.push_all(kv.to_c_str().as_bytes());\n+                blk.push_all(kv.as_bytes());\n+                blk.push(0);\n             }\n \n             blk.push(0);"}, {"sha": "5796b541186e55cbf3401772e8d5505fcee124bf", "filename": "src/libstd/str.rs", "status": "modified", "additions": 374, "deletions": 10, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -33,6 +33,7 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n+#[cfg(stage0)]\n use unstable::raw::Repr;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n@@ -91,6 +92,7 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n+#[cfg(stage0)]\n pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     unsafe {\n         assert!(is_utf8(vector));\n@@ -100,6 +102,20 @@ pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n     }\n }\n \n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// returned as a '&str' instead of a '&[u8]'\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n+#[cfg(not(stage0))]\n+pub fn from_bytes_slice<'a>(v: &'a [u8]) -> &'a str {\n+    assert!(is_utf8(v));\n+    unsafe { cast::transmute(v) }\n+}\n+\n impl ToStr for ~str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n@@ -118,11 +134,23 @@ impl ToStr for @str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n+#[cfg(stage0)]\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n     unsafe { cast::transmute(~[b, 0u8]) }\n }\n \n+/// Convert a byte to a UTF-8 string\n+///\n+/// # Failure\n+///\n+/// Fails if invalid UTF-8\n+#[cfg(not(stage0))]\n+pub fn from_byte(b: u8) -> ~str {\n+    assert!(b < 128u8);\n+    unsafe { ::cast::transmute(~[b]) }\n+}\n+\n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n@@ -153,6 +181,7 @@ pub trait StrVector {\n \n impl<'self, S: Str> StrVector for &'self [S] {\n     /// Concatenate a vector of strings.\n+    #[cfg(stage0)]\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -176,7 +205,32 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s\n     }\n \n+    /// Concatenate a vector of strings.\n+    #[cfg(not(stage0))]\n+    pub fn concat(&self) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n+\n+        let mut s = with_capacity(len);\n+\n+        unsafe {\n+            do s.as_mut_buf |buf, _| {\n+                let mut buf = buf;\n+                foreach ss in self.iter() {\n+                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n+                        ptr::copy_memory(buf, ssbuf, sslen);\n+                        buf = buf.offset(sslen as int);\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n+    }\n+\n     /// Concatenate a vector of strings, placing a given separator between each.\n+    #[cfg(stage0)]\n     pub fn connect(&self, sep: &str) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -215,6 +269,45 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         }\n         s\n     }\n+\n+    /// Concatenate a vector of strings, placing a given separator between each.\n+    #[cfg(not(stage0))]\n+    pub fn connect(&self, sep: &str) -> ~str {\n+        if self.is_empty() { return ~\"\"; }\n+\n+        // concat is faster\n+        if sep.is_empty() { return self.concat(); }\n+\n+        // this is wrong without the guarantee that `self` is non-empty\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().transform(|s| s.as_slice().len()).sum();\n+        let mut s = ~\"\";\n+        let mut first = true;\n+\n+        s.reserve(len);\n+\n+        unsafe {\n+            do s.as_mut_buf |buf, _| {\n+                do sep.as_imm_buf |sepbuf, seplen| {\n+                    let mut buf = buf;\n+                    foreach ss in self.iter() {\n+                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n+                            if first {\n+                                first = false;\n+                            } else {\n+                                ptr::copy_memory(buf, sepbuf, seplen);\n+                                buf = buf.offset(seplen as int);\n+                            }\n+                            ptr::copy_memory(buf, ssbuf, sslen);\n+                            buf = buf.offset(sslen as int);\n+                        }\n+                    }\n+                }\n+            }\n+            raw::set_len(&mut s, len);\n+        }\n+        s\n+    }\n }\n \n /// Something that can be used to compare against a character\n@@ -485,7 +578,7 @@ Section: Comparing strings\n */\n \n /// Bytewise slice equality\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n@@ -503,7 +596,28 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n     }\n }\n \n-#[cfg(test)]\n+/// Bytewise slice equality\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"str_eq\"]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n+            if (alen != blen) { false }\n+            else {\n+                unsafe {\n+                    libc::memcmp(ap as *libc::c_void,\n+                                 bp as *libc::c_void,\n+                                 alen as libc::size_t) == 0\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(test, stage0)]\n+#[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     do a.as_imm_buf |ap, alen| {\n@@ -520,6 +634,24 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n     }\n }\n \n+/// Bytewise slice equality\n+#[cfg(test, not(stage0))]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n+            if (alen != blen) { false }\n+            else {\n+                unsafe {\n+                    libc::memcmp(ap as *libc::c_void,\n+                                 bp as *libc::c_void,\n+                                 alen as libc::size_t) == 0\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Bytewise string equality\n #[cfg(not(test))]\n #[lang=\"uniq_str_eq\"]\n@@ -761,9 +893,12 @@ pub mod raw {\n     use str::is_utf8;\n     use vec;\n     use vec::MutableVector;\n-    use unstable::raw::{Slice, String};\n+    use unstable::raw::Slice;\n+    #[cfg(stage0)]\n+    use unstable::raw::String;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n+    #[cfg(stage0)]\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         v.as_mut_buf(|vbuf, _len| {\n@@ -776,6 +911,19 @@ pub mod raw {\n         cast::transmute(v)\n     }\n \n+    /// Create a Rust string from a *u8 buffer of the given length\n+    #[cfg(not(stage0))]\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n+        let mut v: ~[u8] = vec::with_capacity(len);\n+        do v.as_mut_buf |vbuf, _len| {\n+            ptr::copy_memory(vbuf, buf as *u8, len)\n+        };\n+        vec::raw::set_len(&mut v, len);\n+\n+        assert!(is_utf8(v));\n+        ::cast::transmute(v)\n+    }\n+\n     /// Create a Rust string from a null-terminated C string\n     pub unsafe fn from_c_str(buf: *libc::c_char) -> ~str {\n         let mut curr = buf;\n@@ -796,17 +944,27 @@ pub mod raw {\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n+    #[cfg(stage0)]\n     pub unsafe fn from_bytes_owned(mut v: ~[u8]) -> ~str {\n         v.push(0u8);\n         cast::transmute(v)\n     }\n \n+    /// Converts an owned vector of bytes to a new owned string. This assumes\n+    /// that the utf-8-ness of the vector has already been validated\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn from_bytes_owned(v: ~[u8]) -> ~str {\n+        cast::transmute(v)\n+    }\n+\n     /// Converts a byte to a string.\n     pub unsafe fn from_byte(u: u8) -> ~str { from_bytes([u]) }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n+    #[cfg(stage0)]\n     pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n         let mut curr = s;\n@@ -820,6 +978,23 @@ pub mod raw {\n         cast::transmute(v)\n     }\n \n+    /// Form a slice from a C string. Unsafe because the caller must ensure the\n+    /// C string has the static lifetime, or else the return value may be\n+    /// invalidated later.\n+    #[cfg(not(stage0))]\n+    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s;\n+        let mut len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len as int);\n+        }\n+        let v = Slice { data: s, len: len };\n+        assert!(is_utf8(::cast::transmute(v)));\n+        ::cast::transmute(v)\n+    }\n+\n     /// Takes a bytewise (not UTF-8) slice from a string.\n     ///\n     /// Returns the substring from [`begin`..`end`).\n@@ -828,6 +1003,7 @@ pub mod raw {\n     ///\n     /// If begin is greater than end.\n     /// If end is greater than the length of the string.\n+    #[cfg(stage0)]\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do s.as_imm_buf |sbuf, n| {\n@@ -841,6 +1017,28 @@ pub mod raw {\n         }\n     }\n \n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Failure\n+    ///\n+    /// If begin is greater than end.\n+    /// If end is greater than the length of the string.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n+        do s.as_imm_buf |sbuf, n| {\n+             assert!((begin <= end));\n+             assert!((end <= n));\n+\n+             cast::transmute(Slice {\n+                 data: ptr::offset(sbuf, begin as int),\n+                 len: end - begin,\n+             })\n+        }\n+    }\n+\n     /// Appends a byte to a string. (Not UTF-8 safe).\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n@@ -877,6 +1075,7 @@ pub mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n+    #[cfg(stage0)]\n     #[inline]\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **mut String = cast::transmute(v);\n@@ -886,6 +1085,23 @@ pub mod raw {\n         *null = 0u8;\n     }\n \n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifing its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n+        let v: &mut ~[u8] = cast::transmute(s);\n+        vec::raw::set_len(v, new_len)\n+    }\n+\n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifing its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n     #[test]\n     fn test_from_buf_len() {\n         unsafe {\n@@ -1081,10 +1297,17 @@ impl<'self> Str for @str {\n }\n \n impl<'self> Container for &'self str {\n+    #[cfg(stage0)]\n     #[inline]\n     fn len(&self) -> uint {\n         do self.as_imm_buf |_p, n| { n - 1u }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn len(&self) -> uint {\n+        do self.as_imm_buf |_p, n| { n }\n+    }\n }\n \n impl Container for ~str {\n@@ -1558,6 +1781,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Copy a slice into a new unique str\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_owned(&self) -> ~str {\n         do self.as_imm_buf |src, len| {\n@@ -1575,6 +1799,24 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Copy a slice into a new unique str\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_owned(&self) -> ~str {\n+        do self.as_imm_buf |src, len| {\n+            unsafe {\n+                let mut v = vec::with_capacity(len);\n+\n+                do v.as_mut_buf |dst, _| {\n+                    ptr::copy_memory(dst, src, len);\n+                }\n+                vec::raw::set_len(&mut v, len);\n+                ::cast::transmute(v)\n+            }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n@@ -1583,6 +1825,15 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { cast::transmute(v) }\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_managed(&self) -> @str {\n+        unsafe {\n+            let v: *&[u8] = cast::transmute(self);\n+            cast::transmute(at_vec::to_managed(*v))\n+        }\n+    }\n+\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n@@ -1723,6 +1974,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Work with the byte buffer of a string as a byte slice.\n     ///\n     /// The byte slice does not include the null terminator.\n+    #[cfg(stage0)]\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe {\n             let mut slice = self.repr();\n@@ -1731,6 +1983,14 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Work with the byte buffer of a string as a byte slice.\n+    ///\n+    /// The byte slice does not include the null terminator.\n+    #[cfg(not(stage0))]\n+    fn as_bytes(&self) -> &'self [u8] {\n+        unsafe { cast::transmute(*self) }\n+    }\n+\n     /// Returns the byte index of the first character of `self` that matches `search`\n     ///\n     /// # Return value\n@@ -1797,6 +2057,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n+    #[cfg(stage0)]\n     fn repeat(&self, nn: uint) -> ~str {\n         do self.as_imm_buf |buf, len| {\n             // ignore the NULL terminator\n@@ -1818,6 +2079,27 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /// Given a string, make a new string with repeated copies of it.\n+    #[cfg(not(stage0))]\n+    fn repeat(&self, nn: uint) -> ~str {\n+        do self.as_imm_buf |buf, len| {\n+            let mut ret = with_capacity(nn * len);\n+\n+            unsafe {\n+                do ret.as_mut_buf |rbuf, _len| {\n+                    let mut rbuf = rbuf;\n+\n+                    do nn.times {\n+                        ptr::copy_memory(rbuf, buf, len);\n+                        rbuf = rbuf.offset(len as int);\n+                    }\n+                }\n+                raw::set_len(&mut ret, nn * len);\n+            }\n+            ret\n+        }\n+    }\n+\n     /// Retrieves the first character from a string slice and returns\n     /// it. This does not allocate a new string; instead, it returns a\n     /// slice that point one character beyond the character that was\n@@ -1934,6 +2216,7 @@ pub trait OwnedStr {\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n+    #[cfg(stage0)]\n     fn to_bytes_with_null(self) -> ~[u8];\n \n     /// Work with the mutable byte buffer and length of a slice.\n@@ -2080,6 +2363,7 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n+    #[cfg(stage0)]\n     #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n@@ -2088,6 +2372,29 @@ impl OwnedStr for ~str {\n         }\n     }\n \n+    /// Reserves capacity for exactly `n` bytes in the given string, not including\n+    /// the null terminator.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    pub fn reserve(&mut self, n: uint) {\n+        unsafe {\n+            let v: &mut ~[u8] = cast::transmute(self);\n+            (*v).reserve(n);\n+        }\n+    }\n+\n     /// Reserves capacity for at least `n` bytes in the given string, not including\n     /// the null terminator.\n     ///\n@@ -2106,22 +2413,58 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n+    #[cfg(stage0)]\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n     }\n \n+    /// Reserves capacity for at least `n` bytes in the given string.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`. To account for the null terminator,\n+    /// the underlying buffer will have the size `n` + 1.\n+    ///\n+    /// This function will over-allocate in order to amortize the allocation costs\n+    /// in scenarios where the caller may need to repeatedly reserve additional\n+    /// space.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn reserve_at_least(&mut self, n: uint) {\n+        self.reserve(uint::next_power_of_two(n))\n+    }\n+\n     /// Returns the number of single-byte characters the string can hold without\n     /// reallocating\n+    #[cfg(stage0)]\n     fn capacity(&self) -> uint {\n         let buf: &~[u8] = unsafe { cast::transmute(self) };\n         let vcap = buf.capacity();\n         assert!(vcap > 0u);\n         vcap - 1u\n     }\n \n+    /// Returns the number of single-byte characters the string can hold without\n+    /// reallocating\n+    #[cfg(not(stage0))]\n+    fn capacity(&self) -> uint {\n+        unsafe {\n+            let buf: &~[u8] = cast::transmute(self);\n+            buf.capacity()\n+        }\n+    }\n+\n     /// Convert to a vector of bytes. This does not allocate a new\n     /// string, and includes the null terminator.\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_bytes_with_null(self) -> ~[u8] {\n         unsafe { cast::transmute(self) }\n@@ -2817,6 +3160,31 @@ mod tests {\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n     }\n \n+    #[cfg(stage0)]\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_as_bytes_fail() {\n+        // Don't double free. (I'm not sure if this exercises the\n+        // original problem code path anymore.)\n+        let s = ~\"\";\n+        let _bytes = s.as_bytes();\n+        fail!();\n+    }\n+\n+    #[cfg(stage0)]\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_as_bytes_fail() {\n+        // Don't double free. (I'm not sure if this exercises the\n+        // original problem code path anymore.)\n+        let s = ~\"\";\n+        let _bytes = s.as_bytes_with_null();\n+        fail!();\n+    }\n+\n+    #[cfg(stage0)]\n     #[test]\n     fn test_to_bytes_with_null() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -2844,22 +3212,18 @@ mod tests {\n \n     #[test]\n     fn test_as_imm_buf() {\n-        do \"\".as_imm_buf |buf, len| {\n-            assert_eq!(len, 1);\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 0);\n-            }\n+        do \"\".as_imm_buf |_, len| {\n+            assert_eq!(len, 0);\n         }\n \n         do \"hello\".as_imm_buf |buf, len| {\n-            assert_eq!(len, 6);\n+            assert_eq!(len, 5);\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n                 assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n-                assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n         }\n     }"}, {"sha": "f1ffa1b3bce16c5ca7ddd35e1b62eedb24b15d23", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -15,7 +15,9 @@ use str;\n use str::StrSlice;\n use cast;\n use iterator::{Iterator, IteratorUtil};\n-use vec::{CopyableVector, ImmutableVector, OwnedVector};\n+use vec::{CopyableVector, ImmutableVector};\n+#[cfg(stage0)]\n+use vec::OwnedVector;\n use to_bytes::IterBytes;\n use option::{Some, None};\n \n@@ -101,19 +103,26 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n     }\n }\n \n-impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n+impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n     #[inline]\n-    fn to_ascii(&self) -> &'self[Ascii] {\n+    fn to_ascii(&self) -> &'self [Ascii] {\n         assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n+        unsafe { self.to_ascii_nocheck() }\n     }\n \n+    #[cfg(stage0)]\n     #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n+    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n         let (p,len): (*u8, uint) = cast::transmute(*self);\n         cast::transmute((p, len - 1))\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n+        cast::transmute(*self)\n+    }\n+\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.byte_iter().all(|b| b.is_ascii())\n@@ -186,12 +195,19 @@ impl OwnedAsciiCast for ~str {\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n+    #[cfg(stage0)]\n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n         let mut r: ~[Ascii] = cast::transmute(self);\n         r.pop();\n         r\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n+        cast::transmute(self)\n+    }\n }\n \n /// Trait for converting an ascii type to a string. Needed to convert `&[Ascii]` to `~str`\n@@ -210,11 +226,19 @@ pub trait AsciiStr {\n }\n \n impl<'self> AsciiStr for &'self [Ascii] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_str_ascii(&self) -> ~str {\n         let mut cpy = self.to_owned();\n         cpy.push(0u8.to_ascii());\n-        unsafe {cast::transmute(cpy)}\n+        unsafe { cast::transmute(cpy) }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn to_str_ascii(&self) -> ~str {\n+        let cpy = self.to_owned();\n+        unsafe { cast::transmute(cpy) }\n     }\n \n     #[inline]\n@@ -234,11 +258,18 @@ impl<'self> AsciiStr for &'self [Ascii] {\n }\n \n impl ToStrConsume for ~[Ascii] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn into_str(self) -> ~str {\n         let mut cpy = self;\n         cpy.push(0u8.to_ascii());\n-        unsafe {cast::transmute(cpy)}\n+        unsafe { cast::transmute(cpy) }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn into_str(self) -> ~str {\n+        unsafe { cast::transmute(self) }\n     }\n }\n \n@@ -257,7 +288,7 @@ pub trait ToBytesConsume {\n \n impl ToBytesConsume for ~[Ascii] {\n     fn into_bytes(self) -> ~[u8] {\n-        unsafe {cast::transmute(self)}\n+        unsafe { cast::transmute(self) }\n     }\n }\n "}, {"sha": "a08851df626c6240276029684a09f82dbe47b2db", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -549,12 +549,14 @@ pub mod rt {\n         // For strings, precision is the maximum characters\n         // displayed\n         let unpadded = match cv.precision {\n-          CountImplied => s,\n-          CountIs(max) => if (max as uint) < s.char_len() {\n-            s.slice(0, max as uint)\n-          } else {\n-            s\n-          }\n+            CountImplied => s,\n+            CountIs(max) => {\n+                if (max as uint) < s.char_len() {\n+                    s.slice(0, max as uint)\n+                } else {\n+                    s\n+                }\n+            }\n         };\n         pad(cv, unpadded, None, PadNozero, buf);\n     }"}, {"sha": "dffa7232e348770fa7c5119e07a63bbd02c2f29d", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5865a7597b060e81a6540b5d205b4a7d45a9b328/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5865a7597b060e81a6540b5d205b4a7d45a9b328", "patch": "@@ -302,10 +302,9 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n \n     if (zone != NULL) {\n         size_t size = strlen(zone);\n-        reserve_vec_exact(&out_tm->tm_zone, size + 1);\n+        reserve_vec_exact(&out_tm->tm_zone, size);\n         memcpy(out_tm->tm_zone->data, zone, size);\n-        out_tm->tm_zone->fill = size + 1;\n-        out_tm->tm_zone->data[size] = '\\0';\n+        out_tm->tm_zone->fill = size;\n     }\n }\n "}]}