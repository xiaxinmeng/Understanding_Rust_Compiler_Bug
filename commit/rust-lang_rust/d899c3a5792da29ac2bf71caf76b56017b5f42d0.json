{"sha": "d899c3a5792da29ac2bf71caf76b56017b5f42d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4OTljM2E1NzkyZGEyOWFjMmJmNzFjYWY3NmI1NjAxN2I1ZjQyZDA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-14T22:48:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-05-14T22:49:10Z"}, "message": "More work on reflection, now calls iface visitors back as well.", "tree": {"sha": "72b8d3b2b766b9637e3682d1cc8a40a7a7db9efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72b8d3b2b766b9637e3682d1cc8a40a7a7db9efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d899c3a5792da29ac2bf71caf76b56017b5f42d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d899c3a5792da29ac2bf71caf76b56017b5f42d0", "html_url": "https://github.com/rust-lang/rust/commit/d899c3a5792da29ac2bf71caf76b56017b5f42d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d899c3a5792da29ac2bf71caf76b56017b5f42d0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5428a22b95ccd8c84a402e2f5cb4aa53ddc6f4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5428a22b95ccd8c84a402e2f5cb4aa53ddc6f4d4", "html_url": "https://github.com/rust-lang/rust/commit/5428a22b95ccd8c84a402e2f5cb4aa53ddc6f4d4"}], "stats": {"total": 328, "additions": 166, "deletions": 162}, "files": [{"sha": "4b4dbe987697079a7766c12c839af2df4b1f1a8e", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=d899c3a5792da29ac2bf71caf76b56017b5f42d0", "patch": "@@ -64,24 +64,13 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         }\n       }\n       typeck::method_iface(_, off) {\n-        trans_iface_callee(bcx, self, callee_id, off)\n+        let {bcx, val} = trans_temp_expr(bcx, self);\n+        let fty = node_id_type(bcx, callee_id);\n+        trans_iface_callee(bcx, val, fty, off)\n       }\n     }\n }\n \n-fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n-                       callee_id: ast::node_id, n_method: uint)\n-    -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_vtable_callee\");\n-    let bcx = bcx, ccx = bcx.ccx();\n-    let fty = node_id_type(bcx, callee_id);\n-    let llfty = type_of::type_of_fn_from_ty(ccx, fty);\n-    let vtable = PointerCast(bcx, vtable,\n-                             T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n-    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n-    {bcx: bcx, val: mptr, kind: owned, env: env}\n-}\n-\n fn method_from_methods(ms: [@ast::method], name: ast::ident) -> ast::def_id {\n   local_def(option::get(vec::find(ms, {|m| m.ident == name})).id)\n }\n@@ -139,7 +128,9 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n          with lval}\n       }\n       typeck::vtable_iface(iid, tps) {\n-        trans_iface_callee(bcx, base, callee_id, n_method)\n+        let {bcx, val} = trans_temp_expr(bcx, base);\n+        let fty = node_id_type(bcx, callee_id);\n+        trans_iface_callee(bcx, val, fty, n_method)\n       }\n       typeck::vtable_param(n_param, n_bound) {\n         fail \"vtable_param left in monomorphized function's vtable substs\";\n@@ -148,18 +139,22 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n }\n \n // Method callee where the vtable comes from a boxed iface\n-fn trans_iface_callee(bcx: block, base: @ast::expr,\n-                      callee_id: ast::node_id, n_method: uint)\n+fn trans_iface_callee(bcx: block, val: ValueRef,\n+                      callee_ty: ty::t, n_method: uint)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_iface_callee\");\n-    let {bcx, val} = trans_temp_expr(bcx, base);\n+    let ccx = bcx.ccx();\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]),\n-                                     T_ptr(T_ptr(T_vtable()))));\n+                                       T_ptr(T_ptr(T_vtable()))));\n     let box = Load(bcx, GEPi(bcx, val, [0u, 1u]));\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = GEPi(bcx, box, [0u, abi::box_field_body]);\n     let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(box));\n-    trans_vtable_callee(bcx, env, vtable, callee_id, n_method)\n+    let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n+    let vtable = PointerCast(bcx, vtable,\n+                             T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n+    {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)"}, {"sha": "f5b1a59d15fac3fc86a1c1115d7f5985f4196f64", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=d899c3a5792da29ac2bf71caf76b56017b5f42d0", "patch": "@@ -10,7 +10,7 @@ import lib::llvm::{ llvm, TypeRef, ValueRef,\n                     StructRetAttribute, ByValAttribute\n                   };\n import syntax::{ast, ast_util};\n-import back::link;\n+import back::{link, abi};\n import common::*;\n import build::*;\n import base::*;\n@@ -842,63 +842,65 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n         let vp_ty = substs.tys[1];\n         let visitor = get_param(decl, first_real_arg);\n \n-        // We're going to synthesize a monomorphized vtbl call here much\n-        // like what impl::trans_monomorphized_callee does, but without\n-        // having quite as much source machinery to go on.\n+        let (tyname, args) = alt ty::get(tp_ty).struct {\n+          ty::ty_bot { (\"bot\", []) }\n+          ty::ty_nil { (\"nil\", []) }\n+          ty::ty_bool { (\"bool\", []) }\n+          ty::ty_int(ast::ty_i) { (\"int\", []) }\n+          ty::ty_int(ast::ty_char) { (\"char\", []) }\n+          ty::ty_int(ast::ty_i8) { (\"i8\", []) }\n+          ty::ty_int(ast::ty_i16) { (\"i16\", []) }\n+          ty::ty_int(ast::ty_i32) { (\"i32\", []) }\n+          ty::ty_int(ast::ty_i64) { (\"i64\", []) }\n+          ty::ty_uint(ast::ty_u) { (\"uint\", []) }\n+          ty::ty_uint(ast::ty_u8) { (\"u8\", []) }\n+          ty::ty_uint(ast::ty_u16) { (\"u16\", []) }\n+          ty::ty_uint(ast::ty_u32) { (\"u32\", []) }\n+          ty::ty_uint(ast::ty_u64) { (\"u64\", []) }\n+          ty::ty_float(ast::ty_f) { (\"float\", []) }\n+          ty::ty_float(ast::ty_f32) { (\"f32\", []) }\n+          ty::ty_float(ast::ty_f64) { (\"f64\", []) }\n+          ty::ty_str { (\"str\", []) }\n+          _ {\n+            bcx.sess().unimpl(\"trans::native::visit_ty on \"\n+                              + ty_to_str(ccx.tcx, tp_ty));\n+          }\n+        };\n+\n+        let mth_name = \"visit_\" + tyname;\n+        let dest = ignore;\n \n         alt impl::find_vtable_in_fn_ctxt(substs,\n                                          1u, /* n_param */\n                                          0u  /* n_bound */ ) {\n \n           typeck::vtable_static(impl_did, impl_substs, sub_origins) {\n-\n-            let (tyname, args) = alt ty::get(tp_ty).struct {\n-              ty::ty_bot { (\"bot\", []) }\n-              ty::ty_nil { (\"nil\", []) }\n-              ty::ty_bool { (\"bool\", []) }\n-              ty::ty_int(ast::ty_i) { (\"int\", []) }\n-              ty::ty_int(ast::ty_char) { (\"char\", []) }\n-              ty::ty_int(ast::ty_i8) { (\"i8\", []) }\n-              ty::ty_int(ast::ty_i16) { (\"i16\", []) }\n-              ty::ty_int(ast::ty_i32) { (\"i32\", []) }\n-              ty::ty_int(ast::ty_i64) { (\"i64\", []) }\n-              ty::ty_uint(ast::ty_u) { (\"uint\", []) }\n-              ty::ty_uint(ast::ty_u8) { (\"u8\", []) }\n-              ty::ty_uint(ast::ty_u16) { (\"u16\", []) }\n-              ty::ty_uint(ast::ty_u32) { (\"u32\", []) }\n-              ty::ty_uint(ast::ty_u64) { (\"u64\", []) }\n-              ty::ty_float(ast::ty_f) { (\"float\", []) }\n-              ty::ty_float(ast::ty_f32) { (\"f32\", []) }\n-              ty::ty_float(ast::ty_f64) { (\"f64\", []) }\n-              ty::ty_str { (\"str\", []) }\n-              _ {\n-                bcx.sess().unimpl(\"trans::native::visit_ty on \"\n-                                  + ty_to_str(ccx.tcx, tp_ty));\n-              }\n-            };\n-\n-            let mth_id = impl::method_with_name(ccx, impl_did,\n-                                                \"visit_\" + tyname);\n+            let mth_id = impl::method_with_name(ccx, impl_did, mth_name);\n             let mth_ty = ty::lookup_item_type(ccx.tcx, mth_id).ty;\n-\n             // FIXME: is this safe? There is no callee AST node,\n             // we're synthesizing it.\n             let callee_id = (-1) as ast::node_id;\n+            let get_lval = {|bcx|\n+                let lval = lval_static_fn_inner(bcx, mth_id, callee_id,\n+                                                impl_substs,\n+                                                some(sub_origins));\n+                {env: self_env(visitor, vp_ty, none) with lval}\n+            };\n+            bcx = trans_call_inner(bcx, mth_ty, ty::mk_bool(ccx.tcx),\n+                                   get_lval, arg_vals(args), dest);\n+          }\n \n-            let dest = ignore;\n-\n-            bcx = trans_call_inner(bcx,\n-                                   mth_ty,\n-                                   ty::mk_nil(ccx.tcx),\n-                                   {|bcx|\n-                                       let lval =\n-                                           lval_static_fn_inner\n-                                           (bcx, mth_id, callee_id,\n-                                            impl_substs,  some(sub_origins));\n-                                       {env: self_env(visitor, vp_ty, none)\n-                                        with lval}\n-                                   }, arg_vals(args), dest);\n+          typeck::vtable_iface(iid, _tps) {\n+            let methods = ty::iface_methods(ccx.tcx, iid);\n+            let mth_idx = option::get(ty::method_idx(mth_name, *methods));\n+            let mth_ty = ty::mk_fn(ccx.tcx, methods[mth_idx].fty);\n+            let get_lval = {|bcx|\n+                impl::trans_iface_callee(bcx, visitor, mth_ty, mth_idx)\n+            };\n+            bcx = trans_call_inner(bcx, mth_ty, ty::mk_bool(ccx.tcx),\n+                                   get_lval, arg_vals(args), dest);\n           }\n+\n           _ {\n             ccx.sess.span_bug(item.span,\n                               \"non-static callee in 'visit_ty' intrinsinc\");"}, {"sha": "66a7f109d215b5dcf3f529372f28c09cf1aea4e3", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 103, "deletions": 96, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d899c3a5792da29ac2bf71caf76b56017b5f42d0/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=d899c3a5792da29ac2bf71caf76b56017b5f42d0", "patch": "@@ -7,114 +7,119 @@\n //\n \n iface ty_visitor {\n-    fn visit_bot();\n-    fn visit_nil();\n-    fn visit_bool();\n-\n-    fn visit_int();\n-    fn visit_i8();\n-    fn visit_i16();\n-    fn visit_i32();\n-    fn visit_i64();\n-\n-    fn visit_uint();\n-    fn visit_u8();\n-    fn visit_u16();\n-    fn visit_u32();\n-    fn visit_u64();\n-\n-    fn visit_float();\n-    fn visit_f32();\n-    fn visit_f64();\n-\n-    fn visit_char();\n-    fn visit_str();\n-\n-    fn visit_vec(cells_mut: bool,\n-                 visit_cell: fn(uint, self));\n-\n-    fn visit_box(inner_mut: bool,\n-                 visit_inner: fn(self));\n-\n-    fn visit_uniq(inner_mut: bool,\n-                  visit_inner: fn(self));\n-\n-    fn visit_ptr(inner_mut: bool,\n-                 visit_inner: fn(self));\n-\n-    fn visit_rptr(inner_mut: bool,\n-                  visit_inner: fn(self));\n-\n-    fn visit_rec(n_fields: uint,\n-                 field_name: fn(uint) -> str/&,\n-                 field_mut: fn(uint) -> bool,\n-                 visit_field: fn(uint, self));\n-    fn visit_tup(n_fields: uint,\n-                 visit_field: fn(uint, self));\n-    fn visit_enum(n_variants: uint,\n-                  variant: uint,\n-                  variant_name: fn(uint) -> str/&,\n-                  visit_variant: fn(uint, self));\n+    fn visit_bot() -> bool;\n+    fn visit_nil() -> bool;\n+    fn visit_bool() -> bool;\n+\n+    fn visit_int() -> bool;\n+    fn visit_i8() -> bool;\n+    fn visit_i16() -> bool;\n+    fn visit_i32() -> bool;\n+    fn visit_i64() -> bool;\n+\n+    fn visit_uint() -> bool;\n+    fn visit_u8() -> bool;\n+    fn visit_u16() -> bool;\n+    fn visit_u32() -> bool;\n+    fn visit_u64() -> bool;\n+\n+    fn visit_float() -> bool;\n+    fn visit_f32() -> bool;\n+    fn visit_f64() -> bool;\n+\n+    fn visit_char() -> bool;\n+    fn visit_str() -> bool;\n+\n+    // FIXME: possibly pair these as enter/leave calls\n+    // not just enter with implicit number of subsequent\n+    // calls.\n+    fn visit_vec_of(is_mut: bool) -> bool;\n+    fn visit_box_of(is_mut: bool) -> bool;\n+    fn visit_uniq_of(is_mut: bool) -> bool;\n+    fn visit_ptr_of(is_mut: bool) -> bool;\n+    fn visit_rptr_of(is_mut: bool) -> bool;\n+    fn visit_rec_of(n_fields: uint) -> bool;\n+    fn visit_rec_field(name: str/&, is_mut: bool) -> bool;\n+    fn visit_tup_of(n_fields: uint) -> bool;\n+    fn visit_tup_field(is_mut: bool) -> bool;\n+    fn visit_enum_of(n_variants: uint) -> bool;\n+    fn visit_enum_variant(name: str/&) -> bool;\n }\n \n enum my_visitor = { mut types: [str] };\n \n impl of ty_visitor for my_visitor {\n-    fn visit_bot() { self.types += [\"bot\"] }\n-    fn visit_nil() { self.types += [\"nil\"] }\n-    fn visit_bool() { self.types += [\"bool\"] }\n-\n-    fn visit_int() { self.types += [\"int\"] }\n-    fn visit_i8() { self.types += [\"i8\"] }\n-    fn visit_i16() { self.types += [\"i16\"] }\n-    fn visit_i32() { }\n-    fn visit_i64() { }\n-\n-    fn visit_uint() { }\n-    fn visit_u8() { }\n-    fn visit_u16() { }\n-    fn visit_u32() { }\n-    fn visit_u64() { }\n-\n-    fn visit_float() { }\n-    fn visit_f32() { }\n-    fn visit_f64() { }\n-\n-    fn visit_char() { }\n-    fn visit_str() { }\n-\n-    fn visit_vec(_cells_mut: bool,\n-                 _visit_cell: fn(uint, my_visitor)) { }\n-\n-    fn visit_box(_inner_mut: bool,\n-                 _visit_inner: fn(my_visitor)) { }\n-\n-    fn visit_uniq(_inner_mut: bool,\n-                  _visit_inner: fn(my_visitor)) { }\n-\n-    fn visit_ptr(_inner_mut: bool,\n-                 _visit_inner: fn(my_visitor)) { }\n-\n-    fn visit_rptr(_inner_mut: bool,\n-                  _visit_inner: fn(my_visitor)) { }\n-\n-    fn visit_rec(_n_fields: uint,\n-                 _field_name: fn(uint) -> str/&,\n-                 _field_mut: fn(uint) -> bool,\n-                 _visit_field: fn(uint, my_visitor)) { }\n-    fn visit_tup(_n_fields: uint,\n-                 _visit_field: fn(uint, my_visitor)) { }\n-    fn visit_enum(_n_variants: uint,\n-                  _variant: uint,\n-                  _variant_name: fn(uint) -> str/&,\n-                  _visit_variant: fn(uint, my_visitor)) { }\n+    fn visit_bot() -> bool {\n+        self.types += [\"bot\"];\n+        #error(\"visited bot type\");\n+        true\n+    }\n+    fn visit_nil() -> bool {\n+        self.types += [\"nil\"];\n+        #error(\"visited nil type\");\n+        true\n+    }\n+    fn visit_bool() -> bool {\n+        self.types += [\"bool\"];\n+        #error(\"visited bool type\");\n+        true\n+    }\n+    fn visit_int() -> bool {\n+        self.types += [\"int\"];\n+        #error(\"visited int type\");\n+        true\n+    }\n+    fn visit_i8() -> bool {\n+        self.types += [\"i8\"];\n+        #error(\"visited i8 type\");\n+        true\n+    }\n+    fn visit_i16() -> bool {\n+        self.types += [\"i16\"];\n+        #error(\"visited i16 type\");\n+        true\n+    }\n+    fn visit_i32() -> bool { true }\n+    fn visit_i64() -> bool { true }\n+\n+    fn visit_uint() -> bool { true }\n+    fn visit_u8() -> bool { true }\n+    fn visit_u16() -> bool { true }\n+    fn visit_u32() -> bool { true }\n+    fn visit_u64() -> bool { true }\n+\n+    fn visit_float() -> bool { true }\n+    fn visit_f32() -> bool { true }\n+    fn visit_f64() -> bool { true }\n+\n+    fn visit_char() -> bool { true }\n+    fn visit_str() -> bool { true }\n+\n+    fn visit_vec_of(_is_mut: bool) -> bool { true }\n+    fn visit_box_of(_is_mut: bool) -> bool { true }\n+    fn visit_uniq_of(_is_mut: bool) -> bool { true }\n+    fn visit_ptr_of(_is_mut: bool) -> bool { true }\n+    fn visit_rptr_of(_is_mut: bool) -> bool { true }\n+    fn visit_rec_of(_n_fields: uint) -> bool { true }\n+    fn visit_rec_field(_name: str/&, _is_mut: bool) -> bool { true }\n+    fn visit_tup_of(_n_fields: uint) -> bool { true }\n+    fn visit_tup_field(_is_mut: bool) -> bool { true }\n+    fn visit_enum_of(_n_variants: uint) -> bool { true }\n+    fn visit_enum_variant(_name: str/&) -> bool { true }\n }\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n     fn visit_ty<T,V:ty_visitor>(tv: V);\n }\n \n+fn via_iface(v: ty_visitor) {\n+    rusti::visit_ty::<bool,ty_visitor>(v);\n+    rusti::visit_ty::<int,ty_visitor>(v);\n+    rusti::visit_ty::<i8,ty_visitor>(v);\n+    rusti::visit_ty::<i16,ty_visitor>(v);\n+}\n+\n fn main() {\n     let v = my_visitor({mut types: []});\n \n@@ -127,4 +132,6 @@ fn main() {\n         io::println(#fmt(\"type: %s\", s));\n     }\n     assert v.types == [\"bool\", \"int\", \"i8\", \"i16\"];\n+\n+    via_iface(v as ty_visitor);\n }"}]}