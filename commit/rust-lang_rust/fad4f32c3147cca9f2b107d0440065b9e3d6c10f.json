{"sha": "fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDRmMzJjMzE0N2NjYTlmMmIxMDdkMDQ0MDA2NWI5ZTNkNmMxMGY=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-05T22:58:31Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-07T14:46:49Z"}, "message": "Turn on new errors, json mode. Remove duplicate unicode test", "tree": {"sha": "d37019a13a053ff6a7224a195f5237521646d6ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37019a13a053ff6a7224a195f5237521646d6ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "html_url": "https://github.com/rust-lang/rust/commit/fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/comments", "author": null, "committer": null, "parents": [{"sha": "42903d9a8f0f471f5e0eb453e49fe44a65a746c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/42903d9a8f0f471f5e0eb453e49fe44a65a746c5", "html_url": "https://github.com/rust-lang/rust/commit/42903d9a8f0f471f5e0eb453e49fe44a65a746c5"}], "stats": {"total": 624, "additions": 29, "deletions": 595}, "files": [{"sha": "3ad5ef1e0ff6d438720898027ddbed945692dcde", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -94,7 +94,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{self, Pos, Span};\n-use errors::{DiagnosticBuilder, check_old_school};\n+use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -541,25 +541,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let span = origin.span();\n \n-        let mut is_simple_error = false;\n-\n         if let Some((expected, found)) = expected_found {\n-            is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+            let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n                 values.expected.is_primitive() && values.found.is_primitive()\n             } else {\n                 false\n             };\n \n-            if !is_simple_error || check_old_school() {\n+            if !is_simple_error {\n                 diag.note_expected_found(&\"type\", &expected, &found);\n             }\n         }\n \n-        if !is_simple_error && check_old_school() {\n-            diag.span_note(span, &format!(\"{}\", terr));\n-        } else {\n-            diag.span_label(span, &terr);\n-        }\n+        diag.span_label(span, &terr);\n \n         self.note_error_origin(diag, &origin);\n         self.check_and_note_conflicting_crates(diag, terr, span);"}, {"sha": "b986b657ce20a047d4b019ce3855cd41bd764f2b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -1055,7 +1055,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                      \"NAME=PATH\"),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi_ubnr(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        opt::opt_ubnr(\"\", \"error-format\",\n+        opt::opt_s(\"\", \"error-format\",\n                       \"How errors and other messages are produced\",\n                       \"human|json\"),\n         opt::opt_s(\"\", \"color\", \"Configure coloring of output:"}, {"sha": "9ab75c8a5a20c8e17a9c47c3d5c70c18d779ccc0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -23,7 +23,6 @@ use mir::transform as mir_pass;\n use syntax::ast::{NodeId, Name};\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n-use errors::snippet::FormatMode;\n use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -369,9 +368,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n     let emitter: Box<Emitter> = match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           Some(registry),\n-                                           Some(codemap.clone()),\n-                                           errors::snippet::FormatMode::EnvironmentSelected))\n+                                           Some(codemap.clone())))\n         }\n         config::ErrorOutputType::Json => {\n             Box::new(JsonEmitter::stderr(Some(registry), codemap.clone()))\n@@ -509,9 +506,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           None,\n-                                           None,\n-                                           FormatMode::EnvironmentSelected))\n+                                           None))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n@@ -524,9 +519,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           None,\n-                                           None,\n-                                           FormatMode::EnvironmentSelected))\n+                                           None))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };"}, {"sha": "a1ff6da7e98ad23c46bbae482231b532a84366ca", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -44,7 +44,7 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n-use rustc_errors::{DiagnosticBuilder, check_old_school};\n+use rustc_errors::DiagnosticBuilder;\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -378,11 +378,7 @@ pub fn note_const_eval_err<'a, 'tcx>(\n {\n     match err.description() {\n         ConstEvalErrDescription::Simple(message) => {\n-            if check_old_school() {\n-                diag.note(&message);\n-            } else {\n-                diag.span_label(err.span, &message);\n-            }\n+            diag.span_label(err.span, &message);\n         }\n     }\n "}, {"sha": "80f1910906b4c99c72654862f5eaac0e6d4ed45b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -100,7 +100,6 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n-use errors::snippet::FormatMode;\n \n #[cfg(test)]\n pub mod test;\n@@ -141,9 +140,7 @@ pub fn run(args: Vec<String>) -> isize {\n                     None => {\n                         let emitter =\n                             errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                   None,\n-                                                                   None,\n-                                                                   FormatMode::EnvironmentSelected);\n+                                                                   None);\n                         let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                         handler.emit(&MultiSpan::new(),\n                                      &abort_msg(err_count),\n@@ -381,10 +378,7 @@ fn check_cfg(sopts: &config::Options,\n              output: ErrorOutputType) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::EmitterWriter::stderr(color_config,\n-                                                            None,\n-                                                            None,\n-                                                            FormatMode::EnvironmentSelected))\n+            Box::new(errors::emitter::EmitterWriter::stderr(color_config, None))\n         }\n         config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n     };\n@@ -1050,10 +1044,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         // Thread panicked without emitting a fatal diagnostic\n         if !value.is::<errors::FatalError>() {\n             let emitter =\n-                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                       None,\n-                                                       None,\n-                                                       FormatMode::EnvironmentSelected));\n+                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None));\n             let handler = errors::Handler::with_emitter(true, false, emitter);\n \n             // a .span_bug or .bug call has already printed what"}, {"sha": "981729ddb839581ceecabe70f30093b388313de1", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 280, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -10,16 +10,13 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n-use registry;\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n-use check_old_school;\n use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n-use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n+use snippet::{StyledString, Style, Annotation, Line};\n use styled_buffer::StyledBuffer;\n \n-use std::cmp;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -33,18 +30,7 @@ pub trait Emitter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self, db: &DiagnosticBuilder) {\n-        // Pick old school mode either from env or let the test dictate the format\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_school()\n-        };\n-\n-        if old_school {\n-            self.emit_messages_old_school(db);\n-        } else {\n-            self.emit_messages_default(db);\n-        }\n+        self.emit_messages_default(db);\n     }\n }\n \n@@ -70,11 +56,7 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    registry: Option<registry::Registry>,\n     cm: Option<Rc<CodeMapper>>,\n-\n-    // For now, allow an old-school mode while we transition\n-    format_mode: FormatMode\n }\n \n struct FileWithAnnotatedLines {\n@@ -99,33 +81,23 @@ macro_rules! println_maybe_styled {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<registry::Registry>,\n-                  code_map: Option<Rc<CodeMapper>>,\n-                  format_mode: FormatMode)\n+                  code_map: Option<Rc<CodeMapper>>)\n                   -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter { dst: dst,\n-                            registry: registry,\n-                            cm: code_map,\n-                            format_mode: format_mode.clone() }\n+                            cm: code_map}\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n-                            registry: registry,\n-                            cm: code_map,\n-                            format_mode: format_mode.clone() }\n+                            cm: code_map}\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               registry: Option<registry::Registry>,\n-               code_map: Option<Rc<CodeMapper>>,\n-               format_mode: FormatMode)\n+               code_map: Option<Rc<CodeMapper>>)\n                -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst),\n-                        registry: registry,\n-                        cm: code_map,\n-                        format_mode: format_mode.clone() }\n+                        cm: code_map}\n     }\n \n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n@@ -668,240 +640,6 @@ impl EmitterWriter {\n             _ => ()\n         }\n     }\n-    fn emit_message_old_school(&mut self,\n-                               msp: &MultiSpan,\n-                               msg: &str,\n-                               code: &Option<String>,\n-                               level: &Level,\n-                               show_snippet: bool)\n-                               -> io::Result<()> {\n-        let mut buffer = StyledBuffer::new();\n-\n-        let loc = match msp.primary_span() {\n-            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-            Some(ps) => if let Some(ref cm) = self.cm {\n-                cm.span_to_string(ps)\n-            } else {\n-                \"\".to_string()\n-            },\n-            None => {\n-                \"\".to_string()\n-            }\n-        };\n-        if loc != \"\" {\n-            buffer.append(0, &loc, Style::NoStyle);\n-            buffer.append(0, \" \", Style::NoStyle);\n-        }\n-        buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-        buffer.append(0, \": \", Style::HeaderMsg);\n-        buffer.append(0, msg, Style::HeaderMsg);\n-        buffer.append(0, \" \", Style::NoStyle);\n-        match code {\n-            &Some(ref code) => {\n-                buffer.append(0, \"[\", Style::ErrorCode);\n-                buffer.append(0, &code, Style::ErrorCode);\n-                buffer.append(0, \"]\", Style::ErrorCode);\n-            }\n-            _ => {}\n-        }\n-\n-        if !show_snippet {\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-            return Ok(());\n-        }\n-\n-        // Watch out for various nasty special spans; don't try to\n-        // print any filename or anything for those.\n-        match msp.primary_span() {\n-            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-                return Ok(());\n-            }\n-            _ => { }\n-        }\n-\n-        let annotated_files = self.preprocess_annotations(msp);\n-\n-        if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n-            (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n-\n-            // Next, print the source line and its squiggle\n-            // for old school mode, we will render them to the buffer, then insert the file loc\n-            // (or space the same amount) in front of the line and the squiggle\n-            let source_string = ann_file.file.get_line(ann_file.lines[0].line_index - 1)\n-                .unwrap_or(\"\");\n-\n-            let line_offset = buffer.num_lines();\n-\n-            let lo = cm.lookup_char_pos(primary_span.lo);\n-            //Before each secondary line in old skool-mode, print the label\n-            //as an old-style note\n-            let file_pos = format!(\"{}:{} \", lo.file.name.clone(), lo.line);\n-            let file_pos_len = file_pos.len();\n-\n-            // First create the source line we will highlight.\n-            buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n-            buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n-            // Sort the annotations by (start, end col)\n-            let annotations = ann_file.lines[0].annotations.clone();\n-\n-            // Next, create the highlight line.\n-            for annotation in &annotations {\n-                for p in annotation.start_col..annotation.end_col {\n-                    if p == annotation.start_col {\n-                        buffer.putc(line_offset + 1,\n-                                    file_pos_len + p,\n-                                    '^',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n-                    } else {\n-                        buffer.putc(line_offset + 1,\n-                                    file_pos_len + p,\n-                                    '~',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n-                    }\n-                }\n-            }\n-        }\n-        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n-            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n-        }\n-\n-        match code {\n-            &Some(ref code) if self.registry.as_ref()\n-                                           .and_then(|registry| registry.find_description(code))\n-                                           .is_some() => {\n-                let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n-                    \"` to see a detailed explanation\";\n-\n-                let line_offset = buffer.num_lines();\n-                buffer.append(line_offset, &loc, Style::NoStyle);\n-                buffer.append(line_offset, \" \", Style::NoStyle);\n-                buffer.append(line_offset, &Level::Help.to_string(), Style::Level(Level::Help));\n-                buffer.append(line_offset, \": \", Style::HeaderMsg);\n-                buffer.append(line_offset, &msg, Style::HeaderMsg);\n-            }\n-            _ => ()\n-        }\n-\n-        // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-        Ok(())\n-    }\n-    fn emit_suggestion_old_school(&mut self,\n-                                  suggestion: &CodeSuggestion,\n-                                  level: &Level,\n-                                  msg: &str)\n-                                  -> io::Result<()> {\n-        use std::borrow::Borrow;\n-\n-        let primary_span = suggestion.msp.primary_span().unwrap();\n-        if let Some(ref cm) = self.cm {\n-            let mut buffer = StyledBuffer::new();\n-\n-            let loc = cm.span_to_string(primary_span);\n-\n-            if loc != \"\" {\n-                buffer.append(0, &loc, Style::NoStyle);\n-                buffer.append(0, \" \", Style::NoStyle);\n-            }\n-\n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-            buffer.append(0, msg, Style::HeaderMsg);\n-\n-            let lines = cm.span_to_lines(primary_span).unwrap();\n-\n-            assert!(!lines.lines.is_empty());\n-\n-            let complete = suggestion.splice_lines(cm.borrow());\n-            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-            let display_lines = &lines.lines[..line_count];\n-\n-            let fm = &*lines.file;\n-            // Calculate the widest number to format evenly\n-            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n-\n-            // print the suggestion without any line numbers, but leave\n-            // space for them. This helps with lining up with previous\n-            // snippets from the actual error being reported.\n-            let mut lines = complete.lines();\n-            let mut row_num = 1;\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                buffer.append(row_num, &fm.name, Style::FileNameStyle);\n-                for _ in 0..max_digits+2 {\n-                    buffer.append(row_num, &\" \", Style::NoStyle);\n-                }\n-                buffer.append(row_num, line, Style::NoStyle);\n-                row_num += 1;\n-            }\n-\n-            // if we elided some lines, add an ellipsis\n-            if let Some(_) = lines.next() {\n-                buffer.append(row_num, \"...\", Style::NoStyle);\n-            }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_messages_old_school(&mut self, db: &DiagnosticBuilder) {\n-        match self.emit_message_old_school(&db.span,\n-                                           &db.message,\n-                                           &db.code,\n-                                           &db.level,\n-                                           true) {\n-            Ok(()) => {\n-                for child in &db.children {\n-                    let (span, show_snippet) = if child.span.primary_spans().is_empty() {\n-                        (db.span.clone(), false)\n-                    } else {\n-                        (child.span.clone(), true)\n-                    };\n-\n-                    match child.render_span {\n-                        Some(FullSpan(_)) => {\n-                            match self.emit_message_old_school(&span,\n-                                                               &child.message,\n-                                                               &None,\n-                                                               &child.level,\n-                                                               show_snippet) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        },\n-                        Some(Suggestion(ref cs)) => {\n-                            match self.emit_suggestion_old_school(cs,\n-                                                                  &child.level,\n-                                                                  &child.message) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        },\n-                        None => {\n-                            match self.emit_message_old_school(&span,\n-                                                               &child.message,\n-                                                               &None,\n-                                                               &child.level,\n-                                                               show_snippet) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n-        }\n-    }\n-\n     fn render_macro_backtrace_old_school(&mut self,\n                                          sp: &Span,\n                                          buffer: &mut StyledBuffer) -> io::Result<()> {\n@@ -958,16 +696,6 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n     Ok(())\n }\n \n-fn line_num_max_digits(line: &LineInfo) -> usize {\n-    let mut max_line_num = line.line_index + 1;\n-    let mut digits = 0;\n-    while max_line_num > 0 {\n-        max_line_num /= 10;\n-        digits += 1;\n-    }\n-    digits\n-}\n-\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;"}, {"sha": "172e27d56d4852b83bb80be3e0ff00112a0c1500", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -420,13 +420,11 @@ pub struct Handler {\n \n impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n-                            registry: Option<registry::Registry>,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n                             cm: Option<Rc<CodeMapper>>)\n                             -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm,\n-                               snippet::FormatMode::EnvironmentSelected));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, cm));\n         Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n     }\n \n@@ -750,21 +748,4 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n         Some(t) => t,\n         None => diag.bug(&msg()),\n     }\n-}\n-\n-/// True if we should use the old-skool error format style. This is\n-/// the default setting until the new errors are deemed stable enough\n-/// for general use.\n-///\n-/// FIXME(#33240)\n-#[cfg(not(test))]\n-pub fn check_old_school() -> bool {\n-    use std::env;\n-    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n-}\n-\n-/// For unit tests, use the new format.\n-#[cfg(test)]\n-pub fn check_old_school() -> bool {\n-    false\n-}\n+}\n\\ No newline at end of file"}, {"sha": "5ade8cd9bad82be4f2c34b6ffe98fe5d7494e02c", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -15,18 +15,10 @@ use CodeMapper;\n use std::rc::Rc;\n use {Level};\n \n-#[derive(Clone)]\n-pub enum FormatMode {\n-    NewErrorFormat,\n-    OriginalErrorFormat,\n-    EnvironmentSelected\n-}\n-\n #[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMapper>,\n-    files: Vec<FileInfo>,\n-    format_mode: FormatMode,\n+    files: Vec<FileInfo>\n }\n \n #[derive(Clone)]\n@@ -41,10 +33,6 @@ pub struct FileInfo {\n     primary_span: Option<Span>,\n \n     lines: Vec<Line>,\n-\n-    /// The type of error format to render.  We keep it here so that\n-    /// it's easy to configure for both tests and regular usage\n-    format_mode: FormatMode,\n }\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]"}, {"sha": "7d8ebc403b08f1c5cc59f050a0df042ce42a5650", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -128,7 +128,6 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               None,\n                                                                true,\n                                                                false,\n                                                                Some(codemap.clone()));"}, {"sha": "5f1d28c8d316ad35014bd2f4a56f124449a6fdfc", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -74,7 +74,6 @@ pub fn run(input: &str,\n \n     let codemap = Rc::new(CodeMap::new());\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               None,\n                                                                true,\n                                                                false,\n                                                                Some(codemap.clone()));\n@@ -228,9 +227,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let codemap = Rc::new(CodeMap::new());\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                None,\n-                                                Some(codemap.clone()),\n-                                                errors::snippet::FormatMode::EnvironmentSelected);\n+                                                      Some(codemap.clone()));\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n "}, {"sha": "cd1fdcfe9d130ce94a4e428a9c6d1255222c8190", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -51,7 +51,6 @@ impl ParseSess {\n     pub fn new() -> ParseSess {\n         let cm = Rc::new(CodeMap::new());\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                None,\n                                                 true,\n                                                 false,\n                                                 Some(cm.clone()));"}, {"sha": "24ff20ea89242ef7f54009eec003a83d967f2de5", "filename": "src/test/run-make/error-found-staticlib-instead-crate/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -2,4 +2,4 @@\n \n all:\n \t$(RUSTC) foo.rs --crate-type staticlib\n-\t$(RUSTC) bar.rs 2>&1 | grep \"error: found staticlib\"\n+\t$(RUSTC) bar.rs 2>&1 | grep \"found staticlib\""}, {"sha": "239b689b52645b8a00fa63e798a4b13c67babc86", "filename": "src/test/run-make/many-crates-but-no-match/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -27,7 +27,7 @@ all:\n \tmv $(TMPDIR)/$(call RLIB_GLOB,crateA) $(A3)\n \t# Ensure crateC fails to compile since A1 is \"missing\" and A2/A3 hashes do not match\n \t$(RUSTC) -L $(A2) -L $(A3) crateC.rs >$(LOG) 2>&1 || true\n-\tgrep \"error: found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n+\tgrep \"found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n \tgrep \"note: perhaps that crate needs to be recompiled?\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #1:\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #2:\" $(LOG)"}, {"sha": "4275c9b3f9fa341e30f06bdf76f9debda6a71eaa", "filename": "src/test/run-make/missing-crate-dependency/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -6,4 +6,4 @@ all:\n \t$(call REMOVE_RLIBS,crateA)\n \t# Ensure crateC fails to compile since dependency crateA is missing\n \t$(RUSTC) crateC.rs 2>&1 | \\\n-\t\tgrep \"error: can't find crate for \\`crateA\\` which \\`crateB\\` depends on\"\n+\t\tgrep \"can't find crate for \\`crateA\\` which \\`crateB\\` depends on\""}, {"sha": "f834a85cdcc741c0cc496fa1d55bffd7a3f79974", "filename": "src/test/run-make/unicode-input/Makefile", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile?ref=42903d9a8f0f471f5e0eb453e49fe44a65a746c5", "patch": "@@ -1,26 +0,0 @@\n--include ../tools.mk\n-\n-# This test attempts to run rustc itself from the compiled binary; but\n-# that means that you need to set the LD_LIBRARY_PATH for rustc itself\n-# while running multiple_files, and that won't work for stage1.\n-\n-# FIXME ignore windows\n-ifndef IS_WINDOWS\n-ifeq ($(RUST_BUILD_STAGE),1)\n-DOTEST=\n-else\n-DOTEST=dotest\n-endif\n-endif\n-\n-all: $(DOTEST)\n-\n-dotest:\n-\t# check that we don't ICE on unicode input, issue #11178\n-\t$(RUSTC) multiple_files.rs\n-\t$(call RUN,multiple_files)  \"$(RUSTC)\" \"$(TMPDIR)\"\n-\n-\t# check that our multibyte-ident spans are (approximately) the\n-\t# correct length. issue #8706\n-\t$(RUSTC) span_length.rs\n-\t$(call RUN,span_length) \"$(RUSTC)\" \"$(TMPDIR)\""}, {"sha": "b1fe938767dc912cd8a533b7df908799b2e6fd3d", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=42903d9a8f0f471f5e0eb453e49fe44a65a746c5", "patch": "@@ -1,74 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rand)]\n-\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::path::Path;\n-use std::process::Command;\n-use std::__rand::{thread_rng, Rng};\n-use std::{char, env};\n-\n-// creates unicode_input_multiple_files_{main,chars}.rs, where the\n-// former imports the latter. `_chars` just contains an identifier\n-// made up of random characters, because will emit an error message\n-// about the ident being in the wrong place, with a span (and creating\n-// this span used to upset the compiler).\n-\n-fn random_char() -> char {\n-    let mut rng = thread_rng();\n-    // a subset of the XID_start Unicode table (ensuring that the\n-    // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n-        1 => (0x41, 0x5a),\n-        2 => (0xf8, 0x1ba),\n-        3 => (0x1401, 0x166c),\n-        _ => (0x10400, 0x1044f)\n-    };\n-\n-    char::from_u32(rng.gen_range(lo, hi + 1)).unwrap()\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    let rustc = &args[1];\n-    let tmpdir = Path::new(&args[2]);\n-\n-    let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n-    {\n-        let _ = File::create(&main_file).unwrap()\n-            .write_all(b\"mod unicode_input_multiple_files_chars;\").unwrap();\n-    }\n-\n-    for _ in 0..100 {\n-        {\n-            let randoms = tmpdir.join(\"unicode_input_multiple_files_chars.rs\");\n-            let mut w = File::create(&randoms).unwrap();\n-            for _ in 0..30 {\n-                write!(&mut w, \"{}\", random_char()).unwrap();\n-            }\n-        }\n-\n-        // rustc is passed to us with --out-dir and -L etc., so we\n-        // can't exec it directly\n-        let result = Command::new(\"sh\")\n-                             .arg(\"-c\")\n-                             .arg(&format!(\"{} {}\",\n-                                           rustc,\n-                                           main_file.display()))\n-                             .output().unwrap();\n-        let err = String::from_utf8_lossy(&result.stderr);\n-\n-        // positive test so that this test will be updated when the\n-        // compiler changes.\n-        assert!(err.contains(\"expected item, found\"))\n-    }\n-}"}, {"sha": "da8769e616c3f0ae545554aebb55edcc0eb6e964", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42903d9a8f0f471f5e0eb453e49fe44a65a746c5/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=42903d9a8f0f471f5e0eb453e49fe44a65a746c5", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rand)]\n-\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::iter::repeat;\n-use std::path::Path;\n-use std::process::Command;\n-use std::__rand::{thread_rng, Rng};\n-use std::{char, env};\n-\n-pub fn check_old_skool() -> bool {\n-    use std::env;\n-    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n-}\n-\n-// creates a file with `fn main() { <random ident> }` and checks the\n-// compiler emits a span of the appropriate length (for the\n-// \"unresolved name\" message); currently just using the number of code\n-// points, but should be the number of graphemes (FIXME #7043)\n-\n-fn random_char() -> char {\n-    let mut rng = thread_rng();\n-    // a subset of the XID_start Unicode table (ensuring that the\n-    // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n-        1 => (0x41, 0x5a),\n-        2 => (0xf8, 0x1ba),\n-        3 => (0x1401, 0x166c),\n-        _ => (0x10400, 0x1044f)\n-    };\n-\n-    char::from_u32(rng.gen_range(lo, hi + 1)).unwrap()\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    let rustc = &args[1];\n-    let tmpdir = Path::new(&args[2]);\n-    let main_file = tmpdir.join(\"span_main.rs\");\n-\n-    for _ in 0..100 {\n-        let n = thread_rng().gen_range(3, 20);\n-\n-        {\n-            let _ = write!(&mut File::create(&main_file).unwrap(),\n-                           \"#![feature(non_ascii_idents)] fn main() {{ {} }}\",\n-                           // random string of length n\n-                           (0..n).map(|_| random_char()).collect::<String>());\n-        }\n-\n-        // rustc is passed to us with --out-dir and -L etc., so we\n-        // can't exec it directly\n-        let result = Command::new(\"sh\")\n-                             .arg(\"-c\")\n-                             .arg(&format!(\"{} {}\",\n-                                           rustc,\n-                                           main_file.to_str()\n-                                                    .unwrap()))\n-                             .output().unwrap();\n-\n-        let err = String::from_utf8_lossy(&result.stderr);\n-\n-        if check_old_skool() {\n-            // the span should end the line (e.g no extra ~'s)\n-            let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n-                                                            .collect::<String>());\n-            assert!(err.contains(&expected_span));\n-        } else {\n-            // the span should end the line (e.g no extra ~'s)\n-            let expected_span = format!(\"^{}\\n\", repeat(\"^\").take(n - 1)\n-                                                            .collect::<String>());\n-            assert!(err.contains(&expected_span));\n-        }\n-    }\n-\n-    // Test multi-column characters and tabs\n-    {\n-        let _ = write!(&mut File::create(&main_file).unwrap(),\n-                       r#\"extern \"\uf937\uf922\uf92ba\u0301\u0301\u0301\" fn foo() {{}} extern \"\uf937\uf922\uf92ba\u0301\u0301\" fn bar() {{}}\"#);\n-    }\n-\n-    let result = Command::new(\"sh\")\n-                         .arg(\"-c\")\n-                         .arg(format!(\"{} {}\",\n-                                      rustc,\n-                                      main_file.display()))\n-                         .output().unwrap();\n-\n-    let err = String::from_utf8_lossy(&result.stderr);\n-\n-    // Test both the length of the snake and the leading spaces up to it\n-\n-    if check_old_skool() {\n-        // Extra characters. Every line is preceded by `filename:lineno <actual code>`\n-        let offset = main_file.to_str().unwrap().len() + 3;\n-\n-        // First snake is 8 ~s long, with 7 preceding spaces (excluding file name/line offset)\n-        let expected_span = format!(\"\\n{}^{}\\n\",\n-                                    repeat(\" \").take(offset + 7).collect::<String>(),\n-                                    repeat(\"~\").take(8).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-        // Second snake is only 7 ~s long, with 36 preceding spaces,\n-        // because rustc counts chars() now rather than width(). This\n-        // is because width() functions are to be removed from\n-        // librustc_unicode\n-        let expected_span = format!(\"\\n{}^{}\\n\",\n-                                    repeat(\" \").take(offset + 36).collect::<String>(),\n-                                    repeat(\"~\").take(7).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-    } else {\n-        let expected_span = format!(\"\\n  |>{}{}\\n\",\n-                                    repeat(\" \").take(8).collect::<String>(),\n-                                    repeat(\"^\").take(9).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-        let expected_span = format!(\"\\n  |>{}{}\\n\",\n-                                    repeat(\" \").take(37).collect::<String>(),\n-                                    repeat(\"^\").take(8).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-    }\n-}"}, {"sha": "ae8e82e4e2f60e36639358d9fa062381431fbe75", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad4f32c3147cca9f2b107d0440065b9e3d6c10f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=fad4f32c3147cca9f2b107d0440065b9e3d6c10f", "patch": "@@ -1330,9 +1330,7 @@ actual:\\n\\\n                 // patterns still match the raw compiler output.\n                 if self.props.error_patterns.is_empty() {\n                     args.extend([\"--error-format\",\n-                                 \"json\",\n-                                 \"-Z\",\n-                                 \"unstable-options\"]\n+                                 \"json\"]\n                                 .iter()\n                                 .map(|s| s.to_string()));\n                 }"}]}