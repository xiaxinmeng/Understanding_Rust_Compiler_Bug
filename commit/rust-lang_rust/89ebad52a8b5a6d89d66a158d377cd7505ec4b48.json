{"sha": "89ebad52a8b5a6d89d66a158d377cd7505ec4b48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZWJhZDUyYThiNWE2ZDg5ZDY2YTE1OGQzNzdjZDc1MDVlYzRiNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-02T11:43:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-02T11:43:39Z"}, "message": "Auto merge of #84802 - jyn514:option-dead-code, r=Mark-Simulacrum\n\nRemove dead code in `rustc_session::Options`\n\n- Don't recompile the same functions for each debugging option\n  This reduces the amount of items in the crate by quite a lot.\n- Remove unused `parse_opt_list` and `parse_pathbuf_push` functions\n- Remove unused macro parameters\n- Remove `allow(dead_code)`.", "tree": {"sha": "5b23e604b1c362e55f6f25b0dd675e19c639b7fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b23e604b1c362e55f6f25b0dd675e19c639b7fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89ebad52a8b5a6d89d66a158d377cd7505ec4b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89ebad52a8b5a6d89d66a158d377cd7505ec4b48", "html_url": "https://github.com/rust-lang/rust/commit/89ebad52a8b5a6d89d66a158d377cd7505ec4b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89ebad52a8b5a6d89d66a158d377cd7505ec4b48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1cd0ed368ea98fc67e8688dba5982a6aae62e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1cd0ed368ea98fc67e8688dba5982a6aae62e0", "html_url": "https://github.com/rust-lang/rust/commit/3a1cd0ed368ea98fc67e8688dba5982a6aae62e0"}, {"sha": "b19c02cce0761b517f92344d991ffb2c5d035cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b19c02cce0761b517f92344d991ffb2c5d035cd0", "html_url": "https://github.com/rust-lang/rust/commit/b19c02cce0761b517f92344d991ffb2c5d035cd0"}], "stats": {"total": 882, "additions": 453, "deletions": 429}, "files": [{"sha": "735188768e44694ea4570e43315668d2ee5335ce", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 453, "deletions": 429, "changes": 882, "blob_url": "https://github.com/rust-lang/rust/blob/89ebad52a8b5a6d89d66a158d377cd7505ec4b48/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89ebad52a8b5a6d89d66a158d377cd7505ec4b48/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=89ebad52a8b5a6d89d66a158d377cd7505ec4b48", "patch": "@@ -212,7 +212,7 @@ top_level_options!(\n macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n-     $stat:ident, $mod_desc:ident, $mod_set:ident,\n+     $stat:ident,\n      $($( #[$attr:meta] )* $opt:ident : $t:ty = (\n         $init:expr,\n         $parse:ident,\n@@ -286,546 +286,570 @@ macro_rules! options {\n \n     pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n     pub const $stat: &[(&str, $setter_name, &str, &str)] =\n-        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n-\n-    #[allow(non_upper_case_globals, dead_code)]\n-    mod $mod_desc {\n-        pub const parse_no_flag: &str = \"no value\";\n-        pub const parse_bool: &str = \"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\";\n-        pub const parse_opt_bool: &str = parse_bool;\n-        pub const parse_string: &str = \"a string\";\n-        pub const parse_opt_string: &str = parse_string;\n-        pub const parse_string_push: &str = parse_string;\n-        pub const parse_opt_pathbuf: &str = \"a path\";\n-        pub const parse_pathbuf_push: &str = parse_opt_pathbuf;\n-        pub const parse_list: &str = \"a space-separated list of strings\";\n-        pub const parse_opt_list: &str = parse_list;\n-        pub const parse_opt_comma_list: &str = \"a comma-separated list of strings\";\n-        pub const parse_number: &str = \"a number\";\n-        pub const parse_opt_number: &str = parse_number;\n-        pub const parse_threads: &str = parse_number;\n-        pub const parse_passes: &str = \"a space-separated list of passes, or `all`\";\n-        pub const parse_panic_strategy: &str = \"either `unwind` or `abort`\";\n-        pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-        pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `hwaddress`, `leak`, `memory` or `thread`\";\n-        pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n-        pub const parse_cfguard: &str =\n-            \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n-        pub const parse_strip: &str = \"either `none`, `debuginfo`, or `symbols`\";\n-        pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavor::one_of();\n-        pub const parse_optimization_fuel: &str = \"crate=integer\";\n-        pub const parse_mir_spanview: &str = \"`statement` (default), `terminator`, or `block`\";\n-        pub const parse_instrument_coverage: &str = \"`all` (default), `except-unused-generics`, `except-unused-functions`, or `off`\";\n-        pub const parse_unpretty: &str = \"`string` or `string=string`\";\n-        pub const parse_treat_err_as_bug: &str = \"either no value or a number bigger than 0\";\n-        pub const parse_lto: &str =\n-            \"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted\";\n-        pub const parse_linker_plugin_lto: &str =\n-            \"either a boolean (`yes`, `no`, `on`, `off`, etc), or the path to the linker plugin\";\n-        pub const parse_switch_with_opt_path: &str =\n-            \"an optional path to the profiling data output directory\";\n-        pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n-        pub const parse_symbol_mangling_version: &str = \"either `legacy` or `v0` (RFC 2603)\";\n-        pub const parse_src_file_hash: &str = \"either `md5` or `sha1`\";\n-        pub const parse_relocation_model: &str =\n-            \"one of supported relocation models (`rustc --print relocation-models`)\";\n-        pub const parse_code_model: &str =\n-            \"one of supported code models (`rustc --print code-models`)\";\n-        pub const parse_tls_model: &str =\n-            \"one of supported TLS models (`rustc --print tls-models`)\";\n-        pub const parse_target_feature: &str = parse_string;\n-        pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n-        pub const parse_split_debuginfo: &str =\n-            \"one of supported split-debuginfo modes (`off` or `dsymutil`)\";\n+        &[ $( (stringify!($opt), crate::options::parse::$opt, $crate::options::desc::$parse, $desc) ),* ];\n+\n+    // Sometimes different options need to build a common structure.\n+    // That structure can kept in one of the options' fields, the others become dummy.\n+    macro_rules! redirect_field {\n+        ($cg:ident.link_arg) => { $cg.link_args };\n+        ($cg:ident.pre_link_arg) => { $cg.pre_link_args };\n+        ($cg:ident.$field:ident) => { $cg.$field };\n     }\n \n-    #[allow(dead_code)]\n-    mod $mod_set {\n-        use super::*;\n-        use std::str::FromStr;\n-\n-        // Sometimes different options need to build a common structure.\n-        // That structure can kept in one of the options' fields, the others become dummy.\n-        macro_rules! redirect_field {\n-            ($cg:ident.link_arg) => { $cg.link_args };\n-            ($cg:ident.pre_link_arg) => { $cg.pre_link_args };\n-            ($cg:ident.$field:ident) => { $cg.$field };\n+    $(\n+        pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n+            $crate::options::parse::$parse(&mut redirect_field!(cg.$opt), v)\n         }\n+    )*\n \n-        $(\n-            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n-                $parse(&mut redirect_field!(cg.$opt), v)\n-            }\n-        )*\n-\n-        /// This is for boolean options that don't take a value and start with\n-        /// `no-`. This style of option is deprecated.\n-        fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                None => { *slot = true; true }\n-                Some(_) => false,\n-            }\n-        }\n+) }\n \n-        /// Use this for any boolean option that has a static default.\n-        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => { *slot = true; true }\n-                Some(\"n\") | Some(\"no\") | Some(\"off\") => { *slot = false; true }\n-                _ => false,\n-            }\n-        }\n+#[allow(non_upper_case_globals)]\n+mod desc {\n+    pub const parse_no_flag: &str = \"no value\";\n+    pub const parse_bool: &str = \"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\";\n+    pub const parse_opt_bool: &str = parse_bool;\n+    pub const parse_string: &str = \"a string\";\n+    pub const parse_opt_string: &str = parse_string;\n+    pub const parse_string_push: &str = parse_string;\n+    pub const parse_opt_pathbuf: &str = \"a path\";\n+    pub const parse_list: &str = \"a space-separated list of strings\";\n+    pub const parse_opt_comma_list: &str = \"a comma-separated list of strings\";\n+    pub const parse_number: &str = \"a number\";\n+    pub const parse_opt_number: &str = parse_number;\n+    pub const parse_threads: &str = parse_number;\n+    pub const parse_passes: &str = \"a space-separated list of passes, or `all`\";\n+    pub const parse_panic_strategy: &str = \"either `unwind` or `abort`\";\n+    pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n+    pub const parse_sanitizers: &str =\n+        \"comma separated list of sanitizers: `address`, `hwaddress`, `leak`, `memory` or `thread`\";\n+    pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n+    pub const parse_cfguard: &str =\n+        \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n+    pub const parse_strip: &str = \"either `none`, `debuginfo`, or `symbols`\";\n+    pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavor::one_of();\n+    pub const parse_optimization_fuel: &str = \"crate=integer\";\n+    pub const parse_mir_spanview: &str = \"`statement` (default), `terminator`, or `block`\";\n+    pub const parse_instrument_coverage: &str =\n+        \"`all` (default), `except-unused-generics`, `except-unused-functions`, or `off`\";\n+    pub const parse_unpretty: &str = \"`string` or `string=string`\";\n+    pub const parse_treat_err_as_bug: &str = \"either no value or a number bigger than 0\";\n+    pub const parse_lto: &str =\n+        \"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted\";\n+    pub const parse_linker_plugin_lto: &str =\n+        \"either a boolean (`yes`, `no`, `on`, `off`, etc), or the path to the linker plugin\";\n+    pub const parse_switch_with_opt_path: &str =\n+        \"an optional path to the profiling data output directory\";\n+    pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n+    pub const parse_symbol_mangling_version: &str = \"either `legacy` or `v0` (RFC 2603)\";\n+    pub const parse_src_file_hash: &str = \"either `md5` or `sha1`\";\n+    pub const parse_relocation_model: &str =\n+        \"one of supported relocation models (`rustc --print relocation-models`)\";\n+    pub const parse_code_model: &str = \"one of supported code models (`rustc --print code-models`)\";\n+    pub const parse_tls_model: &str = \"one of supported TLS models (`rustc --print tls-models`)\";\n+    pub const parse_target_feature: &str = parse_string;\n+    pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n+    pub const parse_split_debuginfo: &str =\n+        \"one of supported split-debuginfo modes (`off` or `dsymutil`)\";\n+}\n+\n+mod parse {\n+    crate use super::*;\n+    use std::str::FromStr;\n \n-        /// Use this for any boolean option that lacks a static default. (The\n-        /// actions taken when such an option is not specified will depend on\n-        /// other factors, such as other options, or target options.)\n-        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => { *slot = Some(true); true }\n-                Some(\"n\") | Some(\"no\") | Some(\"off\") => { *slot = Some(false); true }\n-                _ => false,\n+    /// This is for boolean options that don't take a value and start with\n+    /// `no-`. This style of option is deprecated.\n+    crate fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n+        match v {\n+            None => {\n+                *slot = true;\n+                true\n             }\n+            Some(_) => false,\n         }\n+    }\n \n-        /// Use this for any string option that has a static default.\n-        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.to_string(); true },\n-                None => false,\n+    /// Use this for any boolean option that has a static default.\n+    crate fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n+                *slot = true;\n+                true\n             }\n+            Some(\"n\") | Some(\"no\") | Some(\"off\") => {\n+                *slot = false;\n+                true\n+            }\n+            _ => false,\n         }\n+    }\n \n-        /// Use this for any string option that lacks a static default.\n-        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(s.to_string()); true },\n-                None => false,\n+    /// Use this for any boolean option that lacks a static default. (The\n+    /// actions taken when such an option is not specified will depend on\n+    /// other factors, such as other options, or target options.)\n+    crate fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n+                *slot = Some(true);\n+                true\n+            }\n+            Some(\"n\") | Some(\"no\") | Some(\"off\") => {\n+                *slot = Some(false);\n+                true\n             }\n+            _ => false,\n         }\n+    }\n \n-        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n-                None => false,\n+    /// Use this for any string option that has a static default.\n+    crate fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = s.to_string();\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(s.to_string()); true },\n-                None => false,\n+    /// Use this for any string option that lacks a static default.\n+    crate fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = Some(s.to_string());\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(PathBuf::from(s)); true },\n-                None => false,\n+    crate fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = Some(PathBuf::from(s));\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    slot.extend(s.split_whitespace().map(|s| s.to_string()));\n-                    true\n-                },\n-                None => false,\n+    crate fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                slot.push(s.to_string());\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n+    crate fn parse_list(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                slot.extend(s.split_whitespace().map(|s| s.to_string()));\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split(',').map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n+    crate fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                let mut v: Vec<_> = s.split(',').map(|s| s.to_string()).collect();\n+                v.sort_unstable();\n+                *slot = Some(v);\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(0) => { *slot = ::num_cpus::get(); true },\n-                Some(i) => { *slot = i; true },\n-                None => false\n+    crate fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n+        match v.and_then(|s| s.parse().ok()) {\n+            Some(0) => {\n+                *slot = ::num_cpus::get();\n+                true\n+            }\n+            Some(i) => {\n+                *slot = i;\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        /// Use this for any numeric option that has a static default.\n-        fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(i) => { *slot = i; true },\n-                None => false\n+    /// Use this for any numeric option that has a static default.\n+    crate fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n+        match v.and_then(|s| s.parse().ok()) {\n+            Some(i) => {\n+                *slot = i;\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        /// Use this for any numeric option that lacks a static default.\n-        fn parse_opt_number<T: Copy + FromStr>(slot: &mut Option<T>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n-                None => false\n+    /// Use this for any numeric option that lacks a static default.\n+    crate fn parse_opt_number<T: Copy + FromStr>(slot: &mut Option<T>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = s.parse().ok();\n+                slot.is_some()\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"all\") => {\n-                    *slot = Passes::All;\n+    crate fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"all\") => {\n+                *slot = Passes::All;\n+                true\n+            }\n+            v => {\n+                let mut passes = vec![];\n+                if parse_list(&mut passes, v) {\n+                    *slot = Passes::Some(passes);\n                     true\n-                }\n-                v => {\n-                    let mut passes = vec![];\n-                    if parse_list(&mut passes, v) {\n-                        *slot = Passes::Some(passes);\n-                        true\n-                    } else {\n-                        false\n-                    }\n+                } else {\n+                    false\n                 }\n             }\n         }\n+    }\n \n-        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n-                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n-                _ => return false\n-            }\n-            true\n+    crate fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n+            Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s.parse::<RelroLevel>() {\n-                        Ok(level) => *slot = Some(level),\n-                        _ => return false\n-                    }\n-                },\n-                _ => return false\n-            }\n-            true\n+    crate fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => match s.parse::<RelroLevel>() {\n+                Ok(level) => *slot = Some(level),\n+                _ => return false,\n+            },\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n-            if let Some(v) = v {\n-                for s in v.split(',') {\n-                    *slot |= match s {\n-                        \"address\" => SanitizerSet::ADDRESS,\n-                        \"leak\" => SanitizerSet::LEAK,\n-                        \"memory\" => SanitizerSet::MEMORY,\n-                        \"thread\" => SanitizerSet::THREAD,\n-                        \"hwaddress\" => SanitizerSet::HWADDRESS,\n-                        _ => return false,\n-                    }\n+    crate fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n+        if let Some(v) = v {\n+            for s in v.split(',') {\n+                *slot |= match s {\n+                    \"address\" => SanitizerSet::ADDRESS,\n+                    \"leak\" => SanitizerSet::LEAK,\n+                    \"memory\" => SanitizerSet::MEMORY,\n+                    \"thread\" => SanitizerSet::THREAD,\n+                    \"hwaddress\" => SanitizerSet::HWADDRESS,\n+                    _ => return false,\n                 }\n-                true\n-            } else {\n-                false\n             }\n+            true\n+        } else {\n+            false\n         }\n+    }\n \n-        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"2\") | None => { *slot = 2; true }\n-                Some(\"1\") => { *slot = 1; true }\n-                Some(\"0\") => { *slot = 0; true }\n-                Some(_) => false,\n+    crate fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"2\") | None => {\n+                *slot = 2;\n+                true\n+            }\n+            Some(\"1\") => {\n+                *slot = 1;\n+                true\n+            }\n+            Some(\"0\") => {\n+                *slot = 0;\n+                true\n             }\n+            Some(_) => false,\n         }\n+    }\n \n-        fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"none\") => *slot = Strip::None,\n-                Some(\"debuginfo\") => *slot = Strip::Debuginfo,\n-                Some(\"symbols\") => *slot = Strip::Symbols,\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"none\") => *slot = Strip::None,\n+            Some(\"debuginfo\") => *slot = Strip::Debuginfo,\n+            Some(\"symbols\") => *slot = Strip::Symbols,\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        CFGuard::Checks\n-                    } else {\n-                        CFGuard::Disabled\n-                    };\n-                    return true\n-                }\n+    crate fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n+        if v.is_some() {\n+            let mut bool_arg = None;\n+            if parse_opt_bool(&mut bool_arg, v) {\n+                *slot = if bool_arg.unwrap() { CFGuard::Checks } else { CFGuard::Disabled };\n+                return true;\n             }\n-\n-            *slot = match v {\n-                None => CFGuard::Checks,\n-                Some(\"checks\") => CFGuard::Checks,\n-                Some(\"nochecks\") => CFGuard::NoChecks,\n-                Some(_) => return false,\n-            };\n-            true\n         }\n \n-        fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n-            match v.and_then(LinkerFlavor::from_str) {\n-                Some(lf) => *slote = Some(lf),\n-                _ => return false,\n-            }\n-            true\n+        *slot = match v {\n+            None => CFGuard::Checks,\n+            Some(\"checks\") => CFGuard::Checks,\n+            Some(\"nochecks\") => CFGuard::NoChecks,\n+            Some(_) => return false,\n+        };\n+        true\n+    }\n+\n+    crate fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n+        match v.and_then(LinkerFlavor::from_str) {\n+            Some(lf) => *slote = Some(lf),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) => {\n-                    let parts = s.split('=').collect::<Vec<_>>();\n-                    if parts.len() != 2 { return false; }\n-                    let crate_name = parts[0].to_string();\n-                    let fuel = parts[1].parse::<u64>();\n-                    if fuel.is_err() { return false; }\n-                    *slot = Some((crate_name, fuel.unwrap()));\n-                    true\n+    crate fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n+        match v {\n+            None => false,\n+            Some(s) => {\n+                let parts = s.split('=').collect::<Vec<_>>();\n+                if parts.len() != 2 {\n+                    return false;\n+                }\n+                let crate_name = parts[0].to_string();\n+                let fuel = parts[1].parse::<u64>();\n+                if fuel.is_err() {\n+                    return false;\n                 }\n+                *slot = Some((crate_name, fuel.unwrap()));\n+                true\n             }\n         }\n+    }\n \n-        fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) if s.split('=').count() <= 2 => {\n-                    *slot = Some(s.to_string());\n-                    true\n-                }\n-                _ => false,\n+    crate fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+        match v {\n+            None => false,\n+            Some(s) if s.split('=').count() <= 2 => {\n+                *slot = Some(s.to_string());\n+                true\n             }\n+            _ => false,\n         }\n+    }\n \n-        fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        Some(MirSpanview::Statement)\n-                    } else {\n-                        None\n-                    };\n-                    return true\n-                }\n+    crate fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n+        if v.is_some() {\n+            let mut bool_arg = None;\n+            if parse_opt_bool(&mut bool_arg, v) {\n+                *slot = if bool_arg.unwrap() { Some(MirSpanview::Statement) } else { None };\n+                return true;\n             }\n-\n-            let v = match v {\n-                None => {\n-                    *slot = Some(MirSpanview::Statement);\n-                    return true;\n-                }\n-                Some(v) => v,\n-            };\n-\n-            *slot = Some(match v.trim_end_matches(\"s\") {\n-                \"statement\" | \"stmt\" => MirSpanview::Statement,\n-                \"terminator\" | \"term\" => MirSpanview::Terminator,\n-                \"block\" | \"basicblock\" => MirSpanview::Block,\n-                _ => return false,\n-            });\n-            true\n         }\n \n-        fn parse_instrument_coverage(slot: &mut Option<InstrumentCoverage>, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        Some(InstrumentCoverage::All)\n-                    } else {\n-                        None\n-                    };\n-                    return true\n-                }\n+        let v = match v {\n+            None => {\n+                *slot = Some(MirSpanview::Statement);\n+                return true;\n             }\n+            Some(v) => v,\n+        };\n+\n+        *slot = Some(match v.trim_end_matches(\"s\") {\n+            \"statement\" | \"stmt\" => MirSpanview::Statement,\n+            \"terminator\" | \"term\" => MirSpanview::Terminator,\n+            \"block\" | \"basicblock\" => MirSpanview::Block,\n+            _ => return false,\n+        });\n+        true\n+    }\n \n-            let v = match v {\n-                None => {\n-                    *slot = Some(InstrumentCoverage::All);\n-                    return true;\n-                }\n-                Some(v) => v,\n-            };\n-\n-            *slot = Some(match v {\n-                \"all\" => InstrumentCoverage::All,\n-                \"except-unused-generics\" | \"except_unused_generics\" => {\n-                    InstrumentCoverage::ExceptUnusedGenerics\n-                }\n-                \"except-unused-functions\" | \"except_unused_functions\" => {\n-                    InstrumentCoverage::ExceptUnusedFunctions\n-                }\n-                \"off\" | \"no\" | \"n\" | \"false\" | \"0\" => InstrumentCoverage::Off,\n-                _ => return false,\n-            });\n-            true\n+    crate fn parse_instrument_coverage(\n+        slot: &mut Option<InstrumentCoverage>,\n+        v: Option<&str>,\n+    ) -> bool {\n+        if v.is_some() {\n+            let mut bool_arg = None;\n+            if parse_opt_bool(&mut bool_arg, v) {\n+                *slot = if bool_arg.unwrap() { Some(InstrumentCoverage::All) } else { None };\n+                return true;\n+            }\n         }\n \n-        fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n-                None => { *slot = NonZeroUsize::new(1); true }\n+        let v = match v {\n+            None => {\n+                *slot = Some(InstrumentCoverage::All);\n+                return true;\n             }\n-        }\n+            Some(v) => v,\n+        };\n \n-        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LtoCli::Yes\n-                    } else {\n-                        LtoCli::No\n-                    };\n-                    return true\n-                }\n+        *slot = Some(match v {\n+            \"all\" => InstrumentCoverage::All,\n+            \"except-unused-generics\" | \"except_unused_generics\" => {\n+                InstrumentCoverage::ExceptUnusedGenerics\n             }\n+            \"except-unused-functions\" | \"except_unused_functions\" => {\n+                InstrumentCoverage::ExceptUnusedFunctions\n+            }\n+            \"off\" | \"no\" | \"n\" | \"false\" | \"0\" => InstrumentCoverage::Off,\n+            _ => return false,\n+        });\n+        true\n+    }\n \n-            *slot = match v {\n-                None => LtoCli::NoParam,\n-                Some(\"thin\") => LtoCli::Thin,\n-                Some(\"fat\") => LtoCli::Fat,\n-                Some(_) => return false,\n-            };\n-            true\n+    crate fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                *slot = s.parse().ok();\n+                slot.is_some()\n+            }\n+            None => {\n+                *slot = NonZeroUsize::new(1);\n+                true\n+            }\n         }\n+    }\n \n-        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LinkerPluginLto::LinkerPluginAuto\n-                    } else {\n-                        LinkerPluginLto::Disabled\n-                    };\n-                    return true\n-                }\n+    crate fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+        if v.is_some() {\n+            let mut bool_arg = None;\n+            if parse_opt_bool(&mut bool_arg, v) {\n+                *slot = if bool_arg.unwrap() { LtoCli::Yes } else { LtoCli::No };\n+                return true;\n             }\n-\n-            *slot = match v {\n-                None => LinkerPluginLto::LinkerPluginAuto,\n-                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n-            };\n-            true\n         }\n \n-        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n-            *slot = match v {\n-                None => SwitchWithOptPath::Enabled(None),\n-                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n-            };\n-            true\n-        }\n+        *slot = match v {\n+            None => LtoCli::NoParam,\n+            Some(\"thin\") => LtoCli::Thin,\n+            Some(\"fat\") => LtoCli::Fat,\n+            Some(_) => return false,\n+        };\n+        true\n+    }\n \n-        fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n-                Some(mergefunc) => *slot = Some(mergefunc),\n-                _ => return false,\n+    crate fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n+        if v.is_some() {\n+            let mut bool_arg = None;\n+            if parse_opt_bool(&mut bool_arg, v) {\n+                *slot = if bool_arg.unwrap() {\n+                    LinkerPluginLto::LinkerPluginAuto\n+                } else {\n+                    LinkerPluginLto::Disabled\n+                };\n+                return true;\n             }\n-            true\n         }\n \n-        fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| RelocModel::from_str(s).ok()) {\n-                Some(relocation_model) => *slot = Some(relocation_model),\n-                None if v == Some(\"default\") => *slot = None,\n-                _ => return false,\n-            }\n-            true\n+        *slot = match v {\n+            None => LinkerPluginLto::LinkerPluginAuto,\n+            Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n+        };\n+        true\n+    }\n+\n+    crate fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n+        *slot = match v {\n+            None => SwitchWithOptPath::Enabled(None),\n+            Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n+        };\n+        true\n+    }\n+\n+    crate fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n+        match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n+            Some(mergefunc) => *slot = Some(mergefunc),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| CodeModel::from_str(s).ok()) {\n-                Some(code_model) => *slot = Some(code_model),\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n+        match v.and_then(|s| RelocModel::from_str(s).ok()) {\n+            Some(relocation_model) => *slot = Some(relocation_model),\n+            None if v == Some(\"default\") => *slot = None,\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| TlsModel::from_str(s).ok()) {\n-                Some(tls_model) => *slot = Some(tls_model),\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n+        match v.and_then(|s| CodeModel::from_str(s).ok()) {\n+            Some(code_model) => *slot = Some(code_model),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_symbol_mangling_version(\n-            slot: &mut Option<SymbolManglingVersion>,\n-            v: Option<&str>,\n-        ) -> bool {\n-            *slot = match v {\n-                Some(\"legacy\") => Some(SymbolManglingVersion::Legacy),\n-                Some(\"v0\") => Some(SymbolManglingVersion::V0),\n-                _ => return false,\n-            };\n-            true\n+    crate fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n+        match v.and_then(|s| TlsModel::from_str(s).ok()) {\n+            Some(tls_model) => *slot = Some(tls_model),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_src_file_hash(slot: &mut Option<SourceFileHashAlgorithm>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| SourceFileHashAlgorithm::from_str(s).ok()) {\n-                Some(hash_kind) => *slot = Some(hash_kind),\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_symbol_mangling_version(\n+        slot: &mut Option<SymbolManglingVersion>,\n+        v: Option<&str>,\n+    ) -> bool {\n+        *slot = match v {\n+            Some(\"legacy\") => Some(SymbolManglingVersion::Legacy),\n+            Some(\"v0\") => Some(SymbolManglingVersion::V0),\n+            _ => return false,\n+        };\n+        true\n+    }\n+\n+    crate fn parse_src_file_hash(\n+        slot: &mut Option<SourceFileHashAlgorithm>,\n+        v: Option<&str>,\n+    ) -> bool {\n+        match v.and_then(|s| SourceFileHashAlgorithm::from_str(s).ok()) {\n+            Some(hash_kind) => *slot = Some(hash_kind),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    if !slot.is_empty() {\n-                        slot.push_str(\",\");\n-                    }\n-                    slot.push_str(s);\n-                    true\n+    crate fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n+        match v {\n+            Some(s) => {\n+                if !slot.is_empty() {\n+                    slot.push_str(\",\");\n                 }\n-                None => false,\n+                slot.push_str(s);\n+                true\n             }\n+            None => false,\n         }\n+    }\n \n-        fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"command\")  => *slot = Some(WasiExecModel::Command),\n-                Some(\"reactor\") => *slot = Some(WasiExecModel::Reactor),\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"command\") => *slot = Some(WasiExecModel::Command),\n+            Some(\"reactor\") => *slot = Some(WasiExecModel::Reactor),\n+            _ => return false,\n         }\n+        true\n+    }\n \n-        fn parse_split_debuginfo(slot: &mut Option<SplitDebuginfo>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| SplitDebuginfo::from_str(s).ok()) {\n-                Some(e) => *slot = Some(e),\n-                _ => return false,\n-            }\n-            true\n+    crate fn parse_split_debuginfo(slot: &mut Option<SplitDebuginfo>, v: Option<&str>) -> bool {\n+        match v.and_then(|s| SplitDebuginfo::from_str(s).ok()) {\n+            Some(e) => *slot = Some(e),\n+            _ => return false,\n         }\n+        true\n     }\n-) }\n+}\n \n options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n           build_codegen_options, \"C\", \"codegen\",\n-          CG_OPTIONS, cg_type_desc, cgsetters,\n+          CG_OPTIONS,\n \n     // This list is in alphabetical order.\n     //\n@@ -935,7 +959,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           build_debugging_options, \"Z\", \"debugging\",\n-          DB_OPTIONS, db_type_desc, dbsetters,\n+          DB_OPTIONS,\n \n     // This list is in alphabetical order.\n     //"}]}