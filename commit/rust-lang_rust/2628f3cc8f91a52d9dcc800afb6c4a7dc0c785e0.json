{"sha": "2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MjhmM2NjOGY5MWE1MmQ5ZGNjODAwYWZiNmM0YTdkYzBjNzg1ZTA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-22T22:58:45Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-23T03:03:54Z"}, "message": "fix alignment", "tree": {"sha": "218a69ade6504638f42db4f4c855cbd15d29cb73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/218a69ade6504638f42db4f4c855cbd15d29cb73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "html_url": "https://github.com/rust-lang/rust/commit/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/comments", "author": null, "committer": null, "parents": [{"sha": "bd71d11a8f75b9957489c795a1551a0cd489eca3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd71d11a8f75b9957489c795a1551a0cd489eca3", "html_url": "https://github.com/rust-lang/rust/commit/bd71d11a8f75b9957489c795a1551a0cd489eca3"}], "stats": {"total": 943, "additions": 464, "deletions": 479}, "files": [{"sha": "95838e03d2378858b99c70b086a69a1fee68e663", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -312,10 +312,10 @@ fn collect_tests_from_dir(config: &Config,\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             collect_tests_from_dir(config,\n-                                        base,\n-                                        &file_path,\n-                                        &relative_file_path,\n-                                        tests)?;\n+                                   base,\n+                                   &file_path,\n+                                   relative_file_path,\n+                                   tests)?;\n         }\n     }\n     Ok(())"}, {"sha": "f5bdf28a4b134032031a26c9e3fcb07640837c82", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -56,7 +56,7 @@ pub struct DefId {\n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n-                    self.krate, self.index)?;\n+               self.krate, self.index)?;\n \n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now"}, {"sha": "f67389e3c3b008b0d91dc8ae71ca76d9274369d6", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -71,9 +71,9 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n         // Relate integral variables to other types\n         (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n             infcx.int_unification_table\n-                      .borrow_mut()\n-                      .unify_var_var(a_id, b_id)\n-                      .map_err(|e| int_unification_error(a_is_expected, e))?;\n+                 .borrow_mut()\n+                 .unify_var_var(a_id, b_id)\n+                 .map_err(|e| int_unification_error(a_is_expected, e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n@@ -92,9 +92,9 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n         // Relate floating-point variables to other types\n         (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n             infcx.float_unification_table\n-                      .borrow_mut()\n-                      .unify_var_var(a_id, b_id)\n-                      .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n+                 .borrow_mut()\n+                 .unify_var_var(a_id, b_id)\n+                 .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n@@ -123,8 +123,7 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                     val: ty::IntVarValue)\n                                     -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    infcx\n-         .int_unification_table\n+    infcx.int_unification_table\n          .borrow_mut()\n          .unify_var_value(vid, val)\n          .map_err(|e| int_unification_error(vid_is_expected, e))?;\n@@ -140,8 +139,7 @@ fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                  val: ast::FloatTy)\n                                  -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    infcx\n-         .float_unification_table\n+    infcx.float_unification_table\n          .borrow_mut()\n          .unify_var_value(vid, val)\n          .map_err(|e| float_unification_error(vid_is_expected, e))?;"}, {"sha": "e94311697c35a9c30dd238f3b26cdd43373a5263", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -76,8 +76,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n                 self.fields\n-                         .switch_expected()\n-                         .instantiate(b, SupertypeOf, a_id)?;\n+                    .switch_expected()\n+                    .instantiate(b, SupertypeOf, a_id)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {"}, {"sha": "3eaf123e5be58f3265a28f5d78143df2cd8fe768", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -1038,15 +1038,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // For other types, we'll use the builtin rules.\n                 self.assemble_builtin_bound_candidates(ty::BoundCopy,\n-                                                            obligation,\n-                                                            &mut candidates)?;\n+                                                       obligation,\n+                                                       &mut candidates)?;\n             }\n             Some(bound @ ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n                 self.assemble_builtin_bound_candidates(bound,\n-                                                            obligation,\n-                                                            &mut candidates)?;\n+                                                       obligation,\n+                                                       &mut candidates)?;\n             }\n \n             None if self.tcx().lang_items.unsize_trait() ==\n@@ -2422,8 +2422,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                          obligation.predicate.to_poly_trait_ref(),\n-                                          trait_ref)?;\n+                                     obligation.predicate.to_poly_trait_ref(),\n+                                     trait_ref)?;\n         Ok(self_ty)\n     }\n \n@@ -2450,8 +2450,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligations);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                          obligation.predicate.to_poly_trait_ref(),\n-                                          trait_ref)?;\n+                                     obligation.predicate.to_poly_trait_ref(),\n+                                     trait_ref)?;\n \n         Ok(VtableClosureData {\n             closure_def_id: closure_def_id,"}, {"sha": "1df7a440f4f16d5ba88e6072f1e54dd7cd1c1404", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -167,9 +167,9 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n                 let b_regions = b.get_slice(space);\n                 let r_variances = variances.map(|v| v.regions.get_slice(space));\n                 let regions = relate_region_params(relation,\n-                                                        r_variances,\n-                                                        a_regions,\n-                                                        b_regions)?;\n+                                                   r_variances,\n+                                                   a_regions,\n+                                                   b_regions)?;\n                 substs.mut_regions().replace(space, regions);\n             }\n         }\n@@ -261,8 +261,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n         }\n \n         let inputs = relate_arg_vecs(relation,\n-                                          &a.inputs,\n-                                          &b.inputs)?;\n+                                     &a.inputs,\n+                                     &b.inputs)?;\n \n         let output = match (a.output, b.output) {\n             (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n@@ -557,8 +557,8 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         {\n             if as_.len() == bs.len() {\n                 let ts = as_.iter().zip(bs)\n-                                 .map(|(a, b)| relation.relate(a, b))\n-                                 .collect::<Result<_, _>>()?;\n+                            .map(|(a, b)| relation.relate(a, b))\n+                            .collect::<Result<_, _>>()?;\n                 Ok(tcx.mk_tup(ts))\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize("}, {"sha": "ff3e292f45818c4245982fc941740a89842ee107", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -809,8 +809,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did,\n-                                                  ppaux::Ns::Value, &[],\n-                                                  |tcx| {\n+                                             ppaux::Ns::Value, &[],\n+                                             |tcx| {\n                             tcx.lookup_item_type(variant_def.did).generics\n                         })?;\n "}, {"sha": "64619e40f49414c34092a11edf4e6ee66f4a8b98", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -123,8 +123,8 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         for projection in projections {\n             start_or_continue(f, \"<\", \", \")?;\n             write!(f, \"{}={}\",\n-                        projection.projection_ty.item_name,\n-                        projection.ty)?;\n+                   projection.projection_ty.item_name,\n+                   projection.ty)?;\n         }\n         return start_or_continue(f, \"\", \">\");\n     }\n@@ -201,8 +201,8 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     for projection in projections {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}={}\",\n-                    projection.projection_ty.item_name,\n-                    projection.ty)?;\n+               projection.projection_ty.item_name,\n+               projection.ty)?;\n     }\n \n     start_or_continue(f, \"\", \">\")?;\n@@ -865,7 +865,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n \n                 write!(f, \"{} {{\", bare_fn.sig.0)?;\n                 parameterized(f, substs, def_id, Ns::Value, &[],\n-                                   |tcx| tcx.lookup_item_type(def_id).generics)?;\n+                              |tcx| tcx.lookup_item_type(def_id).generics)?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {"}, {"sha": "a8eac524971ba7107a1d242fdb744ee1b33100a6", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -468,7 +468,7 @@ impl Target {\n             let mut contents = Vec::new();\n             f.read_to_end(&mut contents).map_err(|e| e.to_string())?;\n             let obj = json::from_reader(&mut &contents[..])\n-                                .map_err(|e| e.to_string())?;\n+                           .map_err(|e| e.to_string())?;\n             Ok(Target::from_json(obj))\n         }\n "}, {"sha": "460c71dee3d721e6f00b1d0cc125ccda7a3ad2c8", "filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -124,15 +124,15 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n                     write!(w, \"</td><td></td><td></td></tr>\")?;\n                 }\n                 write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n-                            bg = BG_FLOWCONTENT,\n-                            align = ALIGN_RIGHT,\n-                            objs = c)?;\n+                       bg = BG_FLOWCONTENT,\n+                       align = ALIGN_RIGHT,\n+                       objs = c)?;\n                 seen_one = true;\n             }\n             if !seen_one {\n                 write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n-                            bg = BG_FLOWCONTENT,\n-                            align = ALIGN_RIGHT)?;\n+                       bg = BG_FLOWCONTENT,\n+                       align = ALIGN_RIGHT)?;\n             }\n             Ok(())\n         }\n@@ -155,38 +155,38 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n                 let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n                 chunked_present_left(w, &gen[..], chunk_size)?;\n                 write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n-                                            <td></td></tr>\",\n-                            bg = BG_FLOWCONTENT,\n-                            face = FACE_MONOSPACE,\n-                            genbits=bits_to_string( flow.sets.gen_set_for(i),\n-                                                    flow.sets.bytes_per_block()))?;\n+                                       <td></td></tr>\",\n+                       bg = BG_FLOWCONTENT,\n+                       face = FACE_MONOSPACE,\n+                       genbits=bits_to_string( flow.sets.gen_set_for(i),\n+                                               flow.sets.bytes_per_block()))?;\n                 write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n-                                             <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n-                            bg = BG_FLOWCONTENT,\n-                            align = ALIGN_RIGHT,\n-                            face = FACE_MONOSPACE,\n-                            killbits=bits_to_string(flow.sets.kill_set_for(i),\n-                                                    flow.sets.bytes_per_block()))?;\n+                                        <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n+                       bg = BG_FLOWCONTENT,\n+                       align = ALIGN_RIGHT,\n+                       face = FACE_MONOSPACE,\n+                       killbits=bits_to_string(flow.sets.kill_set_for(i),\n+                                               flow.sets.bytes_per_block()))?;\n \n                 // (chunked_present_right)\n                 let mut seen_one = false;\n                 for k in kill.chunks(chunk_size) {\n                     if !seen_one {\n                         // continuation of row; this is fourth <td>\n                         write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n-                                    bg = BG_FLOWCONTENT,\n-                                    kill=k)?;\n+                               bg = BG_FLOWCONTENT,\n+                               kill=k)?;\n                     } else {\n                         // new row, with indent of three <td>'s\n                         write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n-                                    bg = BG_FLOWCONTENT,\n-                                    kill=k)?;\n+                               bg = BG_FLOWCONTENT,\n+                               kill=k)?;\n                     }\n                     seen_one = true;\n                 }\n                 if !seen_one {\n                     write!(w, \"<td {bg}>= []</td></tr>\",\n-                                bg = BG_FLOWCONTENT)?;\n+                           bg = BG_FLOWCONTENT)?;\n                 }\n \n                 Ok(())"}, {"sha": "55b873c06630a2b1bb5018efc635fe8ceec1b26f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -100,10 +100,10 @@ pub fn compile_input(sess: &Session,\n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n             let expanded_crate = phase_2_configure_and_expand(sess,\n-                                                                   &cstore,\n-                                                                   krate,\n-                                                                   &id[..],\n-                                                                   addl_plugins)?;\n+                                                              &cstore,\n+                                                              krate,\n+                                                              &id[..],\n+                                                              addl_plugins)?;\n \n             (outputs, expanded_crate, id)\n         };\n@@ -169,12 +169,12 @@ pub fn compile_input(sess: &Session,\n         };\n \n         phase_3_run_analysis_passes(sess,\n-                                              &cstore,\n-                                              hir_map,\n-                                              &arenas,\n-                                              &id,\n-                                              control.make_glob_map,\n-                                              |tcx, mir_map, analysis, result| {\n+                                    &cstore,\n+                                    hir_map,\n+                                    &arenas,\n+                                    &id,\n+                                    control.make_glob_map,\n+                                    |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -683,8 +683,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     })?;\n \n     time(time_passes,\n-              \"const fn bodies and arguments\",\n-              || const_fn::check_crate(sess, &krate))?;\n+         \"const fn bodies and arguments\",\n+         || const_fn::check_crate(sess, &krate))?;\n \n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n@@ -781,10 +781,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     };\n \n     let named_region_map = time(time_passes,\n-                                     \"lifetime resolution\",\n-                                     || middle::resolve_lifetime::krate(sess,\n-                                                                        &hir_map,\n-                                                                        &def_map.borrow()))?;\n+                                \"lifetime resolution\",\n+                                || middle::resolve_lifetime::krate(sess,\n+                                                                   &hir_map,\n+                                                                   &def_map.borrow()))?;\n \n     time(time_passes,\n          \"looking for entry point\","}, {"sha": "3b8e6763de011a7d3bb1aae09250331e9a430658", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -288,13 +288,13 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl,\n-                        unsafety,\n-                        constness,\n-                        Abi::Rust,\n-                        Some(name),\n-                        generics,\n-                        opt_explicit_self,\n-                        hir::Inherited)?;\n+                   unsafety,\n+                   constness,\n+                   Abi::Rust,\n+                   Some(name),\n+                   generics,\n+                   opt_explicit_self,\n+                   hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -567,13 +567,13 @@ impl<'a> State<'a> {\n             hir::ForeignItemFn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n-                                   hir::Unsafety::Normal,\n-                                   hir::Constness::NotConst,\n-                                   Abi::Rust,\n-                                   Some(item.name),\n-                                   generics,\n-                                   None,\n-                                   item.vis)?;\n+                              hir::Unsafety::Normal,\n+                              hir::Constness::NotConst,\n+                              Abi::Rust,\n+                              Some(item.name),\n+                              generics,\n+                              None,\n+                              item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n@@ -704,13 +704,13 @@ impl<'a> State<'a> {\n             hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n-                                   unsafety,\n-                                   constness,\n-                                   abi,\n-                                   Some(item.name),\n-                                   typarams,\n-                                   None,\n-                                   item.vis)?;\n+                              unsafety,\n+                              constness,\n+                              abi,\n+                              Some(item.name),\n+                              typarams,\n+                              None,\n+                              item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n             }\n@@ -984,9 +984,9 @@ impl<'a> State<'a> {\n         match ti.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n                 self.print_associated_const(ti.name,\n-                                                 &ty,\n-                                                 default.as_ref().map(|expr| &**expr),\n-                                                 hir::Inherited)?;\n+                                            &ty,\n+                                            default.as_ref().map(|expr| &**expr),\n+                                            hir::Inherited)?;\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n@@ -1002,8 +1002,8 @@ impl<'a> State<'a> {\n             }\n             hir::TypeTraitItem(ref bounds, ref default) => {\n                 self.print_associated_type(ti.name,\n-                                                Some(bounds),\n-                                                default.as_ref().map(|ty| &**ty))?;\n+                                           Some(bounds),\n+                                           default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n         self.ann.post(self, NodeSubItem(ti.id))\n@@ -1219,15 +1219,15 @@ impl<'a> State<'a> {\n         self.print_path(path, true, 0)?;\n         word(&mut self.s, \"{\")?;\n         self.commasep_cmnt(Consistent,\n-                                &fields[..],\n-                                |s, field| {\n-                                    s.ibox(indent_unit)?;\n-                                    s.print_name(field.name.node)?;\n-                                    s.word_space(\":\")?;\n-                                    s.print_expr(&field.expr)?;\n-                                    s.end()\n-                                },\n-                                |f| f.span)?;\n+                           &fields[..],\n+                           |s, field| {\n+                               s.ibox(indent_unit)?;\n+                               s.print_name(field.name.node)?;\n+                               s.word_space(\":\")?;\n+                               s.print_expr(&field.expr)?;\n+                               s.end()\n+                           },\n+                           |f| f.span)?;\n         match *wth {\n             Some(ref expr) => {\n                 self.ibox(indent_unit)?;\n@@ -1760,17 +1760,17 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(Consistent,\n-                                        &fields[..],\n-                                        |s, f| {\n-                                            s.cbox(indent_unit)?;\n-                                            if !f.node.is_shorthand {\n-                                                s.print_name(f.node.name)?;\n-                                                s.word_nbsp(\":\")?;\n-                                            }\n-                                            s.print_pat(&f.node.pat)?;\n-                                            s.end()\n-                                        },\n-                                        |f| f.node.pat.span)?;\n+                                   &fields[..],\n+                                   |s, f| {\n+                                       s.cbox(indent_unit)?;\n+                                       if !f.node.is_shorthand {\n+                                           s.print_name(f.node.name)?;\n+                                           s.word_nbsp(\":\")?;\n+                                       }\n+                                       s.print_pat(&f.node.pat)?;\n+                                       s.end()\n+                                   },\n+                                   |f| f.node.pat.span)?;\n                 if etc {\n                     if !fields.is_empty() {\n                         self.word_space(\",\")?;\n@@ -2261,13 +2261,13 @@ impl<'a> State<'a> {\n             },\n         };\n         self.print_fn(decl,\n-                           unsafety,\n-                           hir::Constness::NotConst,\n-                           abi,\n-                           name,\n-                           &generics,\n-                           opt_explicit_self,\n-                           hir::Inherited)?;\n+                      unsafety,\n+                      hir::Constness::NotConst,\n+                      abi,\n+                      name,\n+                      &generics,\n+                      opt_explicit_self,\n+                      hir::Inherited)?;\n         self.end()\n     }\n "}, {"sha": "953eb724f50ec33030b6a47fb0ee245f5aeb1015", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -65,9 +65,9 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n \n     // Basic block number at the top.\n     write!(w, r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n-                attrs=r#\"bgcolor=\"gray\" align=\"center\"\"#,\n-                colspan=num_cols,\n-                blk=block.index())?;\n+           attrs=r#\"bgcolor=\"gray\" align=\"center\"\"#,\n+           colspan=num_cols,\n+           blk=block.index())?;\n \n     init(w)?;\n \n@@ -145,13 +145,13 @@ fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut\n             write!(w, \"mut \")?;\n         }\n         write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                    Lvalue::Var(i as u32), escape(&var.ty), var.name)?;\n+               Lvalue::Var(i as u32), escape(&var.ty), var.name)?;\n     }\n \n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n         write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-                    Lvalue::Temp(i as u32), escape(&temp.ty))?;\n+               Lvalue::Temp(i as u32), escape(&temp.ty))?;\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "514fc52d0085b8df8b1ab2d89f86475a0b4f8aae", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -255,7 +255,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // permission bits.\n         if let Some(ref s) = self.config.src {\n             io::copy(&mut File::open(s)?,\n-                          &mut File::create(&self.config.dst)?)?;\n+                     &mut File::create(&self.config.dst)?)?;\n         }\n \n         if removals.len() > 0 {\n@@ -272,7 +272,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 }\n                 Addition::Archive { archive, archive_name, mut skip } => {\n                     self.add_archive_members(&mut members, archive,\n-                                                  &archive_name, &mut *skip)?;\n+                                             &archive_name, &mut *skip)?;\n                 }\n             }\n         }"}, {"sha": "dd6856916f603fc72f50a143bed787c52f323300", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -976,7 +976,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let method_call = ty::MethodCall::expr(e.id);\n             let method = cx.tcx().tables.borrow().method_map[&method_call];\n             const_fn_call(cx, method.def_id, method.substs.clone(),\n-                               &arg_vals, param_substs, trueconst)?\n+                          &arg_vals, param_substs, trueconst)?\n         },\n         hir::ExprType(ref e, _) => const_expr(cx, &e, param_substs, fn_args, trueconst)?.0,\n         hir::ExprBlock(ref block) => {"}, {"sha": "67bd79bb57eb304574e44e2b425415a964a03ec6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -954,10 +954,10 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     }\n \n     let candidate = one_bound_for_assoc_type(tcx,\n-                                                  candidates,\n-                                                  &trait_ref.to_string(),\n-                                                  &binding.item_name.as_str(),\n-                                                  binding.span)?;\n+                                             candidates,\n+                                             &trait_ref.to_string(),\n+                                             &binding.item_name.as_str(),\n+                                             binding.span)?;\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n         projection_ty: ty::ProjectionTy {               //                           |"}, {"sha": "7dd5db831fd75f319d89aa2748f80b8d68f967c9", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -47,10 +47,10 @@ pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(tcx,\n-                                                               drop_impl_did,\n-                                                               dtor_generics,\n-                                                               &dtor_self_type,\n-                                                               adt_def.did)?;\n+                                                          drop_impl_did,\n+                                                          dtor_generics,\n+                                                          &dtor_self_type,\n+                                                          adt_def.did)?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n@@ -469,8 +469,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         ty::TyTuple(ref tys) |\n         ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n             for ty in tys {\n-                iterate_over_potentially_unsafe_regions_in_type(\n-                    cx, context, ty, depth+1)?\n+                iterate_over_potentially_unsafe_regions_in_type(cx, context, ty, depth+1)?\n             }\n             Ok(())\n         }"}, {"sha": "4e1f3d3cbb7a9cb4d3306dca8ef00b0afe36b118", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -354,17 +354,13 @@ pub fn check_crate(tcx: &TyCtxt, trait_map: ty::TraitMap) -> CompileResult {\n           coherence::check_coherence(&ccx));\n     })?;\n \n-    time(time_passes, \"wf checking\", ||\n-        check::check_wf_new(&ccx))?;\n+    time(time_passes, \"wf checking\", || check::check_wf_new(&ccx))?;\n \n-    time(time_passes, \"item-types checking\", ||\n-        check::check_item_types(&ccx))?;\n+    time(time_passes, \"item-types checking\", || check::check_item_types(&ccx))?;\n \n-    time(time_passes, \"item-bodies checking\", ||\n-        check::check_item_bodies(&ccx))?;\n+    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(&ccx))?;\n \n-    time(time_passes, \"drop-impl checking\", ||\n-        check::check_drop_impls(&ccx))?;\n+    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(&ccx))?;\n \n     check_for_entry_fn(&ccx);\n "}, {"sha": "e9a883d6d7a0139a161560cb9deacfcfa4706c58", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -344,9 +344,9 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n                         write!(w, \"<a class='mod'\n-                                            href='{}index.html'>{}</a>::\",\n-                                      root,\n-                                      seg.name)?;\n+                                       href='{}index.html'>{}</a>::\",\n+                                 root,\n+                                 seg.name)?;\n                     }\n                 }\n             }\n@@ -361,7 +361,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     match href(did) {\n         Some((url, shortty, fqp)) => {\n             write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                          shortty, url, fqp.join(\"::\"), last.name)?;\n+                   shortty, url, fqp.join(\"::\"), last.name)?;\n         }\n         _ => write!(w, \"{}\", last.name)?,\n     }\n@@ -379,8 +379,8 @@ fn primitive_link(f: &mut fmt::Formatter,\n             let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n             let len = if len == 0 {0} else {len - 1};\n             write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n-                        repeat(\"../\").take(len).collect::<String>(),\n-                        prim.to_url_str())?;\n+                   repeat(\"../\").take(len).collect::<String>(),\n+                   prim.to_url_str())?;\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n@@ -399,9 +399,9 @@ fn primitive_link(f: &mut fmt::Formatter,\n             match loc {\n                 Some(root) => {\n                     write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n-                                root,\n-                                path.0.first().unwrap(),\n-                                prim.to_url_str())?;\n+                           root,\n+                           path.0.first().unwrap(),\n+                           prim.to_url_str())?;\n                     needs_termination = true;\n                 }\n                 None => {}\n@@ -490,7 +490,7 @@ impl fmt::Display for clean::Type {\n                     }\n                     _ => {\n                         primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n-                                            &format!(\"*{}\", RawMutableSpace(m)))?;\n+                                       &format!(\"*{}\", RawMutableSpace(m)))?;\n                         write!(f, \"{}\", t)\n                     }\n                 }\n@@ -508,8 +508,7 @@ impl fmt::Display for clean::Type {\n                                 primitive_link(f, clean::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n                             _ => {\n-                                primitive_link(f, clean::Slice,\n-                                    &format!(\"&amp;{}{}[\", lt, m))?;\n+                                primitive_link(f, clean::Slice, &format!(\"&amp;{}{}[\", lt, m))?;\n                                 write!(f, \"{}\", **bt)?;\n                                 primitive_link(f, clean::Slice, \"]\")\n                             }\n@@ -567,8 +566,8 @@ impl fmt::Display for clean::Impl {\n         write!(f, \"impl{} \", self.generics)?;\n         if let Some(ref ty) = self.trait_ {\n             write!(f, \"{}{} for \",\n-                        if self.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" },\n-                        *ty)?;\n+                   if self.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" },\n+                   *ty)?;\n         }\n         write!(f, \"{}{}\", self.for_, WhereClause(&self.generics))?;\n         Ok(())"}, {"sha": "b3cad90ccb551ff4073f39a182c2bbeab0ce0a9b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -71,7 +71,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n             },\n             token::Comment => {\n                 write!(out, \"<span class='comment'>{}</span>\",\n-                            Escape(&snip(next.sp)))?;\n+                       Escape(&snip(next.sp)))?;\n                 continue\n             },\n             token::Shebang(s) => {\n@@ -180,8 +180,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         if klass == \"\" {\n             write!(out, \"{}\", Escape(&snip))?;\n         } else {\n-            write!(out, \"<span class='{}'>{}</span>\", klass,\n-                          Escape(&snip))?;\n+            write!(out, \"<span class='{}'>{}</span>\", klass, Escape(&snip))?;\n         }\n     }\n "}, {"sha": "9e74702e06c96b8bd9348db3bedc7d90d458850e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 136, "deletions": 137, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -630,45 +630,45 @@ fn write_shared(cx: &Context,\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n     write(cx.dst.join(\"jquery.js\"),\n-               include_bytes!(\"static/jquery-2.1.4.min.js\"))?;\n+          include_bytes!(\"static/jquery-2.1.4.min.js\"))?;\n     write(cx.dst.join(\"main.js\"),\n-               include_bytes!(\"static/main.js\"))?;\n+          include_bytes!(\"static/main.js\"))?;\n     write(cx.dst.join(\"playpen.js\"),\n-               include_bytes!(\"static/playpen.js\"))?;\n+          include_bytes!(\"static/playpen.js\"))?;\n     write(cx.dst.join(\"rustdoc.css\"),\n-               include_bytes!(\"static/rustdoc.css\"))?;\n+          include_bytes!(\"static/rustdoc.css\"))?;\n     write(cx.dst.join(\"main.css\"),\n-               include_bytes!(\"static/styles/main.css\"))?;\n+          include_bytes!(\"static/styles/main.css\"))?;\n     write(cx.dst.join(\"normalize.css\"),\n-               include_bytes!(\"static/normalize.css\"))?;\n+          include_bytes!(\"static/normalize.css\"))?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-               include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n+          include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n     write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-               include_bytes!(\"static/FiraSans-Medium.woff\"))?;\n+          include_bytes!(\"static/FiraSans-Medium.woff\"))?;\n     write(cx.dst.join(\"FiraSans-LICENSE.txt\"),\n-               include_bytes!(\"static/FiraSans-LICENSE.txt\"))?;\n+          include_bytes!(\"static/FiraSans-LICENSE.txt\"))?;\n     write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-               include_bytes!(\"static/Heuristica-Italic.woff\"))?;\n+          include_bytes!(\"static/Heuristica-Italic.woff\"))?;\n     write(cx.dst.join(\"Heuristica-LICENSE.txt\"),\n-               include_bytes!(\"static/Heuristica-LICENSE.txt\"))?;\n+          include_bytes!(\"static/Heuristica-LICENSE.txt\"))?;\n     write(cx.dst.join(\"SourceSerifPro-Regular.woff\"),\n-               include_bytes!(\"static/SourceSerifPro-Regular.woff\"))?;\n+          include_bytes!(\"static/SourceSerifPro-Regular.woff\"))?;\n     write(cx.dst.join(\"SourceSerifPro-Bold.woff\"),\n-               include_bytes!(\"static/SourceSerifPro-Bold.woff\"))?;\n+          include_bytes!(\"static/SourceSerifPro-Bold.woff\"))?;\n     write(cx.dst.join(\"SourceSerifPro-LICENSE.txt\"),\n-               include_bytes!(\"static/SourceSerifPro-LICENSE.txt\"))?;\n+          include_bytes!(\"static/SourceSerifPro-LICENSE.txt\"))?;\n     write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n-               include_bytes!(\"static/SourceCodePro-Regular.woff\"))?;\n+          include_bytes!(\"static/SourceCodePro-Regular.woff\"))?;\n     write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n-               include_bytes!(\"static/SourceCodePro-Semibold.woff\"))?;\n+          include_bytes!(\"static/SourceCodePro-Semibold.woff\"))?;\n     write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n-               include_bytes!(\"static/SourceCodePro-LICENSE.txt\"))?;\n+          include_bytes!(\"static/SourceCodePro-LICENSE.txt\"))?;\n     write(cx.dst.join(\"LICENSE-MIT.txt\"),\n-               include_bytes!(\"static/LICENSE-MIT.txt\"))?;\n+          include_bytes!(\"static/LICENSE-MIT.txt\"))?;\n     write(cx.dst.join(\"LICENSE-APACHE.txt\"),\n-               include_bytes!(\"static/LICENSE-APACHE.txt\"))?;\n+          include_bytes!(\"static/LICENSE-APACHE.txt\"))?;\n     write(cx.dst.join(\"COPYRIGHT.txt\"),\n-               include_bytes!(\"static/COPYRIGHT.txt\"))?;\n+          include_bytes!(\"static/COPYRIGHT.txt\"))?;\n \n     fn collect(path: &Path, krate: &str,\n                key: &str) -> io::Result<Vec<String>> {\n@@ -925,7 +925,7 @@ impl<'a> SourceCollector<'a> {\n             keywords: BASIC_KEYWORDS,\n         };\n         layout::render(&mut w, &self.cx.layout,\n-                            &page, &(\"\"), &Source(contents))?;\n+                       &page, &(\"\"), &Source(contents))?;\n         w.flush()?;\n         self.cx.local_sources.insert(p, href);\n         Ok(())\n@@ -1290,8 +1290,8 @@ impl Context {\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n                 layout::render(&mut writer, &cx.layout, &page,\n-                                    &Sidebar{ cx: cx, item: it },\n-                                    &Item{ cx: cx, item: it })?;\n+                               &Sidebar{ cx: cx, item: it },\n+                               &Item{ cx: cx, item: it })?;\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n@@ -1515,22 +1515,22 @@ impl<'a> fmt::Display for Item<'a> {\n             let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n-                            repeat(\"../\").take(cur.len() - i - 1)\n-                                         .collect::<String>(),\n-                            component)?;\n+                       repeat(\"../\").take(cur.len() - i - 1)\n+                                    .collect::<String>(),\n+                       component)?;\n             }\n         }\n         write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-                    shortty(self.item), self.item.name.as_ref().unwrap())?;\n+               shortty(self.item), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n         write!(fmt, \"<span class='out-of-band'>\")?;\n         write!(fmt,\n-        r##\"<span id='render-detail'>\n-            <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\">\n-                [<span class='inner'>&#x2212;</span>]\n-            </a>\n-        </span>\"##)?;\n+               r##\"<span id='render-detail'>\n+                   <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\">\n+                       [<span class='inner'>&#x2212;</span>]\n+                   </a>\n+               </span>\"##)?;\n \n         // Write `src` tag\n         //\n@@ -1541,8 +1541,8 @@ impl<'a> fmt::Display for Item<'a> {\n         if self.cx.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n                 write!(fmt, \"<a id='src-{}' class='srclink' \\\n-                                   href='{}' title='{}'>[src]</a>\",\n-                            self.item.def_id.index.as_usize(), l, \"goto source code\")?;\n+                              href='{}' title='{}'>[src]</a>\",\n+                       self.item.def_id.index.as_usize(), l, \"goto source code\")?;\n             }\n         }\n \n@@ -1698,30 +1698,30 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n             write!(w, \"<h2 id='{id}' class='section-header'>\\\n-                           <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                           id = derive_id(short.to_owned()), name = name)?;\n+                       <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n+                   id = derive_id(short.to_owned()), name = name)?;\n         }\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                                    VisSpace(myitem.visibility),\n-                                    src,\n-                                    name)?\n+                               VisSpace(myitem.visibility),\n+                               src,\n+                               name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                                    VisSpace(myitem.visibility), name)?\n+                               VisSpace(myitem.visibility), name)?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n             }\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                            VisSpace(myitem.visibility), *import)?;\n+                       VisSpace(myitem.visibility), *import)?;\n             }\n \n             _ => {\n@@ -1733,21 +1733,20 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 };\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \"\n-                    <tr class='{stab} module-item'>\n-                        <td><a class='{class}' href='{href}'\n-                               title='{title}'>{name}</a></td>\n-                        <td class='docblock short'>\n-                            {stab_docs} {docs}\n-                        </td>\n-                    </tr>\n-                \",\n-                name = *myitem.name.as_ref().unwrap(),\n-                stab_docs = stab_docs,\n-                docs = shorter(Some(&Markdown(doc_value).to_string())),\n-                class = shortty(myitem),\n-                stab = myitem.stability_class(),\n-                href = item_path(myitem),\n-                title = full_path(cx, myitem))?;\n+                       <tr class='{stab} module-item'>\n+                           <td><a class='{class}' href='{href}'\n+                                  title='{title}'>{name}</a></td>\n+                           <td class='docblock short'>\n+                               {stab_docs} {docs}\n+                           </td>\n+                       </tr>\",\n+                       name = *myitem.name.as_ref().unwrap(),\n+                       stab_docs = stab_docs,\n+                       docs = shorter(Some(&Markdown(doc_value).to_string())),\n+                       class = shortty(myitem),\n+                       stab = myitem.stability_class(),\n+                       href = item_path(myitem),\n+                       title = full_path(cx, myitem))?;\n             }\n         }\n     }\n@@ -1824,7 +1823,7 @@ impl<'a> fmt::Display for Initializer<'a> {\n fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>{vis}const \\\n-                    {name}: {typ}{init}</pre>\",\n+               {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n@@ -1835,7 +1834,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n-                    {name}: {typ}{init}</pre>\",\n+               {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n@@ -1851,7 +1850,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         _ => hir::Constness::NotConst\n     };\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n-                    {name}{generics}{decl}{where_clause}</pre>\",\n+               {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            constness = ConstnessSpace(vis_constness),\n            unsafety = UnsafetySpace(f.unsafety),\n@@ -1880,12 +1879,12 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n-                  VisSpace(it.visibility),\n-                  UnsafetySpace(t.unsafety),\n-                  it.name.as_ref().unwrap(),\n-                  t.generics,\n-                  bounds,\n-                  WhereClause(&t.generics))?;\n+           VisSpace(it.visibility),\n+           UnsafetySpace(t.unsafety),\n+           it.name.as_ref().unwrap(),\n+           t.generics,\n+           bounds,\n+           WhereClause(&t.generics))?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -1937,8 +1936,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         let name = m.name.as_ref().unwrap();\n         let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n         write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n-                       id = id,\n-                       stab = m.stability_class())?;\n+               id = id,\n+               stab = m.stability_class())?;\n         render_assoc_item(w, m, AssocItemLink::Anchor)?;\n         write!(w, \"</code>\")?;\n         render_stability_since(w, m, t)?;\n@@ -2009,17 +2008,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n     write!(w, \"</ul>\")?;\n     write!(w, r#\"<script type=\"text/javascript\" async\n-                              src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n-                      </script>\"#,\n-                root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n-                path = if it.def_id.is_local() {\n-                    cx.current.join(\"/\")\n-                } else {\n-                    let path = &cache.external_paths[&it.def_id];\n-                    path[..path.len() - 1].join(\"/\")\n-                },\n-                ty = shortty(it).to_static_str(),\n-                name = *it.name.as_ref().unwrap())?;\n+                         src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n+                 </script>\"#,\n+           root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n+           path = if it.def_id.is_local() {\n+               cx.current.join(\"/\")\n+           } else {\n+               let path = &cache.external_paths[&it.def_id];\n+               path[..path.len() - 1].join(\"/\")\n+           },\n+           ty = shortty(it).to_static_str(),\n+           name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n \n@@ -2054,7 +2053,7 @@ fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n     if let Some(v) = ver {\n         if containing_ver != ver && v.len() > 0 {\n             write!(w, \"<span class=\\\"since\\\">{}</span>\",\n-                        v)?\n+                   v)?\n         }\n     }\n     Ok(())\n@@ -2131,12 +2130,12 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"<pre class='rust struct'>\")?;\n     render_attributes(w, it)?;\n     render_struct(w,\n-                       it,\n-                       Some(&s.generics),\n-                       s.struct_type,\n-                       &s.fields,\n-                       \"\",\n-                       true)?;\n+                  it,\n+                  Some(&s.generics),\n+                  s.struct_type,\n+                  &s.fields,\n+                  \"\",\n+                  true)?;\n     write!(w, \"</pre>\")?;\n     render_stability_since_raw(w, it.stable_since(), None)?;\n \n@@ -2153,10 +2152,10 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\")?;\n             for field in fields {\n                 write!(w, \"<tr class='stab {stab}'>\n-                                  <td id='structfield.{name}'>\\\n-                                    <code>{name}</code></td><td>\",\n-                            stab = field.stability_class(),\n-                            name = field.name.as_ref().unwrap())?;\n+                             <td id='structfield.{name}'>\\\n+                               <code>{name}</code></td><td>\",\n+                       stab = field.stability_class(),\n+                       name = field.name.as_ref().unwrap())?;\n                 document(w, cx, field)?;\n                 write!(w, \"</td></tr>\")?;\n             }\n@@ -2171,10 +2170,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"{}enum {}{}{}\",\n-                  VisSpace(it.visibility),\n-                  it.name.as_ref().unwrap(),\n-                  e.generics,\n-                  WhereClause(&e.generics))?;\n+           VisSpace(it.visibility),\n+           it.name.as_ref().unwrap(),\n+           e.generics,\n+           WhereClause(&e.generics))?;\n     if e.variants.is_empty() && !e.variants_stripped {\n         write!(w, \" {{}}\")?;\n     } else {\n@@ -2198,12 +2197,12 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                         }\n                         clean::StructVariant(ref s) => {\n                             render_struct(w,\n-                                               v,\n-                                               None,\n-                                               s.struct_type,\n-                                               &s.fields,\n-                                               \"    \",\n-                                               false)?;\n+                                          v,\n+                                          None,\n+                                          s.struct_type,\n+                                          &s.fields,\n+                                          \"    \",\n+                                          false)?;\n                         }\n                     }\n                 }\n@@ -2225,7 +2224,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\")?;\n         for variant in &e.variants {\n             write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n-                          name = variant.name.as_ref().unwrap())?;\n+                   name = variant.name.as_ref().unwrap())?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n@@ -2237,13 +2236,13 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     }\n                 });\n                 write!(w, \"<h3 class='fields'>Fields</h3>\\n\n-                                  <table>\")?;\n+                           <table>\")?;\n                 for field in fields {\n                     write!(w, \"<tr><td \\\n-                                      id='variant.{v}.field.{f}'>\\\n-                                      <code>{f}</code></td><td>\",\n-                                  v = variant.name.as_ref().unwrap(),\n-                                  f = field.name.as_ref().unwrap())?;\n+                               id='variant.{v}.field.{f}'>\\\n+                               <code>{f}</code></td><td>\",\n+                           v = variant.name.as_ref().unwrap(),\n+                           f = field.name.as_ref().unwrap())?;\n                     document(w, cx, field)?;\n                     write!(w, \"</td></tr>\")?;\n                 }\n@@ -2281,9 +2280,9 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n     write!(w, \"{}{}{}\",\n-                  VisSpace(it.visibility),\n-                  if structhead {\"struct \"} else {\"\"},\n-                  it.name.as_ref().unwrap())?;\n+           VisSpace(it.visibility),\n+           if structhead {\"struct \"} else {\"\"},\n+           it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n         write!(w, \"{}{}\", *g, WhereClause(g))?\n     }\n@@ -2298,10 +2297,10 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     }\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n                         write!(w, \"    {}{}: {},\\n{}\",\n-                                      VisSpace(field.visibility),\n-                                      field.name.as_ref().unwrap(),\n-                                      *ty,\n-                                      tab)?;\n+                               VisSpace(field.visibility),\n+                               field.name.as_ref().unwrap(),\n+                               *ty,\n+                               tab)?;\n                     }\n                     _ => unreachable!(),\n                 };\n@@ -2369,13 +2368,13 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n             AssocItemRender::DerefFor { trait_, type_ } => {\n                 write!(w, \"<h2 id='deref-methods'>Methods from \\\n-                                    {}&lt;Target={}&gt;</h2>\", trait_, type_)?;\n+                               {}&lt;Target={}&gt;</h2>\", trait_, type_)?;\n                 false\n             }\n         };\n         for i in &non_trait {\n             render_impl(w, cx, i, AssocItemLink::Anchor, render_header,\n-                             containing_item.stable_since())?;\n+                        containing_item.stable_since())?;\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -2394,23 +2393,23 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             render_deref_methods(w, cx, impl_, containing_item)?;\n         }\n         write!(w, \"<h2 id='implementations'>Trait \\\n-                          Implementations</h2>\")?;\n+                   Implementations</h2>\")?;\n         let (derived, manual): (Vec<_>, Vec<&Impl>) = traits.iter().partition(|i| {\n             i.impl_.derived\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n             render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                             containing_item.stable_since())?;\n+                        containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n             write!(w, \"<h3 id='derived_implementations'>\\\n-                Derived Implementations \\\n-            </h3>\")?;\n+                           Derived Implementations \\\n+                       </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n                 render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                                 containing_item.stable_since())?;\n+                            containing_item.stable_since())?;\n             }\n         }\n     }\n@@ -2533,7 +2532,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             }\n \n             doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n-                              outer_version)?;\n+                         outer_version)?;\n         }\n         Ok(())\n     }\n@@ -2554,10 +2553,10 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n-                  it.name.as_ref().unwrap(),\n-                  t.generics,\n-                  where_clause = WhereClause(&t.generics),\n-                  type_ = t.type_)?;\n+           it.name.as_ref().unwrap(),\n+           t.generics,\n+           where_clause = WhereClause(&t.generics),\n+           type_ = t.type_)?;\n \n     document(w, cx, it)\n }\n@@ -2582,28 +2581,28 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                 write!(fmt, \"::<wbr>\")?;\n             }\n             write!(fmt, \"<a href='{}index.html'>{}</a>\",\n-                          &cx.root_path[..(cx.current.len() - i - 1) * 3],\n-                          *name)?;\n+                   &cx.root_path[..(cx.current.len() - i - 1) * 3],\n+                   *name)?;\n         }\n         write!(fmt, \"</p>\")?;\n \n         // sidebar refers to the enclosing module, not this module\n         let relpath = if it.is_mod() { \"../\" } else { \"\" };\n         write!(fmt,\n-                    \"<script>window.sidebarCurrent = {{\\\n-                        name: '{name}', \\\n-                        ty: '{ty}', \\\n-                        relpath: '{path}'\\\n-                     }};</script>\",\n-                    name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n-                    ty = shortty(it).to_static_str(),\n-                    path = relpath)?;\n+               \"<script>window.sidebarCurrent = {{\\\n+                   name: '{name}', \\\n+                   ty: '{ty}', \\\n+                   relpath: '{path}'\\\n+                }};</script>\",\n+               name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n+               ty = shortty(it).to_static_str(),\n+               path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path\n             // FIXME maybe dynamic crate loading can be merged here\n         } else {\n             write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n-                        path = relpath)?;\n+                   path = relpath)?;\n         }\n \n         Ok(())\n@@ -2633,8 +2632,8 @@ impl<'a> fmt::Display for Source<'a> {\n fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n     w.write_str(&highlight::highlight(&t.source,\n-                                          Some(\"macro\"),\n-                                          None))?;\n+                                      Some(\"macro\"),\n+                                      None))?;\n     render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }"}, {"sha": "305e6258baa41c31ee7f7910682c04569b782900", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -188,10 +188,10 @@ impl fmt::Display for Toc {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n             write!(fmt,\n-                        \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>{children}</li>\",\n-                        id = entry.id,\n-                        num = entry.sec_number, name = entry.name,\n-                        children = entry.children)?\n+                   \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>{children}</li>\",\n+                   id = entry.id,\n+                   num = entry.sec_number, name = entry.name,\n+                   children = entry.children)?\n         }\n         write!(fmt, \"</ul>\")\n     }"}, {"sha": "d5d967114c407f1101ae39c2035241cabaa3969d", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -49,7 +49,7 @@ pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n         cvt(c::setsockopt(*sock.as_inner(), opt, val, payload,\n-                               mem::size_of::<T>() as c::socklen_t))?;\n+                          mem::size_of::<T>() as c::socklen_t))?;\n         Ok(())\n     }\n }\n@@ -60,8 +60,8 @@ pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as c::socklen_t;\n         cvt(c::getsockopt(*sock.as_inner(), opt, val,\n-                               &mut slot as *mut _ as *mut _,\n-                               &mut len))?;\n+                          &mut slot as *mut _ as *mut _,\n+                          &mut len))?;\n         assert_eq!(len as usize, mem::size_of::<T>());\n         Ok(slot)\n     }\n@@ -147,7 +147,7 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     let mut res = ptr::null_mut();\n     unsafe {\n         cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n-                                   &mut res))?;\n+                               &mut res))?;\n         Ok(LookupHost { original: res, cur: res })\n     }\n }\n@@ -308,7 +308,7 @@ impl TcpListener {\n         // the OS to clean up the previous one.\n         if !cfg!(windows) {\n             setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\n-                            1 as c_int)?;\n+                       1 as c_int)?;\n         }\n \n         // Bind our new socket\n@@ -334,7 +334,7 @@ impl TcpListener {\n         let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut len = mem::size_of_val(&storage) as c::socklen_t;\n         let sock = self.inner.accept(&mut storage as *mut _ as *mut _,\n-                                          &mut len)?;\n+                                     &mut len)?;\n         let addr = sockaddr_to_addr(&storage, len as usize)?;\n         Ok((TcpStream { inner: sock, }, addr))\n     }"}, {"sha": "a74f7ea13b4157cbd15ab7d811e8dbf77e9c833d", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -642,11 +642,11 @@ impl UnixDatagram {\n                 let (addr, len) = sockaddr_un(path)?;\n \n                 let count = cvt(libc::sendto(*d.0.as_inner(),\n-                                                  buf.as_ptr() as *const _,\n-                                                  buf.len(),\n-                                                  0,\n-                                                  &addr as *const _ as *const _,\n-                                                  len))?;\n+                                             buf.as_ptr() as *const _,\n+                                             buf.len(),\n+                                             0,\n+                                             &addr as *const _ as *const _,\n+                                             len))?;\n                 Ok(count as usize)\n             }\n         }"}, {"sha": "eed62c9ecfd1588080ec3ba125fe906cf280cfd7", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -181,15 +181,15 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        -1 as c_int];\n         let mut sz: libc::size_t = 0;\n         cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                              ptr::null_mut(), &mut sz, ptr::null_mut(),\n-                              0 as libc::size_t))?;\n+                         ptr::null_mut(), &mut sz, ptr::null_mut(),\n+                         0 as libc::size_t))?;\n         if sz == 0 {\n             return Err(io::Error::last_os_error())\n         }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n         cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                              v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n-                              ptr::null_mut(), 0 as libc::size_t))?;\n+                         v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n+                         ptr::null_mut(), 0 as libc::size_t))?;\n         if sz == 0 {\n             return Err(io::Error::last_os_error());\n         }\n@@ -218,10 +218,10 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         let mib = mib.as_mut_ptr();\n         let mut argv_len = 0;\n         cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n-                              0 as *mut _, 0))?;\n+                         0 as *mut _, 0))?;\n         let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n-                              &mut argv_len, 0 as *mut _, 0))?;\n+                         &mut argv_len, 0 as *mut _, 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n             return Err(io::Error::new(io::ErrorKind::Other,"}, {"sha": "6f56f3ade065a482d9c36d676491cf5df0c21b61", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -392,7 +392,7 @@ impl Command {\n             let mut set: libc::sigset_t = mem::uninitialized();\n             t!(cvt(libc::sigemptyset(&mut set)));\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                           ptr::null_mut())));\n+                                         ptr::null_mut())));\n             let ret = libc::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n                 return io::Error::last_os_error()"}, {"sha": "529e42248f6a2c47b7fb8f8c1f608b746373785d", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -290,7 +290,7 @@ impl File {\n         unsafe {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n             cvt(c::GetFileInformationByHandle(self.handle.raw(),\n-                                                   &mut info))?;\n+                                              &mut info))?;\n             let mut attr = FileAttr {\n                 attributes: info.dwFileAttributes,\n                 creation_time: info.ftCreationTime,"}, {"sha": "f4957297581bb93f3ebbf0cd6747f3ac2ab09afa", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -188,9 +188,9 @@ impl Command {\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n         let stdin = stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin)?;\n         let stdout = stdout.to_handle(c::STD_OUTPUT_HANDLE,\n-                                           &mut pipes.stdout)?;\n+                                      &mut pipes.stdout)?;\n         let stderr = stderr.to_handle(c::STD_ERROR_HANDLE,\n-                                           &mut pipes.stderr)?;\n+                                      &mut pipes.stderr)?;\n         si.hStdInput = stdin.raw();\n         si.hStdOutput = stdout.raw();\n         si.hStdError = stderr.raw();"}, {"sha": "804ca6705ecbb5e9f589321de71f7c835723d0ea", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -530,51 +530,51 @@ impl Encodable for FileMap {\n             s.emit_struct_field(\"start_pos\", 1, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 2, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 3, |s| {\n-                    let lines = self.lines.borrow();\n-                    // store the length\n-                    s.emit_u32(lines.len() as u32)?;\n-\n-                    if !lines.is_empty() {\n-                        // In order to preserve some space, we exploit the fact that\n-                        // the lines list is sorted and individual lines are\n-                        // probably not that long. Because of that we can store lines\n-                        // as a difference list, using as little space as possible\n-                        // for the differences.\n-                        let max_line_length = if lines.len() == 1 {\n-                            0\n-                        } else {\n-                            lines.windows(2)\n-                                 .map(|w| w[1] - w[0])\n-                                 .map(|bp| bp.to_usize())\n-                                 .max()\n-                                 .unwrap()\n-                        };\n-\n-                        let bytes_per_diff: u8 = match max_line_length {\n-                            0 ... 0xFF => 1,\n-                            0x100 ... 0xFFFF => 2,\n-                            _ => 4\n-                        };\n-\n-                        // Encode the number of bytes used per diff.\n-                        bytes_per_diff.encode(s)?;\n-\n-                        // Encode the first element.\n-                        lines[0].encode(s)?;\n-\n-                        let diff_iter = (&lines[..]).windows(2)\n-                                                    .map(|w| (w[1] - w[0]));\n-\n-                        match bytes_per_diff {\n-                            1 => for diff in diff_iter { (diff.0 as u8).encode(s)? },\n-                            2 => for diff in diff_iter { (diff.0 as u16).encode(s)? },\n-                            4 => for diff in diff_iter { diff.0.encode(s)? },\n-                            _ => unreachable!()\n-                        }\n+                let lines = self.lines.borrow();\n+                // store the length\n+                s.emit_u32(lines.len() as u32)?;\n+\n+                if !lines.is_empty() {\n+                    // In order to preserve some space, we exploit the fact that\n+                    // the lines list is sorted and individual lines are\n+                    // probably not that long. Because of that we can store lines\n+                    // as a difference list, using as little space as possible\n+                    // for the differences.\n+                    let max_line_length = if lines.len() == 1 {\n+                        0\n+                    } else {\n+                        lines.windows(2)\n+                             .map(|w| w[1] - w[0])\n+                             .map(|bp| bp.to_usize())\n+                             .max()\n+                             .unwrap()\n+                    };\n+\n+                    let bytes_per_diff: u8 = match max_line_length {\n+                        0 ... 0xFF => 1,\n+                        0x100 ... 0xFFFF => 2,\n+                        _ => 4\n+                    };\n+\n+                    // Encode the number of bytes used per diff.\n+                    bytes_per_diff.encode(s)?;\n+\n+                    // Encode the first element.\n+                    lines[0].encode(s)?;\n+\n+                    let diff_iter = (&lines[..]).windows(2)\n+                                                .map(|w| (w[1] - w[0]));\n+\n+                    match bytes_per_diff {\n+                        1 => for diff in diff_iter { (diff.0 as u8).encode(s)? },\n+                        2 => for diff in diff_iter { (diff.0 as u16).encode(s)? },\n+                        4 => for diff in diff_iter { diff.0.encode(s)? },\n+                        _ => unreachable!()\n                     }\n+                }\n \n-                    Ok(())\n-                })?;\n+                Ok(())\n+            })?;\n             s.emit_struct_field(\"multibyte_chars\", 4, |s| {\n                 (*self.multibyte_chars.borrow()).encode(s)\n             })\n@@ -590,33 +590,33 @@ impl Decodable for FileMap {\n             let start_pos: BytePos = d.read_struct_field(\"start_pos\", 1, |d| Decodable::decode(d))?;\n             let end_pos: BytePos = d.read_struct_field(\"end_pos\", 2, |d| Decodable::decode(d))?;\n             let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 3, |d| {\n-                    let num_lines: u32 = Decodable::decode(d)?;\n-                    let mut lines = Vec::with_capacity(num_lines as usize);\n+                let num_lines: u32 = Decodable::decode(d)?;\n+                let mut lines = Vec::with_capacity(num_lines as usize);\n+\n+                if num_lines > 0 {\n+                    // Read the number of bytes used per diff.\n+                    let bytes_per_diff: u8 = Decodable::decode(d)?;\n+\n+                    // Read the first element.\n+                    let mut line_start: BytePos = Decodable::decode(d)?;\n+                    lines.push(line_start);\n+\n+                    for _ in 1..num_lines {\n+                        let diff = match bytes_per_diff {\n+                            1 => d.read_u8()? as u32,\n+                            2 => d.read_u16()? as u32,\n+                            4 => d.read_u32()?,\n+                            _ => unreachable!()\n+                        };\n \n-                    if num_lines > 0 {\n-                        // Read the number of bytes used per diff.\n-                        let bytes_per_diff: u8 = Decodable::decode(d)?;\n+                        line_start = line_start + BytePos(diff);\n \n-                        // Read the first element.\n-                        let mut line_start: BytePos = Decodable::decode(d)?;\n                         lines.push(line_start);\n-\n-                        for _ in 1..num_lines {\n-                            let diff = match bytes_per_diff {\n-                                1 => d.read_u8()? as u32,\n-                                2 => d.read_u16()? as u32,\n-                                4 => d.read_u32()?,\n-                                _ => unreachable!()\n-                            };\n-\n-                            line_start = line_start + BytePos(diff);\n-\n-                            lines.push(line_start);\n-                        }\n                     }\n+                }\n \n-                    Ok(lines)\n-                })?;\n+                Ok(lines)\n+            })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n                 d.read_struct_field(\"multibyte_chars\", 4, |d| Decodable::decode(d))?;\n             Ok(FileMap {"}, {"sha": "61fdc8453d8fdf63853c7cce40855ceb077ba1cc", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -208,8 +208,8 @@ impl EmitterWriter {\n             if let Some(_) = self.registry.as_ref()\n                                           .and_then(|registry| registry.find_description(code)) {\n                 print_diagnostic(&mut self.dst, &ss[..], Help,\n-                                      &format!(\"run `rustc --explain {}` to see a \\\n-                                               detailed explanation\", code), None)?;\n+                                 &format!(\"run `rustc --explain {}` to see a \\\n+                                           detailed explanation\", code), None)?;\n             }\n         }\n         Ok(())\n@@ -234,13 +234,13 @@ impl EmitterWriter {\n         let mut lines = complete.lines();\n         for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n             write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                        fm.name, \"\", max_digits, line)?;\n+                   fm.name, \"\", max_digits, line)?;\n         }\n \n         // if we elided some lines, add an ellipsis\n         if let Some(_) = lines.next() {\n             write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                        \"\", fm.name.len(), max_digits)?;\n+                   \"\", fm.name.len(), max_digits)?;\n         }\n \n         Ok(())\n@@ -424,15 +424,15 @@ impl EmitterWriter {\n             // Print offending code-line\n             remaining_err_lines -= 1;\n             write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n-                        fm.name,\n-                        line.line_index + 1,\n-                        cur_line_str,\n-                        width=digits)?;\n+                   fm.name,\n+                   line.line_index + 1,\n+                   cur_line_str,\n+                   width=digits)?;\n \n             if s.len() > skip {\n                 // Render the spans we assembled previously (if any).\n                 println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                           \"{}\", s)?;\n+                                      \"{}\", s)?;\n             }\n \n             if !overflowed_buf.is_empty() {\n@@ -561,13 +561,13 @@ impl EmitterWriter {\n \n             // Print offending code-lines\n             write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n-                        line.line_index + 1, line_str, width=digits)?;\n+                   line.line_index + 1, line_str, width=digits)?;\n             remaining_err_lines -= 1;\n \n             if s.len() > skip {\n                 // Render the spans we assembled previously (if any)\n                 println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                           \"{}\", s)?;\n+                                      \"{}\", s)?;\n             }\n             prev_line_index = line.line_index;\n         }\n@@ -642,7 +642,7 @@ fn print_diagnostic(dst: &mut Destination,\n     }\n \n     print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n-                             \"{}: \", lvl.to_string())?;\n+                        \"{}: \", lvl.to_string())?;\n     print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg)?;\n \n     if let Some(code) = code {"}, {"sha": "a1adc99055f081a7dda5a27c9a464918ebd1908b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -834,7 +834,7 @@ impl<'a> Parser<'a> {\n         F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let (result, returned) = self.parse_seq_to_before_gt_or_return(sep,\n-                                                    |p| Ok(Some(f(p)?)))?;\n+                                                                       |p| Ok(Some(f(p)?)))?;\n         assert!(!returned);\n         return Ok(result);\n     }\n@@ -1476,8 +1476,8 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let delim = self.expect_open_delim()?;\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                     SeqSep::none(),\n-                                                     |p| p.parse_token_tree())?;\n+                                                SeqSep::none(),\n+                                                |p| p.parse_token_tree())?;\n                 let hi = self.span.hi;\n                 TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n             } else {\n@@ -2225,7 +2225,7 @@ impl<'a> Parser<'a> {\n                             &token::CloseDelim(token::Bracket),\n                             SeqSep::trailing_allowed(token::Comma),\n                             |p| Ok(p.parse_expr()?)\n-                                )?;\n+                        )?;\n                         let mut exprs = vec!(first_expr);\n                         exprs.extend(remaining_exprs);\n                         ex = ExprKind::Vec(exprs);\n@@ -2610,8 +2610,8 @@ impl<'a> Parser<'a> {\n \n                     let dot_pos = self.last_span.hi;\n                     e = self.parse_dot_suffix(special_idents::invalid,\n-                                                   mk_sp(dot_pos, dot_pos),\n-                                                   e, lo)?;\n+                                              mk_sp(dot_pos, dot_pos),\n+                                              e, lo)?;\n                   }\n                 }\n                 continue;\n@@ -3267,7 +3267,7 @@ impl<'a> Parser<'a> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n-                                                    None)?;\n+                                               None)?;\n         if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n                                                        token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3612,8 +3612,9 @@ impl<'a> Parser<'a> {\n                         let path = ident_to_path(ident_span, ident);\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                SeqSep::none(), |p| p.parse_token_tree())?;\n+                        let tts = self.parse_seq_to_end(\n+                            &token::CloseDelim(delim),\n+                            SeqSep::none(), |p| p.parse_token_tree())?;\n                         let mac = Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT };\n                         pat = PatKind::Mac(codemap::Spanned {node: mac,\n                                                        span: mk_sp(lo, self.last_span.hi)});\n@@ -3670,10 +3671,10 @@ impl<'a> Parser<'a> {\n                             pat = PatKind::TupleStruct(path, None);\n                         } else {\n                             let args = self.parse_enum_variant_seq(\n-                                    &token::OpenDelim(token::Paren),\n-                                    &token::CloseDelim(token::Paren),\n-                                    SeqSep::trailing_allowed(token::Comma),\n-                                    |p| p.parse_pat())?;\n+                                &token::OpenDelim(token::Paren),\n+                                &token::CloseDelim(token::Paren),\n+                                SeqSep::trailing_allowed(token::Comma),\n+                                |p| p.parse_pat())?;\n                             pat = PatKind::TupleStruct(path, Some(args));\n                         }\n                       }\n@@ -3963,7 +3964,7 @@ impl<'a> Parser<'a> {\n             // FIXME: Bad copy of attrs\n             let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n             match self.with_res(restrictions,\n-                                     |this| this.parse_item_(attrs.clone(), false, true))? {\n+                                |this| this.parse_item_(attrs.clone(), false, true))? {\n                 Some(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclKind::Item(i)));\n@@ -4941,8 +4942,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                 SeqSep::none(),\n-                                                 |p| p.parse_token_tree())?;\n+                                            SeqSep::none(),\n+                                            |p| p.parse_token_tree())?;\n             let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n                                                 span: mk_sp(lo,\n@@ -5409,8 +5410,8 @@ impl<'a> Parser<'a> {\n                     id_sp: Span)\n                     -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let ModulePathSuccess { path, owns_directory } = self.submod_path(id,\n-                                                                               outer_attrs,\n-                                                                               id_sp)?;\n+                                                                          outer_attrs,\n+                                                                          id_sp)?;\n \n         self.eval_src_mod_from_path(path,\n                                     owns_directory,\n@@ -5993,8 +5994,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                 SeqSep::none(),\n-                                                 |p| p.parse_token_tree())?;\n+                                            SeqSep::none(),\n+                                            |p| p.parse_token_tree())?;\n             // single-variant-enum... :\n             let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m,"}, {"sha": "5b06eb026d6969f968f8becbff7ef7163d67bfe4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -388,7 +388,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n-                        generics, opt_explicit_self, ast::Visibility::Inherited)?;\n+                   generics, opt_explicit_self, ast::Visibility::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -779,8 +779,8 @@ pub trait PrintState<'a> {\n                 word(self.writer(), &name)?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n-                                   &items[..],\n-                                   |s, i| s.print_meta_item(&i))?;\n+                              &items[..],\n+                              |s, i| s.print_meta_item(&i))?;\n                 self.pclose()?;\n             }\n         }\n@@ -915,7 +915,7 @@ impl<'a> State<'a> {\n             if i < len {\n                 word(&mut self.s, \",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt),\n-                                                    Some(get_span(&elts[i]).hi))?;\n+                                                  Some(get_span(&elts[i]).hi))?;\n                 self.space_if_not_bol()?;\n             }\n         }\n@@ -979,7 +979,7 @@ impl<'a> State<'a> {\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..],\n-                                   |s, ty| s.print_type(&ty))?;\n+                              |s, ty| s.print_type(&ty))?;\n                 if elts.len() == 1 {\n                     word(&mut self.s, \",\")?;\n                 }\n@@ -1000,11 +1000,11 @@ impl<'a> State<'a> {\n                     },\n                 };\n                 self.print_ty_fn(f.abi,\n-                                      f.unsafety,\n-                                      &f.decl,\n-                                      None,\n-                                      &generics,\n-                                      None)?;\n+                                 f.unsafety,\n+                                 &f.decl,\n+                                 None,\n+                                 &generics,\n+                                 None)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n                 self.print_path(path, false, 0)?;\n@@ -1050,16 +1050,15 @@ impl<'a> State<'a> {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl, ast::Unsafety::Normal,\n-                                   ast::Constness::NotConst,\n-                                   Abi::Rust, Some(item.ident),\n-                                   generics, None, item.vis)?;\n+                              ast::Constness::NotConst,\n+                              Abi::Rust, Some(item.ident),\n+                              generics, None, item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                    \"static\"))?;\n+                self.head(&visibility_qualified(item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1119,8 +1118,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n             ast::ItemKind::ExternCrate(ref optional_path) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                     \"extern crate\"))?;\n+                self.head(&visibility_qualified(item.vis, \"extern crate\"))?;\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n@@ -1138,16 +1136,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Use(ref vp) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                     \"use\"))?;\n+                self.head(&visibility_qualified(item.vis, \"use\"))?;\n                 self.print_view_path(&vp)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Static(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                    \"static\"))?;\n+                self.head(&visibility_qualified(item.vis, \"static\"))?;\n                 if m == ast::Mutability::Mutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -1163,8 +1159,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                    \"const\"))?;\n+                self.head(&visibility_qualified(item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -1192,8 +1187,7 @@ impl<'a> State<'a> {\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(&visibility_qualified(item.vis,\n-                                                    \"mod\"))?;\n+                self.head(&visibility_qualified(item.vis, \"mod\"))?;\n                 self.print_ident(item.ident)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -1555,8 +1549,8 @@ impl<'a> State<'a> {\n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n                 self.print_associated_const(ti.ident, &ty,\n-                                                 default.as_ref().map(|expr| &**expr),\n-                                                 ast::Visibility::Inherited)?;\n+                                            default.as_ref().map(|expr| &**expr),\n+                                            ast::Visibility::Inherited)?;\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 if body.is_some() {\n@@ -1572,7 +1566,7 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Type(ref bounds, ref default) => {\n                 self.print_associated_type(ti.ident, Some(bounds),\n-                                                default.as_ref().map(|ty| &**ty))?;\n+                                           default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n         self.ann.post(self, NodeSubItem(ti.id))\n@@ -1923,7 +1917,7 @@ impl<'a> State<'a> {\n         if !tys.is_empty() {\n             word(&mut self.s, \"::<\")?;\n             self.commasep(Inconsistent, tys,\n-                               |s, ty| s.print_type(&ty))?;\n+                          |s, ty| s.print_type(&ty))?;\n             word(&mut self.s, \">\")?;\n         }\n         self.print_call_post(base_args)\n@@ -2223,7 +2217,7 @@ impl<'a> State<'a> {\n                     match out.constraint.slice_shift_char() {\n                         Some(('=', operand)) if out.is_rw => {\n                             s.print_string(&format!(\"+{}\", operand),\n-                                                ast::StrStyle::Cooked)?\n+                                           ast::StrStyle::Cooked)?\n                         }\n                         _ => s.print_string(&out.constraint, ast::StrStyle::Cooked)?\n                     }\n@@ -2267,10 +2261,10 @@ impl<'a> State<'a> {\n                     space(&mut self.s)?;\n                     self.word_space(\":\")?;\n                     self.commasep(Inconsistent, &options,\n-                                       |s, &co| {\n-                        s.print_string(co, ast::StrStyle::Cooked)?;\n-                        Ok(())\n-                    })?;\n+                                  |s, &co| {\n+                                      s.print_string(co, ast::StrStyle::Cooked)?;\n+                                      Ok(())\n+                                  })?;\n                 }\n \n                 self.pclose()?;\n@@ -3037,13 +3031,13 @@ impl<'a> State<'a> {\n             },\n         };\n         self.print_fn(decl,\n-                           unsafety,\n-                           ast::Constness::NotConst,\n-                           abi,\n-                           name,\n-                           &generics,\n-                           opt_explicit_self,\n-                           ast::Visibility::Inherited)?;\n+                      unsafety,\n+                      ast::Constness::NotConst,\n+                      abi,\n+                      name,\n+                      &generics,\n+                      opt_explicit_self,\n+                      ast::Visibility::Inherited)?;\n         self.end()\n     }\n "}, {"sha": "2c734c8e3e4d4cbeac69ea5b266695df6d8eea95", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -96,8 +96,8 @@ impl Formatter for HTMLFormatter {\n \n         // Error title (with self-link).\n         write!(output,\n-                    \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n-                    err_code)?;\n+               \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n+               err_code)?;\n \n         // Description rendered as markdown.\n         match info.description {"}, {"sha": "6014439fafcf9661cfe981a515bea5558f8c58a4", "filename": "src/tools/rustbook/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Ftools%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0/src%2Ftools%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fbuild.rs?ref=2628f3cc8f91a52d9dcc800afb6c4a7dc0c785e0", "patch": "@@ -56,10 +56,10 @@ fn write_toc(book: &Book, current_page: &BookItem, out: &mut Write) -> io::Resul\n         };\n \n         writeln!(out, \"<li><a {} href='{}'><b>{}</b> {}</a>\",\n-                      class_string,\n-                      current_page.path_to_root.join(&item.path).with_extension(\"html\").display(),\n-                      section,\n-                      item.title)?;\n+                 class_string,\n+                 current_page.path_to_root.join(&item.path).with_extension(\"html\").display(),\n+                 section,\n+                 item.title)?;\n         if !item.children.is_empty() {\n             writeln!(out, \"<ul class='section'>\")?;\n             let _ = walk_items(&item.children[..], section, current_page, out);"}]}