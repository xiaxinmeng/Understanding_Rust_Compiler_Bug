{"sha": "6e25418474ae9961e50bd3ff076d80a3ec728531", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMjU0MTg0NzRhZTk5NjFlNTBiZDNmZjA3NmQ4MGEzZWM3Mjg1MzE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-04T02:44:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-04T02:44:49Z"}, "message": "Rollup merge of #75143 - oli-obk:tracing, r=RalfJung\n\nUse `tracing` spans to trace the entire MIR interp stack\n\nr? @RalfJung\n\nWhile being very verbose, this allows really good tracking of what's going on. While I considered schemes like the previous indenter that we had (which we could get by using the `tracing-tree` crate), this will break down horribly with things like multithreaded rustc. Instead, we can now use `RUSTC_LOG` to restrict the things being traced. You could specify a filter in a way that only shows the logging of a specific frame.\n\n![screenshot of command line output of the new formatting](https://user-images.githubusercontent.com/332036/89291343-aa40de00-d65a-11ea-9f6c-ea06c1806327.png)\n\nIf we lower the span's level to `debug`, then in `info` level logging we'd not see the frames, but in `debug` level we would see them. The filtering rules in `tracing` are super powerful, but  I'm not sure if we can specify a filter so we do see `debug` level events, but *not* the `frame` spans. The documentation at https://docs.rs/tracing-subscriber/0.2.10/tracing_subscriber/struct.EnvFilter.html makes me think that we can only turn on things, not turn off things at a more precise level.\n\ncc @hawkw", "tree": {"sha": "46e2dfce32305e2ada94db72b02a93e2fba83a02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e2dfce32305e2ada94db72b02a93e2fba83a02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e25418474ae9961e50bd3ff076d80a3ec728531", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfeTchCRBK7hj4Ov3rIwAAdHIIALFXWMNRLlGjnH63QOvGHNBH\n31f+C4aymNSD/+y42WwDXw0vayEGYXEdgCFH+xtB9wFu+oFoIdLJgWHjpjIZFzBZ\nN7vdxG7WRwagwi0WHQuJeSfvU7RUjiNPn6+L22BVo5sa1DjyVwF0R36Ch7PkLUO9\nlAxtetd6dToWwwp8qOANxm/dHH3ygTVDf9oqz1mif+pRy/oPAjELT+fJctGG2yi8\ne6TNA3y+Uc6IhzOnSCUlL85f8Vp9/G9avD48kX0zTjm0BfujEHjgB/8CBo0LhH7p\nQs2pPlIZX9SPxFYEZfaz1mCJa7vV79aDuMPLYZ+B4bOhSwtIVlJtqyR4AsAgQp8=\n=KzHL\n-----END PGP SIGNATURE-----\n", "payload": "tree 46e2dfce32305e2ada94db72b02a93e2fba83a02\nparent bad9ad06c00141114900c41750e961574f2ecc15\nparent 8f9472cc9e372351964390bdf531cc65b13768c7\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601779489 +0900\ncommitter GitHub <noreply@github.com> 1601779489 +0900\n\nRollup merge of #75143 - oli-obk:tracing, r=RalfJung\n\nUse `tracing` spans to trace the entire MIR interp stack\n\nr? @RalfJung\n\nWhile being very verbose, this allows really good tracking of what's going on. While I considered schemes like the previous indenter that we had (which we could get by using the `tracing-tree` crate), this will break down horribly with things like multithreaded rustc. Instead, we can now use `RUSTC_LOG` to restrict the things being traced. You could specify a filter in a way that only shows the logging of a specific frame.\n\n![screenshot of command line output of the new formatting](https://user-images.githubusercontent.com/332036/89291343-aa40de00-d65a-11ea-9f6c-ea06c1806327.png)\n\nIf we lower the span's level to `debug`, then in `info` level logging we'd not see the frames, but in `debug` level we would see them. The filtering rules in `tracing` are super powerful, but  I'm not sure if we can specify a filter so we do see `debug` level events, but *not* the `frame` spans. The documentation at https://docs.rs/tracing-subscriber/0.2.10/tracing_subscriber/struct.EnvFilter.html makes me think that we can only turn on things, not turn off things at a more precise level.\n\ncc @hawkw\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e25418474ae9961e50bd3ff076d80a3ec728531", "html_url": "https://github.com/rust-lang/rust/commit/6e25418474ae9961e50bd3ff076d80a3ec728531", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e25418474ae9961e50bd3ff076d80a3ec728531/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad9ad06c00141114900c41750e961574f2ecc15", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad9ad06c00141114900c41750e961574f2ecc15", "html_url": "https://github.com/rust-lang/rust/commit/bad9ad06c00141114900c41750e961574f2ecc15"}, {"sha": "8f9472cc9e372351964390bdf531cc65b13768c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f9472cc9e372351964390bdf531cc65b13768c7", "html_url": "https://github.com/rust-lang/rust/commit/8f9472cc9e372351964390bdf531cc65b13768c7"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "fb7d2a4ac2fc60216707f83995b94cfa68dbd0f6", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -1726,15 +1726,6 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n-[[package]]\n-name = \"log_settings\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"19af41f0565d7c19b2058153ad0b42d4d5ce89ec4dbf06ed6741114a8b63e7cd\"\n-dependencies = [\n- \"lazy_static\",\n-]\n-\n [[package]]\n name = \"lsp-codec\"\n version = \"0.1.2\"\n@@ -3523,6 +3514,7 @@ dependencies = [\n  \"rustc_target\",\n  \"tracing\",\n  \"tracing-subscriber\",\n+ \"tracing-tree\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -3810,7 +3802,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"either\",\n  \"itertools 0.9.0\",\n- \"log_settings\",\n  \"polonius-engine\",\n  \"regex\",\n  \"rustc_apfloat\",\n@@ -5105,9 +5096,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-tree\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e1a3dc4774db3a6b2d66a4f8d8de670e874ec3ed55615860c994927419b32c5f\"\n+checksum = \"43aac8afb493b08e1e1904956f7407c1e671b9c83b26a17e1bd83d6a3520e350\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n  \"atty\","}, {"sha": "f610e88b7fce5fe7cee95c9179fc6ba151bdbe8b", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -11,6 +11,7 @@ crate-type = [\"dylib\"]\n libc = \"0.2\"\n tracing = { version = \"0.1.18\" }\n tracing-subscriber = { version = \"0.2.10\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n+tracing-tree = \"0.1.6\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "3f50c68e3ebf54ff3b93d0fafcef306c3db2301c", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -1251,11 +1251,21 @@ pub fn init_env_logger(env: &str) {\n         Ok(s) if s.is_empty() => return,\n         Ok(_) => {}\n     }\n-    let builder = tracing_subscriber::FmtSubscriber::builder();\n-\n-    let builder = builder.with_env_filter(tracing_subscriber::EnvFilter::from_env(env));\n-\n-    builder.init()\n+    let filter = tracing_subscriber::EnvFilter::from_env(env);\n+    let layer = tracing_tree::HierarchicalLayer::default()\n+        .with_indent_lines(true)\n+        .with_ansi(true)\n+        .with_targets(true)\n+        .with_thread_ids(true)\n+        .with_thread_names(true)\n+        .with_wraparound(10)\n+        .with_verbose_exit(true)\n+        .with_verbose_entry(true)\n+        .with_indent_amount(2);\n+\n+    use tracing_subscriber::layer::SubscriberExt;\n+    let subscriber = tracing_subscriber::Registry::default().with(filter).with(layer);\n+    tracing::subscriber::set_global_default(subscriber).unwrap();\n }\n \n pub fn main() -> ! {"}, {"sha": "487668cfa1109476ccc6449d32718a20e8e49ce1", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -12,7 +12,6 @@ either = \"1.5.0\"\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n itertools = \"0.9\"\n tracing = \"0.1\"\n-log_settings = \"0.1.1\"\n polonius-engine = \"0.12.0\"\n regex = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "93da6e3d38a93c71df5a1491dda6cf2eae02b893", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -48,8 +48,41 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n         FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n }\n \n+// The Phantomdata exists to prevent this type from being `Send`. If it were sent across a thread\n+// boundary and dropped in the other thread, it would exit the span in the other thread.\n+struct SpanGuard(tracing::Span, std::marker::PhantomData<*const u8>);\n+\n+impl SpanGuard {\n+    /// By default a `SpanGuard` does nothing.\n+    fn new() -> Self {\n+        Self(tracing::Span::none(), std::marker::PhantomData)\n+    }\n+\n+    /// If a span is entered, we exit the previous span (if any, normally none) and enter the\n+    /// new span. This is mainly so we don't have to use `Option` for the `tracing_span` field of\n+    /// `Frame` by creating a dummy span to being with and then entering it once the frame has\n+    /// been pushed.\n+    fn enter(&mut self, span: tracing::Span) {\n+        // This executes the destructor on the previous instance of `SpanGuard`, ensuring that\n+        // we never enter or exit more spans than vice versa. Unless you `mem::leak`, then we\n+        // can't protect the tracing stack, but that'll just lead to weird logging, no actual\n+        // problems.\n+        *self = Self(span, std::marker::PhantomData);\n+        self.0.with_subscriber(|(id, dispatch)| {\n+            dispatch.enter(id);\n+        });\n+    }\n+}\n+\n+impl Drop for SpanGuard {\n+    fn drop(&mut self) {\n+        self.0.with_subscriber(|(id, dispatch)| {\n+            dispatch.exit(id);\n+        });\n+    }\n+}\n+\n /// A stack frame.\n-#[derive(Clone)]\n pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n@@ -80,6 +113,11 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     pub locals: IndexVec<mir::Local, LocalState<'tcx, Tag>>,\n \n+    /// The span of the `tracing` crate is stored here.\n+    /// When the guard is dropped, the span is exited. This gives us\n+    /// a full stack trace on all tracing statements.\n+    tracing_span: SpanGuard,\n+\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -184,6 +222,7 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n             locals: self.locals,\n             loc: self.loc,\n             extra,\n+            tracing_span: self.tracing_span,\n         }\n     }\n }\n@@ -637,11 +676,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n-        if !self.stack().is_empty() {\n-            info!(\"PAUSING({}) {}\", self.frame_idx(), self.frame().instance);\n-        }\n-        ::log_settings::settings().indentation += 1;\n-\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n@@ -652,6 +686,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n             instance,\n+            tracing_span: SpanGuard::new(),\n             extra: (),\n         };\n         let frame = M::init_frame_extra(self, pre_frame)?;\n@@ -696,7 +731,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.frame_mut().locals = locals;\n         M::after_stack_push(self)?;\n         self.frame_mut().loc = Ok(mir::Location::START);\n-        info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n+\n+        let span = info_span!(\"frame\", \"{}\", instance);\n+        self.frame_mut().tracing_span.enter(span);\n \n         Ok(())\n     }\n@@ -747,10 +784,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// cause us to continue unwinding.\n     pub(super) fn pop_stack_frame(&mut self, unwinding: bool) -> InterpResult<'tcx> {\n         info!(\n-            \"LEAVING({}) {} (unwinding = {})\",\n-            self.frame_idx(),\n-            self.frame().instance,\n-            unwinding\n+            \"popping stack frame ({})\",\n+            if unwinding { \"during unwinding\" } else { \"returning from function\" }\n         );\n \n         // Sanity check `unwinding`.\n@@ -766,7 +801,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n         }\n \n-        ::log_settings::settings().indentation -= 1;\n         let frame =\n             self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n@@ -823,15 +857,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        if !self.stack().is_empty() {\n-            info!(\n-                \"CONTINUING({}) {} (unwinding = {})\",\n-                self.frame_idx(),\n-                self.frame().instance,\n-                unwinding\n-            );\n-        }\n-\n         Ok(())\n     }\n \n@@ -995,7 +1020,16 @@ where\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n         // Exhaustive match on fields to make sure we forget no field.\n-        let Frame { body, instance, return_to_block, return_place, locals, loc, extra } = self;\n+        let Frame {\n+            body,\n+            instance,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            loc,\n+            extra,\n+            tracing_span: _,\n+        } = self;\n         body.hash_stable(hcx, hasher);\n         instance.hash_stable(hcx, hasher);\n         return_to_block.hash_stable(hcx, hasher);"}, {"sha": "0c52fee68a968e36686278e1b46ca183b51ce277", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e25418474ae9961e50bd3ff076d80a3ec728531/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e25418474ae9961e50bd3ff076d80a3ec728531/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=6e25418474ae9961e50bd3ff076d80a3ec728531", "patch": "@@ -116,7 +116,6 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"libz-sys\",\n     \"lock_api\",\n     \"log\",\n-    \"log_settings\",\n     \"maybe-uninit\",\n     \"md-5\",\n     \"measureme\","}]}