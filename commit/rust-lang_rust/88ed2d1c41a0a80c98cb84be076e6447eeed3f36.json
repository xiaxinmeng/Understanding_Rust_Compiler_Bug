{"sha": "88ed2d1c41a0a80c98cb84be076e6447eeed3f36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZWQyZDFjNDFhMGE4MGM5OGNiODRiZTA3NmU2NDQ3ZWVlZDNmMzY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-29T23:31:41Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-06T01:11:14Z"}, "message": "Use operator sugar in the expansion of `#[deriving(PartialEq)]`", "tree": {"sha": "f81aed46e5aa4d432ecac723f5ec4fe8042e09af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f81aed46e5aa4d432ecac723f5ec4fe8042e09af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88ed2d1c41a0a80c98cb84be076e6447eeed3f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88ed2d1c41a0a80c98cb84be076e6447eeed3f36", "html_url": "https://github.com/rust-lang/rust/commit/88ed2d1c41a0a80c98cb84be076e6447eeed3f36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88ed2d1c41a0a80c98cb84be076e6447eeed3f36/comments", "author": null, "committer": null, "parents": [{"sha": "63c4f22f2bf9f1c070311cdc08c6ceb279434733", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c4f22f2bf9f1c070311cdc08c6ceb279434733", "html_url": "https://github.com/rust-lang/rust/commit/63c4f22f2bf9f1c070311cdc08c6ceb279434733"}], "stats": {"total": 36, "additions": 31, "deletions": 5}, "files": [{"sha": "c3b1a52925d452ea3749001673efbe281a880f38", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/88ed2d1c41a0a80c98cb84be076e6447eeed3f36/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88ed2d1c41a0a80c98cb84be076e6447eeed3f36/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=88ed2d1c41a0a80c98cb84be076e6447eeed3f36", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Item, Expr, mod};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -25,12 +25,38 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n-                                 cx, span, substr)\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Eq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+            },\n+            cx.expr_bool(span, true),\n+            |cx, span, _, _| cx.expr_bool(span, false),\n+            cx, span, substr)\n     }\n     fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n-              cx, span, substr)\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Eq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+            },\n+            cx.expr_bool(span, false),\n+            |cx, span, _, _| cx.expr_bool(span, true),\n+            cx, span, substr)\n     }\n \n     macro_rules! md ("}]}