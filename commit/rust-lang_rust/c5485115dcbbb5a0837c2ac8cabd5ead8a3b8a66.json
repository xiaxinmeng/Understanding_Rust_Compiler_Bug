{"sha": "c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NDg1MTE1ZGNiYmI1YTA4MzdjMmFjOGNhYmQ1ZWFkOGEzYjhhNjY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-23T02:03:36Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-23T15:06:41Z"}, "message": "Add more `.await` suggestions on E0308", "tree": {"sha": "41cfd5db62ca776080533a6ce4126e281b760ceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41cfd5db62ca776080533a6ce4126e281b760ceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "html_url": "https://github.com/rust-lang/rust/commit/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1829b4a887553797d6fa018ae2518ca0d45b67ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/1829b4a887553797d6fa018ae2518ca0d45b67ea", "html_url": "https://github.com/rust-lang/rust/commit/1829b4a887553797d6fa018ae2518ca0d45b67ea"}], "stats": {"total": 355, "additions": 167, "deletions": 188}, "files": [{"sha": "fcf21c61d8fd98a6dda247ba312be3c13f910637", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 119, "deletions": 38, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -50,7 +50,6 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n-use crate::infer::OriginalQueryValues;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -65,7 +64,6 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::ParamEnvAnd;\n use rustc_middle::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n@@ -1621,6 +1619,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             Mismatch::Variable(exp_found) => Some(exp_found),\n             Mismatch::Fixed(_) => None,\n         };\n+        let exp_found = match terr {\n+            // `terr` has more accurate type information than `exp_found` in match expressions.\n+            ty::error::TypeError::Sorts(terr)\n+                if exp_found.map_or(false, |ef| terr.found == ef.found) =>\n+            {\n+                Some(*terr)\n+            }\n+            _ => exp_found,\n+        };\n+        debug!(\"exp_found {:?} terr {:?}\", exp_found, terr);\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n             self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n@@ -1642,6 +1650,53 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found);\n     }\n \n+    fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::Opaque(def_id, substs) = ty.kind() {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let bounds = self.tcx.explicit_item_bounds(*def_id);\n+\n+            for (predicate, _) in bounds {\n+                let predicate = predicate.subst(self.tcx, substs);\n+                if let ty::PredicateAtom::Projection(projection_predicate) =\n+                    predicate.skip_binders()\n+                {\n+                    if projection_predicate.projection_ty.item_def_id == item_def_id {\n+                        // We don't account for multiple `Future::Output = Ty` contraints.\n+                        return Some(projection_predicate.ty);\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n     fn suggest_await_on_expect_found(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -1651,50 +1706,76 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\n             \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found\n+            exp_span, exp_found.expected, exp_found.found,\n         );\n \n-        if let ty::Opaque(def_id, _) = *exp_found.expected.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self\n-                .tcx\n-                .associated_items(future_trait)\n-                .in_definition_order()\n-                .next()\n-                .unwrap()\n-                .def_id;\n+        if let ObligationCauseCode::CompareImplMethodObligation { .. } = &cause.code {\n+            return;\n+        }\n \n-            let projection_ty = self.tcx.projection_ty_from_predicates((def_id, item_def_id));\n-            if let Some(projection_ty) = projection_ty {\n-                let projection_query = self.canonicalize_query(\n-                    &ParamEnvAnd { param_env: self.tcx.param_env(def_id), value: projection_ty },\n-                    &mut OriginalQueryValues::default(),\n-                );\n-                if let Ok(resp) = self.tcx.normalize_projection_ty(projection_query) {\n-                    let normalized_ty = resp.value.value.normalized_ty;\n-                    debug!(\"suggest_await_on_expect_found: normalized={:?}\", normalized_ty);\n-                    if ty::TyS::same_type(normalized_ty, exp_found.found) {\n-                        let span = if let ObligationCauseCode::Pattern {\n-                            span,\n-                            origin_expr: _,\n-                            root_ty: _,\n-                        } = cause.code\n-                        {\n-                            // scrutinee's span\n-                            span.unwrap_or(exp_span)\n-                        } else {\n-                            exp_span\n-                        };\n-                        diag.span_suggestion_verbose(\n-                            span.shrink_to_hi(),\n-                            \"consider awaiting on the future\",\n-                            \".await\".to_string(),\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if ty::TyS::same_type(exp, found) => match &cause.code {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n                             Applicability::MaybeIncorrect,\n                         );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n                     }\n                 }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if ty::TyS::same_type(exp_found.expected, ty) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if ty::TyS::same_type(ty, exp_found.found) => {\n+                let span = match cause.code {\n+                    // scrutinee's span\n+                    ObligationCauseCode::Pattern { span: Some(span), .. } => span,\n+                    _ => exp_span,\n+                };\n+                diag.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n+            _ => {}\n         }\n     }\n "}, {"sha": "5ec0ec0c56ad64b25d1effd7be08cd76139d08d7", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -334,26 +334,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n         match err {\n             Sorts(values) => {\n-                let expected_str = values.expected.sort_string(self);\n-                let found_str = values.found.sort_string(self);\n-                if expected_str == found_str && expected_str == \"closure\" {\n-                    db.note(\"no two closures, even if identical, have the same type\");\n-                    db.help(\"consider boxing your closure and/or using it as a trait object\");\n-                }\n-                if expected_str == found_str && expected_str == \"opaque type\" {\n-                    // Issue #63167\n-                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    let e_str = values.expected.to_string();\n-                    let f_str = values.found.to_string();\n-                    if e_str == f_str && &e_str == \"impl std::future::Future\" {\n-                        // FIXME: use non-string based check.\n-                        db.help(\n-                            \"if both `Future`s have the same `Output` type, consider \\\n-                                 `.await`ing on both of them\",\n-                        );\n-                    }\n-                }\n                 match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        db.note(\"no two closures, even if identical, have the same type\");\n+                        db.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                        // Issue #63167\n+                        db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n                     (ty::Float(_), ty::Infer(ty::IntVar(_))) => {\n                         if let Ok(\n                             // Issue #53280\n@@ -382,12 +371,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                         }\n                         db.note(\n                             \"a type parameter was expected, but a different one was found; \\\n-                                 you might be missing a type parameter or trait bound\",\n+                             you might be missing a type parameter or trait bound\",\n                         );\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Projection(_), ty::Projection(_)) => {\n@@ -471,8 +460,8 @@ impl<T> Trait<T> for X {\n                         }\n                         db.note(\n                             \"for more information, visit \\\n-                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                                 #traits-as-parameters\",\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n                         );\n                     }\n                     (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {"}, {"sha": "241803fab1e68b7b8b994057b45fa3386bd6cae5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -33,7 +33,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n-        self.suggest_missing_await(err, expr, expected, expr_ty);\n         self.suggest_missing_parentheses(err, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);"}, {"sha": "a8ad9f4fdf8af01ac6031e56ca57c1b7079a502a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits;\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -13,7 +12,6 @@ use rustc_hir::{ExprKind, ItemKind, Node};\n use rustc_infer::infer;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::kw;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n use std::iter;\n \n@@ -433,83 +431,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    pub(in super::super) fn suggest_missing_await(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n-        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n-        // body isn't `async`.\n-        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n-        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n-            let body = self.tcx().hir().body(body_id);\n-            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n-                let sp = expr.span;\n-                // Check for `Future` implementations by constructing a predicate to\n-                // prove: `<T as Future>::Output == U`\n-                let future_trait = self.tcx.require_lang_item(LangItem::Future, Some(sp));\n-                let item_def_id = self\n-                    .tcx\n-                    .associated_items(future_trait)\n-                    .in_definition_order()\n-                    .next()\n-                    .unwrap()\n-                    .def_id;\n-                // `<T as Future>::Output`\n-                let projection_ty = ty::ProjectionTy {\n-                    // `T`\n-                    substs: self\n-                        .tcx\n-                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n-                    // `Future::Output`\n-                    item_def_id,\n-                };\n-\n-                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    ty: expected,\n-                })\n-                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n-                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n-\n-                debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n-\n-                if self.infcx.predicate_may_hold(&obligation) {\n-                    debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n-                    err.span_suggestion_verbose(\n-                        sp.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    debug!(\"suggest_missing_await: obligation did not hold: {:?}\", obligation)\n-                }\n-            }\n-        }\n-    }\n-\n     pub(in super::super) fn suggest_missing_parentheses(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "14e72c2b1e7e2a757a514dc33db3aaaffb7a618c", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -9,6 +9,10 @@ LL |         take_u32(x)\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Future`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |         take_u32(x.await)\n+   |                   ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "df54ac88acee1e427a388ee09ee974438a7b37ae", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -53,6 +53,10 @@ LL |         Tuple(_) => {}\n    |\n    = note: expected opaque type `impl Future`\n                    found struct `Tuple`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     match tuple().await {\n+   |                  ^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "e548fda7cb4f59719c303efbe87f20a9e2fd7f74", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1829b4a887553797d6fa018ae2518ca0d45b67ea/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1829b4a887553797d6fa018ae2518ca0d45b67ea/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=1829b4a887553797d6fa018ae2518ca0d45b67ea", "patch": "@@ -1,30 +0,0 @@\n-// edition:2018\n-// run-rustfix\n-\n-fn take_u32(_x: u32) {}\n-\n-async fn make_u32() -> u32 {\n-    22\n-}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn() {\n-    let x = make_u32();\n-    take_u32(x.await)\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider `await`ing on the `Future`\n-    //~| SUGGESTION .await\n-}\n-\n-async fn dummy() {}\n-\n-#[allow(unused)]\n-async fn suggest_await_in_async_fn_return() {\n-    dummy().await;\n-    //~^ ERROR mismatched types [E0308]\n-    //~| HELP try adding a semicolon\n-    //~| HELP consider `await`ing on the `Future`\n-    //~| SUGGESTION .await\n-}\n-\n-fn main() {}"}, {"sha": "d629054911dac16e7326d3c307c48da7c9fa9bfb", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-// run-rustfix\n \n fn take_u32(_x: u32) {}\n "}, {"sha": "46615dae7e2ba3b43c48505fac9baa0e10446ddb", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:13:14\n+  --> $DIR/suggest-missing-await.rs:12:14\n    |\n LL | async fn make_u32() -> u32 {\n    |                        --- the `Output` of this `async fn`'s found opaque type\n@@ -15,7 +15,7 @@ LL |     take_u32(x.await)\n    |               ^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:23:5\n+  --> $DIR/suggest-missing-await.rs:22:5\n    |\n LL | async fn dummy() {}\n    |                  - the `Output` of this `async fn`'s found opaque type\n@@ -25,14 +25,14 @@ LL |     dummy()\n    |\n    = note: expected unit type `()`\n             found opaque type `impl Future`\n-help: try adding a semicolon\n-   |\n-LL |     dummy();\n-   |            ^\n help: consider `await`ing on the `Future`\n    |\n LL |     dummy().await\n    |            ^^^^^^\n+help: try adding a semicolon\n+   |\n+LL |     dummy();\n+   |            ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b8ac030b0bbbee86be6414265964c513aceb46c3", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -46,6 +46,7 @@ async fn async_extra_semicolon_different() {\n async fn async_different_futures() {\n     let _ = match true { //~ NOTE `match` arms have incompatible types\n         true => async_dummy(), //~ NOTE this is found to be\n+        //~| HELP consider `await`ing on both `Future`s\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected opaque type, found a different opaque type\n         //~| NOTE expected type `impl Future`"}, {"sha": "7a4f74a1994ce117594ebad727fd4597f2f6a235", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -20,14 +20,14 @@ LL | |     };\n    |\n    = note:     expected type `()`\n            found opaque type `impl Future`\n-help: consider removing this semicolon and boxing the expression\n-   |\n-LL |             async_dummy()\n-   |                         --\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy().await,\n    |                               ^^^^^^\n+help: consider removing this semicolon and boxing the expression\n+   |\n+LL |             async_dummy()\n+   |                         --\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/match-prev-arm-needing-semi.rs:39:18\n@@ -51,17 +51,17 @@ LL | |     };\n    |\n    = note:     expected type `()`\n            found opaque type `impl Future`\n-help: consider removing this semicolon and boxing the expression\n-   |\n-LL |             async_dummy()\n-   |                         --\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy2().await,\n    |                                ^^^^^^\n+help: consider removing this semicolon and boxing the expression\n+   |\n+LL |             async_dummy()\n+   |                         --\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:49:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:50:18\n    |\n LL |   async fn async_dummy2() {}\n    |                           - the `Output` of this `async fn`'s found opaque type\n@@ -81,6 +81,11 @@ LL | |     };\n    = note:     expected type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n            found opaque type `impl Future` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:17:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         true => async_dummy().await,\n+LL |         false => async_dummy2().await,\n+   |\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/match-prev-arm-needing-semi.rs:11:18"}, {"sha": "d74076cbc9b8e1bad1564cffb12f3316214d1583", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=c5485115dcbbb5a0837c2ac8cabd5ead8a3b8a66", "patch": "@@ -16,6 +16,12 @@ LL | |     }.await\n    = note:     expected type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n            found opaque type `impl Future` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n+help: consider `await`ing on both `Future`s\n+   |\n+LL |         thing_one().await\n+LL |     } else {\n+LL |         thing_two().await\n+   |\n \n error: aborting due to previous error\n "}]}