{"sha": "9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMGE2YzIxYjJkZTIyNDdlY2NiZmIxYjcyMTM3ZGI1YzdkZDUxNzM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T18:47:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T18:47:10Z"}, "message": "Implement preliminary form of structured compare. No boxes, vectors or strings yet.", "tree": {"sha": "c4929a54a7ff40ab4b252e32e7aa548320304258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4929a54a7ff40ab4b252e32e7aa548320304258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "html_url": "https://github.com/rust-lang/rust/commit/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72cc89c8c3b744bb4afff193e42a5d66e5c70e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/72cc89c8c3b744bb4afff193e42a5d66e5c70e2e", "html_url": "https://github.com/rust-lang/rust/commit/72cc89c8c3b744bb4afff193e42a5d66e5c70e2e"}], "stats": {"total": 282, "additions": 203, "deletions": 79}, "files": [{"sha": "8277ed31a63cbc6bc67b1ec728a5a7e919d94e9d", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "patch": "@@ -537,6 +537,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       str-append.rs \\\n                       str-concat.rs \\\n                       str-idx.rs \\\n+                      structured-compare.rs \\\n                       tag.rs \\\n                       tail-call-arg-leak.rs \\\n                       tail-cps.rs \\"}, {"sha": "945155b0d799d9aec5148ce9e69a3d2e77c27fb8", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "patch": "@@ -26,7 +26,7 @@ type glue =\n   | GLUE_sever of Ast.ty          (* Null all box state slots.          *)\n   | GLUE_mark of Ast.ty           (* Mark all box state slots.          *)\n   | GLUE_clone of Ast.ty          (* Deep copy.                         *)\n-  | GLUE_compare of Ast.ty\n+  | GLUE_cmp of Ast.ty\n   | GLUE_hash of Ast.ty\n   | GLUE_write of Ast.ty\n   | GLUE_read of Ast.ty\n@@ -2508,7 +2508,7 @@ let glue_str (cx:ctxt) (g:glue) : string =\n     | GLUE_sever ty -> \"glue$sever$\" ^ (ty_str cx ty)\n     | GLUE_mark ty -> \"glue$mark$\" ^ (ty_str cx ty)\n     | GLUE_clone ty -> \"glue$clone$\" ^ (ty_str cx ty)\n-    | GLUE_compare ty -> \"glue$compare$\" ^ (ty_str cx ty)\n+    | GLUE_cmp ty -> \"glue$cmp$\" ^ (ty_str cx ty)\n     | GLUE_hash ty -> \"glue$hash$\" ^ (ty_str cx ty)\n     | GLUE_write ty -> \"glue$write$\" ^ (ty_str cx ty)\n     | GLUE_read ty -> \"glue$read$\" ^ (ty_str cx ty)"}, {"sha": "591bf9a33dec0241aa2fb9c581c0a13880eaecaa", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 179, "deletions": 75, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "patch": "@@ -91,6 +91,7 @@ let trans_visitor\n   let imm (i:int64) : Il.operand = imm_of_ty i word_ty_mach in\n   let simm (i:int64) : Il.operand = imm_of_ty i word_ty_signed_mach in\n   let one = imm 1L in\n+  let neg_one = simm (-1L) in\n   let zero = imm 0L in\n   let imm_true = imm_of_ty 1L TY_u8 in\n   let imm_false = imm_of_ty 0L TY_u8 in\n@@ -1858,7 +1859,38 @@ let trans_visitor\n     in\n       get_typed_mem_glue g fty inner\n \n-  and get_cmp_glue _ = failwith \"TODO\"\n+  and get_cmp_glue ty =\n+    let arg_ty_params_alias = 0 in\n+    let arg_lhs_alias = 1 in\n+    let arg_rhs_alias = 2 in\n+    let g = GLUE_cmp ty in\n+    let inner (out_ptr:Il.cell) (args:Il.cell) =\n+      let dst = deref out_ptr in\n+      let ty_params = deref (get_element_ptr args arg_ty_params_alias) in\n+      let lhs = deref (get_element_ptr args arg_lhs_alias) in\n+      let rhs = deref (get_element_ptr args arg_rhs_alias) in\n+      let early_finish_jmps = Queue.create () in\n+      let cmp_part lhs rhs ty =\n+        let tmp = trans_cmp ~ty_params ~ty (Il.Cell lhs) (Il.Cell rhs) in\n+        let keep_going_jmps =\n+          trans_compare_simple Il.JE tmp zero\n+        in\n+          mov dst tmp;\n+          Queue.add (mark()) early_finish_jmps;\n+          emit (Il.jmp Il.JMP Il.CodeNone);\n+          List.iter patch keep_going_jmps\n+      in\n+        mov dst zero;\n+        iter_ty_parts_full ty_params lhs rhs ty cmp_part;\n+        Queue.iter patch early_finish_jmps;\n+    in\n+    let ty_params_ptr = ty_params_covering ty in\n+    let fty =\n+      mk_ty_fn\n+        (local_slot Ast.TY_int)\n+        [| ty_params_ptr; alias_slot ty; alias_slot ty |]\n+    in\n+      get_typed_mem_glue g fty inner\n \n   (*\n    * Vector-growth glue takes four arguments:\n@@ -2108,62 +2140,120 @@ let trans_visitor\n         (Array.append [| ty_params_ptr |] args)\n         clo\n \n-  (* [trans_compare_full] returns the quad number of the cjmp, which the\n-   * caller patches to the cjmp destination.\n+  (*\n+   * NB: there are 2 categories of comparisons:\n+   *\n+   *   - Those called 'compare' that take a jmpop and return a jump list\n+   *     that the caller should patch.\n+   *\n+   *   - Those called 'cmp' that return a number, -1/0/1, indicating the\n+   *     relative order of lhs and rhs.\n+   *\n+   * While in theory compare could be built out of cmp, on real machines\n+   * we are forced to build cmp out of compare.\n+   *)\n+\n+\n+  (* \n+   * [trans_cmp] returns the result-code of a three-value comparison, \n+   * which is an operand representing the ordering of lhs and rhs. -1 means\n+   * less than, 0 means equal, 1 means greater-than.\n    *\n    * We assume that the LHS and RHS of the comparison have the same type, an\n-   * invariant that the typechecker enforces. *)\n-  and trans_compare_full\n-      ~cjmp:(cjmp:Il.jmpop)\n+   * invariant that the typechecker enforces.\n+   *)\n+  and trans_cmp\n       ~ty_params:(ty_params:Il.cell)\n       ~ty:(ty:Ast.ty)\n-      (lhs:Il.cell)\n-      (rhs:Il.cell)\n-      : quad_idx list =\n+      (lhs:Il.operand)\n+      (rhs:Il.operand)\n+      : Il.operand =\n     let ty = strip_mutable_or_constrained_ty ty in\n     let (result:Il.cell) = next_vreg_cell (Il.ValTy Il.Bits32) in\n-    begin\n-      match ty with\n-          Ast.TY_obj _ ->\n-            let lhs_binding = get_element_ptr lhs Abi.obj_field_box in\n-            let rhs_binding = get_element_ptr rhs Abi.obj_field_box in\n-            let lhs_box, rhs_box = deref lhs_binding, deref rhs_binding in\n-            let lhs_obj = get_element_ptr lhs_box Abi.box_rc_field_body in\n-            let rhs_obj = get_element_ptr rhs_box Abi.box_rc_field_body in\n-            let tydesc = get_element_ptr lhs_obj Abi.obj_body_elt_tydesc in\n-            let lhs_body = get_element_ptr lhs_obj Abi.obj_body_elt_fields in\n-            let rhs_body = get_element_ptr rhs_obj Abi.obj_body_elt_fields in\n-            trans_call_dynamic_glue\n-              tydesc\n-              Abi.tydesc_field_cmp_glue\n-              (Some result)\n-              [| alias lhs_body; alias rhs_body |]\n-              None\n-\n-        | Ast.TY_param (i, _) ->\n-            trans_call_simple_dynamic_glue\n-              i\n-              Abi.tydesc_field_cmp_glue\n-              ty_params\n-              [| alias lhs; alias rhs |]\n-              None\n+      begin\n+        match ty with\n \n-        | _ ->\n-            trans_call_static_glue\n-              (code_fixup_to_ptr_operand (get_cmp_glue ty))\n-              (Some result)\n-              [| lhs; rhs |]\n-              None\n-    end;\n-    emit (Il.cmp (Il.Cell result) zero);\n-    let jmp = mark() in\n-    emit (Il.jmp cjmp Il.CodeNone);\n-    [ jmp ]\n+            Ast.TY_bool\n+          | Ast.TY_mach _\n+          | Ast.TY_int\n+          | Ast.TY_uint\n+          | Ast.TY_char ->\n+              let cjmp =\n+                if type_is_unsigned_2s_complement ty\n+                then Il.JB\n+                else Il.JL\n+              in\n+                (* Start with assumption lhs < rhs *)\n+                mov result neg_one;\n+                let lhs_lt_rhs_jmps =\n+                  trans_compare ~ty_params ~cjmp ~ty lhs rhs\n+                in\n+                  (* ... disproven, so assume lhs > rhs *)\n+                  mov result one;\n+                  let rhs_lt_lhs_jmps =\n+                    trans_compare ~ty_params ~cjmp ~ty rhs lhs\n+                  in\n+                    (* ... disproven, must be lhs == rhs *)\n+                    mov result zero;\n+                    List.iter patch lhs_lt_rhs_jmps;\n+                    List.iter patch rhs_lt_lhs_jmps;\n+\n+          | Ast.TY_obj _ ->\n+              let lhs = need_cell lhs in\n+              let rhs = need_cell rhs in\n+              let lhs_binding = get_element_ptr lhs Abi.obj_field_box in\n+              let rhs_binding = get_element_ptr rhs Abi.obj_field_box in\n+              let lhs_box, rhs_box = deref lhs_binding, deref rhs_binding in\n+              let lhs_obj = get_element_ptr lhs_box Abi.box_rc_field_body in\n+              let rhs_obj = get_element_ptr rhs_box Abi.box_rc_field_body in\n+              let td = get_element_ptr lhs_obj Abi.obj_body_elt_tydesc in\n+              let lhs_body =\n+                get_element_ptr lhs_obj Abi.obj_body_elt_fields\n+              in\n+              let rhs_body =\n+                get_element_ptr rhs_obj Abi.obj_body_elt_fields\n+              in\n+              let ty_params_ptr = get_tydesc_params ty_params td in\n+                trans_call_dynamic_glue\n+                  td Abi.tydesc_field_cmp_glue\n+                  (Some result)\n+                  [| ty_params_ptr; alias lhs_body; alias rhs_body |]\n+                  None\n \n-  (* Like [trans_compare_full], returns the address of the jump, which the\n+          | Ast.TY_param (i, _) ->\n+              let lhs = need_cell lhs in\n+              let rhs = need_cell rhs in\n+              let td = get_ty_param ty_params i in\n+              let ty_params_ptr = get_tydesc_params ty_params td in\n+                trans_call_dynamic_glue\n+                  td Abi.tydesc_field_cmp_glue\n+                  (Some result)\n+                  [| ty_params_ptr; alias lhs; alias rhs |]\n+                  None\n+\n+          | Ast.TY_vec _\n+          | Ast.TY_str ->\n+              (* FIXME: temporary until we get sequence-compares working. *)\n+              mov result zero;\n+\n+          | _ ->\n+              let lhs = need_cell lhs in\n+              let rhs = need_cell rhs in\n+                trans_call_static_glue\n+                  (code_fixup_to_ptr_operand (get_cmp_glue ty))\n+                  (Some result)\n+                  [| alias ty_params; alias lhs; alias rhs |]\n+                  None\n+      end;\n+      Il.Cell result\n+\n+\n+  (*\n+   * [trans_compare_simple] returns a set of jump addresses, which the\n    * caller patches to the destination. Only use this function if you are sure\n    * that the LHS and RHS have the same type and that both will fit in a\n-   * machine register; otherwise, use [trans_compare] instead. *)\n+   * machine register; otherwise, use [trans_compare] instead.\n+   *)\n   and trans_compare_simple\n       (cjmp:Il.jmpop)\n       (lhs:Il.operand)\n@@ -2174,20 +2264,34 @@ let trans_visitor\n       emit (Il.jmp cjmp Il.CodeNone);\n       [ jmp ]\n \n+  (*\n+   * [trans_compare] returns a set of jump addresses, which the\n+   * caller patches to the destination.\n+   *)\n   and trans_compare\n       ?ty_params:(ty_params=get_ty_params_of_current_frame())\n       ~cjmp:(cjmp:Il.jmpop)\n       ~ty:(ty:Ast.ty)\n       (lhs:Il.operand)\n       (rhs:Il.operand)\n       : quad_idx list =\n-    ignore (trans_compare ~cjmp ~ty lhs rhs);\n-      (* TODO *)\n-    match lhs, rhs with\n-        Il.Cell lhs, Il.Cell rhs ->\n-          trans_compare_full\n-            ~cjmp ~ty_params ~ty lhs rhs\n-      | _ -> trans_compare_simple cjmp lhs rhs\n+      match ty with\n+          Ast.TY_bool\n+        | Ast.TY_mach _\n+        | Ast.TY_int\n+        | Ast.TY_uint\n+        | Ast.TY_char ->\n+            trans_compare_simple cjmp lhs rhs\n+\n+        | _ ->\n+            let result =\n+              trans_cmp ~ty_params ~ty lhs rhs\n+            in\n+              emit (Il.cmp result zero);\n+              let jmp = mark() in\n+                emit (Il.jmp cjmp Il.CodeNone);\n+                [ jmp ]\n+\n \n   and trans_cond (invert:bool) (expr:Ast.expr) : quad_idx list =\n     let anno _ =\n@@ -2198,27 +2302,27 @@ let trans_visitor\n                         \": cond, finale\")\n         end\n     in\n-\n-    match expr with\n-        Ast.EXPR_binary (binop, a, b) ->\n-          let lhs = trans_atom a in\n-          let rhs = trans_atom b in\n-          let cjmp = binop_to_jmpop binop in\n-          let cjmp' =\n-            if invert then\n-              match cjmp with\n-                  Il.JE -> Il.JNE\n-                | Il.JNE -> Il.JE\n-                | Il.JL -> Il.JGE\n-                | Il.JLE -> Il.JG\n-                | Il.JGE -> Il.JL\n-                | Il.JG -> Il.JLE\n-                | _ -> bug () \"Unhandled inverse binop in trans_cond\"\n-            else\n-              cjmp\n-          in\n-            anno ();\n-            trans_compare_simple cjmp' lhs rhs\n+      match expr with\n+          Ast.EXPR_binary (binop, a, b) ->\n+            let lhs = trans_atom a in\n+            let rhs = trans_atom b in\n+            let cjmp = binop_to_jmpop binop in\n+            let cjmp =\n+              if invert then\n+                match cjmp with\n+                    Il.JE -> Il.JNE\n+                  | Il.JNE -> Il.JE\n+                  | Il.JL -> Il.JGE\n+                  | Il.JLE -> Il.JG\n+                  | Il.JGE -> Il.JL\n+                  | Il.JG -> Il.JLE\n+                  | _ -> bug () \"Unhandled inverse binop in trans_cond\"\n+              else\n+                cjmp\n+            in\n+              anno ();\n+              let ty = atom_type cx a in\n+                trans_compare ~cjmp ~ty lhs rhs\n \n       | _ ->\n           let bool_operand = trans_expr expr in"}, {"sha": "fd11efe1c97bde91f21858deec8054557d8a18cb", "filename": "src/comp/fe/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fcomp%2Ffe%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Fcomp%2Ffe%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fparser.rs?ref=9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "patch": "@@ -50,8 +50,7 @@ state fn new_parser(session.session sess, str path) -> parser {\n }\n \n state fn expect(parser p, token.token t) {\n-    // FIXME: comparing tags would be good. One of these days.\n-    if (true /* p.peek() == t */) {\n+    if (p.peek() == t) {\n         p.bump();\n     } else {\n         let str s = \"expecting \";"}, {"sha": "fed4b1837303a8345898820847cfa0d833d5248f", "filename": "src/test/run-pass/structured-compare.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f0a6c21b2de2247eccbfb1b72137db5c7dd5173/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=9f0a6c21b2de2247eccbfb1b72137db5c7dd5173", "patch": "@@ -0,0 +1,20 @@\n+tag foo {\n+  large;\n+  small;\n+}\n+\n+fn main() {\n+  auto a = tup(1,2,3);\n+  auto b = tup(1,2,3);\n+  check (a == b);\n+  check (a != tup(1,2,4));\n+  check (a < tup(1,2,4));\n+  check (a <= tup(1,2,4));\n+  check (tup(1,2,4) > a);\n+  check (tup(1,2,4) >= a);\n+  auto x = large;\n+  auto y = small;\n+  check (x != y);\n+  check (x == large);\n+  check (x != small);\n+}\n\\ No newline at end of file"}]}