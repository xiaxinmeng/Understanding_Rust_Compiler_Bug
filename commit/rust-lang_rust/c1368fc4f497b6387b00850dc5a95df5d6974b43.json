{"sha": "c1368fc4f497b6387b00850dc5a95df5d6974b43", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzY4ZmM0ZjQ5N2I2Mzg3YjAwODUwZGM1YTk1ZGY1ZDY5NzRiNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-20T18:58:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-20T18:58:28Z"}, "message": "Auto merge of #39981 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 3 pull requests\n\n- Successful merges: #39913, #39937, #39976\n- Failed merges:", "tree": {"sha": "be7ffac7211cbedf53d95320197a17ec97248a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be7ffac7211cbedf53d95320197a17ec97248a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1368fc4f497b6387b00850dc5a95df5d6974b43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1368fc4f497b6387b00850dc5a95df5d6974b43", "html_url": "https://github.com/rust-lang/rust/commit/c1368fc4f497b6387b00850dc5a95df5d6974b43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1368fc4f497b6387b00850dc5a95df5d6974b43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7c5563855123ab094db99d42ccab5f26dbccdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7c5563855123ab094db99d42ccab5f26dbccdf", "html_url": "https://github.com/rust-lang/rust/commit/5b7c5563855123ab094db99d42ccab5f26dbccdf"}, {"sha": "9a8dbbe918da20eb75b924ecc0742e42c70c3709", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a8dbbe918da20eb75b924ecc0742e42c70c3709", "html_url": "https://github.com/rust-lang/rust/commit/9a8dbbe918da20eb75b924ecc0742e42c70c3709"}], "stats": {"total": 856, "additions": 483, "deletions": 373}, "files": [{"sha": "f17095f96092088a7235f151c3048a3a5a4ce018", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -270,7 +270,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.0.15\"\n+version = \"0.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -401,7 +401,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mdbook 0.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mdbook 0.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -991,7 +991,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lazy_static 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6abe0ee2e758cd6bc8a2cd56726359007748fbf4128da998b65d0b70f881e19b\"\n \"checksum libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684f330624d8c3784fb9558ca46c4ce488073a8d22450415c5eb4f4cfb0d11b5\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum mdbook 0.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a6b8e6eb10d1c6beeca799fe5919778cf5c6f22a4f2abb5f50faea1221adeae\"\n+\"checksum mdbook 0.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14e8a6aca534ac51bad1c1886b10f6d6948a14fa70b1b20a1e41c9e5c0fe3019\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum num-traits 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a16a42856a256b39c6d3484f097f6713e14feacd9bfb02290917904fae46c81c\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\""}, {"sha": "853fb1ec254176cbb3956440aec18883eb451382", "filename": "src/doc/book/src/casting-between-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fcasting-between-types.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -8,7 +8,7 @@ most dangerous features of Rust!\n # Coercion\n \n Coercion between types is implicit and has no syntax of its own, but can\n-be spelled out with [`as`](#Explicit%20coercions).\n+be spelled out with [`as`](#explicit-coercions).\n \n Coercion occurs in `let`, `const`, and `static` statements; in\n function call arguments; in field values in struct initialization; and in a"}, {"sha": "5426ed0ff4c9c2e4985e2007daaba4bc590103e3", "filename": "src/doc/book/src/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fclosures.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -463,7 +463,7 @@ fn factory() -> &(Fn(i32) -> i32) {\n \n Right. Because we have a reference, we need to give it a lifetime. But\n our `factory()` function takes no arguments, so\n-[elision](lifetimes.html#Lifetime%20Elision) doesn\u2019t kick in here. Then what\n+[elision](lifetimes.html#lifetime-elision) doesn\u2019t kick in here. Then what\n choices do we have? Try `'static`:\n \n ```rust,ignore"}, {"sha": "1b7ce678982afe80b0475060c40c0ed6a08cd25c", "filename": "src/doc/book/src/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fcompiler-plugins.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -127,7 +127,7 @@ enum.  For a more involved macro example, see\n \n ## Tips and tricks\n \n-Some of the [macro debugging tips](macros.html#Debugging%20macro%20code) are applicable.\n+Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n \n You can use `syntax::parse` to turn token trees into\n higher-level syntax elements like expressions:"}, {"sha": "a64178c26f237f914da56b421067f75c063a5ec0", "filename": "src/doc/book/src/concurrency.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fconcurrency.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -55,7 +55,7 @@ For sharing references across threads, Rust provides a wrapper type called\n `Arc<T>`. `Arc<T>` implements `Send` and `Sync` if and only if `T` implements\n both `Send` and `Sync`. For example, an object of type `Arc<RefCell<U>>` cannot\n be transferred across threads because\n-[`RefCell`](choosing-your-guarantees.html#RefCell%3CT%3E) does not implement\n+[`RefCell`](choosing-your-guarantees.html#refcellt) does not implement\n `Sync`, consequently `Arc<RefCell<U>>` would not implement `Send`.\n \n These two traits allow you to use the type system to make strong guarantees\n@@ -126,7 +126,7 @@ closure only captures a _reference to `x`_. This is a problem, because the\n thread may outlive the scope of `x`, leading to a dangling pointer.\n \n To fix this, we use a `move` closure as mentioned in the error message. `move`\n-closures are explained in depth [here](closures.html#move%20closures); basically\n+closures are explained in depth [here](closures.html#move-closures); basically\n they move variables from their environment into themselves.\n \n ```rust"}, {"sha": "c823c32a135bb272ad08328185a2d85f7928e7c0", "filename": "src/doc/book/src/error-handling.md", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ferror-handling.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -21,35 +21,35 @@ sum types and combinators, and try to motivate the way Rust does error handling\n incrementally. As such, programmers with experience in other expressive type\n systems may want to jump around.\n \n-* [The Basics](#The%20Basics)\n-    * [Unwrapping explained](#Unwrapping%20explained)\n-    * [The `Option` type](#The%20Option%20type)\n-        * [Composing `Option<T>` values](#Composing%20Option%3CT%3E%20values)\n-    * [The `Result` type](#The%20Result%20type)\n-        * [Parsing integers](#Parsing%20integers)\n-        * [The `Result` type alias idiom](#The%20Result%20type%20alias%20idiom)\n-    * [A brief interlude: unwrapping isn't evil](#A%20brief%20interlude:%20unwrapping%20isnt%20evil)\n-* [Working with multiple error types](#Working%20with%20multiple%20error%20types)\n-    * [Composing `Option` and `Result`](#Composing%20Option%20and%20Result)\n-    * [The limits of combinators](#The%20limits%20of%20combinators)\n-    * [Early returns](#Early%20returns)\n-    * [The `try!` macro](#The%20try%20macro)\n-    * [Defining your own error type](#Defining%20your%20own%20error%20type)\n-* [Standard library traits used for error handling](#Standard%20library%20traits%20used%20for%20error%20handling)\n-    * [The `Error` trait](#The%20Error%20trait)\n-    * [The `From` trait](#The%20From%20trait)\n-    * [The real `try!` macro](#The%20real%20try%20macro)\n-    * [Composing custom error types](#Composing%20custom%20error%20types)\n-    * [Advice for library writers](#Advice%20for%20library%20writers)\n-* [Case study: A program to read population data](#Case%20study:%20A%20program%20to%20read%20population%20data)\n-    * [Initial setup](#Initial%20setup)\n-    * [Argument parsing](#Argument%20parsing)\n-    * [Writing the logic](#Writing%20the%20logic)\n-    * [Error handling with `Box<Error>`](#Error%20handling%20with%20Box%3CError%3E)\n-    * [Reading from stdin](#Reading%20from%20stdin)\n-    * [Error handling with a custom type](#Error%20handling%20with%20a%20custom%20type)\n-    * [Adding functionality](#Adding%20functionality)\n-* [The short story](#The%20short%20story)\n+* [The Basics](#the-basics)\n+    * [Unwrapping explained](#unwrapping-explained)\n+    * [The `Option` type](#the-option-type)\n+        * [Composing `Option<T>` values](#composing-optiont-values)\n+    * [The `Result` type](#the-result-type)\n+        * [Parsing integers](#parsing-integers)\n+        * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil)\n+* [Working with multiple error types](#working-with-multiple-error-types)\n+    * [Composing `Option` and `Result`](#composing-option-and-result)\n+    * [The limits of combinators](#the-limits-of-combinators)\n+    * [Early returns](#early-returns)\n+    * [The `try!` macro](#the-try-macro)\n+    * [Defining your own error type](#defining-your-own-error-type)\n+* [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling)\n+    * [The `Error` trait](#the-error-trait)\n+    * [The `From` trait](#the-from-trait)\n+    * [The real `try!` macro](#the-real-try-macro)\n+    * [Composing custom error types](#composing-custom-error-types)\n+    * [Advice for library writers](#advice-for-library-writers)\n+* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n+    * [Initial setup](#initial-setup)\n+    * [Argument parsing](#argument-parsing)\n+    * [Writing the logic](#writing-the-logic)\n+    * [Error handling with `Box<Error>`](#error-handling-with-boxerror)\n+    * [Reading from stdin](#reading-from-stdin)\n+    * [Error handling with a custom type](#error-handling-with-a-custom-type)\n+    * [Adding functionality](#adding-functionality)\n+* [The short story](#the-short-story)\n \n # The Basics\n \n@@ -796,7 +796,7 @@ because of the return types of\n [`std::fs::File::open`](../std/fs/struct.File.html#method.open) and\n [`std::io::Read::read_to_string`](../std/io/trait.Read.html#method.read_to_string).\n (Note that they both use the [`Result` type alias\n-idiom](#The%20Result%20type%20alias%20idiom) described previously. If you\n+idiom](#the-result-type-alias-idiom) described previously. If you\n click on the `Result` type, you'll [see the type\n alias](../std/io/type.Result.html), and consequently, the underlying\n `io::Error` type.)  The third problem is described by the\n@@ -1120,7 +1120,7 @@ returns an `&Error`, which is itself a trait object. We'll revisit the\n \n For now, it suffices to show an example implementing the `Error` trait. Let's\n use the error type we defined in the\n-[previous section](#Defining%20your%20own%20error%20type):\n+[previous section](#defining-your-own-error-type):\n \n ```rust\n use std::io;\n@@ -1493,19 +1493,19 @@ representation. But certainly, this will vary depending on use cases.\n At a minimum, you should probably implement the\n [`Error`](../std/error/trait.Error.html)\n trait. This will give users of your library some minimum flexibility for\n-[composing errors](#The%20real%20try%20macro). Implementing the `Error` trait also\n+[composing errors](#the-real-try-macro). Implementing the `Error` trait also\n means that users are guaranteed the ability to obtain a string representation\n of an error (because it requires impls for both `fmt::Debug` and\n `fmt::Display`).\n \n Beyond that, it can also be useful to provide implementations of `From` on your\n error types. This allows you (the library author) and your users to\n-[compose more detailed errors](#Composing%20custom%20error%20types). For example,\n+[compose more detailed errors](#composing-custom-error-types). For example,\n [`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html)\n provides `From` impls for both `io::Error` and `byteorder::Error`.\n \n Finally, depending on your tastes, you may also want to define a\n-[`Result` type alias](#The%20Result%20type%20alias%20idiom), particularly if your\n+[`Result` type alias](#the-result-type-alias-idiom), particularly if your\n library defines a single error type. This is used in the standard library\n for [`io::Result`](../std/io/type.Result.html)\n and [`fmt::Result`](../std/fmt/type.Result.html).\n@@ -1538,7 +1538,7 @@ and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n \n We're not going to spend a lot of time on setting up a project with\n Cargo because it is already covered well in [the Cargo\n-section](getting-started.html#Hello%20Cargo) and [Cargo's documentation][14].\n+section](getting-started.html#hello-cargo) and [Cargo's documentation][14].\n \n To get started from scratch, run `cargo new --bin city-pop` and make sure your\n `Cargo.toml` looks something like this:\n@@ -1729,7 +1729,7 @@ error types and you don't need any `From` implementations. The downside is that\n since `Box<Error>` is a trait object, it *erases the type*, which means the\n compiler can no longer reason about its underlying type.\n \n-[Previously](#The%20limits%20of%20combinators) we started refactoring our code by\n+[Previously](#the-limits-of-combinators) we started refactoring our code by\n changing the type of our function from `T` to `Result<T, OurErrorType>`. In\n this case, `OurErrorType` is only `Box<Error>`. But what's `T`? And can we add\n a return type to `main`?"}, {"sha": "cccefd8dfe73f5d1732586d45426578d3fc58dc3", "filename": "src/doc/book/src/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fffi.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -680,7 +680,7 @@ pub extern fn hello_rust() -> *const u8 {\n \n The `extern` makes this function adhere to the C calling convention, as\n discussed above in \"[Foreign Calling\n-Conventions](ffi.html#Foreign%20calling%20conventions)\". The `no_mangle`\n+Conventions](ffi.html#foreign-calling-conventions)\". The `no_mangle`\n attribute turns off Rust's name mangling, so that it is easier to link to.\n \n # FFI and panics"}, {"sha": "6208b1f4c123409f76683b6dd61c0742fc058117", "filename": "src/doc/book/src/getting-started.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fgetting-started.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -236,7 +236,7 @@ language]*, which means that most things are expressions, rather than\n statements. The `;` indicates that this expression is over, and the next one is\n ready to begin. Most lines of Rust code end with a `;`.\n \n-[expression-oriented language]: glossary.html#Expression-Oriented%20Language\n+[expression-oriented language]: glossary.html#expression-oriented-language\n \n ## Compiling and Running Are Separate Steps\n "}, {"sha": "b17b89633f356406ef9e003f2ea453b64fcba0d7", "filename": "src/doc/book/src/glossary.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fglossary.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -56,7 +56,7 @@ They can be used to manage control flow in a modular fashion.\n \n A type without a statically known size or alignment. ([more info][link])\n \n-[link]: ../nomicon/exotic-sizes.html#Dynamically%20Sized%20Types%20(DSTs)\n+[link]: ../nomicon/exotic-sizes.html#dynamically-sized-types-dsts\n \n ### Expression\n \n@@ -76,8 +76,8 @@ In an expression-oriented language, (nearly) every statement is an expression\n and therefore returns a value. Consequently, these expression statements can\n themselves form part of larger expressions.\n \n-[expression]: glossary.html#Expression\n-[statement]: glossary.html#Statement\n+[expression]: glossary.html#expression\n+[statement]: glossary.html#statement\n \n ### Statement\n "}, {"sha": "7368d2184e5c2d73af831dce3ff7f774b3b95eee", "filename": "src/doc/book/src/guessing-game.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fguessing-game.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -119,7 +119,7 @@ there are no arguments, and `{` starts the body of the function. Because\n we didn\u2019t include a return type, it\u2019s assumed to be `()`, an empty\n [tuple][tuples].\n \n-[tuples]: primitive-types.html#Tuples\n+[tuples]: primitive-types.html#tuples\n \n ```rust,ignore\n     println!(\"Guess the number!\");\n@@ -727,7 +727,7 @@ thirty-two bit integer. Rust has [a number of built-in number types][number],\n but we\u2019ve chosen `u32`. It\u2019s a good default choice for a small positive number.\n \n [parse]: ../std/primitive.str.html#method.parse\n-[number]: primitive-types.html#Numeric%20types\n+[number]: primitive-types.html#numeric-types\n \n Just like `read_line()`, our call to `parse()` could cause an error. What if\n our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As"}, {"sha": "8bca13c28f0bd2b2def24b6dc7b1ed8bbdc28abd", "filename": "src/doc/book/src/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -139,7 +139,7 @@ associated with it, but the compiler lets you elide (i.e. omit, see\n [\"Lifetime Elision\"][lifetime-elision] below) them in common cases. Before we\n get to that, though, let\u2019s look at a short example with explicit lifetimes:\n \n-[lifetime-elision]: #Lifetime%20Elision\n+[lifetime-elision]: #lifetime-elision\n \n ```rust,ignore\n fn bar<'a>(...)"}, {"sha": "861cb4371f9b42b4bf2cb0623f05490494bdf1c5", "filename": "src/doc/book/src/macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fmacros.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -430,7 +430,7 @@ Even when Rust code contains un-expanded macros, it can be parsed as a full\n tools that process code. It also has a few consequences for the design of\n Rust\u2019s macro system.\n \n-[ast]: glossary.html#Abstract%20Syntax%20Tree\n+[ast]: glossary.html#abstract-syntax-tree\n \n One consequence is that Rust must determine, when it parses a macro invocation,\n whether the macro stands in for"}, {"sha": "fa7a259392a7e6af0ca22da903749bd54269a90e", "filename": "src/doc/book/src/mutability.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fmutability.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -89,7 +89,7 @@ philosophy, memory safety, and the mechanism by which Rust guarantees it, the\n > * exactly one mutable reference (`&mut T`).\n \n [ownership]: ownership.html\n-[borrowing]: references-and-borrowing.html#Borrowing\n+[borrowing]: references-and-borrowing.html#borrowing\n \n So, that\u2019s the real definition of \u2018immutability\u2019: is this safe to have two\n pointers to? In `Arc<T>`\u2019s case, yes: the mutation is entirely contained inside"}, {"sha": "21ebd6333f7101bd2d2d28db0d5fa013b3606369", "filename": "src/doc/book/src/ownership.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fownership.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -65,10 +65,10 @@ elements onto them.\n Vectors have a [generic type][generics] `Vec<T>`, so in this example `v` will have type\n `Vec<i32>`. We'll cover [generics] in detail in a later chapter.\n \n-[arrays]: primitive-types.html#Arrays\n+[arrays]: primitive-types.html#arrays\n [vectors]: vectors.html\n-[heap]: the-stack-and-the-heap.html#The%20Heap\n-[stack]: the-stack-and-the-heap.html#The%20Stack\n+[heap]: the-stack-and-the-heap.html#the-heap\n+[stack]: the-stack-and-the-heap.html#the-stack\n [bindings]: variable-bindings.html\n [generics]: generics.html\n \n@@ -136,7 +136,7 @@ Rust allocates memory for an integer [i32] on the [stack][sh], copies the bit\n pattern representing the value of 10 to the allocated memory and binds the\n variable name x to this memory region for future reference.\n \n-[i32]: primitive-types.html#Numeric%20types\n+[i32]: primitive-types.html#numeric-types\n \n Now consider the following code fragment:\n "}, {"sha": "8fd3d17c15e57f5a90a59ed14f6bfb016b9cbd5d", "filename": "src/doc/book/src/primitive-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprimitive-types.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -232,7 +232,7 @@ soon.\n You can assign one tuple into another, if they have the same contained types\n and [arity]. Tuples have the same arity when they have the same length.\n \n-[arity]: glossary.html#Arity\n+[arity]: glossary.html#arity\n \n ```rust\n let mut x = (1, 2); // x: (i32, i32)"}, {"sha": "b2cd59c87af47f4f0a2a9c39f772ca2ee2343a15", "filename": "src/doc/book/src/syntax-index.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fsyntax-index.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -196,18 +196,18 @@\n [Associated Types]: associated-types.html\n [Attributes]: attributes.html\n [Casting Between Types (`as`)]: casting-between-types.html#as\n-[Closures (`move` closures)]: closures.html#move%20closures\n+[Closures (`move` closures)]: closures.html#move-closures\n [Closures]: closures.html\n [Comments]: comments.html\n-[Crates and Modules (Defining Modules)]: crates-and-modules.html#Defining%20modules\n-[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#Exporting%20a%20public%20interface\n-[Crates and Modules (Importing External Crates)]: crates-and-modules.html#Importing%20external%20crates\n-[Crates and Modules (Importing Modules with `use`)]: crates-and-modules.html#Importing%20modules%20with%20use\n-[Crates and Modules (Re-exporting with `pub use`)]: crates-and-modules.html#Re-exporting%20with%20pub%20use\n-[Diverging Functions]: functions.html#Diverging%20functions\n+[Crates and Modules (Defining Modules)]: crates-and-modules.html#defining-modules\n+[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#exporting-a-public-interface\n+[Crates and Modules (Importing External Crates)]: crates-and-modules.html#importing-external-crates\n+[Crates and Modules (Importing Modules with `use`)]: crates-and-modules.html#importing-modules-with-use\n+[Crates and Modules (Re-exporting with `pub use`)]: crates-and-modules.html#re-exporting-with-pub-use\n+[Diverging Functions]: functions.html#diverging-functions\n [Enums]: enums.html\n [Foreign Function Interface]: ffi.html\n-[Functions (Early Returns)]: functions.html#Early%20returns\n+[Functions (Early Returns)]: functions.html#early-returns\n [Functions]: functions.html\n [Generics]: generics.html\n [Iterators]: iterators.html\n@@ -216,38 +216,38 @@\n [Loops (`for`)]: loops.html#for\n [Loops (`loop`)]: loops.html#loop\n [Loops (`while`)]: loops.html#while\n-[Loops (Ending Iteration Early)]: loops.html#Ending%20iteration%20early\n-[Loops (Loops Labels)]: loops.html#Loop%20labels\n+[Loops (Ending Iteration Early)]: loops.html#ending-iteration-early\n+[Loops (Loops Labels)]: loops.html#loop-labels\n [Macros]: macros.html\n [Match]: match.html\n-[Method Syntax (Method Calls)]: method-syntax.html#Method%20calls\n+[Method Syntax (Method Calls)]: method-syntax.html#method-calls\n [Method Syntax]: method-syntax.html\n [Mutability]: mutability.html\n [Operators and Overloading]: operators-and-overloading.html\n-[Patterns (`ref` and `ref mut`)]: patterns.html#ref%20and%20ref%20mut\n-[Patterns (Bindings)]: patterns.html#Bindings\n-[Patterns (Ignoring bindings)]: patterns.html#Ignoring%20bindings\n-[Patterns (Multiple patterns)]: patterns.html#Multiple%20patterns\n-[Patterns (Ranges)]: patterns.html#Ranges\n+[Patterns (`ref` and `ref mut`)]: patterns.html#ref-and-ref-mut\n+[Patterns (Bindings)]: patterns.html#bindings\n+[Patterns (Ignoring bindings)]: patterns.html#ignoring-bindings\n+[Patterns (Multiple patterns)]: patterns.html#multiple-patterns\n+[Patterns (Ranges)]: patterns.html#ranges\n [Primitive Types (`char`)]: primitive-types.html#char\n-[Primitive Types (Arrays)]: primitive-types.html#Arrays\n-[Primitive Types (Booleans)]: primitive-types.html#Booleans\n-[Primitive Types (Tuple Indexing)]: primitive-types.html#Tuple%20indexing\n-[Primitive Types (Tuples)]: primitive-types.html#Tuples\n+[Primitive Types (Arrays)]: primitive-types.html#arrays\n+[Primitive Types (Booleans)]: primitive-types.html#booleans\n+[Primitive Types (Tuple Indexing)]: primitive-types.html#tuple-indexing\n+[Primitive Types (Tuples)]: primitive-types.html#tuples\n [Raw Pointers]: raw-pointers.html\n [Reference (Byte String Literals)]: ../reference.html#byte-string-literals\n [Reference (Integer literals)]: ../reference.html#integer-literals\n [Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals\n [Reference (Raw String Literals)]: ../reference.html#raw-string-literals\n [References and Borrowing]: references-and-borrowing.html\n [Strings]: strings.html\n-[Structs (Update syntax)]: structs.html#Update%20syntax\n+[Structs (Update syntax)]: structs.html#update-syntax\n [Structs]: structs.html\n-[Traits (`where` clause)]: traits.html#Where%20clause\n-[Traits (Multiple Trait Bounds)]: traits.html#Multiple%20trait%20bounds\n+[Traits (`where` clause)]: traits.html#where-clause\n+[Traits (Multiple Trait Bounds)]: traits.html#multiple-trait-bounds\n [Traits]: traits.html\n [Universal Function Call Syntax]: ufcs.html\n-[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#Angle-bracket%20Form\n+[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#angle-bracket-form\n [Unsafe]: unsafe.html\n-[Unsized Types (`?Sized`)]: unsized-types.html#Sized\n+[Unsized Types (`?Sized`)]: unsized-types.html#sized\n [Variable Bindings]: variable-bindings.html"}, {"sha": "19a133f84b0b6ffee92eaf55645bfc1989e4263b", "filename": "src/doc/book/src/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ftraits.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -81,7 +81,7 @@ Traits are useful because they allow a type to make certain promises about its\n behavior. Generic functions can exploit this to constrain, or [bound][bounds], the types they\n accept. Consider this function, which does not compile:\n \n-[bounds]: glossary.html#Bounds\n+[bounds]: glossary.html#bounds\n \n ```rust,ignore\n fn print_area<T>(shape: T) {"}, {"sha": "1bd0f78e36853143cf391b91957ef653c1ed20a9", "filename": "src/doc/book/src/type-aliases.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Ftype-aliases.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -55,7 +55,7 @@ if x == y {\n This compiles without error. Values of a `Num` type are the same as a value of\n type `i32`, in every way. You can use [tuple struct] to really get a new type.\n \n-[tuple struct]: structs.html#Tuple%20structs\n+[tuple struct]: structs.html#tuple-structs\n \n You can also use type aliases with generics:\n "}, {"sha": "aff078718dfb1311726529cb5199d7c2001d8288", "filename": "src/doc/book/src/vectors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fvectors.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -151,6 +151,6 @@ API documentation][vec].\n [vec]: ../std/vec/index.html\n [box]: ../std/boxed/index.html\n [generic]: generics.html\n-[panic]: concurrency.html#Panics\n+[panic]: concurrency.html#panics\n [get]: ../std/vec/struct.Vec.html#method.get\n [get_mut]: ../std/vec/struct.Vec.html#method.get_mut"}, {"sha": "30b4f09f9032de94c3c10e39e3ef112448524a1a", "filename": "src/doc/nomicon/src/lifetime-mismatch.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Flifetime-mismatch.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -78,4 +78,4 @@ TODO: other common problems? SEME regions stuff, mostly?\n \n \n \n-[ex2]: lifetimes.html#Example%3A%20aliasing%20a%20mutable%20reference\n+[ex2]: lifetimes.html#example-aliasing-a-mutable-reference"}, {"sha": "c02cf44189f1a704354712dbed60f2b31f73fa47", "filename": "src/doc/nomicon/src/repr-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsrc%2Frepr-rust.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -151,4 +151,4 @@ use fairly elaborate algorithms to cache bits throughout nested types with\n special constrained representations. As such it is *especially* desirable that\n we leave enum layout unspecified today.\n \n-[dst]: exotic-sizes.html#Dynamically%20Sized%20Types%20(DSTs)\n+[dst]: exotic-sizes.html#dynamically-sized-types-dsts"}, {"sha": "15645fa9e31df80a0e3f1594158b32cceed2013f", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -2108,7 +2108,7 @@ On `struct`s:\n   list of names `#[macro_use(foo, bar)]` restricts the import to just those\n   macros named.  The `extern crate` must appear at the crate root, not inside\n   `mod`, which ensures proper function of the [`$crate` macro\n-  variable](book/macros.html#The%20variable%20%24crate).\n+  variable](book/macros.html#the-variable-crate).\n \n - `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n \n@@ -2118,7 +2118,7 @@ On `struct`s:\n   link it into the output.\n \n See the [macros section of the\n-book](book/macros.html#Scoping%20and%20macro%20import%2Fexport) for more information on\n+book](book/macros.html#scoping-and-macro-importexport) for more information on\n macro scope.\n \n \n@@ -2277,7 +2277,7 @@ For any lint check `C`:\n \n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.  [Compiler\n-plugins](book/compiler-plugins.html#Lint%20plugins) can provide additional lint checks.\n+plugins](book/compiler-plugins.html#lint-plugins) can provide additional lint checks.\n \n ```{.ignore}\n pub mod m1 {"}, {"sha": "38d843263ffda09c7c1609e684a42da31a9763df", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -102,7 +102,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [assoc]: ../../book/method-syntax.html#Associated%20functions\n+/// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n /// # Examples\n ///"}, {"sha": "6108a06634bb88cfaefafda0e88a76f80aa12e2d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -215,7 +215,7 @@\n //! [downgrade]: struct.Rc.html#method.downgrade\n //! [upgrade]: struct.Weak.html#method.upgrade\n //! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [assoc]: ../../book/method-syntax.html#Associated%20functions\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n //! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "209107ef92ceb824f67ae3dea053c3f2503b3922", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -525,7 +525,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// it will not release any borrows, as borrows are based on lexical scope.\n ///\n /// This effectively does nothing for\n-/// [types which implement `Copy`](../../book/ownership.html#Copy%20types),\n+/// [types which implement `Copy`](../../book/ownership.html#copy-types),\n /// e.g. integers. Such values are copied and _then_ moved into the function,\n /// so the value persists after this function call.\n ///"}, {"sha": "a7d0d3899b181d2dd3add95f7bbb46c2bb83ced3", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -25,7 +25,7 @@\n /// Book][moreinfo] contains more details about the precise nature of\n /// these internals.\n ///\n-/// [moreinfo]: ../../book/trait-objects.html#Representation\n+/// [moreinfo]: ../../book/trait-objects.html#representation\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g. the fields are not directly accessible"}, {"sha": "9295fb2ee327b4f5910b4c29be7b12c8fc4491a6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 221, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -65,9 +65,6 @@ use super::region_inference::ConcreteFailure;\n use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n-use super::region_inference::ProcessedErrors;\n-use super::region_inference::ProcessedErrorOrigin;\n-use super::region_inference::SameRegions;\n \n use hir::map as hir_map;\n use hir;\n@@ -77,11 +74,10 @@ use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, ReFree, Issue32330};\n+use ty::{Region, Issue32330};\n use ty::error::TypeError;\n \n use std::fmt;\n-use syntax::ast;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -255,8 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:\n-        let processed_errors = self.process_errors(errors);\n-        let errors = processed_errors.as_ref().unwrap_or(errors);\n+        let errors = self.process_errors(errors);\n \n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n@@ -278,13 +273,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                  sub_origin, sub_r,\n                                                  sup_origin, sup_r);\n                 }\n-\n-                ProcessedErrors(ref origins,\n-                                ref same_regions) => {\n-                    if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins);\n-                    }\n-                }\n             }\n         }\n     }\n@@ -300,202 +288,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n-        let mut origins = Vec::new();\n-\n-        // we collect up ConcreteFailures and SubSupConflicts that are\n-        // relating free-regions bound on the fn-header and group them\n-        // together into this vector\n-        let mut same_regions = Vec::new();\n-\n-        // here we put errors that we will not be able to process nicely\n-        let mut other_errors = Vec::new();\n-\n-        // we collect up GenericBoundFailures in here.\n-        let mut bound_failures = Vec::new();\n-\n-        for error in errors {\n-            // Check whether we can process this error into some other\n-            // form; if not, fall through.\n-            match *error {\n-                ConcreteFailure(ref origin, sub, sup) => {\n-                    debug!(\"processing ConcreteFailure\");\n-                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n-                        // When comparing an impl method against a\n-                        // trait method, it is not helpful to suggest\n-                        // changes to the impl method.  This is\n-                        // because the impl method signature is being\n-                        // checked using the trait's environment, so\n-                        // usually the changes we suggest would\n-                        // actually have to be applied to the *trait*\n-                        // method (and it's not clear that the trait\n-                        // method is even under the user's control).\n-                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        origins.push(\n-                            ProcessedErrorOrigin::ConcreteFailure(\n-                                origin.clone(),\n-                                sub,\n-                                sup));\n-                        append_to_same_regions(&mut same_regions, &same_frs);\n-                        continue;\n-                    }\n-                }\n-                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n-                    match (sub_origin, sup_origin) {\n-                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n-                            // As above, when comparing an impl method\n-                            // against a trait method, it is not helpful\n-                            // to suggest changes to the impl method.\n-                        }\n-                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n-                            // See above.\n-                        }\n-                        _ => {\n-                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n-                                origins.push(\n-                                    ProcessedErrorOrigin::VariableFailure(\n-                                        var_origin.clone()));\n-                                append_to_same_regions(&mut same_regions, &same_frs);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-                GenericBoundFailure(ref origin, ref kind, region) => {\n-                    bound_failures.push((origin.clone(), kind.clone(), region));\n-                    continue;\n-                }\n-                ProcessedErrors(..) => {\n-                    bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n-                }\n-            }\n-\n-            // No changes to this error.\n-            other_errors.push(error.clone());\n-        }\n-\n-        // ok, let's pull together the errors, sorted in an order that\n-        // we think will help user the best\n-        let mut processed_errors = vec![];\n-\n-        // first, put the processed errors, if any\n-        if !same_regions.is_empty() {\n-            let common_scope_id = same_regions[0].scope_id;\n-            for sr in &same_regions {\n-                // Since ProcessedErrors is used to reconstruct the function\n-                // declaration, we want to make sure that they are, in fact,\n-                // from the same scope\n-                if sr.scope_id != common_scope_id {\n-                    debug!(\"returning empty result from process_errors because\n-                            {} != {}\", sr.scope_id, common_scope_id);\n-                    return None;\n-                }\n-            }\n-            assert!(origins.len() > 0);\n-            let pe = ProcessedErrors(origins, same_regions);\n-            debug!(\"errors processed: {:?}\", pe);\n-            processed_errors.push(pe);\n-        }\n-\n-        // next, put the other misc errors\n-        processed_errors.extend(other_errors);\n-\n-        // finally, put the `T: 'a` errors, but only if there were no\n-        // other errors. otherwise, these have a very high rate of\n-        // being unhelpful in practice. This is because they are\n-        // basically secondary checks that test the state of the\n-        // region graph after the rest of inference is done, and the\n-        // other kinds of errors indicate that the region constraint\n-        // graph is internally inconsistent, so these test results are\n-        // likely to be meaningless.\n-        if processed_errors.is_empty() {\n-            for (origin, kind, region) in bound_failures {\n-                processed_errors.push(GenericBoundFailure(origin, kind, region));\n-            }\n-        }\n \n-        // we should always wind up with SOME errors, unless there were no\n-        // errors to start\n-        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n-\n-        return Some(processed_errors);\n-\n-        #[derive(Debug)]\n-        struct FreeRegionsFromSameFn {\n-            sub_fr: ty::FreeRegion,\n-            sup_fr: ty::FreeRegion,\n-            scope_id: ast::NodeId\n-        }\n-\n-        impl FreeRegionsFromSameFn {\n-            fn new(sub_fr: ty::FreeRegion,\n-                   sup_fr: ty::FreeRegion,\n-                   scope_id: ast::NodeId)\n-                   -> FreeRegionsFromSameFn {\n-                FreeRegionsFromSameFn {\n-                    sub_fr: sub_fr,\n-                    sup_fr: sup_fr,\n-                    scope_id: scope_id\n-                }\n-            }\n-        }\n-\n-        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: &'tcx Region,\n-                                                     sup: &'tcx Region)\n-                                                     -> Option<FreeRegionsFromSameFn> {\n-            debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n-            let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (&ReFree(fr1), &ReFree(fr2)) => {\n-                    if fr1.scope != fr2.scope {\n-                        return None\n-                    }\n-                    assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id(&tcx.region_maps), fr1, fr2)\n-                },\n-                _ => return None\n-            };\n-            let parent = tcx.hir.get_parent(scope_id);\n-            let parent_node = tcx.hir.find(parent);\n-            match parent_node {\n-                Some(node) => match node {\n-                    hir_map::NodeItem(item) => match item.node {\n-                        hir::ItemFn(..) => {\n-                            Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                        },\n-                        _ => None\n-                    },\n-                    hir_map::NodeImplItem(..) |\n-                    hir_map::NodeTraitItem(..) => {\n-                        Some(FreeRegionsFromSameFn::new(fr1, fr2, scope_id))\n-                    },\n-                    _ => None\n-                },\n-                None => {\n-                    debug!(\"no parent node of scope_id {}\", scope_id);\n-                    None\n-                }\n-            }\n-        }\n+        // We want to avoid reporting generic-bound failures if we can\n+        // avoid it: these have a very high rate of being unhelpful in\n+        // practice. This is because they are basically secondary\n+        // checks that test the state of the region graph after the\n+        // rest of inference is done, and the other kinds of errors\n+        // indicate that the region constraint graph is internally\n+        // inconsistent, so these test results are likely to be\n+        // meaningless.\n+        //\n+        // Therefore, we filter them out of the list unless they are\n+        // the only thing in the list.\n+\n+        let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n+            ConcreteFailure(..) => false,\n+            SubSupConflict(..) => false,\n+            GenericBoundFailure(..) => true,\n+        };\n \n-        fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n-                                  same_frs: &FreeRegionsFromSameFn) {\n-            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n-                   same_regions, same_frs);\n-            let scope_id = same_frs.scope_id;\n-            let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in same_regions.iter_mut() {\n-                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n-                    sr.push(sub_fr.bound_region);\n-                    return\n-                }\n-            }\n-            same_regions.push(SameRegions {\n-                scope_id: scope_id,\n-                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n-            })\n+        if errors.iter().all(|e| is_bound_failure(e)) {\n+            errors.clone()\n+        } else {\n+            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n         }\n     }\n \n@@ -1072,20 +889,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n-        for origin in origins.iter() {\n-            let mut err = match *origin {\n-                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n-                    self.report_inference_failure(var_origin.clone()),\n-                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n-                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n-            };\n-\n-            err.emit();\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0bb9e2c7fa15c91345ea6c7ec0c7acb630d91410", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -24,7 +24,7 @@ use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n-use ty::{BoundRegion, Region, RegionVid};\n+use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n@@ -171,13 +171,6 @@ pub enum RegionResolutionError<'tcx> {\n                    &'tcx Region,\n                    SubregionOrigin<'tcx>,\n                    &'tcx Region),\n-\n-    /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n-    /// more specific errors message by suggesting to the user where they\n-    /// should put a lifetime. In those cases we process and put those errors\n-    /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n-                    Vec<SameRegions>),\n }\n \n #[derive(Clone, Debug)]\n@@ -186,33 +179,6 @@ pub enum ProcessedErrorOrigin<'tcx> {\n     VariableFailure(RegionVariableOrigin),\n }\n \n-/// SameRegions is used to group regions that we think are the same and would\n-/// like to indicate so to the user.\n-/// For example, the following function\n-/// ```\n-/// struct Foo { bar: i32 }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b i32 {\n-///    &x.bar\n-/// }\n-/// ```\n-/// would report an error because we expect 'a and 'b to match, and so we group\n-/// 'a and 'b together inside a SameRegions struct\n-#[derive(Clone, Debug)]\n-pub struct SameRegions {\n-    pub scope_id: ast::NodeId,\n-    pub regions: Vec<BoundRegion>,\n-}\n-\n-impl SameRegions {\n-    pub fn contains(&self, other: &BoundRegion) -> bool {\n-        self.regions.contains(other)\n-    }\n-\n-    pub fn push(&mut self, other: BoundRegion) {\n-        self.regions.push(other);\n-    }\n-}\n-\n pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "fd5827b4c07537abeadc123e0550dfc61a135894", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -182,15 +182,15 @@ impl DefaultResizePolicy {\n // ----------------------\n // To protect against degenerate performance scenarios (including DOS attacks),\n // the implementation includes an adaptive behavior that can resize the map\n-// early (before it's capacity is exceeded) when suspiciously long probe or\n-// foward shifts sequences are encounted.\n+// early (before its capacity is exceeded) when suspiciously long probe or\n+// forward shifts sequences are encountered.\n //\n // With this algorithm in place it would be possible to turn a CPU attack into\n-// a memory attack due to the agressive resizing. To prevent that the\n+// a memory attack due to the aggressive resizing. To prevent that the\n // adaptive behavior only triggers when the map occupancy is half the maximum occupancy.\n-// This reduces the effectivenes of the algorithm but also makes it completelly safe.\n+// This reduces the effectiveness of the algorithm but also makes it completely safe.\n //\n-// The previous safety measure that also prevents degenerate iteractions with\n+// The previous safety measure also prevents degenerate interactions with\n // really bad quality hash algorithms that can make normal inputs look like a\n // DOS attack.\n //"}, {"sha": "070690773b6c4792a05dc525ce790c9d1cdc72ce", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -189,8 +189,8 @@\n //! [`sync`]: sync/index.html\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n-//! [`use`]: ../book/crates-and-modules.html#Importing%20Modules%20with%20use\n-//! [crate root]: ../book/crates-and-modules.html#Basic%20terminology%3A%20Crates%20and%20Modules\n+//! [`use`]: ../book/crates-and-modules.html#importing-modules-with-use\n+//! [crate root]: ../book/crates-and-modules.html#basic-terminology-crates-and-modules\n //! [crates.io]: https://crates.io\n //! [deref coercions]: ../book/deref-coercions.html\n //! [files]: fs/struct.File.html"}, {"sha": "11197db98a39680b098af9d929f637f5954a9d7c", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -490,7 +490,7 @@ mod prim_str { }\n /// assert_eq!(tuple.2, 'c');\n /// ```\n ///\n-/// For more about tuples, see [the book](../book/primitive-types.html#Tuples).\n+/// For more about tuples, see [the book](../book/primitive-types.html#tuples).\n ///\n /// # Trait implementations\n ///"}, {"sha": "9724d17bef1eaf446e77c95e0a0d7b59975fe0e1", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -108,9 +108,6 @@ impl Debug for Player {\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n     match to_parse { //~ ERROR match arms have incompatible types\n-    //~^ expected enum `RoomDirection`, found enum `std::option::Option`\n-    //~| expected type `RoomDirection`\n-    //~| found type `std::option::Option<_>`\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,\n@@ -119,7 +116,7 @@ fn str_to_direction(to_parse: &str) -> RoomDirection {\n         \"out\" => RoomDirection::Out,\n         \"up\" => RoomDirection::Up,\n         \"down\" => RoomDirection::Down,\n-        _ => None //~ NOTE match arm with an incompatible type\n+        _ => None\n     }\n }\n "}, {"sha": "9c1a4dbdffa846c24e266cc86e93398ea6d5fe11", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[derive(Copy, Clone)]\n enum E { V1(isize), V0 }\n+\n const C: &'static [E] = &[E::V0, E::V1(0xDEADBEE)];\n static C0: E = C[0];\n static C1: E = C[1];"}, {"sha": "30239f4c0946c0234f36ab67551a0dd6195ca11e", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "85e05422ab3b2f2e58aae9ec34194294dbc425f6", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,25 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:12:27\n+   |\n+12 |     if x > y { x } else { y }\n+   |                           ^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the body at 11:43...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+   |\n+11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n+   |  ____________________________________________^ starting here...\n+12 | |     if x > y { x } else { y }\n+13 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "098950e13b3154f8832fd1240afde3319587b08d", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(x: &i32, y: &i32) -> &i32 {\n+    if x > y { x } else { y }\n+}\n+\n+fn main() { }"}, {"sha": "fccc44caac81a5f7e25b11cdb0ca893266387bd7", "filename": "src/test/ui/lifetime-errors/ex1b-return-no-names-if-else.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1b-return-no-names-if-else.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,10 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/ex1b-return-no-names-if-else.rs:11:29\n+   |\n+11 | fn foo(x: &i32, y: &i32) -> &i32 {\n+   |                             ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n+\n+error: aborting due to previous error\n+"}, {"sha": "71a1c865e09957e447621d70e0ac45e1717abe1f", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "6f42a9f679a6a51225746d8d0f386139afc0f8f4", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2a-push-one-existing-name.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'a, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #2 defined on the body at 15:51...\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+   |\n+15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n+   |  ____________________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "09038d8ce9027ce0708f2f314c58bd5e637d61e8", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+    x.push(y);\n+}\n+\n+fn main() { }"}, {"sha": "edc1c2362de57c597c75e923f1d8d81cca6dee04", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/ex2b-push-no-existing-names.rs:16:12\n+   |\n+16 |     x.push(y);\n+   |            ^ lifetime mismatch\n+   |\n+   = note: expected type `Ref<'_, i32>`\n+              found type `Ref<'_, i32>`\n+note: the anonymous lifetime #3 defined on the body at 15:43...\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+   |\n+15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n+   |  ____________________________________________^ starting here...\n+16 | |     x.push(y);\n+17 | | }\n+   | |_^ ...ending here\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb083f778deeb7e2e8d0e493988a60342a3efdd5", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let z = Ref { data: y.data };\n+    x.push(z);\n+}\n+\n+fn main() { }"}, {"sha": "755b71d4a1d9e9eabb90fbfaacda6d517096d634", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,37 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2c-push-inference-variable.rs:16:13\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2c-push-inference-variable.rs:16:25\n+   |\n+16 |     let z = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let z = Ref { data: y.data };\n+17 | |     x.push(z);\n+18 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+  --> $DIR/ex2c-push-inference-variable.rs:17:12\n+   |\n+17 |     x.push(z);\n+   |            ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bcb7583beefcf5f28d45b2c0add7323f2fe56cb0", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    a.push(b);\n+}\n+\n+fn main() { }"}, {"sha": "daa6ea2d91aa3b567334a89cf84fad9a32e713ab", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2d-push-inference-variable-2.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     a.push(b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2d-push-inference-variable-2.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2d05adb7ecd370b660bb8b13765cf071ba0e04c5", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Ref<'a, T: 'a> {\n+    data: &'a T\n+}\n+\n+fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+    let a: &mut Vec<Ref<i32>> = x;\n+    let b = Ref { data: y.data };\n+    Vec::push(a, b);\n+}\n+\n+fn main() { }"}, {"sha": "b679532a4d91086ef85d0a22b5a81541e9780e01", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -0,0 +1,39 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:13\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |             ^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/ex2e-push-inference-variable-3.rs:17:25\n+   |\n+17 |     let b = Ref { data: y.data };\n+   |                         ^^^^^^\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+   |\n+15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n+   |  ___________________________________________________________________^ starting here...\n+16 | |     let a: &mut Vec<Ref<i32>> = x;\n+17 | |     let b = Ref { data: y.data };\n+18 | |     Vec::push(a, b);\n+19 | | }\n+   | |_^ ...ending here\n+note: ...so that expression is assignable (expected &mut std::vec::Vec<Ref<'_, i32>>, found &mut std::vec::Vec<Ref<'b, i32>>)\n+  --> $DIR/ex2e-push-inference-variable-3.rs:16:33\n+   |\n+16 |     let a: &mut Vec<Ref<i32>> = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "ba5ca44526b86340be3209a2233d7dbd5324a58f", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -65,6 +65,7 @@ enum Redirect {\n struct FileEntry {\n     source: String,\n     ids: HashSet<String>,\n+    names: HashSet<String>,\n }\n \n type Cache = HashMap<PathBuf, FileEntry>;\n@@ -81,6 +82,15 @@ impl FileEntry {\n             });\n         }\n     }\n+\n+    fn parse_names(&mut self, contents: &str) {\n+        if self.names.is_empty() {\n+            with_attrs_in_source(contents, \" name\", |fragment, _| {\n+                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                self.names.insert(frag);\n+            });\n+        }\n+    }\n }\n \n fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n@@ -139,6 +149,9 @@ fn check(cache: &mut Cache,\n         cache.get_mut(&pretty_file)\n              .unwrap()\n              .parse_ids(&pretty_file, &contents, errors);\n+        cache.get_mut(&pretty_file)\n+             .unwrap()\n+             .parse_names(&contents);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n@@ -209,13 +222,6 @@ fn check(cache: &mut Cache,\n                 Err(LoadError::IsRedirect) => unreachable!(),\n             };\n \n-            // we don't check the book for fragments because they're added via JS\n-            for book in [\"book/\", \"nomicon/\"].iter() {\n-                if !pretty_path.to_str().unwrap().starts_with(book) {\n-                    return;\n-                }\n-            }\n-\n             if let Some(ref fragment) = fragment {\n                 // Fragments like `#1-6` are most likely line numbers to be\n                 // interpreted by javascript, so we're ignoring these\n@@ -226,8 +232,9 @@ fn check(cache: &mut Cache,\n \n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n+                entry.parse_names(&contents);\n \n-                if !entry.ids.contains(*fragment) {\n+                if !(entry.ids.contains(*fragment) || entry.names.contains(*fragment)) {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment  \",\n                            pretty_file.display(),\n@@ -277,6 +284,7 @@ fn load_file(cache: &mut Cache,\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n+                    names: HashSet::new(),\n                 });\n             }\n             maybe"}, {"sha": "f7a452d9f7bd7fef1311a739827ddf7ab7f4a5f3", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c1368fc4f497b6387b00850dc5a95df5d6974b43/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=c1368fc4f497b6387b00850dc5a95df5d6974b43", "patch": "@@ -8,5 +8,5 @@ license = \"MIT/Apache-2.0\"\n clap = \"2.19.3\"\n \n [dependencies.mdbook]\n-version = \"0.0.15\"\n+version = \"0.0.16\"\n default-features = false"}]}