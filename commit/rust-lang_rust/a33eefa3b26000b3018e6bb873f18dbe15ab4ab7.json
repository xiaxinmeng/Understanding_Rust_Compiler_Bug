{"sha": "a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzM2VlZmEzYjI2MDAwYjMwMThlNmJiODczZjE4ZGJlMTVhYjRhYjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-01T18:41:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T18:41:06Z"}, "message": "Merge #5149\n\n5149: Implement Chalk variable kinds r=flodiebold a=flodiebold\n\nThis means we need to keep track of the kinds (general/int/float) of variables in `Canonical`, which requires some more ceremony. (It also exposes some places where we're not really dealing with canonicalization correctly -- another thing to be cleaned up when we switch to using Chalk's types directly.)\r\n\r\nShould fix the last remaining issue of #2534.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "da55aac24be34db6750e6675673317f52e7db4dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da55aac24be34db6750e6675673317f52e7db4dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/NjCCRBK7hj4Ov3rIwAAdHIIADk0h67M12Py/YZ6aAAAfdXB\nPMJebwXOBUTlcpBeaUhIrpy5NCIqeTG3Vfd3ZI5POXxvlTC90ZMOnXGU7fXBt1cn\njZYl+auDp1rLbyeNzCuV6YC1Nx5Kn8IuuOrn5F1HCtF1zUHm1Oh2jlSN+p/hkVPj\nydMcb1xPsHdaHGLa9HTfytY1BCgxqv9uIDhhac5WDS7PuI2tPt+g00SHqlq11j9D\nyKFh/N6wQ+Xp3ohwbPhNhTPLaUmRjJDzJ6kon2g60joIT7oqt6GTD1LslieLZbaF\nq6odqrg/UcfPLBzadLcmbg98eRRUjnz+54BOsTmY8Kbi1UQwpN8Es7qB14u+JCA=\n=thLZ\n-----END PGP SIGNATURE-----\n", "payload": "tree da55aac24be34db6750e6675673317f52e7db4dc\nparent ec1d1a1b709a6eafff07077cdf75291d01cda3b6\nparent d5d485ef9289589332893f2c0ad96cb366afe9d6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593628866 +0000\ncommitter GitHub <noreply@github.com> 1593628866 +0000\n\nMerge #5149\n\n5149: Implement Chalk variable kinds r=flodiebold a=flodiebold\n\nThis means we need to keep track of the kinds (general/int/float) of variables in `Canonical`, which requires some more ceremony. (It also exposes some places where we're not really dealing with canonicalization correctly -- another thing to be cleaned up when we switch to using Chalk's types directly.)\r\n\r\nShould fix the last remaining issue of #2534.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "html_url": "https://github.com/rust-lang/rust/commit/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1d1a1b709a6eafff07077cdf75291d01cda3b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1d1a1b709a6eafff07077cdf75291d01cda3b6", "html_url": "https://github.com/rust-lang/rust/commit/ec1d1a1b709a6eafff07077cdf75291d01cda3b6"}, {"sha": "d5d485ef9289589332893f2c0ad96cb366afe9d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d485ef9289589332893f2c0ad96cb366afe9d6", "html_url": "https://github.com/rust-lang/rust/commit/d5d485ef9289589332893f2c0ad96cb366afe9d6"}], "stats": {"total": 211, "additions": 140, "deletions": 71}, "files": [{"sha": "1b3525011d9486a301571913b73d9e933f328fa1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -1189,7 +1189,7 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n         method_resolution::implements_trait(\n             &canonical_ty,\n             db,\n@@ -1213,7 +1213,7 @@ impl Type {\n                 self.ty.environment.clone(),\n                 hir_ty::Obligation::Trait(trait_ref),\n             ),\n-            num_vars: 0,\n+            kinds: Arc::new([]),\n         };\n \n         db.trait_solve(self.krate, goal).is_some()\n@@ -1288,7 +1288,7 @@ impl Type {\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n         let environment = self.ty.environment.clone();\n         let ty = InEnvironment { value: canonical, environment };\n         autoderef(db, Some(self.krate), ty)\n@@ -1329,7 +1329,7 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;\n@@ -1360,7 +1360,7 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;"}, {"sha": "c727012c69de33681a52f05bcbbd2bf03507bae2", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -37,7 +37,7 @@ pub(crate) fn deref(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     if let Some(derefed) = ty.value.value.builtin_deref() {\n-        Some(Canonical { value: derefed, num_vars: ty.value.num_vars })\n+        Some(Canonical { value: derefed, kinds: ty.value.kinds.clone() })\n     } else {\n         deref_by_trait(db, krate, ty)\n     }\n@@ -68,8 +68,8 @@ fn deref_by_trait(\n \n     // Check that the type implements Deref at all\n     let trait_ref = TraitRef { trait_: deref_trait, substs: parameters.clone() };\n-    let implements_goal = super::Canonical {\n-        num_vars: ty.value.num_vars,\n+    let implements_goal = Canonical {\n+        kinds: ty.value.kinds.clone(),\n         value: InEnvironment {\n             value: Obligation::Trait(trait_ref),\n             environment: ty.environment.clone(),\n@@ -81,15 +81,16 @@ fn deref_by_trait(\n \n     // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n-        ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.num_vars)),\n+        ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len())),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);\n \n     let in_env = InEnvironment { value: obligation, environment: ty.environment };\n \n-    let canonical = super::Canonical { num_vars: 1 + ty.value.num_vars, value: in_env };\n+    let canonical =\n+        Canonical::new(in_env, ty.value.kinds.iter().copied().chain(Some(super::TyKind::General)));\n \n     let solution = db.trait_solve(krate, canonical)?;\n \n@@ -110,7 +111,7 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..vars.0.num_vars {\n+            for i in 1..vars.0.kinds.len() {\n                 if vars.0.value[i - 1] != Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n@@ -119,7 +120,7 @@ fn deref_by_trait(\n             }\n             Some(Canonical {\n                 value: vars.0.value[vars.0.value.len() - 1].clone(),\n-                num_vars: vars.0.num_vars,\n+                kinds: vars.0.kinds.clone(),\n             })\n         }\n         Solution::Ambig(_) => {"}, {"sha": "2e895d911683c7f18b2cdace38d9b3a19a998cfb", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -9,7 +9,7 @@ use test_utils::mark;\n use super::{InferenceContext, Obligation};\n use crate::{\n     BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Substs, Ty,\n-    TypeCtor, TypeWalk,\n+    TyKind, TypeCtor, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -86,10 +86,20 @@ where\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n-        Canonicalized {\n-            value: Canonical { value: result, num_vars: self.free_vars.len() },\n-            free_vars: self.free_vars,\n-        }\n+        let kinds = self\n+            .free_vars\n+            .iter()\n+            .map(|v| match v {\n+                // mapping MaybeNeverTypeVar to the same kind as general ones\n+                // should be fine, because as opposed to int or float type vars,\n+                // they don't restrict what kind of type can go into them, they\n+                // just affect fallback.\n+                InferTy::TypeVar(_) | InferTy::MaybeNeverTypeVar(_) => TyKind::General,\n+                InferTy::IntVar(_) => TyKind::Integer,\n+                InferTy::FloatVar(_) => TyKind::Float,\n+            })\n+            .collect();\n+        Canonicalized { value: Canonical { value: result, kinds }, free_vars: self.free_vars }\n     }\n \n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n@@ -131,26 +141,41 @@ impl<T> Canonicalized<T> {\n         ty\n     }\n \n-    pub fn apply_solution(&self, ctx: &mut InferenceContext<'_>, solution: Canonical<Vec<Ty>>) {\n+    pub fn apply_solution(&self, ctx: &mut InferenceContext<'_>, solution: Canonical<Substs>) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n+        let new_vars = Substs(\n+            solution\n+                .kinds\n+                .iter()\n+                .map(|k| match k {\n+                    TyKind::General => ctx.table.new_type_var(),\n+                    TyKind::Integer => ctx.table.new_integer_var(),\n+                    TyKind::Float => ctx.table.new_float_var(),\n+                })\n+                .collect(),\n+        );\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n-            let ty = ctx.normalize_associated_types_in(ty.subst_bound_vars(&new_vars));\n+            let ty = ctx.normalize_associated_types_in(ty.clone().subst_bound_vars(&new_vars));\n             ctx.table.unify(&Ty::Infer(var), &ty);\n         }\n     }\n }\n \n-pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n+pub fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n     let mut table = InferenceTable::new();\n-    let num_vars = ty1.num_vars.max(ty2.num_vars);\n-    let vars =\n-        Substs::builder(num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n-    let ty1_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n-    let ty2_with_vars = ty2.value.clone().subst_bound_vars(&vars);\n+    let vars = Substs(\n+        tys.kinds\n+            .iter()\n+            // we always use type vars here because we want everything to\n+            // fallback to Unknown in the end (kind of hacky, as below)\n+            .map(|_| table.new_type_var())\n+            .collect(),\n+    );\n+    let ty1_with_vars = tys.value.0.clone().subst_bound_vars(&vars);\n+    let ty2_with_vars = tys.value.1.clone().subst_bound_vars(&vars);\n     if !table.unify(&ty1_with_vars, &ty2_with_vars) {\n         return None;\n     }\n@@ -162,7 +187,7 @@ pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n         }\n     }\n     Some(\n-        Substs::builder(ty1.num_vars)\n+        Substs::builder(tys.kinds.len())\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n             .build(),\n     )"}, {"sha": "7f3f5e771556e44243eaf0aeeb75e690b79a6f07", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -662,13 +662,27 @@ impl TypeWalk for GenericPredicate {\n \n /// Basically a claim (currently not validated / checked) that the contained\n /// type / trait ref contains no inference variables; any inference variables it\n-/// contained have been replaced by bound variables, and `num_vars` tells us how\n-/// many there are. This is used to erase irrelevant differences between types\n-/// before using them in queries.\n+/// contained have been replaced by bound variables, and `kinds` tells us how\n+/// many there are and whether they were normal or float/int variables. This is\n+/// used to erase irrelevant differences between types before using them in\n+/// queries.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Canonical<T> {\n     pub value: T,\n-    pub num_vars: usize,\n+    pub kinds: Arc<[TyKind]>,\n+}\n+\n+impl<T> Canonical<T> {\n+    pub fn new(value: T, kinds: impl IntoIterator<Item = TyKind>) -> Self {\n+        Self { value, kinds: kinds.into_iter().collect() }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TyKind {\n+    General,\n+    Integer,\n+    Float,\n }\n \n /// A function signature as seen by type inference: Several parameter types and"}, {"sha": "a45febbf74ea978130eaf0828f07709bff4b0e70", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -2,7 +2,7 @@\n //! For details about how this works in rustc, see the method lookup page in the\n //! [rustc guide](https://rust-lang.github.io/rustc-guide/method-lookup.html)\n //! and the corresponding code mostly in librustc_typeck/check/method/probe.rs.\n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use hir_def::{\n@@ -17,7 +17,8 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use super::Substs;\n use crate::{\n     autoderef, db::HirDatabase, primitive::FloatBitness, utils::all_super_traits, ApplicationTy,\n-    Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n+    TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -372,7 +373,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let refed = Canonical {\n-        num_vars: deref_chain[0].num_vars,\n+        kinds: deref_chain[0].kinds.clone(),\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -388,7 +389,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let ref_muted = Canonical {\n-        num_vars: deref_chain[0].num_vars,\n+        kinds: deref_chain[0].kinds.clone(),\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -607,18 +608,19 @@ pub(crate) fn inherent_impl_substs(\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n     let vars = Substs::build_for_def(db, impl_id)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.num_vars)\n+        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.kinds.len())\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n-    let self_ty_with_vars =\n-        Canonical { num_vars: vars.len() + self_ty.num_vars, value: self_ty_with_vars };\n-    let substs = super::infer::unify(&self_ty_with_vars, self_ty);\n+    let mut kinds = self_ty.kinds.to_vec();\n+    kinds.extend(iter::repeat(TyKind::General).take(vars.len()));\n+    let tys = Canonical { kinds: kinds.into(), value: (self_ty_with_vars, self_ty.value.clone()) };\n+    let substs = super::infer::unify(&tys);\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained\n     // Unknown, and in that case we want the result to contain Unknown in those\n     // places again.\n-    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.num_vars))\n+    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.kinds.len()))\n }\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n@@ -678,15 +680,15 @@ fn generic_implements_goal(\n     trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n-    let num_vars = self_ty.num_vars;\n+    let mut kinds = self_ty.kinds.to_vec();\n     let substs = super::Substs::build_for_def(db, trait_)\n         .push(self_ty.value)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, num_vars)\n+        .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n-    let num_vars = substs.len() - 1 + self_ty.num_vars;\n+    kinds.extend(iter::repeat(TyKind::General).take(substs.len() - 1));\n     let trait_ref = TraitRef { trait_, substs };\n     let obligation = super::Obligation::Trait(trait_ref);\n-    Canonical { num_vars, value: InEnvironment::new(env, obligation) }\n+    Canonical { kinds: kinds.into(), value: InEnvironment::new(env, obligation) }\n }\n \n fn autoderef_method_receiver(\n@@ -699,9 +701,9 @@ fn autoderef_method_receiver(\n     if let Some(Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, parameters })) =\n         deref_chain.last().map(|ty| &ty.value)\n     {\n-        let num_vars = deref_chain.last().unwrap().num_vars;\n+        let kinds = deref_chain.last().unwrap().kinds.clone();\n         let unsized_ty = Ty::apply(TypeCtor::Slice, parameters.clone());\n-        deref_chain.push(Canonical { value: unsized_ty, num_vars })\n+        deref_chain.push(Canonical { value: unsized_ty, kinds })\n     }\n     deref_chain\n }"}, {"sha": "766790576d0b6d2d50a65ca31bdadb4db3eb3460", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -3029,3 +3029,21 @@ fn infer_dyn_fn_output() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn variable_kinds() {\n+    check_types(\n+        r#\"\n+trait Trait<T> { fn get(self, t: T) -> T; }\n+struct S;\n+impl Trait<u128> for S {}\n+impl Trait<f32> for S {}\n+fn test() {\n+    S.get(1);\n+  //^^^^^^^^ u128\n+    S.get(1.);\n+  //^^^^^^^^ f32\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "2a6d7faefe5637de3755f5c47ca74333fb88591e", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -1,5 +1,5 @@\n //! Trait solving using Chalk.\n-use std::{panic, sync::Arc};\n+use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n use hir_def::{\n@@ -8,7 +8,7 @@ use hir_def::{\n use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n \n-use crate::{db::HirDatabase, DebruijnIndex};\n+use crate::{db::HirDatabase, DebruijnIndex, Substs};\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n@@ -190,15 +190,7 @@ fn solution_from_chalk(\n     solution: chalk_solve::Solution<Interner>,\n ) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<Interner>>| {\n-        let value = subst\n-            .value\n-            .iter(&Interner)\n-            .map(|p| match p.ty(&Interner) {\n-                Some(ty) => from_chalk(db, ty.clone()),\n-                None => unimplemented!(),\n-            })\n-            .collect();\n-        let result = Canonical { value, num_vars: subst.binders.len(&Interner) };\n+        let result = from_chalk(db, subst);\n         SolutionVariables(result)\n     };\n     match solution {\n@@ -222,7 +214,7 @@ fn solution_from_chalk(\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct SolutionVariables(pub Canonical<Vec<Ty>>);\n+pub struct SolutionVariables(pub Canonical<Substs>);\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n /// A (possible) solution for a proposed goal."}, {"sha": "433d6aa03de3fdf64ac0e6522868dcfec621cdb9", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33eefa3b26000b3018e6bb873f18dbe15ab4ab7/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=a33eefa3b26000b3018e6bb873f18dbe15ab4ab7", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n     traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n     ApplicationTy, CallableDef, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n };\n \n use super::interner::*;\n@@ -555,22 +555,39 @@ where\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let parameter = chalk_ir::CanonicalVarKind::new(\n-            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n-            chalk_ir::UniverseIndex::ROOT,\n-        );\n+        let kinds = self\n+            .kinds\n+            .iter()\n+            .map(|k| match k {\n+                TyKind::General => chalk_ir::TyKind::General,\n+                TyKind::Integer => chalk_ir::TyKind::Integer,\n+                TyKind::Float => chalk_ir::TyKind::Float,\n+            })\n+            .map(|tk| {\n+                chalk_ir::CanonicalVarKind::new(\n+                    chalk_ir::VariableKind::Ty(tk),\n+                    chalk_ir::UniverseIndex::ROOT,\n+                )\n+            });\n         let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical {\n-            value,\n-            binders: chalk_ir::CanonicalVarKinds::from(&Interner, vec![parameter; self.num_vars]),\n-        }\n+        chalk_ir::Canonical { value, binders: chalk_ir::CanonicalVarKinds::from(&Interner, kinds) }\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        Canonical {\n-            num_vars: canonical.binders.len(&Interner),\n-            value: from_chalk(db, canonical.value),\n-        }\n+        let kinds = canonical\n+            .binders\n+            .iter(&Interner)\n+            .map(|k| match k.kind {\n+                chalk_ir::VariableKind::Ty(tk) => match tk {\n+                    chalk_ir::TyKind::General => TyKind::General,\n+                    chalk_ir::TyKind::Integer => TyKind::Integer,\n+                    chalk_ir::TyKind::Float => TyKind::Float,\n+                },\n+                chalk_ir::VariableKind::Lifetime => panic!(\"unexpected lifetime from Chalk\"),\n+                chalk_ir::VariableKind::Const(_) => panic!(\"unexpected const from Chalk\"),\n+            })\n+            .collect();\n+        Canonical { kinds, value: from_chalk(db, canonical.value) }\n     }\n }\n "}]}