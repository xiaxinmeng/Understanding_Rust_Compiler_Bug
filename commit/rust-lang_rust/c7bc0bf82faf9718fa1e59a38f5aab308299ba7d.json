{"sha": "c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YmMwYmY4MmZhZjk3MThmYTFlNTlhMzhmNWFhYjMwODI5OWJhN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T05:54:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T05:54:00Z"}, "message": "Auto merge of #64627 - nnethercote:ObligForest-even-more, r=nikomatsakis\n\nEven more `ObligationForest` improvements\n\nFollowing on from #64545, more speed and readability improvements.\n\nr? @nikomatsakis", "tree": {"sha": "86c496ee2d6155d5b6eb9d9a4f396a8c9d29237b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c496ee2d6155d5b6eb9d9a4f396a8c9d29237b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "html_url": "https://github.com/rust-lang/rust/commit/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7820b28937ba875521a2525cf75223c80faf9f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7820b28937ba875521a2525cf75223c80faf9f2", "html_url": "https://github.com/rust-lang/rust/commit/b7820b28937ba875521a2525cf75223c80faf9f2"}, {"sha": "aa10abb2119f0740aac704a78d6eebd800ddb1da", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa10abb2119f0740aac704a78d6eebd800ddb1da", "html_url": "https://github.com/rust-lang/rust/commit/aa10abb2119f0740aac704a78d6eebd800ddb1da"}], "stats": {"total": 145, "additions": 85, "deletions": 60}, "files": [{"sha": "106792b941e679e4b9c16f928172c16c502e956d", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -917,9 +917,9 @@ dependencies = [\n \n [[package]]\n name = \"ena\"\n-version = \"0.13.0\"\n+version = \"0.13.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3dc01d68e08ca384955a3aeba9217102ca1aa85b6e168639bf27739f1d749d87\"\n+checksum = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n dependencies = [\n  \"log\",\n ]"}, {"sha": "5d556485c15f3b6bfbddd6729781ec04aba469ad", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -1600,29 +1600,30 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n \n     // `resolver.shallow_resolve_changed(ty)` is equivalent to\n     // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has a single call site that is\n-    // extremely hot.\n+    // inlined, despite being large, because it has only two call sites that\n+    // are extremely hot.\n     #[inline(always)]\n     pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n         match typ.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 use self::type_variable::TypeVariableValue;\n \n                 // See the comment in `shallow_resolve()`.\n-                match self.infcx.type_variables.borrow_mut().probe(v) {\n+                match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n                     TypeVariableValue::Known { value: t } => self.fold_ty(t) != typ,\n                     TypeVariableValue::Unknown { .. } => false,\n                 }\n             }\n \n             ty::Infer(ty::IntVar(v)) => {\n-                match self.infcx.int_unification_table.borrow_mut().probe_value(v) {\n+                match self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v) {\n                     Some(v) => v.to_type(self.infcx.tcx) != typ,\n                     None => false,\n                 }\n             }\n \n             ty::Infer(ty::FloatVar(v)) => {\n+                // Not `inlined_probe_value(v)` because this call site is colder.\n                 match self.infcx.float_unification_table.borrow_mut().probe_value(v) {\n                     Some(v) => v.to_type(self.infcx.tcx) != typ,\n                     None => false,"}, {"sha": "dd09e9a8f58a40a7608dd5978d5537fddcdf8dea", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -234,7 +234,13 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Retrieves the type to which `vid` has been instantiated, if\n     /// any.\n     pub fn probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n-        self.eq_relations.probe_value(vid)\n+        self.inlined_probe(vid)\n+    }\n+\n+    /// An always-inlined variant of `probe`, for very hot call sites.\n+    #[inline(always)]\n+    pub fn inlined_probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n+        self.eq_relations.inlined_probe_value(vid)\n     }\n \n     /// If `t` is a type-inference variable, and it has been"}, {"sha": "6c421e9df6800aad9c2a69d00a92c51ad559cf2c", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -256,29 +256,46 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         &mut self,\n         pending_obligation: &mut Self::Obligation,\n     ) -> ProcessResult<Self::Obligation, Self::Error> {\n-        // If we were stalled on some unresolved variables, first check\n-        // whether any of them have been resolved; if not, don't bother\n-        // doing more work yet\n-        if !pending_obligation.stalled_on.is_empty() {\n-            let mut changed = false;\n-            // This `for` loop was once a call to `all()`, but this lower-level\n-            // form was a perf win. See #64545 for details.\n-            for &ty in &pending_obligation.stalled_on {\n-                if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n-                    changed = true;\n-                    break;\n-                }\n+        // If we were stalled on some unresolved variables, first check whether\n+        // any of them have been resolved; if not, don't bother doing more work\n+        // yet.\n+        let change = match pending_obligation.stalled_on.len() {\n+            // Match arms are in order of frequency, which matters because this\n+            // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n+            1 => {\n+                let ty = pending_obligation.stalled_on[0];\n+                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty)\n+            }\n+            0 => {\n+                // In this case we haven't changed, but wish to make a change.\n+                true\n             }\n-            if !changed {\n-                debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                       self.selcx.infcx()\n-                           .resolve_vars_if_possible(&pending_obligation.obligation),\n-                       pending_obligation.stalled_on);\n-                return ProcessResult::Unchanged;\n+            _ => {\n+                // This `for` loop was once a call to `all()`, but this lower-level\n+                // form was a perf win. See #64545 for details.\n+                (|| {\n+                    for &ty in &pending_obligation.stalled_on {\n+                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n+                            return true;\n+                        }\n+                    }\n+                    false\n+                })()\n             }\n-            pending_obligation.stalled_on = vec![];\n+        };\n+\n+        if !change {\n+            debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n+                   self.selcx.infcx()\n+                       .resolve_vars_if_possible(&pending_obligation.obligation),\n+                   pending_obligation.stalled_on);\n+            return ProcessResult::Unchanged;\n         }\n \n+        // This part of the code is much colder.\n+\n+        pending_obligation.stalled_on.truncate(0);\n+\n         let obligation = &mut pending_obligation.obligation;\n \n         if obligation.predicate.has_infer_types() {"}, {"sha": "ae3403cf0ce9f6955b148f0fe10ede6d5300ecc2", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-ena = \"0.13\"\n+ena = \"0.13.1\"\n indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }"}, {"sha": "1c7109fe500e083c5f5e694f021793e5de0ffac2", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bc0bf82faf9718fa1e59a38f5aab308299ba7d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=c7bc0bf82faf9718fa1e59a38f5aab308299ba7d", "patch": "@@ -149,7 +149,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    waiting_cache: FxHashMap<O::Predicate, usize>,\n+    active_cache: FxHashMap<O::Predicate, usize>,\n \n     /// A scratch vector reused in various operations, to avoid allocating new\n     /// vectors.\n@@ -278,7 +278,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n             done_cache: Default::default(),\n-            waiting_cache: Default::default(),\n+            active_cache: Default::default(),\n             scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n@@ -303,15 +303,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n             return Ok(());\n         }\n \n-        match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n+        match self.active_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n-                    // If the node is already in `waiting_cache`, it has\n-                    // already had its chance to be marked with a parent. So if\n-                    // it's not already present, just dump `parent` into the\n+                    // If the node is already in `active_cache`, it has already\n+                    // had its chance to be marked with a parent. So if it's\n+                    // not already present, just dump `parent` into the\n                     // dependents as a non-parent.\n                     if !node.dependents.contains(&parent_index) {\n                         node.dependents.push(parent_index);\n@@ -355,10 +355,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         for (index, node) in self.nodes.iter().enumerate() {\n             if let NodeState::Pending = node.state.get() {\n-                let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n-                    backtrace,\n+                    backtrace: self.error_at(index),\n                 });\n             }\n         }\n@@ -406,8 +405,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n-            // `self.waiting_cache`. This means that `self.waiting_cache` can\n-            // get out of sync with `nodes`. It's not very common, but it does\n+            // `self.active_cache`. This means that `self.active_cache` can get\n+            // out of sync with `nodes`. It's not very common, but it does\n             // happen, and code in `compress` has to allow for it.\n             let result = match node.state.get() {\n                 NodeState::Pending => processor.process_obligation(&mut node.obligation),\n@@ -439,10 +438,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n-                        backtrace,\n+                        backtrace: self.error_at(index),\n                     });\n                 }\n             }\n@@ -484,13 +482,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n         debug!(\"process_cycles()\");\n \n         for (index, node) in self.nodes.iter().enumerate() {\n-            // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n-            // hot and the state is almost always `Pending` or `Waiting`. It's\n-            // a win to handle the no-op cases immediately to avoid the cost of\n-            // the function call.\n+            // For some benchmarks this state test is extremely\n+            // hot. It's a win to handle the no-op cases immediately to avoid\n+            // the cost of the function call.\n             match node.state.get() {\n-                NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+                // Match arms are in order of frequency. Pending, Success and\n+                // Waiting dominate; the others are rare.\n+                NodeState::Pending => {},\n+                NodeState::Success => self.find_cycles_from_node(&mut stack, processor, index),\n+                NodeState::Waiting | NodeState::Done | NodeState::Error => {},\n+                NodeState::OnDfsStack => self.find_cycles_from_node(&mut stack, processor, index),\n             }\n         }\n \n@@ -506,8 +507,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let node = &self.nodes[index];\n         match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let index = stack.iter().rposition(|&n| n == index).unwrap();\n-                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                let rpos = stack.iter().rposition(|&n| n == index).unwrap();\n+                processor.process_backedge(stack[rpos..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n@@ -636,11 +637,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 NodeState::Done => {\n                     // This lookup can fail because the contents of\n-                    // `self.waiting_cache` is not guaranteed to match those of\n+                    // `self.active_cache` is not guaranteed to match those of\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n-                    if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(node.obligation.as_predicate())\n+                    if let Some((predicate, _)) =\n+                        self.active_cache.remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n@@ -653,7 +654,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(node.obligation.as_predicate());\n+                    self.active_cache.remove(node.obligation.as_predicate());\n                     node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n                     self.insert_into_error_cache(index);\n@@ -697,25 +698,25 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n-            let mut index = 0;\n-            while index < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[index]];\n+            let mut i = 0;\n+            while i < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[i]];\n                 if new_index >= nodes_len {\n-                    node.dependents.swap_remove(index);\n-                    if index == 0 && node.has_parent {\n+                    node.dependents.swap_remove(i);\n+                    if i == 0 && node.has_parent {\n                         // We just removed the parent.\n                         node.has_parent = false;\n                     }\n                 } else {\n-                    node.dependents[index] = new_index;\n-                    index += 1;\n+                    node.dependents[i] = new_index;\n+                    i += 1;\n                 }\n             }\n         }\n \n-        // This updating of `self.waiting_cache` is necessary because the\n+        // This updating of `self.active_cache` is necessary because the\n         // removal of nodes within `compress` can fail. See above.\n-        self.waiting_cache.retain(|_predicate, index| {\n+        self.active_cache.retain(|_predicate, index| {\n             let new_index = node_rewrites[*index];\n             if new_index >= nodes_len {\n                 false"}]}