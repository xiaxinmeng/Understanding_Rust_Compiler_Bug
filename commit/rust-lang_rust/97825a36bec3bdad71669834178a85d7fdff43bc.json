{"sha": "97825a36bec3bdad71669834178a85d7fdff43bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ODI1YTM2YmVjM2JkYWQ3MTY2OTgzNDE3OGE4NWQ3ZmRmZjQzYmM=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-24T15:35:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:36:38Z"}, "message": "Move doc to trait declarations", "tree": {"sha": "6f77b5d8efc82847acf2affaa2fcff9040c5ac2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f77b5d8efc82847acf2affaa2fcff9040c5ac2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97825a36bec3bdad71669834178a85d7fdff43bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97825a36bec3bdad71669834178a85d7fdff43bc", "html_url": "https://github.com/rust-lang/rust/commit/97825a36bec3bdad71669834178a85d7fdff43bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97825a36bec3bdad71669834178a85d7fdff43bc/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac34068ed9c1fa96d7fd172c1033df96db1d7143", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac34068ed9c1fa96d7fd172c1033df96db1d7143", "html_url": "https://github.com/rust-lang/rust/commit/ac34068ed9c1fa96d7fd172c1033df96db1d7143"}], "stats": {"total": 235, "additions": 124, "deletions": 111}, "files": [{"sha": "8cbc2cba7de7c834e2d315e90ddcd3b0c94cdc6a", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -25,7 +25,6 @@ use libc::{c_uint, c_char};\n \n \n impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    // Take an inline assembly expression and splat it out via LLVM\n     fn codegen_inline_asm(\n         &self,\n         ia: &hir::InlineAsm,"}, {"sha": "333264cf1c3d70ab4717c1cedfeeef4640b14ad0", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -156,14 +156,14 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    lhs: Builder::Value,\n-    rhs: Builder::Value,\n+pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n     t: Ty<'tcx>,\n-    ret_ty: Builder::Type,\n+    ret_ty: Bx::Type,\n     op: hir::BinOpKind\n-) -> Builder::Value {\n+) -> Bx::Value {\n     let signed = match t.sty {\n         ty::Float(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n@@ -332,31 +332,31 @@ pub fn coerce_unsized_into<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n+pub fn cast_shift_expr_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n     op: hir::BinOpKind,\n-    lhs: Builder::Value,\n-    rhs: Builder::Value\n-) -> Builder::Value {\n+    lhs: Bx::Value,\n+    rhs: Bx::Value\n+) -> Bx::Value {\n     cast_shift_rhs(bx, op, lhs, rhs, |a, b| bx.trunc(a, b), |a, b| bx.zext(a, b))\n }\n \n-fn cast_shift_rhs<'a, 'tcx: 'a, F, G, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n+fn cast_shift_rhs<'a, 'tcx: 'a, F, G, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n     op: hir::BinOpKind,\n-    lhs: Builder::Value,\n-    rhs: Builder::Value,\n+    lhs: Bx::Value,\n+    rhs: Bx::Value,\n     trunc: F,\n     zext: G\n-) -> Builder::Value\n+) -> Bx::Value\n     where F: FnOnce(\n-        Builder::Value,\n-        Builder::Type\n-    ) -> Builder::Value,\n+        Bx::Value,\n+        Bx::Type\n+    ) -> Bx::Value,\n     G: FnOnce(\n-        Builder::Value,\n-        Builder::Type\n-    ) -> Builder::Value\n+        Bx::Value,\n+        Bx::Type\n+    ) -> Bx::Value\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n@@ -412,33 +412,33 @@ pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn to_immediate<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    val: Builder::Value,\n+pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value,\n     layout: layout::TyLayout,\n-) -> Builder::Value {\n+) -> Bx::Value {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n     }\n     val\n }\n \n-pub fn to_immediate_scalar<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    val: Builder::Value,\n+pub fn to_immediate_scalar<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    val: Bx::Value,\n     scalar: &layout::Scalar,\n-) -> Builder::Value {\n+) -> Bx::Value {\n     if scalar.is_bool() {\n         return bx.trunc(val, bx.cx().type_i1());\n     }\n     val\n }\n \n-pub fn memcpy_ty<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    dst: Builder::Value,\n+pub fn memcpy_ty<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &Bx,\n+    dst: Bx::Value,\n     dst_align: Align,\n-    src: Builder::Value,\n+    src: Bx::Value,\n     src_align: Align,\n     layout: TyLayout<'tcx>,\n     flags: MemFlags,"}, {"sha": "642c36e886e7cbedefc185bfae5886ab16d56a6c", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -1265,7 +1265,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    /// Returns the ptr value that should be used for storing `val`.\n     fn check_store<'b>(&self,\n                        val: &'ll Value,\n                        ptr: &'ll Value) -> &'ll Value {\n@@ -1285,7 +1284,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(&self,\n                       typ: &str,\n                       llfn: &'ll Value,\n@@ -1336,14 +1334,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n     }\n \n-    /// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n-    /// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n-    /// and the intrinsic for `lt` and passes them to `emit`, which is in\n-    /// charge of generating code to call the passed intrinsic on whatever\n-    /// block of generated code is targeted for the intrinsic.\n-    ///\n-    /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n-    /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;"}, {"sha": "e049a43fd6a407059ca9f478d6bebe3001d46531", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -203,9 +203,7 @@ pub fn get_fn(\n     llfn\n }\n \n-pub fn resolve_and_get_fn<'tcx,\n-    Cx: Backend<'tcx> + MiscMethods<'tcx> + TypeMethods<'tcx>\n->(\n+pub fn resolve_and_get_fn<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,\n     def_id: DefId,\n     substs: &'tcx Substs<'tcx>,"}, {"sha": "51c8ab9308b892dd342fc8d64a475213880501c7", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -224,7 +224,6 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n }\n \n impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    // LLVM constant constructors.\n     fn const_null(&self, t: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMConstNull(t)\n@@ -286,9 +285,6 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.const_uint(self.type_i8(), i as u64)\n     }\n \n-\n-    // This is a 'c-like' raw string, which differs from\n-    // our boxed-and-length-annotated strings.\n     fn const_cstr(\n         &self,\n         s: LocalInternedString,\n@@ -316,8 +312,6 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n-    // you will be kicked off fast isel. See issue #4352 for an example of this.\n     fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n         let len = s.len();\n         let cs = consts::ptrcast(self.const_cstr(s, false),"}, {"sha": "41e5bed123e79ad3b045a3e49d04bbff9abe6741", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -444,7 +444,6 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         self.declare_intrinsic(key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n     }\n \n-    /// Declare any llvm intrinsics that you might need\n     fn declare_intrinsic(\n         &self,\n         key: &str"}, {"sha": "eef3ddb24a7f32a4b42d02fda81bd4d5a00288f8", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -285,12 +285,6 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    /// Creates the function-specific debug context.\n-    ///\n-    /// Returns the FunctionDebugContext for the function which holds state needed\n-    /// for debug info creation. The function may also return another variant of the\n-    /// FunctionDebugContext enum which indicates why no debuginfo should be created\n-    /// for the function.\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,"}, {"sha": "b5c64adb427fda548742ab7a75244e00a680d9ae", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -97,10 +97,6 @@ fn declare_raw_fn(\n \n impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n-    /// Declare a global value.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// return its Value instead.\n     fn declare_global(\n         &self,\n         name: &str, ty: &'ll Type\n@@ -112,13 +108,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Declare a C ABI function.\n-    ///\n-    /// Only use this for foreign function ABIs and glue. For Rust functions use\n-    /// `declare_fn` instead.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n     fn declare_cfn(\n         &self,\n         name: &str,\n@@ -127,11 +116,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n     }\n \n-\n-    /// Declare a Rust function.\n-    ///\n-    /// If there\u2019s a value with the same name already declared, the function will\n-    /// update the declaration and return existing Value instead.\n     fn declare_fn(\n         &self,\n         name: &str,\n@@ -157,13 +141,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         llfn\n     }\n \n-\n-    /// Declare a global with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a global. This function will\n-    /// return None if the name already has a definition associated with it. In that\n-    /// case an error should be reported to the user, because it usually happens due\n-    /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n     fn define_global(\n         &self,\n         name: &str,\n@@ -176,20 +153,12 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Declare a private global\n-    ///\n-    /// Use this function when you intend to define a global without a name.\n     fn define_private_global(&self, ty: &'ll Type) -> &'ll Value {\n         unsafe {\n             llvm::LLVMRustInsertPrivateGlobal(self.llmod, ty)\n         }\n     }\n \n-    /// Declare a Rust function with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a function. This function will\n-    /// return panic if the name already has a definition associated with it. This\n-    /// can happen with #[no_mangle] or #[export_name], for example.\n     fn define_fn(\n         &self,\n         name: &str,\n@@ -202,11 +171,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Declare a Rust function with an intention to define it.\n-    ///\n-    /// Use this function when you intend to define a function. This function will\n-    /// return panic if the name already has a definition associated with it. This\n-    /// can happen with #[no_mangle] or #[export_name], for example.\n     fn define_internal_fn(\n         &self,\n         name: &str,\n@@ -217,16 +181,12 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         llfn\n     }\n \n-\n-    /// Get declared value by name.\n     fn get_declared_value(&self, name: &str) -> Option<&'ll Value> {\n         debug!(\"get_declared_value(name={:?})\", name);\n         let namebuf = SmallCStr::new(name);\n         unsafe { llvm::LLVMRustGetNamedValue(self.llmod, namebuf.as_ptr()) }\n     }\n \n-    /// Get defined or externally defined (AvailableExternally linkage) value by\n-    /// name.\n     fn get_defined_value(&self, name: &str) -> Option<&'ll Value> {\n         self.get_declared_value(name).and_then(|val|{\n             let declaration = unsafe {"}, {"sha": "33c751cc1d974f2e446a47b58af3c8bf5f8e1af0", "filename": "src/librustc_codegen_llvm/interfaces/asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fasm.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -14,6 +14,7 @@ use mir::place::PlaceRef;\n use rustc::hir::{GlobalAsm, InlineAsm};\n \n pub trait AsmBuilderMethods<'tcx>: HasCodegen<'tcx> {\n+    // Take an inline assembly expression and splat it out via LLVM\n     fn codegen_inline_asm(\n         &self,\n         ia: &InlineAsm,"}, {"sha": "139ad4d3d69996a0c5d83a2ef7e05d6105184858", "filename": "src/librustc_codegen_llvm/interfaces/builder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -244,7 +244,10 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn add_incoming_to_phi(&self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock);\n     fn set_invariant_load(&self, load: Self::Value);\n \n+    /// Returns the ptr value that should be used for storing `val`.\n     fn check_store(&self, val: Self::Value, ptr: Self::Value) -> Self::Value;\n+\n+    /// Returns the args that should be used for a call to `llfn`.\n     fn check_call<'b>(\n         &self,\n         typ: &str,\n@@ -256,6 +259,14 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn lifetime_start(&self, ptr: Self::Value, size: Size);\n     fn lifetime_end(&self, ptr: Self::Value, size: Size);\n \n+    /// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+    /// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+    /// and the intrinsic for `lt` and passes them to `emit`, which is in\n+    /// charge of generating code to call the passed intrinsic on whatever\n+    /// block of generated code is targeted for the intrinsic.\n+    ///\n+    /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+    /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: Self::Value, size: Size);\n \n     fn call("}, {"sha": "c0a5445219565cb86e7fab49ec48be0ae175a41d", "filename": "src/librustc_codegen_llvm/interfaces/consts.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fconsts.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -17,6 +17,7 @@ use syntax::symbol::LocalInternedString;\n \n pub trait ConstMethods<'tcx>: Backend<'tcx> {\n     // Constant constructors\n+\n     fn const_null(&self, t: Self::Type) -> Self::Value;\n     fn const_undef(&self, t: Self::Type) -> Self::Value;\n     fn const_int(&self, t: Self::Type, i: i64) -> Self::Value;\n@@ -28,7 +29,11 @@ pub trait ConstMethods<'tcx>: Backend<'tcx> {\n     fn const_u64(&self, i: u64) -> Self::Value;\n     fn const_usize(&self, i: u64) -> Self::Value;\n     fn const_u8(&self, i: u8) -> Self::Value;\n+\n+    // This is a 'c-like' raw string, which differs from\n+    // our boxed-and-length-annotated strings.\n     fn const_cstr(&self, s: LocalInternedString, null_terminated: bool) -> Self::Value;\n+\n     fn const_str_slice(&self, s: LocalInternedString) -> Self::Value;\n     fn const_fat_ptr(&self, ptr: Self::Value, meta: Self::Value) -> Self::Value;\n     fn const_struct(&self, elts: &[Self::Value], packed: bool) -> Self::Value;"}, {"sha": "eca60e9c9cee1c1ef48de55e4a1ae3317a8cb98c", "filename": "src/librustc_codegen_llvm/interfaces/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdebuginfo.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -21,13 +21,21 @@ use syntax_pos::{SourceFile, Span};\n \n pub trait DebugInfoMethods<'tcx>: Backend<'tcx> {\n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value);\n+\n+    /// Creates the function-specific debug context.\n+    ///\n+    /// Returns the FunctionDebugContext for the function which holds state needed\n+    /// for debug info creation. The function may also return another variant of the\n+    /// FunctionDebugContext enum which indicates why no debuginfo should be created\n+    /// for the function.\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: Self::Value,\n         mir: &mir::Mir,\n     ) -> FunctionDebugContext<Self::DIScope>;\n+\n     fn create_mir_scopes(\n         &self,\n         mir: &mir::Mir,"}, {"sha": "5c9aedd1a3becc5fb52fd08ced9f25ca5ab06bb7", "filename": "src/librustc_codegen_llvm/interfaces/declare.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fdeclare.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -15,14 +15,59 @@ use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty;\n \n pub trait DeclareMethods<'tcx>: Backend<'tcx> {\n+    /// Declare a global value.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// return its Value instead.\n     fn declare_global(&self, name: &str, ty: Self::Type) -> Self::Value;\n+\n+    /// Declare a C ABI function.\n+    ///\n+    /// Only use this for foreign function ABIs and glue. For Rust functions use\n+    /// `declare_fn` instead.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n     fn declare_cfn(&self, name: &str, fn_type: Self::Type) -> Self::Value;\n+\n+    /// Declare a Rust function.\n+    ///\n+    /// If there\u2019s a value with the same name already declared, the function will\n+    /// update the declaration and return existing Value instead.\n     fn declare_fn(&self, name: &str, sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+\n+    /// Declare a global with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a global. This function will\n+    /// return None if the name already has a definition associated with it. In that\n+    /// case an error should be reported to the user, because it usually happens due\n+    /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n     fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n+\n+    /// Declare a private global\n+    ///\n+    /// Use this function when you intend to define a global without a name.\n     fn define_private_global(&self, ty: Self::Type) -> Self::Value;\n+\n+    /// Declare a Rust function with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a function. This function will\n+    /// return panic if the name already has a definition associated with it. This\n+    /// can happen with #[no_mangle] or #[export_name], for example.\n     fn define_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+\n+    /// Declare a Rust function with an intention to define it.\n+    ///\n+    /// Use this function when you intend to define a function. This function will\n+    /// return panic if the name already has a definition associated with it. This\n+    /// can happen with #[no_mangle] or #[export_name], for example.\n     fn define_internal_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n+\n+    /// Get declared value by name.\n     fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n+\n+    /// Get defined or externally defined (AvailableExternally linkage) value by\n+    /// name.\n     fn get_defined_value(&self, name: &str) -> Option<Self::Value>;\n }\n "}, {"sha": "5f2994c1a83019d66ba8b0c05847f6bbfd2b027a", "filename": "src/librustc_codegen_llvm/interfaces/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fintrinsic.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -16,6 +16,9 @@ use rustc::ty::Ty;\n use syntax_pos::Span;\n \n pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {\n+    /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n+    /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n+    /// add them to librustc_codegen_llvm/context.rs\n     fn codegen_intrinsic_call(\n         &self,\n         callee_ty: Ty<'tcx>,\n@@ -28,5 +31,7 @@ pub trait IntrinsicCallMethods<'tcx>: HasCodegen<'tcx> {\n \n pub trait IntrinsicDeclarationMethods<'tcx>: Backend<'tcx> {\n     fn get_intrinsic(&self, key: &str) -> Self::Value;\n+\n+    /// Declare any llvm intrinsics that you might need\n     fn declare_intrinsic(&self, key: &str) -> Option<Self::Value>;\n }"}, {"sha": "7f1d0ffdde59d093101602c11f6949c4526873f2", "filename": "src/librustc_codegen_llvm/interfaces/type_.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -29,7 +29,10 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_i32(&self) -> Self::Type;\n     fn type_i64(&self) -> Self::Type;\n     fn type_i128(&self) -> Self::Type;\n+\n+    // Creates an integer type with the given number of bits, e.g. i24\n     fn type_ix(&self, num_bits: u64) -> Self::Type;\n+\n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n     fn type_x86_mmx(&self) -> Self::Type;\n@@ -44,9 +47,14 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn set_struct_body(&self, ty: Self::Type, els: &[Self::Type], packed: bool);\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n+\n+    /// Return the number of elements in `self` if it is a LLVM vector type.\n     fn vector_length(&self, ty: Self::Type) -> usize;\n+\n     fn func_params_types(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n+\n+    /// Retrieve the bit width of the integer type `self`.\n     fn int_width(&self, ty: Self::Type) -> u64;\n \n     fn val_ty(&self, v: Self::Value) -> Self::Type;\n@@ -62,7 +70,13 @@ pub trait DerivedTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_uint_from_ty(&self, t: ast::UintTy) -> Self::Type;\n     fn type_float_from_ty(&self, t: ast::FloatTy) -> Self::Type;\n     fn type_from_integer(&self, i: layout::Integer) -> Self::Type;\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// as a conservative approximation for unknown pointee types.\n     fn type_pointee_for_abi_align(&self, align: Align) -> Self::Type;\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// and exactly the required size, as a best-effort padding array.\n     fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type;\n \n     fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool;"}, {"sha": "563d205020c88f2d96e463371126da21fa351f58", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -87,9 +87,6 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n-    /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n-    /// add them to librustc_codegen_llvm/context.rs\n     fn codegen_intrinsic_call(\n         &self,\n         callee_ty: Ty<'tcx>,"}, {"sha": "60134d9dfe367826404df883072c9f24fddedda3", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97825a36bec3bdad71669834178a85d7fdff43bc/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=97825a36bec3bdad71669834178a85d7fdff43bc", "patch": "@@ -100,7 +100,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n     fn type_ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n@@ -204,7 +203,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Return the number of elements in `self` if it is a LLVM vector type.\n     fn vector_length(&self, ty: &'ll Type) -> usize {\n         unsafe {\n             llvm::LLVMGetVectorSize(ty) as usize\n@@ -231,7 +229,6 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Retrieve the bit width of the integer type `self`.\n     fn int_width(&self, ty: &'ll Type) -> u64 {\n         unsafe {\n             llvm::LLVMGetIntTypeWidth(ty) as u64\n@@ -346,16 +343,12 @@ impl DerivedTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    /// Return a LLVM type that has at most the required alignment,\n-    /// as a conservative approximation for unknown pointee types.\n     fn type_pointee_for_abi_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n-    /// Return a LLVM type that has at most the required alignment,\n-    /// and exactly the required size, as a best-effort padding array.\n     fn type_padding_filler(\n         &self,\n         size: Size,"}]}