{"sha": "948af01633337b3ab57f0db84d49128c5dbc417b", "node_id": "C_kwDOAAsO6NoAKDk0OGFmMDE2MzMzMzdiM2FiNTdmMGRiODRkNDkxMjhjNWRiYzQxN2I", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-14T19:13:10Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-27T04:38:39Z"}, "message": "Don't lint `vec_init_then_push` when further extended", "tree": {"sha": "785ba6d66c43cf48a5d241a782442c7e947927e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/785ba6d66c43cf48a5d241a782442c7e947927e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/948af01633337b3ab57f0db84d49128c5dbc417b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/948af01633337b3ab57f0db84d49128c5dbc417b", "html_url": "https://github.com/rust-lang/rust/commit/948af01633337b3ab57f0db84d49128c5dbc417b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/948af01633337b3ab57f0db84d49128c5dbc417b/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95396f61bcc3f9439132d57dcd21b6aa0a5deb73", "url": "https://api.github.com/repos/rust-lang/rust/commits/95396f61bcc3f9439132d57dcd21b6aa0a5deb73", "html_url": "https://github.com/rust-lang/rust/commit/95396f61bcc3f9439132d57dcd21b6aa0a5deb73"}], "stats": {"total": 326, "additions": 255, "deletions": 71}, "files": [{"sha": "5a5dfcfdc8ab3bf3de1889cd5b7b463c766bbf10", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 124, "deletions": 57, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=948af01633337b3ab57f0db84d49128c5dbc417b", "patch": "@@ -1,14 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::source::snippet;\n-use clippy_utils::{path_to_local, path_to_local_id};\n-use if_chain::if_chain;\n+use clippy_utils::visitors::for_each_local_use_after_expr;\n+use clippy_utils::{get_parent_expr, path_to_local_id};\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, Stmt, StmtKind};\n+use rustc_hir::def::Res;\n+use rustc_hir::{\n+    BindingAnnotation, Block, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, Stmt, StmtKind, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,26 +47,86 @@ pub struct VecInitThenPush {\n struct VecPushSearcher {\n     local_id: HirId,\n     init: VecInitKind,\n-    lhs_is_local: bool,\n-    lhs_span: Span,\n+    lhs_is_let: bool,\n+    let_ty_span: Option<Span>,\n+    name: Symbol,\n     err_span: Span,\n-    found: u64,\n+    found: u128,\n+    last_push_expr: HirId,\n }\n impl VecPushSearcher {\n     fn display_err(&self, cx: &LateContext<'_>) {\n-        match self.init {\n+        let min_pushes_for_extension = match self.init {\n             _ if self.found == 0 => return,\n-            VecInitKind::WithLiteralCapacity(x) if x > self.found => return,\n+            VecInitKind::WithConstCapacity(x) if x > self.found => return,\n+            VecInitKind::WithConstCapacity(x) => x,\n             VecInitKind::WithExprCapacity(_) => return,\n-            _ => (),\n+            _ => 3,\n         };\n \n-        let mut s = if self.lhs_is_local {\n+        let mut needs_mut = false;\n+        let res = for_each_local_use_after_expr(cx, self.local_id, self.last_push_expr, |e| {\n+            let Some(parent) = get_parent_expr(cx, e) else {\n+                return ControlFlow::Continue(())\n+            };\n+            let adjusted_ty = cx.typeck_results().expr_ty_adjusted(e);\n+            let adjusted_mut = adjusted_ty.ref_mutability().unwrap_or(Mutability::Not);\n+            needs_mut |= adjusted_mut == Mutability::Mut;\n+            match parent.kind {\n+                ExprKind::AddrOf(_, Mutability::Mut, _) => {\n+                    needs_mut = true;\n+                    return ControlFlow::Break(true);\n+                },\n+                ExprKind::Unary(UnOp::Deref, _) | ExprKind::Index(..) if !needs_mut => {\n+                    let mut last_place = parent;\n+                    while let Some(parent) = get_parent_expr(cx, parent) {\n+                        if matches!(parent.kind, ExprKind::Unary(UnOp::Deref, _) | ExprKind::Field(..))\n+                            || matches!(parent.kind, ExprKind::Index(e, _) if e.hir_id == last_place.hir_id)\n+                        {\n+                            last_place = parent;\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    needs_mut |= cx.typeck_results().expr_ty_adjusted(last_place).ref_mutability()\n+                        == Some(Mutability::Mut)\n+                        || get_parent_expr(cx, last_place)\n+                            .map_or(false, |e| matches!(e.kind, ExprKind::AddrOf(_, Mutability::Mut, _)));\n+                },\n+                ExprKind::MethodCall(_, [recv, ..], _)\n+                    if recv.hir_id == e.hir_id\n+                        && adjusted_mut == Mutability::Mut\n+                        && !adjusted_ty.peel_refs().is_slice() =>\n+                {\n+                    return ControlFlow::Break(true);\n+                },\n+                ExprKind::Assign(lhs, ..) if e.hir_id == lhs.hir_id => {\n+                    needs_mut = true;\n+                    return ControlFlow::Break(false);\n+                },\n+                _ => (),\n+            }\n+            ControlFlow::Continue(())\n+        });\n+\n+        // Avoid allocating small `Vec`s when they'll be extended right after.\n+        if res == ControlFlow::Break(true) && self.found <= min_pushes_for_extension {\n+            return;\n+        }\n+\n+        let mut s = if self.lhs_is_let {\n             String::from(\"let \")\n         } else {\n             String::new()\n         };\n-        s.push_str(&snippet(cx, self.lhs_span, \"..\"));\n+        if needs_mut {\n+            s.push_str(\"mut \");\n+        }\n+        s.push_str(self.name.as_str());\n+        if let Some(span) = self.let_ty_span {\n+            s.push_str(\": \");\n+            s.push_str(&snippet(cx, span, \"_\"));\n+        }\n         s.push_str(\" = vec![..];\");\n \n         span_lint_and_sugg(\n@@ -83,60 +147,63 @@ impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), local.span);\n-            if let Some(init) = local.init;\n-            if let PatKind::Binding(BindingAnnotation::Mutable, id, _, None) = local.pat.kind;\n-            if let Some(init_kind) = get_vec_init_kind(cx, init);\n-            then {\n-                self.searcher = Some(VecPushSearcher {\n-                        local_id: id,\n-                        init: init_kind,\n-                        lhs_is_local: true,\n-                        lhs_span: local.ty.map_or(local.pat.span, |t| local.pat.span.to(t.span)),\n-                        err_span: local.span,\n-                        found: 0,\n-                    });\n-            }\n+        if let Some(init_expr) = local.init\n+            && let PatKind::Binding(BindingAnnotation::Mutable, id, name, None) = local.pat.kind\n+            && !in_external_macro(cx.sess(), local.span)\n+            && let Some(init) = get_vec_init_kind(cx, init_expr)\n+            && !matches!(init, VecInitKind::WithExprCapacity(_))\n+        {\n+            self.searcher = Some(VecPushSearcher {\n+                local_id: id,\n+                init,\n+                lhs_is_let: true,\n+                name: name.name,\n+                let_ty_span: local.ty.map(|ty| ty.span),\n+                err_span: local.span,\n+                found: 0,\n+                last_push_expr: init_expr.hir_id,\n+            });\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if self.searcher.is_none();\n-            if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Assign(left, right, _) = expr.kind;\n-            if let Some(id) = path_to_local(left);\n-            if let Some(init_kind) = get_vec_init_kind(cx, right);\n-            then {\n-                self.searcher = Some(VecPushSearcher {\n-                    local_id: id,\n-                    init: init_kind,\n-                    lhs_is_local: false,\n-                    lhs_span: left.span,\n-                    err_span: expr.span,\n-                    found: 0,\n-                });\n-            }\n+        if self.searcher.is_none()\n+            && let ExprKind::Assign(left, right, _) = expr.kind\n+            && let ExprKind::Path(QPath::Resolved(None, path)) = left.kind\n+            && let [name] = &path.segments\n+            && let Res::Local(id) = path.res\n+            && !in_external_macro(cx.sess(), expr.span)\n+            && let Some(init) = get_vec_init_kind(cx, right)\n+            && !matches!(init, VecInitKind::WithExprCapacity(_))\n+        {\n+            self.searcher = Some(VecPushSearcher {\n+                local_id: id,\n+                init,\n+                lhs_is_let: false,\n+                let_ty_span: None,\n+                name: name.ident.name,\n+                err_span: expr.span,\n+                found: 0,\n+                last_push_expr: expr.hir_id,\n+            });\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let Some(searcher) = self.searcher.take() {\n-            if_chain! {\n-                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind;\n-                if let ExprKind::MethodCall(path, [self_arg, _], _) = expr.kind;\n-                if path_to_local_id(self_arg, searcher.local_id);\n-                if path.ident.name.as_str() == \"push\";\n-                then {\n-                    self.searcher = Some(VecPushSearcher {\n-                        found: searcher.found + 1,\n-                        err_span: searcher.err_span.to(stmt.span),\n-                        .. searcher\n-                    });\n-                } else {\n-                    searcher.display_err(cx);\n-                }\n+            if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = stmt.kind\n+                && let ExprKind::MethodCall(name, [self_arg, _], _) = expr.kind\n+                && path_to_local_id(self_arg, searcher.local_id)\n+                && name.ident.as_str() == \"push\"\n+            {\n+                self.searcher = Some(VecPushSearcher {\n+                    found: searcher.found + 1,\n+                    err_span: searcher.err_span.to(stmt.span),\n+                    last_push_expr: expr.hir_id,\n+                    .. searcher\n+                });\n+            } else {\n+                searcher.display_err(cx);\n             }\n         }\n     }"}, {"sha": "1e0fc789af24306beaea24a7823acac6ca2dca8a", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=948af01633337b3ab57f0db84d49128c5dbc417b", "patch": "@@ -2,10 +2,11 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n+use crate::consts::{constant_simple, Constant};\n use crate::ty::is_type_diagnostic_item;\n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitKind};\n+use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_hir::{Arm, Block, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath};\n use rustc_lint::LateContext;\n@@ -431,7 +432,7 @@ pub enum VecInitKind {\n     /// `Vec::default()` or `Default::default()`\n     Default,\n     /// `Vec::with_capacity(123)`\n-    WithLiteralCapacity(u64),\n+    WithConstCapacity(u128),\n     /// `Vec::with_capacity(slice.len())`\n     WithExprCapacity(HirId),\n }\n@@ -449,15 +450,11 @@ pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -\n                     return Some(VecInitKind::Default);\n                 } else if name.ident.name.as_str() == \"with_capacity\" {\n                     let arg = args.get(0)?;\n-                    if_chain! {\n-                        if let ExprKind::Lit(lit) = &arg.kind;\n-                        if let LitKind::Int(num, _) = lit.node;\n-                        then {\n-                            return Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?));\n-                        }\n-                    }\n-                    return Some(VecInitKind::WithExprCapacity(arg.hir_id));\n-                }\n+                    return match constant_simple(cx, cx.typeck_results(), arg) {\n+                        Some(Constant::Int(num)) => Some(VecInitKind::WithConstCapacity(num)),\n+                        _ => Some(VecInitKind::WithExprCapacity(arg.hir_id)),\n+                    };\n+                };\n             },\n             ExprKind::Path(QPath::Resolved(_, path))\n                 if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)"}, {"sha": "b6c8f1d516e557fb77e928541d5eaf92a0400c0d", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948af01633337b3ab57f0db84d49128c5dbc417b/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=948af01633337b3ab57f0db84d49128c5dbc417b", "patch": "@@ -1,4 +1,4 @@\n-use crate::path_to_local_id;\n+use crate::{get_enclosing_block, path_to_local_id};\n use core::ops::ControlFlow;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -436,3 +436,61 @@ pub fn for_each_value_source<'tcx, B>(\n         _ => f(e),\n     }\n }\n+\n+/// Runs the given function for each path expression referencing the given local which occur after\n+/// the given expression.\n+pub fn for_each_local_use_after_expr<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    local_id: HirId,\n+    expr_id: HirId,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<'cx, 'tcx, F, B> {\n+        cx: &'cx LateContext<'tcx>,\n+        local_id: HirId,\n+        expr_id: HirId,\n+        found: bool,\n+        res: ControlFlow<B>,\n+        f: F,\n+    }\n+    impl<'cx, 'tcx, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>, B> Visitor<'tcx> for V<'cx, 'tcx, F, B> {\n+        type NestedFilter = nested_filter::OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            if !self.found {\n+                if e.hir_id == self.expr_id {\n+                    self.found = true;\n+                } else {\n+                    walk_expr(self, e);\n+                }\n+                return;\n+            }\n+            if self.res.is_break() {\n+                return;\n+            }\n+            if path_to_local_id(e, self.local_id) {\n+                self.res = (self.f)(e);\n+            } else {\n+                walk_expr(self, e);\n+            }\n+        }\n+    }\n+\n+    if let Some(b) = get_enclosing_block(cx, local_id) {\n+        let mut v = V {\n+            cx,\n+            local_id,\n+            expr_id,\n+            found: false,\n+            res: ControlFlow::Continue(()),\n+            f,\n+        };\n+        v.visit_block(b);\n+        v.res\n+    } else {\n+        ControlFlow::Continue(())\n+    }\n+}"}, {"sha": "768ea3e668a33e46f5bc869af30f2f82971b33e9", "filename": "tests/ui/vec_init_then_push.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/948af01633337b3ab57f0db84d49128c5dbc417b/tests%2Fui%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948af01633337b3ab57f0db84d49128c5dbc417b/tests%2Fui%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_init_then_push.rs?ref=948af01633337b3ab57f0db84d49128c5dbc417b", "patch": "@@ -44,3 +44,45 @@ pub fn no_lint() -> Vec<i32> {\n         }\n     }\n }\n+\n+fn _from_iter(items: impl Iterator<Item = u32>) -> Vec<u32> {\n+    let mut v = Vec::new();\n+    v.push(0);\n+    v.push(1);\n+    v.extend(items);\n+    v\n+}\n+\n+fn _cond_push(x: bool) -> Vec<u32> {\n+    let mut v = Vec::new();\n+    v.push(0);\n+    if x {\n+        v.push(1);\n+    }\n+    v.push(2);\n+    v\n+}\n+\n+fn _push_then_edit(x: u32) -> Vec<u32> {\n+    let mut v = Vec::new();\n+    v.push(x);\n+    v.push(1);\n+    v[0] = v[1] + 5;\n+    v\n+}\n+\n+fn _cond_push_with_large_start(x: bool) -> Vec<u32> {\n+    let mut v = Vec::new();\n+    v.push(0);\n+    v.push(1);\n+    v.push(0);\n+    v.push(1);\n+    v.push(0);\n+    v.push(0);\n+    v.push(1);\n+    v.push(0);\n+    if x {\n+        v.push(1);\n+    }\n+    v\n+}"}, {"sha": "362c9603bbfb4f0ab7126d006a02f0db275b1316", "filename": "tests/ui/vec_init_then_push.stderr", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/948af01633337b3ab57f0db84d49128c5dbc417b/tests%2Fui%2Fvec_init_then_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/948af01633337b3ab57f0db84d49128c5dbc417b/tests%2Fui%2Fvec_init_then_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_init_then_push.stderr?ref=948af01633337b3ab57f0db84d49128c5dbc417b", "patch": "@@ -3,7 +3,7 @@ error: calls to `push` immediately after creation\n    |\n LL | /     let mut def_err: Vec<u32> = Default::default();\n LL | |     def_err.push(0);\n-   | |____________________^ help: consider using the `vec![]` macro: `let mut def_err: Vec<u32> = vec![..];`\n+   | |____________________^ help: consider using the `vec![]` macro: `let def_err: Vec<u32> = vec![..];`\n    |\n    = note: `-D clippy::vec-init-then-push` implied by `-D warnings`\n \n@@ -30,5 +30,25 @@ LL | /     new_err = Vec::new();\n LL | |     new_err.push(0);\n    | |____________________^ help: consider using the `vec![]` macro: `new_err = vec![..];`\n \n-error: aborting due to 4 previous errors\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:67:5\n+   |\n+LL | /     let mut v = Vec::new();\n+LL | |     v.push(x);\n+LL | |     v.push(1);\n+   | |______________^ help: consider using the `vec![]` macro: `let mut v = vec![..];`\n+\n+error: calls to `push` immediately after creation\n+  --> $DIR/vec_init_then_push.rs:75:5\n+   |\n+LL | /     let mut v = Vec::new();\n+LL | |     v.push(0);\n+LL | |     v.push(1);\n+LL | |     v.push(0);\n+...  |\n+LL | |     v.push(1);\n+LL | |     v.push(0);\n+   | |______________^ help: consider using the `vec![]` macro: `let mut v = vec![..];`\n+\n+error: aborting due to 6 previous errors\n "}]}