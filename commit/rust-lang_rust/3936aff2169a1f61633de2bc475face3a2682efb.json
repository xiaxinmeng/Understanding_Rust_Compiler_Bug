{"sha": "3936aff2169a1f61633de2bc475face3a2682efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MzZhZmYyMTY5YTFmNjE2MzNkZTJiYzQ3NWZhY2UzYTI2ODJlZmI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-03T00:14:35Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-12T23:03:13Z"}, "message": "Use derive macro for HashStable", "tree": {"sha": "0acd56359a94980bef3519e0d39123e8d0d4a8af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0acd56359a94980bef3519e0d39123e8d0d4a8af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3936aff2169a1f61633de2bc475face3a2682efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3936aff2169a1f61633de2bc475face3a2682efb", "html_url": "https://github.com/rust-lang/rust/commit/3936aff2169a1f61633de2bc475face3a2682efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3936aff2169a1f61633de2bc475face3a2682efb/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48757a70a382afe27d5469fdcfbe5d434c9d4097", "url": "https://api.github.com/repos/rust-lang/rust/commits/48757a70a382afe27d5469fdcfbe5d434c9d4097", "html_url": "https://github.com/rust-lang/rust/commit/48757a70a382afe27d5469fdcfbe5d434c9d4097"}], "stats": {"total": 2980, "additions": 358, "deletions": 2622}, "files": [{"sha": "b45fc3ffd82fe0118ba89baaa58db033ba234392", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -3,12 +3,13 @@ use crate::util::nodemap::{NodeMap, DefIdMap};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n+use rustc_macros::HashStable;\n use crate::hir;\n use crate::ty;\n \n use self::Namespace::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n     Fn,\n@@ -18,7 +19,7 @@ pub enum CtorKind {\n     Fictive,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n     Builtin,\n@@ -32,7 +33,7 @@ pub enum NonMacroAttrKind {\n     Custom,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n@@ -209,7 +210,7 @@ pub type ExportMap = DefIdMap<Vec<Export>>;\n /// namespace.\n pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export {\n     /// The name of the target.\n     pub ident: ast::Ident,"}, {"sha": "14e39748eb087b6f36d884a7cc9a66a256202c5a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 109, "deletions": 88, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -122,6 +122,7 @@ impl fmt::Display for HirId {\n // hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n+    use rustc_macros::HashStable;\n     newtype_index! {\n         /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n         /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n@@ -131,7 +132,9 @@ mod item_local_id_inner {\n         /// integers starting at zero, so a mapping that maps all or most nodes within\n         /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n         /// tree or hash map.\n-        pub struct ItemLocalId { .. }\n+        pub struct ItemLocalId {\n+            derive [HashStable]\n+        }\n     }\n }\n \n@@ -164,7 +167,7 @@ pub struct Lifetime {\n     pub name: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -207,7 +210,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, HashStable)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n@@ -290,7 +293,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Path {\n     pub span: Span,\n     /// The definition that the path resolved to.\n@@ -319,9 +322,10 @@ impl fmt::Display for Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     // `id` and `def` are optional. We currently only use these in save-analysis,\n     // any path segments without these will not have save-analysis info and\n@@ -391,13 +395,13 @@ impl PathSegment {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Ty),\n@@ -422,7 +426,7 @@ impl GenericArg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment.\n     pub args: HirVec<GenericArg>,\n@@ -486,7 +490,7 @@ impl GenericArgs {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -496,7 +500,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -513,7 +517,7 @@ impl GenericBound {\n \n pub type GenericBounds = HirVec<GenericBound>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -532,7 +536,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -547,7 +551,7 @@ pub enum GenericParamKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericParam {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -568,7 +572,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Generics {\n     pub params: HirVec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -616,13 +620,13 @@ impl Generics {\n \n /// Synthetic type parameters are converted to another form during lowering; this allows\n /// us to track the original form they had, and is useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereClause {\n     pub hir_id: HirId,\n     pub predicates: HirVec<WherePredicate>,\n@@ -641,7 +645,7 @@ impl WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -662,7 +666,7 @@ impl WherePredicate {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -674,15 +678,15 @@ pub struct WhereBoundPredicate {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct WhereEqPredicate {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -801,7 +805,7 @@ impl Crate {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n@@ -812,13 +816,14 @@ pub struct MacroDef {\n     pub legacy: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Block {\n     /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n@@ -829,8 +834,9 @@ pub struct Block {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Pat {\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n@@ -891,10 +897,12 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FieldPat {\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     /// The identifier for the field.\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n@@ -904,7 +912,7 @@ pub struct FieldPat {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -925,13 +933,13 @@ pub enum BindingAnnotation {\n     RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -976,7 +984,8 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n@@ -992,7 +1001,7 @@ impl Mutability {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1126,7 +1135,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash, HashStable)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1169,7 +1178,7 @@ impl fmt::Debug for Stmt {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StmtKind {\n     /// A local (`let`) binding.\n     Local(P<Local>),\n@@ -1196,7 +1205,7 @@ impl StmtKind {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n@@ -1209,37 +1218,38 @@ pub struct Local {\n }\n \n /// Represents a single arm of a `match` expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n     pub pats: HirVec<P<Pat>>,\n     pub guard: Option<Guard>,\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Field {\n+    #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub ident: Ident,\n     pub expr: P<Expr>,\n     pub span: Span,\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1315,7 +1325,7 @@ impl BodyOwnerKind {\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub body: BodyId,\n@@ -1431,7 +1441,7 @@ impl fmt::Debug for Expr {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1537,7 +1547,7 @@ pub enum ExprKind {\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1557,7 +1567,7 @@ pub enum QPath {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1566,7 +1576,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1584,7 +1594,7 @@ pub enum MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1594,7 +1604,7 @@ pub enum LoopSource {\n     ForLoop,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1612,7 +1622,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1622,28 +1632,29 @@ pub struct Destination {\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum GeneratorMovability {\n     Static,\n     Movable,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a method's signature in a trait declaration or implementation.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MethodSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n@@ -1672,7 +1683,7 @@ pub struct TraitItem {\n }\n \n /// A trait method's body (or just argument names).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n     Required(HirVec<Ident>),\n@@ -1682,7 +1693,7 @@ pub enum TraitMethod {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n@@ -1716,7 +1727,7 @@ pub struct ImplItem {\n }\n \n /// Represents different contents within `impl`s\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n@@ -1730,9 +1741,10 @@ pub enum ImplItemKind {\n }\n \n // Bind a type to an associated type: `A=Foo`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TypeBinding {\n     pub hir_id: HirId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub ty: P<Ty>,\n     pub span: Span,\n@@ -1753,7 +1765,7 @@ impl fmt::Debug for Ty {\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, HashStable)]\n pub enum PrimTy {\n     Int(IntTy),\n     Uint(UintTy),\n@@ -1763,7 +1775,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -1772,15 +1784,15 @@ pub struct BareFnTy {\n     pub arg_names: HirVec<Ident>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ExistTy {\n     pub generics: Generics,\n     pub bounds: GenericBounds,\n     pub impl_trait_fn: Option<DefId>,\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TyKind {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n@@ -1822,15 +1834,15 @@ pub enum TyKind {\n     CVarArgs(Lifetime),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct InlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -1840,18 +1852,19 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n+    #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n /// Represents an argument in a function header.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n@@ -1861,7 +1874,7 @@ pub struct FnDecl {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -1887,31 +1900,33 @@ impl ImplicitSelfKind {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum IsAuto {\n     Yes,\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, HashStable,\n+         Ord, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async,\n     NotAsync,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -1947,7 +1962,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -1965,7 +1980,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FunctionRetTy {\n     /// Return type is not specified.\n     ///\n@@ -2004,24 +2019,25 @@ pub struct Mod {\n     pub item_ids: HirVec<ItemId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: HirVec<ForeignItem>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n+    #[stable_hasher(ignore)] // This is used for error reporting\n     pub ctxt: SyntaxContext,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct EnumDef {\n     pub variants: HirVec<Variant>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct VariantKind {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n@@ -2032,7 +2048,7 @@ pub struct VariantKind {\n \n pub type Variant = Spanned<VariantKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2054,9 +2070,11 @@ pub enum UseKind {\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n /// within the DefMap.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,\n+    // Don't hash the ref_id. It is tracked via the thing it is used to access\n+    #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,\n }\n \n@@ -2074,7 +2092,7 @@ impl TraitRef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n@@ -2122,9 +2140,10 @@ impl VisibilityKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct StructField {\n     pub span: Span,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub vis: Visibility,\n     pub hir_id: HirId,\n@@ -2151,7 +2170,7 @@ impl StructField {\n /// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum VariantData {\n     Struct(HirVec<StructField>, HirId),\n     Tuple(HirVec<StructField>, HirId),\n@@ -2216,15 +2235,15 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n     pub asyncness: IsAsync,\n     pub abi: Abi,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2327,9 +2346,10 @@ impl ItemKind {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n@@ -2342,25 +2362,26 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum AssociatedItemKind {\n     Const,\n     Method { has_self: bool },\n     Type,\n     Existential,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n@@ -2371,7 +2392,7 @@ pub struct ForeignItem {\n }\n \n /// An item within an `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind {\n     /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),\n@@ -2393,7 +2414,7 @@ impl ForeignItemKind {\n }\n \n /// A free variable referred to in a function.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: Def,\n@@ -2434,7 +2455,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.describe_def = map::describe_def;\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CodegenFnAttrs {\n     pub flags: CodegenFnAttrFlags,\n     /// Parsed representation of the `#[inline]` attribute\n@@ -2460,7 +2481,7 @@ pub struct CodegenFnAttrs {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable)]\n+    #[derive(RustcEncodable, RustcDecodable, HashStable)]\n     pub struct CodegenFnAttrFlags: u32 {\n         /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n         /// the hot path."}, {"sha": "17ed1a79d45e0ae293a3248b1b3d750e0995cdb5", "filename": "src/librustc/ich/impls_cstore.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/48757a70a382afe27d5469fdcfbe5d434c9d4097/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48757a70a382afe27d5469fdcfbe5d434c9d4097/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=48757a70a382afe27d5469fdcfbe5d434c9d4097", "patch": "@@ -1,53 +0,0 @@\n-//! This module contains `HashStable` implementations for various data types\n-//! from rustc::middle::cstore in no particular order.\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::DepKind {\n-    UnexportedMacrosOnly,\n-    MacrosOnly,\n-    Implicit,\n-    Explicit\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::NativeLibraryKind {\n-    NativeStatic,\n-    NativeStaticNobundle,\n-    NativeFramework,\n-    NativeUnknown\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::NativeLibrary {\n-    kind,\n-    name,\n-    cfg,\n-    foreign_module,\n-    wasm_import_module\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::ForeignModule {\n-    foreign_items,\n-    def_id\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::LinkagePreference {\n-    RequireDynamic,\n-    RequireStatic\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::ExternCrate {\n-    src,\n-    span,\n-    path_len,\n-    direct\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::cstore::ExternCrateSource {\n-    Extern(def_id),\n-    Use,\n-    Path,\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::cstore::CrateSource {\n-    dylib,\n-    rlib,\n-    rmeta\n-});"}, {"sha": "9491a073b8f8c35d076504849508b1d9e84c7ed7", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 753, "changes": 753, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -69,15 +69,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemLocalId {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.as_u32().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n@@ -139,167 +130,11 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ParamName {\n-    Plain(name),\n-    Fresh(index),\n-    Error,\n-});\n-\n-impl_stable_hash_for!(enum hir::LifetimeName {\n-    Param(param_name),\n-    Implicit,\n-    Underscore,\n-    Static,\n-    Error,\n-});\n \n impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n \n-impl_stable_hash_for!(struct hir::Path {\n-    span,\n-    def,\n-    segments\n-});\n-\n-impl_stable_hash_for!(struct hir::PathSegment {\n-    ident -> (ident.name),\n-    hir_id,\n-    def,\n-    infer_types,\n-    args\n-});\n-\n-impl_stable_hash_for!(struct hir::ConstArg {\n-    value,\n-    span,\n-});\n-\n-impl_stable_hash_for!(enum hir::GenericArg {\n-    Lifetime(lt),\n-    Type(ty),\n-    Const(ct),\n-});\n-\n-impl_stable_hash_for!(struct hir::GenericArgs {\n-    args,\n-    bindings,\n-    parenthesized\n-});\n-\n-impl_stable_hash_for!(enum hir::GenericBound {\n-    Trait(poly_trait_ref, trait_bound_modifier),\n-    Outlives(lifetime)\n-});\n-\n-impl_stable_hash_for!(enum hir::TraitBoundModifier {\n-    None,\n-    Maybe\n-});\n-\n-impl_stable_hash_for!(struct hir::GenericParam {\n-    hir_id,\n-    name,\n-    pure_wrt_drop,\n-    attrs,\n-    bounds,\n-    span,\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum hir::LifetimeParamKind {\n-    Explicit,\n-    InBand,\n-    Elided,\n-    Error,\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            hir::GenericParamKind::Lifetime { kind } => {\n-                kind.hash_stable(hcx, hasher);\n-            }\n-            hir::GenericParamKind::Type { ref default, synthetic } => {\n-                default.hash_stable(hcx, hasher);\n-                synthetic.hash_stable(hcx, hasher);\n-            }\n-            hir::GenericParamKind::Const { ref ty } => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct hir::Generics {\n-    params,\n-    where_clause,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum hir::SyntheticTyParamKind {\n-    ImplTrait\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereClause {\n-    hir_id,\n-    predicates\n-});\n-\n-impl_stable_hash_for!(enum hir::WherePredicate {\n-    BoundPredicate(pred),\n-    RegionPredicate(pred),\n-    EqPredicate(pred)\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereBoundPredicate {\n-    span,\n-    bound_generic_params,\n-    bounded_ty,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n-    span,\n-    lifetime,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(struct hir::WhereEqPredicate {\n-    hir_id,\n-    span,\n-    lhs_ty,\n-    rhs_ty\n-});\n-\n-impl_stable_hash_for!(struct hir::MutTy {\n-    ty,\n-    mutbl\n-});\n-\n-impl_stable_hash_for!(struct hir::MethodSig {\n-    header,\n-    decl\n-});\n-\n-impl_stable_hash_for!(struct hir::TypeBinding {\n-    hir_id,\n-    ident -> (ident.name),\n-    ty,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct hir::FnHeader {\n-    unsafety,\n-    constness,\n-    asyncness,\n-    abi\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -317,228 +152,19 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::PrimTy {\n-    Int(int_ty),\n-    Uint(uint_ty),\n-    Float(float_ty),\n-    Str,\n-    Bool,\n-    Char\n-});\n-\n-impl_stable_hash_for!(struct hir::BareFnTy {\n-    unsafety,\n-    abi,\n-    generic_params,\n-    decl,\n-    arg_names\n-});\n-\n-impl_stable_hash_for!(struct hir::ExistTy {\n-    generics,\n-    impl_trait_fn,\n-    bounds\n-});\n-\n-impl_stable_hash_for!(enum hir::TyKind {\n-    Slice(t),\n-    Array(t, body_id),\n-    Ptr(t),\n-    Rptr(lifetime, t),\n-    BareFn(t),\n-    Never,\n-    Tup(ts),\n-    Path(qpath),\n-    Def(it, lt),\n-    TraitObject(trait_refs, lifetime),\n-    Typeof(body_id),\n-    Err,\n-    Infer,\n-    CVarArgs(lt),\n-});\n-\n-impl_stable_hash_for!(struct hir::FnDecl {\n-    inputs,\n-    output,\n-    c_variadic,\n-    implicit_self\n-});\n-\n-impl_stable_hash_for!(enum hir::FunctionRetTy {\n-    DefaultReturn(span),\n-    Return(t)\n-});\n-\n-impl_stable_hash_for!(enum hir::ImplicitSelfKind {\n-    Imm,\n-    Mut,\n-    ImmRef,\n-    MutRef,\n-    None\n-});\n-\n-impl_stable_hash_for!(struct hir::TraitRef {\n-    // Don't hash the hir_ref_id. It is tracked via the thing it is used to access\n-    hir_ref_id -> _,\n-    path,\n-});\n-\n-impl_stable_hash_for!(struct hir::PolyTraitRef {\n-    bound_generic_params,\n-    trait_ref,\n-    span\n-});\n-\n-impl_stable_hash_for!(enum hir::QPath {\n-    Resolved(t, path),\n-    TypeRelative(t, path_segment)\n-});\n-\n-impl_stable_hash_for!(struct hir::MacroDef {\n-    name,\n-    vis,\n-    attrs,\n-    hir_id,\n-    span,\n-    legacy,\n-    body\n-});\n-\n-impl_stable_hash_for!(struct hir::Block {\n-    stmts,\n-    expr,\n-    hir_id -> _,\n-    rules,\n-    span,\n-    targeted_by_break,\n-});\n-\n-impl_stable_hash_for!(struct hir::Pat {\n-    hir_id -> _,\n-    node,\n-    span,\n-});\n-\n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n-impl_stable_hash_for!(struct hir::FieldPat {\n-    hir_id -> _,\n-    ident -> (ident.name),\n-    pat,\n-    is_shorthand,\n-});\n-\n-impl_stable_hash_for!(enum hir::BindingAnnotation {\n-    Unannotated,\n-    Mutable,\n-    Ref,\n-    RefMut\n-});\n-\n-impl_stable_hash_for!(enum hir::RangeEnd {\n-    Included,\n-    Excluded\n-});\n-\n-impl_stable_hash_for!(enum hir::PatKind {\n-    Wild,\n-    Binding(binding_mode, hir_id, name, sub),\n-    Struct(path, field_pats, dotdot),\n-    TupleStruct(path, field_pats, dotdot),\n-    Path(path),\n-    Tuple(field_pats, dotdot),\n-    Box(sub),\n-    Ref(sub, mutability),\n-    Lit(expr),\n-    Range(start, end, end_kind),\n-    Slice(one, two, three)\n-});\n-\n-impl_stable_hash_for!(enum hir::BinOpKind {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    And,\n-    Or,\n-    BitXor,\n-    BitAnd,\n-    BitOr,\n-    Shl,\n-    Shr,\n-    Eq,\n-    Lt,\n-    Le,\n-    Ne,\n-    Ge,\n-    Gt\n-});\n-\n impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n-impl_stable_hash_for!(enum hir::UnOp {\n-    UnDeref,\n-    UnNot,\n-    UnNeg\n-});\n-\n impl_stable_hash_for!(struct hir::Stmt {\n     hir_id,\n     node,\n     span,\n });\n \n \n-impl_stable_hash_for!(struct hir::Local {\n-    pat,\n-    ty,\n-    init,\n-    hir_id,\n-    span,\n-    attrs,\n-    source\n-});\n-\n-impl_stable_hash_for!(struct hir::Arm {\n-    attrs,\n-    pats,\n-    guard,\n-    body\n-});\n-\n-impl_stable_hash_for!(enum hir::Guard {\n-    If(expr),\n-});\n-\n-impl_stable_hash_for!(struct hir::Field {\n-    hir_id -> _,\n-    ident,\n-    expr,\n-    span,\n-    is_shorthand,\n-});\n-\n impl_stable_hash_for_spanned!(ast::Name);\n \n-\n-impl_stable_hash_for!(enum hir::BlockCheckMode {\n-    DefaultBlock,\n-    UnsafeBlock(src),\n-    PushUnsafeBlock(src),\n-    PopUnsafeBlock(src)\n-});\n-\n-impl_stable_hash_for!(enum hir::UnsafeSource {\n-    CompilerGenerated,\n-    UserProvided\n-});\n-\n-impl_stable_hash_for!(struct hir::AnonConst {\n-    hir_id,\n-    body\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -558,96 +184,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ExprKind {\n-    Box(sub),\n-    Array(subs),\n-    Call(callee, args),\n-    MethodCall(segment, span, args),\n-    Tup(fields),\n-    Binary(op, lhs, rhs),\n-    Unary(op, operand),\n-    Lit(value),\n-    Cast(expr, t),\n-    Type(expr, t),\n-    If(cond, then, els),\n-    While(cond, body, label),\n-    Loop(body, label, loop_src),\n-    Match(matchee, arms, match_src),\n-    Closure(capture_clause, decl, body_id, span, gen),\n-    Block(blk, label),\n-    Assign(lhs, rhs),\n-    AssignOp(op, lhs, rhs),\n-    Field(owner, ident),\n-    Index(lhs, rhs),\n-    Path(path),\n-    AddrOf(mutability, sub),\n-    Break(destination, sub),\n-    Continue(destination),\n-    Ret(val),\n-    InlineAsm(asm, inputs, outputs),\n-    Struct(path, fields, base),\n-    Repeat(val, times),\n-    Yield(val),\n-    Err\n-});\n-\n-impl_stable_hash_for!(enum hir::LocalSource {\n-    Normal,\n-    ForLoopDesugar\n-});\n-\n-impl_stable_hash_for!(enum hir::LoopSource {\n-    Loop,\n-    WhileLet,\n-    ForLoop\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::hir::MatchSource;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            MatchSource::Normal |\n-            MatchSource::WhileLetDesugar |\n-            MatchSource::ForLoopDesugar |\n-            MatchSource::TryDesugar => {\n-                // No fields to hash.\n-            }\n-            MatchSource::IfLetDesugar { contains_else_clause } => {\n-                contains_else_clause.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum hir::GeneratorMovability {\n-    Static,\n-    Movable\n-});\n-\n-impl_stable_hash_for!(enum hir::CaptureClause {\n-    CaptureByValue,\n-    CaptureByRef\n-});\n-\n impl_stable_hash_for_spanned!(usize);\n \n-impl_stable_hash_for!(struct hir::Destination {\n-    label,\n-    target_id\n-});\n-\n impl_stable_hash_for_spanned!(ast::Ident);\n \n-impl_stable_hash_for!(enum hir::LoopIdError {\n-    OutsideLoopScope,\n-    UnlabeledCfInWhileCondition,\n-    UnresolvedLabel\n-});\n-\n impl_stable_hash_for!(struct ast::Ident {\n     name,\n     span,\n@@ -676,16 +216,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::TraitMethod {\n-    Required(name),\n-    Provided(body)\n-});\n-\n-impl_stable_hash_for!(enum hir::TraitItemKind {\n-    Const(t, body),\n-    Method(sig, method),\n-    Type(bounds, rhs)\n-});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -714,13 +244,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ImplItemKind {\n-    Const(t, body),\n-    Method(sig, body),\n-    Existential(bounds),\n-    Type(t)\n-});\n-\n impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n     JustCrate,\n     PubCrate,\n@@ -751,27 +274,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n \n impl_stable_hash_for_spanned!(hir::VisibilityKind);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            hir::Defaultness::Final => {\n-                // No fields to hash.\n-            }\n-            hir::Defaultness::Default { has_value } => {\n-                has_value.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum hir::ImplPolarity {\n-    Positive,\n-    Negative\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -801,44 +303,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::ForeignMod {\n-    abi,\n-    items\n-});\n-\n-impl_stable_hash_for!(struct hir::EnumDef {\n-    variants\n-});\n-\n-impl_stable_hash_for!(struct hir::VariantKind {\n-    ident -> (ident.name),\n-    attrs,\n-    data,\n-    disr_expr\n-});\n-\n impl_stable_hash_for_spanned!(hir::VariantKind);\n \n-impl_stable_hash_for!(enum hir::UseKind {\n-    Single,\n-    Glob,\n-    ListStem\n-});\n-\n-impl_stable_hash_for!(struct hir::StructField {\n-    span,\n-    ident -> (ident.name),\n-    vis,\n-    hir_id,\n-    ty,\n-    attrs\n-});\n-\n-impl_stable_hash_for!(enum hir::VariantData {\n-    Struct(fields, hir_id),\n-    Tuple(fields, hir_id),\n-    Unit(hir_id)\n-});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -863,87 +329,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::ItemKind {\n-    ExternCrate(orig_name),\n-    Use(path, use_kind),\n-    Static(ty, mutability, body_id),\n-    Const(ty, body_id),\n-    Fn(fn_decl, header, generics, body_id),\n-    Mod(module),\n-    ForeignMod(foreign_mod),\n-    GlobalAsm(global_asm),\n-    Ty(ty, generics),\n-    Existential(exist),\n-    Enum(enum_def, generics),\n-    Struct(variant_data, generics),\n-    Union(variant_data, generics),\n-    Trait(is_auto, unsafety, generics, bounds, item_refs),\n-    TraitAlias(generics, bounds),\n-    Impl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n-});\n-\n-impl_stable_hash_for!(struct hir::TraitItemRef {\n-    id,\n-    ident -> (ident.name),\n-    kind,\n-    span,\n-    defaultness\n-});\n-\n-impl_stable_hash_for!(struct hir::ImplItemRef {\n-    id,\n-    ident -> (ident.name),\n-    kind,\n-    span,\n-    vis,\n-    defaultness\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::AssociatedItemKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            hir::AssociatedItemKind::Const |\n-            hir::AssociatedItemKind::Existential |\n-            hir::AssociatedItemKind::Type => {\n-                // No fields to hash.\n-            }\n-            hir::AssociatedItemKind::Method { has_self } => {\n-                has_self.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct hir::ForeignItem {\n-    ident -> (ident.name),\n-    attrs,\n-    node,\n-    hir_id,\n-    span,\n-    vis\n-});\n-\n-impl_stable_hash_for!(enum hir::ForeignItemKind {\n-    Fn(fn_decl, arg_names, generics),\n-    Static(ty, is_mutbl),\n-    Type\n-});\n-\n-impl_stable_hash_for!(enum hir::StmtKind {\n-    Local(local),\n-    Item(item_id),\n-    Expr(expr),\n-    Semi(expr)\n-});\n-\n-impl_stable_hash_for!(struct hir::Arg {\n-    pat,\n-    hir_id\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -974,103 +359,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::InlineAsmOutput {\n-    constraint,\n-    is_rw,\n-    is_indirect,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct hir::GlobalAsm {\n-    asm,\n-    ctxt -> _, // This is used for error reporting\n-});\n-\n-impl_stable_hash_for!(struct hir::InlineAsm {\n-    asm,\n-    asm_str_style,\n-    outputs,\n-    inputs,\n-    clobbers,\n-    volatile,\n-    alignstack,\n-    dialect,\n-    ctxt -> _, // This is used for error reporting\n-});\n-\n-impl_stable_hash_for!(enum hir::def::CtorKind {\n-    Fn,\n-    Const,\n-    Fictive\n-});\n-\n-impl_stable_hash_for!(enum hir::def::NonMacroAttrKind {\n-    Builtin,\n-    Tool,\n-    DeriveHelper,\n-    LegacyPluginHelper,\n-    Custom,\n-});\n-\n-impl_stable_hash_for!(enum hir::def::Def {\n-    Mod(def_id),\n-    Struct(def_id),\n-    Union(def_id),\n-    Enum(def_id),\n-    Existential(def_id),\n-    Variant(def_id),\n-    Trait(def_id),\n-    TyAlias(def_id),\n-    TraitAlias(def_id),\n-    AssociatedTy(def_id),\n-    AssociatedExistential(def_id),\n-    PrimTy(prim_ty),\n-    TyParam(def_id),\n-    ConstParam(def_id),\n-    SelfTy(trait_def_id, impl_def_id),\n-    ForeignTy(def_id),\n-    Fn(def_id),\n-    Const(def_id),\n-    Static(def_id, is_mutbl),\n-    StructCtor(def_id, ctor_kind),\n-    SelfCtor(impl_def_id),\n-    VariantCtor(def_id, ctor_kind),\n-    Method(def_id),\n-    AssociatedConst(def_id),\n-    Local(def_id),\n-    Upvar(def_id, index, expr_id),\n-    Label(node_id),\n-    Macro(def_id, macro_kind),\n-    ToolMod,\n-    NonMacroAttr(attr_kind),\n-    Err\n-});\n-\n-impl_stable_hash_for!(enum hir::Mutability {\n-    MutMutable,\n-    MutImmutable\n-});\n-\n-impl_stable_hash_for!(enum hir::IsAuto {\n-    Yes,\n-    No\n-});\n-\n-impl_stable_hash_for!(enum hir::Unsafety {\n-    Unsafe,\n-    Normal\n-});\n-\n-impl_stable_hash_for!(enum hir::IsAsync {\n-    Async,\n-    NotAsync\n-});\n-\n-impl_stable_hash_for!(enum hir::Constness {\n-    Const,\n-    NotConst\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -1090,18 +378,6 @@ for hir::def_id::DefIndex {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::def::Export {\n-    ident,\n-    def,\n-    vis,\n-    span\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::lib_features::LibFeatures {\n-    stable,\n-    unstable\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n@@ -1110,11 +386,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::Lan\n     }\n }\n \n-impl_stable_hash_for!(struct crate::middle::lang_items::LanguageItems {\n-    items,\n-    missing\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1149,26 +420,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::CodegenFnAttrs {\n-    flags,\n-    inline,\n-    optimize,\n-    export_name,\n-    link_name,\n-    target_features,\n-    linkage,\n-    link_section,\n-});\n-\n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrFlags\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.bits().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'hir>,\n@@ -1185,7 +436,3 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for attr::OptimizeAttr {\n     }\n }\n \n-impl_stable_hash_for!(struct hir::Freevar {\n-    def,\n-    span\n-});"}, {"sha": "ba47116434f8d12440365a7d7a997bdc9fe5766f", "filename": "src/librustc/ich/impls_mir.rs", "status": "removed", "additions": 0, "deletions": 504, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/48757a70a382afe27d5469fdcfbe5d434c9d4097/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48757a70a382afe27d5469fdcfbe5d434c9d4097/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=48757a70a382afe27d5469fdcfbe5d434c9d4097", "patch": "@@ -1,504 +0,0 @@\n-//! This module contains `HashStable` implementations for various MIR data\n-//! types in no particular order.\n-\n-use crate::ich::StableHashingContext;\n-use crate::mir;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n-use std::mem;\n-\n-impl_stable_hash_for!(struct mir::GeneratorLayout<'tcx> { fields });\n-impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n-impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n-impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n-impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n-    mutability,\n-    ty,\n-    user_ty,\n-    name,\n-    source_info,\n-    visibility_scope,\n-    internal,\n-    is_block_tail,\n-    is_user_variable\n-});\n-impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, var_hir_id, by_ref, mutability });\n-impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n-impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, details, kind });\n-impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n-\n-impl_stable_hash_for!(enum mir::BorrowKind {\n-    Shared,\n-    Shallow,\n-    Unique,\n-    Mut { allow_two_phase_borrow },\n-});\n-\n-impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n-    General,\n-    GeneralAndConstFn,\n-    ExternStatic(lint_node_id),\n-    BorrowPacked(lint_node_id),\n-});\n-\n-impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n-    kind,\n-    source_info\n-});\n-\n-impl_stable_hash_for!(\n-    impl<T> for enum mir::ClearCrossCrate<T> [ mir::ClearCrossCrate ] {\n-        Clear,\n-        Set(value),\n-    }\n-);\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::BasicBlock {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::SourceScope {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Promoted {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::TerminatorKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::TerminatorKind::Goto { ref target } => {\n-                target.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::SwitchInt { ref discr,\n-                                             switch_ty,\n-                                             ref values,\n-                                             ref targets } => {\n-                discr.hash_stable(hcx, hasher);\n-                switch_ty.hash_stable(hcx, hasher);\n-                values.hash_stable(hcx, hasher);\n-                targets.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Resume |\n-            mir::TerminatorKind::Abort |\n-            mir::TerminatorKind::Return |\n-            mir::TerminatorKind::GeneratorDrop |\n-            mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                location.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::DropAndReplace { ref location,\n-                                                  ref value,\n-                                                  target,\n-                                                  unwind, } => {\n-                location.hash_stable(hcx, hasher);\n-                value.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Yield { ref value,\n-                                        resume,\n-                                        drop } => {\n-                value.hash_stable(hcx, hasher);\n-                resume.hash_stable(hcx, hasher);\n-                drop.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Call { ref func,\n-                                        ref args,\n-                                        ref destination,\n-                                        cleanup,\n-                                        from_hir_call, } => {\n-                func.hash_stable(hcx, hasher);\n-                args.hash_stable(hcx, hasher);\n-                destination.hash_stable(hcx, hasher);\n-                cleanup.hash_stable(hcx, hasher);\n-                from_hir_call.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::Assert { ref cond,\n-                                          expected,\n-                                          ref msg,\n-                                          target,\n-                                          cleanup } => {\n-                cond.hash_stable(hcx, hasher);\n-                expected.hash_stable(hcx, hasher);\n-                msg.hash_stable(hcx, hasher);\n-                target.hash_stable(hcx, hasher);\n-                cleanup.hash_stable(hcx, hasher);\n-            }\n-            mir::TerminatorKind::FalseEdges { ref real_target, ref imaginary_targets } => {\n-                real_target.hash_stable(hcx, hasher);\n-                for target in imaginary_targets {\n-                    target.hash_stable(hcx, hasher);\n-                }\n-            }\n-            mir::TerminatorKind::FalseUnwind { ref real_target, ref unwind } => {\n-                real_target.hash_stable(hcx, hasher);\n-                unwind.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n-\n-impl_stable_hash_for!(impl<'gcx> for enum mir::StatementKind<'gcx> [ mir::StatementKind ] {\n-    Assign(place, rvalue),\n-    FakeRead(cause, place),\n-    SetDiscriminant { place, variant_index },\n-    StorageLive(place),\n-    StorageDead(place),\n-    Retag(retag_kind, place),\n-    AscribeUserType(place, variance, c_ty),\n-    Nop,\n-    InlineAsm { asm, outputs, inputs },\n-});\n-\n-impl_stable_hash_for!(enum mir::RetagKind { FnEntry, TwoPhase, Raw, Default });\n-impl_stable_hash_for!(enum mir::FakeReadCause {\n-    ForMatchGuard,\n-    ForMatchedPlace,\n-    ForGuardBinding,\n-    ForLet\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::Place::Base(mir::PlaceBase::Local(ref local)) => {\n-                local.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Base(mir::PlaceBase::Static(ref statik)) => {\n-                statik.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Base(mir::PlaceBase::Promoted(ref promoted)) => {\n-                promoted.hash_stable(hcx, hasher);\n-            }\n-            mir::Place::Projection(ref place_projection) => {\n-                place_projection.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, B, V, T> HashStable<StableHashingContext<'a>>\n-for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'a>>,\n-          V: HashStable<StableHashingContext<'a>>,\n-          T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let mir::Projection {\n-            ref base,\n-            ref elem,\n-        } = *self;\n-\n-        base.hash_stable(hcx, hasher);\n-        elem.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, V, T> HashStable<StableHashingContext<'a>>\n-for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'a>>,\n-          T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ProjectionElem::Deref => {}\n-            mir::ProjectionElem::Field(field, ref ty) => {\n-                field.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Index(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n-                offset.hash_stable(hcx, hasher);\n-                min_length.hash_stable(hcx, hasher);\n-                from_end.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Subslice { from, to } => {\n-                from.hash_stable(hcx, hasher);\n-                to.hash_stable(hcx, hasher);\n-            }\n-            mir::ProjectionElem::Downcast(adt_def, variant) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                variant.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::SourceScopeData { span, parent_scope });\n-impl_stable_hash_for!(struct mir::SourceScopeLocalData {\n-    lint_root, safety\n-});\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::Safety {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Safety::Safe |\n-            mir::Safety::BuiltinUnsafe |\n-            mir::Safety::FnUnsafe => {}\n-            mir::Safety::ExplicitUnsafe(node_id) => {\n-                node_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Operand<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Operand::Copy(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Operand::Move(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Operand::Constant(ref constant) => {\n-                constant.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Rvalue<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::Rvalue::Use(ref operand) => {\n-                operand.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Repeat(ref operand, ref val) => {\n-                operand.hash_stable(hcx, hasher);\n-                val.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Ref(region, borrow_kind, ref place) => {\n-                region.hash_stable(hcx, hasher);\n-                borrow_kind.hash_stable(hcx, hasher);\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Len(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Cast(cast_kind, ref operand, ty) => {\n-                cast_kind.hash_stable(hcx, hasher);\n-                operand.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::BinaryOp(op, ref operand1, ref operand2) |\n-            mir::Rvalue::CheckedBinaryOp(op, ref operand1, ref operand2) => {\n-                op.hash_stable(hcx, hasher);\n-                operand1.hash_stable(hcx, hasher);\n-                operand2.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::UnaryOp(op, ref operand) => {\n-                op.hash_stable(hcx, hasher);\n-                operand.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Discriminant(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::NullaryOp(op, ty) => {\n-                op.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                kind.hash_stable(hcx, hasher);\n-                operands.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::CastKind {\n-    Misc,\n-    ReifyFnPointer,\n-    ClosureFnPointer,\n-    UnsafeFnPointer,\n-    MutToConstPointer,\n-    Unsize\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::AggregateKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::AggregateKind::Tuple => {}\n-            mir::AggregateKind::Array(t) => {\n-                t.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Adt(adt_def, idx, substs, user_substs, active_field) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                idx.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-                user_substs.hash_stable(hcx, hasher);\n-                active_field.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Closure(def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            mir::AggregateKind::Generator(def_id, ref substs, movability) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-                movability.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum mir::BinOp {\n-    Add,\n-    Sub,\n-    Mul,\n-    Div,\n-    Rem,\n-    BitXor,\n-    BitAnd,\n-    BitOr,\n-    Shl,\n-    Shr,\n-    Eq,\n-    Lt,\n-    Le,\n-    Ne,\n-    Ge,\n-    Gt,\n-    Offset\n-});\n-\n-impl_stable_hash_for!(enum mir::UnOp {\n-    Not,\n-    Neg\n-});\n-\n-impl_stable_hash_for!(enum mir::NullOp {\n-    Box,\n-    SizeOf\n-});\n-\n-impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, user_ty, literal });\n-\n-impl_stable_hash_for!(struct mir::Location { block, statement_index });\n-\n-impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {\n-    closure_requirements,\n-    used_mut_upvars\n-});\n-\n-impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n-    num_external_vids,\n-    outlives_requirements\n-});\n-\n-impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n-    subject,\n-    outlived_free_region,\n-    blame_span,\n-    category\n-});\n-\n-impl_stable_hash_for!(enum mir::ConstraintCategory {\n-    Return,\n-    Yield,\n-    UseAsConst,\n-    UseAsStatic,\n-    TypeAnnotation,\n-    Cast,\n-    ClosureBounds,\n-    CallArgument,\n-    CopyBound,\n-    SizedBound,\n-    Assignment,\n-    OpaqueType,\n-    Boring,\n-    BoringNoLocation,\n-    Internal,\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubject<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ClosureOutlivesSubject::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::ClosureOutlivesSubject::Region(ref region) => {\n-                region.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n-\n-impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n-impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "417305139e472ee58a4e30c9c1d29a6a2e8b6a53", "filename": "src/librustc/ich/impls_misc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -1,15 +1,6 @@\n //! This module contains `HashStable` implementations for various data types\n //! that don't fit into any of the other impls_xxx modules.\n \n-impl_stable_hash_for!(enum crate::session::search_paths::PathKind {\n-    Native,\n-    Crate,\n-    Dependency,\n-    Framework,\n-    ExternFlag,\n-    All\n-});\n-\n impl_stable_hash_for!(enum ::rustc_target::spec::PanicStrategy {\n     Abort,\n     Unwind"}, {"sha": "ec1b0da68107439f0b436c1280ad35854edc4963", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 1050, "changes": 1050, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -6,11 +6,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::cell::RefCell;\n-use std::hash as std_hash;\n use std::mem;\n use crate::middle::region;\n-use crate::infer;\n-use crate::traits;\n use crate::ty;\n use crate::mir;\n \n@@ -65,20 +62,6 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::subst::UnpackedKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            ty::subst::UnpackedKind::Lifetime(lt) => lt.hash_stable(hcx, hasher),\n-            ty::subst::UnpackedKind::Type(ty) => ty.hash_stable(hcx, hasher),\n-            ty::subst::UnpackedKind::Const(ct) => ct.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -153,105 +136,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n     }\n }\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::adjustment::AutoBorrow<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::AutoBorrow::Ref(ref region, mutability) => {\n-                region.hash_stable(hcx, hasher);\n-                mutability.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(mutability) => {\n-                mutability.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::adjustment::Adjust<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::Adjust::NeverToAny |\n-            ty::adjustment::Adjust::ReifyFnPointer |\n-            ty::adjustment::Adjust::UnsafeFnPointer |\n-            ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer |\n-            ty::adjustment::Adjust::Unsize => {}\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n-                overloaded.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n-                autoref.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n-impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n-impl_stable_hash_for!(enum ty::adjustment::AllowTwoPhase {\n-    Yes,\n-    No\n-});\n-\n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::adjustment::AutoBorrowMutability::Mutable { ref allow_two_phase_borrow } => {\n-                allow_two_phase_borrow.hash_stable(hcx, hasher);\n-            }\n-            ty::adjustment::AutoBorrowMutability::Immutable => {}\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(tuple_struct ty::util::NeedsDrop { value });\n-\n-impl_stable_hash_for!(tuple_struct ty::AdtSizedConstraint<'tcx> { list });\n-\n-impl_stable_hash_for!(struct ty::UpvarPath { hir_id });\n-\n-impl_stable_hash_for!(struct ty::UpvarId { var_path, closure_expr_id });\n-\n-impl_stable_hash_for!(enum ty::BorrowKind {\n-    ImmBorrow,\n-    UniqueImmBorrow,\n-    MutBorrow\n-});\n-\n-impl_stable_hash_for!(impl<'gcx> for enum ty::UpvarCapture<'gcx> [ ty::UpvarCapture ] {\n-    ByValue,\n-    ByRef(up_var_borrow),\n-});\n-\n-impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n-    yield_ty,\n-    return_ty\n-});\n-\n-impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n-    inputs_and_output,\n-    c_variadic,\n-    unsafety,\n-    abi\n-});\n-\n-impl_stable_hash_for!(struct ty::ResolvedOpaqueTy<'tcx> {\n-    concrete_type,\n-    substs\n-});\n-\n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n     where T: HashStable<StableHashingContext<'a>>\n {\n@@ -262,108 +146,6 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n     }\n }\n \n-impl_stable_hash_for!(enum ty::ClosureKind { Fn, FnMut, FnOnce });\n-\n-impl_stable_hash_for!(enum ty::Visibility {\n-    Public,\n-    Restricted(def_id),\n-    Invisible\n-});\n-\n-impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n-impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n-impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n-impl_stable_hash_for!(impl<A, B> for tuple_struct ty::OutlivesPredicate<A, B> { a, b });\n-impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n-impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum ty::Predicate<'tcx> [ ty::Predicate ] {\n-        Trait(pred),\n-        Subtype(pred),\n-        RegionOutlives(pred),\n-        TypeOutlives(pred),\n-        Projection(pred),\n-        WellFormed(ty),\n-        ObjectSafe(def_id),\n-        ClosureKind(def_id, closure_substs, closure_kind),\n-        ConstEvaluatable(def_id, substs),\n-    }\n-);\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        std_hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::VariantFlags {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        std_hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum ty::InferConst<'tcx> [ ty::InferConst ] {\n-        Var(vid),\n-        Fresh(i),\n-        Canonical(debruijn, var),\n-    }\n-);\n-\n-impl_stable_hash_for!(enum ty::VariantDiscr {\n-    Explicit(def_id),\n-    Relative(distance)\n-});\n-\n-impl_stable_hash_for!(struct ty::FieldDef {\n-    did,\n-    ident -> (ident.name),\n-    vis,\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n-        Param(param),\n-        Infer(infer),\n-        Scalar(val),\n-        Slice(a, b),\n-        ByRef(ptr, alloc),\n-    }\n-);\n-\n-impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {\n-    alloc_id,\n-    ty,\n-});\n-\n-impl_stable_hash_for! {\n-    impl<Tag> for struct mir::interpret::Pointer<Tag> {\n-        alloc_id,\n-        offset,\n-        tag,\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    impl<Tag> for enum mir::interpret::Scalar<Tag> [ mir::interpret::Scalar ] {\n-        Bits { bits, size },\n-        Ptr(ptr),\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    impl<'tcx> for enum mir::interpret::AllocKind<'tcx> [ mir::interpret::AllocKind ] {\n-        Function(instance),\n-        Static(def_id),\n-        Memory(mem),\n-    }\n-);\n-\n // AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n@@ -402,194 +184,6 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-impl_stable_hash_for!(struct ty::Const<'tcx> {\n-    ty,\n-    val\n-});\n-\n-impl_stable_hash_for!(impl<'tcx> for enum ty::LazyConst<'tcx> [ty::LazyConst] {\n-    Unevaluated(did, substs),\n-    Evaluated(c)\n-});\n-\n-impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n-    Reported,\n-    TooGeneric\n-});\n-\n-impl_stable_hash_for!(struct mir::interpret::FrameInfo<'tcx> {\n-    call_site,\n-    lint_root,\n-    instance\n-});\n-\n-impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n-impl_stable_hash_for!(struct ty::GeneratorSubsts<'tcx> { substs });\n-\n-impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n-    parent,\n-    predicates\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, O> for enum mir::interpret::EvalErrorKind<'tcx, O>\n-        [ mir::interpret::EvalErrorKind ]\n-    {\n-        FunctionArgCountMismatch,\n-        DanglingPointerDeref,\n-        DoubleFree,\n-        InvalidMemoryAccess,\n-        InvalidFunctionPointer,\n-        InvalidBool,\n-        InvalidNullPointerUsage,\n-        ReadPointerAsBytes,\n-        ReadBytesAsPointer,\n-        ReadForeignStatic,\n-        InvalidPointerMath,\n-        DeadLocal,\n-        StackFrameLimitReached,\n-        OutOfTls,\n-        TlsOutOfBounds,\n-        CalledClosureAsFunction,\n-        VtableForArgumentlessMethod,\n-        ModifiedConstantMemory,\n-        ModifiedStatic,\n-        AssumptionNotHeld,\n-        InlineAsm,\n-        ReallocateNonBasePtr,\n-        DeallocateNonBasePtr,\n-        HeapAllocZeroBytes,\n-        Unreachable,\n-        ReadFromReturnPointer,\n-        UnimplementedTraitSelection,\n-        TypeckError,\n-        TooGeneric,\n-        DerefFunctionPointer,\n-        ExecuteMemory,\n-        OverflowNeg,\n-        RemainderByZero,\n-        DivisionByZero,\n-        GeneratorResumedAfterReturn,\n-        GeneratorResumedAfterPanic,\n-        ReferencedConstant,\n-        InfiniteLoop,\n-        ReadUndefBytes(offset),\n-        InvalidDiscriminant(val),\n-        Panic { msg, file, line, col },\n-        MachineError(err),\n-        FunctionAbiMismatch(a, b),\n-        FunctionArgMismatch(a, b),\n-        FunctionRetMismatch(a, b),\n-        NoMirFor(s),\n-        UnterminatedCString(ptr),\n-        PointerOutOfBounds { ptr, check, allocation_size },\n-        InvalidBoolOp(bop),\n-        Unimplemented(s),\n-        BoundsCheck { len, index },\n-        Intrinsic(s),\n-        InvalidChar(c),\n-        AbiViolation(s),\n-        AlignmentCheckFailed { required, has },\n-        ValidationFailure(s),\n-        TypeNotPrimitive(ty),\n-        ReallocatedWrongMemoryKind(a, b),\n-        DeallocatedWrongMemoryKind(a, b),\n-        IncorrectAllocationInformation(a, b, c, d),\n-        Layout(lay),\n-        HeapAllocNonPowerOfTwoAlignment(n),\n-        PathNotFound(v),\n-        Overflow(op),\n-    }\n-);\n-\n-impl_stable_hash_for!(enum mir::interpret::InboundsCheck {\n-    Live,\n-    MaybeDead\n-});\n-\n-impl_stable_hash_for!(enum ty::Variance {\n-    Covariant,\n-    Invariant,\n-    Contravariant,\n-    Bivariant\n-});\n-\n-impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n-    Struct(index)\n-});\n-\n-impl_stable_hash_for!(struct ty::Generics {\n-    parent,\n-    parent_count,\n-    params,\n-    // Reverse map to each param's `index` field, from its `def_id`.\n-    param_def_id_to_index -> _, // Don't hash this\n-    has_self,\n-    has_late_bound_regions,\n-});\n-\n-impl_stable_hash_for!(struct ty::GenericParamDef {\n-    name,\n-    def_id,\n-    index,\n-    pure_wrt_drop,\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum ty::GenericParamDefKind {\n-    Lifetime,\n-    Type { has_default, object_lifetime_default, synthetic },\n-    Const,\n-});\n-\n-impl_stable_hash_for!(\n-    impl<T> for enum crate::middle::resolve_lifetime::Set1<T>\n-        [ crate::middle::resolve_lifetime::Set1 ]\n-    {\n-        Empty,\n-        Many,\n-        One(value),\n-    }\n-);\n-\n-impl_stable_hash_for!(enum crate::middle::resolve_lifetime::LifetimeDefOrigin {\n-    ExplicitOrElided,\n-    InBand,\n-    Error,\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::resolve_lifetime::Region {\n-    Static,\n-    EarlyBound(index, decl, is_in_band),\n-    LateBound(db_index, decl, is_in_band),\n-    LateBoundAnon(db_index, anon_index),\n-    Free(call_site_scope_data, decl)\n-});\n-\n-impl_stable_hash_for!(enum ty::cast::CastKind {\n-    CoercionCast,\n-    PtrPtrCast,\n-    PtrAddrCast,\n-    AddrPtrCast,\n-    NumericCast,\n-    EnumCast,\n-    PrimIntCast,\n-    U8CharCast,\n-    ArrayPtrCast,\n-    FnPtrPtrCast,\n-    FnPtrAddrCast\n-});\n-\n-impl_stable_hash_for!(struct crate::middle::region::Scope { id, data });\n-\n-impl_stable_hash_for!(enum crate::middle::region::ScopeData {\n-    Node,\n-    CallSite,\n-    Arguments,\n-    Destruction,\n-    Remainder(first_statement_index)\n-});\n-\n impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n \n@@ -599,129 +193,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     }\n }\n \n-impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n-    custom_kind\n-});\n-\n-impl_stable_hash_for!(struct ty::FreeRegion {\n-    scope,\n-    bound_region\n-});\n-\n-impl_stable_hash_for!(enum ty::BoundRegion {\n-    BrAnon(index),\n-    BrNamed(def_id, name),\n-    BrFresh(index),\n-    BrEnv\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::TyKind<'gcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::ty::TyKind::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Bool  |\n-            Char  |\n-            Str   |\n-            Error |\n-            Never => {\n-                // Nothing more to hash.\n-            }\n-            Int(int_ty) => {\n-                int_ty.hash_stable(hcx, hasher);\n-            }\n-            Uint(uint_ty) => {\n-                uint_ty.hash_stable(hcx, hasher);\n-            }\n-            Float(float_ty)  => {\n-                float_ty.hash_stable(hcx, hasher);\n-            }\n-            Adt(adt_def, substs) => {\n-                adt_def.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Array(inner_ty, len) => {\n-                inner_ty.hash_stable(hcx, hasher);\n-                len.hash_stable(hcx, hasher);\n-            }\n-            Slice(inner_ty) => {\n-                inner_ty.hash_stable(hcx, hasher);\n-            }\n-            RawPtr(pointee_ty) => {\n-                pointee_ty.hash_stable(hcx, hasher);\n-            }\n-            Ref(region, pointee_ty, mutbl) => {\n-                region.hash_stable(hcx, hasher);\n-                pointee_ty.hash_stable(hcx, hasher);\n-                mutbl.hash_stable(hcx, hasher);\n-            }\n-            FnDef(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            FnPtr(ref sig) => {\n-                sig.hash_stable(hcx, hasher);\n-            }\n-            Dynamic(ref existential_predicates, region) => {\n-                existential_predicates.hash_stable(hcx, hasher);\n-                region.hash_stable(hcx, hasher);\n-            }\n-            Closure(def_id, closure_substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                closure_substs.hash_stable(hcx, hasher);\n-            }\n-            Generator(def_id, generator_substs, movability) => {\n-                def_id.hash_stable(hcx, hasher);\n-                generator_substs.hash_stable(hcx, hasher);\n-                movability.hash_stable(hcx, hasher);\n-            }\n-            GeneratorWitness(types) => {\n-                types.hash_stable(hcx, hasher)\n-            }\n-            Tuple(inner_tys) => {\n-                inner_tys.hash_stable(hcx, hasher);\n-            }\n-            Projection(ref data) | UnnormalizedProjection(ref data) => {\n-                data.hash_stable(hcx, hasher);\n-            }\n-            Opaque(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Param(param_ty) => {\n-                param_ty.hash_stable(hcx, hasher);\n-            }\n-            Bound(debruijn, bound_ty) => {\n-                debruijn.hash_stable(hcx, hasher);\n-                bound_ty.hash_stable(hcx, hasher);\n-            }\n-            ty::Placeholder(placeholder_ty) => {\n-                placeholder_ty.hash_stable(hcx, hasher);\n-            }\n-            Foreign(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            Infer(infer_ty) => {\n-                infer_ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum ty::InferTy {\n-    TyVar(a),\n-    IntVar(a),\n-    FloatVar(a),\n-    FreshTy(a),\n-    FreshIntTy(a),\n-    FreshFloatTy(a),\n-});\n-\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::TyVid\n {\n@@ -758,146 +229,6 @@ for ty::FloatVid\n     }\n }\n \n-impl_stable_hash_for!(struct ty::ParamConst {\n-    index,\n-    name\n-});\n-\n-impl_stable_hash_for!(struct ty::ParamTy {\n-    idx,\n-    name\n-});\n-\n-impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n-    ty,\n-    mutbl\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::ExistentialPredicate<'gcx>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::ExistentialPredicate::Trait(ref trait_ref) => {\n-                trait_ref.hash_stable(hcx, hasher);\n-            }\n-            ty::ExistentialPredicate::Projection(ref projection) => {\n-                projection.hash_stable(hcx, hasher);\n-            }\n-            ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ty::ExistentialTraitRef<'tcx> {\n-    def_id,\n-    substs\n-});\n-\n-impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n-    item_def_id,\n-    substs,\n-    ty\n-});\n-\n-impl_stable_hash_for!(struct ty::Instance<'tcx> {\n-    def,\n-    substs\n-});\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            ty::InstanceDef::Item(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::VtableShim(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::Intrinsic(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::Virtual(def_id, n) => {\n-                def_id.hash_stable(hcx, hasher);\n-                n.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::ClosureOnceShim { call_once } => {\n-                call_once.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::DropGlue(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::InstanceDef::CloneShim(def_id, ty) => {\n-                def_id.hash_stable(hcx, hasher);\n-                ty.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(struct ty::TraitDef {\n-    // We already have the def_path_hash below, no need to hash it twice\n-    def_id -> _,\n-    unsafety,\n-    paren_sugar,\n-    has_auto_impl,\n-    is_marker,\n-    def_path_hash,\n-});\n-\n-impl_stable_hash_for!(struct ty::Destructor {\n-    did\n-});\n-\n-impl_stable_hash_for!(struct ty::CrateVariancesMap {\n-    variances,\n-    // This is just an irrelevant helper value.\n-    empty_variance -> _,\n-});\n-\n-impl_stable_hash_for!(struct ty::CratePredicatesMap<'tcx> {\n-    predicates,\n-    // This is just an irrelevant helper value.\n-    empty_predicate -> _,\n-});\n-\n-impl_stable_hash_for!(struct ty::AssociatedItem {\n-    def_id,\n-    ident -> (ident.name),\n-    kind,\n-    vis,\n-    defaultness,\n-    container,\n-    method_has_self_argument\n-});\n-\n-impl_stable_hash_for!(enum ty::AssociatedKind {\n-    Const,\n-    Method,\n-    Existential,\n-    Type\n-});\n-\n-impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n-    TraitContainer(def_id),\n-    ImplContainer(def_id)\n-});\n-\n-\n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ty::steal::Steal<T>\n     where T: HashStable<StableHashingContext<'a>>\n@@ -909,24 +240,6 @@ for ty::steal::Steal<T>\n     }\n }\n \n-impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n-    caller_bounds,\n-    reveal,\n-    def_id\n-});\n-\n-impl_stable_hash_for!(enum traits::Reveal {\n-    UserFacing,\n-    All\n-});\n-\n-impl_stable_hash_for!(enum crate::middle::privacy::AccessLevel {\n-    ReachableFromImplTrait,\n-    Reachable,\n-    Exported,\n-    Public\n-});\n-\n impl<'a> HashStable<StableHashingContext<'a>>\n for crate::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -941,366 +254,3 @@ for crate::middle::privacy::AccessLevels {\n         });\n     }\n }\n-\n-impl_stable_hash_for!(struct ty::CrateInherentImpls {\n-    inherent_impls\n-});\n-\n-impl_stable_hash_for!(struct crate::util::common::ErrorReported {});\n-\n-impl_stable_hash_for!(tuple_struct crate::middle::reachable::ReachableSet {\n-    reachable_set\n-});\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::Vtable::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match self {\n-            &VtableImpl(ref table_impl) => table_impl.hash_stable(hcx, hasher),\n-            &VtableAutoImpl(ref table_def_impl) => table_def_impl.hash_stable(hcx, hasher),\n-            &VtableParam(ref table_param) => table_param.hash_stable(hcx, hasher),\n-            &VtableObject(ref table_obj) => table_obj.hash_stable(hcx, hasher),\n-            &VtableBuiltin(ref table_builtin) => table_builtin.hash_stable(hcx, hasher),\n-            &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n-            &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n-            &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n-            &VtableTraitAlias(ref table_alias) => table_alias.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableImplData {\n-            impl_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        impl_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableAutoImplData {\n-            trait_def_id,\n-            ref nested,\n-        } = *self;\n-        trait_def_id.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableObjectData {\n-            upcast_trait_ref,\n-            vtable_base,\n-            ref nested,\n-        } = *self;\n-        upcast_trait_ref.hash_stable(hcx, hasher);\n-        vtable_base.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableBuiltinData {\n-            ref nested,\n-        } = *self;\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableClosureData {\n-            closure_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        closure_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableFnPointerData {\n-            fn_ty,\n-            ref nested,\n-        } = *self;\n-        fn_ty.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableGeneratorData {\n-            generator_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        generator_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n-for traits::VtableTraitAliasData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let traits::VtableTraitAliasData {\n-            alias_def_id,\n-            substs,\n-            ref nested,\n-        } = *self;\n-        alias_def_id.hash_stable(hcx, hasher);\n-        substs.hash_stable(hcx, hasher);\n-        nested.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n-        max_universe, variables, value\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    struct infer::canonical::CanonicalVarValues<'tcx> {\n-        var_values\n-    }\n-);\n-\n-impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n-    kind\n-});\n-\n-impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n-    Ty(k),\n-    PlaceholderTy(placeholder),\n-    Region(ui),\n-    PlaceholderRegion(placeholder),\n-});\n-\n-impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n-    General(ui),\n-    Int,\n-    Float\n-});\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, R> for struct infer::canonical::QueryResponse<'tcx, R> {\n-        var_values, region_constraints, certainty, value\n-    }\n-);\n-\n-impl_stable_hash_for!(enum infer::canonical::Certainty {\n-    Proven, Ambiguous\n-});\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::WhereClause::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n-            TypeOutlives(ty_outlives) => ty_outlives.hash_stable(hcx, hasher),\n-            RegionOutlives(region_outlives) => region_outlives.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::WellFormed::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            Ty(ty) => ty.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::FromEnv::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n-            Ty(ty) => ty.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::DomainGoal::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Holds(wc) => wc.hash_stable(hcx, hasher),\n-            WellFormed(wf) => wf.hash_stable(hcx, hasher),\n-            FromEnv(from_env) => from_env.hash_stable(hcx, hasher),\n-            Normalize(projection) => projection.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::GoalKind::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                hypotheses.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            },\n-            And(goal1, goal2) => {\n-                goal1.hash_stable(hcx, hasher);\n-                goal2.hash_stable(hcx, hasher);\n-            }\n-            Not(goal) => goal.hash_stable(hcx, hasher),\n-            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n-            Quantified(quantifier, goal) => {\n-                quantifier.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            },\n-            Subtype(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            CannotProve => { },\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(\n-    struct traits::ProgramClause<'tcx> {\n-        goal, hypotheses, category\n-    }\n-);\n-\n-impl_stable_hash_for!(enum traits::ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-});\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use crate::traits::Clause::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Implies(clause) => clause.hash_stable(hcx, hasher),\n-            ForAll(clause) => clause.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n-impl_stable_hash_for!(enum traits::QuantifierKind {\n-    Universal,\n-    Existential\n-});\n-\n-impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty });\n-\n-impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n-\n-impl_stable_hash_for!(\n-    struct traits::Environment<'tcx> {\n-        clauses,\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    impl<'tcx, G> for struct traits::InEnvironment<'tcx, G> {\n-        environment,\n-        goal,\n-    }\n-);\n-\n-impl_stable_hash_for!(\n-    struct ty::CanonicalUserTypeAnnotation<'tcx> {\n-        user_ty, span, inferred_ty\n-    }\n-);\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserType<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::UserType::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::UserType::TypeOf(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotationIndex {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.index().hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "b407b75e68c9af4c6e307fc6ae2c3ff6ef80465f", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -7,9 +7,7 @@ pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHa\n mod caching_source_map_view;\n mod hcx;\n \n-mod impls_cstore;\n mod impls_hir;\n-mod impls_mir;\n mod impls_misc;\n mod impls_ty;\n mod impls_syntax;"}, {"sha": "95fdd6f01e2a861193931f4025d725f3f3a8330f", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -24,6 +24,7 @@\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n@@ -41,7 +42,7 @@ mod substitute;\n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewritten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct Canonical<'gcx, V> {\n     pub max_universe: ty::UniverseIndex,\n     pub variables: CanonicalVarInfos<'gcx>,\n@@ -61,7 +62,7 @@ impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n /// vectors with the original values that were replaced by canonical\n /// variables. You will need to supply it later to instantiate the\n /// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<BoundVar, Kind<'tcx>>,\n }\n@@ -99,7 +100,7 @@ impl Default for OriginalQueryValues<'tcx> {\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n@@ -122,7 +123,7 @@ impl CanonicalVarInfo {\n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -159,7 +160,7 @@ impl CanonicalVarKind {\n /// 22.) can only be instantiated with integral/float types (e.g.,\n /// usize or f32). In order to faithfully reproduce a type, we need to\n /// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n     General(ty::UniverseIndex),\n@@ -174,7 +175,7 @@ pub enum CanonicalTyVarKind {\n /// After we execute a query with a canonicalized key, we get back a\n /// `Canonical<QueryResponse<..>>`. You can use\n /// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, HashStable)]\n pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n@@ -189,7 +190,7 @@ pub type CanonicalizedQueryResponse<'gcx, T> =\n \n /// Indicates whether or not we were able to prove the query to be\n /// true.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum Certainty {\n     /// The query is known to be true, presuming that you apply the\n     /// given `var_values` and the region-constraints are satisfied."}, {"sha": "e4890977c9bd62357ad9e5786cb02076a9e79d46", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -17,21 +17,23 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_target::spec::Target;\n use rustc_data_structures::sync::{self, MetadataRef, Lrc};\n+use rustc_macros::HashStable;\n \n pub use self::NativeLibraryKind::*;\n \n // lonely orphan structs and enums looking for a better home\n \n /// Where a crate came from on the local filesystem. One of these three options\n /// must be non-None.\n-#[derive(PartialEq, Clone, Debug)]\n+#[derive(PartialEq, Clone, Debug, HashStable)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Copy, Clone,\n+         Ord, PartialOrd, Eq, PartialEq, Debug, HashStable)]\n pub enum DepKind {\n     /// A dependency that is only used for its macros, none of which are visible from other crates.\n     /// These are included in the metadata only as placeholders and are ignored when decoding.\n@@ -79,13 +81,14 @@ impl LibSource {\n     }\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum NativeLibraryKind {\n     /// native static library (.a archive)\n     NativeStatic,\n@@ -97,7 +100,7 @@ pub enum NativeLibraryKind {\n     NativeUnknown,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Option<Symbol>,\n@@ -106,13 +109,13 @@ pub struct NativeLibrary {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct ExternCrate {\n     pub src: ExternCrateSource,\n \n@@ -129,7 +132,7 @@ pub struct ExternCrate {\n     pub direct: bool,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum ExternCrateSource {\n     /// Crate is loaded by `extern crate`.\n     Extern("}, {"sha": "5d809f1407114aec0849b8554ce227cbf8df61d9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -20,6 +20,7 @@ use crate::util::nodemap::FxHashMap;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n+use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir;\n \n@@ -45,6 +46,7 @@ impl LangItem {\n     }\n }\n \n+#[derive(HashStable)]\n pub struct LanguageItems {\n     pub items: Vec<Option<DefId>>,\n     pub missing: Vec<LangItem>,"}, {"sha": "9d15b0543cb41b2e65311f05013569192bd35ab9", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -10,8 +10,10 @@ use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n use syntax_pos::Span;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_macros::HashStable;\n use errors::DiagnosticId;\n \n+#[derive(HashStable)]\n pub struct LibFeatures {\n     // A map from feature to stabilisation version.\n     pub stable: FxHashMap<Symbol, Symbol>,"}, {"sha": "6ba55f882f8fda02222495dad5ae9adc4bfc7b22", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -7,9 +7,10 @@ use crate::util::nodemap::{DefIdSet, FxHashMap};\n use std::hash::Hash;\n use std::fmt;\n use syntax::ast::NodeId;\n+use rustc_macros::HashStable;\n \n // Accessibility levels, sorted in ascending order\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum AccessLevel {\n     /// Superset of `AccessLevel::Reachable` used to mark impl Trait items.\n     ReachableFromImplTrait,"}, {"sha": "72f6d22b696f7f6d609df91c2e8b8703b8a0ae9c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -17,6 +17,7 @@ use crate::session::config;\n use crate::util::nodemap::{HirIdSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n+use rustc_macros::HashStable;\n use crate::hir;\n use crate::hir::def_id::LOCAL_CRATE;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -388,7 +389,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n \n // We introduce a new-type here, so we can have a specialized HashStable\n // implementation for it.\n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {"}, {"sha": "42e253273ab3e59fda9fab5eef174c9c4dc94331", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -13,6 +13,7 @@ use crate::ty;\n use std::mem;\n use std::fmt;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -90,7 +91,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n // placate the same deriving in `ty::FreeRegion`, but we may want to\n // actually attach a more meaningful ordering to scopes than the one\n // generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n     pub data: ScopeData,\n@@ -113,7 +115,8 @@ impl fmt::Debug for Scope {\n     }\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ScopeData {\n     Node,\n "}, {"sha": "96f0beafa005fb420722813b2eb9071e2db4fc2a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -16,6 +16,7 @@ use crate::session::Session;\n use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::mem::replace;\n@@ -31,7 +32,7 @@ use crate::hir::{self, GenericParamKind, LifetimeParamKind};\n /// The origin of a named lifetime definition.\n ///\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeDefOrigin {\n     // Explicit binders like `fn foo<'a>(x: &'a u8)` or elided like `impl Foo<&u32>`\n     ExplicitOrElided,\n@@ -62,7 +63,7 @@ pub enum LifetimeUseSet<'tcx> {\n     Many,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n     EarlyBound(\n@@ -161,7 +162,7 @@ impl Region {\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Set1<T> {\n     Empty,\n     One(T),"}, {"sha": "d4ee60eee631004c85e04143d410b6f58f8cb95d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -11,11 +11,12 @@ use std::iter;\n use crate::mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_macros::HashStable;\n use rustc_target::abi::HasDataLayout;\n \n /// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n /// or also inbounds of a *live* allocation.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InboundsCheck {\n     Live,\n     MaybeDead,"}, {"sha": "819c65e2503260649b7d395ee412c10377207cef", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -6,6 +6,7 @@ use crate::mir;\n use crate::ty::{self, Ty, layout};\n use crate::ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n+use rustc_macros::HashStable;\n \n use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n@@ -17,7 +18,7 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n     Reported,\n@@ -46,7 +47,7 @@ pub struct ConstEvalErr<'tcx> {\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FrameInfo<'tcx> {\n     pub call_site: Span, // this span is in the caller!\n     pub instance: ty::Instance<'tcx>,\n@@ -209,7 +210,7 @@ impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n \n pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant."}, {"sha": "9fb023156022a135e82507bc03af7fd7bfccdd29", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -34,13 +34,14 @@ use crate::rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n+use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n use crate::ty::codec::TyDecoder;\n use std::sync::atomic::{AtomicU32, Ordering};\n use std::num::NonZeroU32;\n \n /// Uniquely identifies a specific constant or static.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to.\n@@ -258,7 +259,7 @@ impl fmt::Display for AllocId {\n     }\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum AllocKind<'tcx> {\n     /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),"}, {"sha": "9216cb494cef9ccae392230d9abbfcdb5f2de7e9", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -1,5 +1,6 @@\n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n+use rustc_macros::HashStable;\n \n use super::{\n     AllocId, EvalResult, InboundsCheck,\n@@ -69,7 +70,8 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n ///\n /// Pointer is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct Pointer<Tag=(),Id=AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,"}, {"sha": "9620ac95d86d10db78fba8978117e0b951156ad1", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -1,11 +1,12 @@\n use std::fmt;\n+use rustc_macros::HashStable;\n \n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}};\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents the result of a raw const operation, pre-validation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct RawConst<'tcx> {\n     // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n@@ -15,7 +16,8 @@ pub struct RawConst<'tcx> {\n \n /// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n /// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {\n     /// A const generic parameter.\n     Param(ParamConst),\n@@ -80,7 +82,8 @@ impl<'tcx> ConstValue<'tcx> {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd,\n+         RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum Scalar<Tag=(), Id=AllocId> {\n     /// The raw bytes of a simple value.\n     Bits {"}, {"sha": "3a4422a62390bc8493425e695d4cc830ca00bf4b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n+use rustc_macros::HashStable;\n use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n@@ -405,7 +406,7 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock\n@@ -451,7 +452,7 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n     Set(T),\n@@ -472,7 +473,7 @@ impl<T: serialize::Decodable> serialize::UseSpecializedDecodable for ClearCrossC\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -485,7 +486,7 @@ pub struct SourceInfo {\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Mutability {\n     Mut,\n     Not,\n@@ -500,7 +501,8 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd,\n+         Ord, RustcEncodable, RustcDecodable, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -585,13 +587,14 @@ impl BorrowKind {\n \n newtype_index! {\n     pub struct Local {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"_{}\",\n         const RETURN_PLACE = 0,\n     }\n }\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n     /// User-declared variable binding\n     Var,\n@@ -721,7 +724,7 @@ impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n /// argument, or the return place.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct LocalDecl<'tcx> {\n     /// `let mut x` vs `let x`.\n     ///\n@@ -977,7 +980,7 @@ impl<'tcx> LocalDecl<'tcx> {\n }\n \n /// A closure capture, with its name and mode.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarDecl {\n     pub debug_name: Name,\n \n@@ -995,6 +998,7 @@ pub struct UpvarDecl {\n \n newtype_index! {\n     pub struct BasicBlock {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"bb{}\",\n         const START_BLOCK = 0,\n     }\n@@ -1012,7 +1016,7 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BasicBlockData<'tcx> {\n     /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n@@ -1034,13 +1038,13 @@ pub struct BasicBlockData<'tcx> {\n     pub is_cleanup: bool,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum TerminatorKind<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto { target: BasicBlock },\n@@ -1723,7 +1727,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Statement<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n@@ -1749,7 +1753,7 @@ impl<'tcx> Statement<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n@@ -1808,7 +1812,7 @@ pub enum StatementKind<'tcx> {\n }\n \n /// `RetagKind` describes what kind of retag is to be performed.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n     /// The initial retag when entering a function\n     FnEntry,\n@@ -1821,7 +1825,7 @@ pub enum RetagKind {\n }\n \n /// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n     /// code.\n@@ -1894,15 +1898,15 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Place<'tcx> {\n     Base(PlaceBase<'tcx>),\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum PlaceBase<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1931,13 +1935,15 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Place`. See the aliases\n /// `PlaceProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V, T>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<'tcx, V, T> {\n     Deref,\n     Field(Field, T),\n@@ -1994,6 +2000,7 @@ pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n \n newtype_index! {\n     pub struct Field {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"field[{}]\"\n     }\n }\n@@ -2102,18 +2109,19 @@ impl<'tcx> Debug for Place<'tcx> {\n \n newtype_index! {\n     pub struct SourceScope {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"scope[{}]\",\n         const OUTERMOST_SOURCE_SCOPE = 0,\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeData {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n     /// A HirId with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n@@ -2126,7 +2134,7 @@ pub struct SourceScopeLocalData {\n \n /// These are values that can appear inside an rvalue. They are intentionally\n /// limited to prevent rvalues from being nested in one another.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n@@ -2188,7 +2196,7 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -2224,7 +2232,7 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n \n@@ -2248,7 +2256,7 @@ pub enum CastKind {\n     Unsize,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),\n@@ -2271,7 +2279,7 @@ pub enum AggregateKind<'tcx> {\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,\n@@ -2319,15 +2327,15 @@ impl BinOp {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum NullOp {\n     /// Returns the size of a value of that type\n     SizeOf,\n     /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n@@ -2468,7 +2476,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n@@ -2515,7 +2523,7 @@ pub struct Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjections<'tcx> {\n     pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n }\n@@ -2601,7 +2609,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserTypeProjection<'tcx> {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n@@ -2671,6 +2679,7 @@ impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n \n newtype_index! {\n     pub struct Promoted {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"promoted[{}]\"\n     }\n }\n@@ -2793,7 +2802,7 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Mir<'a> {\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,\n@@ -2865,7 +2874,7 @@ impl Location {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted in const fn and regular fns.\n@@ -2874,15 +2883,15 @@ pub enum UnsafetyViolationKind {\n     BorrowPacked(hir::HirId),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub description: InternedString,\n     pub details: InternedString,\n     pub kind: UnsafetyViolationKind,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function\n     pub violations: Lrc<[UnsafetyViolation]>,\n@@ -2892,12 +2901,12 @@ pub struct UnsafetyCheckResult {\n }\n \n /// The layout of generator state\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'gcx> {\n     pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n@@ -2953,7 +2962,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// that case because the regions must be allocated in the global\n /// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'gcx> {\n     /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n@@ -2969,7 +2978,7 @@ pub struct ClosureRegionRequirements<'gcx> {\n \n /// Indicates an outlives constraint between a type or between two\n /// free-regions declared on the closure.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n     pub subject: ClosureOutlivesSubject<'tcx>,\n@@ -2989,7 +2998,8 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n /// order of the category, thereby influencing diagnostic output.\n ///\n /// See also [rustc_mir::borrow_check::nll::constraints]\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {\n     Return,\n     Yield,\n@@ -3026,7 +3036,7 @@ pub enum ConstraintCategory {\n \n /// The subject of a ClosureOutlivesRequirement -- that is, the thing\n /// that must outlive some region.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being"}, {"sha": "1b6a1739b0248ddaac32b58cf6675006708dee2b", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -1,4 +1,5 @@\n use std::path::{Path, PathBuf};\n+use rustc_macros::HashStable;\n use crate::session::{early_error, config};\n use crate::session::filesearch::make_target_lib_path;\n \n@@ -9,7 +10,7 @@ pub struct SearchPath {\n     pub files: Vec<PathBuf>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash, HashStable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "df127b934b0b11723f2de8ce6c4f8263cab2c930", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -27,6 +27,7 @@ use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::middle::region;\n use crate::mir::interpret::ErrorHandled;\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n@@ -294,27 +295,27 @@ pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum WhereClause<'tcx> {\n     Implemented(ty::TraitPredicate<'tcx>),\n     ProjectionEq(ty::ProjectionPredicate<'tcx>),\n     RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n     TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum WellFormed<'tcx> {\n     Trait(ty::TraitPredicate<'tcx>),\n     Ty(Ty<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum FromEnv<'tcx> {\n     Trait(ty::TraitPredicate<'tcx>),\n     Ty(Ty<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum DomainGoal<'tcx> {\n     Holds(WhereClause<'tcx>),\n     WellFormed(WellFormed<'tcx>),\n@@ -324,13 +325,13 @@ pub enum DomainGoal<'tcx> {\n \n pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum QuantifierKind {\n     Universal,\n     Existential,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum GoalKind<'tcx> {\n     Implies(Clauses<'tcx>, Goal<'tcx>),\n     And(Goal<'tcx>, Goal<'tcx>),\n@@ -376,7 +377,7 @@ impl<'tcx> GoalKind<'tcx> {\n \n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum Clause<'tcx> {\n     Implies(ProgramClause<'tcx>),\n     ForAll(ty::Binder<ProgramClause<'tcx>>),\n@@ -400,7 +401,7 @@ pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n /// it with the reverse implication operator `:-` to emphasize the way\n /// that programs are actually solved (via backchaining, which starts\n /// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct ProgramClause<'tcx> {\n     /// This goal will be considered true ...\n     pub goal: DomainGoal<'tcx>,\n@@ -412,15 +413,15 @@ pub struct ProgramClause<'tcx> {\n     pub category: ProgramClauseCategory,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub enum ProgramClauseCategory {\n     ImpliedBound,\n     WellFormed,\n     Other,\n }\n \n /// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct Environment<'tcx> {\n     pub clauses: Clauses<'tcx>,\n }\n@@ -435,7 +436,7 @@ impl Environment<'tcx> {\n }\n \n /// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n pub struct InEnvironment<'tcx, G> {\n     pub environment: Environment<'tcx>,\n     pub goal: G,\n@@ -514,7 +515,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -562,14 +563,14 @@ pub enum Vtable<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: ty::GeneratorSubsts<'tcx>,\n@@ -578,7 +579,7 @@ pub struct VtableGeneratorData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: ty::ClosureSubsts<'tcx>,\n@@ -587,20 +588,20 @@ pub struct VtableClosureData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableBuiltinData<N> {\n     pub nested: Vec<N>\n }\n \n /// A vtable for some object-safe trait `Foo` automatically derived\n /// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -613,13 +614,13 @@ pub struct VtableObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VtableTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "197bea1c3118998247d01369866e500ba97ab21d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -17,6 +17,7 @@ use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::TypeVariableOrigin;\n use crate::mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n+use rustc_macros::HashStable;\n use syntax::ast::Ident;\n use crate::ty::subst::{Subst, InternalSubsts};\n use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n@@ -25,7 +26,7 @@ use crate::util::common::FN_OUTPUT_NAME;\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n pub enum Reveal {\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types"}, {"sha": "f9149ce0f6e6b2a43e0b84e124834754d45a23ff", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -2,6 +2,7 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n+use rustc_macros::HashStable;\n \n \n /// Represents coercing a value to a different type of value.\n@@ -44,13 +45,13 @@ use crate::ty::subst::SubstsRef;\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n ///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -90,7 +91,7 @@ pub enum Adjust<'tcx> {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -121,13 +122,13 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n /// capable mutable borrows.\n /// See #49434 for tracking.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AllowTwoPhase {\n     Yes,\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n     Mutable { allow_two_phase_borrow: AllowTwoPhase },\n     Immutable,\n@@ -142,7 +143,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n@@ -157,7 +158,7 @@ pub enum AutoBorrow<'tcx> {\n /// This struct can be obtained via the `coerce_impl_info` query.\n /// Demanding this struct also has the side-effect of reporting errors\n /// for inappropriate impls.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct CoerceUnsizedInfo {\n     /// If this is a \"custom coerce\" impl, then what kind of custom\n     /// coercion is it? This applies to impls of `CoerceUnsized` for\n@@ -166,7 +167,7 @@ pub struct CoerceUnsizedInfo {\n     pub custom_kind: Option<CustomCoerceUnsized>\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize)"}, {"sha": "7ea5c73c5b749b9803cf53617e6b2e27946286ec", "filename": "src/librustc/ty/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcast.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -4,6 +4,7 @@\n use crate::ty::{self, Ty};\n \n use syntax::ast;\n+use rustc_macros::HashStable;\n \n /// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -32,7 +33,7 @@ pub enum CastTy<'tcx> {\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     CoercionCast,\n     PtrPtrCast,"}, {"sha": "e290ad19642b5f734eef9caf53261ac0d2f903e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -65,6 +65,7 @@ use std::sync::mpsc;\n use std::sync::Arc;\n use std::marker::PhantomData;\n use rustc_target::spec::abi;\n+use rustc_macros::HashStable;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n@@ -316,7 +317,7 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n }\n \n /// All information necessary to validate and reveal an `impl Trait` or `existential Type`\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct ResolvedOpaqueTy<'tcx> {\n     /// The revealed type as seen by this function.\n     pub concrete_type: Ty<'tcx>,\n@@ -808,6 +809,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n newtype_index! {\n     pub struct UserTypeAnnotationIndex {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"UserType({})\",\n         const START_INDEX = 0,\n     }\n@@ -817,7 +819,7 @@ newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -893,7 +895,7 @@ impl CanonicalUserType<'gcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "e0b7bbc68e25e95da3f60f53b668ecb05cfb891a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -3,18 +3,19 @@ use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, PolyFnSig, TypeFoldable, SubstsRef, TyCtxt};\n use crate::traits;\n use rustc_target::spec::abi::Abi;\n+use rustc_macros::HashStable;\n use crate::util::ppaux;\n \n use std::fmt;\n use std::iter;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),"}, {"sha": "68bdae7d744c53b3724247d6f6b82852ec73ac96", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -10,6 +10,7 @@ use crate::hir::def::{Def, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::hir::map::DefPathData;\n use rustc_data_structures::svh::Svh;\n+use rustc_macros::HashStable;\n use crate::ich::Fingerprint;\n use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n@@ -128,7 +129,7 @@ pub struct Resolutions {\n     pub extern_prelude: FxHashMap<Name, bool>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n     ImplContainer(DefId),\n@@ -163,9 +164,10 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n@@ -177,7 +179,7 @@ pub struct AssociatedItem {\n     pub method_has_self_argument: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum AssociatedKind {\n     Const,\n     Method,\n@@ -225,7 +227,7 @@ impl AssociatedItem {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -312,7 +314,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcDecodable, RustcEncodable, Hash, HashStable)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -326,13 +328,15 @@ pub enum Variance {\n /// HIR of every item in the local crate. Instead, use\n /// `tcx.variances_of()` to get the variance for a *particular*\n /// item.\n+#[derive(HashStable)]\n pub struct CrateVariancesMap {\n     /// For each item with generics, maps to a vector of the variance\n     /// of its generics. If an item has no generics, it will have no\n     /// entry.\n     pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n \n     /// An empty vector, useful for cloning.\n+    #[stable_hasher(ignore)]\n     pub empty_variance: Lrc<Vec<ty::Variance>>,\n }\n \n@@ -718,21 +722,21 @@ impl<T> List<T> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -780,7 +784,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -791,7 +795,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -833,7 +837,7 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n@@ -844,7 +848,7 @@ pub enum GenericParamDefKind {\n     Const,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: InternedString,\n     pub def_id: DefId,\n@@ -892,13 +896,14 @@ pub struct GenericParamCount {\n ///\n /// The ordering of parameters is the same as in `Subst` (excluding child generics):\n /// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_count: usize,\n     pub params: Vec<GenericParamDef>,\n \n     /// Reverse map to the `index` field of each `GenericParamDef`\n+    #[stable_hasher(ignore)]\n     pub param_def_id_to_index: FxHashMap<DefId, u32>,\n \n     pub has_self: bool,\n@@ -995,7 +1000,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<(Predicate<'tcx>, Span)>,\n@@ -1058,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -1099,13 +1104,15 @@ pub enum Predicate<'tcx> {\n /// HIR of every item in the local crate. Instead, use\n /// `tcx.inferred_outlives_of()` to get the outlives for a *particular*\n /// item.\n+#[derive(HashStable)]\n pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n     pub predicates: FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n \n     /// An empty vector, useful for cloning.\n+    #[stable_hasher(ignore)]\n     pub empty_predicate: Lrc<Vec<ty::Predicate<'tcx>>>,\n }\n \n@@ -1209,7 +1216,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -1237,7 +1244,8 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n@@ -1247,7 +1255,7 @@ pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>,\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n     pub a: Ty<'tcx>,\n@@ -1267,7 +1275,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1622,7 +1630,7 @@ pub type PlaceholderType = Placeholder<BoundVar>;\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n pub struct ParamEnv<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n@@ -1757,13 +1765,14 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct Destructor {\n     /// The `DefId` of the destructor method\n     pub did: DefId,\n }\n \n bitflags! {\n+    #[derive(HashStable)]\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n         const IS_ENUM             = 1 << 0;\n@@ -1784,6 +1793,7 @@ bitflags! {\n }\n \n bitflags! {\n+    #[derive(HashStable)]\n     pub struct VariantFlags: u32 {\n         const NO_VARIANT_FLAGS        = 0;\n         /// Indicates whether the field list of this variant is `#[non_exhaustive]`.\n@@ -1861,7 +1871,7 @@ impl_stable_hash_for!(struct VariantDef {\n     flags\n });\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n@@ -1874,9 +1884,10 @@ pub enum VariantDiscr {\n     Relative(u32),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, HashStable)]\n pub struct FieldDef {\n     pub did: DefId,\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub vis: Visibility,\n }\n@@ -2497,7 +2508,8 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n ///\n /// You can get the environment type of a closure using\n /// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n     // because the trait Fn is a subtrait of FnMut and so in turn, and\n@@ -3092,7 +3104,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n               parent_item.node)\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n /// Calculates the `Sized` constraint.\n@@ -3325,7 +3337,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// rather, you should request the vector for a specific type via\n /// `tcx.inherent_impls(def_id)` so as to minimize your dependencies\n /// (constructing this map requires touching the entire crate).\n-#[derive(Clone, Debug, Default)]\n+#[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }"}, {"sha": "39728cc8cd5cba9916b691439f4cf3e5b26567e4", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -7,6 +7,7 @@ use crate::mir::interpret::{ConstValue, truncate};\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n use crate::ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n@@ -25,14 +26,15 @@ use serialize;\n use self::InferTy::*;\n use self::TyKind::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, HashStable)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -41,7 +43,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable, Copy)]\n+         RustcEncodable, RustcDecodable, Copy, HashStable)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -82,7 +84,8 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -303,7 +306,8 @@ static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n ///\n /// It'd be nice to split this struct into ClosureSubsts and\n /// GeneratorSubsts, I believe. -nmatsakis\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with the types of the upvars.\n@@ -386,7 +390,8 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -519,7 +524,8 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n     Trait(ExistentialTraitRef<'tcx>),\n@@ -670,7 +676,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n /// or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -740,7 +746,8 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -913,7 +920,8 @@ impl<T> Binder<T> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: SubstsRef<'tcx>,\n@@ -958,7 +966,7 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GenSig<'tcx> {\n     pub yield_ty: Ty<'tcx>,\n     pub return_ty: Ty<'tcx>,\n@@ -981,7 +989,8 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// - `inputs`: is the list of arguments and their modes.\n /// - `output`: is the return type.\n /// - `c_variadic`: indicates whether this is a C-variadic function.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n     pub c_variadic: bool,\n@@ -1031,7 +1040,8 @@ impl<'tcx> PolyFnSig<'tcx> {\n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n     pub idx: u32,\n     pub name: InternedString,\n@@ -1062,7 +1072,8 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n pub struct ParamConst {\n     pub index: u32,\n     pub name: InternedString,\n@@ -1278,7 +1289,8 @@ impl Atom for RegionVid {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n+         Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -1321,7 +1333,8 @@ impl From<BoundVar> for BoundTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -2083,7 +2096,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to `Evaluated` if the\n /// code is monomorphic enough for that.\n pub enum LazyConst<'tcx> {\n@@ -2129,7 +2143,8 @@ impl<'tcx> LazyConst<'tcx> {\n }\n \n /// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable,\n+         Eq, PartialEq, Ord, PartialOrd, HashStable)]\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,\n \n@@ -2273,7 +2288,8 @@ impl<'tcx> Const<'tcx> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx LazyConst<'tcx> {}\n \n /// An inference variable for a const, for use in const generics.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd,\n+         Ord, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum InferConst<'tcx> {\n     /// Infer the value of the const.\n     Var(ConstVid<'tcx>),"}, {"sha": "38be19a71c48cbdba1c387a74bf602b770c66ab6", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -9,6 +9,7 @@ use crate::mir::interpret::ConstValue;\n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n+use rustc_macros::HashStable;\n \n use core::intrinsics;\n use std::cmp::Ordering;\n@@ -33,7 +34,7 @@ const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n@@ -666,7 +667,7 @@ pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserSubsts<'tcx> {\n     /// The substitutions for the item as given by the user.\n     pub substs: SubstsRef<'tcx>,\n@@ -707,7 +708,7 @@ BraceStructLiftImpl! {\n /// the impl (with the substs from `UserSubsts`) and apply those to\n /// the self type, giving `Foo<?A>`. Finally, we unify that with\n /// the self type here, which contains `?A` to be `&'static u32`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UserSelfTy<'tcx> {\n     pub impl_def_id: DefId,\n     pub self_ty: Ty<'tcx>,"}, {"sha": "b25a6c4f28c77f6ab9b6ce4f9e4a20aa7a6c8cb8", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -11,9 +11,13 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable;\n \n /// A trait's definition with type information.\n+#[derive(HashStable)]\n pub struct TraitDef {\n+    // We already have the def_path_hash below, no need to hash it twice\n+    #[stable_hasher(ignore)]\n     pub def_id: DefId,\n \n     pub unsafety: hir::Unsafety,"}, {"sha": "422f97b299646361e45f535da3f53aaca64dbc9d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -18,6 +18,7 @@ use crate::middle::lang_items;\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_macros::HashStable;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -1005,7 +1006,7 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "5622fe434363a05fc1d289bbe74a315d78ca5976", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -12,6 +12,7 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n+use rustc_macros::HashStable;\n use crate::ty::TyCtxt;\n use crate::dep_graph::{DepNode};\n use lazy_static;\n@@ -22,7 +23,7 @@ pub const FN_OUTPUT_NAME: &str = \"Output\";\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));"}, {"sha": "52f23f4893eeb23e320e1a12776166722960f53d", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3936aff2169a1f61633de2bc475face3a2682efb/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=3936aff2169a1f61633de2bc475face3a2682efb", "patch": "@@ -1,3 +1,5 @@\n+use crate::stable_hasher::{StableHasher, StableHasherResult, HashStable};\n+\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n@@ -56,3 +58,11 @@ impl<T> Extend<T> for ThinVec<T> {\n         }\n     }\n }\n+\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(hcx, hasher)\n+    }\n+}"}]}