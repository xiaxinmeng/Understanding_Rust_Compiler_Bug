{"sha": "a795f0f5367d35c7c5e8f03228037ae0aa0fee6a", "node_id": "C_kwDOAAsO6NoAKGE3OTVmMGY1MzY3ZDM1YzdjNWU4ZjAzMjI4MDM3YWUwYWEwZmVlNmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-07T10:35:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-07T10:35:57Z"}, "message": "Rollup merge of #94685 - RalfJung:saturating, r=oli-obk\n\ninterpret: move saturating_add/sub into (pub) helper method\n\nI plan to use them for `simd_saturating_add/sub`.\n\nThe first commit just moves code, the 2nd simplifies it a bit with some helper methods that did not exist yet when the code was originally written.", "tree": {"sha": "8a425e3f124a82063f9fec24f2cc2d72f8028d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a425e3f124a82063f9fec24f2cc2d72f8028d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiJeAOCRBK7hj4Ov3rIwAAl7UIAH2dD1ruDWdYVYMV35d6BYn8\nYdVpDP42zrVTJOzJltBDtAp/s4Ny0hwdUNBiAQPZzwESLUUnfhx0OzgtfKKt8dBw\nShQcloffi1y5+eMCfE+Ii7FjSFUPnPMsfQLWHtk+6V1+VCXjJCzMQrK5oCvLT9vQ\nRHINh+k50/2Jkf3YF82j1j67APL7ttZHh0HzwZoV2Q2PzKTZbW3QNErAPHD3G7ty\nhJRNWPZWSfyLR6NgVJnH6FmYIlQ3yuOx954KkOy4pGVKIpPAIIUExACZWCIc5wQP\nUjZ7GfmYL3alUSkMEs/LqPrQYTbbMPkKUMJymX40Zg3FdnZVyQ5yLY2xNwaLuv8=\n=tZK9\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a425e3f124a82063f9fec24f2cc2d72f8028d51\nparent 87df3f663d302431d745172f35f34997b05945d1\nparent ac844986d8f5646b686e2a5619e5a90372953b38\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646649357 +0100\ncommitter GitHub <noreply@github.com> 1646649357 +0100\n\nRollup merge of #94685 - RalfJung:saturating, r=oli-obk\n\ninterpret: move saturating_add/sub into (pub) helper method\n\nI plan to use them for `simd_saturating_add/sub`.\n\nThe first commit just moves code, the 2nd simplifies it a bit with some helper methods that did not exist yet when the code was originally written.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a", "html_url": "https://github.com/rust-lang/rust/commit/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87df3f663d302431d745172f35f34997b05945d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/87df3f663d302431d745172f35f34997b05945d1", "html_url": "https://github.com/rust-lang/rust/commit/87df3f663d302431d745172f35f34997b05945d1"}, {"sha": "ac844986d8f5646b686e2a5619e5a90372953b38", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac844986d8f5646b686e2a5619e5a90372953b38", "html_url": "https://github.com/rust-lang/rust/commit/ac844986d8f5646b686e2a5619e5a90372953b38"}], "stats": {"total": 84, "additions": 45, "deletions": 39}, "files": [{"sha": "715b174491bcbc524921d082b028a17b3b1cb487", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a795f0f5367d35c7c5e8f03228037ae0aa0fee6a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=a795f0f5367d35c7c5e8f03228037ae0aa0fee6a", "patch": "@@ -219,48 +219,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::saturating_add | sym::saturating_sub => {\n                 let l = self.read_immediate(&args[0])?;\n                 let r = self.read_immediate(&args[1])?;\n-                let is_add = intrinsic_name == sym::saturating_add;\n-                let (val, overflowed, _ty) = self.overflowing_binary_op(\n-                    if is_add { BinOp::Add } else { BinOp::Sub },\n+                let val = self.saturating_arith(\n+                    if intrinsic_name == sym::saturating_add { BinOp::Add } else { BinOp::Sub },\n                     &l,\n                     &r,\n                 )?;\n-                let val = if overflowed {\n-                    let size = l.layout.size;\n-                    let num_bits = size.bits();\n-                    if l.layout.abi.is_signed() {\n-                        // For signed ints the saturated value depends on the sign of the first\n-                        // term since the sign of the second term can be inferred from this and\n-                        // the fact that the operation has overflowed (if either is 0 no\n-                        // overflow can occur)\n-                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n-                        let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n-                        if first_term_positive {\n-                            // Negative overflow not possible since the positive first term\n-                            // can only increase an (in range) negative term for addition\n-                            // or corresponding negated positive term for subtraction\n-                            Scalar::from_uint(\n-                                (1u128 << (num_bits - 1)) - 1, // max positive\n-                                Size::from_bits(num_bits),\n-                            )\n-                        } else {\n-                            // Positive overflow not possible for similar reason\n-                            // max negative\n-                            Scalar::from_uint(1u128 << (num_bits - 1), Size::from_bits(num_bits))\n-                        }\n-                    } else {\n-                        // unsigned\n-                        if is_add {\n-                            // max unsigned\n-                            Scalar::from_uint(size.unsigned_int_max(), Size::from_bits(num_bits))\n-                        } else {\n-                            // underflow to 0\n-                            Scalar::from_uint(0u128, Size::from_bits(num_bits))\n-                        }\n-                    }\n-                } else {\n-                    val\n-                };\n                 self.write_scalar(val, dest)?;\n             }\n             sym::discriminant_value => {\n@@ -508,6 +471,49 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n     }\n \n+    pub fn saturating_arith(\n+        &self,\n+        mir_op: BinOp,\n+        l: &ImmTy<'tcx, M::PointerTag>,\n+        r: &ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        assert!(matches!(mir_op, BinOp::Add | BinOp::Sub));\n+        let (val, overflowed, _ty) = self.overflowing_binary_op(mir_op, l, r)?;\n+        Ok(if overflowed {\n+            let size = l.layout.size;\n+            let num_bits = size.bits();\n+            if l.layout.abi.is_signed() {\n+                // For signed ints the saturated value depends on the sign of the first\n+                // term since the sign of the second term can be inferred from this and\n+                // the fact that the operation has overflowed (if either is 0 no\n+                // overflow can occur)\n+                let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n+                if first_term_positive {\n+                    // Negative overflow not possible since the positive first term\n+                    // can only increase an (in range) negative term for addition\n+                    // or corresponding negated positive term for subtraction\n+                    Scalar::from_int(size.signed_int_max(), size)\n+                } else {\n+                    // Positive overflow not possible for similar reason\n+                    // max negative\n+                    Scalar::from_int(size.signed_int_min(), size)\n+                }\n+            } else {\n+                // unsigned\n+                if matches!(mir_op, BinOp::Add) {\n+                    // max unsigned\n+                    Scalar::from_uint(size.unsigned_int_max(), size)\n+                } else {\n+                    // underflow to 0\n+                    Scalar::from_uint(0u128, size)\n+                }\n+            }\n+        } else {\n+            val\n+        })\n+    }\n+\n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n     /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n     /// 0, so offset-by-0 (and only 0) is okay -- except that null cannot be offset by _any_ value."}]}