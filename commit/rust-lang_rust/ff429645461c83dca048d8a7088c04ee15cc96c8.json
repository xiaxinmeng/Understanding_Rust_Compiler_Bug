{"sha": "ff429645461c83dca048d8a7088c04ee15cc96c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNDI5NjQ1NDYxYzgzZGNhMDQ4ZDhhNzA4OGMwNGVlMTVjYzk2Yzg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-17T12:17:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-17T22:03:12Z"}, "message": "Clean up some of trans using block combinators\n\n`with_scope` and `with_cond` can be used to wrap a piece of code in a\nscope block, or conditionalize it on a value, without doing all the\ncontext-creation and jumping by hand.\n\nAlso renames @block_ctxt to block to reduce noise.", "tree": {"sha": "b0e7f4ff8ff8becd67aa3f90fcdbf7b5cb029a18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0e7f4ff8ff8becd67aa3f90fcdbf7b5cb029a18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff429645461c83dca048d8a7088c04ee15cc96c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff429645461c83dca048d8a7088c04ee15cc96c8", "html_url": "https://github.com/rust-lang/rust/commit/ff429645461c83dca048d8a7088c04ee15cc96c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff429645461c83dca048d8a7088c04ee15cc96c8/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c1261bcb86841cc5fdedd9db0f0ced8a178cb4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1261bcb86841cc5fdedd9db0f0ced8a178cb4d", "html_url": "https://github.com/rust-lang/rust/commit/1c1261bcb86841cc5fdedd9db0f0ced8a178cb4d"}], "stats": {"total": 1700, "additions": 792, "deletions": 908}, "files": [{"sha": "efd9203911c8165f93017213286b3fd6511099d9", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -224,7 +224,7 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n     codemap::lookup_char_pos(cm, sp.lo).line\n }\n \n-fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n+fn create_block(cx: block) -> @metadata<block_md> {\n     let cache = get_cache(bcx_ccx(cx));\n     let cx = cx;\n     while option::is_none(cx.block_span) {\n@@ -677,7 +677,7 @@ fn create_var(type_tag: int, context: ValueRef, name: str, file: ValueRef,\n     ret llmdnode(lldata);\n }\n \n-fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n+fn create_local_var(bcx: block, local: @ast::local)\n     -> @metadata<local_var_md> unsafe {\n     let cx = bcx_ccx(bcx);\n     let cache = get_cache(cx);\n@@ -728,7 +728,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     ret mdval;\n }\n \n-fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n+fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> @metadata<argument_md> unsafe {\n     let fcx = bcx_fcx(bcx);\n     let cx = fcx_ccx(fcx);\n@@ -763,7 +763,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n     ret mdval;\n }\n \n-fn update_source_pos(cx: @block_ctxt, s: span) {\n+fn update_source_pos(cx: block, s: span) {\n     if !bcx_ccx(cx).sess.opts.debuginfo {\n         ret;\n     }"}, {"sha": "38cd5e83af02558002ef158f92553388550739d9", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 93, "deletions": 113, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -3,8 +3,7 @@ import lib::llvm::llvm;\n import lib::llvm::{ValueRef, BasicBlockRef};\n import pat_util::*;\n import build::*;\n-import base::{new_sub_block_ctxt, new_scope_block_ctxt,\n-              new_real_block_ctxt, load_if_immediate};\n+import base::*;\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_util::{dummy_sp};\n@@ -38,28 +37,28 @@ enum opt_result {\n     single_result(result),\n     range_result(result, result),\n }\n-fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n+fn trans_opt(bcx: block, o: opt) -> opt_result {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     alt o {\n       lit(l) {\n         alt l.node {\n           ast::expr_lit(@{node: ast::lit_str(s), _}) {\n             let strty = ty::mk_str(bcx_tcx(bcx));\n-            let cell = base::empty_dest_cell();\n-            bcx = tvec::trans_str(bcx, s, base::by_val(cell));\n+            let cell = empty_dest_cell();\n+            bcx = tvec::trans_str(bcx, s, by_val(cell));\n             add_clean_temp(bcx, *cell, strty);\n             ret single_result(rslt(bcx, *cell));\n           }\n           _ {\n             ret single_result(\n-                rslt(bcx, base::trans_const_expr(ccx, l)));\n+                rslt(bcx, trans_const_expr(ccx, l)));\n           }\n         }\n       }\n       var(disr_val, _) { ret single_result(rslt(bcx, C_int(ccx, disr_val))); }\n       range(l1, l2) {\n-        ret range_result(rslt(bcx, base::trans_const_expr(ccx, l1)),\n-                         rslt(bcx, base::trans_const_expr(ccx, l2)));\n+        ret range_result(rslt(bcx, trans_const_expr(ccx, l1)),\n+                         rslt(bcx, trans_const_expr(ccx, l2)));\n       }\n     }\n }\n@@ -259,9 +258,9 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n     ret found;\n }\n \n-fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n+fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n-   {vals: [ValueRef], bcx: @block_ctxt} {\n+   {vals: [ValueRef], bcx: block} {\n     let ccx = bcx.fcx.ccx, bcx = bcx;\n     // invariant:\n     // pat_id must have the same length ty_param_substs as vdefs?\n@@ -285,7 +284,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n             // invariant needed:\n             // how do we know it even makes sense to pass in ty_param_substs\n             // here? What if it's [] and the enum type has variables in it?\n-            base::GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n+            GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n                             ty_param_substs, i);\n         bcx = r.bcx;\n         args += [r.val];\n@@ -363,31 +362,27 @@ fn pick_col(m: match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n+fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n                     &exits: [exit_node]) {\n     let bcx = bcx;\n     if m.len() == 0u { Br(bcx, f()); ret; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n         alt data.guard {\n           some(e) {\n-            let guard_cx = new_scope_block_ctxt(bcx, \"submatch_guard\");\n-            Br(bcx, guard_cx.llbb);\n-            // Temporarily set bindings. They'll be rewritten to PHI nodes for\n-            // the actual arm block.\n+            // Temporarily set bindings. They'll be rewritten to PHI nodes\n+            // for the actual arm block.\n             data.id_map.items {|key, val|\n-                let local = local_mem(option::get(assoc(key, m[0].bound)));\n-                bcx.fcx.lllocals.insert(val, local);\n+                let loc = local_mem(option::get(assoc(key, m[0].bound)));\n+                bcx.fcx.lllocals.insert(val, loc);\n+            };\n+            let {bcx: guard_cx, val} = with_scope_result(bcx, \"guard\") {|bcx|\n+                trans_temp_expr(bcx, e)\n+            };\n+            bcx = with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n+                compile_submatch(bcx, vec::tail(m), vals, f, exits);\n+                bcx\n             };\n-            let {bcx: guard_bcx, val: guard_val} =\n-                base::trans_temp_expr(guard_cx, e);\n-            guard_bcx = base::trans_block_cleanups(guard_bcx, guard_cx);\n-            let next_cx = new_sub_block_ctxt(guard_cx, \"submatch_next\");\n-            let else_cx = new_sub_block_ctxt(guard_cx, \"submatch_else\");\n-            CondBr(guard_bcx, guard_val, next_cx.llbb, else_cx.llbb);\n-            compile_submatch(else_cx, vec::slice(m, 1u, m.len()), vals, f,\n-                             exits);\n-            bcx = next_cx;\n           }\n           _ { }\n         }\n@@ -425,7 +420,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n+            let r = GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             rec_vals += [r.val];\n             bcx = r.bcx;\n         }\n@@ -442,7 +437,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         };\n         let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n-            let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n+            let r = GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             tup_vals += [r.val];\n             bcx = r.bcx;\n             i += 1u;\n@@ -507,7 +502,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     let else_cx =\n         alt kind {\n           no_branch | single { bcx }\n-          _ { new_sub_block_ctxt(bcx, \"match_else\") }\n+          _ { sub_block(bcx, \"match_else\") }\n         };\n     let sw;\n     if kind == switch {\n@@ -521,7 +516,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n-        let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n+        let opt_cx = sub_block(bcx, \"match_case\");\n         alt kind {\n           single { Br(bcx, opt_cx.llbb); }\n           switch {\n@@ -536,35 +531,24 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             }\n           }\n           compare {\n-            let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n-            Br(bcx, compare_cx.llbb);\n-            bcx = compare_cx;\n             let t = node_id_type(bcx, pat_id);\n-            let res = trans_opt(bcx, opt);\n-            alt res {\n-              single_result(r) {\n-                bcx = r.bcx;\n-                let eq =\n-                    base::trans_compare(bcx, ast::eq, test_val, t, r.val, t);\n-                let cleanup_cx = base::trans_block_cleanups(\n-                    eq.bcx, compare_cx);\n-                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n-                CondBr(cleanup_cx, eq.val, opt_cx.llbb, bcx.llbb);\n-              }\n-              range_result(rbegin, rend) {\n-                bcx = rend.bcx;\n-                let ge = base::trans_compare(bcx, ast::ge, test_val, t,\n-                                              rbegin.val, t);\n-                let le = base::trans_compare(ge.bcx, ast::le, test_val, t,\n-                                              rend.val, t);\n-                let in_range = rslt(le.bcx, And(le.bcx, ge.val, le.val));\n-                bcx = in_range.bcx;\n-                let cleanup_cx =\n-                    base::trans_block_cleanups(bcx, compare_cx);\n-                bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n-                CondBr(cleanup_cx, in_range.val, opt_cx.llbb, bcx.llbb);\n-              }\n-            }\n+            let {bcx: after_cx, val: matches} =\n+                with_scope_result(bcx, \"compare_scope\") {|bcx|\n+                alt trans_opt(bcx, opt) {\n+                  single_result({bcx, val}) {\n+                    trans_compare(bcx, ast::eq, test_val, t, val, t)\n+                  }\n+                  range_result({val: vbegin, _}, {bcx, val: vend}) {\n+                    let {bcx, val: ge} = trans_compare(bcx, ast::ge, test_val,\n+                                                       t, vbegin, t);\n+                    let {bcx, val: le} = trans_compare(bcx, ast::le, test_val,\n+                                                       t, vend, t);\n+                    {bcx: bcx, val: And(bcx, ge, le)}\n+                  }\n+                }\n+            };\n+            bcx = sub_block(after_cx, \"compare_next\");\n+            CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n           }\n           _ { }\n         }\n@@ -592,7 +576,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n }\n \n // Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n+fn make_phi_bindings(bcx: block, map: [exit_node],\n                      ids: pat_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true, bcx = bcx;\n@@ -623,8 +607,8 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                         make_phi_bindings\"); }\n                 };\n                 let e_ty = node_id_type(bcx, node_id);\n-                let {bcx: abcx, val: alloc} = base::alloc_ty(bcx, e_ty);\n-                bcx = base::copy_val(abcx, base::INIT, alloc,\n+                let {bcx: abcx, val: alloc} = alloc_ty(bcx, e_ty);\n+                bcx = copy_val(abcx, INIT, alloc,\n                                       load_if_immediate(abcx, local, e_ty),\n                                       e_ty);\n                 add_clean(bcx, alloc, e_ty);\n@@ -637,76 +621,72 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n     ret success;\n }\n \n-fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n-             dest: base::dest) -> @block_ctxt {\n-    let bodies = [];\n-    let match: match = [];\n-    let alt_cx = new_scope_block_ctxt(cx, \"alt\");\n-    Br(cx, alt_cx.llbb);\n-\n-    let er = base::trans_temp_expr(alt_cx, expr);\n-    if er.bcx.unreachable { ret er.bcx; }\n-\n-    /*\n-      n.b. nothing else in this module should need to normalize,\n-      b/c of this call\n-     */\n-    let arms = normalize_arms(bcx_tcx(cx), arms_);\n-\n-    for a: ast::arm in arms {\n-        let body = new_real_block_ctxt(er.bcx, \"case_body\",\n-                                       a.body.span);\n-        let id_map = pat_util::pat_id_map(bcx_tcx(cx), a.pats[0]);\n+fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n+             dest: dest) -> block {\n+    with_scope(bcx, \"alt\") {|bcx| trans_alt_inner(bcx, expr, arms, dest)}\n+}\n+\n+fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n+                   dest: dest) -> block {\n+    let bcx = scope_cx, tcx = bcx_tcx(bcx);\n+    let bodies = [], match = [];\n+\n+    let {bcx, val, _} = trans_temp_expr(bcx, expr);\n+    if bcx.unreachable { ret bcx; }\n+\n+    // n.b. nothing else in this module should need to normalize,\n+    // b/c of this call\n+    let arms = normalize_arms(tcx, arms);\n+\n+    for a in arms {\n+        let body = scope_block(bcx, \"case_body\");\n+        body.block_span = some(a.body.span);\n+        let id_map = pat_util::pat_id_map(tcx, a.pats[0]);\n         bodies += [body];\n-        for p: @ast::pat in a.pats {\n-            match +=\n-                [@{pats: [p],\n-                   bound: [],\n-                   data: @{body: body.llbb, guard: a.guard, id_map: id_map}}];\n+        for p in a.pats {\n+            match += [@{pats: [p],\n+                        bound: [],\n+                        data: @{body: body.llbb, guard: a.guard,\n+                                id_map: id_map}}];\n         }\n     }\n \n     // Cached fail-on-fallthrough block\n     let fail_cx = @mutable none;\n-    fn mk_fail(cx: @block_ctxt, sp: span,\n+    fn mk_fail(bcx: block, sp: span,\n                done: @mutable option<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n-        let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n-        base::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n+        let fail_cx = sub_block(bcx, \"case_fallthrough\");\n+        trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");;\n         *done = some(fail_cx.llbb);\n         ret fail_cx.llbb;\n     }\n \n     let exit_map = [];\n-    let t = node_id_type(cx, expr.id);\n-    let vr = base::spill_if_immediate(er.bcx, er.val, t);\n-    compile_submatch(vr.bcx, match, [vr.val],\n-                     bind mk_fail(alt_cx, expr.span, fail_cx), exit_map);\n+    let t = node_id_type(bcx, expr.id);\n+    let {bcx, val: spilled} = spill_if_immediate(bcx, val, t);\n+    compile_submatch(bcx, match, [spilled],\n+                     bind mk_fail(scope_cx, expr.span, fail_cx), exit_map);\n \n     let arm_cxs = [], arm_dests = [], i = 0u;\n-    for a: ast::arm in arms {\n+    for a in arms {\n         let body_cx = bodies[i];\n         if make_phi_bindings(body_cx, exit_map,\n-                             pat_util::pat_id_map(bcx_tcx(cx),\n-                                                  a.pats[0])) {\n-            let arm_dest = base::dup_for_join(dest);\n+                             pat_util::pat_id_map(tcx, a.pats[0])) {\n+            let arm_dest = dup_for_join(dest);\n             arm_dests += [arm_dest];\n-            let arm_cx = base::trans_block(body_cx, a.body, arm_dest);\n-            arm_cx = base::trans_block_cleanups(arm_cx, body_cx);\n+            let arm_cx = trans_block(body_cx, a.body, arm_dest);\n+            arm_cx = trans_block_cleanups(arm_cx, body_cx);\n             arm_cxs += [arm_cx];\n         }\n         i += 1u;\n     }\n-    let after_cx = base::join_returns(alt_cx, arm_cxs, arm_dests, dest);\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    if after_cx.unreachable { Unreachable(next_cx); }\n-    base::cleanup_and_Br(after_cx, alt_cx, next_cx.llbb);\n-    ret next_cx;\n+    join_returns(scope_cx, arm_cxs, arm_dests, dest)\n }\n \n // Not alt-related, but similar to the pattern-munging code above\n-fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n-                        make_copy: bool) -> @block_ctxt {\n+fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n+                        make_copy: bool) -> block {\n     let ccx = bcx.fcx.ccx, bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n@@ -717,10 +697,10 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // FIXME: Could constrain pat_bind to make this\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n-            let llty = base::type_of(ccx, ty);\n-            let alloc = base::alloca(bcx, llty);\n-            bcx = base::copy_val(bcx, base::INIT, alloc,\n-                                  base::load_if_immediate(bcx, val, ty), ty);\n+            let llty = type_of(ccx, ty);\n+            let alloc = alloca(bcx, llty);\n+            bcx = copy_val(bcx, INIT, alloc,\n+                                  load_if_immediate(bcx, val, ty), ty);\n             bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n             add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n@@ -745,15 +725,15 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n-            let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n+            let r = GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n         let tup_ty = node_id_type(bcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n-            let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n+            let r = GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(r.bcx, elem, r.val, make_copy);\n             i += 1u;\n         }"}, {"sha": "a99c70b1519e744656f304c268d2cc67a8fac3fd", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 435, "deletions": 498, "changes": 933, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -275,7 +275,7 @@ fn get_extern_const(externs: hashmap<str, ValueRef>, llmod: ModuleRef,\n     ret c;\n }\n \n-fn get_simple_extern_fn(cx: @block_ctxt,\n+fn get_simple_extern_fn(cx: block,\n                         externs: hashmap<str, ValueRef>,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n@@ -286,7 +286,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n     ret get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n-fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n+fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n                      llmod: ModuleRef, name: str, args: [ValueRef]) ->\n    ValueRef {\n     let n = args.len() as int;\n@@ -299,37 +299,37 @@ fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n     ret Call(cx, llnative, call_args);\n }\n \n-fn trans_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n+fn trans_free(cx: block, v: ValueRef) -> block {\n     Call(cx, bcx_ccx(cx).upcalls.free, [PointerCast(cx, v, T_ptr(T_i8()))]);\n     cx\n }\n \n-fn trans_shared_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n+fn trans_shared_free(cx: block, v: ValueRef) -> block {\n     Call(cx, bcx_ccx(cx).upcalls.shared_free,\n          [PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n }\n \n-fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     ret Select(cx, cond, b, a);\n }\n \n-fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     ret Select(cx, cond, a, b);\n }\n \n-fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n+fn alloca(cx: block, t: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n-    ret Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n+    ret Alloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t);\n }\n \n-fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n+fn dynastack_alloca(cx: block, t: TypeRef, n: ValueRef, ty: ty::t) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(t)); }\n     let bcx = cx;\n-    let dy_cx = new_raw_block_ctxt(cx.fcx, cx.fcx.lldynamicallocas);\n+    let dy_cx = raw_block(cx.fcx, cx.fcx.lldynamicallocas);\n     alt bcx_fcx(cx).llobstacktoken {\n       none {\n         bcx_fcx(cx).llobstacktoken =\n@@ -351,21 +351,21 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n \n fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n    ValueRef {\n-    let cx = new_raw_block_ctxt(fcx, fcx.lldynamicallocas);\n+    let cx = raw_block(fcx, fcx.lldynamicallocas);\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n }\n \n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n-fn ptr_offs(bcx: @block_ctxt, base: ValueRef, sz: ValueRef) -> ValueRef {\n+fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     GEP(bcx, raw, [sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n-fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n+fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let ccx = bcx_ccx(bcx);\n     let bumped = ptr_offs(bcx, base, sz);\n@@ -380,13 +380,13 @@ fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n-fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n+fn GEP_tup_like(bcx: block, t: ty::t, base: ValueRef, ixs: [int])\n     -> result {\n-    fn compute_off(bcx: @block_ctxt,\n+    fn compute_off(bcx: block,\n                    off: ValueRef,\n                    t: ty::t,\n                    ixs: [int],\n-                   n: uint) -> (@block_ctxt, ValueRef, ty::t) {\n+                   n: uint) -> (block, ValueRef, ty::t) {\n         if n == ixs.len() {\n             ret (bcx, off, t);\n         }\n@@ -436,7 +436,7 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n // This function uses GEP_tup_like() above and automatically performs casts as\n // appropriate. @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n-fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n+fn GEP_enum(cx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n            variant_id: ast::def_id, ty_substs: [ty::t],\n            ix: uint) : valid_variant_index(ix, cx, enum_id, variant_id) ->\n    result {\n@@ -487,7 +487,7 @@ fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n \n // trans_shared_malloc: expects a type indicating which pointer type we want\n // and a size indicating how much space we want malloc'd.\n-fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n+fn trans_shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n    -> result {\n     // FIXME: need a table to collect tydesc globals.\n \n@@ -503,7 +503,7 @@ fn trans_shared_malloc(cx: @block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-fn opaque_box_body(bcx: @block_ctxt,\n+fn opaque_box_body(bcx: block,\n                       body_t: ty::t,\n                       boxptr: ValueRef) -> ValueRef {\n     let ccx = bcx_ccx(bcx);\n@@ -519,7 +519,7 @@ fn opaque_box_body(bcx: @block_ctxt,\n // trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn trans_malloc_boxed_raw(bcx: @block_ctxt, t: ty::t,\n+fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n                           &static_ti: option<@tydesc_info>) -> result {\n     let bcx = bcx, ccx = bcx_ccx(bcx);\n \n@@ -540,8 +540,8 @@ fn trans_malloc_boxed_raw(bcx: @block_ctxt, t: ty::t,\n \n // trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n // initializes the reference count to 1, and pulls out the body and rc\n-fn trans_malloc_boxed(bcx: @block_ctxt, t: ty::t) ->\n-   {bcx: @block_ctxt, box: ValueRef, body: ValueRef} {\n+fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n+   {bcx: block, box: ValueRef, body: ValueRef} {\n     let ti = none;\n     let {bcx, val:box} = trans_malloc_boxed_raw(bcx, t, ti);\n     let body = GEPi(bcx, box, [0, abi::box_field_body]);\n@@ -553,7 +553,7 @@ fn trans_malloc_boxed(bcx: @block_ctxt, t: ty::t) ->\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n+fn field_of_tydesc(cx: block, t: ty::t, escapes: bool, field: int) ->\n    result {\n     let tydesc = get_tydesc_simple(cx, t, escapes);\n     ret rslt(tydesc.bcx,\n@@ -564,7 +564,7 @@ fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n+fn linearize_ty_params(cx: block, t: ty::t) ->\n    {params: [uint], descs: [ValueRef]} {\n     let param_vals = [], param_defs = [];\n     ty::walk_ty(bcx_tcx(cx), t) {|t|\n@@ -581,7 +581,7 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n     ret {params: param_defs, descs: param_vals};\n }\n \n-fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n+fn trans_stack_local_derived_tydesc(cx: block, llsz: ValueRef,\n                                     llalign: ValueRef, llroottydesc: ValueRef,\n                                     llfirstparam: ValueRef, n_params: uint)\n     -> ValueRef {\n@@ -607,7 +607,7 @@ fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n     ret llmyroottydesc;\n }\n \n-fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n+fn get_derived_tydesc(cx: block, t: ty::t, escapes: bool,\n                       &static_ti: option<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n@@ -621,7 +621,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     }\n \n     bcx_ccx(cx).stats.n_derived_tydescs += 1u;\n-    let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n+    let bcx = raw_block(cx.fcx, cx.fcx.llderivedtydescs);\n     let tys = linearize_ty_params(bcx, t);\n     let root_ti = get_static_tydesc(bcx_ccx(bcx), t, tys.params);\n     static_ti = some(root_ti);\n@@ -681,7 +681,7 @@ fn get_tydesc_simple(bcx: block, t: ty::t, escapes: bool) -> result {\n     get_tydesc(bcx, t, escapes, ti)\n }\n \n-fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n+fn get_tydesc(cx: block, t: ty::t, escapes: bool,\n               &static_ti: option<@tydesc_info>) -> result {\n \n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n@@ -780,7 +780,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n     ret info;\n }\n \n-type glue_helper = fn@(@block_ctxt, ValueRef, ty::t);\n+type glue_helper = fn@(block, ValueRef, ty::t);\n \n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: str) -> ValueRef {\n@@ -813,7 +813,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n \n     let ty_param_count = ty_params.len();\n     let lltyparams = llvm::LLVMGetParam(llfn, 2u as c_uint);\n-    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+    let load_env_bcx = raw_block(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n     let p = 0u;\n     while p < ty_param_count {\n@@ -825,7 +825,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n \n     fcx.lltyparams = vec::map_mut(lltydescs, {|d| {desc: d, dicts: none}});\n \n-    let bcx = new_top_block_ctxt(fcx, none);\n+    let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n     let llval0 = BitCast(bcx, llrawptr0, llty);\n@@ -899,7 +899,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n     };\n }\n \n-fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n+fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n     let bcx = cx;\n     // NB: v is a *pointer* to type t here, not a direct value.\n     bcx = alt ty::get(t).struct {\n@@ -943,7 +943,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n+fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) -> block {\n     let ccx = bcx_ccx(cx);\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n@@ -953,7 +953,7 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n-fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n+fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n     // everything to a pointer to the type that the glue acts on).\n@@ -999,7 +999,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n+fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(bcx);\n     let bcx = alt ty::get(t).struct {\n@@ -1032,47 +1032,40 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n-                  inner_t: ty::t, tps: [ty::t]) -> @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n+fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n+                  inner_t: ty::t, tps: [ty::t]) -> block {\n+    let ccx = bcx_ccx(bcx);\n     let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n     let tup_ty = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n-    let drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n-\n-    let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n-    let cx = drop_flag.bcx;\n-    let null_test = IsNull(cx, Load(cx, drop_flag.val));\n-    CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n-    cx = drop_cx;\n-\n-    let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n-    cx = val.bcx;\n-    // Find and call the actual destructor.\n-    let dtor_addr = common::get_res_dtor(ccx, did, inner_t);\n-    let args = [cx.fcx.llretptr, null_env_ptr(cx)];\n-    for tp: ty::t in tps {\n-        let td = get_tydesc_simple(cx, tp, false);\n-        args += [td.val];\n-        cx = td.bcx;\n-    }\n-    // Kludge to work around the fact that we know the precise type of the\n-    // value here, but the dtor expects a type that still has opaque pointers\n-    // for type variables.\n-    let val_llty = lib::llvm::fn_ty_param_tys\n-        (llvm::LLVMGetElementType\n-         (llvm::LLVMTypeOf(dtor_addr)))[args.len()];\n-    let val_cast = BitCast(cx, val.val, val_llty);\n-    Call(cx, dtor_addr, args + [val_cast]);\n-\n-    cx = drop_ty(cx, val.val, inner_t_s);\n-    // FIXME #1184: Resource flag is larger than necessary\n-    Store(cx, C_int(ccx, 0), drop_flag.val);\n-    Br(cx, next_cx.llbb);\n-    ret next_cx;\n+\n+    let {bcx, val: drop_flag} = GEP_tup_like(bcx, tup_ty, rs, [0, 0]);\n+    with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n+        let {bcx, val: valptr} = GEP_tup_like(bcx, tup_ty, rs, [0, 1]);\n+        // Find and call the actual destructor.\n+        let dtor_addr = common::get_res_dtor(ccx, did, inner_t);\n+        let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n+        for tp in tps {\n+            let td = get_tydesc_simple(bcx, tp, false);\n+            args += [td.val];\n+            bcx = td.bcx;\n+        }\n+        // Kludge to work around the fact that we know the precise type of the\n+        // value here, but the dtor expects a type that still has opaque\n+        // pointers for type variables.\n+        let val_llty = lib::llvm::fn_ty_param_tys\n+            (llvm::LLVMGetElementType\n+             (llvm::LLVMTypeOf(dtor_addr)))[args.len()];\n+        let val_cast = BitCast(bcx, valptr, val_llty);\n+        Call(bcx, dtor_addr, args + [val_cast]);\n+\n+        bcx = drop_ty(bcx, valptr, inner_t_s);\n+        // FIXME #1184: Resource flag is larger than necessary\n+        Store(bcx, C_int(ccx, 0), drop_flag);\n+        bcx\n+    }\n }\n \n-fn maybe_validate_box(_cx: @block_ctxt, _box_ptr: ValueRef) {\n+fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n     // Uncomment this when debugging annoying use-after-free\n     // bugs.  But do not commit with this uncommented!  Big performance hit.\n \n@@ -1083,28 +1076,19 @@ fn maybe_validate_box(_cx: @block_ctxt, _box_ptr: ValueRef) {\n     // Call(cx, ccx.upcalls.validate_box, [raw_box_ptr]);\n }\n \n-fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n-    -> @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n-\n-    maybe_validate_box(cx, box_ptr);\n+fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n+    let ccx = bcx_ccx(bcx);\n+    maybe_validate_box(bcx, box_ptr);\n \n-    let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n-    let free_cx = new_sub_block_ctxt(cx, \"free\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let llbox_ty = T_opaque_box_ptr(ccx);\n-    let box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n-    let null_test = IsNull(cx, box_ptr);\n-    CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n-    let rc_ptr = GEPi(rc_adj_cx, box_ptr, [0, abi::box_field_refcnt]);\n-    let rc = Load(rc_adj_cx, rc_ptr);\n-    rc = Sub(rc_adj_cx, rc, C_int(ccx, 1));\n-    Store(rc_adj_cx, rc, rc_ptr);\n-    let zero_test = ICmp(rc_adj_cx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-    CondBr(rc_adj_cx, zero_test, free_cx.llbb, next_cx.llbb);\n-    let free_cx = free_ty(free_cx, box_ptr, t);\n-    Br(free_cx, next_cx.llbb);\n-    ret next_cx;\n+    let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n+    with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n+        let rc_ptr = GEPi(bcx, box_ptr, [0, abi::box_field_refcnt]);\n+        let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n+        Store(bcx, rc, rc_ptr);\n+        let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n+        with_cond(bcx, zero_test) {|bcx| free_ty(bcx, box_ptr, t)}\n+    }\n }\n \n // Structural comparison: a rather involved form of glue.\n@@ -1119,7 +1103,7 @@ fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n \n-fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n+fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> result {\n     let f = bind compare_scalar_values(cx, lhs, rhs, _, op);\n \n@@ -1144,9 +1128,9 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n \n \n // A helper function to do the actual comparison of scalar values.\n-fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n+fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n-    fn die_(cx: @block_ctxt) -> ! {\n+    fn die_(cx: block) -> ! {\n         bcx_tcx(cx).sess.bug(\"compare_scalar_values: must be a\\\n           comparison operator\");\n     }\n@@ -1201,38 +1185,24 @@ fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     }\n }\n \n-type val_pair_fn = fn@(@block_ctxt, ValueRef, ValueRef) -> @block_ctxt;\n-type val_and_ty_fn = fn@(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n+type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n+type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n-fn load_inbounds(cx: @block_ctxt, p: ValueRef, idxs: [int]) -> ValueRef {\n+fn load_inbounds(cx: block, p: ValueRef, idxs: [int]) -> ValueRef {\n     ret Load(cx, GEPi(cx, p, idxs));\n }\n \n-fn store_inbounds(cx: @block_ctxt, v: ValueRef, p: ValueRef,\n+fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n                   idxs: [int]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n-                      f: val_and_ty_fn) -> @block_ctxt {\n-    fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: val_and_ty_fn) ->\n-       @block_ctxt {\n-        let box_ptr = Load(cx, box_cell);\n-        let tnil = ty::mk_nil(bcx_tcx(cx));\n-        let tbox = ty::mk_imm_box(bcx_tcx(cx), tnil);\n-        let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let null_test = IsNull(cx, box_ptr);\n-        CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        let inner_cx = f(inner_cx, box_cell, tbox);\n-        Br(inner_cx, next_cx.llbb);\n-        ret next_cx;\n-    }\n-\n-    fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n+fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n+                      f: val_and_ty_fn) -> block {\n+    fn iter_variant(cx: block, a_tup: ValueRef,\n                     variant: ty::variant_info, tps: [ty::t], tid: ast::def_id,\n-                    f: val_and_ty_fn) -> @block_ctxt {\n+                    f: val_and_ty_fn) -> block {\n         if variant.args.len() == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n@@ -1305,13 +1275,13 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n         cx = f(cx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx)));\n-        let unr_cx = new_sub_block_ctxt(cx, \"enum-iter-unr\");\n+        let unr_cx = sub_block(cx, \"enum-iter-unr\");\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = new_sub_block_ctxt(cx, \"enum-iter-next\");\n+        let next_cx = sub_block(cx, \"enum-iter-next\");\n         for variant: ty::variant_info in *variants {\n             let variant_cx =\n-                new_sub_block_ctxt(cx,\n+                sub_block(cx,\n                                    \"enum-iter-variant-\" +\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n@@ -1398,7 +1368,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n     }\n }\n \n-fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n+fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: int, static_ti: option<@tydesc_info>) {\n     lazily_emit_tydesc_glue(bcx_ccx(cx), field, static_ti);\n \n@@ -1434,15 +1404,15 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n                     lltydescs, llrawptr]);\n }\n \n-fn call_tydesc_glue(cx: @block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n-   @block_ctxt {\n+fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n+   block {\n     let ti: option<@tydesc_info> = none::<@tydesc_info>;\n     let {bcx: bcx, val: td} = get_tydesc(cx, t, false, ti);\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n     ret bcx;\n }\n \n-fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n+fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n                  llop: ValueRef) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n@@ -1473,21 +1443,21 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     ret rslt(bcx, Load(bcx, llcmpresultptr));\n }\n \n-fn take_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     if ty::type_needs_drop(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n     ret cx;\n }\n \n-fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     if ty::type_needs_drop(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     ret cx;\n }\n \n-fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     alt ty::get(t).struct {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n       ty::ty_box(_) | ty::ty_opaque_box {\n@@ -1498,7 +1468,7 @@ fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     }\n }\n \n-fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n@@ -1511,14 +1481,14 @@ fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     }\n }\n \n-fn free_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     if ty::type_needs_drop(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     ret cx;\n }\n \n-fn call_memmove(cx: @block_ctxt, dst: ValueRef, src: ValueRef,\n+fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n                 n_bytes: ValueRef) -> result {\n     // TODO: Provide LLVM with better alignment information when the alignment\n     // is statically known (it must be nothing more than a constant int, or\n@@ -1543,8 +1513,8 @@ fn call_memmove(cx: @block_ctxt, dst: ValueRef, src: ValueRef,\n     ret rslt(cx, ret_val);\n }\n \n-fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n-    @block_ctxt {\n+fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) ->\n+    block {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         if ty::type_is_structural(t) {\n@@ -1570,27 +1540,24 @@ fn type_is_structural_or_param(t: ty::t) -> bool {\n     }\n }\n \n-fn copy_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-            src: ValueRef, t: ty::t) -> @block_ctxt {\n+fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n+            src: ValueRef, t: ty::t) -> block {\n     if action == DROP_EXISTING &&\n         (type_is_structural_or_param(t) ||\n          ty::type_is_unique(t)) {\n-        let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n         let dstcmp = load_if_immediate(cx, dst, t);\n-        let self_assigning =\n-            ICmp(cx, lib::llvm::IntNE,\n-                 PointerCast(cx, dstcmp, val_ty(src)), src);\n-        CondBr(cx, self_assigning, do_copy_cx.llbb, next_cx.llbb);\n-        do_copy_cx = copy_val_no_check(do_copy_cx, action, dst, src, t);\n-        Br(do_copy_cx, next_cx.llbb);\n-        ret next_cx;\n+        let cast = PointerCast(cx, dstcmp, val_ty(src));\n+        // Self-copy check\n+        with_cond(cx, ICmp(cx, lib::llvm::IntNE, cast, src)) {|bcx|\n+            copy_val_no_check(bcx, action, dst, src, t)\n+        }\n+    } else {\n+        copy_val_no_check(cx, action, dst, src, t)\n     }\n-    ret copy_val_no_check(cx, action, dst, src, t);\n }\n \n-fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n-                     src: ValueRef, t: ty::t) -> @block_ctxt {\n+fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n+                     src: ValueRef, t: ty::t) -> block {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     if ty::type_is_scalar(t) {\n         Store(bcx, src, dst);\n@@ -1618,8 +1585,8 @@ fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n // FIXME: We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n // doesn't need to be dropped.\n-fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-            src: lval_result, t: ty::t) -> @block_ctxt {\n+fn move_val(cx: block, action: copy_action, dst: ValueRef,\n+            src: lval_result, t: ty::t) -> block {\n     let src_val = src.val;\n     let tcx = bcx_tcx(cx), cx = cx;\n     if ty::type_is_scalar(t) {\n@@ -1649,9 +1616,9 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                              ty_to_str(tcx, t));\n }\n \n-fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n+fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n                    src: lval_result, t: ty::t, last_use: bool)\n-    -> @block_ctxt {\n+    -> block {\n     // Lvals in memory are not temporaries. Copy them.\n     if src.kind != temporary && !last_use {\n         let v = if src.kind == owned {\n@@ -1677,7 +1644,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     }\n }\n \n-fn trans_lit(cx: @block_ctxt, lit: ast::lit, dest: dest) -> @block_ctxt {\n+fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n     if dest == ignore { ret cx; }\n     alt lit.node {\n       ast::lit_str(s) { ret tvec::trans_str(cx, s, dest); }\n@@ -1687,8 +1654,8 @@ fn trans_lit(cx: @block_ctxt, lit: ast::lit, dest: dest) -> @block_ctxt {\n     }\n }\n \n-fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n-               un_expr: @ast::expr, dest: dest) -> @block_ctxt {\n+fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n+               un_expr: @ast::expr, dest: dest) -> block {\n     // Check for user-defined method call\n     alt bcx_ccx(bcx).method_map.find(un_expr.id) {\n       some(origin) {\n@@ -1741,7 +1708,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     }\n }\n \n-fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n+fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n@@ -1774,9 +1741,9 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n+fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n-    -> @block_ctxt {\n+    -> block {\n     if dest == ignore { ret cx; }\n     let intype = lhs_t;\n     if ty::type_is_bot(intype) { intype = rhs_t; }\n@@ -1825,8 +1792,8 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     ret store_in_dest(cx, val, dest);\n }\n \n-fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n-                   dst: @ast::expr, src: @ast::expr) -> @block_ctxt {\n+fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n+                   dst: @ast::expr, src: @ast::expr) -> block {\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == owned);\n@@ -1870,7 +1837,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n                           save_in(lhs_res.val));\n }\n \n-fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n+fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n     let ccx = bcx_ccx(cx);\n@@ -1919,41 +1886,31 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n // refinement types would obviate the need for this\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n-fn trans_lazy_binop(bcx: @block_ctxt, op: lazy_binop_ty, a: @ast::expr,\n-                    b: @ast::expr, dest: dest) -> @block_ctxt {\n-    let is_and = alt op { lazy_and { true } lazy_or { false } };\n-    let lhs_res = trans_temp_expr(bcx, a);\n-    if lhs_res.bcx.unreachable { ret lhs_res.bcx; }\n-    let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n-    let rhs_res = trans_temp_expr(rhs_cx, b);\n-\n-    let lhs_past_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs\");\n-    // The following line ensures that any cleanups for rhs\n-    // are done within the block for rhs. This is necessary\n-    // because and/or are lazy. So the rhs may never execute,\n-    // and the cleanups can't be pushed into later code.\n-    let rhs_bcx = trans_block_cleanups(rhs_res.bcx, rhs_cx);\n-    if is_and {\n-        CondBr(lhs_res.bcx, lhs_res.val, rhs_cx.llbb, lhs_past_cx.llbb);\n-    } else {\n-        CondBr(lhs_res.bcx, lhs_res.val, lhs_past_cx.llbb, rhs_cx.llbb);\n-    }\n+fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n+                    b: @ast::expr, dest: dest) -> block {\n+\n+    let {bcx: past_lhs, val: lhs} = with_scope_result(bcx, \"lhs\")\n+        {|bcx| trans_temp_expr(bcx, a)};\n+    if past_lhs.unreachable { ret past_lhs; }\n+    let join = sub_block(bcx, \"join\"), before_rhs = sub_block(bcx, \"rhs\");\n \n-    let join_cx = new_sub_block_ctxt(bcx, \"join\");\n-    Br(lhs_past_cx, join_cx.llbb);\n-    if rhs_bcx.unreachable {\n-        ret store_in_dest(join_cx, C_bool(!is_and), dest);\n+    alt op {\n+      lazy_and { CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb); }\n+      lazy_or { CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb); }\n     }\n-    Br(rhs_bcx, join_cx.llbb);\n-    let phi = Phi(join_cx, T_bool(), [C_bool(!is_and), rhs_res.val],\n-                  [lhs_past_cx.llbb, rhs_bcx.llbb]);\n-    ret store_in_dest(join_cx, phi, dest);\n+    let {bcx: past_rhs, val: rhs} = with_scope_result(before_rhs, \"rhs\")\n+        {|bcx| trans_temp_expr(bcx, b)};\n+\n+    if past_rhs.unreachable { ret store_in_dest(join, lhs, dest); }\n+    Br(past_rhs, join.llbb);\n+    let phi = Phi(join, T_bool(), [lhs, rhs], [past_lhs.llbb, past_rhs.llbb]);\n+    ret store_in_dest(join, phi, dest);\n }\n \n \n \n-fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n-                rhs: @ast::expr, dest: dest, ex: @ast::expr) -> @block_ctxt {\n+fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n+                rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n     // User-defined operators\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n@@ -2002,9 +1959,9 @@ fn dup_for_join(dest: dest) -> dest {\n     }\n }\n \n-fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n-                in_ds: [dest], out_dest: dest) -> @block_ctxt {\n-    let out = new_sub_block_ctxt(parent_cx, \"join\");\n+fn join_returns(parent_cx: block, in_cxs: [block],\n+                in_ds: [dest], out_dest: dest) -> block {\n+    let out = sub_block(parent_cx, \"join\");\n     let reachable = false, i = 0u, phi = none;\n     for cx in in_cxs {\n         if !cx.unreachable {\n@@ -2034,7 +1991,7 @@ fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n }\n \n // Used to put an immediate value in a dest.\n-fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n+fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n     alt dest {\n       ignore {}\n       by_val(cell) { *cell = val; }\n@@ -2051,18 +2008,17 @@ fn get_dest_addr(dest: dest) -> ValueRef {\n     }\n }\n \n-fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n+fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             els: option<@ast::expr>, dest: dest)\n-    -> @block_ctxt {\n+    -> block {\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n     let then_dest = dup_for_join(dest);\n     let else_dest = dup_for_join(dest);\n-    let then_cx = new_real_block_ctxt(bcx, \"then\", thn.span);\n-    let else_cx = new_real_block_ctxt(bcx, \"else\", alt els {\n-        some(e) { e.span }\n-        _ { ast_util::dummy_sp() }\n-    });\n+    let then_cx = scope_block(bcx, \"then\");\n+    then_cx.block_span = some(thn.span);\n+    let else_cx = scope_block(bcx, \"else\");\n+    option::may(els) {|e| else_cx.block_span = some(e.span); }\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     let then_bcx = trans_block(then_cx, thn, then_dest);\n     then_bcx = trans_block_cleanups(then_bcx, then_cx);\n@@ -2090,15 +2046,14 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n     ret join_returns(cx, [then_bcx, else_bcx], [then_dest, else_dest], dest);\n }\n \n-fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n-             body: ast::blk) -> @block_ctxt {\n-    fn inner(bcx: @block_ctxt, local: @ast::local, curr: ValueRef, t: ty::t,\n-             body: ast::blk, outer_next_cx: @block_ctxt) -> @block_ctxt {\n-        let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-        let scope_cx =\n-            new_loop_scope_block_ctxt(bcx, cont_other(next_cx),\n-                                      outer_next_cx, \"for loop scope\",\n-                                      body.span);\n+fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n+             body: ast::blk) -> block {\n+    fn inner(bcx: block, local: @ast::local, curr: ValueRef, t: ty::t,\n+             body: ast::blk, outer_next_cx: block) -> block {\n+        let next_cx = sub_block(bcx, \"next\");\n+        let scope_cx = loop_scope_block(bcx, cont_other(next_cx),\n+                                        outer_next_cx, \"for loop scope\",\n+                                        body.span);\n         Br(bcx, scope_cx.llbb);\n         let curr = PointerCast(bcx, curr,\n                                T_ptr(type_of_or_i8(bcx_ccx(bcx), t)));\n@@ -2109,7 +2064,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         ret next_cx;\n     }\n     let ccx = bcx_ccx(cx);\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    let next_cx = sub_block(cx, \"next\");\n     let seq_ty = expr_ty(cx, seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n     let seq = PointerCast(bcx, seq, T_ptr(ccx.opaque_vec_type));\n@@ -2123,12 +2078,12 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     ret next_cx;\n }\n \n-fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n-    -> @block_ctxt {\n-    let next_cx = new_sub_block_ctxt(cx, \"while next\");\n-    let cond_cx = new_loop_scope_block_ctxt(cx, cont_self, next_cx,\n+fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n+    -> block {\n+    let next_cx = sub_block(cx, \"while next\");\n+    let cond_cx = loop_scope_block(cx, cont_self, next_cx,\n                                             \"while cond\", body.span);\n-    let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n+    let body_cx = scope_block(cond_cx, \"while loop body\");\n     Br(cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n@@ -2138,14 +2093,14 @@ fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     ret next_cx;\n }\n \n-fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n-    @block_ctxt {\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+fn trans_do_while(cx: block, body: ast::blk, cond: @ast::expr) ->\n+    block {\n+    let next_cx = sub_block(cx, \"next\");\n     let body_cx =\n-        new_loop_scope_block_ctxt(cx, cont_self, next_cx,\n+        loop_scope_block(cx, cont_self, next_cx,\n                                   \"do-while loop body\", body.span);\n     let body_end = trans_block(body_cx, body, ignore);\n-    let cond_cx = new_scope_block_ctxt(body_cx, \"do-while cond\");\n+    let cond_cx = scope_block(body_cx, \"do-while cond\");\n     cleanup_and_Br(body_end, body_cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n@@ -2172,41 +2127,41 @@ enum lval_kind {\n     owned_imm, //< Non-temporary value passed by value\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n-type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n+type lval_result = {bcx: block, val: ValueRef, kind: lval_kind};\n enum callee_env {\n     null_env,\n     is_closure,\n     self_env(ValueRef, ty::t),\n     dict_env(ValueRef, ValueRef),\n }\n-type lval_maybe_callee = {bcx: @block_ctxt,\n+type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n                           kind: lval_kind,\n                           env: callee_env,\n                           generic: generic_callee};\n \n-fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n+fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx_ccx(bcx)))\n }\n \n-fn lval_from_local_var(bcx: @block_ctxt, r: local_var_result) -> lval_result {\n+fn lval_from_local_var(bcx: block, r: local_var_result) -> lval_result {\n     ret { bcx: bcx, val: r.val, kind: r.kind };\n }\n \n-fn lval_owned(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+fn lval_owned(bcx: block, val: ValueRef) -> lval_result {\n     ret {bcx: bcx, val: val, kind: owned};\n }\n-fn lval_temp(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n     ret {bcx: bcx, val: val, kind: temporary};\n }\n \n-fn lval_no_env(bcx: @block_ctxt, val: ValueRef, kind: lval_kind)\n+fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n     ret {bcx: bcx, val: val, kind: kind, env: is_closure,\n          generic: generic_none};\n }\n \n-fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n+fn trans_external_path(cx: block, did: ast::def_id,\n                        tpt: ty::ty_param_bounds_and_ty) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n@@ -2277,7 +2232,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     some({llfn: lldecl, fty: mono_ty})\n }\n \n-fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id,\n+fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(bcx);\n@@ -2376,7 +2331,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     }\n }\n \n-fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n+fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         alt table.find(id) {\n@@ -2410,12 +2365,12 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n     }\n }\n \n-fn trans_path(cx: @block_ctxt, id: ast::node_id)\n+fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n     ret trans_var(cx, bcx_tcx(cx).def_map.get(id), id);\n }\n \n-fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n+fn trans_var(cx: block, def: ast::def, id: ast::node_id)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(cx);\n     alt def {\n@@ -2458,7 +2413,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n     }\n }\n \n-fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n+fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n@@ -2473,7 +2428,7 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n-fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n+fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n@@ -2501,33 +2456,28 @@ fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n     maybe_name_value(bcx_ccx(cx), scaled_ix, \"scaled_ix\");\n     let lim = tvec::get_fill(bcx, v);\n     let body = tvec::get_dataptr(bcx, v, type_of_or_i8(ccx, unit_ty));\n-    let bounds_check = ICmp(bcx, lib::llvm::IntULT, scaled_ix, lim);\n-    let fail_cx = new_sub_block_ctxt(bcx, \"fail\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    let ncx = bcx_ccx(next_cx);\n-    CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n-    // fail: bad bounds check.\n-\n-    trans_fail(fail_cx, some(ex.span), \"bounds check\");\n-    let elt =\n-        if check type_has_static_size(ncx, unit_ty) {\n-            let elt_1 = GEP(next_cx, body, [ix_val]);\n-            let llunitty = type_of(ncx, unit_ty);\n-            PointerCast(next_cx, elt_1, T_ptr(llunitty))\n-        } else {\n-            body = PointerCast(next_cx, body, T_ptr(T_i8()));\n-            GEP(next_cx, body, [scaled_ix])\n-        };\n-\n-    ret lval_owned(next_cx, elt);\n+    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n+    bcx = with_cond(bcx, bounds_check) {|bcx|\n+        // fail: bad bounds check.\n+        trans_fail(bcx, some(ex.span), \"bounds check\")\n+    };\n+    let elt = if check type_has_static_size(ccx, unit_ty) {\n+        let elt_1 = GEP(bcx, body, [ix_val]);\n+        let llunitty = type_of(ccx, unit_ty);\n+        PointerCast(bcx, elt_1, T_ptr(llunitty))\n+    } else {\n+        body = PointerCast(bcx, body, T_ptr(T_i8()));\n+        GEP(bcx, body, [scaled_ix])\n+    };\n+    ret lval_owned(bcx, elt);\n }\n \n-fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n+fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n     let ccx = bcx_ccx(bcx);\n     ty::expr_is_lval(ccx.method_map, e)\n }\n \n-fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n+fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n       ast::expr_path(_) { ret trans_path(bcx, e.id); }\n       ast::expr_field(base, ident, _) {\n@@ -2553,7 +2503,7 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n-fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n+fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n     alt e.node {\n       ast::expr_path(_) {\n         let v = trans_path(cx, e.id);\n@@ -2621,7 +2571,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     }\n }\n \n-fn int_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n@@ -2634,7 +2584,7 @@ fn int_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n         } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n }\n \n-fn float_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n+fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n               llsrc: ValueRef) -> ValueRef {\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n@@ -2645,8 +2595,8 @@ fn float_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n         } else { llsrc };\n }\n \n-fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n-              dest: dest) -> @block_ctxt {\n+fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n+              dest: dest) -> block {\n     let ccx = bcx_ccx(cx);\n     let t_out = node_id_type(cx, id);\n     alt ty::get(t_out).struct {\n@@ -2718,7 +2668,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     ret store_in_dest(e_res.bcx, newval, dest);\n }\n \n-fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n+fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef,\n                   e: @ast::expr) -> result {\n     let ccx = bcx_ccx(cx);\n     let e_ty = expr_ty(cx, e);\n@@ -2786,10 +2736,10 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n+fn trans_args(cx: block, llenv: ValueRef,\n               gen: generic_callee, es: [@ast::expr], fn_ty: ty::t,\n               dest: dest)\n-   -> {bcx: @block_ctxt,\n+   -> {bcx: block,\n        args: [ValueRef],\n        retslot: ValueRef} {\n \n@@ -2883,118 +2833,110 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n          retslot: llretslot};\n }\n \n-fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n+fn trans_call(in_cx: block, f: @ast::expr,\n               args: [@ast::expr], id: ast::node_id, dest: dest)\n-    -> @block_ctxt {\n+    -> block {\n     trans_call_inner(in_cx, expr_ty(in_cx, f),\n                      {|cx| trans_callee(cx, f)}, args, id, dest)\n }\n \n-fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n-                    get_callee: fn(@block_ctxt) -> lval_maybe_callee,\n+fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n+                    get_callee: fn(block) -> lval_maybe_callee,\n                     args: [@ast::expr], id: ast::node_id, dest: dest)\n-    -> @block_ctxt {\n-    // NB: 'f' isn't necessarily a function; it might be an entire self-call\n-    // expression because of the hack that allows us to process self-calls\n-    // with trans_call.\n-    let cx = new_scope_block_ctxt(in_cx, \"call\");\n-    Br(in_cx, cx.llbb);\n-    let f_res = get_callee(cx);\n-    let bcx = f_res.bcx, ccx = bcx_ccx(cx);\n-\n-    let faddr = f_res.val;\n-    let llenv, dict_param = none;\n-    alt f_res.env {\n-      null_env {\n-        llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(ccx));\n-      }\n-      self_env(e, _) {\n-        llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n-      }\n-      dict_env(dict, e) {\n-        llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n-        dict_param = some(dict);\n-      }\n-      is_closure {\n-        // It's a closure. Have to fetch the elements\n-        if f_res.kind == owned {\n-            faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n-        }\n-        let pair = faddr;\n-        faddr = GEPi(bcx, pair, [0, abi::fn_field_code]);\n-        faddr = Load(bcx, faddr);\n-        let llclosure = GEPi(bcx, pair, [0, abi::fn_field_box]);\n-        llenv = Load(bcx, llclosure);\n-      }\n-    }\n-\n-    let ret_ty = node_id_type(bcx, id);\n-    let args_res =\n-        trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n-    bcx = args_res.bcx;\n-    let llargs = args_res.args;\n-    option::may(dict_param) {|dict| llargs = [dict] + llargs}\n-    let llretslot = args_res.retslot;\n-\n-    /* If the block is terminated,\n-       then one or more of the args has\n-       type _|_. Since that means it diverges, the code\n-       for the call itself is unreachable. */\n-    bcx = invoke_full(bcx, faddr, llargs);\n-    alt dest {\n-      ignore {\n-        if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-            bcx = drop_ty(bcx, llretslot, ret_ty);\n+    -> block {\n+    with_scope(in_cx, \"call\") {|cx|\n+        let f_res = get_callee(cx);\n+        let bcx = f_res.bcx, ccx = bcx_ccx(cx);\n+\n+        let faddr = f_res.val;\n+        let llenv, dict_param = none;\n+        alt f_res.env {\n+          null_env {\n+            llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(ccx));\n+          }\n+          self_env(e, _) {\n+            llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n+          }\n+          dict_env(dict, e) {\n+            llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n+            dict_param = some(dict);\n+          }\n+          is_closure {\n+            // It's a closure. Have to fetch the elements\n+            if f_res.kind == owned {\n+                faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n+            }\n+            let pair = faddr;\n+            faddr = GEPi(bcx, pair, [0, abi::fn_field_code]);\n+            faddr = Load(bcx, faddr);\n+            let llclosure = GEPi(bcx, pair, [0, abi::fn_field_box]);\n+            llenv = Load(bcx, llclosure);\n+          }\n         }\n-      }\n-      save_in(_) { } // Already saved by callee\n-      by_val(cell) {\n-        *cell = Load(bcx, llretslot);\n-      }\n-    }\n \n-    let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n-    if bcx.unreachable || ty::type_is_bot(ret_ty) {\n-        Unreachable(next_cx);\n+        let ret_ty = node_id_type(bcx, id);\n+        let args_res =\n+            trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n+        bcx = args_res.bcx;\n+        let llargs = args_res.args;\n+        option::may(dict_param) {|dict| llargs = [dict] + llargs}\n+        let llretslot = args_res.retslot;\n+\n+        /* If the block is terminated,\n+        then one or more of the args has\n+        type _|_. Since that means it diverges, the code\n+        for the call itself is unreachable. */\n+        bcx = invoke_full(bcx, faddr, llargs);\n+        alt dest {\n+          ignore {\n+            if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n+                bcx = drop_ty(bcx, llretslot, ret_ty);\n+            }\n+          }\n+          save_in(_) { } // Already saved by callee\n+          by_val(cell) {\n+            *cell = Load(bcx, llretslot);\n+          }\n+        }\n+        if ty::type_is_bot(ret_ty) { Unreachable(bcx); }\n+        bcx\n     }\n-    cleanup_and_Br(bcx, cx, next_cx.llbb);\n-    ret next_cx;\n }\n \n-fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n-          llargs: [ValueRef]) -> @block_ctxt {\n+fn invoke(bcx: block, llfn: ValueRef,\n+          llargs: [ValueRef]) -> block {\n     ret invoke_(bcx, llfn, llargs, Invoke);\n }\n \n-fn invoke_full(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef])\n-    -> @block_ctxt {\n+fn invoke_full(bcx: block, llfn: ValueRef, llargs: [ValueRef])\n+    -> block {\n     ret invoke_(bcx, llfn, llargs, Invoke);\n }\n \n-fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n-           invoker: fn(@block_ctxt, ValueRef, [ValueRef],\n-                       BasicBlockRef, BasicBlockRef)) -> @block_ctxt {\n+fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n+           invoker: fn(block, ValueRef, [ValueRef],\n+                       BasicBlockRef, BasicBlockRef)) -> block {\n     // FIXME: May be worth turning this into a plain call when there are no\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n-    let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n+    let normal_bcx = sub_block(bcx, \"normal return\");\n     invoker(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n     ret normal_bcx;\n }\n \n-fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n-    fn in_lpad_scope_cx(bcx: @block_ctxt, f: fn(scope_info)) {\n+fn get_landing_pad(bcx: block) -> BasicBlockRef {\n+    fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n         let bcx = bcx;\n         while true {\n             alt bcx.kind {\n-              scope_block(info) {\n+              block_scope(info) {\n                 if info.cleanups.len() > 0u || bcx.parent == parent_none {\n                     f(info); ret;\n                 }\n               }\n               _ {}\n             }\n-            bcx = alt check bcx.parent { parent_some(b) { b } };\n+            bcx = block_parent(bcx);\n         }\n     }\n \n@@ -3005,7 +2947,7 @@ fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n           some(target) { cached = some(target); ret; }\n           none {}\n         }\n-        pad_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n+        pad_bcx = sub_block(bcx, \"unwind\");\n         info.landing_pad = some(pad_bcx.llbb);\n     }\n     alt cached { some(b) { ret b; } none {} } // Can't return from block above\n@@ -3043,8 +2985,8 @@ fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n     ret pad_bcx.llbb;\n }\n \n-fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n-             dest: dest) -> @block_ctxt {\n+fn trans_tup(bcx: block, elts: [@ast::expr], id: ast::node_id,\n+             dest: dest) -> block {\n     let t = node_id_type(bcx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n@@ -3068,9 +3010,9 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n     ret bcx;\n }\n \n-fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n+fn trans_rec(bcx: block, fields: [ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n-             dest: dest) -> @block_ctxt {\n+             dest: dest) -> block {\n     let t = node_id_type(bcx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n@@ -3124,8 +3066,8 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n \n // Store the result of an expression in the given memory location, ensuring\n // that nil or bot expressions get ignore rather than save_in as destination.\n-fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n-    -> @block_ctxt {\n+fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n+    -> block {\n     let t = expr_ty(bcx, e);\n     let do_ignore = ty::type_is_bot(t) || ty::type_is_nil(t);\n     ret trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n@@ -3136,7 +3078,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n // field in the returned struct). For non-intermediates, use trans_expr or\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n-fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n+fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n     let bcx = bcx;\n     if expr_is_lval(bcx, e) {\n         ret trans_lval(bcx, e);\n@@ -3161,7 +3103,7 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n \n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n-fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n+fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n     let {bcx, val, kind} = trans_temp_lval(bcx, e);\n     if kind == owned {\n         val = load_if_immediate(bcx, val, expr_ty(bcx, e));\n@@ -3173,7 +3115,7 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // the result. Invariants:\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n-fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n+fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let tcx = bcx_tcx(bcx);\n     debuginfo::update_source_pos(bcx, e.span);\n \n@@ -3191,13 +3133,10 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n-        let sub_cx = new_real_block_ctxt(bcx, \"block-expr body\", blk.span);\n-        Br(bcx, sub_cx.llbb);\n-        let sub_bcx = trans_block(sub_cx, blk, dest);\n-        let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-        if sub_bcx.unreachable { Unreachable(next_cx); }\n-        cleanup_and_Br(sub_bcx, sub_cx, next_cx.llbb);\n-        ret next_cx;\n+        ret with_scope(bcx, \"block-expr body\") {|bcx|\n+            bcx.block_span = some(blk.span);\n+            trans_block(bcx, blk, dest)\n+        };\n       }\n       ast::expr_rec(args, base) {\n         ret trans_rec(bcx, args, base, e.id, dest);\n@@ -3305,18 +3244,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n            check the value of that variable, doing nothing\n            if it's set to false and acting like a check\n            otherwise. */\n-        let c =\n-            get_extern_const(bcx_ccx(bcx).externs, bcx_ccx(bcx).llmod,\n-                             \"check_claims\", T_bool());\n-        let cond = Load(bcx, c);\n-\n-        let then_cx = new_scope_block_ctxt(bcx, \"claim_then\");\n-        let check_cx = trans_check_expr(then_cx, a, \"Claim\");\n-        let next_cx = new_sub_block_ctxt(bcx, \"join\");\n-\n-        CondBr(bcx, cond, then_cx.llbb, next_cx.llbb);\n-        Br(check_cx, next_cx.llbb);\n-        ret next_cx;\n+        let c = get_extern_const(bcx_ccx(bcx).externs, bcx_ccx(bcx).llmod,\n+                                 \"check_claims\", T_bool());\n+        ret with_cond(bcx, Load(bcx, c)) {|bcx|\n+            trans_check_expr(bcx, a, \"Claim\")\n+        };\n       }\n       ast::expr_for(decl, seq, body) {\n         assert dest == ignore;\n@@ -3370,7 +3302,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     }\n }\n \n-fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n+fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let lv = trans_lval(bcx, e), ccx = bcx_ccx(bcx);\n     let {bcx, val, kind} = lv;\n     let last_use = kind == owned && ccx.last_uses.contains_key(e.id);\n@@ -3400,7 +3332,7 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn do_spill(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn do_spill(cx: block, v: ValueRef, t: ty::t) -> result {\n     // We have a value but we have to spill it, and root it, to pass by alias.\n     let bcx = cx;\n \n@@ -3419,30 +3351,30 @@ fn do_spill(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-fn do_spill_noroot(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n+fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     ret llptr;\n }\n \n-fn spill_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> result {\n     if ty::type_is_immediate(t) { ret do_spill(cx, v, t); }\n     ret rslt(cx, v);\n }\n \n-fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n+fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_immediate(t) { ret Load(cx, v); }\n     ret v;\n }\n \n-fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n-    if ty::type_is_bot(expr_ty(cx, lvl)) {\n-       ret trans_expr(cx, lvl, ignore);\n+fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n+    let ccx = bcx_ccx(bcx);\n+    if ty::type_is_bot(expr_ty(bcx, lvl)) {\n+       ret trans_expr(bcx, lvl, ignore);\n     }\n \n     let modpath = [path_mod(ccx.link_meta.name)] +\n-        vec::filter(cx.fcx.path, {|e|\n+        vec::filter(bcx.fcx.path, {|e|\n             alt e { path_mod(_) { true } _ { false } }\n         });\n     let modname = path_str(modpath);\n@@ -3461,51 +3393,37 @@ fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n         ccx.module_data.insert(modname, global);\n         global\n     };\n-    let level_cx = new_scope_block_ctxt(cx, \"level\");\n-    let log_cx = new_scope_block_ctxt(cx, \"log\");\n-    let after_cx = new_sub_block_ctxt(cx, \"after\");\n-    let load = Load(cx, global);\n-\n-    Br(cx, level_cx.llbb);\n-    let level_res = trans_temp_expr(level_cx, lvl);\n-    let test = ICmp(level_res.bcx, lib::llvm::IntUGE,\n-                    load, level_res.val);\n-    let level_bcx = trans_block_cleanups(level_res.bcx, level_cx);\n-\n-    CondBr(level_bcx, test, log_cx.llbb, after_cx.llbb);\n-    let sub = trans_temp_expr(log_cx, e);\n-    let e_ty = expr_ty(cx, e);\n-    let log_bcx = sub.bcx;\n-\n-    let r = get_tydesc_simple(log_bcx, e_ty, false);\n-    log_bcx = r.bcx;\n-    let lltydesc = r.val;\n-\n-    // Call the polymorphic log function.\n-    r = spill_if_immediate(log_bcx, sub.val, e_ty);\n-    log_bcx = r.bcx;\n-    let llvalptr = r.val;\n-    let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n-\n-    Call(log_bcx, ccx.upcalls.log_type,\n-         [lltydesc, llval_i8, level_res.val]);\n+    let current_level = Load(bcx, global);\n+    let {bcx, val: level} = with_scope_result(bcx, \"level\") {|bcx|\n+        trans_temp_expr(bcx, lvl)\n+    };\n \n-    cleanup_and_Br(log_bcx, log_cx, after_cx.llbb);\n-    ret after_cx;\n+    with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level)) {|bcx|\n+        with_scope(bcx, \"log\") {|bcx|\n+            let {bcx, val, _} = trans_temp_expr(bcx, e);\n+            let e_ty = expr_ty(bcx, e);\n+            let {bcx, val: tydesc} = get_tydesc_simple(bcx, e_ty, false);\n+            // Call the polymorphic log function.\n+            let {bcx, val} = spill_if_immediate(bcx, val, e_ty);\n+            let val = PointerCast(bcx, val, T_ptr(T_i8()));\n+            Call(bcx, ccx.upcalls.log_type, [tydesc, val, level]);\n+            bcx\n+        }\n+    }\n }\n \n-fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n-    let cond_res = trans_temp_expr(cx, e);\n+fn trans_check_expr(bcx: block, e: @ast::expr, s: str) -> block {\n     let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n-    let fail_cx = new_sub_block_ctxt(cx, \"fail\");\n-    trans_fail(fail_cx, some::<span>(e.span), expr_str);\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    CondBr(cond_res.bcx, cond_res.val, next_cx.llbb, fail_cx.llbb);\n-    ret next_cx;\n+    let {bcx, val} = with_scope_result(bcx, \"check\") {|bcx|\n+        trans_temp_expr(bcx, e)\n+    };\n+    with_cond(bcx, Not(bcx, val)) {|bcx|\n+        trans_fail(bcx, some(e.span), expr_str)\n+    }\n }\n \n-fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n-                   fail_expr: option<@ast::expr>) -> @block_ctxt {\n+fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n+                   fail_expr: option<@ast::expr>) -> block {\n     let bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n@@ -3531,14 +3449,14 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n     }\n }\n \n-fn trans_fail(bcx: @block_ctxt, sp_opt: option<span>, fail_str: str) ->\n-    @block_ctxt {\n+fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: str) ->\n+    block {\n     let V_fail_str = C_cstr(bcx_ccx(bcx), fail_str);\n     ret trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: @block_ctxt, sp_opt: option<span>,\n-                    V_fail_str: ValueRef) -> @block_ctxt {\n+fn trans_fail_value(bcx: block, sp_opt: option<span>,\n+                    V_fail_str: ValueRef) -> block {\n     let ccx = bcx_ccx(bcx);\n     let V_filename;\n     let V_line;\n@@ -3559,13 +3477,13 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option<span>,\n     ret bcx;\n }\n \n-fn trans_break_cont(bcx: @block_ctxt, to_end: bool)\n-    -> @block_ctxt {\n+fn trans_break_cont(bcx: block, to_end: bool)\n+    -> block {\n     // Locate closest loop block, outputting cleanup as we go.\n     let unwind = bcx, target = bcx;\n     while true {\n         alt unwind.kind {\n-          scope_block({is_loop: some({cnt, brk}), _}) {\n+          block_scope({is_loop: some({cnt, brk}), _}) {\n             target = if to_end {\n                 brk\n             } else {\n@@ -3591,15 +3509,15 @@ fn trans_break_cont(bcx: @block_ctxt, to_end: bool)\n     ret bcx;\n }\n \n-fn trans_break(cx: @block_ctxt) -> @block_ctxt {\n+fn trans_break(cx: block) -> block {\n     ret trans_break_cont(cx, true);\n }\n \n-fn trans_cont(cx: @block_ctxt) -> @block_ctxt {\n+fn trans_cont(cx: block) -> block {\n     ret trans_break_cont(cx, false);\n }\n \n-fn trans_ret(bcx: @block_ctxt, e: option<@ast::expr>) -> @block_ctxt {\n+fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n     let bcx = bcx;\n     alt e {\n       some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n@@ -3610,17 +3528,17 @@ fn trans_ret(bcx: @block_ctxt, e: option<@ast::expr>) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn build_return(bcx: @block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n+fn build_return(bcx: block) { Br(bcx, bcx_fcx(bcx).llreturn); }\n \n-// fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n-fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n-   @block_ctxt {\n+// fn trans_be(cx: &block, e: &@ast::expr) -> result {\n+fn trans_be(cx: block, e: @ast::expr) : ast_util::is_call_expr(e) ->\n+   block {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n }\n \n-fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n+fn init_local(bcx: block, local: @ast::local) -> block {\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n@@ -3665,8 +3583,8 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     ret alt::bind_irrefutable_pat(bcx, local.node.pat, llptr, false);\n }\n \n-fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n-    -> @block_ctxt {\n+fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n+    -> block {\n     let bcx = cx;\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n@@ -3689,7 +3607,7 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n     ret bcx;\n }\n \n-fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n+fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     #debug[\"trans_expr(%s)\", stmt_to_str(s)];\n \n     if (!bcx_ccx(cx).sess.opts.no_asm_comments) {\n@@ -3724,8 +3642,8 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n-                  name: str, block_span: option<span>) -> @block_ctxt {\n+fn new_block(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n+             name: str, block_span: option<span>) -> block {\n     let s = \"\";\n     if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         s = cx.ccx.names(name);\n@@ -3738,7 +3656,7 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 mutable unreachable: false,\n                 parent: parent,\n                 kind: kind,\n-                block_span: block_span,\n+                mutable block_span: block_span,\n                 fcx: cx};\n     alt parent {\n       parent_some(cx) {\n@@ -3749,32 +3667,26 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     ret bcx;\n }\n \n-fn simple_scope_block() -> block_kind {\n-    scope_block({is_loop: none, mutable cleanups: [],\n+fn simple_block_scope() -> block_kind {\n+    block_scope({is_loop: none, mutable cleanups: [],\n                  mutable cleanup_paths: [], mutable landing_pad: none})\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn new_top_block_ctxt(fcx: @fn_ctxt, sp: option<span>) -> @block_ctxt {\n-    ret new_block_ctxt(fcx, parent_none, simple_scope_block(),\n-                       \"function top level\", sp);\n-}\n-\n-// Use this when you're at a curly-brace or similar lexical scope.\n-fn new_scope_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), simple_scope_block(),\n-                       n, none);\n+fn top_scope_block(fcx: @fn_ctxt, sp: option<span>) -> block {\n+    ret new_block(fcx, parent_none, simple_block_scope(),\n+                  \"function top level\", sp);\n }\n \n-fn new_real_block_ctxt(bcx: @block_ctxt, n: str, sp: span) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), simple_scope_block(),\n-                       n, some(sp));\n+fn scope_block(bcx: block, n: str) -> block {\n+    ret new_block(bcx.fcx, parent_some(bcx), simple_block_scope(),\n+                  n, none);\n }\n \n-fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: loop_cont,\n-                             _break: @block_ctxt, n: str, sp: span)\n-    -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), scope_block({\n+fn loop_scope_block(bcx: block, _cont: loop_cont,\n+                    _break: block, n: str, sp: span)\n+    -> block {\n+    ret new_block(bcx.fcx, parent_some(bcx), block_scope({\n         is_loop: some({cnt: _cont, brk: _break}),\n         mutable cleanups: [],\n         mutable cleanup_paths: [],\n@@ -3784,34 +3696,34 @@ fn new_loop_scope_block_ctxt(bcx: @block_ctxt, _cont: loop_cont,\n \n \n // Use this when you're making a general CFG BB within a scope.\n-fn new_sub_block_ctxt(bcx: @block_ctxt, n: str) -> @block_ctxt {\n-    ret new_block_ctxt(bcx.fcx, parent_some(bcx), non_scope_block, n, none);\n+fn sub_block(bcx: block, n: str) -> block {\n+    ret new_block(bcx.fcx, parent_some(bcx), block_non_scope, n, none);\n }\n \n-fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n+fn raw_block(fcx: @fn_ctxt, llbb: BasicBlockRef) -> block {\n     ret @{llbb: llbb,\n           mutable terminated: false,\n           mutable unreachable: false,\n           parent: parent_none,\n-          kind: non_scope_block,\n-          block_span: none,\n+          kind: block_non_scope,\n+          mutable block_span: none,\n           fcx: fcx};\n }\n \n \n // trans_block_cleanups: Go through all the cleanups attached to this\n-// block_ctxt and execute them.\n+// block and execute them.\n //\n // When translating a block that introdces new variables during its scope, we\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n-   @block_ctxt {\n+fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n+   block {\n     if bcx.unreachable { ret bcx; }\n     let bcx = bcx;\n     alt check cleanup_cx.kind {\n-      scope_block({cleanups, _}) {\n+      block_scope({cleanups, _}) {\n         vec::riter(cleanups) {|cu|\n             alt cu { clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); } }\n         }\n@@ -3823,19 +3735,19 @@ fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n // In the last argument, some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-fn cleanup_and_leave(bcx: @block_ctxt, upto: option<BasicBlockRef>,\n+fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n     let cur = bcx, bcx = bcx;\n     while true {\n         alt cur.kind {\n-          scope_block(info) if info.cleanups.len() > 0u {\n+          block_scope(info) if info.cleanups.len() > 0u {\n             for exists in info.cleanup_paths {\n                 if exists.target == leave {\n                     Br(bcx, exists.dest);\n                     ret;\n                 }\n             }\n-            let sub_cx = new_sub_block_ctxt(bcx, \"cleanup\");\n+            let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n             info.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n             bcx = trans_block_cleanups(sub_cx, cur);\n@@ -3857,18 +3769,43 @@ fn cleanup_and_leave(bcx: @block_ctxt, upto: option<BasicBlockRef>,\n     }\n }\n \n-fn cleanup_and_Br(bcx: @block_ctxt, upto: @block_ctxt,\n+fn cleanup_and_Br(bcx: block, upto: block,\n                   target: BasicBlockRef) {\n     cleanup_and_leave(bcx, some(upto.llbb), some(target));\n }\n \n-fn trans_fn_cleanups(fcx: @fn_ctxt, cx: @block_ctxt) {\n-    alt fcx.llobstacktoken {\n-      some(lltoken_) {\n-        let lltoken = lltoken_; // satisfy alias checker\n+fn leave_block(bcx: block, out_of: block) -> block {\n+    let next_cx = sub_block(block_parent(out_of), \"next\");\n+    if bcx.unreachable { Unreachable(next_cx); }\n+    cleanup_and_Br(bcx, out_of, next_cx.llbb);\n+    next_cx\n+}\n+\n+fn with_scope(bcx: block, name: str, f: fn(block) -> block) -> block {\n+    let scope_cx = scope_block(bcx, name);\n+    Br(bcx, scope_cx.llbb);\n+    leave_block(f(scope_cx), scope_cx)\n+}\n+\n+fn with_scope_result(bcx: block, name: str, f: fn(block) -> result)\n+    -> result {\n+    let scope_cx = scope_block(bcx, name);\n+    Br(bcx, scope_cx.llbb);\n+    let {bcx, val} = f(scope_cx);\n+    {bcx: leave_block(bcx, scope_cx), val: val}\n+}\n+\n+fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n+    let next_cx = sub_block(bcx, \"next\"), cond_cx = sub_block(bcx, \"cond\");\n+    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n+    let after_cx = f(cond_cx);\n+    if !after_cx.terminated { Br(after_cx, next_cx.llbb); }\n+    next_cx\n+}\n+\n+fn trans_fn_cleanups(fcx: @fn_ctxt, cx: block) {\n+    option::may(fcx.llobstacktoken) {|lltoken|\n         Call(cx, fcx_ccx(fcx).upcalls.dynastack_free, [lltoken]);\n-      }\n-      none {/* nothing to do */ }\n     }\n }\n \n@@ -3888,17 +3825,17 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     }\n }\n \n-fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n+fn alloc_ty(cx: block, t: ty::t) -> result {\n     let bcx = cx, ccx = bcx_ccx(cx);\n     let llty = type_of(ccx, t);\n     let val = if type_has_static_size(ccx, t) {\n         alloca(bcx, llty)\n     } else {\n         // NB: we have to run this particular 'size_of' in a\n-        // block_ctxt built on the llderivedtydescs block for the fn,\n+        // block built on the llderivedtydescs block for the fn,\n         // so that the size dominates the array_alloca that\n         // comes next.\n-        let n = size_of(new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs),\n+        let n = size_of(raw_block(cx.fcx, cx.fcx.llderivedtydescs),\n                         t);\n         bcx.fcx.llderivedtydescs = n.bcx.llbb;\n         PointerCast(bcx, dynastack_alloca(bcx, T_i8(), n.val, t), T_ptr(llty))\n@@ -3914,7 +3851,7 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n     ret rslt(cx, val);\n }\n \n-fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n+fn alloc_local(cx: block, local: @ast::local) -> block {\n     let t = node_id_type(cx, local.node.id);\n     let p = normalize_pat(bcx_tcx(cx), local.node.pat);\n     let is_simple = alt p.node {\n@@ -3945,8 +3882,8 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     ret r.bcx;\n }\n \n-fn trans_block(bcx: @block_ctxt, b: ast::blk, dest: dest)\n-    -> @block_ctxt {\n+fn trans_block(bcx: block, b: ast::blk, dest: dest)\n+    -> block {\n     let bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n@@ -4084,8 +4021,8 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n-                        arg_tys: [ty::arg]) -> @block_ctxt {\n+fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: block, args: [ast::arg],\n+                        arg_tys: [ty::arg]) -> block {\n     let tcx = bcx_tcx(bcx);\n     let arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n@@ -4123,16 +4060,16 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     tie_up_header_blocks(fcx, lltop);\n-    let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n+    let ret_cx = raw_block(fcx, fcx.llreturn);\n     trans_fn_cleanups(fcx, ret_cx);\n     RetVoid(ret_cx);\n }\n \n fn tie_up_header_blocks(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n-    Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llloadenv);\n-    Br(new_raw_block_ctxt(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n-    Br(new_raw_block_ctxt(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n-    Br(new_raw_block_ctxt(fcx, fcx.lldynamicallocas), lltop);\n+    Br(raw_block(fcx, fcx.llstaticallocas), fcx.llloadenv);\n+    Br(raw_block(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n+    Br(raw_block(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n+    Br(raw_block(fcx, fcx.lldynamicallocas), lltop);\n }\n \n enum self_arg { impl_self(ty::t), no_self, }\n@@ -4154,7 +4091,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = new_top_block_ctxt(fcx, some(body.span)), bcx = bcx_top;\n+    let bcx_top = top_scope_block(fcx, some(body.span)), bcx = bcx_top;\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.node.id);\n \n@@ -4208,7 +4145,7 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n-    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n     let arg_t = ty::ty_fn_args(fty)[0].ty;\n     let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n@@ -4261,7 +4198,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n         })\n       }\n     };\n-    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n@@ -4538,7 +4475,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n         let fcx = new_fn_ctxt(ccx, [], llfdecl, none);\n \n-        let bcx = new_top_block_ctxt(fcx, none);\n+        let bcx = top_scope_block(fcx, none);\n         let lltop = bcx.llbb;\n \n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n@@ -4588,14 +4525,14 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n // Create a /real/ closure: this is like create_fn_pair, but creates a\n // a fn value on the stack with a specified environment (which need not be\n // on the stack).\n-fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n+fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n                        llenvptr: ValueRef) -> ValueRef {\n     let pair = alloca(cx, T_fn_pair(bcx_ccx(cx), llfnty));\n     fill_fn_pair(cx, pair, llfn, llenvptr);\n     ret pair;\n }\n \n-fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n+fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n     let ccx = bcx_ccx(bcx);\n     let code_cell = GEPi(bcx, pair, [0, abi::fn_field_code]);\n@@ -4778,7 +4715,7 @@ fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n     }));\n }\n \n-fn vp2i(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n+fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     let ccx = bcx_ccx(cx);\n     ret PtrToInt(cx, v, ccx.int_type);\n }\n@@ -4839,7 +4776,7 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n     intrinsics.insert(\"llvm.dbg.value\", value);\n }\n \n-fn trap(bcx: @block_ctxt) {\n+fn trap(bcx: block) {\n     let v: [ValueRef] = [];\n     alt bcx_ccx(bcx).intrinsics.find(\"llvm.trap\") {\n       some(x) { Call(bcx, x, v); }"}, {"sha": "957381431506236ec92267449c48647b57dfe250", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -6,10 +6,10 @@ import codemap::span;\n import lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n import lib::llvm::{Opcode, IntPredicate, RealPredicate, True, False,\n                    CallConv};\n-import common::{block_ctxt, T_ptr, T_nil, T_i8, T_i1, T_void,\n+import common::{block, T_ptr, T_nil, T_i8, T_i1, T_void,\n                 T_fn, val_ty, bcx_ccx, C_i32, val_str};\n \n-fn B(cx: @block_ctxt) -> BuilderRef {\n+fn B(cx: block) -> BuilderRef {\n     let b = *cx.fcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n     ret b;\n@@ -23,21 +23,21 @@ fn B(cx: @block_ctxt) -> BuilderRef {\n // for (fail/break/ret statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-fn RetVoid(cx: @block_ctxt) {\n+fn RetVoid(cx: block) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     llvm::LLVMBuildRetVoid(B(cx));\n }\n \n-fn Ret(cx: @block_ctxt, V: ValueRef) {\n+fn Ret(cx: block, V: ValueRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n-fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n+fn AggregateRet(cx: block, RetVals: [ValueRef]) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n@@ -47,22 +47,22 @@ fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n     }\n }\n \n-fn Br(cx: @block_ctxt, Dest: BasicBlockRef) {\n+fn Br(cx: block, Dest: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n-fn CondBr(cx: @block_ctxt, If: ValueRef, Then: BasicBlockRef,\n+fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n-fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     assert !cx.terminated;\n@@ -75,7 +75,7 @@ fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     llvm::LLVMAddCase(S, OnVal, Dest);\n }\n \n-fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n+fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n@@ -89,7 +89,7 @@ fn noname() -> sbuf unsafe {\n     ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n \n-fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n+fn Invoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n@@ -105,7 +105,7 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     }\n }\n \n-fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n+fn FastInvoke(cx: block, Fn: ValueRef, Args: [ValueRef],\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n@@ -118,7 +118,7 @@ fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     }\n }\n \n-fn Unreachable(cx: @block_ctxt) {\n+fn Unreachable(cx: block) {\n     if cx.unreachable { ret; }\n     cx.unreachable = true;\n     if !cx.terminated { llvm::LLVMBuildUnreachable(B(cx)); }\n@@ -129,188 +129,188 @@ fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n-fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n-fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n-fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n-fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n-fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n-fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n-fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n-fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n-fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n-fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n-fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n-fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n-fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n-fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n-fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n-fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n-fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n-fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n-fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n-fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n-fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n-fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n-fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n-fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n-fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n+fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n     ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n-fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn Neg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     ret llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n-fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n-fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n-fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n-fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n+fn Not(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     ret llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n-fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n-fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n-fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n     ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n-fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n     ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n-fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n+fn Free(cx: block, PointerVal: ValueRef) {\n     if cx.unreachable { ret; }\n     llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n-fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     if cx.unreachable {\n         let ty = val_ty(PointerVal);\n@@ -321,12 +321,12 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n-fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n+fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { ret; }\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n-fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n+fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n         ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n@@ -336,13 +336,13 @@ fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n-fn GEPi(cx: @block_ctxt, base: ValueRef, ixs: [int]) -> ValueRef {\n+fn GEPi(cx: block, base: ValueRef, ixs: [int]) -> ValueRef {\n     let v: [ValueRef] = [];\n     for i: int in ixs { v += [C_i32(i as i32)]; }\n     ret InBoundsGEP(cx, base, v);\n }\n \n-fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n+fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n@@ -353,142 +353,142 @@ fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n     }\n }\n \n-fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n-fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n+fn GlobalString(cx: block, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n-fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n+fn GlobalStringPtr(cx: block, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n-fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n-fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n-fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n-fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n-fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n-fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n-fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n-fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n-fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n-fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n-fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n-fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n-fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n-fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n-fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n-fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n+fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n-fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n-fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n-fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n \n /* Comparisons */\n-fn ICmp(cx: @block_ctxt, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n-fn FCmp(cx: @block_ctxt, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n-fn EmptyPhi(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n+fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n-fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n+fn Phi(cx: block, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n    -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     assert vals.len() == bbs.len();\n@@ -509,15 +509,15 @@ fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n+fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     let ty = val_ty(Fn);\n     let retty = if llvm::LLVMGetTypeKind(ty) == 8 as c_int {\n         llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n     ret llvm::LLVMGetUndef(retty);\n }\n \n-fn add_span_comment(bcx: @block_ctxt, sp: span, text: str) {\n+fn add_span_comment(bcx: block, sp: span, text: str) {\n     let ccx = bcx_ccx(bcx);\n     if (!ccx.sess.opts.no_asm_comments) {\n         let s = text + \" (\" + codemap::span_to_str(sp, ccx.sess.codemap)\n@@ -527,7 +527,7 @@ fn add_span_comment(bcx: @block_ctxt, sp: span, text: str) {\n     }\n }\n \n-fn add_comment(bcx: @block_ctxt, text: str) {\n+fn add_comment(bcx: block, text: str) {\n     let ccx = bcx_ccx(bcx);\n     if (!ccx.sess.opts.no_asm_comments) {\n         check str::is_not_empty(\"$\");\n@@ -543,15 +543,15 @@ fn add_comment(bcx: @block_ctxt, text: str) {\n     }\n }\n \n-fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+fn Call(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                 Args.len() as c_uint, noname());\n     }\n }\n \n-fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n+fn FastCall(cx: block, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n@@ -561,7 +561,7 @@ fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     }\n }\n \n-fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n+fn CallWithConv(cx: block, Fn: ValueRef, Args: [ValueRef],\n                 Conv: CallConv) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n@@ -572,64 +572,64 @@ fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     }\n }\n \n-fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n+fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(Then); }\n     ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n-fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n     ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n-fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n+fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n     ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n-fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n+fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { ret; }\n     llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n-fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n+fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { ret; }\n     llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n-fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n+fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n     ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index as c_uint, noname());\n }\n \n-fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n+fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n     llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n                                noname());\n }\n \n-fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n+fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n-fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n+fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n     ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n-fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n     ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n-fn Trap(cx: @block_ctxt) {\n+fn Trap(cx: block) {\n     if cx.unreachable { ret; }\n     let b = B(cx);\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n@@ -646,18 +646,18 @@ fn Trap(cx: @block_ctxt) {\n     }\n }\n \n-fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n+fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n     ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                   NumClauses as c_uint, noname());\n }\n \n-fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {\n+fn SetCleanup(_cx: block, LandingPad: ValueRef) {\n     llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n }\n \n-fn Resume(cx: @block_ctxt, Exn: ValueRef) -> ValueRef {\n+fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildResume(B(cx), Exn);"}, {"sha": "bb07da27ca8e6e88e82f69799312d6107df95066", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -162,15 +162,15 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     ret (cdata_ty, bound_tys);\n }\n \n-fn allocate_cbox(bcx: @block_ctxt,\n+fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n-    -> (@block_ctxt, ValueRef, [ValueRef]) {\n+    -> (block, ValueRef, [ValueRef]) {\n \n     // let ccx = bcx_ccx(bcx);\n     let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n \n-    fn nuke_ref_count(bcx: @block_ctxt, box: ValueRef) {\n+    fn nuke_ref_count(bcx: block, box: ValueRef) {\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx_ccx(bcx);\n         let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n@@ -179,10 +179,10 @@ fn allocate_cbox(bcx: @block_ctxt,\n         Store(bcx, rc, ref_cnt);\n     }\n \n-    fn store_uniq_tydesc(bcx: @block_ctxt,\n+    fn store_uniq_tydesc(bcx: block,\n                          cdata_ty: ty::t,\n                          box: ValueRef,\n-                         &ti: option::t<@tydesc_info>) -> @block_ctxt {\n+                         &ti: option::t<@tydesc_info>) -> block {\n         let ccx = bcx_ccx(bcx);\n         let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n         let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, true, ti);\n@@ -224,10 +224,10 @@ fn allocate_cbox(bcx: @block_ctxt,\n type closure_result = {\n     llbox: ValueRef,     // llvalue of ptr to closure\n     cdata_ty: ty::t,      // type of the closure data\n-    bcx: @block_ctxt     // final bcx\n+    bcx: block     // final bcx\n };\n \n-fn cast_if_we_can(bcx: @block_ctxt, llbox: ValueRef, t: ty::t) -> ValueRef {\n+fn cast_if_we_can(bcx: block, llbox: ValueRef, t: ty::t) -> ValueRef {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         let llty = type_of(ccx, t);\n@@ -242,12 +242,12 @@ fn cast_if_we_can(bcx: @block_ctxt, llbox: ValueRef, t: ty::t) -> ValueRef {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(\n-    bcx: @block_ctxt, lltyparams: [fn_ty_param],\n+    bcx: block, lltyparams: [fn_ty_param],\n     bound_values: [environment_value],\n     ck: ty::closure_kind)\n     -> closure_result {\n \n-    fn maybe_clone_tydesc(bcx: @block_ctxt,\n+    fn maybe_clone_tydesc(bcx: block,\n                           ck: ty::closure_kind,\n                           td: ValueRef) -> ValueRef {\n         ret alt ck {\n@@ -349,7 +349,7 @@ fn store_environment(\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-fn build_closure(bcx0: @block_ctxt,\n+fn build_closure(bcx0: block,\n                  cap_vars: [capture::capture_var],\n                  ck: ty::closure_kind)\n     -> closure_result {\n@@ -386,12 +386,12 @@ fn build_closure(bcx0: @block_ctxt,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: @block_ctxt,\n+fn load_environment(enclosing_cx: block,\n                     fcx: @fn_ctxt,\n                     cdata_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n-    let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+    let bcx = raw_block(fcx, fcx.llloadenv);\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n@@ -440,14 +440,14 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     }\n }\n \n-fn trans_expr_fn(bcx: @block_ctxt,\n+fn trans_expr_fn(bcx: block,\n                  proto: ast::proto,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n                  sp: span,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n-                 dest: dest) -> @block_ctxt {\n+                 dest: dest) -> block {\n     if dest == ignore { ret bcx; }\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(bcx, id);\n@@ -482,17 +482,17 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     ret bcx;\n }\n \n-fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option<@ast::expr>],\n-              id: ast::node_id, dest: dest) -> @block_ctxt {\n+fn trans_bind(cx: block, f: @ast::expr, args: [option<@ast::expr>],\n+              id: ast::node_id, dest: dest) -> block {\n     let f_res = trans_callee(cx, f);\n     ret trans_bind_1(cx, expr_ty(cx, f), f_res, args,\n                      node_id_type(cx, id), dest);\n }\n \n-fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n+fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 f_res: lval_maybe_callee,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n-                dest: dest) -> @block_ctxt {\n+                dest: dest) -> block {\n     let ccx = bcx_ccx(cx);\n     let bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {\n@@ -572,33 +572,19 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     ret bcx;\n }\n \n-fn make_null_test(\n-    in_bcx: @block_ctxt,\n-    ptr: ValueRef,\n-    blk: fn(@block_ctxt) -> @block_ctxt)\n-    -> @block_ctxt {\n-    let not_null_bcx = new_sub_block_ctxt(in_bcx, \"not null\");\n-    let next_bcx = new_sub_block_ctxt(in_bcx, \"next\");\n-    let null_test = IsNull(in_bcx, ptr);\n-    CondBr(in_bcx, null_test, next_bcx.llbb, not_null_bcx.llbb);\n-    let not_null_bcx = blk(not_null_bcx);\n-    Br(not_null_bcx, next_bcx.llbb);\n-    ret next_bcx;\n-}\n-\n fn make_fn_glue(\n-    cx: @block_ctxt,\n+    cx: block,\n     v: ValueRef,\n     t: ty::t,\n-    glue_fn: fn@(@block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt)\n-    -> @block_ctxt {\n+    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n+    -> block {\n     let bcx = cx;\n     let tcx = bcx_tcx(cx);\n \n-    let fn_env = fn@(ck: ty::closure_kind) -> @block_ctxt {\n+    let fn_env = fn@(ck: ty::closure_kind) -> block {\n         let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n-        make_null_test(cx, box_ptr_v) {|bcx|\n+        with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n             glue_fn(bcx, box_cell_v, closure_ty)\n         }\n@@ -615,10 +601,10 @@ fn make_fn_glue(\n }\n \n fn make_opaque_cbox_take_glue(\n-    bcx: @block_ctxt,\n+    bcx: block,\n     ck: ty::closure_kind,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n-    -> @block_ctxt {\n+    -> block {\n     // Easy cases:\n     alt ck {\n       ty::ck_block { ret bcx; }\n@@ -631,7 +617,7 @@ fn make_opaque_cbox_take_glue(\n     let tcx = bcx_tcx(bcx);\n     let llopaquecboxty = T_opaque_box_ptr(ccx);\n     let cbox_in = Load(bcx, cboxptr);\n-    make_null_test(bcx, cbox_in) {|bcx|\n+    with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n         let tydescptr = GEPi(bcx, cbox_in, [0, abi::box_field_tydesc]);\n@@ -663,10 +649,10 @@ fn make_opaque_cbox_take_glue(\n }\n \n fn make_opaque_cbox_drop_glue(\n-    bcx: @block_ctxt,\n+    bcx: block,\n     ck: ty::closure_kind,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n-    -> @block_ctxt {\n+    -> block {\n     alt ck {\n       ty::ck_block { bcx }\n       ty::ck_box {\n@@ -681,18 +667,18 @@ fn make_opaque_cbox_drop_glue(\n }\n \n fn make_opaque_cbox_free_glue(\n-    bcx: @block_ctxt,\n+    bcx: block,\n     ck: ty::closure_kind,\n     cbox: ValueRef)     // ptr to the opaque closure\n-    -> @block_ctxt {\n+    -> block {\n     alt ck {\n       ty::ck_block { ret bcx; }\n       ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n     }\n \n     let ccx = bcx_ccx(bcx);\n     let tcx = bcx_tcx(bcx);\n-    make_null_test(bcx, cbox) {|bcx|\n+    with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n@@ -783,13 +769,13 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n     let fcx = new_fn_ctxt(ccx, path, llthunk, none);\n-    let bcx = new_top_block_ctxt(fcx, none);\n+    let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     // Since we might need to construct derived tydescs that depend on\n     // our bound tydescs, we need to load tydescs out of the environment\n     // before derived tydescs are constructed. To do this, we load them\n     // in the load_env block.\n-    let l_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+    let l_bcx = raw_block(fcx, fcx.llloadenv);\n \n     // The 'llenv' that will arrive in the thunk we're creating is an\n     // environment that will contain the values of its arguments and a"}, {"sha": "6de08e2cfef0097df598262352ad31f6dc50e6e4", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -218,8 +218,8 @@ fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n }\n \n enum cleanup {\n-    clean(fn@(@block_ctxt) -> @block_ctxt),\n-    clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt),\n+    clean(fn@(block) -> block),\n+    clean_temp(ValueRef, fn@(block) -> block),\n }\n \n // Used to remember and reuse existing cleanup paths\n@@ -232,17 +232,17 @@ fn scope_clean_changed(info: scope_info) {\n     info.landing_pad = none;\n }\n \n-fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n+fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean(bind drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n     }\n }\n-fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n+fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n-    fn do_drop(bcx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n-       @block_ctxt {\n+    fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n+       block {\n         if ty::type_is_immediate(ty) {\n             ret base::drop_ty_immediate(bcx, val, ty);\n         } else {\n@@ -254,14 +254,14 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n         scope_clean_changed(info);\n     }\n }\n-fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n+fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n     }\n }\n-fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n+fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n     let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n                   else { bind base::trans_free(_, ptr) };\n     in_scope_cx(cx) {|info|\n@@ -274,7 +274,7 @@ fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n+fn revoke_clean(cx: block, val: ValueRef) {\n     in_scope_cx(cx) {|info|\n         let i = 0u;\n         for cu in info.cleanups {\n@@ -317,18 +317,18 @@ enum block_kind {\n     // cleaned up. May correspond to an actual block in the language, but also\n     // to an implicit scope, for example, calls introduce an implicit scope in\n     // which the arguments are evaluated and cleaned up.\n-    scope_block(scope_info),\n+    block_scope(scope_info),\n     // A non-scope block is a basic block created as a translation artifact\n     // from translating code that expresses conditional logic rather than by\n     // explicit { ... } block structure in the source language.  It's called a\n     // non-scope block because it doesn't introduce a new variable scope.\n-    non_scope_block,\n+    block_non_scope,\n }\n \n-enum loop_cont { cont_self, cont_other(@block_ctxt), }\n+enum loop_cont { cont_self, cont_other(block), }\n \n type scope_info = {\n-    is_loop: option<{cnt: loop_cont, brk: @block_ctxt}>,\n+    is_loop: option<{cnt: loop_cont, brk: block}>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n@@ -345,7 +345,7 @@ type scope_info = {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block_ctxt = {\n+type block = @{\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -359,20 +359,20 @@ type block_ctxt = {\n     kind: block_kind,\n     // The source span where the block came from, if it is a block that\n     // actually appears in the source code.\n-    block_span: option<span>,\n+    mutable block_span: option<span>,\n     // The function context for the function to which this block is\n     // attached.\n     fcx: @fn_ctxt\n };\n \n // FIXME: we should be able to use option<@block_parent> here but\n // the infinite-enum check in rustboot gets upset.\n-enum block_parent { parent_none, parent_some(@block_ctxt), }\n+enum block_parent { parent_none, parent_some(block), }\n \n-type result = {bcx: @block_ctxt, val: ValueRef};\n-type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n+type result = {bcx: block, val: ValueRef};\n+type result_t = {bcx: block, val: ValueRef, ty: ty::t};\n \n-fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n+fn rslt(bcx: block, val: ValueRef) -> result {\n     {bcx: bcx, val: val}\n }\n \n@@ -393,23 +393,27 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n     ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n-fn in_scope_cx(cx: @block_ctxt, f: fn(scope_info)) {\n+fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let cur = cx;\n     while true {\n         alt cur.kind {\n-          scope_block(info) { f(info); ret; }\n+          block_scope(info) { f(info); ret; }\n           _ {}\n         }\n-        cur = alt check cur.parent { parent_some(b) { b } };\n+        cur = block_parent(cur);\n     }\n }\n \n+fn block_parent(cx: block) -> block {\n+    alt check cx.parent { parent_some(b) { b } }\n+}\n+\n // Accessors\n // TODO: When we have overloading, simplify these names!\n \n-pure fn bcx_tcx(bcx: @block_ctxt) -> ty::ctxt { ret bcx.fcx.ccx.tcx; }\n-pure fn bcx_ccx(bcx: @block_ctxt) -> @crate_ctxt { ret bcx.fcx.ccx; }\n-pure fn bcx_fcx(bcx: @block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n+pure fn bcx_tcx(bcx: block) -> ty::ctxt { ret bcx.fcx.ccx.tcx; }\n+pure fn bcx_ccx(bcx: block) -> @crate_ctxt { ret bcx.fcx.ccx; }\n+pure fn bcx_fcx(bcx: block) -> @fn_ctxt { ret bcx.fcx; }\n pure fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.ccx; }\n pure fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.ccx.tcx; }\n pure fn ccx_tcx(ccx: @crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n@@ -838,7 +842,7 @@ fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n }\n \n \n-pure fn valid_variant_index(ix: uint, cx: @block_ctxt, enum_id: ast::def_id,\n+pure fn valid_variant_index(ix: uint, cx: block, enum_id: ast::def_id,\n                             variant_id: ast::def_id) -> bool {\n \n     // Handwaving: it's ok to pretend this code is referentially\n@@ -882,17 +886,17 @@ fn hash_mono_id(&&mi: mono_id) -> uint {\n     h\n }\n \n-fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     ret build::Select(cx, cond, b, a);\n }\n \n-fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     ret build::Select(cx, cond, a, b);\n }\n \n-fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n+fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(bcx_ccx(cx), 1));\n     let bumped = build::Add(cx, off, mask);\n     ret build::And(cx, bumped, build::Not(cx, mask));\n@@ -910,18 +914,18 @@ fn path_str(p: path) -> str {\n     r\n }\n \n-fn node_id_type(bcx: @block_ctxt, id: ast::node_id) -> ty::t {\n+fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let tcx = bcx_tcx(bcx);\n     let t = ty::node_id_to_type(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) { ty::substitute_type_params(tcx, substs.tys, t) }\n       _ { t }\n     }\n }\n-fn expr_ty(bcx: @block_ctxt, ex: @ast::expr) -> ty::t {\n+fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n-fn node_id_type_params(bcx: @block_ctxt, id: ast::node_id) -> [ty::t] {\n+fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n     let tcx = bcx_tcx(bcx);\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {"}, {"sha": "57721682982bf48eb76b2fb2986673a5e23fbcad", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -59,14 +59,14 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     }\n }\n \n-fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n+fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                    T_ptr(type_of_or_i8(bcx_ccx(bcx), basety)), base)\n }\n \n-fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, origin: typeck::method_origin)\n     -> lval_maybe_callee {\n     alt origin {\n@@ -91,7 +91,7 @@ fn trans_method_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n }\n \n // Method callee where the method is statically known\n-fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+fn trans_static_callee(bcx: block, callee_id: ast::node_id,\n                        base: @ast::expr, did: ast::def_id,\n                        substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n@@ -107,7 +107,7 @@ fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n     {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n }\n \n-fn trans_vtable_callee(bcx: @block_ctxt, env: callee_env, dict: ValueRef,\n+fn trans_vtable_callee(bcx: block, env: callee_env, dict: ValueRef,\n                        callee_id: ast::node_id, iface_id: ast::def_id,\n                        n_method: uint) -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n@@ -140,7 +140,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, env: callee_env, dict: ValueRef,\n      generic: generic}\n }\n \n-fn trans_monomorphized_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               base: @ast::expr, iface_id: ast::def_id,\n                               n_method: uint, n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n@@ -172,7 +172,7 @@ fn trans_monomorphized_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n \n \n // Method callee where the dict comes from a type param\n-fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+fn trans_param_callee(bcx: block, callee_id: ast::node_id,\n                       base: @ast::expr, iface_id: ast::def_id, n_method: uint,\n                       n_param: uint, n_bound: uint) -> lval_maybe_callee {\n     let {bcx, val} = trans_self_arg(bcx, base);\n@@ -182,7 +182,7 @@ fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n }\n \n // Method callee where the dict comes from a boxed iface\n-fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n+fn trans_iface_callee(bcx: block, callee_id: ast::node_id,\n                       base: @ast::expr, iface_id: ast::def_id, n_method: uint)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n@@ -266,12 +266,12 @@ fn resolve_dicts_in_fn_ctxt(fcx: @fn_ctxt, dicts: typeck::dict_res)\n }\n \n fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n-                 fill: fn(ValueRef, @block_ctxt) -> @block_ctxt)\n+                 fill: fn(ValueRef, block) -> block)\n     -> ValueRef {\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n     let fcx = new_fn_ctxt(ccx, [], llfn, none);\n-    let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n+    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let bcx = fill(llfn, bcx);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -396,7 +396,7 @@ fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n     }\n }\n \n-fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n+fn get_dict(bcx: block, origin: typeck::dict_origin) -> result {\n     let ccx = bcx_ccx(bcx);\n     alt origin {\n       typeck::dict_static(impl_did, tys, sub_origins) {\n@@ -453,7 +453,7 @@ fn dict_id(tcx: ty::ctxt, origin: typeck::dict_origin) -> dict_id {\n     }\n }\n \n-fn get_static_dict(bcx: @block_ctxt, origin: typeck::dict_origin)\n+fn get_static_dict(bcx: block, origin: typeck::dict_origin)\n     -> ValueRef {\n     let ccx = bcx_ccx(bcx);\n     let id = dict_id(ccx.tcx, origin);\n@@ -474,8 +474,8 @@ fn get_static_dict(bcx: @block_ctxt, origin: typeck::dict_origin)\n     cast\n }\n \n-fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n-    -> {bcx: @block_ctxt, ptrs: [ValueRef]} {\n+fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n+    -> {bcx: block, ptrs: [ValueRef]} {\n     let ccx = bcx_ccx(bcx);\n     fn get_vtable(ccx: @crate_ctxt, did: ast::def_id) -> ValueRef {\n         if did.crate == ast::local_crate {\n@@ -517,8 +517,8 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n     }\n }\n \n-fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n-    -> @block_ctxt {\n+fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n+    -> block {\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n     let ccx = bcx_ccx(bcx);\n     let v_ty = expr_ty(bcx, val);"}, {"sha": "83c7bafe1946c839383835c80175073b396bcfd1", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -54,10 +54,10 @@ fn c_stack_tys(ccx: @crate_ctxt,\n     };\n }\n \n-type shim_arg_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+type shim_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef) -> [ValueRef];\n \n-type shim_ret_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+type shim_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef, llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @crate_ctxt,\n@@ -73,7 +73,7 @@ fn build_shim_fn_(ccx: @crate_ctxt,\n \n     // Declare the body of the shim function:\n     let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n-    let bcx = new_top_block_ctxt(fcx, none);\n+    let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n@@ -90,11 +90,11 @@ fn build_shim_fn_(ccx: @crate_ctxt,\n     ret llshimfn;\n }\n \n-type wrap_arg_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+type wrap_arg_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llwrapfn: ValueRef,\n                            llargbundle: ValueRef);\n \n-type wrap_ret_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+type wrap_ret_builder = fn(bcx: block, tys: @c_stack_tys,\n                            llargbundle: ValueRef);\n \n fn build_wrap_fn_(ccx: @crate_ctxt,\n@@ -106,7 +106,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n                   ret_builder: wrap_ret_builder) {\n \n     let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n-    let bcx = new_top_block_ctxt(fcx, none);\n+    let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n \n     // Allocate the struct and write the arguments into it.\n@@ -122,7 +122,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Make sure our standard return block (that we didn't use) is terminated\n-    let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n+    let ret_cx = raw_block(fcx, fcx.llreturn);\n     Unreachable(ret_cx);\n }\n \n@@ -168,7 +168,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n \n-        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n             let llargvals = [];\n             let i = 0u;\n@@ -181,7 +181,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             ret llargvals;\n         }\n \n-        fn build_ret(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n             if tys.ret_def {\n                 let n = vec::len(tys.arg_tys);\n@@ -210,7 +210,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n \n-        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef,\n                       num_tps: uint) {\n             let i = 0u, n = vec::len(tys.arg_tys);\n@@ -226,7 +226,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n         }\n \n-        fn build_ret(bcx: @block_ctxt, _tys: @c_stack_tys,\n+        fn build_ret(bcx: block, _tys: @c_stack_tys,\n                      _llargbundle: ValueRef) {\n             RetVoid(bcx);\n         }\n@@ -283,7 +283,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n-        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n             let llargvals = [];\n             let i = 0u;\n@@ -300,7 +300,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             ret llargvals;\n         }\n \n-        fn build_ret(_bcx: @block_ctxt, _tys: @c_stack_tys,\n+        fn build_ret(_bcx: block, _tys: @c_stack_tys,\n                      _llargbundle: ValueRef, _llretval: ValueRef)  {\n             // Nop. The return pointer in the Rust ABI function\n             // is wired directly into the return slot in the shim struct\n@@ -316,7 +316,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n-        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let llretptr = alloca(bcx, tys.ret_ty);\n             let i = 0u, n = vec::len(tys.arg_tys);\n@@ -329,7 +329,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n         }\n \n-        fn build_ret(bcx: @block_ctxt, tys: @c_stack_tys,\n+        fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n             let n = vec::len(tys.arg_tys);\n             let llretval = load_inbounds(bcx, llargbundle, [0, n as int]);"}, {"sha": "d1ea547aa8309b533c4febce1d568013d3a58295", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -8,7 +8,7 @@ import driver::session::session;\n import trans::base;\n import middle::trans::common::{crate_ctxt, val_ty, C_bytes, C_int,\n                                C_named_struct, C_struct, T_enum_variant,\n-                               block_ctxt, result, rslt, bcx_ccx, bcx_tcx,\n+                               block, result, rslt, bcx_ccx, bcx_tcx,\n                                type_has_static_size, umax, umin, align_to,\n                                tydesc_info};\n import back::abi;\n@@ -593,19 +593,19 @@ fn gen_shape_tables(ccx: @crate_ctxt) {\n // compute sizeof / alignof\n \n type metrics = {\n-    bcx: @block_ctxt,\n+    bcx: block,\n     sz: ValueRef,\n     align: ValueRef\n };\n \n type tag_metrics = {\n-    bcx: @block_ctxt,\n+    bcx: block,\n     sz: ValueRef,\n     align: ValueRef,\n     payload_align: ValueRef\n };\n \n-fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n+fn size_of(bcx: block, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         rslt(bcx, llsize_of(ccx, base::type_of(ccx, t)))\n@@ -615,7 +615,7 @@ fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n     }\n }\n \n-fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n+fn align_of(bcx: block, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         rslt(bcx, llalign_of(ccx, base::type_of(ccx, t)))\n@@ -625,7 +625,7 @@ fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n     }\n }\n \n-fn metrics(bcx: @block_ctxt, t: ty::t) -> metrics {\n+fn metrics(bcx: block, t: ty::t) -> metrics {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         let llty = base::type_of(ccx, t);\n@@ -688,8 +688,8 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n     }\n }\n \n-fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> metrics {\n+fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n+    fn align_elements(cx: block, elts: [ty::t]) -> metrics {\n         //\n         // C padding rules:\n         //\n@@ -736,7 +736,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n         let bcx = cx;\n         let ccx = bcx_ccx(bcx);\n \n-        let compute_max_variant_size = fn@(bcx: @block_ctxt) -> result {\n+        let compute_max_variant_size = fn@(bcx: block) -> result {\n             // Compute max(variant sizes).\n             let bcx = bcx;\n             let max_size: ValueRef = C_int(ccx, 0);\n@@ -799,7 +799,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n }\n \n // Given a tag type `ty`, returns the offset of the payload.\n-//fn tag_payload_offs(bcx: @block_ctxt, tag_id: ast::def_id, tps: [ty::t])\n+//fn tag_payload_offs(bcx: block, tag_id: ast::def_id, tps: [ty::t])\n //    -> ValueRef {\n //    alt tag_kind(tag_id) {\n //      tk_unit | tk_enum | tk_newtype { C_int(bcx_ccx(bcx), 0) }"}, {"sha": "35494cc82dd2cc328d7f1bea9af3ed6d57876377", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -4,28 +4,28 @@ import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n import base::{call_memmove, trans_shared_malloc, type_of_or_i8,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n-               new_sub_block_ctxt, do_spill_noroot,\n+               sub_block, do_spill_noroot,\n                dest};\n import shape::{llsize_of, size_of};\n import build::*;\n import common::*;\n \n-fn get_fill(bcx: @block_ctxt, vptr: ValueRef) -> ValueRef {\n+fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill]))\n }\n-fn get_dataptr(bcx: @block_ctxt, vptr: ValueRef, unit_ty: TypeRef)\n+fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n     let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n-fn pointer_add(bcx: @block_ctxt, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n+fn alloc_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n     let ccx = bcx_ccx(bcx);\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n@@ -37,13 +37,13 @@ fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n }\n \n type alloc_result =\n-    {bcx: @block_ctxt,\n+    {bcx: block,\n      val: ValueRef,\n      unit_ty: ty::t,\n      llunitsz: ValueRef,\n      llunitty: TypeRef};\n \n-fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n+fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(ccx, unit_ty);\n@@ -66,7 +66,7 @@ fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n          llunitty: llunitty};\n }\n \n-fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n+fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n@@ -80,23 +80,19 @@ fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n     }\n     ret rslt(bcx, newptr);\n }\n-fn make_free_glue(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) ->\n-   @block_ctxt {\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    let drop_cx = new_sub_block_ctxt(bcx, \"drop\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-    let null_test = IsNull(bcx, vptr);\n-    CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n-    if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        drop_cx = iter_vec(drop_cx, vptr, vec_ty, base::drop_ty);\n+fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n+   block {\n+    let tcx = bcx_tcx(bcx), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n+    base::with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n+        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n+            iter_vec(bcx, vptr, vec_ty, base::drop_ty)\n+        } else { bcx };\n+        base::trans_shared_free(bcx, vptr)\n     }\n-    drop_cx = base::trans_shared_free(drop_cx, vptr);\n-    Br(drop_cx, next_cx.llbb);\n-    ret next_cx;\n }\n \n-fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n-             dest: dest) -> @block_ctxt {\n+fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n+             dest: dest) -> block {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     if dest == base::ignore {\n         for arg in args {\n@@ -129,7 +125,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n     ret base::store_in_dest(bcx, vptr, dest);\n }\n \n-fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n+fn trans_str(bcx: block, s: str, dest: dest) -> block {\n     let veclen = str::len_bytes(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n@@ -142,8 +138,8 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     ret base::store_in_dest(bcx, sptr, dest);\n }\n \n-fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-                rhs: ValueRef) -> @block_ctxt {\n+fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n+                rhs: ValueRef) -> block {\n     // Cast to opaque interior vector types if necessary.\n     let ccx = bcx_ccx(cx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n@@ -206,8 +202,8 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     ret bcx;\n }\n \n-fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-                        vals: [@ast::expr]) -> @block_ctxt {\n+fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n+                        vals: [@ast::expr]) -> block {\n     let ccx = bcx_ccx(bcx);\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n@@ -227,8 +223,8 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret bcx;\n }\n \n-fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n-             rhs: ValueRef, dest: dest) -> @block_ctxt {\n+fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n+             rhs: ValueRef, dest: dest) -> block {\n     let ccx = bcx_ccx(bcx);\n     let strings = alt ty::get(vec_ty).struct {\n       ty::ty_str { true }\n@@ -247,8 +243,8 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n \n     let write_ptr_ptr = do_spill_noroot\n         (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n-    let copy_fn = fn@(bcx: @block_ctxt, addr: ValueRef,\n-                      _ty: ty::t) -> @block_ctxt {\n+    let copy_fn = fn@(bcx: block, addr: ValueRef,\n+                      _ty: ty::t) -> block {\n         let ccx = bcx_ccx(bcx);\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n@@ -269,12 +265,12 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     ret base::store_in_dest(bcx, new_vec_ptr, dest);\n }\n \n-type val_and_ty_fn = fn@(@block_ctxt, ValueRef, ty::t) -> result;\n+type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> result;\n \n-type iter_vec_block = fn(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n+type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n-fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n-                fill: ValueRef, f: iter_vec_block) -> @block_ctxt {\n+fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n+                fill: ValueRef, f: iter_vec_block) -> block {\n     let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(ccx, unit_ty);\n@@ -288,13 +284,13 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n \n     // Now perform the iteration.\n-    let header_cx = new_sub_block_ctxt(bcx, \"iter_vec_loop_header\");\n+    let header_cx = sub_block(bcx, \"iter_vec_loop_header\");\n     Br(bcx, header_cx.llbb);\n     let data_ptr = Phi(header_cx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n     let not_yet_at_end =\n         ICmp(header_cx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n-    let body_cx = new_sub_block_ctxt(header_cx, \"iter_vec_loop_body\");\n-    let next_cx = new_sub_block_ctxt(header_cx, \"iter_vec_next\");\n+    let body_cx = sub_block(header_cx, \"iter_vec_loop_body\");\n+    let next_cx = sub_block(header_cx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n     let increment =\n@@ -307,8 +303,8 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     ret next_cx;\n }\n \n-fn iter_vec(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n-            f: iter_vec_block) -> @block_ctxt {\n+fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n+            f: iter_vec_block) -> block {\n     let ccx = bcx_ccx(bcx);\n     let vptr = PointerCast(bcx, vptr, T_ptr(ccx.opaque_vec_type));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);"}, {"sha": "b1b701fdc66fc969af3ddaaffc2315f0450adf02", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -2,31 +2,22 @@ import syntax::ast;\n import lib::llvm::ValueRef;\n import common::*;\n import build::*;\n-import base::{\n-    trans_shared_malloc,\n-    type_of,\n-    INIT,\n-    trans_shared_free,\n-    drop_ty,\n-    new_sub_block_ctxt,\n-    load_if_immediate,\n-    dest\n-};\n-import shape::{size_of};\n+import base::*;\n+import shape::size_of;\n \n export trans_uniq, make_free_glue, autoderef, duplicate, alloc_uniq;\n \n-fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n-              node_id: ast::node_id, dest: dest) -> @block_ctxt {\n+fn trans_uniq(bcx: block, contents: @ast::expr,\n+              node_id: ast::node_id, dest: dest) -> block {\n     let uniq_ty = node_id_type(bcx, node_id);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = base::trans_expr_save_in(bcx, contents, llptr);\n+    bcx = trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n-    ret base::store_in_dest(bcx, llptr, dest);\n+    ret store_in_dest(bcx, llptr, dest);\n }\n \n-fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t) -> result {\n+fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n     let bcx = cx;\n     let contents_ty = content_ty(uniq_ty);\n     let r = size_of(bcx, contents_ty);\n@@ -42,19 +33,12 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t) -> result {\n     ret rslt(bcx, llptr);\n }\n \n-fn make_free_glue(cx: @block_ctxt, vptr: ValueRef, t: ty::t)\n-    -> @block_ctxt {\n-    let bcx = cx;\n-    let free_cx = new_sub_block_ctxt(bcx, \"uniq_free\");\n-    let next_cx = new_sub_block_ctxt(bcx, \"uniq_free_next\");\n-    let null_test = IsNull(bcx, vptr);\n-    CondBr(bcx, null_test, next_cx.llbb, free_cx.llbb);\n-\n-    let bcx = free_cx;\n-    let bcx = drop_ty(bcx, vptr, content_ty(t));\n-    let bcx = trans_shared_free(bcx, vptr);\n-    Br(bcx, next_cx.llbb);\n-    next_cx\n+fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n+    -> block {\n+    with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n+        let bcx = drop_ty(bcx, vptr, content_ty(t));\n+        trans_shared_free(bcx, vptr)\n+    }\n }\n \n fn content_ty(t: ty::t) -> ty::t {\n@@ -69,12 +53,12 @@ fn autoderef(v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n     ret {v: v, t: content_ty};\n }\n \n-fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let content_ty = content_ty(t);\n     let {bcx, val: llptr} = alloc_uniq(bcx, t);\n \n     let src = load_if_immediate(bcx, v, content_ty);\n     let dst = llptr;\n-    let bcx = base::copy_val(bcx, INIT, dst, src, content_ty);\n+    let bcx = copy_val(bcx, INIT, dst, src, content_ty);\n     ret rslt(bcx, dst);\n }\n\\ No newline at end of file"}, {"sha": "778534053628c9665db5a8f2a6337f1964f87e6b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff429645461c83dca048d8a7088c04ee15cc96c8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ff429645461c83dca048d8a7088c04ee15cc96c8", "patch": "@@ -186,11 +186,8 @@ pure fn head<T: copy>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n Function: tail\n \n Returns all but the first element of a vector\n-\n-Predicates:\n-<is_not_empty> (v)\n */\n-fn tail<T: copy>(v: [const T]) : is_not_empty(v) -> [T] {\n+fn tail<T: copy>(v: [const T]) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n "}]}