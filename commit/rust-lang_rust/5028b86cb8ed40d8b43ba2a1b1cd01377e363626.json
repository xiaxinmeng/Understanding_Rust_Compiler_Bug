{"sha": "5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMjhiODZjYjhlZDQwZDhiNDNiYTJhMWIxY2QwMTM3N2UzNjM2MjY=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-14T14:01:25Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-14T14:01:42Z"}, "message": "Move hir_fmt code to display module", "tree": {"sha": "edb1afe1cce5fe7fab43a261dfa35f7ac5620834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edb1afe1cce5fe7fab43a261dfa35f7ac5620834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "html_url": "https://github.com/rust-lang/rust/commit/5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5028b86cb8ed40d8b43ba2a1b1cd01377e363626/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d46b555e31d04feeb6310c52248bba7ff267c453", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46b555e31d04feeb6310c52248bba7ff267c453", "html_url": "https://github.com/rust-lang/rust/commit/d46b555e31d04feeb6310c52248bba7ff267c453"}], "stats": {"total": 748, "additions": 376, "deletions": 372}, "files": [{"sha": "14e089cf4f437a5c6e304e7d4e0f9b703a6174d4", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 372, "deletions": 1, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/5028b86cb8ed40d8b43ba2a1b1cd01377e363626/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5028b86cb8ed40d8b43ba2a1b1cd01377e363626/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "patch": "@@ -2,7 +2,12 @@\n \n use std::fmt;\n \n-use crate::db::HirDatabase;\n+use crate::{\n+    db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n+    Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+};\n+use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_expand::name::Name;\n \n pub struct HirFormatter<'a, 'b, DB> {\n     pub db: &'a DB,\n@@ -97,3 +102,369 @@ where\n         })\n     }\n }\n+\n+const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n+\n+impl HirDisplay for &Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for ApplicationTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self.ctor {\n+            TypeCtor::Bool => write!(f, \"bool\")?,\n+            TypeCtor::Char => write!(f, \"char\")?,\n+            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Str => write!(f, \"str\")?,\n+            TypeCtor::Slice => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}]\", t.display(f.db))?;\n+            }\n+            TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{}; _]\", t.display(f.db))?;\n+            }\n+            TypeCtor::RawPtr(m) => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n+            }\n+            TypeCtor::Ref(m) => {\n+                let t = self.parameters.as_single();\n+                let ty_display = if f.omit_verbose_types() {\n+                    t.display_truncated(f.db, f.max_size)\n+                } else {\n+                    t.display(f.db)\n+                };\n+                write!(f, \"&{}{}\", m.as_keyword_for_ref(), ty_display)?;\n+            }\n+            TypeCtor::Never => write!(f, \"!\")?,\n+            TypeCtor::Tuple { .. } => {\n+                let ts = &self.parameters;\n+                if ts.len() == 1 {\n+                    write!(f, \"({},)\", ts[0].display(f.db))?;\n+                } else {\n+                    write!(f, \"(\")?;\n+                    f.write_joined(&*ts.0, \", \")?;\n+                    write!(f, \")\")?;\n+                }\n+            }\n+            TypeCtor::FnPtr { .. } => {\n+                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n+                write!(f, \"fn(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::FnDef(def) => {\n+                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n+                let name = match def {\n+                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n+                    CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n+                    CallableDef::EnumVariantId(e) => {\n+                        let enum_data = f.db.enum_data(e.parent);\n+                        enum_data.variants[e.local_id].name.clone()\n+                    }\n+                };\n+                match def {\n+                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n+                        write!(f, \"{}\", name)?\n+                    }\n+                }\n+                if self.parameters.len() > 0 {\n+                    let generics = generics(f.db, def.into());\n+                    let (parent_params, self_param, type_params, _impl_trait_params) =\n+                        generics.provenance_split();\n+                    let total_len = parent_params + self_param + type_params;\n+                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n+                    if total_len > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n+                        write!(f, \">\")?;\n+                    }\n+                }\n+                write!(f, \"(\")?;\n+                f.write_joined(sig.params(), \", \")?;\n+                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n+            }\n+            TypeCtor::Adt(def_id) => {\n+                let name = match def_id {\n+                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                };\n+                write!(f, \"{}\", name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+\n+                    let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n+                    let parameters_to_write = if f.omit_verbose_types() {\n+                        match self\n+                            .ctor\n+                            .as_generic_def()\n+                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .filter(|defaults| !defaults.is_empty())\n+                        {\n+                            Option::None => self.parameters.0.as_ref(),\n+                            Option::Some(default_parameters) => {\n+                                for (i, parameter) in self.parameters.iter().enumerate() {\n+                                    match (parameter, default_parameters.get(i)) {\n+                                        (&Ty::Unknown, _) | (_, None) => {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        (_, Some(default_parameter))\n+                                            if parameter != default_parameter =>\n+                                        {\n+                                            non_default_parameters.push(parameter.clone())\n+                                        }\n+                                        _ => (),\n+                                    }\n+                                }\n+                                &non_default_parameters\n+                            }\n+                        }\n+                    } else {\n+                        self.parameters.0.as_ref()\n+                    };\n+\n+                    f.write_joined(parameters_to_write, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_ = match type_alias.lookup(f.db).container {\n+                    AssocContainerId::TraitId(it) => it,\n+                    _ => panic!(\"not an associated type\"),\n+                };\n+                let trait_name = f.db.trait_data(trait_).name.clone();\n+                let name = f.db.type_alias_data(type_alias).name.clone();\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n+            TypeCtor::Closure { .. } => {\n+                let sig = self.parameters[0]\n+                    .callable_sig(f.db)\n+                    .expect(\"first closure parameter should contain signature\");\n+                let return_type_hint = sig.ret().display(f.db);\n+                if sig.params().is_empty() {\n+                    write!(f, \"|| -> {}\", return_type_hint)?;\n+                } else if f.omit_verbose_types() {\n+                    write!(f, \"|{}| -> {}\", TYPE_HINT_TRUNCATION, return_type_hint)?;\n+                } else {\n+                    write!(f, \"|\")?;\n+                    f.write_joined(sig.params(), \", \")?;\n+                    write!(f, \"| -> {}\", return_type_hint)?;\n+                };\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        let trait_name = f.db.trait_data(self.trait_(f.db)).name.clone();\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Ty {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self {\n+            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::Placeholder(id) => {\n+                let generics = generics(f.db, id.parent);\n+                let param_data = &generics.params.types[id.local_id];\n+                match param_data.provenance {\n+                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n+                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n+                    }\n+                    TypeParamProvenance::ArgumentImplTrait => {\n+                        write!(f, \"impl \")?;\n+                        let bounds = f.db.generic_predicates_for_param(*id);\n+                        let substs = Substs::type_params_for_generics(&generics);\n+                        write_bounds_like_dyn_trait(\n+                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n+                            f,\n+                        )?;\n+                    }\n+                }\n+            }\n+            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                write_bounds_like_dyn_trait(&predicates, f)?;\n+            }\n+            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n+            Ty::Infer(..) => write!(f, \"_\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn write_bounds_like_dyn_trait(\n+    predicates: &[GenericPredicate],\n+    f: &mut HirFormatter<impl HirDatabase>,\n+) -> fmt::Result {\n+    // Note: This code is written to produce nice results (i.e.\n+    // corresponding to surface Rust) for types that can occur in\n+    // actual Rust. It will have weird results if the predicates\n+    // aren't as expected (i.e. self types = $0, projection\n+    // predicates for a certain trait come after the Implemented\n+    // predicate for that trait).\n+    let mut first = true;\n+    let mut angle_open = false;\n+    for p in predicates.iter() {\n+        match p {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if angle_open {\n+                    write!(f, \">\")?;\n+                }\n+                if !first {\n+                    write!(f, \" + \")?;\n+                }\n+                // We assume that the self type is $0 (i.e. the\n+                // existential) here, which is the only thing that's\n+                // possible in actual Rust, and hence don't print it\n+                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n+                if trait_ref.substs.len() > 1 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                    // there might be assoc type bindings, so we leave the angle brackets open\n+                    angle_open = true;\n+                }\n+            }\n+            GenericPredicate::Projection(projection_pred) => {\n+                // in types in actual Rust, these will always come\n+                // after the corresponding Implemented predicate\n+                if angle_open {\n+                    write!(f, \", \")?;\n+                } else {\n+                    write!(f, \"<\")?;\n+                    angle_open = true;\n+                }\n+                let name =\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n+                write!(f, \"{} = \", name)?;\n+                projection_pred.ty.hir_fmt(f)?;\n+            }\n+            GenericPredicate::Error => {\n+                if angle_open {\n+                    // impl Trait<X, {error}>\n+                    write!(f, \", \")?;\n+                } else if !first {\n+                    // impl Trait + {error}\n+                    write!(f, \" + \")?;\n+                }\n+                p.hir_fmt(f)?;\n+            }\n+        }\n+        first = false;\n+    }\n+    if angle_open {\n+        write!(f, \">\")?;\n+    }\n+    Ok(())\n+}\n+\n+impl TraitRef {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n+        }\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone())?;\n+        if self.substs.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.substs[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, false)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        if f.should_truncate() {\n+            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n+        }\n+\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n+                    projection_pred.ty.display(f.db)\n+                )?;\n+            }\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Obligation {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+            Obligation::Projection(proj) => write!(\n+                f,\n+                \"Normalize({} => {})\",\n+                proj.projection_ty.display(f.db),\n+                proj.ty.display(f.db)\n+            ),\n+        }\n+    }\n+}"}, {"sha": "571579cc44b4a37394bea0639cb5a670fb9ef240", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 4, "deletions": 371, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/5028b86cb8ed40d8b43ba2a1b1cd01377e363626/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5028b86cb8ed40d8b43ba2a1b1cd01377e363626/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=5028b86cb8ed40d8b43ba2a1b1cd01377e363626", "patch": "@@ -41,21 +41,20 @@ mod marks;\n \n use std::ops::Deref;\n use std::sync::Arc;\n-use std::{fmt, iter, mem};\n+use std::{iter, mem};\n \n use hir_def::{\n-    expr::ExprId, generics::TypeParamProvenance, type_ref::Mutability, AdtId, AssocContainerId,\n-    DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId, type_ref::Mutability, AdtId, AssocContainerId, DefWithBodyId, GenericDefId,\n+    HasModule, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n-use hir_expand::name::Name;\n use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy, Uncertain},\n     utils::{generics, make_mut_slice, Generics},\n };\n-use display::{HirDisplay, HirFormatter};\n+use display::HirDisplay;\n \n pub use autoderef::autoderef;\n pub use infer::{do_infer_query, InferTy, InferenceResult};\n@@ -836,369 +835,3 @@ impl TypeWalk for Ty {\n         f(self, binders);\n     }\n }\n-\n-const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n-\n-impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}]\", t.display(f.db))?;\n-            }\n-            TypeCtor::Array => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"[{}; _]\", t.display(f.db))?;\n-            }\n-            TypeCtor::RawPtr(m) => {\n-                let t = self.parameters.as_single();\n-                write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;\n-            }\n-            TypeCtor::Ref(m) => {\n-                let t = self.parameters.as_single();\n-                let ty_display = if f.omit_verbose_types() {\n-                    t.display_truncated(f.db, f.max_size)\n-                } else {\n-                    t.display(f.db)\n-                };\n-                write!(f, \"&{}{}\", m.as_keyword_for_ref(), ty_display)?;\n-            }\n-            TypeCtor::Never => write!(f, \"!\")?,\n-            TypeCtor::Tuple { .. } => {\n-                let ts = &self.parameters;\n-                if ts.len() == 1 {\n-                    write!(f, \"({},)\", ts[0].display(f.db))?;\n-                } else {\n-                    write!(f, \"(\")?;\n-                    f.write_joined(&*ts.0, \", \")?;\n-                    write!(f, \")\")?;\n-                }\n-            }\n-            TypeCtor::FnPtr { .. } => {\n-                let sig = FnSig::from_fn_ptr_substs(&self.parameters);\n-                write!(f, \"fn(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::FnDef(def) => {\n-                let sig = f.db.callable_item_signature(def).subst(&self.parameters);\n-                let name = match def {\n-                    CallableDef::FunctionId(ff) => f.db.function_data(ff).name.clone(),\n-                    CallableDef::StructId(s) => f.db.struct_data(s).name.clone(),\n-                    CallableDef::EnumVariantId(e) => {\n-                        let enum_data = f.db.enum_data(e.parent);\n-                        enum_data.variants[e.local_id].name.clone()\n-                    }\n-                };\n-                match def {\n-                    CallableDef::FunctionId(_) => write!(f, \"fn {}\", name)?,\n-                    CallableDef::StructId(_) | CallableDef::EnumVariantId(_) => {\n-                        write!(f, \"{}\", name)?\n-                    }\n-                }\n-                if self.parameters.len() > 0 {\n-                    let generics = generics(f.db, def.into());\n-                    let (parent_params, self_param, type_params, _impl_trait_params) =\n-                        generics.provenance_split();\n-                    let total_len = parent_params + self_param + type_params;\n-                    // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n-                    if total_len > 0 {\n-                        write!(f, \"<\")?;\n-                        f.write_joined(&self.parameters.0[..total_len], \", \")?;\n-                        write!(f, \">\")?;\n-                    }\n-                }\n-                write!(f, \"(\")?;\n-                f.write_joined(sig.params(), \", \")?;\n-                write!(f, \") -> {}\", sig.ret().display(f.db))?;\n-            }\n-            TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-\n-                    let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n-                    let parameters_to_write = if f.omit_verbose_types() {\n-                        match self\n-                            .ctor\n-                            .as_generic_def()\n-                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n-                            .filter(|defaults| !defaults.is_empty())\n-                        {\n-                            Option::None => self.parameters.0.as_ref(),\n-                            Option::Some(default_parameters) => {\n-                                for (i, parameter) in self.parameters.iter().enumerate() {\n-                                    match (parameter, default_parameters.get(i)) {\n-                                        (&Ty::Unknown, _) | (_, None) => {\n-                                            non_default_parameters.push(parameter.clone())\n-                                        }\n-                                        (_, Some(default_parameter))\n-                                            if parameter != default_parameter =>\n-                                        {\n-                                            non_default_parameters.push(parameter.clone())\n-                                        }\n-                                        _ => (),\n-                                    }\n-                                }\n-                                &non_default_parameters\n-                            }\n-                        }\n-                    } else {\n-                        self.parameters.0.as_ref()\n-                    };\n-\n-                    f.write_joined(parameters_to_write, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::AssociatedType(type_alias) => {\n-                let trait_ = match type_alias.lookup(f.db).container {\n-                    AssocContainerId::TraitId(it) => it,\n-                    _ => panic!(\"not an associated type\"),\n-                };\n-                let trait_name = f.db.trait_data(trait_).name.clone();\n-                let name = f.db.type_alias_data(type_alias).name.clone();\n-                write!(f, \"{}::{}\", trait_name, name)?;\n-                if self.parameters.len() > 0 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&*self.parameters.0, \", \")?;\n-                    write!(f, \">\")?;\n-                }\n-            }\n-            TypeCtor::Closure { .. } => {\n-                let sig = self.parameters[0]\n-                    .callable_sig(f.db)\n-                    .expect(\"first closure parameter should contain signature\");\n-                let return_type_hint = sig.ret().display(f.db);\n-                if sig.params().is_empty() {\n-                    write!(f, \"|| -> {}\", return_type_hint)?;\n-                } else if f.omit_verbose_types() {\n-                    write!(f, \"|{}| -> {}\", TYPE_HINT_TRUNCATION, return_type_hint)?;\n-                } else {\n-                    write!(f, \"|\")?;\n-                    f.write_joined(sig.params(), \", \")?;\n-                    write!(f, \"| -> {}\", return_type_hint)?;\n-                };\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        let trait_name = f.db.trait_data(self.trait_(f.db)).name.clone();\n-        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n-        if self.parameters.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        write!(f, \">::{}\", f.db.type_alias_data(self.associated_ty).name)?;\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self {\n-            Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n-            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n-            Ty::Placeholder(id) => {\n-                let generics = generics(f.db, id.parent);\n-                let param_data = &generics.params.types[id.local_id];\n-                match param_data.provenance {\n-                    TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n-                        write!(f, \"{}\", param_data.name.clone().unwrap_or_else(Name::missing))?\n-                    }\n-                    TypeParamProvenance::ArgumentImplTrait => {\n-                        write!(f, \"impl \")?;\n-                        let bounds = f.db.generic_predicates_for_param(*id);\n-                        let substs = Substs::type_params_for_generics(&generics);\n-                        write_bounds_like_dyn_trait(\n-                            &bounds.iter().map(|b| b.clone().subst(&substs)).collect::<Vec<_>>(),\n-                            f,\n-                        )?;\n-                    }\n-                }\n-            }\n-            Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n-                write_bounds_like_dyn_trait(&predicates, f)?;\n-            }\n-            Ty::Unknown => write!(f, \"{{unknown}}\")?,\n-            Ty::Infer(..) => write!(f, \"_\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn write_bounds_like_dyn_trait(\n-    predicates: &[GenericPredicate],\n-    f: &mut HirFormatter<impl HirDatabase>,\n-) -> fmt::Result {\n-    // Note: This code is written to produce nice results (i.e.\n-    // corresponding to surface Rust) for types that can occur in\n-    // actual Rust. It will have weird results if the predicates\n-    // aren't as expected (i.e. self types = $0, projection\n-    // predicates for a certain trait come after the Implemented\n-    // predicate for that trait).\n-    let mut first = true;\n-    let mut angle_open = false;\n-    for p in predicates.iter() {\n-        match p {\n-            GenericPredicate::Implemented(trait_ref) => {\n-                if angle_open {\n-                    write!(f, \">\")?;\n-                }\n-                if !first {\n-                    write!(f, \" + \")?;\n-                }\n-                // We assume that the self type is $0 (i.e. the\n-                // existential) here, which is the only thing that's\n-                // possible in actual Rust, and hence don't print it\n-                write!(f, \"{}\", f.db.trait_data(trait_ref.trait_).name.clone())?;\n-                if trait_ref.substs.len() > 1 {\n-                    write!(f, \"<\")?;\n-                    f.write_joined(&trait_ref.substs[1..], \", \")?;\n-                    // there might be assoc type bindings, so we leave the angle brackets open\n-                    angle_open = true;\n-                }\n-            }\n-            GenericPredicate::Projection(projection_pred) => {\n-                // in types in actual Rust, these will always come\n-                // after the corresponding Implemented predicate\n-                if angle_open {\n-                    write!(f, \", \")?;\n-                } else {\n-                    write!(f, \"<\")?;\n-                    angle_open = true;\n-                }\n-                let name =\n-                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name.clone();\n-                write!(f, \"{} = \", name)?;\n-                projection_pred.ty.hir_fmt(f)?;\n-            }\n-            GenericPredicate::Error => {\n-                if angle_open {\n-                    // impl Trait<X, {error}>\n-                    write!(f, \", \")?;\n-                } else if !first {\n-                    // impl Trait + {error}\n-                    write!(f, \" + \")?;\n-                }\n-                p.hir_fmt(f)?;\n-            }\n-        }\n-        first = false;\n-    }\n-    if angle_open {\n-        write!(f, \">\")?;\n-    }\n-    Ok(())\n-}\n-\n-impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        self.substs[0].hir_fmt(f)?;\n-        if use_as {\n-            write!(f, \" as \")?;\n-        } else {\n-            write!(f, \": \")?;\n-        }\n-        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone())?;\n-        if self.substs.len() > 1 {\n-            write!(f, \"<\")?;\n-            f.write_joined(&self.substs[1..], \", \")?;\n-            write!(f, \">\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, false)\n-    }\n-}\n-\n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n-impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        if f.should_truncate() {\n-            return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n-        }\n-\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n-            GenericPredicate::Projection(projection_pred) => {\n-                write!(f, \"<\")?;\n-                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = {}\",\n-                    f.db.type_alias_data(projection_pred.projection_ty.associated_ty).name,\n-                    projection_pred.ty.display(f.db)\n-                )?;\n-            }\n-            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n-            Obligation::Projection(proj) => write!(\n-                f,\n-                \"Normalize({} => {})\",\n-                proj.projection_ty.display(f.db),\n-                proj.ty.display(f.db)\n-            ),\n-        }\n-    }\n-}"}]}