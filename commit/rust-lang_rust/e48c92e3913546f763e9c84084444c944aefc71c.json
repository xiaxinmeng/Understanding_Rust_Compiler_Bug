{"sha": "e48c92e3913546f763e9c84084444c944aefc71c", "node_id": "C_kwDOAAsO6NoAKGU0OGM5MmUzOTEzNTQ2Zjc2M2U5Yzg0MDg0NDQ0Yzk0NGFlZmM3MWM", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-06-10T02:12:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-10T02:12:32Z"}, "message": "Merge pull request #176 from rust-lang/feature/more-simd\n\nFeature/more simd", "tree": {"sha": "6b605d0a05a32eb317cac1b0138553c1b26523d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b605d0a05a32eb317cac1b0138553c1b26523d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e48c92e3913546f763e9c84084444c944aefc71c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJioqiQCRBK7hj4Ov3rIwAAV8IIAHThbpwl6VtVM5BQSoGn3jQg\niQkm4Hoe61KbT9QMyyBHBS9ohOQHAzj/JvBldUBfDyfjDaWz2caU/M0EU6KxnAov\n7MBu7wtix2bE6H2X8WM0k3scH9x2hrOvkpYFFaXmvD6TRhDdtO41UCukJbb2U61P\naW4ZXv7dqpq5owFG7zlXOBw9EwSLFX5JLTMp2Wa/6JUA5L5A2MUDDDrM3CVibQ6J\nVJD+fcBYxz7zyYilAc6ijL3/PjZ+3QmLGHj/g4cIKUn9tfRmMqYNV3RwRlUTQFuV\nnRas3iFXNb2wWhwKdGvmLKon8vRcHgq/N+Rj4NC+74NO1tlbGZe2THphFPF1lcE=\n=jNDE\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b605d0a05a32eb317cac1b0138553c1b26523d1\nparent e8dca3e87d164d2806098c462c6ce41301341f68\nparent ee4755afdbd8123333513931747d295021561b97\nauthor antoyo <antoyo@users.noreply.github.com> 1654827152 -0400\ncommitter GitHub <noreply@github.com> 1654827152 -0400\n\nMerge pull request #176 from rust-lang/feature/more-simd\n\nFeature/more simd"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e48c92e3913546f763e9c84084444c944aefc71c", "html_url": "https://github.com/rust-lang/rust/commit/e48c92e3913546f763e9c84084444c944aefc71c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e48c92e3913546f763e9c84084444c944aefc71c/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8dca3e87d164d2806098c462c6ce41301341f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8dca3e87d164d2806098c462c6ce41301341f68", "html_url": "https://github.com/rust-lang/rust/commit/e8dca3e87d164d2806098c462c6ce41301341f68"}, {"sha": "ee4755afdbd8123333513931747d295021561b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4755afdbd8123333513931747d295021561b97", "html_url": "https://github.com/rust-lang/rust/commit/ee4755afdbd8123333513931747d295021561b97"}], "stats": {"total": 1113, "additions": 787, "deletions": 326}, "files": [{"sha": "5bbd29fceba2a8051e0d082b290d608997c38773", "filename": "Readme.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48c92e3913546f763e9c84084444c944aefc71c/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/e48c92e3913546f763e9c84084444c944aefc71c/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=e48c92e3913546f763e9c84084444c944aefc71c", "patch": "@@ -127,6 +127,10 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit"}, {"sha": "19c981309d759cdd4a61e2e6c7c857811952f064", "filename": "src/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=e48c92e3913546f763e9c84084444c944aefc71c", "patch": "@@ -81,11 +81,17 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        /*context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-mavx512vpopcntdq\");\n+        context.add_command_line_option(\"-mavx512vl\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");*/\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "3804a958e6916b9db53fd890c443b5973ab6673e", "filename": "src/builder.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=e48c92e3913546f763e9c84084444c944aefc71c", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -275,21 +275,25 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n+        let func_name = format!(\"{:?}\", func_ptr);\n+        let previous_arg_count = args.len();\n+        let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name);\n+        let args_adjusted = args.len() != previous_arg_count;\n+        let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            let func_name = format!(\"{:?}\", func_ptr);\n-            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args, args_adjusted);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {\n@@ -1386,18 +1390,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n@@ -1409,7 +1415,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();"}, {"sha": "f2faae070284ad731092707e56daa9f4f242f3c1", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 583, "deletions": 133, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=e48c92e3913546f763e9c84084444c944aefc71c", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n \n-use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue, UnaryOp};\n \n use crate::{context::CodegenCx, builder::Builder};\n \n@@ -9,151 +9,331 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n         match &*func_name {\n-            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+            // NOTE: the following intrinsics have a different number of parameters in LLVM and GCC.\n+            \"__builtin_ia32_prold512_mask\" | \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n                 | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\" | \"__builtin_ia32_permvarqi512_mask\"\n+                | \"__builtin_ia32_permvarqi256_mask\" | \"__builtin_ia32_permvarqi128_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb512_mask\" | \"__builtin_ia32_vpmultishiftqb256_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb128_mask\"\n                 => {\n-                    // TODO: refactor by separating those intrinsics outside of this branch.\n-                    let add_before_last_arg =\n-                        match &*func_name {\n-                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                            _ => false,\n-                        };\n-                    let new_first_arg_is_zero =\n-                        match &*func_name {\n-                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                            _ => false\n-                        };\n-                    let arg3_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                            _ => 2,\n-                        };\n-                    let mut new_args = args.to_vec();\n-                    let arg3_type = gcc_func.get_param_type(arg3_index);\n-                    let first_arg =\n-                        if new_first_arg_is_zero {\n-                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n-                            let num_units = vector_type.get_num_units();\n-                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                        }\n-                        else {\n-                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                        };\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, first_arg);\n-                    }\n-                    else {\n-                        new_args.push(first_arg);\n-                    }\n-                    let arg4_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                            _ => 3,\n-                        };\n-                    let arg4_type = gcc_func.get_param_type(arg4_index);\n-                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, minus_one);\n-                    }\n-                    else {\n-                        new_args.push(minus_one);\n-                    }\n-                    args = new_args.into();\n-                },\n-                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n-                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n-                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-\n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n-\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n-\n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n-\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n-                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n-                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n-                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg3_type = gcc_func.get_param_type(2);\n-                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n-                        new_args.push(undefined);\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let first_arg = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n+                | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n+                | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n+                | \"__builtin_ia32_pmulhuw512_mask\" | \"__builtin_ia32_pmulhw512_mask\" | \"__builtin_ia32_pmulhrsw512_mask\"\n+                | \"__builtin_ia32_pmaxuw512_mask\" | \"__builtin_ia32_pmaxub512_mask\" | \"__builtin_ia32_pmaxsw512_mask\"\n+                | \"__builtin_ia32_pmaxsb512_mask\" | \"__builtin_ia32_pminuw512_mask\" | \"__builtin_ia32_pminub512_mask\"\n+                | \"__builtin_ia32_pminsw512_mask\" | \"__builtin_ia32_pminsb512_mask\"\n+                | \"__builtin_ia32_pmaddwd512_mask\" | \"__builtin_ia32_pmaddubsw512_mask\" | \"__builtin_ia32_packssdw512_mask\"\n+                | \"__builtin_ia32_packsswb512_mask\" | \"__builtin_ia32_packusdw512_mask\" | \"__builtin_ia32_packuswb512_mask\"\n+                | \"__builtin_ia32_pavgw512_mask\" | \"__builtin_ia32_pavgb512_mask\" | \"__builtin_ia32_psllw512_mask\"\n+                | \"__builtin_ia32_psllwi512_mask\" | \"__builtin_ia32_psllv32hi_mask\" | \"__builtin_ia32_psrlw512_mask\"\n+                | \"__builtin_ia32_psrlwi512_mask\" | \"__builtin_ia32_psllv16hi_mask\" | \"__builtin_ia32_psllv8hi_mask\"\n+                | \"__builtin_ia32_psrlv32hi_mask\" | \"__builtin_ia32_psraw512_mask\" | \"__builtin_ia32_psrawi512_mask\"\n+                | \"__builtin_ia32_psrlv16hi_mask\" | \"__builtin_ia32_psrlv8hi_mask\" | \"__builtin_ia32_psrav32hi_mask\"\n+                | \"__builtin_ia32_permvarhi512_mask\" | \"__builtin_ia32_pshufb512_mask\" | \"__builtin_ia32_psrav16hi_mask\"\n+                | \"__builtin_ia32_psrav8hi_mask\" | \"__builtin_ia32_permvarhi256_mask\" | \"__builtin_ia32_permvarhi128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_dbpsadbw512_mask\" | \"__builtin_ia32_dbpsadbw256_mask\" | \"__builtin_ia32_dbpsadbw128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let vector_type = arg4_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg4_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+                | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                // Remove last arg as it doesn't seem to be used in GCC and is always false.\n+                new_args.pop();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpconflictsi_512_mask\" | \"__builtin_ia32_vpconflictsi_256_mask\"\n+                | \"__builtin_ia32_vpconflictsi_128_mask\" | \"__builtin_ia32_vpconflictdi_512_mask\"\n+                | \"__builtin_ia32_vpconflictdi_256_mask\" | \"__builtin_ia32_vpconflictdi_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+\n+                let mut last_arg = None;\n+                if args.len() == 4 {\n+                    last_arg = new_args.pop();\n+                }\n+\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+\n+                if args.len() == 3 {\n+                    // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                    // the same GCC intrinsic, but the former has 3 parameters and the\n+                    // latter has 4 so it doesn't require this additional argument.\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                }\n+\n+                if let Some(last_arg) = last_arg {\n+                    new_args.push(last_arg);\n+                }\n+\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                |  \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" | \"__builtin_ia32_vpmadd52huq512_mask\"\n+                | \"__builtin_ia32_vpmadd52luq512_mask\" | \"__builtin_ia32_vpmadd52huq256_mask\" | \"__builtin_ia32_vpmadd52luq256_mask\"\n+                | \"__builtin_ia32_vpmadd52huq128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n+                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermt2varqi512_mask\" | \"__builtin_ia32_vpermt2varqi256_mask\"\n+                | \"__builtin_ia32_vpermt2varqi128_mask\" | \"__builtin_ia32_vpermt2varhi512_mask\"\n+                | \"__builtin_ia32_vpermt2varhi256_mask\" | \"__builtin_ia32_vpermt2varhi128_mask\"\n+                => {\n+                let new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                args = vec![new_args[1], new_args[0], new_args[2], minus_one].into();\n+            },\n+            \"__builtin_ia32_xrstor\" | \"__builtin_ia32_xsavec\" => {\n+                let new_args = args.to_vec();\n+                let thirty_two = builder.context.new_rvalue_from_int(new_args[1].get_type(), 32);\n+                let arg2 = new_args[1] << thirty_two | new_args[2];\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg2 = builder.context.new_cast(None, arg2, arg2_type);\n+                args = vec![new_args[0], arg2].into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\" => {\n+                let mut new_args = args.to_vec();\n+                let arg3 = &mut new_args[2];\n+                *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                args = new_args.into();\n+            },\n+            _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            let zero = builder.context.new_rvalue_zero(builder.int_type);\n+            #[cfg(feature=\"master\")]\n+            {\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+            // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,\n+            // but only the former requires adjusting the return value.\n+            // Those 2 LLVM intrinsics differ by their argument count, that's why we check if the\n+            // arguments were adjusted.\n+            if args_adjusted {\n+                let last_arg = args.last().expect(\"last arg\");\n+                let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+                let field2 = builder.context.new_field(None, args[1].get_type(), \"carryResult\");\n+                let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+                return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+            }\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -162,6 +342,14 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n+        \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+            | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+            if index == args_len - 1 {\n+                return true;\n+            }\n+        },\n         _ => (),\n     }\n \n@@ -189,18 +377,10 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n         \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n         \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n         \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n         \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n         \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n         \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n@@ -221,6 +401,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+        \"llvm.x86.subborrow.64\" => \"__builtin_ia32_sbb_u64\",\n+        \"llvm.floor.v2f64\" => \"__builtin_ia32_floorpd\",\n+        \"llvm.floor.v4f32\" => \"__builtin_ia32_floorps\",\n+        \"llvm.ceil.v2f64\" => \"__builtin_ia32_ceilpd\",\n+        \"llvm.ceil.v4f32\" => \"__builtin_ia32_ceilps\",\n+        \"llvm.fma.v2f64\" => \"__builtin_ia32_vfmaddpd\",\n+        \"llvm.fma.v4f64\" => \"__builtin_ia32_vfmaddpd256\",\n+        \"llvm.fma.v4f32\" => \"__builtin_ia32_vfmaddps\",\n+        \"llvm.fma.v8f32\" => \"__builtin_ia32_vfmaddps256\",\n+        \"llvm.ctlz.v16i32\" => \"__builtin_ia32_vplzcntd_512_mask\",\n+        \"llvm.ctlz.v8i32\" => \"__builtin_ia32_vplzcntd_256_mask\",\n+        \"llvm.ctlz.v4i32\" => \"__builtin_ia32_vplzcntd_128_mask\",\n+        \"llvm.ctlz.v8i64\" => \"__builtin_ia32_vplzcntq_512_mask\",\n+        \"llvm.ctlz.v4i64\" => \"__builtin_ia32_vplzcntq_256_mask\",\n+        \"llvm.ctlz.v2i64\" => \"__builtin_ia32_vplzcntq_128_mask\",\n+        \"llvm.ctpop.v32i16\" => \"__builtin_ia32_vpopcountw_v32hi\",\n+        \"llvm.x86.fma.vfmsub.sd\" => \"__builtin_ia32_vfmsubsd3\",\n+        \"llvm.x86.fma.vfmsub.ss\" => \"__builtin_ia32_vfmsubss3\",\n+        \"llvm.x86.fma.vfmsubadd.pd\" => \"__builtin_ia32_vfmaddsubpd\",\n+        \"llvm.x86.fma.vfmsubadd.pd.256\" => \"__builtin_ia32_vfmaddsubpd256\",\n+        \"llvm.x86.fma.vfmsubadd.ps\" => \"__builtin_ia32_vfmaddsubps\",\n+        \"llvm.x86.fma.vfmsubadd.ps.256\" => \"__builtin_ia32_vfmaddsubps256\",\n+        \"llvm.x86.fma.vfnmadd.sd\" => \"__builtin_ia32_vfnmaddsd3\",\n+        \"llvm.x86.fma.vfnmadd.ss\" => \"__builtin_ia32_vfnmaddss3\",\n+        \"llvm.x86.fma.vfnmsub.sd\" => \"__builtin_ia32_vfnmsubsd3\",\n+        \"llvm.x86.fma.vfnmsub.ss\" => \"__builtin_ia32_vfnmsubss3\",\n+        \"llvm.x86.avx512.conflict.d.512\" => \"__builtin_ia32_vpconflictsi_512_mask\",\n+        \"llvm.x86.avx512.conflict.d.256\" => \"__builtin_ia32_vpconflictsi_256_mask\",\n+        \"llvm.x86.avx512.conflict.d.128\" => \"__builtin_ia32_vpconflictsi_128_mask\",\n+        \"llvm.x86.avx512.conflict.q.512\" => \"__builtin_ia32_vpconflictdi_512_mask\",\n+        \"llvm.x86.avx512.conflict.q.256\" => \"__builtin_ia32_vpconflictdi_256_mask\",\n+        \"llvm.x86.avx512.conflict.q.128\" => \"__builtin_ia32_vpconflictdi_128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.512\" => \"__builtin_ia32_vpermt2varqi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.256\" => \"__builtin_ia32_vpermt2varqi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.128\" => \"__builtin_ia32_vpermt2varqi128_mask\",\n+        \"llvm.x86.avx512.permvar.qi.512\" => \"__builtin_ia32_permvarqi512_mask\",\n+        \"llvm.x86.avx512.permvar.qi.256\" => \"__builtin_ia32_permvarqi256_mask\",\n+        \"llvm.x86.avx512.permvar.qi.128\" => \"__builtin_ia32_permvarqi128_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.512\" => \"__builtin_ia32_vpmultishiftqb512_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.256\" => \"__builtin_ia32_vpmultishiftqb256_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.128\" => \"__builtin_ia32_vpmultishiftqb128_mask\",\n+        \"llvm.ctpop.v16i16\" => \"__builtin_ia32_vpopcountw_v16hi\",\n+        \"llvm.ctpop.v8i16\" => \"__builtin_ia32_vpopcountw_v8hi\",\n+        \"llvm.ctpop.v64i8\" => \"__builtin_ia32_vpopcountb_v64qi\",\n+        \"llvm.ctpop.v32i8\" => \"__builtin_ia32_vpopcountb_v32qi\",\n+        \"llvm.ctpop.v16i8\" => \"__builtin_ia32_vpopcountb_v16qi\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.512\" => \"__builtin_ia32_vpshufbitqmb512_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.256\" => \"__builtin_ia32_vpshufbitqmb256_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.128\" => \"__builtin_ia32_vpshufbitqmb128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.512\" => \"__builtin_ia32_ucmpw512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.256\" => \"__builtin_ia32_ucmpw256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.128\" => \"__builtin_ia32_ucmpw128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.512\" => \"__builtin_ia32_ucmpb512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.256\" => \"__builtin_ia32_ucmpb256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.128\" => \"__builtin_ia32_ucmpb128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.512\" => \"__builtin_ia32_cmpw512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.256\" => \"__builtin_ia32_cmpw256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.128\" => \"__builtin_ia32_cmpw128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.512\" => \"__builtin_ia32_cmpb512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.256\" => \"__builtin_ia32_cmpb256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.128\" => \"__builtin_ia32_cmpb128_mask\",\n+        \"llvm.x86.xrstor\" => \"__builtin_ia32_xrstor\",\n+        \"llvm.x86.xsavec\" => \"__builtin_ia32_xsavec\",\n+        \"llvm.x86.addcarry.32\" => \"__builtin_ia32_addcarryx_u32\",\n+        \"llvm.x86.subborrow.32\" => \"__builtin_ia32_sbb_u32\",\n+        \"llvm.x86.avx512.mask.compress.store.w.512\" => \"__builtin_ia32_compressstoreuhi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.256\" => \"__builtin_ia32_compressstoreuhi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.128\" => \"__builtin_ia32_compressstoreuhi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.512\" => \"__builtin_ia32_compressstoreuqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.256\" => \"__builtin_ia32_compressstoreuqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.128\" => \"__builtin_ia32_compressstoreuqi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.512\" => \"__builtin_ia32_compresshi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.256\" => \"__builtin_ia32_compresshi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.128\" => \"__builtin_ia32_compresshi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.512\" => \"__builtin_ia32_compressqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.256\" => \"__builtin_ia32_compressqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.128\" => \"__builtin_ia32_compressqi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.512\" => \"__builtin_ia32_expandhi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.256\" => \"__builtin_ia32_expandhi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.128\" => \"__builtin_ia32_expandhi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.512\" => \"__builtin_ia32_expandqi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.256\" => \"__builtin_ia32_expandqi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.128\" => \"__builtin_ia32_expandqi128_mask\",\n+        \"llvm.fshl.v8i64\" => \"__builtin_ia32_vpshldv_v8di\",\n+        \"llvm.fshl.v4i64\" => \"__builtin_ia32_vpshldv_v4di\",\n+        \"llvm.fshl.v2i64\" => \"__builtin_ia32_vpshldv_v2di\",\n+        \"llvm.fshl.v16i32\" => \"__builtin_ia32_vpshldv_v16si\",\n+        \"llvm.fshl.v8i32\" => \"__builtin_ia32_vpshldv_v8si\",\n+        \"llvm.fshl.v4i32\" => \"__builtin_ia32_vpshldv_v4si\",\n+        \"llvm.fshl.v32i16\" => \"__builtin_ia32_vpshldv_v32hi\",\n+        \"llvm.fshl.v16i16\" => \"__builtin_ia32_vpshldv_v16hi\",\n+        \"llvm.fshl.v8i16\" => \"__builtin_ia32_vpshldv_v8hi\",\n+        \"llvm.fshr.v8i64\" => \"__builtin_ia32_vpshrdv_v8di\",\n+        \"llvm.fshr.v4i64\" => \"__builtin_ia32_vpshrdv_v4di\",\n+        \"llvm.fshr.v2i64\" => \"__builtin_ia32_vpshrdv_v2di\",\n+        \"llvm.fshr.v16i32\" => \"__builtin_ia32_vpshrdv_v16si\",\n+        \"llvm.fshr.v8i32\" => \"__builtin_ia32_vpshrdv_v8si\",\n+        \"llvm.fshr.v4i32\" => \"__builtin_ia32_vpshrdv_v4si\",\n+        \"llvm.fshr.v32i16\" => \"__builtin_ia32_vpshrdv_v32hi\",\n+        \"llvm.fshr.v16i16\" => \"__builtin_ia32_vpshrdv_v16hi\",\n+        \"llvm.fshr.v8i16\" => \"__builtin_ia32_vpshrdv_v8hi\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -239,7 +564,132 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8hi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16hi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32hi\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.256\" => \"__builtin_ia32_dpbf16ps_v8sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.512\" => \"__builtin_ia32_dpbf16ps_v16sf\",\n+        \"llvm.x86.pclmulqdq.512\" => \"__builtin_ia32_vpclmulqdq_v8di\",\n+        \"llvm.x86.pclmulqdq.256\" => \"__builtin_ia32_vpclmulqdq_v4di\",\n+        \"llvm.x86.avx512.pmulhu.w.512\" => \"__builtin_ia32_pmulhuw512_mask\",\n+        \"llvm.x86.avx512.pmulh.w.512\" => \"__builtin_ia32_pmulhw512_mask\",\n+        \"llvm.x86.avx512.pmul.hr.sw.512\" => \"__builtin_ia32_pmulhrsw512_mask\",\n+        \"llvm.x86.avx512.pmaddw.d.512\" => \"__builtin_ia32_pmaddwd512_mask\",\n+        \"llvm.x86.avx512.pmaddubs.w.512\" => \"__builtin_ia32_pmaddubsw512_mask\",\n+        \"llvm.x86.avx512.packssdw.512\" => \"__builtin_ia32_packssdw512_mask\",\n+        \"llvm.x86.avx512.packsswb.512\" => \"__builtin_ia32_packsswb512_mask\",\n+        \"llvm.x86.avx512.packusdw.512\" => \"__builtin_ia32_packusdw512_mask\",\n+        \"llvm.x86.avx512.packuswb.512\" => \"__builtin_ia32_packuswb512_mask\",\n+        \"llvm.x86.avx512.pavg.w.512\" => \"__builtin_ia32_pavgw512_mask\",\n+        \"llvm.x86.avx512.pavg.b.512\" => \"__builtin_ia32_pavgb512_mask\",\n+        \"llvm.x86.avx512.psll.w.512\" => \"__builtin_ia32_psllw512_mask\",\n+        \"llvm.x86.avx512.pslli.w.512\" => \"__builtin_ia32_psllwi512_mask\",\n+        \"llvm.x86.avx512.psllv.w.512\" => \"__builtin_ia32_psllv32hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.256\" => \"__builtin_ia32_psllv16hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.128\" => \"__builtin_ia32_psllv8hi_mask\",\n+        \"llvm.x86.avx512.psrl.w.512\" => \"__builtin_ia32_psrlw512_mask\",\n+        \"llvm.x86.avx512.psrli.w.512\" => \"__builtin_ia32_psrlwi512_mask\",\n+        \"llvm.x86.avx512.psrlv.w.512\" => \"__builtin_ia32_psrlv32hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.256\" => \"__builtin_ia32_psrlv16hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.128\" => \"__builtin_ia32_psrlv8hi_mask\",\n+        \"llvm.x86.avx512.psra.w.512\" => \"__builtin_ia32_psraw512_mask\",\n+        \"llvm.x86.avx512.psrai.w.512\" => \"__builtin_ia32_psrawi512_mask\",\n+        \"llvm.x86.avx512.psrav.w.512\" => \"__builtin_ia32_psrav32hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.256\" => \"__builtin_ia32_psrav16hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.128\" => \"__builtin_ia32_psrav8hi_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.512\" => \"__builtin_ia32_vpermt2varhi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.256\" => \"__builtin_ia32_vpermt2varhi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.128\" => \"__builtin_ia32_vpermt2varhi128_mask\",\n+        \"llvm.x86.avx512.permvar.hi.512\" => \"__builtin_ia32_permvarhi512_mask\",\n+        \"llvm.x86.avx512.permvar.hi.256\" => \"__builtin_ia32_permvarhi256_mask\",\n+        \"llvm.x86.avx512.permvar.hi.128\" => \"__builtin_ia32_permvarhi128_mask\",\n+        \"llvm.x86.avx512.pshuf.b.512\" => \"__builtin_ia32_pshufb512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.512\" => \"__builtin_ia32_dbpsadbw512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.256\" => \"__builtin_ia32_dbpsadbw256_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.128\" => \"__builtin_ia32_dbpsadbw128_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.512\" => \"__builtin_ia32_vpmadd52huq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.512\" => \"__builtin_ia32_vpmadd52luq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.256\" => \"__builtin_ia32_vpmadd52huq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.256\" => \"__builtin_ia32_vpmadd52luq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.128\" => \"__builtin_ia32_vpmadd52huq128_mask\",\n+        \"llvm.x86.avx512.vpdpwssd.512\" => \"__builtin_ia32_vpdpwssd_v16si\",\n+        \"llvm.x86.avx512.vpdpwssd.256\" => \"__builtin_ia32_vpdpwssd_v8si\",\n+        \"llvm.x86.avx512.vpdpwssd.128\" => \"__builtin_ia32_vpdpwssd_v4si\",\n+        \"llvm.x86.avx512.vpdpwssds.512\" => \"__builtin_ia32_vpdpwssds_v16si\",\n+        \"llvm.x86.avx512.vpdpwssds.256\" => \"__builtin_ia32_vpdpwssds_v8si\",\n+        \"llvm.x86.avx512.vpdpwssds.128\" => \"__builtin_ia32_vpdpwssds_v4si\",\n+        \"llvm.x86.avx512.vpdpbusd.512\" => \"__builtin_ia32_vpdpbusd_v16si\",\n+        \"llvm.x86.avx512.vpdpbusd.256\" => \"__builtin_ia32_vpdpbusd_v8si\",\n+        \"llvm.x86.avx512.vpdpbusd.128\" => \"__builtin_ia32_vpdpbusd_v4si\",\n+        \"llvm.x86.avx512.vpdpbusds.512\" => \"__builtin_ia32_vpdpbusds_v16si\",\n+        \"llvm.x86.avx512.vpdpbusds.256\" => \"__builtin_ia32_vpdpbusds_v8si\",\n+        \"llvm.x86.avx512.vpdpbusds.128\" => \"__builtin_ia32_vpdpbusds_v4si\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "8f9862414e60a97c2e91e419939f9c5edcab40f8", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 175, "deletions": 180, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48c92e3913546f763e9c84084444c944aefc71c/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=e48c92e3913546f763e9c84084444c944aefc71c", "patch": "@@ -1,6 +1,4 @@\n-use std::cmp::Ordering;\n-\n-use gccjit::{BinaryOp, RValue, Type, ToRValue};\n+use gccjit::{BinaryOp, RValue, Type, ToRValue, ComparisonOp, UnaryOp};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n@@ -215,48 +213,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name =\n-            match in_len {\n-                2 => {\n-                    if element_type == bx.i64_type {\n-                        \"__builtin_ia32_vec_set_v2di\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                4 => {\n-                    if element_type == bx.i32_type {\n-                        \"__builtin_ia32_vec_set_v4si\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                8 => {\n-                    if element_type == bx.i16_type {\n-                        \"__builtin_ia32_vec_set_v8hi\"\n-                    }\n-                    else {\n-                        unimplemented!();\n-                    }\n-                },\n-                _ => unimplemented!(\"Len: {}\", in_len),\n-            };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO: if simd_insert is constant, use BIT_REF.\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature=\"master\")]\n@@ -290,6 +252,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n+    #[cfg(feature=\"master\")]\n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n@@ -309,117 +272,37 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(None, bx.context.new_array_access(None, array, index).to_rvalue(), out_type)\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(None, vector_type, &[\n-                cast_vec_element(0),\n-                cast_vec_element(1),\n-                cast_vec_element(2),\n-                cast_vec_element(3),\n-                cast_vec_element(4),\n-                cast_vec_element(5),\n-                cast_vec_element(6),\n-                cast_vec_element(7),\n-            ])\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+                    in_ty,\n+                    in_elem,\n+                    ret_ty,\n+                    out_elem\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        );\n     }\n \n     macro_rules! arith_binary {\n@@ -439,6 +322,67 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+        let mut shifts = vec![];\n+        let mut masks = vec![];\n+        let mut mask = 1;\n+        for i in 0..in_len {\n+            shifts.push(bx.context.new_rvalue_from_int(elem_type, i as i32));\n+            masks.push(bx.context.new_rvalue_from_int(elem_type, mask));\n+            mask <<= 1;\n+        }\n+        masks.reverse();\n+        let shifts = bx.context.new_rvalue_from_vector(None, vector.get_type(), &shifts);\n+        let shifted = vector >> shifts;\n+        let masks = bx.context.new_rvalue_from_vector(None, vector.get_type(), &masks);\n+        let masked = shifted & masks;\n+        let reduced = bx.vector_reduce_op(masked, BinaryOp::BitwiseOr);\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(bx.zext(reduced, bx.type_ix(expected_int_bits)));\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(reduced, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(\n+                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -578,40 +522,91 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n+                    return_error!(\n+                        \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n-            }\n-        };\n-        let builtin_name =\n-            match (signed, is_add, in_len, elem_width) {\n-                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n+                     arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                     arg_tys[0]\n+                    );\n+                }\n+            };\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO: improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO: convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO: convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n             };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {"}]}