{"sha": "cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMGI0ZTA2ODIyN2RkMzNmYTE1ZjNmZmUyNGYyOWUwNTM1ZDE5N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-08T09:02:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-08T09:02:33Z"}, "message": "auto merge of #19506 : eddyb/rust/fmt-polish, r=alexcrichton", "tree": {"sha": "4ed56f33eaaf211e3c0b4a21300898f47aa513c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ed56f33eaaf211e3c0b4a21300898f47aa513c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "html_url": "https://github.com/rust-lang/rust/commit/cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e69dfa261ecdf8010ba93a07f2bfed538f9acd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e69dfa261ecdf8010ba93a07f2bfed538f9acd5", "html_url": "https://github.com/rust-lang/rust/commit/1e69dfa261ecdf8010ba93a07f2bfed538f9acd5"}, {"sha": "15ca63081b384bfcf43d5a065298bb6fbf2cbfe0", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ca63081b384bfcf43d5a065298bb6fbf2cbfe0", "html_url": "https://github.com/rust-lang/rust/commit/15ca63081b384bfcf43d5a065298bb6fbf2cbfe0"}], "stats": {"total": 149, "additions": 72, "deletions": 77}, "files": [{"sha": "8b2ffd90ef71529dd948d7033633f47a46fa4e67", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "patch": "@@ -92,6 +92,9 @@ pub struct Formatter<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+// NB. Argument is essentially an optimized partially applied formatting function,\n+// equivalent to `exists T.(&T, fn(&T, &mut Formatter) -> Result`.\n+\n enum Void {}\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n@@ -100,37 +103,66 @@ enum Void {}\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n pub struct Argument<'a> {\n-    formatter: extern \"Rust\" fn(&Void, &mut Formatter) -> Result,\n     value: &'a Void,\n+    formatter: fn(&Void, &mut Formatter) -> Result,\n+}\n+\n+impl<'a> Argument<'a> {\n+    #[inline(never)]\n+    fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n+        Show::fmt(x, f)\n+    }\n+\n+    fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'a> {\n+        unsafe {\n+            Argument {\n+                formatter: mem::transmute(f),\n+                value: mem::transmute(x)\n+            }\n+        }\n+    }\n+\n+    fn from_uint<'a>(x: &'a uint) -> Argument<'a> {\n+        Argument::new(x, Argument::show_uint)\n+    }\n+\n+    fn as_uint(&self) -> Option<uint> {\n+        if self.formatter as uint == Argument::show_uint as uint {\n+            Some(unsafe { *(self.value as *const _ as *const uint) })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n-    /// which is valid because the compiler performs all necessary validation to\n-    /// ensure that the resulting call to format/write would be safe.\n+    /// Arguments structure.\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub unsafe fn new<'a>(pieces: &'static [&'static str],\n-                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn new<'a>(pieces: &'a [&'a str],\n+                   args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n-            pieces: mem::transmute(pieces),\n+            pieces: pieces,\n             fmt: None,\n             args: args\n         }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n     /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure.\n+    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n+    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n+    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub unsafe fn with_placeholders<'a>(pieces: &'static [&'static str],\n-                                        fmt: &'static [rt::Argument<'static>],\n-                                        args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn with_placeholders<'a>(pieces: &'a [&'a str],\n+                                 fmt: &'a [rt::Argument<'a>],\n+                                 args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n-            pieces: mem::transmute(pieces),\n-            fmt: Some(mem::transmute(fmt)),\n+            pieces: pieces,\n+            fmt: Some(fmt),\n             args: args\n         }\n     }\n@@ -312,15 +344,13 @@ impl<'a> Formatter<'a> {\n \n     fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n         match *cnt {\n-            rt::CountIs(n) => { Some(n) }\n-            rt::CountImplied => { None }\n+            rt::CountIs(n) => Some(n),\n+            rt::CountImplied => None,\n             rt::CountIsParam(i) => {\n-                let v = self.args[i].value;\n-                unsafe { Some(*(v as *const _ as *const uint)) }\n+                self.args[i].as_uint()\n             }\n             rt::CountIsNextParam => {\n-                let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *const _ as *const uint)) }\n+                self.curarg.next().and_then(|arg| arg.as_uint())\n             }\n         }\n     }\n@@ -533,30 +563,17 @@ impl Show for Error {\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n+pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n-    unsafe {\n-        Argument {\n-            formatter: mem::transmute(f),\n-            value: mem::transmute(t)\n-        }\n-    }\n-}\n-\n-/// When the compiler determines that the type of an argument *must* be a string\n-/// (such as for select), then it invokes this method.\n-#[doc(hidden)] #[inline]\n-#[experimental = \"implementation detail of the `format_args!` macro\"]\n-pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n-    argument(Show::fmt, s)\n+    Argument::new(t, f)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for plural), then it invokes this method.\n+/// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Show::fmt, s)\n+    Argument::from_uint(s)\n }\n \n // Implementations of the core formatting traits"}, {"sha": "d0c9df9d914e764d72f526712d912f6e73188f5d", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "patch": "@@ -418,7 +418,7 @@ pub use core::fmt::Error;\n pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n-pub use core::fmt::{argument, argumentstr, argumentuint};\n+pub use core::fmt::{argument, argumentuint};\n \n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string."}, {"sha": "c8fed3dcd16f6f092bdee2ef7cf1adad042e2669", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "patch": "@@ -577,17 +577,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n \n         // Now create a vector containing all the arguments\n-        let slicename = self.ecx.ident_of(\"__args_vec\");\n-        {\n-            let args = names.into_iter().map(|a| a.unwrap());\n-            let args = locals.into_iter().chain(args);\n-            let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n-            lets.push(self.ecx.stmt_let(self.fmtsp, false, slicename, args));\n-        }\n+        let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n-        let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n+        let args_slice = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n \n         let (fn_name, fn_args) = if self.all_pieces_simple {\n             (\"new\", vec![pieces, args_slice])\n@@ -602,29 +596,18 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.ident_of(\"Arguments\"),\n                 self.ecx.ident_of(fn_name)), fn_args);\n \n-        // We did all the work of making sure that the arguments\n-        // structure is safe, so we can safely have an unsafe block.\n-        let result = self.ecx.expr_block(P(ast::Block {\n-           view_items: Vec::new(),\n-           stmts: Vec::new(),\n-           expr: Some(result),\n-           id: ast::DUMMY_NODE_ID,\n-           rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-           span: self.fmtsp,\n-        }));\n-        let resname = self.ecx.ident_of(\"__args\");\n-        lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n-        let res = self.ecx.expr_ident(self.fmtsp, resname);\n         let result = match invocation {\n             Call(e) => {\n                 let span = e.span;\n-                self.ecx.expr_call(span, e,\n-                                   vec!(self.ecx.expr_addr_of(span, res)))\n+                self.ecx.expr_call(span, e, vec![\n+                    self.ecx.expr_addr_of(span, result)\n+                ])\n             }\n             MethodCall(e, m) => {\n                 let span = e.span;\n-                self.ecx.expr_method_call(span, e, m,\n-                                          vec!(self.ecx.expr_addr_of(span, res)))\n+                self.ecx.expr_method_call(span, e, m, vec![\n+                    self.ecx.expr_addr_of(span, result)\n+                ])\n             }\n         };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,"}, {"sha": "8a2c2d35ef5ba9eba7ff6147ca422c01e608d1fc", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/cf0b4e068227dd33fa15f3ffe24f29e0535d197f/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=cf0b4e068227dd33fa15f3ffe24f29e0535d197f", "patch": "@@ -41,20 +41,6 @@\n              static __STATIC_FMTSTR: &'static [&'static str] =\n                  (&([(\"test\" as &'static str)] as [&'static str, ..1]) as\n                      &'static [&'static str, ..1]);\n-             let __args_vec =\n-                 (&([] as [core::fmt::Argument<'_>, ..0]) as\n-                     &[core::fmt::Argument<'_>, ..0]);\n-             let __args =\n-                 (unsafe {\n-                      ((::std::fmt::Arguments::new as\n-                           unsafe fn(&'static [&'static str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n-                                                                                                                              as\n-                                                                                                                              &'static [&'static str]),\n-                                                                                                                          (__args_vec\n-                                                                                                                              as\n-                                                                                                                              &[core::fmt::Argument<'_>, ..0]))\n-                          as core::fmt::Arguments<'_>)\n-                  } as core::fmt::Arguments<'_>);\n \n \n \n@@ -64,7 +50,16 @@\n \n \n              ((::std::fmt::format as\n-                  fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&(__args\n+                  fn(&core::fmt::Arguments<'_>) -> collections::string::String)((&((::std::fmt::Arguments::new\n+                                                                                       as\n+                                                                                       fn(&'a [&'a str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n+                                                                                                                                                                         as\n+                                                                                                                                                                         &'static [&'static str]),\n+                                                                                                                                                                     (&([]\n+                                                                                                                                                                           as\n+                                                                                                                                                                           [core::fmt::Argument<'_>, ..0])\n+                                                                                                                                                                         as\n+                                                                                                                                                                         &[core::fmt::Argument<'_>, ..0]))\n                                                                                       as\n                                                                                       core::fmt::Arguments<'_>)\n                                                                                     as"}]}