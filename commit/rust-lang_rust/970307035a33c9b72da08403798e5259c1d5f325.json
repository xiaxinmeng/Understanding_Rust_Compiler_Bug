{"sha": "970307035a33c9b72da08403798e5259c1d5f325", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MDMwNzAzNWEzM2M5YjcyZGEwODQwMzc5OGU1MjU5YzFkNWYzMjU=", "commit": {"author": {"name": "Lokathor", "email": "zefria@gmail.com", "date": "2020-09-27T05:37:52Z"}, "committer": {"name": "Lokathor", "email": "zefria@gmail.com", "date": "2020-09-27T05:37:52Z"}, "message": "end of draft 1", "tree": {"sha": "7873fc84c616a1ca0d524770580f52ea52426e26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7873fc84c616a1ca0d524770580f52ea52426e26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/970307035a33c9b72da08403798e5259c1d5f325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/970307035a33c9b72da08403798e5259c1d5f325", "html_url": "https://github.com/rust-lang/rust/commit/970307035a33c9b72da08403798e5259c1d5f325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/970307035a33c9b72da08403798e5259c1d5f325/comments", "author": {"login": "Lokathor", "id": 5456384, "node_id": "MDQ6VXNlcjU0NTYzODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5456384?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lokathor", "html_url": "https://github.com/Lokathor", "followers_url": "https://api.github.com/users/Lokathor/followers", "following_url": "https://api.github.com/users/Lokathor/following{/other_user}", "gists_url": "https://api.github.com/users/Lokathor/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lokathor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lokathor/subscriptions", "organizations_url": "https://api.github.com/users/Lokathor/orgs", "repos_url": "https://api.github.com/users/Lokathor/repos", "events_url": "https://api.github.com/users/Lokathor/events{/privacy}", "received_events_url": "https://api.github.com/users/Lokathor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lokathor", "id": 5456384, "node_id": "MDQ6VXNlcjU0NTYzODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5456384?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lokathor", "html_url": "https://github.com/Lokathor", "followers_url": "https://api.github.com/users/Lokathor/followers", "following_url": "https://api.github.com/users/Lokathor/following{/other_user}", "gists_url": "https://api.github.com/users/Lokathor/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lokathor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lokathor/subscriptions", "organizations_url": "https://api.github.com/users/Lokathor/orgs", "repos_url": "https://api.github.com/users/Lokathor/repos", "events_url": "https://api.github.com/users/Lokathor/events{/privacy}", "received_events_url": "https://api.github.com/users/Lokathor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e6387fccd1f7c37c353ab4d674d641e21d4315", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e6387fccd1f7c37c353ab4d674d641e21d4315", "html_url": "https://github.com/rust-lang/rust/commit/f6e6387fccd1f7c37c353ab4d674d641e21d4315"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "bf0592236d059058eaed3d3ad33ec7c177218efb", "filename": "beginners-guide.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/970307035a33c9b72da08403798e5259c1d5f325/beginners-guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/970307035a33c9b72da08403798e5259c1d5f325/beginners-guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/beginners-guide.md?ref=970307035a33c9b72da08403798e5259c1d5f325", "patch": "@@ -26,3 +26,40 @@ SIMD has a few special vocabulary terms you should know:\n * **Vertical:** When an operation is \"vertical\", each lane processes individually without regard to the other lanes in the same vector. For example, a \"vertical add\" between two vectors would add lane 0 in `a` with lane 0 in `b`, with the total in lane 0 of `out`, and then the same thing for lanes 1, 2, etc. Most SIMD operations are vertical operations, so if your problem is a vertical problem then you can probably solve it with SIMD.\n \n * **Horizontal:** When an operation is \"horizontal\", the lanes within a single vector interact in some way. A \"horizontal add\" might add up lane 0 of `a` with lane 1 of `a`, with the total in lane 0 of `out`.\n+\n+* **Target Feature:** Rust calls a CPU architecture extension a `target_feature`. Proper SIMD requires various CPU extensions to be enabled (details below). Don't confuse this with `feature`, which is a Cargo crate concept.\n+\n+## Target Features\n+\n+When using SIMD, you should be familiar with the CPU feature set that you're targeting.\n+\n+On `arm` and `aarch64` it's fairly simple. There's just one CPU feature that controls if SIMD is available: `neon` (or \"NEON\", all caps, as the ARM docs often put it). Neon registers are 128-bit, but they can also operate as 64-bit (the high lanes are just zeroed out).\n+\n+> By default, the `aarch64`, `arm`, and `thumb` Rust targets generally do not enable `neon` unless it's in the target string.\n+\n+On `x86` and `x86_64` it's slightly more complicated. The SIMD support is split into many levels:\n+* 128-bit: `sse`, `sse2`, `sse3`, `ssse3` (not a typo!), `sse4.1`, `sse4.2`, `sse4a` (AMD only)\n+* 256-bit (mostly): `avx`, `avx2`, `fma`\n+* 512-bit (mostly): a *wide* range of `avx512` variations\n+\n+> By default, the `i686` and `x86_64` Rust targets enable `sse` and `sse2`.\n+\n+### Selecting Additional Target Features\n+\n+If you want to enable support for a target feature within your build, generally you should use a [target-feature](https://rust-lang.github.io/packed_simd/perf-guide/target-feature/rustflags.html#target-feature) setting within you `RUSTFLAGS` setting.\n+\n+If you know that you're targeting a specific CPU you can instead use the [target-cpu](https://rust-lang.github.io/packed_simd/perf-guide/target-feature/rustflags.html#target-cpu) flag and the compiler will enable the correct set of features for that CPU.\n+\n+The [Steam Hardware Survey](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam) is one of the few places with data on how common various CPU features are. The dataset is limited to \"the kinds of computers owned by people who play computer games\", so the info only covers `x86`/`x86_64`, and it also probably skews to slightly higher quality computers than average. Still, we can see that the `sse` levels have very high support, `avx` and `avx2` are quite common as well, and the `avx-512` family is still so early in adoption you can barely find it in consumer grade stuff.\n+\n+## Running a program compiled for a CPU feature level that the CPU doesn't support is automatic undefined behavior.\n+\n+This means that if you build your program with `avx` support enabled and run it on a CPU without `avx` support, it's **instantly** undefined behavior.\n+\n+Even without an `unsafe` block in sight.\n+\n+This is no bug in Rust, or soundness hole in the type system. You just plain can't make a CPU do what it doesn't know how to do.\n+\n+This is why the various Rust targets *don't* enable many CPU feature flags by default: requiring a more advanced CPU makes the final binary *less* portable.\n+\n+So please select an appropriate CPU feature level when building your programs."}]}