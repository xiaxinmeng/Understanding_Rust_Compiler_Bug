{"sha": "8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOGU0OTdhZTc4NmZmYzAzMmMxZTY4ZmMyM2RhMGVkY2Y2ZmE1ZTM=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-24T08:13:59Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-06-19T04:07:58Z"}, "message": "Handle CRLF properly in the lexer\n\nThe lexer already ignores CRLF in between tokens, but it doesn't\nproperly handle carriage returns inside strings and doc comments. Teach\nit to treat CRLF as LF inside these tokens, and to disallow carriage\nreturns that are not followed by linefeeds. This includes handling an\nescaped CRLF inside a regular string token the same way it handles an\nescaped LF.\n\nThis is technically a breaking change, as bare carriage returns are no\nlonger allowed, and CRLF sequences are now treated as LF inside strings\nand doc comments, but it's very unlikely to actually affect any\nreal-world code.\n\nThis change is necessary to have Rust code compile on Windows the same\nway it does on Unix. The mozilla/rust repository explicitly sets eol=lf\nfor Rust source files, but other Rust repositories don't. Notably,\nrust-http cannot be compiled on Windows without converting the CRLF line\nendings back to LF.\n\n[breaking-change]", "tree": {"sha": "e9d7a99dbf4006f1eba4976cf432cc81bfcf7665", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9d7a99dbf4006f1eba4976cf432cc81bfcf7665"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "html_url": "https://github.com/rust-lang/rust/commit/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d41058ed39fcd7e15ce9d0e7705643da85c94271", "url": "https://api.github.com/repos/rust-lang/rust/commits/d41058ed39fcd7e15ce9d0e7705643da85c94271", "html_url": "https://github.com/rust-lang/rust/commit/d41058ed39fcd7e15ce9d0e7705643da85c94271"}], "stats": {"total": 238, "additions": 215, "deletions": 23}, "files": [{"sha": "add9a4cb9f3bd14e6f961b03d9bafd56818208f5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 118, "deletions": 23, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "patch": "@@ -225,6 +225,47 @@ impl<'a> StringReader<'a> {\n                 self.byte_offset(end).to_uint()))\n     }\n \n+    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n+    fn translate_crlf<'a>(&self, start: BytePos,\n+                          s: &'a str, errmsg: &'a str) -> str::MaybeOwned<'a> {\n+        let mut i = 0u;\n+        while i < s.len() {\n+            let str::CharRange { ch, next } = s.char_range_at(i);\n+            if ch == '\\r' {\n+                if next < s.len() && s.char_at(next) == '\\n' {\n+                    return translate_crlf_(self, start, s, errmsg, i).into_maybe_owned();\n+                }\n+                let pos = start + BytePos(i as u32);\n+                let end_pos = start + BytePos(next as u32);\n+                self.err_span_(pos, end_pos, errmsg);\n+            }\n+            i = next;\n+        }\n+        return s.into_maybe_owned();\n+\n+        fn translate_crlf_(rdr: &StringReader, start: BytePos,\n+                        s: &str, errmsg: &str, mut i: uint) -> String {\n+            let mut buf = String::with_capacity(s.len());\n+            let mut j = 0;\n+            while i < s.len() {\n+                let str::CharRange { ch, next } = s.char_range_at(i);\n+                if ch == '\\r' {\n+                    if j < i { buf.push_str(s.slice(j, i)); }\n+                    j = next;\n+                    if next >= s.len() || s.char_at(next) != '\\n' {\n+                        let pos = start + BytePos(i as u32);\n+                        let end_pos = start + BytePos(next as u32);\n+                        rdr.err_span_(pos, end_pos, errmsg);\n+                    }\n+                }\n+                i = next;\n+            }\n+            if j < s.len() { buf.push_str(s.slice_from(j)); }\n+            buf\n+        }\n+    }\n+\n+\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n@@ -305,7 +346,20 @@ impl<'a> StringReader<'a> {\n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n                     if self.curr_is('/') || self.curr_is('!') {\n                         let start_bpos = self.pos - BytePos(3);\n-                        while !self.curr_is('\\n') && !self.is_eof() {\n+                        while !self.is_eof() {\n+                            match self.curr.unwrap() {\n+                                '\\n' => break,\n+                                '\\r' => {\n+                                    if self.nextch_is('\\n') {\n+                                        // CRLF\n+                                        break\n+                                    } else {\n+                                        self.err_span_(self.last_pos, self.pos,\n+                                                       \"bare CR not allowed in doc-comment\");\n+                                    }\n+                                }\n+                                _ => ()\n+                            }\n                             self.bump();\n                         }\n                         let ret = self.with_str_from(start_bpos, |string| {\n@@ -370,6 +424,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos - BytePos(2);\n \n         let mut level: int = 1;\n+        let mut has_cr = false;\n         while level > 0 {\n             if self.is_eof() {\n                 let msg = if is_doc_comment {\n@@ -379,25 +434,35 @@ impl<'a> StringReader<'a> {\n                 };\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_(start_bpos, last_bpos, msg);\n-            } else if self.curr_is('/') && self.nextch_is('*') {\n-                level += 1;\n-                self.bump();\n-                self.bump();\n-            } else if self.curr_is('*') && self.nextch_is('/') {\n-                level -= 1;\n-                self.bump();\n-                self.bump();\n-            } else {\n-                self.bump();\n             }\n+            let n = self.curr.unwrap();\n+            match n {\n+                '/' if self.nextch_is('*') => {\n+                    level += 1;\n+                    self.bump();\n+                }\n+                '*' if self.nextch_is('/') => {\n+                    level -= 1;\n+                    self.bump();\n+                }\n+                '\\r' => {\n+                    has_cr = true;\n+                }\n+                _ => ()\n+            }\n+            self.bump();\n         }\n \n         let res = if is_doc_comment {\n             self.with_str_from(start_bpos, |string| {\n                 // but comments with only \"*\"s between two \"/\"s are not\n                 if !is_block_non_doc_comment(string) {\n+                    let string = if has_cr {\n+                        self.translate_crlf(start_bpos, string,\n+                                            \"bare CR not allowed in block doc-comment\")\n+                    } else { string.into_maybe_owned() };\n                     Some(TokenAndSpan{\n-                            tok: token::DOC_COMMENT(str_to_ident(string)),\n+                            tok: token::DOC_COMMENT(str_to_ident(string.as_slice())),\n                             sp: codemap::mk_sp(start_bpos, self.last_pos)\n                         })\n                 } else {\n@@ -675,6 +740,10 @@ impl<'a> StringReader<'a> {\n                                 self.consume_whitespace();\n                                 return None\n                             },\n+                            '\\r' if delim == '\"' && self.curr_is('\\n') => {\n+                                self.consume_whitespace();\n+                                return None\n+                            }\n                             c => {\n                                 let last_pos = self.last_pos;\n                                 self.err_span_char(\n@@ -696,6 +765,15 @@ impl<'a> StringReader<'a> {\n                     else { \"character constant must be escaped\" },\n                     first_source_char);\n             }\n+            '\\r' => {\n+                if self.curr_is('\\n') {\n+                    self.bump();\n+                    return Some('\\n');\n+                } else {\n+                    self.err_span_(start, self.last_pos,\n+                                   \"bare CR not allowed in string, use \\\\r instead\");\n+                }\n+            }\n             _ => if ascii_only && first_source_char > '\\x7F' {\n                 let last_pos = self.last_pos;\n                 self.err_span_char(\n@@ -1042,28 +1120,45 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             let content_start_bpos = self.last_pos;\n             let mut content_end_bpos;\n+            let mut has_cr = false;\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n                     self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n                 }\n-                if self.curr_is('\"') {\n-                    content_end_bpos = self.last_pos;\n-                    for _ in range(0, hash_count) {\n-                        self.bump();\n-                        if !self.curr_is('#') {\n-                            continue 'outer;\n+                //if self.curr_is('\"') {\n+                    //content_end_bpos = self.last_pos;\n+                    //for _ in range(0, hash_count) {\n+                        //self.bump();\n+                        //if !self.curr_is('#') {\n+                            //continue 'outer;\n+                let c = self.curr.unwrap();\n+                match c {\n+                    '\"' => {\n+                        content_end_bpos = self.last_pos;\n+                        for _ in range(0, hash_count) {\n+                            self.bump();\n+                            if !self.curr_is('#') {\n+                                continue 'outer;\n+                            }\n                         }\n+                        break;\n+                    }\n+                    '\\r' => {\n+                        has_cr = true;\n                     }\n-                    break;\n+                    _ => ()\n                 }\n                 self.bump();\n             }\n             self.bump();\n-            let str_content = self.with_str_from_to(\n-                                               content_start_bpos,\n-                                               content_end_bpos,\n-                                               str_to_ident);\n+            let str_content = self.with_str_from_to(content_start_bpos, content_end_bpos, |string| {\n+                let string = if has_cr {\n+                    self.translate_crlf(content_start_bpos, string,\n+                                        \"bare CR not allowed in raw string\")\n+                } else { string.into_maybe_owned() };\n+                str_to_ident(string.as_slice())\n+            });\n             return token::LIT_STR_RAW(str_content, hash_count);\n           }\n           '-' => {"}, {"sha": "331a49c83beacbeac006dc3a5666cc0e40c475de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "patch": "@@ -288,6 +288,8 @@ mod test {\n     use owned_slice::OwnedSlice;\n     use ast;\n     use abi;\n+    use attr;\n+    use attr::AttrMetaMethods;\n     use parse::parser::Parser;\n     use parse::token::{str_to_ident};\n     use util::parser_testing::{string_to_tts, string_to_parser};\n@@ -726,4 +728,24 @@ mod test {\n }\".to_string());\n     }\n \n+    #[test] fn crlf_doc_comments() {\n+        let sess = new_parse_sess();\n+\n+        let name = \"<source>\".to_string();\n+        let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let doc = attr::first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        assert_eq!(doc.get(), \"/// doc comment\");\n+\n+        let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n+        let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n+                    .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n+        assert_eq!(docs.as_slice(), &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()]);\n+\n+        let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();\n+        let doc = attr::first_attr_value_str_by_name(item.attrs.as_slice(), \"doc\").unwrap();\n+        assert_eq!(doc.get(), \"/** doc comment\\n *  with CRLF */\");\n+    }\n }"}, {"sha": "c1e5121d6dd4e4b66f78addfef5587e15896d095", "filename": "src/test/compile-fail/lex-bare-cr-string-literal-doc-comment.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-bare-cr-string-literal-doc-comment.rs?ref=8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-cr\n+\n+/// doc comment with bare CR: '\r'\n+pub fn foo() {}\n+//~^^ ERROR: bare CR not allowed in doc-comment\n+\n+/** block doc comment with bare CR: '\r' */\n+pub fn bar() {}\n+//~^^ ERROR: bare CR not allowed in block doc-comment\n+\n+fn main() {\n+    // the following string literal has a bare CR in it\n+    let _s = \"foo\rbar\"; //~ ERROR: bare CR not allowed in string\n+\n+    // the following string literal has a bare CR in it\n+    let _s = r\"bar\rfoo\"; //~ ERROR: bare CR not allowed in raw string\n+\n+    // the following string literal has a bare CR in it\n+    let _s = \"foo\\\rbar\"; //~ ERROR: unknown character escape: \\r\n+}"}, {"sha": "c6a6f23074de0633519ae33822f4a0f18bfb024f", "filename": "src/test/run-pass/.gitattributes", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Frun-pass%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Frun-pass%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2F.gitattributes?ref=8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "patch": "@@ -0,0 +1 @@\n+lexer-crlf-line-endings-string-literal-doc-comment.rs -text"}, {"sha": "5c8db524cc2edeec729b4efb9949333bace83422", "filename": "src/test/run-pass/lexer-crlf-line-endings-string-literal-doc-comment.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexer-crlf-line-endings-string-literal-doc-comment.rs?ref=8a8e497ae786ffc032c1e68fc23da0edcf6fa5e3", "patch": "@@ -0,0 +1,44 @@\n+// ignore-tidy-cr ignore-license\r\n+// ignore-tidy-cr (repeated again because of tidy bug)\r\n+// license is ignored because tidy can't handle the CRLF here properly.\r\n+\r\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\r\n+// file at the top-level directory of this distribution and at\r\n+// http://rust-lang.org/COPYRIGHT.\r\n+//\r\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\r\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\r\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\r\n+// option. This file may not be copied, modified, or distributed\r\n+// except according to those terms.\r\n+\r\n+// NB: this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+// ignore-pretty\r\n+\r\n+/// Doc comment that ends in CRLF\r\n+pub fn foo() {}\r\n+\r\n+/** Block doc comment that\r\n+ *  contains CRLF characters\r\n+ */\r\n+pub fn bar() {}\r\n+\r\n+fn main() {\r\n+    let s = \"string\r\n+literal\";\r\n+    assert_eq!(s, \"string\\nliteral\");\r\n+\r\n+    let s = \"literal with \\\r\n+             escaped newline\";\r\n+    assert_eq!(s, \"literal with escaped newline\");\r\n+\r\n+    let s = r\"string\r\n+literal\";\r\n+    assert_eq!(s, \"string\\nliteral\");\r\n+\r\n+    // validate that our source file has CRLF endings\r\n+    let source = include_str!(\"lexer-crlf-line-endings-string-literal-doc-comment.rs\");\r\n+    assert!(source.contains(\"string\\r\\nliteral\"));\r\n+}\r"}]}