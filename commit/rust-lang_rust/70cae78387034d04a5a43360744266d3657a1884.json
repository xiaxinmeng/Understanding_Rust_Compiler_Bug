{"sha": "70cae78387034d04a5a43360744266d3657a1884", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwY2FlNzgzODcwMzRkMDRhNWE0MzM2MDc0NDI2NmQzNjU3YTE4ODQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-28T05:13:34Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: already-bound-check: account for or-patterns.\n\nAlso document `ast::Pat::walk`.", "tree": {"sha": "3f1e18c026e3ce66f3f43c1b252e58c030f4222c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f1e18c026e3ce66f3f43c1b252e58c030f4222c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70cae78387034d04a5a43360744266d3657a1884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70cae78387034d04a5a43360744266d3657a1884", "html_url": "https://github.com/rust-lang/rust/commit/70cae78387034d04a5a43360744266d3657a1884", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70cae78387034d04a5a43360744266d3657a1884/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc91e229d25b7074f5062662a089a66d627d292b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc91e229d25b7074f5062662a089a66d627d292b", "html_url": "https://github.com/rust-lang/rust/commit/dc91e229d25b7074f5062662a089a66d627d292b"}], "stats": {"total": 147, "additions": 88, "deletions": 59}, "files": [{"sha": "8e4771d26d8f3f0e8ba20af68aceb7b1e48756f5", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 73, "deletions": 47, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/70cae78387034d04a5a43360744266d3657a1884/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cae78387034d04a5a43360744266d3657a1884/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=70cae78387034d04a5a43360744266d3657a1884", "patch": "@@ -19,6 +19,7 @@ use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::TraitCandidate;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use smallvec::{smallvec, SmallVec};\n use syntax::{unwrap_or, walk_list};\n use syntax::ast::*;\n@@ -408,7 +409,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, id: NodeId) {\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n@@ -420,7 +421,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             // Create a label rib for the function.\n             this.with_label_rib(rib_kind, |this| {\n                 // Add each argument to the rib.\n-                this.resolve_params(&declaration.inputs);\n+                this.resolve_params(&declaration.inputs, id);\n \n                 visit::walk_fn_ret_ty(this, &declaration.output);\n \n@@ -1108,11 +1109,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn resolve_params(&mut self, params: &[Arg]) {\n-        let mut bindings_list = FxHashMap::default();\n-        for param in params {\n-            self.resolve_pattern(&param.pat, PatternSource::FnParam, &mut bindings_list);\n-            self.visit_ty(&param.ty);\n+    fn resolve_params(&mut self, params: &[Param], id: NodeId) {\n+        let mut bindings = FxIndexMap::default();\n+        for Param { pat, ty, .. } in params {\n+            self.resolve_pattern(pat, PatternSource::FnParam, &mut smallvec![id], &mut bindings);\n+            self.visit_ty(ty);\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n     }\n@@ -1125,7 +1126,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n+        self.resolve_pattern_top(&local.pat, PatternSource::Let);\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -1219,25 +1220,39 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n     fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n-        let mut bindings_list = FxHashMap::default();\n+        let mut bindings_list = FxIndexMap::default();\n         for pat in pats {\n-            self.resolve_pattern(pat, source, &mut bindings_list);\n+            self.resolve_pattern(pat, source, &mut smallvec![pat.id], &mut bindings_list);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n         if pats.len() > 1 {\n             self.check_consistent_bindings(pats);\n         }\n     }\n \n+    fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n+        self.resolve_pattern(pat, pat_src, &mut smallvec![pat.id], &mut FxIndexMap::default());\n+    }\n+\n     fn resolve_pattern(\n         &mut self,\n         pat: &Pat,\n         pat_src: PatternSource,\n-        // Maps idents to the node ID for the outermost pattern that binds them.\n-        bindings: &mut IdentMap<NodeId>,\n+        prod_ids: &mut SmallVec<[NodeId; 1]>,\n+        bindings: &mut FxIndexMap<Ident, NodeId>,\n+    ) {\n+        self.resolve_pattern_inner(pat, pat_src, prod_ids, bindings);\n+        visit::walk_pat(self, pat);\n+    }\n+\n+    fn resolve_pattern_inner(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        prod_ids: &mut SmallVec<[NodeId; 1]>,\n+        bindings: &mut FxIndexMap<Ident, NodeId>,\n     ) {\n         // Visit all direct subpatterns of this pattern.\n-        let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n             match pat.node {\n@@ -1247,7 +1262,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     let has_sub = sub.is_some();\n                     let res = self.try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n                         .unwrap_or_else(|| {\n-                            self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n+                            self.fresh_binding(ident, pat.id, pat_src, prod_ids, bindings)\n                         });\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n@@ -1260,59 +1275,70 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 PatKind::Struct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n+                PatKind::Or(ref ps) => {\n+                    let len_before = bindings.len();\n+                    for p in ps {\n+                        // We need to change `prod_ids.last()` at this point so that overlapping\n+                        // bindings across the summands in the or-pattern do not result in an error.\n+                        // The idea is that in `V1(a) | V2(a)`, the `a` in `V1` will be inserted\n+                        // with a different id than the one in `V2`. As a result, `V1(a) | V2(a)`\n+                        // compiles as it should. We will later check or-patterns for consistency.\n+                        prod_ids.push(p.id);\n+                        self.resolve_pattern_inner(p, pat_src, prod_ids, bindings);\n+                        prod_ids.pop();\n+                    }\n+\n+                    // We've rejected overlap in each product in the sum.\n+                    // Now we must account for the possibility that the or-pattern is a factor\n+                    // in a product. A basic case to reject here is `(V1(a) | V2(a), a)`.\n+                    let last_id = *prod_ids.last().unwrap();\n+                    bindings.values_mut().skip(len_before).for_each(|val| *val = last_id);\n+\n+                    // Prevent visiting `ps` as we've already done so above.\n+                    return false;\n+                }\n                 _ => {}\n             }\n             true\n         });\n-\n-        visit::walk_pat(self, pat);\n     }\n \n     fn fresh_binding(\n         &mut self,\n         ident: Ident,\n         pat_id: NodeId,\n-        outer_pat_id: NodeId,\n         pat_src: PatternSource,\n-        bindings: &mut IdentMap<NodeId>,\n+        prod_ids: &[NodeId],\n+        bindings: &mut FxIndexMap<Ident, NodeId>,\n     ) -> Res {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n         // later passes make about or-patterns.)\n         let ident = ident.modern_and_legacy();\n-        let mut res = Res::Local(pat_id);\n+        let res = Res::Local(pat_id);\n         match bindings.get(&ident).cloned() {\n-            Some(id) if id == outer_pat_id => {\n-                // `Variant(a, a)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(&ident.as_str()),\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::FnParam => {\n-                // `fn f(a: u8, a: u8)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(&ident.as_str()),\n-                );\n+            Some(id) if prod_ids.contains(&id) => {\n+                // We have some overlap in a product pattern, e.g. `(a, a)` which is not allowed.\n+                use ResolutionError::*;\n+                let error = match pat_src {\n+                    // `fn f(a: u8, a: u8)`:\n+                    PatternSource::FnParam => IdentifierBoundMoreThanOnceInParameterList,\n+                    // `Variant(a, a)`:\n+                    _ => IdentifierBoundMoreThanOnceInSamePattern,\n+                };\n+                self.r.report_error(ident.span, error(&ident.as_str()));\n             }\n-            Some(..) if pat_src == PatternSource::Match ||\n-                        pat_src == PatternSource::Let => {\n+            Some(..) => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                res = self.innermost_rib_bindings(ValueNS)[&ident];\n+                return self.innermost_rib_bindings(ValueNS)[&ident];\n             }\n-            Some(..) => {\n-                span_bug!(ident.span, \"two bindings with the same name from \\\n-                                       unexpected pattern source {:?}\", pat_src);\n-            }\n-            None => {\n-                // A completely fresh binding, add to the lists if it's valid.\n-                if ident.name != kw::Invalid {\n-                    bindings.insert(ident, outer_pat_id);\n-                    self.innermost_rib_bindings(ValueNS).insert(ident, res);\n-                }\n+            // A completely fresh binding, add to the lists if it's valid.\n+            None if ident.name != kw::Invalid => {\n+                bindings.insert(ident, *prod_ids.last().unwrap());\n+                self.innermost_rib_bindings(ValueNS).insert(ident, res);\n             }\n+            None => {}\n         }\n \n         res\n@@ -1810,7 +1836,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ExprKind::ForLoop(ref pat, ref iter_expr, ref block, label) => {\n                 self.visit_expr(iter_expr);\n                 self.with_rib(ValueNS, NormalRibKind, |this| {\n-                    this.resolve_pattern(pat, PatternSource::For, &mut FxHashMap::default());\n+                    this.resolve_pattern_top(pat, PatternSource::For);\n                     this.resolve_labeled_block(label, expr.id, block);\n                 });\n             }\n@@ -1847,7 +1873,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ExprKind::Closure(_, IsAsync::Async { .. }, _, ref fn_decl, ref body, _span) => {\n                 self.with_rib(ValueNS, NormalRibKind, |this| {\n                     // Resolve arguments:\n-                    this.resolve_params(&fn_decl.inputs);\n+                    this.resolve_params(&fn_decl.inputs, expr.id);\n                     // No need to resolve return type --\n                     // the outer closure return type is `FunctionRetTy::Default`.\n "}, {"sha": "8b5532df61fd27f578800294cd1d0faf5feffed5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/70cae78387034d04a5a43360744266d3657a1884/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cae78387034d04a5a43360744266d3657a1884/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=70cae78387034d04a5a43360744266d3657a1884", "patch": "@@ -561,29 +561,31 @@ impl Pat {\n         }))\n     }\n \n-    pub fn walk<F>(&self, it: &mut F) -> bool\n-    where\n-        F: FnMut(&Pat) -> bool,\n-    {\n+    /// Walk top-down and call `it` in each place where a pattern occurs\n+    /// starting with the root pattern `walk` is called on. If `it` returns\n+    /// false then we will decend no further but siblings will be processed.\n+    pub fn walk(&self, it: &mut impl FnMut(&Pat) -> bool) {\n         if !it(self) {\n-            return false;\n+            return;\n         }\n \n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n+            PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s)\n             | PatKind::Tuple(s)\n             | PatKind::Slice(s)\n-            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n-            PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n+            | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n+            PatKind::Box(s)\n+            | PatKind::Ref(s, _)\n+            | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n             | PatKind::Lit(_)\n             | PatKind::Range(..)\n             | PatKind::Ident(..)\n             | PatKind::Path(..)\n-            | PatKind::Mac(_) => true,\n+            | PatKind::Mac(_) => {},\n         }\n     }\n "}, {"sha": "1c51653db6abfeaec21385424ae7186e6011522f", "filename": "src/test/ui/shadowed/shadowing-in-the-same-pattern.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70cae78387034d04a5a43360744266d3657a1884/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cae78387034d04a5a43360744266d3657a1884/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr?ref=70cae78387034d04a5a43360744266d3657a1884", "patch": "@@ -1,8 +1,8 @@\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n+error[E0415]: identifier `a` is bound more than once in this parameter list\n   --> $DIR/shadowing-in-the-same-pattern.rs:3:10\n    |\n LL | fn f((a, a): (isize, isize)) {}\n-   |          ^ used in a pattern more than once\n+   |          ^ used as parameter more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n   --> $DIR/shadowing-in-the-same-pattern.rs:6:13\n@@ -12,4 +12,5 @@ LL |     let (a, a) = (1, 1);\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0416`.\n+Some errors have detailed explanations: E0415, E0416.\n+For more information about an error, try `rustc --explain E0415`."}]}