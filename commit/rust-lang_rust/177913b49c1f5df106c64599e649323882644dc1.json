{"sha": "177913b49c1f5df106c64599e649323882644dc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NzkxM2I0OWMxZjVkZjEwNmM2NDU5OWU2NDkzMjM4ODI2NDRkYzE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-23T23:39:13Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-30T02:48:56Z"}, "message": "rustc: track the Span's of definitions across crates.", "tree": {"sha": "f78febf0d448a7a92521b415cb3f3c26661d7ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f78febf0d448a7a92521b415cb3f3c26661d7ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/177913b49c1f5df106c64599e649323882644dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/177913b49c1f5df106c64599e649323882644dc1", "html_url": "https://github.com/rust-lang/rust/commit/177913b49c1f5df106c64599e649323882644dc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/177913b49c1f5df106c64599e649323882644dc1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa0005f2d5a9081597867b383c9b2d0b21569b88", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0005f2d5a9081597867b383c9b2d0b21569b88", "html_url": "https://github.com/rust-lang/rust/commit/fa0005f2d5a9081597867b383c9b2d0b21569b88"}], "stats": {"total": 230, "additions": 123, "deletions": 107}, "files": [{"sha": "6ce6f6896df29cca0134a636ec79d8f2b01c03dd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -760,47 +760,40 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n-        let sp = match self.find(id) {\n-            Some(NodeItem(item)) => item.span,\n-            Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitItem(trait_method)) => trait_method.span,\n-            Some(NodeImplItem(ref impl_item)) => impl_item.span,\n-            Some(NodeVariant(variant)) => variant.span,\n-            Some(NodeField(field)) => field.span,\n-            Some(NodeExpr(expr)) => expr.span,\n-            Some(NodeStmt(stmt)) => stmt.span,\n-            Some(NodeTy(ty)) => ty.span,\n-            Some(NodeTraitRef(tr)) => tr.path.span,\n-            Some(NodeLocal(pat)) => pat.span,\n-            Some(NodePat(pat)) => pat.span,\n-            Some(NodeBlock(block)) => block.span,\n-            Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n-            Some(NodeTyParam(ty_param)) => ty_param.span,\n-            Some(NodeVisibility(&Visibility::Restricted { ref path, .. })) => path.span,\n-            _ => return None,\n-        };\n-        Some(sp)\n-    }\n-\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n-        self.opt_span(id)\n-            .unwrap_or_else(|| bug!(\"AstMap.span: could not find span for id {:?}\", id))\n+        match self.find_entry(id) {\n+            Some(EntryItem(_, item)) => item.span,\n+            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, variant)) => variant.span,\n+            Some(EntryField(_, field)) => field.span,\n+            Some(EntryExpr(_, expr)) => expr.span,\n+            Some(EntryStmt(_, stmt)) => stmt.span,\n+            Some(EntryTy(_, ty)) => ty.span,\n+            Some(EntryTraitRef(_, tr)) => tr.path.span,\n+            Some(EntryLocal(_, pat)) => pat.span,\n+            Some(EntryPat(_, pat)) => pat.span,\n+            Some(EntryBlock(_, block)) => block.span,\n+            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+\n+            Some(RootCrate) => self.krate().span,\n+            Some(RootInlinedParent(parent)) => parent.body.span,\n+            Some(NotPresent) | None => {\n+                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+            }\n+        }\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n \n-    pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if let Some(node_id) = self.as_local_node_id(def_id) {\n-            self.opt_span(node_id).unwrap_or(fallback)\n-        } else {\n-            fallback\n-        }\n-    }\n-\n     pub fn node_to_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, true)\n     }"}, {"sha": "484e2f1535e7aaaacdb63d01afe454d61976ce13", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -260,6 +260,7 @@ pub struct ExternCrate {\n pub trait CrateStore<'tcx> {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def>;\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n@@ -404,6 +405,7 @@ pub struct DummyCrateStore;\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span { bug!(\"def_span\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }"}, {"sha": "b14148cf38f99ff1c8ccb36d574497a93f12a483", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -291,10 +291,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           expected.ty,\n                                           found.ty));\n \n-                match\n-                    self.map.as_local_node_id(expected.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(expected.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a default was defined here...\");\n                     }\n@@ -308,10 +305,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     expected.origin_span,\n                     \"...that was applied to an unconstrained type variable here\");\n \n-                match\n-                    self.map.as_local_node_id(found.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(found.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a second default was defined here...\");\n                     }"}, {"sha": "7387a48c98984a216fd84e3cb2dc43a26e621b0f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -2370,6 +2370,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn def_span(self, def_id: DefId) -> Span {\n+        if let Some(id) = self.map.as_local_node_id(def_id) {\n+            self.map.span(id)\n+        } else {\n+            self.sess.cstore.def_span(&self.sess, def_id)\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)"}, {"sha": "b0a1b3498545fad7ba47b133cab54bdde9862c67", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -496,8 +496,8 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n         },\n \n         ref ty => {\n-            let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            span_bug!(opt_span.unwrap_or(DUMMY_SP),\n+            let span = origin_id.map_or(DUMMY_SP, |id| tcx.map.span(id));\n+            span_bug!(span,\n                       \"type {:?} ({:?}) is not fragmentable\",\n                       parent_ty, ty);\n         }"}, {"sha": "b055b043723e4ab769304d1a249fa2feff74cd38", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -1006,11 +1006,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                got {:?}\",\n                                               node);\n \n-                        // Point to what was found, if there's an accessible span.\n-                        match tcx.map.opt_span(nodeid) {\n-                            Some(sp) => tcx.sess.span_fatal(sp, &message),\n-                            None => tcx.sess.fatal(&message),\n-                        }\n+                        tcx.sess.span_fatal(tcx.map.span(nodeid), &message)\n                     }\n                 }\n             }"}, {"sha": "c41c3afb83ed5682aab1fd7cdaeac2ddda70ad49", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -32,7 +32,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::new_parser_from_source_str;\n use syntax::symbol::Symbol;\n-use syntax_pos::mk_sp;\n+use syntax_pos::{mk_sp, Span};\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -43,6 +43,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_def(def.index)\n     }\n \n+    fn def_span(&self, sess: &Session, def: DefId) -> Span {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).get_span(def.index, sess)\n+    }\n+\n     fn stability(&self, def: DefId) -> Option<attr::Stability> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_stability(def.index)\n@@ -383,20 +388,23 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let local_span = mk_sp(lo, parser.prev_span.hi);\n \n         // Mark the attrs as used\n-        for attr in &def.attrs {\n+        let attrs = data.get_item_attrs(id.index);\n+        for attr in &attrs {\n             attr::mark_used(attr);\n         }\n \n+        let name = data.def_key(id.index).disambiguated_data.data\n+            .get_opt_name().expect(\"no name in load_macro\");\n         sess.imported_macro_spans.borrow_mut()\n-            .insert(local_span, (def.name.as_str().to_string(), def.span));\n+            .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n         LoadedMacro::MacroRules(ast::MacroDef {\n-            ident: ast::Ident::with_empty_ctxt(def.name),\n+            ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             imported_from: None, // FIXME\n-            allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n-            attrs: def.attrs,\n+            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+            attrs: attrs,\n             body: body,\n         })\n     }"}, {"sha": "088364f98346a7596d2e00a6bf7abc698f280912", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -25,6 +25,7 @@ use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n@@ -47,8 +48,9 @@ use syntax_pos::{self, Span, BytePos, Pos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n-    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     cdata: Option<&'a CrateMetadata>,\n+    sess: Option<&'a Session>,\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n \n@@ -61,22 +63,21 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n /// Abstract over the various ways one can create metadata decoders.\n pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        None\n-    }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        None\n-    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n+    fn sess(self) -> Option<&'a Session> { None }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n             max: NodeId::from_u32(u32::MAX),\n         };\n+        let tcx = self.tcx();\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n-            tcx: self.tcx(),\n+            sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n+            tcx: tcx,\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0,\n@@ -104,6 +105,18 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n     }\n }\n \n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn sess(self) -> Option<&'a Session> {\n+        Some(&self.1)\n+    }\n+}\n+\n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n@@ -280,8 +293,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n \n-        let tcx = if let Some(tcx) = self.tcx {\n-            tcx\n+        let sess = if let Some(sess) = self.sess {\n+            sess\n         } else {\n             return Ok(syntax_pos::mk_sp(lo, hi));\n         };\n@@ -299,7 +312,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             (lo, hi)\n         };\n \n-        let imported_filemaps = self.cdata().imported_filemaps(&tcx.sess.codemap());\n+        let imported_filemaps = self.cdata().imported_filemaps(&sess.codemap());\n         let filemap = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same filemap.\n@@ -528,6 +541,10 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n                          tcx: TyCtxt<'a, 'tcx, 'tcx>)"}, {"sha": "6abc81d74dc0ad041699328bbe440dd4242dbd80", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -275,6 +275,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n             visibility: enum_vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: self.lazy_seq(variant.fields.iter().map(|f| {\n@@ -313,6 +314,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Mod(self.lazy(&data)),\n             visibility: vis.simplify(),\n+            span: self.lazy(&md.inner),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n@@ -393,6 +395,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Field,\n             visibility: field.vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&variant_data.fields()[field_index].attrs),\n             children: LazySeq::empty(),\n@@ -426,6 +429,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n             visibility: struct_vis.simplify(),\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -492,6 +496,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: trait_item.vis.simplify(),\n+            span: self.lazy(&ast_item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -580,6 +585,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: impl_item.vis.simplify(),\n+            span: self.lazy(&ast_item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&ast_item.attrs),\n             children: LazySeq::empty(),\n@@ -743,6 +749,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: item.vis.simplify(),\n+            span: self.lazy(&item.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n@@ -850,18 +857,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n         let def_id = self.tcx.map.local_def_id(macro_def.id);\n-        let macro_def = MacroDef {\n-            name: macro_def.name,\n-            attrs: macro_def.attrs.to_vec(),\n-            span: macro_def.span,\n-            body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n-        };\n         Entry {\n-            kind: EntryKind::MacroDef(self.lazy(&macro_def)),\n+            kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n+                body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n+            })),\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&macro_def.span),\n             def_key: self.encode_def_key(def_id),\n \n-            attributes: LazySeq::empty(),\n+            attributes: self.encode_attributes(&macro_def.attrs),\n             children: LazySeq::empty(),\n             stability: None,\n             deprecation: None,\n@@ -960,6 +964,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: kind,\n             visibility: nitem.vis.simplify(),\n+            span: self.lazy(&nitem.span),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&nitem.attrs),\n             children: LazySeq::empty(),\n@@ -1038,9 +1043,11 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -1069,6 +1076,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         Entry {\n             kind: EntryKind::Closure(self.lazy(&data)),\n             visibility: ty::Visibility::Public,\n+            span: self.lazy(&tcx.def_span(def_id)),\n             def_key: self.encode_def_key(def_id),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),\n             children: LazySeq::empty(),\n@@ -1163,11 +1171,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let all_filemaps = codemap.files.borrow();\n         self.lazy_seq_ref(all_filemaps.iter()\n             .filter(|filemap| {\n-                // No need to export empty filemaps, as they can't contain spans\n-                // that need translation.\n-                // Also no need to re-export imported filemaps, as any downstream\n+                // No need to re-export imported filemaps, as any downstream\n                 // crate will import them from their original source.\n-                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+                !filemap.is_imported()\n             })\n             .map(|filemap| &**filemap))\n     }"}, {"sha": "c2acb2e0d7002694911b5906d8d5e384402addd4", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -197,18 +197,11 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct MacroDef {\n-    pub name: ast::Name,\n-    pub attrs: Vec<ast::Attribute>,\n-    pub span: Span,\n-    pub body: String,\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,\n     pub visibility: ty::Visibility,\n+    pub span: Lazy<Span>,\n     pub def_key: Lazy<hir::map::DefKey>,\n     pub attributes: LazySeq<ast::Attribute>,\n     pub children: LazySeq<DefIndex>,\n@@ -257,6 +250,11 @@ pub struct ModData {\n     pub reexports: LazySeq<def::Export>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MacroDef {\n+    pub body: String,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,"}, {"sha": "521dd7530beeabcbf79d1a663091a777235c966b", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -69,7 +69,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-    let span = ccx.tcx().map.def_id_span(def_id, DUMMY_SP);\n+    let span = ccx.tcx().def_span(def_id);\n     let (file, line) = if span != DUMMY_SP {\n         let loc = span_start(ccx, span);\n         (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)"}, {"sha": "7cac9172a9c8b18975ef6ad3233b77e1bf048d8f", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -79,7 +79,7 @@ pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n     });\n \n     // Try to get some span information, if we have an inlined item.\n-    let definition_span = cx.tcx().map.def_id_span(def_id, syntax_pos::DUMMY_SP);\n+    let definition_span = cx.tcx().def_span(def_id);\n \n     (containing_scope, definition_span)\n }"}, {"sha": "bad014df6fd2a886b49d77ebbca7e5b497ad71da", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -1222,8 +1222,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.tcx().associated_items(b.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n-                .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n-                .and_then(|node_id| self.tcx().map.opt_span(node_id))\n+                .and_then(|item| self.tcx().map.span_if_local(item.def_id))\n             });\n \n             let mut err = struct_span_err!("}, {"sha": "6fe268bdb2c775d658ef39fcbd6d7d5b98193225", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -21,7 +21,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -59,7 +59,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = ccx.tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+            let span = ccx.tcx.def_span(drop_impl_did);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n@@ -88,7 +88,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let named_type = tcx.item_type(self_type_did);\n         let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n-        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+        let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n             infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n@@ -173,7 +173,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n \n     let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n-    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, syntax_pos::DUMMY_SP);\n+    let drop_impl_span = tcx.def_span(drop_impl_did);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold."}, {"sha": "bcf18ff66fad3d1b45f3ed9fe352410a8e11bcf5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n                         let item = self.associated_item(trait_did, item_name).unwrap();\n-                        let item_span = self.tcx.map.def_id_span(item.def_id, span);\n+                        let item_span = self.tcx.def_span(item.def_id);\n                         span_note!(err,\n                                    item_span,\n                                    \"candidate #{} is defined in the trait `{}`\","}, {"sha": "e25b6d56112c5e7f09a2e617fceb59234c04e3c1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -1754,7 +1754,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let item_predicates = self.tcx.item_predicates(def_id);\n                 let bounds = item_predicates.instantiate(self.tcx, substs);\n \n-                let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n+                let span = self.tcx.def_span(def_id);\n                 for predicate in bounds.predicates {\n                     // Change the predicate to refer to the type variable,\n                     // which will be the concrete type, instead of the TyAnon."}, {"sha": "ae336a2f79eacf942fa3ec27b005a5e11e7ff410", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -188,7 +188,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n-                    reject_shadowing_type_parameters(fcx.tcx, span, item.def_id);\n+                    reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let method_ty = fcx.tcx.item_type(item.def_id);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n@@ -581,7 +581,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n+fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.item_generics(def_id);\n     let parent = tcx.item_generics(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.types\n@@ -592,17 +592,12 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, def_id: DefId) {\n     for method_param in &generics.types {\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n-            let shadow_node_id = tcx.map.as_local_node_id(method_param.def_id).unwrap();\n-            let type_span = match tcx.map.opt_span(shadow_node_id) {\n-                Some(osp) => osp,\n-                None => span\n-            };\n+            let type_span = tcx.def_span(method_param.def_id);\n \n             // The expectation here is that the original trait declaration is\n             // local so it should be okay to just unwrap everything.\n-            let trait_def_id = impl_params.get(&method_param.name).unwrap();\n-            let trait_node_id = tcx.map.as_local_node_id(*trait_def_id).unwrap();\n-            let trait_decl_span = tcx.map.opt_span(trait_node_id).unwrap();\n+            let trait_def_id = impl_params[&method_param.name];\n+            let trait_decl_span = tcx.def_span(trait_def_id);\n             error_194(tcx, type_span, trait_decl_span, method_param.name);\n         }\n     }"}, {"sha": "56de75995fd2e820bc4929c1a74eeb51ebbaa82f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177913b49c1f5df106c64599e649323882644dc1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=177913b49c1f5df106c64599e649323882644dc1", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::DefIdMap;\n use std::cell::Cell;\n \n use syntax::ast;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             }\n             ResolvingClosure(did) |\n             ResolvingAnonTy(did) => {\n-                tcx.map.def_id_span(did, DUMMY_SP)\n+                tcx.def_span(did)\n             }\n             ResolvingDeferredObligation(span) => span\n         }"}]}