{"sha": "6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDYzYjc1NjJmNmZmMTVkYjNiYzkwNzE3YzNjMmRhM2Q2OTY3ZGQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-16T01:48:30Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-16T01:48:30Z"}, "message": "Hold an Lvalue for the return pointer in a frame.\n\nPreviously ReturnPointer was just the first slot in the locals array,\nwhich had type `Vec<Pointer>`. But after my recent refactoring, locals\nis `Vec<Value>` and it became increasingly hacky to pull a pointer out\nof the first slot to be the value. Besides, that hack wouldn't allow\nReturnPointer to ever be an `Lvalue::Local`, referring directly to a\nlocal on a higher stack frame.\n\nNow ReturnPointer has no presence in the locals array, instead being\nupgraded to its own field on `Frame`.\n\nThis introduces a couple of new hacks, detailed by some of my FIXME\ncomments, so that I could get the tests passing again and commit. More\ncommits coming soon should clean up these hacks without much trouble,\nand overall I feel that the code is converging on a cleaner, more\nefficient design.", "tree": {"sha": "67562398556322c1f803284f098b84098d781c07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67562398556322c1f803284f098b84098d781c07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "html_url": "https://github.com/rust-lang/rust/commit/6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ae07be075d313f077c383927bc1daa45c752b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ae07be075d313f077c383927bc1daa45c752b0", "html_url": "https://github.com/rust-lang/rust/commit/00ae07be075d313f077c383927bc1daa45c752b0"}], "stats": {"total": 260, "additions": 186, "deletions": 74}, "files": [{"sha": "7691d2a047149f9f90fba5d237f60f18e4f8e6b0", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 164, "deletions": 53, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::indexed_vec::Idx;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n-use std::iter;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n@@ -71,14 +70,18 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub span: codemap::Span,\n \n     ////////////////////////////////////////////////////////////////////////////////\n-    // Return pointer and local allocations\n+    // Return lvalue and locals\n     ////////////////////////////////////////////////////////////////////////////////\n \n     /// The block to return to when returning from the current stack frame\n     pub return_to_block: StackPopCleanup,\n \n-    /// The list of locals for the current function, stored in order as\n-    /// `[return_ptr, arguments..., variables..., temporaries...]`.\n+    /// The location where the result of the current stack frame should be written to.\n+    pub return_lvalue: Lvalue,\n+\n+    /// The list of locals for this stack frame, stored in order as\n+    /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Value`s, which\n+    /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n     pub locals: Vec<Value>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n@@ -101,10 +104,11 @@ pub enum Lvalue {\n         extra: LvalueExtra,\n     },\n \n-    /// An lvalue referring to a value on the stack.\n+    /// An lvalue referring to a value on the stack. Represented by a stack frame index paired with\n+    /// a Mir local index.\n     Local {\n         frame: usize,\n-        local: usize,\n+        local: mir::Local,\n     }\n \n     // TODO(solson): Static/Const? None/Never?\n@@ -345,33 +349,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return_lvalue: Lvalue,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n-        let local_tys = mir.local_decls.iter().map(|a| a.ty);\n-\n         ::log_settings::settings().indentation += 1;\n \n-        // FIXME(solson)\n-        let return_ptr = return_lvalue.to_ptr();\n+        // Skip 1 because we don't make a slot for the ReturnPointer, which is local number zero.\n+        // The ReturnPointer is represented by `return_lvalue`, and points to an allocation or a\n+        // local in a higher stack frame.\n+        //\n+        // FIXME(solson): Write this in a way that doesn't assume ReturnPointer is local 0.\n+        let local_tys = mir.local_decls.iter().map(|a| a.ty).skip(1);\n \n-        // directly change the first allocation (the return value) to *be* the allocation where the\n-        // caller stores the result\n-        let locals: EvalResult<'tcx, Vec<Value>> = iter::once(Ok(Value::ByRef(return_ptr))).chain(local_tys.skip(1).map(|ty| {\n+        let locals: EvalResult<'tcx, Vec<Value>> = local_tys.map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             let align = self.type_align_with_substs(ty, substs);\n \n             // FIXME(solson)\n             self.memory.allocate(size, align).map(Value::ByRef)\n-        })).collect();\n+        }).collect();\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_to_block: return_to_block,\n+            return_lvalue: return_lvalue,\n             locals: locals?,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n             stmt: 0,\n         });\n+\n         if self.stack.len() > self.stack_limit {\n             Err(EvalError::StackFrameLimitReached)\n         } else {\n@@ -410,7 +416,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let overflowed = self.intrinsic_overflowing(op, left, right, dest)?;\n \n         // FIXME(solson)\n-        let dest = dest.to_ptr();\n+        let dest = self.force_allocation(dest)?.to_ptr();\n \n         let offset = tup_layout.offsets[1].bytes() as isize;\n         self.memory.write_bool(dest.offset(offset), overflowed)\n@@ -439,7 +445,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n         // FIXME(solson)\n-        let dest = dest.to_ptr();\n+        let dest = self.force_allocation(dest)?.to_ptr();\n \n         for (offset, operand) in offsets.into_iter().zip(operands) {\n             let value = self.eval_operand(operand)?;\n@@ -508,6 +514,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let discr_offset = variants[variant].offsets[0].bytes() as isize;\n \n                             // FIXME(solson)\n+                            let dest = self.force_allocation(dest)?;\n                             let discr_dest = (dest.to_ptr()).offset(discr_offset);\n \n                             self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n@@ -552,7 +559,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n \n                                 // FIXME(solson)\n-                                let dest = dest.to_ptr();\n+                                let dest = self.force_allocation(dest)?.to_ptr();\n \n                                 let dest = dest.offset(offset.bytes() as isize);\n                                 try!(self.memory.write_isize(dest, 0));\n@@ -568,8 +575,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n                             let size = discr.size().bytes() as usize;\n \n-                            // FIXME(solson)\n-                            let dest = dest.to_ptr();\n+                            // easy FIXME(solson)\n+                            let dest = self.force_allocation(dest)?.to_ptr();\n \n                             if signed {\n                                 self.memory.write_int(dest, val as i64, size)?;\n@@ -594,7 +601,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n@@ -612,12 +619,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Ref(_, _, ref lvalue) => {\n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 let lvalue = self.eval_lvalue(lvalue)?;\n \n                 // FIXME(solson)\n-                let (ptr, extra) = lvalue.to_ptr_and_extra();\n+                let (ptr, extra) = self.force_allocation(lvalue)?.to_ptr_and_extra();\n \n                 self.memory.write_ptr(dest, ptr)?;\n                 let extra_ptr = dest.offset(self.memory.pointer_size() as isize);\n@@ -632,7 +639,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 let size = self.type_size(ty);\n                 let align = self.type_align(ty);\n@@ -642,7 +649,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Cast(kind, ref operand, cast_ty) => {\n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n                 use rustc::mir::repr::CastKind::*;\n@@ -792,7 +799,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => Ok(Value::ByRef(self.eval_lvalue(lvalue)?.to_ptr())),\n+            Consume(ref lvalue) => {\n+                let val = match self.eval_lvalue(lvalue)? {\n+                    Lvalue::Ptr { ptr, extra } => {\n+                        assert_eq!(extra, LvalueExtra::None);\n+                        Value::ByRef(ptr)\n+                    }\n+                    Lvalue::Local { frame, local } => {\n+                        self.stack[frame].get_local(local)\n+                    }\n+                };\n+                Ok(val)\n+            }\n \n             Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal;\n@@ -835,18 +853,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         match *lvalue {\n-            Local(i) => {\n-                // FIXME(solson): Switch to the following code to start enabling lvalues referring\n-                // to `Value`s placed on the locals stack instead of in `Memory`:\n-                //\n-                //     let frame_index = self.stack.len();\n-                //     Ok(Lvalue::Local { frame: frame_index, local: i.index() })\n-                //\n-                let ptr = match self.frame().locals[i.index()] {\n-                    Value::ByRef(p) => p,\n-                    _ => bug!(),\n-                };\n-                Ok(Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None })\n+            Local(i) if self.frame().mir.local_kind(i) == mir::LocalKind::ReturnPointer => {\n+                Ok(self.frame().return_lvalue)\n+            }\n+\n+            Local(local) => {\n+                let frame = self.stack.len() - 1;\n+                Ok(Lvalue::Local { frame: frame, local: local })\n             }\n \n             Static(def_id) => {\n@@ -870,6 +883,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         proj: &mir::LvalueProjection<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue> {\n         let base = self.eval_lvalue(&proj.base)?;\n+\n+        // FIXME(solson): Is this always necessary?\n+        let base = self.force_allocation(base)?;\n+\n         let (base_ptr, base_extra) = base.to_ptr_and_extra();\n         let base_ty = self.lvalue_ty(&proj.base);\n         let base_layout = self.type_layout(base_ty);\n@@ -999,6 +1016,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    fn force_allocation(&mut self, lvalue: Lvalue) -> EvalResult<'tcx, Lvalue> {\n+        let new_lvalue = match lvalue {\n+            Lvalue::Local { frame, local } => {\n+                let ptr = match self.stack[frame].get_local(local) {\n+                    Value::ByRef(ptr) => ptr,\n+                    val => {\n+                        let ty = self.stack[frame].mir.local_decls[local].ty;\n+                        let substs = self.stack[frame].substs;\n+                        let ptr = self.alloc_ptr(ty, substs)?;\n+                        self.write_value_to_ptr(val, ptr, ty)?;\n+                        self.stack[frame].set_local(local, Value::ByRef(ptr));\n+                        ptr\n+                    }\n+                };\n+                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+            }\n+            Lvalue::Ptr { .. } => lvalue,\n+        };\n+        Ok(new_lvalue)\n+    }\n+\n     // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n     // remove it as soon as PrimVal can represent fat pointers.\n     fn value_to_ptr_dont_use(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n@@ -1033,8 +1071,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n             },\n \n-            // TODO(solson): Sanity-check the primval type against the input type.\n-            Value::ByVal(primval) => Ok(primval),\n+            // FIXME(solson): This unnecessarily allocates to work around a new issue my `Value`\n+            // locals refactoring introduced. There is code that calls this function and expects to\n+            // get a PrimVal reflecting the specific type that it asked for, e.g. `PrimVal::Bool`\n+            // when it was asking for `TyBool`. This used to always work because it would go\n+            // through `read_value` which does the right thing.\n+            //\n+            // This is the comment and implementation from before my refactor:\n+            //\n+            //     TODO(solson): Sanity-check the primval type against the input type.\n+            //     Value::ByVal(primval) => Ok(primval),\n+            //\n+            // Turns out sanity-checking isn't enough now, and we need conversion.\n+            //\n+            // Now that we can possibly be reading a `ByVal` straight out of the locals vec, if the\n+            // user did something tricky like transmuting a `u8` to a `bool`, then we'll have a\n+            // `PrimVal::U8` and need to convert to `PrimVal::Bool`.\n+            //\n+            // I want to avoid handling the full set of conversions between `PrimVal`s, so for now\n+            // I will use this hack. I have a plan to change the representation of `PrimVal` to be\n+            // more like a small piece of memory tagged with a `PrimValKind`, which should make the\n+            // conversion easy and make the problem solveable using code already in `Memory`.\n+            Value::ByVal(primval) => {\n+                let substs = self.substs();\n+                let ptr = self.alloc_ptr(ty, substs)?;\n+                self.memory.write_primval(ptr, primval)?;\n+                self.value_to_primval(Value::ByRef(ptr), ty)\n+            }\n+\n             Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n         }\n     }\n@@ -1044,10 +1108,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue,\n         val: PrimVal,\n     ) -> EvalResult<'tcx, ()> {\n-        // FIXME(solson)\n-        let dest = dest.to_ptr();\n-\n-        self.memory.write_primval(dest, val)\n+        match dest {\n+            Lvalue::Ptr { ptr, extra } => {\n+                assert_eq!(extra, LvalueExtra::None);\n+                self.memory.write_primval(ptr, val)\n+            }\n+            Lvalue::Local { frame, local } => {\n+                self.stack[frame].set_local(local, Value::ByVal(val));\n+                Ok(())\n+            }\n+        }\n     }\n \n     fn write_value(\n@@ -1056,9 +1126,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n-        // FIXME(solson)\n-        let dest = dest.to_ptr();\n-        self.write_value_to_ptr(value, dest, dest_ty)\n+        match dest {\n+            Lvalue::Ptr { ptr, extra } => {\n+                assert_eq!(extra, LvalueExtra::None);\n+                self.write_value_to_ptr(value, ptr, dest_ty)?;\n+            }\n+            Lvalue::Local { frame, local } => {\n+                if let Value::ByRef(src_ptr) = value {\n+                    let dest_ptr = if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n+                        ptr\n+                    } else {\n+                        let substs = self.substs();\n+                        let ptr = self.alloc_ptr(dest_ty, substs)?;\n+                        self.stack[frame].set_local(local, Value::ByRef(ptr));\n+                        ptr\n+                    };\n+                    self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                } else {\n+                    // FIXME(solson): Is it safe to free the existing local here?\n+                    self.stack[frame].set_local(local, value);\n+                }\n+            }\n+        }\n+        Ok(())\n     }\n \n     fn write_value_to_ptr(\n@@ -1276,18 +1366,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n+    fn get_local(&self, local: mir::Local) -> Value {\n+        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n+        self.locals[local.index() - 1]\n+    }\n+\n+    fn set_local(&mut self, local: mir::Local, value: Value) {\n+        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n+        self.locals[local.index() - 1] = value;\n+    }\n+}\n+\n impl Lvalue {\n     fn from_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n     }\n \n     fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n-        if let Lvalue::Ptr { ptr, extra } = self {\n-            (ptr, extra)\n-        } else {\n-            // FIXME(solson): This isn't really a bug, but it's unhandled until I finish\n-            // refactoring.\n-            bug!(\"from_ptr: Not an Lvalue::Ptr\");\n+        match self {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n+\n         }\n     }\n \n@@ -1348,7 +1448,18 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n     for _ in 0..step_limit {\n         match ecx.step() {\n-            Ok(true) => {}\n+            Ok(true) => {\n+                let limit = 5;\n+                for (frame_index, frame) in ecx.stack.iter().enumerate() {\n+                    trace!(\"frame[{}]:\", frame_index);\n+                    for (i, v) in frame.locals.iter().enumerate().take(limit) {\n+                        trace!(\"  _{}: {:?}\", i + 1, v);\n+                    }\n+                    if frame.locals.len() > limit {\n+                        trace!(\"  ...\");\n+                    }\n+                }\n+            }\n             Ok(false) => return,\n             Err(e) => {\n                 report(tcx, &ecx, e);"}, {"sha": "236bb5ca00bf7bae46051367374228c1e6405962", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "patch": "@@ -148,7 +148,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"init\" => {\n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                 self.memory.write_repeat(dest, 0, size)?;\n@@ -265,7 +265,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"uninit\" => {\n                 // FIXME(solson)\n-                let dest = dest.to_ptr();\n+                let dest = self.force_allocation(dest)?.to_ptr();\n \n                 let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                 self.memory.mark_definedness(dest, size, false)?;"}, {"sha": "171ba9590e5c3069f1a8f80cf9c99a5e61ed612b", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "patch": "@@ -41,7 +41,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n+                // FIXME(solson)\n+                let lvalue = self.eval_lvalue(discr)?;\n+                let lvalue = self.force_allocation(lvalue)?;\n+\n+                let discr_ptr = lvalue.to_ptr();\n                 let discr_ty = self.lvalue_ty(discr);\n                 let discr_val = self.read_value(discr_ptr, discr_ty)?;\n                 let discr_prim = self.value_to_primval(discr_val, discr_ty)?;\n@@ -62,7 +66,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n-                let adt_ptr = self.eval_lvalue(discr)?.to_ptr();\n+                // FIXME(solson)\n+                let lvalue = self.eval_lvalue(discr)?;\n+                let lvalue = self.force_allocation(lvalue)?;\n+\n+                let adt_ptr = lvalue.to_ptr();\n                 let adt_ty = self.lvalue_ty(discr);\n                 let discr_val = self.read_discriminant_value(adt_ptr, adt_ty)?;\n                 let matching = adt_def.variants.iter()\n@@ -102,7 +110,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Drop { ref location, target, .. } => {\n-                let ptr = self.eval_lvalue(location)?.to_ptr();\n+                // FIXME(solson)\n+                let lvalue = self.eval_lvalue(location)?;\n+                let lvalue = self.force_allocation(lvalue)?;\n+\n+                let ptr = lvalue.to_ptr();\n                 let ty = self.lvalue_ty(location);\n                 self.drop(ptr, ty)?;\n                 self.goto_block(target);\n@@ -202,9 +214,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return_to_block\n                 )?;\n \n-                for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n-                    // argument start at index 1, since index 0 is reserved for the return allocation\n-                    let dest = self.frame().locals[i + 1];\n+                let arg_locals = self.frame().mir.args_iter();\n+                for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                    // FIXME(solson)\n+                    let dest = self.frame().get_local(arg_local);\n \n                     // FIXME(solson)\n                     let dest = match dest {"}, {"sha": "d6eb3f3ae02835dfd309bbf436ace7fa7b102605", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c463b7562f6ff15db3bc90717c3c2da3d6967dd/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "patch": "@@ -3,7 +3,7 @@\n \n fn bar(i: i32) {\n     if i < 1000 {\n-        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 1 bytes are free of the 1000 byte memory\n+        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 1000 byte memory\n         //~^NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n@@ -25,18 +25,6 @@ fn bar(i: i32) {\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n-        //~|NOTE inside call to bar\n     }\n }\n "}]}