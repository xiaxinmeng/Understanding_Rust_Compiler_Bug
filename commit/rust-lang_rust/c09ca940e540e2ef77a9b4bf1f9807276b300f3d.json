{"sha": "c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOWNhOTQwZTU0MGUyZWY3N2E5YjRiZjFmOTgwNzI3NmIzMDBmM2Q=", "commit": {"author": {"name": "Arcterus", "email": "Arcterus@mail.com", "date": "2014-02-04T03:14:40Z"}, "committer": {"name": "Arcterus", "email": "Arcterus@mail.com", "date": "2014-02-06T18:04:26Z"}, "message": "getopts: replaced base functions with those from group", "tree": {"sha": "dfa2ce7e617bd3985b47df76b2563ba3f976179a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa2ce7e617bd3985b47df76b2563ba3f976179a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "html_url": "https://github.com/rust-lang/rust/commit/c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/comments", "author": {"login": "Arcterus", "id": 829813, "node_id": "MDQ6VXNlcjgyOTgxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/829813?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arcterus", "html_url": "https://github.com/Arcterus", "followers_url": "https://api.github.com/users/Arcterus/followers", "following_url": "https://api.github.com/users/Arcterus/following{/other_user}", "gists_url": "https://api.github.com/users/Arcterus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arcterus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arcterus/subscriptions", "organizations_url": "https://api.github.com/users/Arcterus/orgs", "repos_url": "https://api.github.com/users/Arcterus/repos", "events_url": "https://api.github.com/users/Arcterus/events{/privacy}", "received_events_url": "https://api.github.com/users/Arcterus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Arcterus", "id": 829813, "node_id": "MDQ6VXNlcjgyOTgxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/829813?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Arcterus", "html_url": "https://github.com/Arcterus", "followers_url": "https://api.github.com/users/Arcterus/followers", "following_url": "https://api.github.com/users/Arcterus/following{/other_user}", "gists_url": "https://api.github.com/users/Arcterus/gists{/gist_id}", "starred_url": "https://api.github.com/users/Arcterus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Arcterus/subscriptions", "organizations_url": "https://api.github.com/users/Arcterus/orgs", "repos_url": "https://api.github.com/users/Arcterus/repos", "events_url": "https://api.github.com/users/Arcterus/events{/privacy}", "received_events_url": "https://api.github.com/users/Arcterus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9752c63035bc78f624c5fa1ca644f15db4e2a0df", "url": "https://api.github.com/repos/rust-lang/rust/commits/9752c63035bc78f624c5fa1ca644f15db4e2a0df", "html_url": "https://github.com/rust-lang/rust/commit/9752c63035bc78f624c5fa1ca644f15db4e2a0df"}], "stats": {"total": 968, "additions": 463, "deletions": 505}, "files": [{"sha": "b3151ac99b249b7f94acc762444ba6fd9bf2a37f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -20,7 +20,7 @@ use std::os;\n use std::io;\n use std::io::fs;\n \n-use getopts::groups::{optopt, optflag, reqopt};\n+use getopts::{optopt, optflag, reqopt};\n use extra::test;\n \n use common::config;\n@@ -49,7 +49,7 @@ pub fn main() {\n \n pub fn parse_config(args: ~[~str]) -> config {\n \n-    let groups : ~[getopts::groups::OptGroup] =\n+    let groups : ~[getopts::OptGroup] =\n         ~[reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n           reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\"),\n           reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\"),\n@@ -85,20 +85,20 @@ pub fn parse_config(args: ~[~str]) -> config {\n     let args_ = args.tail();\n     if args[1] == ~\"-h\" || args[1] == ~\"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::groups::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups));\n         println!(\"\");\n         fail!()\n     }\n \n     let matches =\n-        &match getopts::groups::getopts(args_, groups) {\n+        &match getopts::getopts(args_, groups) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::groups::usage(message, groups));\n+        println!(\"{}\", getopts::usage(message, groups));\n         println!(\"\");\n         fail!()\n     }"}, {"sha": "f0ad20506cb7720505729541278837291d269252", "filename": "src/libextra/test.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -17,7 +17,6 @@\n \n extern mod term;\n \n-use getopts::groups;\n use getopts;\n use json::ToJson;\n use json;\n@@ -209,29 +208,29 @@ pub struct TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, ~str>;\n \n-fn optgroups() -> ~[getopts::groups::OptGroup] {\n-    ~[groups::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n-      groups::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n-      groups::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n-      groups::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n-      groups::optopt(\"\", \"save-metrics\", \"Location to save bench metrics\",\n+fn optgroups() -> ~[getopts::OptGroup] {\n+    ~[getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n+      getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n+      getopts::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n+      getopts::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n+      getopts::optopt(\"\", \"save-metrics\", \"Location to save bench metrics\",\n                      \"PATH\"),\n-      groups::optopt(\"\", \"ratchet-metrics\",\n+      getopts::optopt(\"\", \"ratchet-metrics\",\n                      \"Location to load and save metrics from. The metrics \\\n                       loaded are cause benchmarks to fail if they run too \\\n                       slowly\", \"PATH\"),\n-      groups::optopt(\"\", \"ratchet-noise-percent\",\n+      getopts::optopt(\"\", \"ratchet-noise-percent\",\n                      \"Tests within N% of the recorded metrics will be \\\n                       considered as passing\", \"PERCENTAGE\"),\n-      groups::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n+      getopts::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n                           of stdout\", \"PATH\"),\n-      groups::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n+      getopts::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n                      \"A.B\")]\n }\n \n fn usage(binary: &str, helpstr: &str) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(\"{}\", groups::usage(message, optgroups()));\n+    println!(\"{}\", getopts::usage(message, optgroups()));\n     println!(\"\");\n     if helpstr == \"help\" {\n         println!(\"{}\", \"\\\n@@ -261,7 +260,7 @@ Test Attributes:\n pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match groups::getopts(args_, optgroups()) {\n+        match getopts::getopts(args_, optgroups()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_err_msg()))\n         };"}, {"sha": "73d317201f0186a4ac8346c86c7b7b2f51d811d0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 435, "deletions": 473, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -130,6 +130,24 @@ pub struct Opt {\n     priv aliases: ~[Opt],\n }\n \n+/// One group of options, e.g., both -h and --help, along with\n+/// their shared description and properties.\n+#[deriving(Clone, Eq)]\n+pub struct OptGroup {\n+    /// Short Name of the `OptGroup`\n+    short_name: ~str,\n+    /// Long Name of the `OptGroup`\n+    long_name: ~str,\n+    /// Hint\n+    hint: ~str,\n+    /// Description\n+    desc: ~str,\n+    /// Whether it has an argument\n+    hasarg: HasArg,\n+    /// How often it can occur\n+    occur: Occur\n+}\n+\n /// Describes wether an option is given at all or has a value.\n #[deriving(Clone, Eq)]\n enum Optval {\n@@ -193,6 +211,50 @@ impl Name {\n     }\n }\n \n+impl OptGroup {\n+    /// Translate OptGroup into Opt.\n+    /// (Both short and long names correspond to different Opts).\n+    pub fn long_to_short(&self) -> Opt {\n+        let OptGroup {\n+            short_name: short_name,\n+            long_name: long_name,\n+            hasarg: hasarg,\n+            occur: occur,\n+            ..\n+        } = (*self).clone();\n+\n+        match (short_name.len(), long_name.len()) {\n+            (0,0) => fail!(\"this long-format option was given no name\"),\n+            (0,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: ~[]\n+            },\n+            (1,0) => Opt {\n+                name: Short(short_name.char_at(0)),\n+                hasarg: hasarg,\n+                occur: occur,\n+                aliases: ~[]\n+            },\n+            (1,_) => Opt {\n+                name: Long((long_name)),\n+                hasarg: hasarg,\n+                occur:  occur,\n+                aliases: ~[\n+                    Opt {\n+                        name: Short(short_name.char_at(0)),\n+                        hasarg: hasarg,\n+                        occur:  occur,\n+                        aliases: ~[]\n+                    }\n+                ]\n+            },\n+            (_,_) => fail!(\"something is wrong with the long-form opt\")\n+        }\n+    }\n+}\n+\n impl Matches {\n     fn opt_vals(&self, nm: &str) -> ~[Optval] {\n         match find_opt(self.opts, Name::from_str(nm)) {\n@@ -308,65 +370,89 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n     None\n }\n \n-/// Create an option that is required and takes an argument.\n-pub fn reqopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is required and takes an argument.\n+pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Req,\n-        aliases: ~[]\n+        occur: Req\n     }\n }\n \n-/// Create an option that is optional and takes an argument.\n-pub fn optopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and takes an argument.\n+pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional and does not take an argument.\n-pub fn optflag(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and does not take an argument.\n+pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: ~\"\",\n+        desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional, does not take an argument,\n-/// and may occur multiple times.\n-pub fn optflagmulti(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that can occur more than once and does not\n+/// take an argument.\n+pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: ~\"\",\n+        desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Multi,\n-        aliases: ~[]\n+        occur: Multi\n     }\n }\n \n-/// Create an option that is optional and takes an optional argument.\n-pub fn optflagopt(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+/// Create a long option that is optional and takes an optional argument.\n+pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Maybe,\n-        occur: Optional,\n-        aliases: ~[]\n+        occur: Optional\n     }\n }\n \n-/// Create an option that is optional, takes an argument, and may occur\n+/// Create a long option that is optional, takes an argument, and may occur\n /// multiple times.\n-pub fn optmulti(name: &str) -> Opt {\n-    Opt {\n-        name: Name::from_str(name),\n+pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n+    let len = short_name.len();\n+    assert!(len == 1 || len == 0);\n+    OptGroup {\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Multi,\n-        aliases: ~[]\n+        occur: Multi\n     }\n }\n \n@@ -398,7 +484,8 @@ impl Fail_ {\n /// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n /// Use `to_err_msg` to get an error message.\n-pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n+pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n+    let opts = optgrps.map(|x| x.long_to_short());\n     let n_opts = opts.len();\n \n     fn f(_x: uint) -> ~[Optval] { return ~[]; }\n@@ -524,369 +611,228 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n     })\n }\n \n-/// A module which provides a way to specify descriptions and\n-/// groups of short and long option names, together.\n-pub mod groups {\n-    use super::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n-    use super::{Short, Yes};\n-\n-    /// One group of options, e.g., both -h and --help, along with\n-    /// their shared description and properties.\n-    #[deriving(Clone, Eq)]\n-    pub struct OptGroup {\n-        /// Short Name of the `OptGroup`\n-        short_name: ~str,\n-        /// Long Name of the `OptGroup`\n-        long_name: ~str,\n-        /// Hint\n-        hint: ~str,\n-        /// Description\n-        desc: ~str,\n-        /// Whether it has an argument\n-        hasarg: HasArg,\n-        /// How often it can occur\n-        occur: Occur\n-    }\n-\n-    impl OptGroup {\n-        /// Translate OptGroup into Opt.\n-        /// (Both short and long names correspond to different Opts).\n-        pub fn long_to_short(&self) -> Opt {\n-            let OptGroup {\n-                short_name: short_name,\n-                long_name: long_name,\n-                hasarg: hasarg,\n-                occur: occur,\n-                ..\n-            } = (*self).clone();\n-\n-            match (short_name.len(), long_name.len()) {\n-                (0,0) => fail!(\"this long-format option was given no name\"),\n-                (0,_) => Opt {\n-                    name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n-                    aliases: ~[]\n-                },\n-                (1,0) => Opt {\n-                    name: Short(short_name.char_at(0)),\n-                    hasarg: hasarg,\n-                    occur: occur,\n-                    aliases: ~[]\n-                },\n-                (1,_) => Opt {\n-                    name: Long((long_name)),\n-                    hasarg: hasarg,\n-                    occur:  occur,\n-                    aliases: ~[\n-                        Opt {\n-                            name: Short(short_name.char_at(0)),\n-                            hasarg: hasarg,\n-                            occur:  occur,\n-                            aliases: ~[]\n-                        }\n-                    ]\n-                },\n-                (_,_) => fail!(\"something is wrong with the long-form opt\")\n-            }\n-        }\n-    }\n-\n-    /// Create a long option that is required and takes an argument.\n-    pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Req\n-        }\n-    }\n+/// Derive a usage message from a set of long options.\n+pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-    /// Create a long option that is optional and takes an argument.\n-    pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Optional\n-        }\n-    }\n+    let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-    /// Create a long option that is optional and does not take an argument.\n-    pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: ~\"\",\n-            desc: desc.to_owned(),\n-            hasarg: No,\n-            occur: Optional\n-        }\n-    }\n+    let mut rows = opts.iter().map(|optref| {\n+        let OptGroup{short_name: short_name,\n+                     long_name: long_name,\n+                     hint: hint,\n+                     desc: desc,\n+                     hasarg: hasarg,\n+                     ..} = (*optref).clone();\n \n-    /// Create a long option that can occur more than once and does not\n-    /// take an argument.\n-    pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: ~\"\",\n-            desc: desc.to_owned(),\n-            hasarg: No,\n-            occur: Multi\n-        }\n-    }\n+        let mut row = \" \".repeat(4);\n \n-    /// Create a long option that is optional and takes an optional argument.\n-    pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Maybe,\n-            occur: Optional\n+        // short option\n+        match short_name.len() {\n+            0 => {}\n+            1 => {\n+                row.push_char('-');\n+                row.push_str(short_name);\n+                row.push_char(' ');\n+            }\n+            _ => fail!(\"the short name should only be 1 ascii char long\"),\n         }\n-    }\n \n-    /// Create a long option that is optional, takes an argument, and may occur\n-    /// multiple times.\n-    pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-        let len = short_name.len();\n-        assert!(len == 1 || len == 0);\n-        OptGroup {\n-            short_name: short_name.to_owned(),\n-            long_name: long_name.to_owned(),\n-            hint: hint.to_owned(),\n-            desc: desc.to_owned(),\n-            hasarg: Yes,\n-            occur: Multi\n+        // long option\n+        match long_name.len() {\n+            0 => {}\n+            _ => {\n+                row.push_str(\"--\");\n+                row.push_str(long_name);\n+                row.push_char(' ');\n+            }\n         }\n-    }\n-\n-    /// Parse command line args with the provided long format options.\n-    pub fn getopts(args: &[~str], opts: &[OptGroup]) -> super::Result {\n-        super::getopts(args, opts.map(|x| x.long_to_short()))\n-    }\n \n-    fn format_option(opt: &OptGroup) -> ~str {\n-        let mut line = ~\"\";\n-\n-        if opt.occur != Req {\n-            line.push_char('[');\n+        // arg\n+        match hasarg {\n+            No => {}\n+            Yes => row.push_str(hint),\n+            Maybe => {\n+                row.push_char('[');\n+                row.push_str(hint);\n+                row.push_char(']');\n+            }\n         }\n \n-        // Use short_name is possible, but fallback to long_name.\n-        if opt.short_name.len() > 0 {\n-            line.push_char('-');\n-            line.push_str(opt.short_name);\n+        // FIXME: #5516 should be graphemes not codepoints\n+        // here we just need to indent the start of the description\n+        let rowlen = row.char_len();\n+        if rowlen < 24 {\n+            for _ in range(0, 24 - rowlen) {\n+                row.push_char(' ');\n+            }\n         } else {\n-            line.push_str(\"--\");\n-            line.push_str(opt.long_name);\n+            row.push_str(desc_sep)\n         }\n \n-        if opt.hasarg != No {\n-            line.push_char(' ');\n-            if opt.hasarg == Maybe {\n-                line.push_char('[');\n-            }\n-            line.push_str(opt.hint);\n-            if opt.hasarg == Maybe {\n-                line.push_char(']');\n-            }\n+        // Normalize desc to contain words separated by one space character\n+        let mut desc_normalized_whitespace = ~\"\";\n+        for word in desc.words() {\n+            desc_normalized_whitespace.push_str(word);\n+            desc_normalized_whitespace.push_char(' ');\n         }\n \n-        if opt.occur != Req {\n-            line.push_char(']');\n-        }\n-        if opt.occur == Multi {\n-            line.push_str(\"..\");\n-        }\n+        // FIXME: #5516 should be graphemes not codepoints\n+        let mut desc_rows = ~[];\n+        each_split_within(desc_normalized_whitespace, 54, |substr| {\n+            desc_rows.push(substr.to_owned());\n+            true\n+        });\n \n-        line\n-    }\n+        // FIXME: #5516 should be graphemes not codepoints\n+        // wrapped description\n+        row.push_str(desc_rows.connect(desc_sep));\n \n-    /// Derive a short one-line usage summary from a set of long options.\n-    pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n-        let mut line = ~\"Usage: \" + program_name + \" \";\n-        line.push_str(opts.iter().map(format_option).to_owned_vec().connect(\" \"));\n+        row\n+    });\n \n-        line\n-    }\n+    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+}\n \n-    /// Derive a usage message from a set of long options.\n-    pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n+fn format_option(opt: &OptGroup) -> ~str {\n+    let mut line = ~\"\";\n \n-        let desc_sep = \"\\n\" + \" \".repeat(24);\n+    if opt.occur != Req {\n+        line.push_char('[');\n+    }\n \n-        let mut rows = opts.iter().map(|optref| {\n-            let OptGroup{short_name: short_name,\n-                         long_name: long_name,\n-                         hint: hint,\n-                         desc: desc,\n-                         hasarg: hasarg,\n-                         ..} = (*optref).clone();\n+    // Use short_name is possible, but fallback to long_name.\n+    if opt.short_name.len() > 0 {\n+        line.push_char('-');\n+        line.push_str(opt.short_name);\n+    } else {\n+        line.push_str(\"--\");\n+        line.push_str(opt.long_name);\n+    }\n \n-            let mut row = \" \".repeat(4);\n+    if opt.hasarg != No {\n+        line.push_char(' ');\n+        if opt.hasarg == Maybe {\n+            line.push_char('[');\n+        }\n+        line.push_str(opt.hint);\n+        if opt.hasarg == Maybe {\n+            line.push_char(']');\n+        }\n+    }\n \n-            // short option\n-            match short_name.len() {\n-                0 => {}\n-                1 => {\n-                    row.push_char('-');\n-                    row.push_str(short_name);\n-                    row.push_char(' ');\n-                }\n-                _ => fail!(\"the short name should only be 1 ascii char long\"),\n-            }\n+    if opt.occur != Req {\n+        line.push_char(']');\n+    }\n+    if opt.occur == Multi {\n+        line.push_str(\"..\");\n+    }\n \n-            // long option\n-            match long_name.len() {\n-                0 => {}\n-                _ => {\n-                    row.push_str(\"--\");\n-                    row.push_str(long_name);\n-                    row.push_char(' ');\n-                }\n-            }\n+    line\n+}\n \n-            // arg\n-            match hasarg {\n-                No => {}\n-                Yes => row.push_str(hint),\n-                Maybe => {\n-                    row.push_char('[');\n-                    row.push_str(hint);\n-                    row.push_char(']');\n-                }\n-            }\n+/// Derive a short one-line usage summary from a set of long options.\n+pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n+    let mut line = ~\"Usage: \" + program_name + \" \";\n+    line.push_str(opts.iter().map(format_option).to_owned_vec().connect(\" \"));\n \n-            // FIXME: #5516 should be graphemes not codepoints\n-            // here we just need to indent the start of the description\n-            let rowlen = row.char_len();\n-            if rowlen < 24 {\n-                for _ in range(0, 24 - rowlen) {\n-                    row.push_char(' ');\n-                }\n-            } else {\n-                row.push_str(desc_sep)\n-            }\n+    line\n+}\n \n-            // Normalize desc to contain words separated by one space character\n-            let mut desc_normalized_whitespace = ~\"\";\n-            for word in desc.words() {\n-                desc_normalized_whitespace.push_str(word);\n-                desc_normalized_whitespace.push_char(' ');\n-            }\n \n-            // FIXME: #5516 should be graphemes not codepoints\n-            let mut desc_rows = ~[];\n-            each_split_within(desc_normalized_whitespace, 54, |substr| {\n-                desc_rows.push(substr.to_owned());\n-                true\n-            });\n+/// Splits a string into substrings with possibly internal whitespace,\n+/// each of them at most `lim` bytes long. The substrings have leading and trailing\n+/// whitespace removed, and are only cut at whitespace boundaries.\n+///\n+/// Note: Function was moved here from `std::str` because this module is the only place that\n+/// uses it, and because it was to specific for a general string function.\n+///\n+/// #Failure:\n+///\n+/// Fails during iteration if the string contains a non-whitespace\n+/// sequence longer than the limit.\n+fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n+                     -> bool {\n+    // Just for fun, let's write this as a state machine:\n+\n+    enum SplitWithinState {\n+        A,  // leading whitespace, initial state\n+        B,  // words\n+        C,  // internal and trailing whitespace\n+    }\n+    enum Whitespace {\n+        Ws, // current char is whitespace\n+        Cr  // current char is not whitespace\n+    }\n+    enum LengthLimit {\n+        UnderLim, // current char makes current substring still fit in limit\n+        OverLim   // current char makes current substring no longer fit in limit\n+    }\n+\n+    let mut slice_start = 0;\n+    let mut last_start = 0;\n+    let mut last_end = 0;\n+    let mut state = A;\n+    let mut fake_i = ss.len();\n+    let mut lim = lim;\n+\n+    let mut cont = true;\n+    let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n+\n+    // if the limit is larger than the string, lower it to save cycles\n+    if lim >= fake_i {\n+        lim = fake_i;\n+    }\n+\n+    let machine: |(uint, char)| -> bool = |(i, c)| {\n+        let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+        let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+\n+        state = match (state, whitespace, limit) {\n+            (A, Ws, _)        => { A }\n+            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n+\n+            (B, Cr, UnderLim) => { B }\n+            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n+                            => fail!(\"word starting with {} longer than limit!\",\n+                                    ss.slice(last_start, i + 1)),\n+            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n+            (B, Ws, UnderLim) => { last_end = i; C }\n+            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n+\n+            (C, Cr, UnderLim) => { last_start = i; B }\n+            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n+            (C, Ws, OverLim)  => { slice(); A }\n+            (C, Ws, UnderLim) => { C }\n+        };\n \n-            // FIXME: #5516 should be graphemes not codepoints\n-            // wrapped description\n-            row.push_str(desc_rows.connect(desc_sep));\n+        cont\n+    };\n \n-            row\n-        });\n+    ss.char_indices().advance(|x| machine(x));\n \n-        format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<~[~str]>().connect(\"\\n\"))\n+    // Let the automaton 'run out' by supplying trailing whitespace\n+    while cont && match state { B | C => true, A => false } {\n+        machine((fake_i, ' '));\n+        fake_i += 1;\n     }\n+    return cont;\n+}\n \n-    /// Splits a string into substrings with possibly internal whitespace,\n-    /// each of them at most `lim` bytes long. The substrings have leading and trailing\n-    /// whitespace removed, and are only cut at whitespace boundaries.\n-    ///\n-    /// Note: Function was moved here from `std::str` because this module is the only place that\n-    /// uses it, and because it was to specific for a general string function.\n-    ///\n-    /// #Failure:\n-    ///\n-    /// Fails during iteration if the string contains a non-whitespace\n-    /// sequence longer than the limit.\n-    fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n-                         -> bool {\n-        // Just for fun, let's write this as a state machine:\n-\n-        enum SplitWithinState {\n-            A,  // leading whitespace, initial state\n-            B,  // words\n-            C,  // internal and trailing whitespace\n-        }\n-        enum Whitespace {\n-            Ws, // current char is whitespace\n-            Cr  // current char is not whitespace\n-        }\n-        enum LengthLimit {\n-            UnderLim, // current char makes current substring still fit in limit\n-            OverLim   // current char makes current substring no longer fit in limit\n-        }\n-\n-        let mut slice_start = 0;\n-        let mut last_start = 0;\n-        let mut last_end = 0;\n-        let mut state = A;\n-        let mut fake_i = ss.len();\n-        let mut lim = lim;\n-\n-        let mut cont = true;\n-        let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n-\n-        // if the limit is larger than the string, lower it to save cycles\n-        if lim >= fake_i {\n-            lim = fake_i;\n-        }\n-\n-        let machine: |(uint, char)| -> bool = |(i, c)| {\n-            let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n-            let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n-\n-            state = match (state, whitespace, limit) {\n-                (A, Ws, _)        => { A }\n-                (A, Cr, _)        => { slice_start = i; last_start = i; B }\n-\n-                (B, Cr, UnderLim) => { B }\n-                (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                                => fail!(\"word starting with {} longer than limit!\",\n-                                        ss.slice(last_start, i + 1)),\n-                (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n-                (B, Ws, UnderLim) => { last_end = i; C }\n-                (B, Ws, OverLim)  => { last_end = i; slice(); A }\n-\n-                (C, Cr, UnderLim) => { last_start = i; B }\n-                (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n-                (C, Ws, OverLim)  => { slice(); A }\n-                (C, Ws, UnderLim) => { C }\n-            };\n-\n-            cont\n-        };\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n \n-        ss.char_indices().advance(|x| machine(x));\n+    use std::result::{Err, Ok};\n+    use std::result;\n \n-        // Let the automaton 'run out' by supplying trailing whitespace\n-        while cont && match state { B | C => true, A => false } {\n-            machine((fake_i, ' '));\n-            fake_i += 1;\n+    fn check_fail_type(f: Fail_, ft: FailType) {\n+        match f {\n+          ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n+          UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n+          OptionMissing(_) => assert!(ft == OptionMissing_),\n+          OptionDuplicated(_) => assert!(ft == OptionDuplicated_),\n+          UnexpectedArgument(_) => assert!(ft == UnexpectedArgument_)\n         }\n-        return cont;\n     }\n \n     #[test]\n@@ -904,33 +850,12 @@ pub mod groups {\n         t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n             [~\"Mary had a little lamb\\nLittle lamb\"]);\n     }\n-} // end groups module\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use super::groups::OptGroup;\n-    use super::*;\n-\n-    use std::result::{Err, Ok};\n-    use std::result;\n-\n-    fn check_fail_type(f: Fail_, ft: FailType) {\n-        match f {\n-          ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n-          UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n-          OptionMissing(_) => assert!(ft == OptionMissing_),\n-          OptionDuplicated(_) => assert!(ft == OptionDuplicated_),\n-          UnexpectedArgument(_) => assert!(ft == UnexpectedArgument_)\n-        }\n-    }\n-\n \n     // Tests for reqopt\n     #[test]\n     fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -944,7 +869,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n@@ -955,7 +880,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -966,7 +891,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -977,7 +902,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -991,7 +916,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionMissing_),\n@@ -1002,7 +927,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -1013,7 +938,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let opts = ~[reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -1026,7 +951,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optopt(\"test\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1040,7 +965,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(\"test\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n@@ -1051,7 +976,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optopt(\"test\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -1062,7 +987,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optopt(\"test\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -1073,7 +998,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optopt(\"t\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1087,7 +1012,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(\"t\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n@@ -1098,7 +1023,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optopt(\"t\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -1109,7 +1034,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optopt(\"t\")];\n+        let opts = ~[optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -1122,7 +1047,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"test\")),\n@@ -1133,7 +1058,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n@@ -1144,7 +1069,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => {\n@@ -1158,7 +1083,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n-        let opts = ~[optflag(\"test\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -1169,7 +1094,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optflag(\"t\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(m.opt_present(\"t\")),\n@@ -1180,7 +1105,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(\"t\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n@@ -1191,7 +1116,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optflag(\"t\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1206,7 +1131,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n-        let opts = ~[optflag(\"t\")];\n+        let opts = ~[optflag(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, OptionDuplicated_),\n@@ -1218,7 +1143,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\", \"VERBOSITY\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1231,7 +1156,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\", \"VERBOSITY\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1244,7 +1169,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n-        let opts = ~[optflagmulti(\"v\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\", \"VERBOSITY\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1257,7 +1182,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"verbose\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\", \"VERBOSITY\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1270,7 +1195,7 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n-        let opts = ~[optflagmulti(\"verbose\")];\n+        let opts = ~[optflagmulti(\"v\", \"verbose\", \"verbosity\", \"VERBOSITY\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1284,7 +1209,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1298,7 +1223,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"test\")),\n@@ -1309,7 +1234,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -1320,7 +1245,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1337,7 +1262,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1351,7 +1276,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert!(!m.opt_present(\"t\")),\n@@ -1362,7 +1287,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n@@ -1373,7 +1298,7 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1390,7 +1315,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1401,7 +1326,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let opts = ~[optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1416,9 +1341,13 @@ mod tests {\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n               ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n         let opts =\n-            ~[optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n-             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n-             optopt(\"notpresent\")];\n+            ~[optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n+              optflag(\"\", \"flag\", \"a flag\", \"FLAG\"),\n+              reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n+              optflag(\"f\", \"\", \"another flag\", \"FLAG\"),\n+              optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n+              optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n+              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -1443,7 +1372,9 @@ mod tests {\n \n     #[test]\n     fn test_multi() {\n-        let opts = ~[optopt(\"e\"), optopt(\"encrypt\"), optopt(\"f\")];\n+        let opts = ~[optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n+                     optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n+                     optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n \n         let args_single = ~[~\"-e\", ~\"foo\"];\n         let matches_single = &match getopts(args_single, opts) {\n@@ -1483,7 +1414,8 @@ mod tests {\n     #[test]\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n-        let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n+        let opts = ~[optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                     optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n@@ -1497,7 +1429,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_reqopt() {\n-        let opt = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n+        let opt = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n@@ -1508,7 +1440,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optopt() {\n-        let opt = groups::optopt(\"a\", \"apple\", \"some apples\", \"VAL\");\n+        let opt = optopt(\"a\", \"apple\", \"some apples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n@@ -1519,7 +1451,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflag() {\n-        let opt = groups::optflag(\"k\", \"kiwi\", \"some kiwis\");\n+        let opt = optflag(\"k\", \"kiwi\", \"some kiwis\");\n         assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n@@ -1530,7 +1462,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflagopt() {\n-        let opt = groups::optflagopt(\"p\", \"pineapple\", \"some pineapples\", \"VAL\");\n+        let opt = optflagopt(\"p\", \"pineapple\", \"some pineapples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n@@ -1541,7 +1473,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optmulti() {\n-        let opt = groups::optmulti(\"l\", \"lime\", \"some limes\", \"VAL\");\n+        let opt = optmulti(\"l\", \"lime\", \"some limes\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n@@ -1552,69 +1484,99 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let mut short = reqopt(\"banana\");\n-        short.aliases = ~[reqopt(\"b\")];\n-        let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n+        let mut short = Opt { name: ~\"banana\",\n+                              hasarg: Yes,\n+                              occur: Req,\n+                              aliases: ~[] };\n+        short.aliases = ~[Opt { name: ~\"b\",\n+                                hasarg: Yes,\n+                                occur: Req,\n+                                aliases: ~[] }];\n+        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(verbose.long_to_short(), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n-        let mut banana = reqopt(\"banana\");\n-        banana.aliases = ~[reqopt(\"b\")];\n-        let mut apple = optopt(\"apple\");\n-        apple.aliases = ~[optopt(\"a\")];\n-        let mut kiwi = optflag(\"kiwi\");\n-        kiwi.aliases = ~[optflag(\"k\")];\n+        let mut banana = Opt { name: ~\"banana\",\n+                               hasarg: Yes,\n+                               occur: Req,\n+                               aliases: ~[] };\n+        banana.aliases = ~[Opt { name: ~\"b\",\n+                                 hasarg: Yes,\n+                                 occur: Req,\n+                                 aliases: ~[] }];\n+        let mut apple = Opt { name: ~\"apple\",\n+                              hasarg: Yes,\n+                              occur: Optional,\n+                              aliases: ~[] };\n+        apple.aliases = ~[Opt { name: ~\"a\",\n+                                hasarg: Yes,\n+                                occur: Optional,\n+                                aliases: ~[] }];\n+        let mut kiwi = Opt { name: ~\"kiwi\",\n+                             hasarg: No,\n+                             occur: Optional,\n+                             aliases: ~[] };\n+        kiwi.aliases = ~[Opt { name: ~\"k\",\n+                               hasarg: No,\n+                               occur: Optional,\n+                               aliases: ~[] }];\n         let short = ~[\n             banana,\n             apple,\n             kiwi,\n-            optflagopt(\"p\"),\n-            optmulti(\"l\")\n+            Opt { name: ~\"p\",\n+                  hasarg: Maybe,\n+                  occur: Optional,\n+                  aliases: ~[] },\n+            Opt { name: ~\"l\",\n+                  hasarg: Yes,\n+                  occur: Multi,\n+                  aliases: ~[] }\n         ];\n \n         // short and verbose should always be in the same order. if they\n         // aren't the test will fail (and in mysterious ways)\n \n         let verbose = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"apple\", \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n+            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            optopt(\"a\", \"apple\", \"Desc\", \"VAL\"),\n+            optflag(\"k\", \"kiwi\", \"Desc\"),\n+            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let sample_args = ~[~\"--kiwi\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         assert!(getopts(sample_args, short)\n-            == groups::getopts(sample_args, verbose));\n+            == getopts(sample_args, verbose));\n     }\n \n     #[test]\n     fn test_groups_aliases_long_and_short() {\n         let opts = ~[\n-            groups::optflagmulti(\"a\", \"apple\", \"Desc\"),\n+            optflagmulti(\"a\", \"apple\", \"Desc\"),\n         ];\n \n         let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n \n-        let matches = groups::getopts(args, opts).unwrap();\n+        let matches = getopts(args, opts).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n         assert_eq!(3, matches.opt_count(\"apple\"));\n     }\n \n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"012345678901234567890123456789\",\n+            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            optopt(\"a\", \"012345678901234567890123456789\",\n                              \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n+            optflag(\"k\", \"kiwi\", \"Desc\"),\n+            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected =\n@@ -1629,7 +1591,7 @@ Options:\n     -l VAL              Desc\n \";\n \n-        let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let generated_usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);\n@@ -1642,9 +1604,9 @@ Options:\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n         let optgroups = ~[\n-            groups::optflag(\"k\", \"kiwi\",\n+            optflag(\"k\", \"kiwi\",\n                 \"This is a long description which won't be wrapped..+..\"), // 54\n-            groups::optflag(\"a\", \"apple\",\n+            optflag(\"a\", \"apple\",\n                 \"This is a long description which _will_ be wrapped..+..\"), // 55\n         ];\n \n@@ -1657,7 +1619,7 @@ Options:\n                         wrapped..+..\n \";\n \n-        let usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1667,9 +1629,9 @@ Options:\n     #[test]\n     fn test_groups_usage_description_multibyte_handling() {\n         let optgroups = ~[\n-            groups::optflag(\"k\", \"k\\u2013w\\u2013\",\n+            optflag(\"k\", \"k\\u2013w\\u2013\",\n                 \"The word kiwi is normally spelled with two i's\"),\n-            groups::optflag(\"a\", \"apple\",\n+            optflag(\"a\", \"apple\",\n                 \"This \\u201Cdescription\\u201D has some characters that could \\\n confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"),\n         ];\n@@ -1684,7 +1646,7 @@ Options:\n                         some parts of Europe.\n \";\n \n-        let usage = groups::usage(\"Usage: fruits\", optgroups);\n+        let usage = usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", usage);\n@@ -1694,16 +1656,16 @@ Options:\n     #[test]\n     fn test_short_usage() {\n         let optgroups = ~[\n-            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            groups::optopt(\"a\", \"012345678901234567890123456789\",\n-                             \"Desc\", \"VAL\"),\n-            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n-            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n+            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            optopt(\"a\", \"012345678901234567890123456789\",\n+                     \"Desc\", \"VAL\"),\n+            optflag(\"k\", \"kiwi\", \"Desc\"),\n+            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected = ~\"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\";\n-        let generated_usage = groups::short_usage(\"fruits\", optgroups);\n+        let generated_usage = short_usage(\"fruits\", optgroups);\n \n         debug!(\"expected: <<{}>>\", expected);\n         debug!(\"generated: <<{}>>\", generated_usage);"}, {"sha": "70974fae5cc287fba4cda3069cb81d97ba7bc853", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -34,7 +34,7 @@ use std::io::fs;\n use std::io::MemReader;\n use std::os;\n use std::vec;\n-use getopts::groups::{optopt, optmulti, optflag, optflagopt};\n+use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use syntax::ast;\n use syntax::abi;\n@@ -992,7 +992,7 @@ pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n }\n \n // rustc command line options\n-pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n+pub fn optgroups() -> ~[getopts::OptGroup] {\n  ~[\n   optflag(\"c\", \"\",    \"Compile and assemble, but do not link\"),\n   optmulti(\"\", \"cfg\", \"Configure the compilation\n@@ -1188,7 +1188,7 @@ mod test {\n     use driver::driver::{build_configuration, build_session};\n     use driver::driver::{build_session_options, optgroups};\n \n-    use getopts::groups::getopts;\n+    use getopts::getopts;\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n     use syntax::diagnostic;"}, {"sha": "9a6cbcc9b96200f7339d636b7901829f3d8e8161", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -51,7 +51,6 @@ use std::os;\n use std::str;\n use std::task;\n use std::vec;\n-use getopts::groups;\n use syntax::ast;\n use syntax::attr;\n use syntax::diagnostic::Emitter;\n@@ -142,7 +141,7 @@ pub fn usage(argv0: &str) {\n Additional help:\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc\\n\",\n-              groups::usage(message, d::optgroups()));\n+              getopts::usage(message, d::optgroups()));\n }\n \n pub fn describe_warnings() {\n@@ -201,7 +200,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::groups::getopts(args, d::optgroups()) {\n+        &match getopts::getopts(args, d::optgroups()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(demitter, f.to_err_msg());"}, {"sha": "dd96018d4af25e762d6d5feecb7a80c39dd1f8c5", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -24,8 +24,7 @@ use middle::ty::{FnTyBase, FnMeta, FnSig};\n use util::ppaux::ty_to_str;\n \n use extra::oldmap::HashMap;\n-use getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n-use getopts::groups;\n+use getopts::{optopt, optmulti, optflag, optflagopt, getopts};\n use getopts::opt_present;\n use syntax::codemap::DUMMY_SP;\n use syntax::parse::parse_crate_from_source_str;"}, {"sha": "f659c8646f5e42dd7c450f365f245f86022ac142", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -29,7 +29,6 @@ use std::str;\n use extra::json;\n use serialize::{Decodable, Encodable};\n use extra::time;\n-use getopts::groups;\n \n pub mod clean;\n pub mod core;\n@@ -80,8 +79,8 @@ pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args()));\n }\n \n-pub fn opts() -> ~[groups::OptGroup] {\n-    use getopts::groups::*;\n+pub fn opts() -> ~[getopts::OptGroup] {\n+    use getopts::*;\n     ~[\n         optflag(\"h\", \"help\", \"show this help message\"),\n         optflag(\"\", \"version\", \"print rustdoc's version\"),\n@@ -107,11 +106,11 @@ pub fn opts() -> ~[groups::OptGroup] {\n }\n \n pub fn usage(argv0: &str) {\n-    println!(\"{}\", groups::usage(format!(\"{} [options] <input>\", argv0), opts()));\n+    println!(\"{}\", getopts::usage(format!(\"{} [options] <input>\", argv0), opts()));\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    let matches = match groups::getopts(args.tail(), opts()) {\n+    let matches = match getopts::getopts(args.tail(), opts()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());"}, {"sha": "db8098a79acb9cdd329c27386eb28ff9ad89d8ad", "filename": "src/test/run-pass/getopts_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09ca940e540e2ef77a9b4bf1f9807276b300f3d/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=c09ca940e540e2ef77a9b4bf1f9807276b300f3d", "patch": "@@ -16,7 +16,7 @@ use getopts::{optopt, getopts};\n \n pub fn main() {\n     let args = ~[];\n-    let opts = ~[optopt(\"b\")];\n+    let opts = ~[optopt(\"b\", \"\", \"something\", \"SMTHNG\")];\n \n     match getopts(args, opts) {\n         Ok(ref m)  =>"}]}