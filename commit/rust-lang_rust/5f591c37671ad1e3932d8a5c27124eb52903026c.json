{"sha": "5f591c37671ad1e3932d8a5c27124eb52903026c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNTkxYzM3NjcxYWQxZTM5MzJkOGE1YzI3MTI0ZWI1MjkwMzAyNmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-17T23:22:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-17T23:22:45Z"}, "message": "Allocate and reload retslots. Copy into them on polymorphic returns.", "tree": {"sha": "6fe6e280e2289713fa11db94b03f36a0f875a7c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fe6e280e2289713fa11db94b03f36a0f875a7c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f591c37671ad1e3932d8a5c27124eb52903026c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f591c37671ad1e3932d8a5c27124eb52903026c", "html_url": "https://github.com/rust-lang/rust/commit/5f591c37671ad1e3932d8a5c27124eb52903026c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f591c37671ad1e3932d8a5c27124eb52903026c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3caed8a029eb3c17d40564da6859d61f1e624d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3caed8a029eb3c17d40564da6859d61f1e624d", "html_url": "https://github.com/rust-lang/rust/commit/9f3caed8a029eb3c17d40564da6859d61f1e624d"}], "stats": {"total": 54, "additions": 35, "deletions": 19}, "files": [{"sha": "62c8a4fb7c7f1b206449221222f0a771e88b9985", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5f591c37671ad1e3932d8a5c27124eb52903026c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f591c37671ad1e3932d8a5c27124eb52903026c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5f591c37671ad1e3932d8a5c27124eb52903026c", "patch": "@@ -1996,22 +1996,27 @@ impure fn trans_args(@block_ctxt cx,\n                      option.t[generic_info] gen,\n                      &vec[@ast.expr] es,\n                      @ty.t fn_ty)\n-    -> tup(@block_ctxt, vec[ValueRef]) {\n+    -> tup(@block_ctxt, vec[ValueRef], option.t[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n \n     let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n \n+    let option.t[ValueRef] llretslot_opt = none[ValueRef];\n+\n     alt (gen) {\n         case (some[generic_info](?g)) {\n             for (ValueRef t in g.tydescs) {\n                 vs += t;\n             }\n             args = ty.ty_fn_args(g.item_type);\n             if (ty.type_has_dynamic_size(ty.ty_fn_ret(g.item_type))) {\n-                // FIXME: allocate real outptr in caller,\n-                // pass in to here.\n-                vs += C_null(T_typaram_ptr());\n+                auto retty = ty.ty_fn_ret(fn_ty);\n+                auto llretty = type_of(cx.fcx.ccx, retty);\n+                auto llretslot = cx.build.Alloca(llretty);\n+                llretslot = cx.build.PointerCast(llretslot, T_ptr(T_i8()));\n+                vs += llretslot;\n+                llretslot_opt = some[ValueRef](llretslot);\n             }\n         }\n         case (_) { }\n@@ -2076,7 +2081,7 @@ impure fn trans_args(@block_ctxt cx,\n         i += 1u;\n     }\n \n-    ret tup(bcx, vs);\n+    ret tup(bcx, vs, llretslot_opt);\n }\n \n impure fn trans_bind_thunk(@crate_ctxt cx,\n@@ -2311,29 +2316,40 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                                f_res.generic,\n                                args, fn_ty);\n \n-    auto real_retval = args_res._0.build.FastCall(faddr, args_res._1);\n+    auto bcx = args_res._0;\n+    auto real_retval = bcx.build.FastCall(faddr, args_res._1);\n     auto retval;\n-    if (ty.type_is_nil(ret_ty)) {\n-        retval = C_nil();\n-    } else {\n-        retval = real_retval;\n-    }\n \n-    // Structured returns come back as first-class values. This is nice for\n-    // LLVM but wrong for us; we treat structured values by pointer in\n-    // most of our code here. So spill it to an alloca.\n-    if (ty.type_is_structural(ret_ty)) {\n-        auto local = args_res._0.build.Alloca(type_of(cx.fcx.ccx, ret_ty));\n-        args_res._0.build.Store(retval, local);\n-        retval = local;\n+    // Check for a generic retslot.\n+    alt (args_res._2) {\n+        case (some[ValueRef](?llretslot)) {\n+            retval = bcx.build.Load(llretslot);\n+        }\n+        case (none[ValueRef]) {\n+            retval = real_retval;\n+\n+            if (ty.type_is_nil(ret_ty)) {\n+                retval = C_nil();\n+            } else if (ty.type_is_structural(ret_ty)) {\n+                // Structured returns come back as first-class values. This is\n+                // nice for LLVM but wrong for us; we treat structured values\n+                // by pointer in most of our code here. So spill it to an\n+                // alloca.\n+                auto local = bcx.build.Alloca(type_of(cx.fcx.ccx, ret_ty));\n+                bcx.build.Store(retval, local);\n+                retval = local;\n+            }\n+        }\n     }\n \n+\n+\n     // Retval doesn't correspond to anything really tangible in the frame, but\n     // it's a ref all the same, so we put a note here to drop it when we're\n     // done in this scope.\n     find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n \n-    ret res(args_res._0, retval);\n+    ret res(bcx, retval);\n }\n \n impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,"}]}