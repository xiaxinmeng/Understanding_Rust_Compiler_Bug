{"sha": "d3d552b71b89633fe6692bf2214a2d001683bfa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZDU1MmI3MWI4OTYzM2ZlNjY5MmJmMjIxNGEyZDAwMTY4M2JmYTk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-07T07:16:55Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T14:12:32Z"}, "message": "rustc and rustc::borrowck: pass fragment info down into trans.", "tree": {"sha": "0d78bd8fe16244f5eb62c01d0fd53378f7a8b68c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d78bd8fe16244f5eb62c01d0fd53378f7a8b68c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3d552b71b89633fe6692bf2214a2d001683bfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d552b71b89633fe6692bf2214a2d001683bfa9", "html_url": "https://github.com/rust-lang/rust/commit/d3d552b71b89633fe6692bf2214a2d001683bfa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3d552b71b89633fe6692bf2214a2d001683bfa9/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0f3f2ac53690ee049d9c5387dafd46411320a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f3f2ac53690ee049d9c5387dafd46411320a4f", "html_url": "https://github.com/rust-lang/rust/commit/a0f3f2ac53690ee049d9c5387dafd46411320a4f"}], "stats": {"total": 141, "additions": 137, "deletions": 4}, "files": [{"sha": "ad4d015979ace2fecdb0b79bc3eb68db2c775ed2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d3d552b71b89633fe6692bf2214a2d001683bfa9", "patch": "@@ -957,6 +957,44 @@ pub struct ctxt<'tcx> {\n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: RefCell<NodeMap<cast::CastKind>>,\n+\n+    /// Maps Fn items to a collection of fragment infos.\n+    ///\n+    /// The main goal is to identify data (each of which may be moved\n+    /// or assigned) whose subparts are not moved nor assigned\n+    /// (i.e. their state is *unfragmented*) and corresponding ast\n+    /// nodes where the path to that data is moved or assigned.\n+    ///\n+    /// In the long term, unfragmented values will have their\n+    /// destructor entirely driven by a single stack-local drop-flag,\n+    /// and their parents, the collections of the unfragmented values\n+    /// (or more simply, \"fragmented values\"), are mapped to the\n+    /// corresponding collections of stack-local drop-flags.\n+    ///\n+    /// (However, in the short term that is not the case; e.g. some\n+    /// unfragmented paths still need to be zeroed, namely when they\n+    /// reference parent data from an outer scope that was not\n+    /// entirely moved, and therefore that needs to be zeroed so that\n+    /// we do not get double-drop when we hit the end of the parent\n+    /// scope.)\n+    ///\n+    /// Also: currently the table solely holds keys for node-ids of\n+    /// unfragmented values (see `FragmentInfo` enum definition), but\n+    /// longer-term we will need to also store mappings from\n+    /// fragmented data to the set of unfragmented pieces that\n+    /// constitute it.\n+    pub fragment_infos: RefCell<DefIdMap<Vec<FragmentInfo>>>,\n+}\n+\n+/// Describes the fragment-state associated with a NodeId.\n+///\n+/// Currently only unfragmented paths have entries in the table,\n+/// but longer-term this enum is expected to expand to also\n+/// include data for fragmented paths.\n+#[derive(Copy, Clone, Debug)]\n+pub enum FragmentInfo {\n+    Moved { var: NodeId, move_expr: NodeId },\n+    Assigned { var: NodeId, assign_expr: NodeId, assignee_id: NodeId },\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -3498,6 +3536,7 @@ impl<'tcx> ctxt<'tcx> {\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n+            fragment_infos: RefCell::new(DefIdMap()),\n        }, f)\n     }\n "}, {"sha": "8d7c964c7b21e4db6d40baabaf97b602f27f85b1", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=d3d552b71b89633fe6692bf2214a2d001683bfa9", "patch": "@@ -86,7 +86,7 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n-    move_data: move_data::FlowedMoveData<'a, 'tcx>,\n+    move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n     param_env: &'a ty::ParameterEnvironment<'a, 'tcx>,\n }\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n-                                     move_data: move_data::FlowedMoveData<'c, 'tcx>,\n+                                     move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &ast::FnDecl,"}, {"sha": "864bd7190a36127e056af4232a51cfaf80ccfd56", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=d3d552b71b89633fe6692bf2214a2d001683bfa9", "patch": "@@ -15,7 +15,7 @@\n use self::Fragment::*;\n \n use borrowck::InteriorKind::{InteriorField, InteriorElement};\n-use borrowck::LoanPath;\n+use borrowck::{self, LoanPath};\n use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n@@ -59,6 +59,84 @@ impl Fragment {\n     }\n }\n \n+pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n+                              move_data: &MoveData,\n+                              id: ast::NodeId) {\n+    let fr = &move_data.fragments.borrow();\n+\n+    // For now, don't care about other kinds of fragments; the precise\n+    // classfication of all paths for non-zeroing *drop* needs them,\n+    // but the loose approximation used by non-zeroing moves does not.\n+    let moved_leaf_paths = fr.moved_leaf_paths();\n+    let assigned_leaf_paths = fr.assigned_leaf_paths();\n+\n+    let mut fragment_infos = Vec::with_capacity(moved_leaf_paths.len());\n+\n+    let find_var_id = |move_path_index: MovePathIndex| -> Option<ast::NodeId> {\n+        let lp = move_data.path_loan_path(move_path_index);\n+        match lp.kind {\n+            LpVar(var_id) => Some(var_id),\n+            LpUpvar(ty::UpvarId { var_id, closure_expr_id }) => {\n+                // The `var_id` is unique *relative to* the current function.\n+                // (Check that we are indeed talking about the same function.)\n+                assert_eq!(id, closure_expr_id);\n+                Some(var_id)\n+            }\n+            LpDowncast(..) | LpExtend(..) => {\n+                // This simple implementation of non-zeroing move does\n+                // not attempt to deal with tracking substructure\n+                // accurately in the general case.\n+                None\n+            }\n+        }\n+    };\n+\n+    let moves = move_data.moves.borrow();\n+    for &move_path_index in moved_leaf_paths {\n+        let var_id = match find_var_id(move_path_index) {\n+            None => continue,\n+            Some(var_id) => var_id,\n+        };\n+\n+        move_data.each_applicable_move(move_path_index, |move_index| {\n+            let info = ty::FragmentInfo::Moved {\n+                var: var_id,\n+                move_expr: moves[move_index.get()].id,\n+            };\n+            debug!(\"fragment_infos push({:?} \\\n+                    due to move_path_index: {} move_index: {}\",\n+                   info, move_path_index.get(), move_index.get());\n+            fragment_infos.push(info);\n+            true\n+        });\n+    }\n+\n+    for &move_path_index in assigned_leaf_paths {\n+        let var_id = match find_var_id(move_path_index) {\n+            None => continue,\n+            Some(var_id) => var_id,\n+        };\n+\n+        let var_assigns = move_data.var_assignments.borrow();\n+        for var_assign in var_assigns.iter()\n+            .filter(|&assign| assign.path == move_path_index)\n+        {\n+            let info = ty::FragmentInfo::Assigned {\n+                var: var_id,\n+                assign_expr: var_assign.id,\n+                assignee_id: var_assign.assignee_id,\n+            };\n+            debug!(\"fragment_infos push({:?} due to var_assignment\", info);\n+            fragment_infos.push(info);\n+        }\n+    }\n+\n+    let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n+    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n+    let prev = fraginfo_map.insert(fn_did, fragment_infos);\n+    assert!(prev.is_none());\n+}\n+\n pub struct FragmentSets {\n     /// During move_data construction, `moved_leaf_paths` tracks paths\n     /// that have been used directly by being moved out of.  When\n@@ -103,6 +181,14 @@ impl FragmentSets {\n         }\n     }\n \n+    pub fn moved_leaf_paths(&self) -> &[MovePathIndex] {\n+        &self.moved_leaf_paths\n+    }\n+\n+    pub fn assigned_leaf_paths(&self) -> &[MovePathIndex] {\n+        &self.assigned_leaf_paths\n+    }\n+\n     pub fn add_move(&mut self, path_index: MovePathIndex) {\n         self.moved_leaf_paths.push(path_index);\n     }"}, {"sha": "994393d0650434507eb749883c3600e8bcc97efa", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d3d552b71b89633fe6692bf2214a2d001683bfa9", "patch": "@@ -169,12 +169,16 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n     check_loans::check_loans(this,\n                              &loan_dfcx,\n-                             flowed_moves,\n+                             &flowed_moves,\n                              &all_loans[..],\n                              id,\n                              decl,\n                              body);\n \n+    move_data::fragments::build_unfragmented_map(this,\n+                                                 &flowed_moves.move_data,\n+                                                 id);\n+\n     visit::walk_fn(this, fk, decl, body, sp);\n }\n "}, {"sha": "ec25dcc7e837691915a229bfc571828b3069ee45", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d552b71b89633fe6692bf2214a2d001683bfa9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=d3d552b71b89633fe6692bf2214a2d001683bfa9", "patch": "@@ -159,6 +159,9 @@ pub struct Assignment {\n \n     /// span of node where assignment occurs\n     pub span: Span,\n+\n+    /// id for l-value expression on lhs of assignment\n+    pub assignee_id: ast::NodeId,\n }\n \n #[derive(Copy, Clone)]\n@@ -412,6 +415,7 @@ impl<'tcx> MoveData<'tcx> {\n             path: path_index,\n             id: assign_id,\n             span: span,\n+            assignee_id: assignee_id,\n         };\n \n         if self.is_var_path(path_index) {"}]}