{"sha": "92e24b95167897881377d43ce3ee6aa7ba2685a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZTI0Yjk1MTY3ODk3ODgxMzc3ZDQzY2UzZWU2YWE3YmEyNjg1YTQ=", "commit": {"author": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-02-16T16:09:17Z"}, "committer": {"name": "Andrea Canciani", "email": "ranma42@gmail.com", "date": "2016-04-08T22:41:23Z"}, "message": "Expose the features computed from LLVM in `cfg!`\n\nInstead of relying on the features explicitly passed through the\ncommand line, compute them from the LLVM `TargetMachine`.", "tree": {"sha": "7041e6c4f0064d16147206779d65cd7d42d7983c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7041e6c4f0064d16147206779d65cd7d42d7983c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92e24b95167897881377d43ce3ee6aa7ba2685a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92e24b95167897881377d43ce3ee6aa7ba2685a4", "html_url": "https://github.com/rust-lang/rust/commit/92e24b95167897881377d43ce3ee6aa7ba2685a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92e24b95167897881377d43ce3ee6aa7ba2685a4/comments", "author": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ranma42", "id": 1506030, "node_id": "MDQ6VXNlcjE1MDYwMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1506030?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ranma42", "html_url": "https://github.com/ranma42", "followers_url": "https://api.github.com/users/ranma42/followers", "following_url": "https://api.github.com/users/ranma42/following{/other_user}", "gists_url": "https://api.github.com/users/ranma42/gists{/gist_id}", "starred_url": "https://api.github.com/users/ranma42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ranma42/subscriptions", "organizations_url": "https://api.github.com/users/ranma42/orgs", "repos_url": "https://api.github.com/users/ranma42/repos", "events_url": "https://api.github.com/users/ranma42/events{/privacy}", "received_events_url": "https://api.github.com/users/ranma42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c883463e9481ca58c9c3b0aefe7873c88e2aa4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c883463e9481ca58c9c3b0aefe7873c88e2aa4e0", "html_url": "https://github.com/rust-lang/rust/commit/c883463e9481ca58c9c3b0aefe7873c88e2aa4e0"}], "stats": {"total": 94, "additions": 31, "deletions": 63}, "files": [{"sha": "7c3c7b2e7b67846ac2e415aec33958ecb1de7417", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 31, "deletions": 63, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/92e24b95167897881377d43ce3ee6aa7ba2685a4/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92e24b95167897881377d43ce3ee6aa7ba2685a4/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=92e24b95167897881377d43ce3ee6aa7ba2685a4", "patch": "@@ -9,79 +9,47 @@\n // except according to those terms.\n \n use syntax::{ast, attr};\n+use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n+use rustc_trans::back::write::create_target_machine;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::intern_and_get_ident as intern;\n+use libc::c_char;\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n-/// This uses a scheme similar to that employed by clang: reimplement\n-/// the target feature knowledge. *Theoretically* we could query LLVM\n-/// since that has perfect knowledge about what things are enabled in\n-/// code-generation, however, it is extremely non-obvious how to do\n-/// this successfully. Each platform defines a subclass of a\n-/// SubtargetInfo, which knows all this information, but the ways to\n-/// query them do not seem to be public.\n+/// This is performed by checking whether a whitelisted set of\n+/// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let tf = InternedString::new(\"target_feature\");\n-    macro_rules! fillout {\n-        ($($func: ident, $name: expr;)*) => {{\n-            $(if $func(sess) {\n-                cfg.push(attr::mk_name_value_item_str(tf.clone(), intern($name)))\n-            })*\n-        }}\n-    }\n-    fillout! {\n-        has_sse, \"sse\";\n-        has_sse2, \"sse2\";\n-        has_sse3, \"sse3\";\n-        has_ssse3, \"ssse3\";\n-        has_sse41, \"sse4.1\";\n-        has_sse42, \"sse4.2\";\n-        has_avx, \"avx\";\n-        has_avx2, \"avx2\";\n-        has_neon, \"neon\";\n-        has_vfp, \"vfp\";\n-    }\n-}\n+    let target_machine = create_target_machine(sess);\n \n+    let arm_whitelist = [\n+        \"neon\\0\",\n+        \"vfp\\0\",\n+    ];\n \n-fn features_contain(sess: &Session, s: &str) -> bool {\n-    sess.target.target.options.features.contains(s) || sess.opts.cg.target_feature.contains(s)\n-}\n+    let x86_whitelist = [\n+        \"avx\\0\",\n+        \"avx2\\0\",\n+        \"sse\\0\",\n+        \"sse2\\0\",\n+        \"sse3\\0\",\n+        \"sse4.1\\0\",\n+        \"sse4.2\\0\",\n+        \"ssse3\\0\",\n+    ];\n \n-pub fn has_sse(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse\") || has_sse2(sess)\n-}\n-pub fn has_sse2(sess: &Session) -> bool {\n-    // x86-64 requires at least SSE2 support\n-    sess.target.target.arch == \"x86_64\" || features_contain(sess, \"+sse2\") || has_sse3(sess)\n-}\n-pub fn has_sse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse3\") || has_ssse3(sess)\n-}\n-pub fn has_ssse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+ssse3\") || has_sse41(sess)\n-}\n-pub fn has_sse41(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.1\") || has_sse42(sess)\n-}\n-pub fn has_sse42(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.2\") || has_avx(sess)\n-}\n-pub fn has_avx(sess: &Session) -> bool {\n-    features_contain(sess, \"+avx\") || has_avx2(sess)\n-}\n-pub fn has_avx2(sess: &Session) -> bool {\n-    features_contain(sess, \"+avx2\")\n-}\n+    let whitelist = match &*sess.target.target.arch {\n+        \"arm\" => &arm_whitelist[..],\n+        \"x86\" | \"x86_64\" => &x86_whitelist[..],\n+        _ => &[][..],\n+    };\n \n-pub fn has_neon(sess: &Session) -> bool {\n-    // AArch64 requires NEON support\n-    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+neon\")\n-}\n-pub fn has_vfp(sess: &Session) -> bool {\n-    // AArch64 requires VFP support\n-    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+vfp\")\n+    let tf = InternedString::new(\"target_feature\");\n+    for feat in whitelist {\n+        if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n+            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(feat)))\n+        }\n+    }\n }"}]}