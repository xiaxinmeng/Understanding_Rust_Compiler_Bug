{"sha": "4d81b14b80a076fa249a4b7022688c600f2e9590", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkODFiMTRiODBhMDc2ZmEyNDlhNGI3MDIyNjg4YzYwMGYyZTk1OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-02T20:44:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-02T20:44:03Z"}, "message": "Auto merge of #41605 - tschottdorf:param-env, r=nikomatsakis\n\nStore interned predicates in ParameterEnvironment\n\nSee #41444. As a first step towards untangling `ParameterEnvironment`, change\nits `caller_bounds` field from a `Vec` into an interned slice of\n`ty::Predicate`s.\n\nThis change is intentionally well-contained and doesn't pull on any of the\nloose ends. In particular, you'll note that `normalize_param_env_or_error`\nnow interns twice.", "tree": {"sha": "e86be0801998a7962b6f8d4961c6a4e2b14e46d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e86be0801998a7962b6f8d4961c6a4e2b14e46d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d81b14b80a076fa249a4b7022688c600f2e9590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d81b14b80a076fa249a4b7022688c600f2e9590", "html_url": "https://github.com/rust-lang/rust/commit/4d81b14b80a076fa249a4b7022688c600f2e9590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d81b14b80a076fa249a4b7022688c600f2e9590/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a5fc9eecec235312755e737fb5b984abe537f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5fc9eecec235312755e737fb5b984abe537f2e", "html_url": "https://github.com/rust-lang/rust/commit/6a5fc9eecec235312755e737fb5b984abe537f2e"}, {"sha": "a6658d5ff1bee0aa46224bc05985692783fd11b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6658d5ff1bee0aa46224bc05985692783fd11b4", "html_url": "https://github.com/rust-lang/rust/commit/a6658d5ff1bee0aa46224bc05985692783fd11b4"}], "stats": {"total": 77, "additions": 59, "deletions": 18}, "files": [{"sha": "2f525e1b8b45c5afcba01f3f6fc720c09ecd81e5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -462,7 +462,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            unnormalized_env);\n \n     let predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n         .filter(|p| !p.is_global()) // (*)\n         .collect();\n \n@@ -477,11 +477,19 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n \n-    let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n+    let elaborated_env = unnormalized_env.with_caller_bounds(tcx.intern_predicates(&predicates));\n \n     tcx.infer_ctxt(elaborated_env, Reveal::UserFacing).enter(|infcx| {\n-        let predicates = match fully_normalize(&infcx, cause,\n-                                               &infcx.parameter_environment.caller_bounds) {\n+        let predicates = match fully_normalize(\n+                &infcx, cause,\n+                // You would really want to pass infcx.parameter_environment.caller_bounds here,\n+                // but that is an interned slice, and fully_normalize takes &T and returns T, so\n+                // without further refactoring, a slice can't be used. Luckily, we still have the\n+                // predicate vector from which we created the ParameterEnvironment in infcx, so we\n+                // can pass that instead. It's roundabout and a bit brittle, but this code path\n+                // ought to be refactored anyway, and until then it saves us from having to copy.\n+                &predicates,\n+        ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n                 infcx.report_fulfillment_errors(&errors);\n@@ -520,7 +528,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n             predicates);\n \n-        infcx.parameter_environment.with_caller_bounds(predicates)\n+        infcx.parameter_environment.with_caller_bounds(tcx.intern_predicates(&predicates))\n     })\n }\n "}, {"sha": "ef0240296ccc55ab53f3ef99e2aba7dfa9f9d0c3", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -32,7 +32,7 @@ use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n+use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n@@ -96,6 +96,7 @@ pub struct CtxtInterners<'tcx> {\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind<'tcx>>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n+    predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -107,6 +108,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             substs: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n+            predicates: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -1130,6 +1132,13 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n+    for Interned<'tcx, Slice<Predicate<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [Predicate<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1224,6 +1233,7 @@ macro_rules! slice_interners {\n \n slice_interners!(\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n+    predicates: _intern_predicates(Predicate),\n     type_list: _intern_type_list(Ty),\n     substs: _intern_substs(Kind)\n );\n@@ -1443,6 +1453,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self._intern_existential_predicates(eps)\n     }\n \n+    pub fn intern_predicates(self, preds: &[Predicate<'tcx>])\n+        -> &'tcx Slice<Predicate<'tcx>> {\n+        // FIXME consider asking the input slice to be sorted to avoid\n+        // re-interning permutations, in which case that would be asserted\n+        // here.\n+        if preds.len() == 0 {\n+            // The macro-generated method below asserts we don't intern an empty slice.\n+            Slice::empty()\n+        } else {\n+            self._intern_predicates(preds)\n+        }\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n         if ts.len() == 0 {\n             Slice::empty()\n@@ -1481,6 +1504,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         iter.intern_with(|xs| self.intern_existential_predicates(xs))\n     }\n \n+    pub fn mk_predicates<I: InternAs<[Predicate<'tcx>],\n+                                     &'tcx Slice<Predicate<'tcx>>>>(self, iter: I)\n+                                     -> I::Output {\n+        iter.intern_with(|xs| self.intern_predicates(xs))\n+    }\n+\n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n                         &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))"}, {"sha": "bf0f75cf323efbb019f54db584bc5d3aa58261a6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -747,7 +747,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -876,7 +876,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -928,18 +928,18 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<ty::Region<'tcx>,\n                                                                    ty::Region<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n     pub a: Ty<'tcx>,\n@@ -1173,7 +1173,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n-    pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n+    pub caller_bounds: &'tcx [ty::Predicate<'tcx>],\n \n     /// Scope that is attached to free regions for this scope. This is\n     /// usually the id of the fn body, but for more abstract scopes\n@@ -1196,7 +1196,7 @@ pub struct ParameterEnvironment<'tcx> {\n \n impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     pub fn with_caller_bounds(&self,\n-                              caller_bounds: Vec<ty::Predicate<'tcx>>)\n+                              caller_bounds: &'tcx [ty::Predicate<'tcx>])\n                               -> ParameterEnvironment<'tcx>\n     {\n         ParameterEnvironment {\n@@ -2441,7 +2441,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n-            caller_bounds: Vec::new(),\n+            caller_bounds: Slice::empty(),\n             implicit_region_bound: None,\n             free_id_outlive: None,\n             is_copy_cache: RefCell::new(FxHashMap()),\n@@ -2516,7 +2516,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let unnormalized_env = ty::ParameterEnvironment {\n             free_substs: free_substs,\n             implicit_region_bound: free_id_outlive.map(|f| tcx.mk_region(ty::ReScope(f))),\n-            caller_bounds: predicates,\n+            caller_bounds: tcx.intern_predicates(&predicates),\n             free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),"}, {"sha": "24dfae3c54065f76b43073d2d0435d3ccff400ff", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -313,6 +313,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Requires that trait definitions have been processed so that we can\n     /// elaborate predicates and walk supertraits.\n+    ///\n+    /// FIXME callers may only have a &[Predicate], not a Vec, so that's\n+    /// what this code should accept.\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)"}, {"sha": "9ed5528e86783905c6e2c46e477c4c1aa6235778", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -218,7 +218,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n-    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n+    let trait_param_env = impl_param_env.with_caller_bounds(\n+        tcx.intern_predicates(&hybrid_preds.predicates));\n     let trait_param_env = traits::normalize_param_env_or_error(tcx,\n                                                                impl_m.def_id,\n                                                                trait_param_env,"}, {"sha": "c1cf5192877c0d45246e5b003c4d63c1a5a20d9a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -893,7 +893,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let caller_predicates = self.parameter_environment.caller_bounds.clone();\n+        let caller_predicates = self.parameter_environment.caller_bounds.to_vec();\n         for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n             .filter_map(|p| p.to_opt_poly_trait_ref())\n             .filter(|b| b.def_id() == trait_def_id) {"}, {"sha": "e4936dfc47bc749f2980dd79545bf98630377843", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d81b14b80a076fa249a4b7022688c600f2e9590/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4d81b14b80a076fa249a4b7022688c600f2e9590", "patch": "@@ -1687,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // To start, collect bounds from user:\n         let mut param_bounds = self.tcx.required_region_bounds(generic.to_ty(self.tcx),\n-                                                               param_env.caller_bounds.clone());\n+                                                               param_env.caller_bounds.to_vec());\n \n         // Next, collect regions we scraped from the well-formedness\n         // constraints in the fn signature. To do that, we walk the list"}]}