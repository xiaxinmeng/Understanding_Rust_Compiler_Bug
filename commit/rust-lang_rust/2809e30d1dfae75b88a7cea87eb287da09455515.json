{"sha": "2809e30d1dfae75b88a7cea87eb287da09455515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MDllMzBkMWRmYWU3NWI4OGE3Y2VhODdlYjI4N2RhMDk0NTU1MTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-28T23:49:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-28T23:49:26Z"}, "message": "rustc: Parse types in external metadata", "tree": {"sha": "912c6763a644e8125514c7c011ba23bad0568a5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/912c6763a644e8125514c7c011ba23bad0568a5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2809e30d1dfae75b88a7cea87eb287da09455515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2809e30d1dfae75b88a7cea87eb287da09455515", "html_url": "https://github.com/rust-lang/rust/commit/2809e30d1dfae75b88a7cea87eb287da09455515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2809e30d1dfae75b88a7cea87eb287da09455515/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ace2c92a96eb4ac46913305854235592aa9207ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ace2c92a96eb4ac46913305854235592aa9207ae", "html_url": "https://github.com/rust-lang/rust/commit/ace2c92a96eb4ac46913305854235592aa9207ae"}], "stats": {"total": 99, "additions": 74, "deletions": 25}, "files": [{"sha": "dae18cb4283adeb6183cd514e5c96ec4df432ae6", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 72, "deletions": 25, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2809e30d1dfae75b88a7cea87eb287da09455515/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2809e30d1dfae75b88a7cea87eb287da09455515/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=2809e30d1dfae75b88a7cea87eb287da09455515", "patch": "@@ -321,7 +321,7 @@ impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n     fail;\n }\n \n-impure fn move_to_item(&ebml.reader ebml_r, ast.def_id did) {\n+impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto outer_ebml_tag = ebml.peek(ebml_r);\n         if (outer_ebml_tag.id == metadata.tag_items) {\n@@ -341,8 +341,7 @@ impure fn move_to_item(&ebml.reader ebml_r, ast.def_id did) {\n                             ebml.move_to_parent(ebml_r);\n \n                             auto this_did = parse_def_id(did_data);\n-                            if (did._0 == this_did._0 &&\n-                                    did._1 == this_did._1) {\n+                            if (this_did._1 == item_id) {\n                                 // Move to the start of this item's data.\n                                 ebml.move_to_parent(ebml_r);\n                                 ebml.move_to_first_child(ebml_r);\n@@ -360,58 +359,102 @@ impure fn move_to_item(&ebml.reader ebml_r, ast.def_id did) {\n         ebml.move_to_next_sibling(ebml_r);\n     }\n \n-    log #fmt(\"move_to_item: item not found: %d:%d\", did._0, did._1);\n+    log #fmt(\"move_to_item: item not found: %d\", item_id);\n }\n \n // Looks up an item in the given metadata and returns an EBML reader pointing\n // to the item data.\n-impure fn lookup_item(ast.def_id did, vec[u8] data) -> ebml.reader {\n+impure fn lookup_item(int item_id, vec[u8] data) -> ebml.reader {\n     auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n     auto ebml_r = ebml.create_reader(io_r);\n-    move_to_item(ebml_r, did);\n+    move_to_item(ebml_r, item_id);\n     ret ebml_r;\n }\n \n-impure fn get_item_kind(&ebml.reader ebml_r) -> u8 {\n+impure fn get_item_generic[T](&ebml.reader ebml_r, uint tag_id,\n+        impure fn(vec[u8] buf) -> T converter) -> T {\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == metadata.tag_items_kind) {\n+        if (ebml_tag.id == tag_id) {\n             ebml.move_to_first_child(ebml_r);\n-            auto kind_ch = ebml.read_data(ebml_r).(0);\n+            auto result = converter(ebml.read_data(ebml_r));\n \n-            // Reset the EBML reader so the callee can use it to look up\n-            // additional info about the item.\n+            // Be kind, rewind.\n             ebml.move_to_parent(ebml_r);\n             ebml.move_to_parent(ebml_r);\n             ebml.move_to_first_child(ebml_r);\n \n-            ret kind_ch;\n+            ret result;\n         }\n         ebml.move_to_next_sibling(ebml_r);\n     }\n \n-    log \"get_item_kind(): no kind found\";\n+    log #fmt(\"get_item_generic(): tag %u not found\", tag_id);\n     fail;\n }\n \n+impure fn get_item_kind(&ebml.reader ebml_r) -> u8 {\n+    impure fn converter(vec[u8] data) -> u8 {\n+        auto x = @mutable 3;\n+        *x = 5;\n+        ret data.(0);\n+    }\n+    auto f = converter;\n+    ret get_item_generic[u8](ebml_r, metadata.tag_items_kind, f);\n+}\n+\n+// FIXME: This is a *terrible* botch.\n+impure fn impure_parse_def_id(vec[u8] data) -> ast.def_id {\n+    auto x = @mutable 3;\n+    *x = 5;\n+    ret parse_def_id(data);\n+}\n+\n impure fn get_variant_tag_id(&ebml.reader ebml_r) -> ast.def_id {\n+    auto f = impure_parse_def_id;\n+    ret get_item_generic[ast.def_id](ebml_r, metadata.tag_items_tag_id, f);\n+}\n+\n+impure fn get_item_type(&ebml.reader ebml_r, int this_cnum) -> @ty.t {\n+    impure fn converter(int this_cnum, vec[u8] data) -> @ty.t {\n+        fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n+            // FIXME: This is completely wrong when linking against a crate\n+            // that, in turn, links against another crate. We need a mapping\n+            // from crate ID to crate \"meta\" attributes as part of the crate\n+            // metadata.\n+            auto buf = _str.bytes(s);\n+            auto external_def_id = parse_def_id(buf);\n+            ret tup(this_cnum, external_def_id._1);\n+        }\n+        auto s = _str.unsafe_from_bytes(data);\n+        ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n+    }\n+    auto f = bind converter(this_cnum, _);\n+    ret get_item_generic[@ty.t](ebml_r, metadata.tag_items_type, f);\n+}\n+\n+impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n+        -> vec[ast.def_id] {\n+    let vec[ast.def_id] tps = vec();\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == metadata.tag_items_tag_id) {\n+        if (ebml_tag.id == metadata.tag_items_ty_param) {\n             ebml.move_to_first_child(ebml_r);\n-            auto tid = parse_def_id(ebml.read_data(ebml_r));\n \n-            // Be kind, rewind.\n-            ebml.move_to_parent(ebml_r);\n-            ebml.move_to_parent(ebml_r);\n-            ebml.move_to_first_child(ebml_r);\n+            auto data = ebml.read_data(ebml_r);\n+            auto external_def_id = parse_def_id(data);\n+            tps += vec(tup(this_cnum, external_def_id._1));\n \n-            ret tid;\n+            ebml.move_to_parent(ebml_r);\n         }\n+        ebml.move_to_next_sibling(ebml_r);\n     }\n \n-    log \"get_variant_tag_id(): no tag ID found\";\n-    fail;\n+    // Be kind, rewind.\n+    ebml.move_to_parent(ebml_r);\n+    ebml.move_to_first_child(ebml_r);\n+\n+    ret tps;\n }\n \n \n@@ -500,7 +543,7 @@ fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n         }\n     }\n \n-    auto ebml_r = lookup_item(did, data);\n+    auto ebml_r = lookup_item(did._1, data);\n     auto kind_ch = get_item_kind(ebml_r);\n \n     did = tup(cnum, did._1);\n@@ -522,8 +565,12 @@ fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n }\n \n fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_and_ty {\n-    // FIXME: fill in.\n-    fail;\n+    auto external_crate_id = def._0;\n+    auto data = sess.get_external_crate(external_crate_id);\n+    auto ebml_r = lookup_item(def._1, data);\n+    auto t = get_item_type(ebml_r, external_crate_id);\n+    auto tps = get_item_ty_params(ebml_r, external_crate_id);\n+    ret tup(tps, t);\n }\n \n // Local Variables:"}, {"sha": "f331eba0db6880e0ecd51c8e28cdd68bd8c2384c", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2809e30d1dfae75b88a7cea87eb287da09455515/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2809e30d1dfae75b88a7cea87eb287da09455515/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=2809e30d1dfae75b88a7cea87eb287da09455515", "patch": "@@ -44,6 +44,8 @@ mod util {\n auth driver.rustc.main = impure;\n auth front.creader.load_crate = unsafe;\n auth front.creader.lookup_def = impure;\n+auth front.creader.get_type = impure;\n+auth front.creader.impure_no_op = impure;\n auth middle.metadata = unsafe;\n auth middle.trans = unsafe;\n auth middle.trans.copy_args_to_allocas = impure;"}]}