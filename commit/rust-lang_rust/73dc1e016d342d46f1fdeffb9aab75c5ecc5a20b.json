{"sha": "73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZGMxZTAxNmQzNDJkNDZmMWZkZWZmYjlhYWI3NWM1ZWNjNWEyMGI=", "commit": {"author": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2014-05-15T00:13:36Z"}, "committer": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2014-05-15T00:13:36Z"}, "message": "Rename HashMap.mangle to find_with_or_insert_with.\n\nThis also entails swapping the order of the find and insert callbacks so\nthat their order matches the order of the terms in the method name.", "tree": {"sha": "dc40fd6aeb0205457f1b6f629d236a8d4a350c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc40fd6aeb0205457f1b6f629d236a8d4a350c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b", "html_url": "https://github.com/rust-lang/rust/commit/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b/comments", "author": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acdce638528618c9f1113b651e296031c7c2a85c", "url": "https://api.github.com/repos/rust-lang/rust/commits/acdce638528618c9f1113b651e296031c7c2a85c", "html_url": "https://github.com/rust-lang/rust/commit/acdce638528618c9f1113b651e296031c7c2a85c"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "35a89fe5dc5decd168266c5c7aba0e96e0340efe", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=73dc1e016d342d46f1fdeffb9aab75c5ecc5a20b", "patch": "@@ -1239,14 +1239,14 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        self.mangle(k, v, |_k, a| a, |_k, _v, _a| ())\n+        self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n-        self.mangle(k, (), |k, _a| f(k), |_k, _v, _a| ())\n+        self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n@@ -1258,7 +1258,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                  v: V,\n                                  f: |&K, &mut V|)\n                                  -> &'a mut V {\n-        self.mangle(k, v, |_k, a| a, |k, v, _a| f(k, v))\n+        self.find_with_or_insert_with(k, v, |k, v, _a| f(k, v), |_k, a| a)\n     }\n \n     /// Modify and return the value corresponding to the key in the map, or\n@@ -1282,31 +1282,33 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let new = vec![\"a key\", \"b key\", \"z key\"];\n     ///\n     /// for k in new.move_iter() {\n-    ///     map.mangle(k, \"new value\",\n-    ///                // if the key doesn't exist in the map yet, add it in\n-    ///                // the obvious way.\n-    ///                |_k, v| vec![v],\n-    ///                // if the key does exist either prepend or append this\n-    ///                // new value based on the first letter of the key.\n-    ///                |key, already, new| {\n-    ///                    if key.as_slice().starts_with(\"z\") {\n-    ///                        already.unshift(new);\n-    ///                    } else {\n-    ///                        already.push(new);\n-    ///                    }\n-    ///                });\n+    ///     map.find_with_or_insert_with(\n+    ///         k, \"new value\",\n+    ///         // if the key does exist either prepend or append this\n+    ///         // new value based on the first letter of the key.\n+    ///         |key, already, new| {\n+    ///             if key.as_slice().starts_with(\"z\") {\n+    ///                 already.unshift(new);\n+    ///             } else {\n+    ///                 already.push(new);\n+    ///             }\n+    ///         },\n+    ///         // if the key doesn't exist in the map yet, add it in\n+    ///         // the obvious way.\n+    ///         |_k, v| vec![v],\n+    ///     );\n     /// }\n     ///\n     /// for (k, v) in map.iter() {\n     ///     println!(\"{} -> {}\", *k, *v);\n     /// }\n     /// ```\n-    pub fn mangle<'a, A>(&'a mut self,\n-                         k: K,\n-                         a: A,\n-                         not_found: |&K, A| -> V,\n-                         found: |&K, &mut V, A|)\n-                        -> &'a mut V {\n+    pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n+                                           k: K,\n+                                           a: A,\n+                                           found: |&K, &mut V, A|,\n+                                           not_found: |&K, A| -> V)\n+                                          -> &'a mut V {\n         let hash = self.make_hash(&k);\n         match self.search_hashed(&hash, &k) {\n             None => {"}]}