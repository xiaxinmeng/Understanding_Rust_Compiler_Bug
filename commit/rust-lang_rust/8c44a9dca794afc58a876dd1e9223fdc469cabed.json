{"sha": "8c44a9dca794afc58a876dd1e9223fdc469cabed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNDRhOWRjYTc5NGFmYzU4YTg3NmRkMWU5MjIzZmRjNDY5Y2FiZWQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-07T12:57:51Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-09T21:20:25Z"}, "message": "Store all generic arguments for method calls in HIR", "tree": {"sha": "0378d8f2f034a2111bd1b059b7d1584f97a09aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0378d8f2f034a2111bd1b059b7d1584f97a09aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c44a9dca794afc58a876dd1e9223fdc469cabed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c44a9dca794afc58a876dd1e9223fdc469cabed", "html_url": "https://github.com/rust-lang/rust/commit/8c44a9dca794afc58a876dd1e9223fdc469cabed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c44a9dca794afc58a876dd1e9223fdc469cabed/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "287de2595a40c03d9ffe81f55c13c731fd01583f", "url": "https://api.github.com/repos/rust-lang/rust/commits/287de2595a40c03d9ffe81f55c13c731fd01583f", "html_url": "https://github.com/rust-lang/rust/commit/287de2595a40c03d9ffe81f55c13c731fd01583f"}], "stats": {"total": 122, "additions": 55, "deletions": 67}, "files": [{"sha": "57198d8ca0b77433ea8a265c8381ee68f51670a0", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -944,10 +944,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_expr, arguments);\n             visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(ref name, ref types, ref arguments) => {\n-            visitor.visit_name(name.span, name.node);\n+        ExprMethodCall(ref segment, _, ref arguments) => {\n+            visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n-            walk_list!(visitor, visit_ty, types);\n         }\n         ExprBinary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);"}, {"sha": "67dc069da41314b62a6844af6a246fb948e4dfca", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -1845,16 +1845,9 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let tps = match seg.parameters {\n-                    Some(ref params) => match **params {\n-                        PathParameters::AngleBracketed(ref param_data) => &param_data.types[..],\n-                        _ => &[],\n-                    },\n-                    _ => &[],\n-                };\n-                let tps = tps.iter().map(|x| self.lower_ty(x)).collect();\n+                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(respan(seg.span, self.lower_ident(seg.identifier)), tps, args)\n+                hir::ExprMethodCall(hir_seg, seg.span, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);"}, {"sha": "fd79ec3b6b92ce539b66b9879186e7a3ba710d16", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -972,19 +972,16 @@ pub enum Expr_ {\n     /// The first field resolves to the function itself (usually an `ExprPath`),\n     /// and the second field is the list of arguments\n     ExprCall(P<Expr>, HirVec<Expr>),\n-    /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n+    /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n     ///\n-    /// The `Spanned<Name>` is the identifier for the method name.\n-    /// The vector of `Ty`s are the ascripted type parameters for the method\n+    /// The `PathSegment`/`Span` represent the method name and its generic arguments\n     /// (within the angle brackets).\n-    ///\n-    /// The first element of the vector of `Expr`s is the expression that\n-    /// evaluates to the object on which the method is being called on (the\n-    /// receiver), and the remaining elements are the rest of the arguments.\n-    ///\n+    /// The first element of the vector of `Expr`s is the expression that evaluates\n+    /// to the object on which the method is being called on (the receiver),\n+    /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<Expr>),\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n+    ExprMethodCall(PathSegment, Span, HirVec<Expr>),\n     /// A tuple (`(a, b, c ,d)`)\n     ExprTup(HirVec<Expr>),\n     /// A binary operation (For example: `a + b`, `a * b`)"}, {"sha": "1f7b73d134596cb49911d4bae46e7975b3021592", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -1188,18 +1188,17 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_method_call(&mut self,\n-                              name: Spanned<ast::Name>,\n-                              tys: &[P<hir::Ty>],\n+                              segment: &hir::PathSegment,\n                               args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n         word(&mut self.s, \".\")?;\n-        self.print_name(name.node)?;\n-        if !tys.is_empty() {\n-            word(&mut self.s, \"::<\")?;\n-            self.commasep(Inconsistent, tys, |s, ty| s.print_type(&ty))?;\n-            word(&mut self.s, \">\")?;\n+        self.print_name(segment.name)?;\n+        if !segment.parameters.lifetimes().is_empty() ||\n+                !segment.parameters.types().is_empty() ||\n+                !segment.parameters.bindings().is_empty() {\n+            self.print_path_parameters(&segment.parameters, true)?;\n         }\n         self.print_call_post(base_args)\n     }\n@@ -1254,8 +1253,8 @@ impl<'a> State<'a> {\n             hir::ExprCall(ref func, ref args) => {\n                 self.print_expr_call(&func, args)?;\n             }\n-            hir::ExprMethodCall(name, ref tys, ref args) => {\n-                self.print_expr_method_call(name, &tys[..], args)?;\n+            hir::ExprMethodCall(ref segment, _, ref args) => {\n+                self.print_expr_method_call(segment, args)?;\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, &lhs, &rhs)?;"}, {"sha": "c82fea197fb751f5692c527c1441af95220db578", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -626,7 +626,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprBox(sub),\n     ExprArray(subs),\n     ExprCall(callee, args),\n-    ExprMethodCall(name, ts, args),\n+    ExprMethodCall(segment, span, args),\n     ExprTup(fields),\n     ExprBinary(op, lhs, rhs),\n     ExprUnary(op, operand),"}, {"sha": "4a74a9e524d0ccdd3d75c91ffa5a5752f688daaf", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -670,10 +670,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     return;\n                 }\n             }\n-            hir::ExprMethodCall(name, ..) => {\n+            hir::ExprMethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n                 let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n-                self.span = name.span;\n+                self.span = span;\n                 if self.tcx.type_of(def_id).visit_with(self) {\n                     return;\n                 }"}, {"sha": "0829951e12debfdaaed9d6d6d15f6aa5c89fc109", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -44,15 +44,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           call_expr: &'gcx hir::Expr,\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n-                          supplied_method_types: Vec<Ty<'tcx>>)\n+                          segment: &hir::PathSegment)\n                           -> MethodCallee<'tcx> {\n-        debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n+        debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n                unadjusted_self_ty,\n                pick,\n-               supplied_method_types);\n+               segment.parameters);\n \n         let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n-        confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n+        confirm_cx.confirm(unadjusted_self_ty, pick, segment)\n     }\n }\n \n@@ -73,7 +73,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn confirm(&mut self,\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n-               supplied_method_types: Vec<Ty<'tcx>>)\n+               segment: &hir::PathSegment)\n                -> MethodCallee<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create substitutions for the method's type parameters.\n         let rcvr_substs = self.fresh_receiver_substs(self_ty, &pick);\n-        let all_substs = self.instantiate_method_substs(&pick, supplied_method_types, rcvr_substs);\n+        let all_substs = self.instantiate_method_substs(&pick, segment, rcvr_substs);\n \n         debug!(\"all_substs={:?}\", all_substs);\n \n@@ -279,9 +279,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n-                                 mut supplied_method_types: Vec<Ty<'tcx>>,\n+                                 segment: &hir::PathSegment,\n                                  substs: &Substs<'tcx>)\n                                  -> &'tcx Substs<'tcx> {\n+        let supplied_method_types = match segment.parameters {\n+            hir::AngleBracketedParameters(ref data) => &data.types,\n+            _ => bug!(\"unexpected generic arguments: {:?}\", segment.parameters),\n+        };\n+\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n@@ -312,7 +317,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                          num_method_types))\n                     .emit();\n             }\n-            supplied_method_types = vec![self.tcx.types.err; num_method_types];\n         }\n \n         // Create subst for early-bound lifetime parameters, combining\n@@ -331,10 +335,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let i = def.index as usize;\n             if i < substs.len() {\n                 substs.type_at(i)\n-            } else if supplied_method_types.is_empty() {\n-                self.type_var_for_def(self.span, def, cur_substs)\n+            } else if let Some(ast_ty) = supplied_method_types.get(i - supplied_start) {\n+                self.to_ty(ast_ty)\n             } else {\n-                supplied_method_types[i - supplied_start]\n+                self.type_var_for_def(self.span, def, cur_substs)\n             }\n         })\n     }"}, {"sha": "c842e47aaf51cbaac5bbe686ed14646348a68c44", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -130,22 +130,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// * `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n     /// * `self_expr`:             the self expression (`foo`)\n     pub fn lookup_method(&self,\n-                         span: Span,\n-                         method_name: ast::Name,\n                          self_ty: ty::Ty<'tcx>,\n-                         supplied_method_types: Vec<ty::Ty<'tcx>>,\n+                         segment: &hir::PathSegment,\n+                         span: Span,\n                          call_expr: &'gcx hir::Expr,\n                          self_expr: &'gcx hir::Expr)\n                          -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n-               method_name,\n+               segment.name,\n                self_ty,\n                call_expr,\n                self_expr);\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+        let pick = self.probe_for_name(span, mode, segment.name, IsSuggestion(false),\n                                        self_ty, call_expr.id)?;\n \n         if let Some(import_id) = pick.import_id {\n@@ -161,7 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                call_expr,\n                                self_ty,\n                                pick,\n-                               supplied_method_types))\n+                               segment))\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators."}, {"sha": "2634e8fcc006d5476114216b68fc2f2a057d7722", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c44a9dca794afc58a876dd1e9223fdc469cabed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c44a9dca794afc58a876dd1e9223fdc469cabed", "patch": "@@ -2771,33 +2771,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Checks a method call.\n     fn check_method_call(&self,\n                          expr: &'gcx hir::Expr,\n-                         method_name: Spanned<ast::Name>,\n+                         segment: &hir::PathSegment,\n+                         span: Span,\n                          args: &'gcx [hir::Expr],\n-                         tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n                          lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         let rcvr = &args[0];\n         let rcvr_t = self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n-\n         // no need to check for bot/err -- callee does that\n-        let expr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n+        let rcvr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n-        let tps = tps.iter().map(|ast_ty| self.to_ty(&ast_ty)).collect::<Vec<_>>();\n-        let method = match self.lookup_method(method_name.span,\n-                                              method_name.node,\n-                                              expr_t,\n-                                              tps,\n+        let method = match self.lookup_method(rcvr_t,\n+                                              segment,\n+                                              span,\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n                 self.write_method_call(expr.id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n-                if method_name.node != keywords::Invalid.name() {\n-                    self.report_method_error(method_name.span,\n-                                             expr_t,\n-                                             method_name.node,\n+                if segment.name != keywords::Invalid.name() {\n+                    self.report_method_error(span,\n+                                             rcvr_t,\n+                                             segment.name,\n                                              Some(rcvr),\n                                              error,\n                                              Some(args));\n@@ -2807,7 +2804,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(method_name.span, method,\n+        self.check_method_argument_types(span, method,\n                                          &args[1..],\n                                          DontTupleArguments,\n                                          expected)\n@@ -3735,8 +3732,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprCall(ref callee, ref args) => {\n               self.check_call(expr, &callee, args, expected)\n           }\n-          hir::ExprMethodCall(name, ref tps, ref args) => {\n-              self.check_method_call(expr, name, args, &tps[..], expected, lvalue_pref)\n+          hir::ExprMethodCall(ref segment, span, ref args) => {\n+              self.check_method_call(expr, segment, span, args, expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             // Find the type of `e`. Supply hints based on the type we are casting to,"}]}