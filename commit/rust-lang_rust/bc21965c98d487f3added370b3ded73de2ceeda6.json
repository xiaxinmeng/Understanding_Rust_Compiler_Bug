{"sha": "bc21965c98d487f3added370b3ded73de2ceeda6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMjE5NjVjOThkNDg3ZjNhZGRlZDM3MGIzZGVkNzNkZTJjZWVkYTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-18T01:24:33Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-18T01:24:33Z"}, "message": "Use homebrew memcpy, not llvm intrinsic. Can't run the latter on a rust stack.", "tree": {"sha": "bcd5b33f989f541cfd0e44ecdf71eae86f234b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcd5b33f989f541cfd0e44ecdf71eae86f234b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc21965c98d487f3added370b3ded73de2ceeda6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc21965c98d487f3added370b3ded73de2ceeda6", "html_url": "https://github.com/rust-lang/rust/commit/bc21965c98d487f3added370b3ded73de2ceeda6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc21965c98d487f3added370b3ded73de2ceeda6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "156e1b363fb7058c7bd734c5664b8f467b1afcd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/156e1b363fb7058c7bd734c5664b8f467b1afcd5", "html_url": "https://github.com/rust-lang/rust/commit/156e1b363fb7058c7bd734c5664b8f467b1afcd5"}], "stats": {"total": 98, "additions": 66, "deletions": 32}, "files": [{"sha": "0c940d2b5cb18ab802a760198f03bb72dc646a86", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc21965c98d487f3added370b3ded73de2ceeda6/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc21965c98d487f3added370b3ded73de2ceeda6/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=bc21965c98d487f3added370b3ded73de2ceeda6", "patch": "@@ -59,6 +59,10 @@ const int worst_case_glue_call_args = 7;\n \n const int n_upcall_glues = 7;\n \n+fn memcpy_glue_name() -> str {\n+    ret \"rust_memcpy_glue\";\n+}\n+\n fn upcall_glue_name(int n) -> str {\n     ret \"rust_upcall_\" + util.common.istr(n);\n }\n@@ -75,6 +79,10 @@ fn exit_task_glue_name() -> str {\n     ret \"rust_exit_task_glue\";\n }\n \n+fn no_op_type_glue_name() -> str {\n+    ret \"rust_no_op_type_glue\";\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "a56d1fd78d62919d0e72909168af863957f187b7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bc21965c98d487f3added370b3ded73de2ceeda6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc21965c98d487f3added370b3ded73de2ceeda6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bc21965c98d487f3added370b3ded73de2ceeda6", "patch": "@@ -51,7 +51,8 @@ type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n                     vec[ValueRef] upcall_glues,\n-                    ValueRef no_op_type_glue);\n+                    ValueRef no_op_type_glue,\n+                    ValueRef memcpy_glue);\n \n tag arity { nullary; n_ary; }\n type tag_info = rec(type_handle th,\n@@ -1237,26 +1238,15 @@ fn drop_ty(@block_ctxt cx,\n     ret res(cx, C_nil());\n }\n \n-fn build_memcpy(@block_ctxt cx,\n-                ValueRef dst,\n-                ValueRef src,\n-                ValueRef n_bytes) -> result {\n-    // FIXME: switch to the 64-bit variant when on such a platform.\n-    check (cx.fcx.ccx.intrinsics.contains_key(\"llvm.memcpy.p0i8.p0i8.i32\"));\n-    auto memcpy = cx.fcx.ccx.intrinsics.get(\"llvm.memcpy.p0i8.p0i8.i32\");\n+fn call_memcpy(@block_ctxt cx,\n+               ValueRef dst,\n+               ValueRef src,\n+               ValueRef n_bytes) -> result {\n     auto src_ptr = cx.build.PointerCast(src, T_ptr(T_i8()));\n     auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n-    auto size = cx.build.IntCast(n_bytes, T_i32());\n-    auto align = cx.build.IntCast(C_int(1), T_i32());\n-\n-    // FIXME: align seems like it should be\n-    //   lib.llvm.llvm.LLVMAlignOf(llty);\n-    // but this makes it upset because it's not a constant.\n-\n-    auto volatile = C_integral(0, T_i1());\n-    ret res(cx, cx.build.Call(memcpy,\n-                              vec(dst_ptr, src_ptr,\n-                                  size, align, volatile)));\n+    auto size = cx.build.IntCast(n_bytes, T_int());\n+    ret res(cx, cx.build.FastCall(cx.fcx.ccx.glues.memcpy_glue,\n+                                  vec(dst_ptr, src_ptr, size)));\n }\n \n fn memcpy_ty(@block_ctxt cx,\n@@ -1266,7 +1256,7 @@ fn memcpy_ty(@block_ctxt cx,\n     if (ty.type_has_dynamic_size(t)) {\n         auto llszptr = field_of_tydesc(cx, t, abi.tydesc_field_size);\n         auto llsz = cx.build.Load(llszptr);\n-        ret build_memcpy(cx, dst, src, llsz);\n+        ret call_memcpy(cx, dst, src, llsz);\n \n     } else {\n         ret res(cx, cx.build.Store(cx.build.Load(src), dst));\n@@ -3624,21 +3614,11 @@ fn trans_main_fn(@crate_ctxt cx, ValueRef llcrate) {\n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n     let vec[TypeRef] T_trap_args = vec();\n-    let vec[TypeRef] T_memcpy32_args = vec(T_ptr(T_i8()), T_ptr(T_i8()),\n-                                           T_i32(), T_i32(), T_i1());\n-    let vec[TypeRef] T_memcpy64_args = vec(T_ptr(T_i8()), T_ptr(T_i8()),\n-                                           T_i32(), T_i32(), T_i1());\n     auto trap = decl_cdecl_fn(llmod, \"llvm.trap\",\n                               T_fn(T_trap_args, T_void()));\n-    auto memcpy32 = decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n-                                  T_fn(T_memcpy32_args, T_void()));\n-    auto memcpy64 = decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n-                                  T_fn(T_memcpy64_args, T_void()));\n \n     auto intrinsics = new_str_hash[ValueRef]();\n     intrinsics.insert(\"llvm.trap\", trap);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n     ret intrinsics;\n }\n \n@@ -3652,13 +3632,58 @@ fn check_module(ModuleRef llmod) {\n \n fn make_no_op_type_glue(ModuleRef llmod) -> ValueRef {\n     auto ty = T_fn(vec(T_taskptr(), T_ptr(T_i8())), T_void());\n-    auto fun = decl_fastcall_fn(llmod, \"_rust_no_op_type_glue\", ty);\n+    auto fun = decl_fastcall_fn(llmod, abi.no_op_type_glue_name(), ty);\n     auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n     new_builder(llbb).RetVoid();\n     ret fun;\n }\n \n+fn make_memcpy_glue(ModuleRef llmod) -> ValueRef {\n+\n+    // We're not using the LLVM memcpy intrinsic. It appears to call through\n+    // to the platform memcpy in some cases, which is not terribly safe to run\n+    // on a rust stack.\n+\n+    auto p8 = T_ptr(T_i8());\n+\n+    auto ty = T_fn(vec(p8, p8, T_int()), T_void());\n+    auto fun = decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n+\n+    auto initbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"init\"));\n+    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"hdr\"));\n+    auto loopbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"loop\"));\n+    auto endbb = llvm.LLVMAppendBasicBlock(fun, _str.buf(\"end\"));\n+\n+    auto dst = llvm.LLVMGetParam(fun, 0u);\n+    auto src = llvm.LLVMGetParam(fun, 1u);\n+    auto count = llvm.LLVMGetParam(fun, 2u);\n+\n+    // Init block.\n+    auto ib = new_builder(initbb);\n+    auto ip = ib.Alloca(T_int());\n+    ib.Store(C_int(0), ip);\n+    ib.Br(hdrbb);\n+\n+    // Loop-header block\n+    auto hb = new_builder(hdrbb);\n+    auto i = hb.Load(ip);\n+    hb.CondBr(hb.ICmp(lib.llvm.LLVMIntEQ, count, i), endbb, loopbb);\n+\n+    // Loop-body block\n+    auto lb = new_builder(loopbb);\n+    i = lb.Load(ip);\n+    lb.Store(lb.Load(lb.GEP(src, vec(i))),\n+             lb.GEP(dst, vec(i)));\n+    lb.Store(lb.Add(i, C_int(1)), ip);\n+    lb.Br(hdrbb);\n+\n+    // End block\n+    auto eb = new_builder(endbb);\n+    eb.RetVoid();\n+    ret fun;\n+}\n+\n fn make_glues(ModuleRef llmod) -> @glue_fns {\n     ret @rec(activate_glue = decl_glue(llmod, abi.activate_glue_name()),\n              yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n@@ -3678,7 +3703,8 @@ fn make_glues(ModuleRef llmod) -> @glue_fns {\n              upcall_glues =\n               _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n                                      abi.n_upcall_glues as uint),\n-             no_op_type_glue = make_no_op_type_glue(llmod));\n+             no_op_type_glue = make_no_op_type_glue(llmod),\n+             memcpy_glue = make_memcpy_glue(llmod));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output,"}]}