{"sha": "9c84ac86d1325816c25531e95777adf467cf31e4", "node_id": "C_kwDOAAsO6NoAKDljODRhYzg2ZDEzMjU4MTZjMjU1MzFlOTU3NzdhZGY0NjdjZjMxZTQ", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-11-04T16:50:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-11-04T16:50:24Z"}, "message": "introduce an enum for tracking the 2229 migration causes", "tree": {"sha": "5d5aac872653fb3f8d2bfef36803b84cce05f3d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d5aac872653fb3f8d2bfef36803b84cce05f3d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c84ac86d1325816c25531e95777adf467cf31e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c84ac86d1325816c25531e95777adf467cf31e4", "html_url": "https://github.com/rust-lang/rust/commit/9c84ac86d1325816c25531e95777adf467cf31e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c84ac86d1325816c25531e95777adf467cf31e4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3190c1eb4c982b1d419ae0632bad07a3b306b48", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3190c1eb4c982b1d419ae0632bad07a3b306b48", "html_url": "https://github.com/rust-lang/rust/commit/c3190c1eb4c982b1d419ae0632bad07a3b306b48"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "7da0838e07a9bbae7e87521514b6cc35080dbb7f", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9c84ac86d1325816c25531e95777adf467cf31e4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c84ac86d1325816c25531e95777adf467cf31e4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9c84ac86d1325816c25531e95777adf467cf31e4", "patch": "@@ -86,7 +86,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n /// Intermediate format to store the hir_id pointing to the use that resulted in the\n /// corresponding place being captured and a String which contains the captured value's\n /// name (i.e: a.b.c)\n-type CapturesInfo = (Option<hir::HirId>, String);\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+enum CapturesInfo {\n+    CapturingLess { source_expr: Option<hir::HirId>, var_name: String },\n+}\n \n /// Intermediate format to store information needed to generate migration lint. The tuple\n /// contains the hir_id pointing to the use that resulted in the\n@@ -963,7 +966,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             if !capture_problems.is_empty() {\n                 problematic_captures.insert(\n-                    (capture.info.path_expr_id, capture.to_string(self.tcx)),\n+                    CapturesInfo::CapturingLess {\n+                        source_expr: capture.info.path_expr_id,\n+                        var_name: capture.to_string(self.tcx),\n+                    },\n                     capture_problems,\n                 );\n             }\n@@ -986,6 +992,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// This function only returns a HashSet of CapturesInfo for significant drops. If there\n     /// are no significant drops than None is returned\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations_for_drop(\n         &self,\n         closure_def_id: DefId,\n@@ -997,12 +1004,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n+            debug!(\"does not have significant drop\");\n             return None;\n         }\n \n         let Some(root_var_min_capture_list) = min_captures.and_then(|m| m.get(&var_hir_id)) else {\n             // The upvar is mentioned within the closure but no path starting from it is\n-            // used.\n+            // used. This occurs when you have (e.g.)\n+            //\n+            // ```\n+            // let x = move || {\n+            //     let _ = y;\n+            // });\n+            // ```\n+            debug!(\"no path starting from it is used\");\n+\n \n             match closure_clause {\n                 // Only migrate if closure is a move closure\n@@ -1012,6 +1028,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             return None;\n         };\n+        debug!(?root_var_min_capture_list);\n \n         let mut projections_list = Vec::new();\n         let mut diagnostics_info = FxHashSet::default();\n@@ -1021,19 +1038,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Only care about captures that are moved into the closure\n                 ty::UpvarCapture::ByValue(..) => {\n                     projections_list.push(captured_place.place.projections.as_slice());\n-                    diagnostics_info.insert((\n-                        captured_place.info.path_expr_id,\n-                        captured_place.to_string(self.tcx),\n-                    ));\n+                    diagnostics_info.insert(CapturesInfo::CapturingLess {\n+                        source_expr: captured_place.info.path_expr_id,\n+                        var_name: captured_place.to_string(self.tcx),\n+                    });\n                 }\n                 ty::UpvarCapture::ByRef(..) => {}\n             }\n         }\n \n+        debug!(?projections_list);\n+        debug!(?diagnostics_info);\n+\n         let is_moved = !projections_list.is_empty();\n+        debug!(?is_moved);\n \n         let is_not_completely_captured =\n             root_var_min_capture_list.iter().any(|capture| !capture.place.projections.is_empty());\n+        debug!(?is_not_completely_captured);\n \n         if is_moved\n             && is_not_completely_captured\n@@ -1066,6 +1088,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Returns a tuple containing a vector of MigrationDiagnosticInfo, as well as a String\n     /// containing the reason why root variables whose HirId is contained in the vector should\n     /// be captured\n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n@@ -1131,14 +1154,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // auto trait implementation issues\n                 auto_trait_migration_reasons.extend(capture_trait_reasons.clone());\n \n-                responsible_captured_hir_ids.push((\n-                    captured_info.0,\n-                    captured_info.1.clone(),\n-                    self.compute_2229_migrations_reasons(\n-                        capture_trait_reasons,\n-                        capture_drop_reorder_reason,\n-                    ),\n-                ));\n+                match captured_info {\n+                    CapturesInfo::CapturingLess { source_expr, var_name } => {\n+                        responsible_captured_hir_ids.push((\n+                            *source_expr,\n+                            var_name.clone(),\n+                            self.compute_2229_migrations_reasons(\n+                                capture_trait_reasons,\n+                                capture_drop_reorder_reason,\n+                            ),\n+                        ));\n+                    }\n+                }\n             }\n \n             if !capture_diagnostic.is_empty() {\n@@ -2087,6 +2114,7 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n \n+#[instrument(level = \"debug\", skip(tcx))]\n fn should_do_rust_2021_incompatible_closure_captures_analysis(\n     tcx: TyCtxt<'_>,\n     closure_id: hir::HirId,"}]}