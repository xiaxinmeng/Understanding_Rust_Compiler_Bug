{"sha": "ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNTkzYmVkODgyZTFhZDZiYzdmZjZhM2IzYjY3MzAxNzZiNTUzNmI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-01T03:19:58Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:00Z"}, "message": "rustc_metadata: go back to not using the opaque format.", "tree": {"sha": "9721dbc29dbbe2b24c248ca97bcaad7cb096a814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9721dbc29dbbe2b24c248ca97bcaad7cb096a814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "html_url": "https://github.com/rust-lang/rust/commit/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903ec52ba9172e38026fd6b833053e1a019fe68e", "url": "https://api.github.com/repos/rust-lang/rust/commits/903ec52ba9172e38026fd6b833053e1a019fe68e", "html_url": "https://github.com/rust-lang/rust/commit/903ec52ba9172e38026fd6b833053e1a019fe68e"}], "stats": {"total": 368, "additions": 165, "deletions": 203}, "files": [{"sha": "ce15ec6a29d287743523e43b943f72596be8e980", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 101, "deletions": 121, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -14,9 +14,7 @@ use rustc::hir::map as ast_map;\n \n use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n \n-use common as c;\n-use cstore;\n-\n+use cstore::CrateMetadata;\n use decoder::DecodeContext;\n use encoder::EncodeContext;\n \n@@ -28,60 +26,53 @@ use rustc::ty::{self, TyCtxt};\n \n use syntax::ast;\n \n-use rbml::reader;\n use rbml;\n use rustc_serialize::{Decodable, Encodable};\n \n // ______________________________________________________________________\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &mut EncodeContext, ii: InlinedItemRef) {\n-    ecx.tag(c::tag_ast, |ecx| {\n-        ecx.tag(c::tag_id_range, |ecx| {\n-            let mut visitor = IdRangeComputingVisitor::new();\n-            match ii {\n-                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n-            }\n-            visitor.result().encode(&mut ecx.opaque()).unwrap()\n-        });\n+    ecx.tag(::common::tag_ast, |ecx| {\n+        let mut visitor = IdRangeComputingVisitor::new();\n+        match ii {\n+            InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+            InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+            InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+        }\n+        visitor.result().encode(ecx).unwrap();\n \n-        ecx.tag(c::tag_tree, |ecx| ii.encode(ecx).unwrap());\n+        ii.encode(ecx).unwrap();\n \n-        ecx.tag(c::tag_table, |ecx| {\n-            let mut visitor = SideTableEncodingIdVisitor {\n-                ecx: ecx\n-            };\n-            match ii {\n-                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n-            }\n-        });\n+        let mut visitor = SideTableEncodingIdVisitor {\n+            ecx: ecx\n+        };\n+        match ii {\n+            InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+            InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+            InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+        }\n     });\n }\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n                                      ast_doc: rbml::Doc,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let from_id_range = {\n-        let decoder = &mut ast_doc.get(c::tag_id_range).opaque();\n-        IdRange {\n-            min: ast::NodeId::from_u32(u32::decode(decoder).unwrap()),\n-            max: ast::NodeId::from_u32(u32::decode(decoder).unwrap())\n-        }\n-    };\n-    let mut dcx = DecodeContext::new(tcx, cdata, from_id_range,\n-                                     ast_doc.get(c::tag_tree));\n-    let ii = InlinedItem::decode(&mut dcx).unwrap();\n+    let dcx = &mut ast_doc.decoder();\n+    dcx.tcx = Some(tcx);\n+    dcx.cdata = Some(cdata);\n+    dcx.from_id_range = IdRange::decode(dcx).unwrap();\n+    let cnt = dcx.from_id_range.max.as_usize() - dcx.from_id_range.min.as_usize();\n+    dcx.to_id_range.min = tcx.sess.reserve_node_ids(cnt);\n+    dcx.to_id_range.max = ast::NodeId::new(dcx.to_id_range.min.as_usize() + cnt);\n+    let ii = InlinedItem::decode(dcx).unwrap();\n \n     let ii = ast_map::map_decoded_item(&tcx.map,\n                                        parent_def_path,\n@@ -97,7 +88,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));\n \n-    decode_side_tables(&mut dcx, ast_doc);\n+    decode_side_tables(dcx, ast_doc);\n \n     ii\n }\n@@ -116,7 +107,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.end_tag().unwrap();\n     }\n \n-    fn id(&mut self, id: ast::NodeId) {\n+    fn entry(&mut self, table: Table, id: ast::NodeId) {\n+        table.encode(self).unwrap();\n         id.encode(self).unwrap();\n     }\n }\n@@ -131,67 +123,67 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n     }\n }\n \n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n+enum Table {\n+    Def,\n+    NodeType,\n+    ItemSubsts,\n+    Freevars,\n+    MethodMap,\n+    Adjustment,\n+    UpvarCaptureMap,\n+    ConstQualif,\n+    CastKind\n+}\n+\n fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n     if let Some(def) = tcx.expect_def_or_none(id) {\n-        ecx.tag(c::tag_table_def, |ecx| {\n-            ecx.id(id);\n-            def.encode(ecx).unwrap();\n-        })\n+        ecx.entry(Table::Def, id);\n+        def.encode(ecx).unwrap();\n     }\n \n     if let Some(ty) = tcx.node_types().get(&id) {\n-        ecx.tag(c::tag_table_node_type, |ecx| {\n-            ecx.id(id);\n-            ty.encode(ecx).unwrap();\n-        })\n+        ecx.entry(Table::NodeType, id);\n+        ty.encode(ecx).unwrap();\n     }\n \n     if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n-        ecx.tag(c::tag_table_item_subst, |ecx| {\n-            ecx.id(id);\n-            item_substs.substs.encode(ecx).unwrap();\n-        })\n+        ecx.entry(Table::ItemSubsts, id);\n+        item_substs.substs.encode(ecx).unwrap();\n     }\n \n     if let Some(fv) = tcx.freevars.borrow().get(&id) {\n-        ecx.tag(c::tag_table_freevars, |ecx| {\n-            ecx.id(id);\n-            fv.encode(ecx).unwrap();\n-        });\n+        ecx.entry(Table::Freevars, id);\n+        fv.encode(ecx).unwrap();\n \n         for freevar in fv {\n-            ecx.tag(c::tag_table_upvar_capture_map, |ecx| {\n-                ecx.id(id);\n-\n-                let def_id = freevar.def.def_id();\n-                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: id\n-                };\n-                let upvar_capture = tcx.tables\n-                                       .borrow()\n-                                       .upvar_capture_map\n-                                       .get(&upvar_id)\n-                                       .unwrap()\n-                                       .clone();\n-                var_id.encode(ecx).unwrap();\n-                upvar_capture.encode(ecx).unwrap();\n-            })\n+            ecx.entry(Table::UpvarCaptureMap, id);\n+            let def_id = freevar.def.def_id();\n+            let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+            let upvar_id = ty::UpvarId {\n+                var_id: var_id,\n+                closure_expr_id: id\n+            };\n+            let upvar_capture = tcx.tables\n+                                    .borrow()\n+                                    .upvar_capture_map\n+                                    .get(&upvar_id)\n+                                    .unwrap()\n+                                    .clone();\n+            var_id.encode(ecx).unwrap();\n+            upvar_capture.encode(ecx).unwrap();\n         }\n     }\n \n     let method_call = ty::MethodCall::expr(id);\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-        ecx.tag(c::tag_table_method_map, |ecx| {\n-            ecx.id(id);\n-            method_call.autoderef.encode(ecx).unwrap();\n-            method.encode(ecx).unwrap();\n-        })\n+        ecx.entry(Table::MethodMap, id);\n+        method_call.autoderef.encode(ecx).unwrap();\n+        method.encode(ecx).unwrap();\n     }\n \n     if let Some(adjustment) = tcx.tables.borrow().adjustments.get(&id) {\n@@ -200,91 +192,79 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n                 for autoderef in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, autoderef as u32);\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n-                        ecx.tag(c::tag_table_method_map, |ecx| {\n-                            ecx.id(id);\n-                            method_call.autoderef.encode(ecx).unwrap();\n-                            method.encode(ecx).unwrap();\n-                        })\n+                        ecx.entry(Table::MethodMap, id);\n+                        method_call.autoderef.encode(ecx).unwrap();\n+                        method.encode(ecx).unwrap();\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        ecx.tag(c::tag_table_adjustments, |ecx| {\n-            ecx.id(id);\n-            adjustment.encode(ecx).unwrap();\n-        })\n+        ecx.entry(Table::Adjustment, id);\n+        adjustment.encode(ecx).unwrap();\n     }\n \n     if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n-        ecx.tag(c::tag_table_cast_kinds, |ecx| {\n-            ecx.id(id);\n-            cast_kind.encode(ecx).unwrap()\n-        })\n+        ecx.entry(Table::CastKind, id);\n+        cast_kind.encode(ecx).unwrap();\n     }\n \n     if let Some(qualif) = tcx.const_qualif_map.borrow().get(&id) {\n-        ecx.tag(c::tag_table_const_qualif, |ecx| {\n-            ecx.id(id);\n-            qualif.encode(ecx).unwrap()\n-        })\n+        ecx.entry(Table::ConstQualif, id);\n+        qualif.encode(ecx).unwrap();\n     }\n }\n \n-fn decode_side_tables<'a, 'tcx>(dcx: &mut DecodeContext<'a, 'tcx>,\n-                                ast_doc: rbml::Doc<'a>) {\n-    for (tag, entry_doc) in reader::docs(ast_doc.get(c::tag_table)) {\n-        dcx.rbml_r = reader::Decoder::new(entry_doc);\n+fn decode_side_tables(dcx: &mut DecodeContext, ast_doc: rbml::Doc) {\n+    while dcx.position() < ast_doc.end {\n+        let table = Decodable::decode(dcx).unwrap();\n         let id = Decodable::decode(dcx).unwrap();\n-        debug!(\"decode_side_tables: entry for id={}, tag=0x{:x}\", id, tag);\n-        match tag {\n-            c::tag_table_def => {\n+        debug!(\"decode_side_tables: entry for id={}, table={:?}\", id, table);\n+        match table {\n+            Table::Def => {\n                 let def = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n+                dcx.tcx().def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n-            c::tag_table_node_type => {\n+            Table::NodeType => {\n                 let ty = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.node_type_insert(id, ty);\n+                dcx.tcx().node_type_insert(id, ty);\n             }\n-            c::tag_table_item_subst => {\n+            Table::ItemSubsts => {\n                 let item_substs = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n+                dcx.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n             }\n-            c::tag_table_freevars => {\n+            Table::Freevars => {\n                 let fv_info = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n+                dcx.tcx().freevars.borrow_mut().insert(id, fv_info);\n             }\n-            c::tag_table_upvar_capture_map => {\n+            Table::UpvarCaptureMap => {\n                 let upvar_id = ty::UpvarId {\n                     var_id: Decodable::decode(dcx).unwrap(),\n                     closure_expr_id: id\n                 };\n                 let ub = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n+                dcx.tcx().tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n             }\n-            c::tag_table_method_map => {\n+            Table::MethodMap => {\n                 let method_call = ty::MethodCall {\n                     expr_id: id,\n                     autoderef: Decodable::decode(dcx).unwrap()\n                 };\n                 let method = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n+                dcx.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n             }\n-            c::tag_table_adjustments => {\n+            Table::Adjustment => {\n                 let adj = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n+                dcx.tcx().tables.borrow_mut().adjustments.insert(id, adj);\n             }\n-            c::tag_table_cast_kinds => {\n+            Table::CastKind => {\n                 let cast_kind = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n+                dcx.tcx().cast_kinds.borrow_mut().insert(id, cast_kind);\n             }\n-            c::tag_table_const_qualif => {\n+            Table::ConstQualif => {\n                 let qualif = Decodable::decode(dcx).unwrap();\n-                dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n-            }\n-            _ => {\n-                bug!(\"unknown tag found in side tables: 0x{:x}\", tag);\n+                dcx.tcx().const_qualif_map.borrow_mut().insert(id, qualif);\n             }\n         }\n     }"}, {"sha": "512f4ca6584c65635d929e5e8de99c9341fb8cbe", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -97,28 +97,11 @@ pub const tag_items_data_item_reexport_name: usize = 0x48;\n // used to encode crate_ctxt side tables\n pub const tag_ast: usize = 0x50;\n \n-pub const tag_tree: usize = 0x51;\n+// GAP 0x51\n \n pub const tag_mir: usize = 0x52;\n \n-pub const tag_table: usize = 0x53;\n-\n-pub const tag_id_range: usize = 0x54;\n-\n-// GAP 0x55\n-pub const tag_table_def: usize = 0x56;\n-pub const tag_table_node_type: usize = 0x57;\n-pub const tag_table_item_subst: usize = 0x58;\n-pub const tag_table_freevars: usize = 0x59;\n-// GAP 0x5a, 0x5b, 0x5c, 0x5d, 0x5e\n-pub const tag_table_method_map: usize = 0x5f;\n-// GAP 0x60\n-pub const tag_table_adjustments: usize = 0x61;\n-// GAP 0x62, 0x63, 0x64, 0x65\n-pub const tag_table_upvar_capture_map: usize = 0x66;\n-// GAP 0x67, 0x68\n-pub const tag_table_const_qualif: usize = 0x69;\n-pub const tag_table_cast_kinds: usize = 0x6a;\n+// GAP 0x53...0x6a\n \n pub const tag_item_trait_item_sort: usize = 0x70;\n "}, {"sha": "1bec365e472b15805caad29a33c998945bb05b9d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -48,6 +48,7 @@ use std::io;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::str;\n+use std::u32;\n \n use rbml::reader;\n use rbml;\n@@ -59,48 +60,48 @@ use syntax::print::pprust;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n-    pub rbml_r: rbml::reader::Decoder<'a>,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub cdata: &'a cstore::CrateMetadata,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n+    rbml_r: rbml::reader::Decoder<'a>,\n+    pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    pub cdata: Option<&'a cstore::CrateMetadata>,\n+    pub from_id_range: IdRange,\n+    pub to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n }\n \n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               cdata: &'a cstore::CrateMetadata,\n-               from_id_range: IdRange,\n-               doc: rbml::Doc<'a>)\n-               -> DecodeContext<'a, 'tcx> {\n-        // Handle the case of an empty range:\n-        let to_id_range = if from_id_range.empty() {\n-            from_id_range\n-        } else {\n-            let cnt = from_id_range.max.as_usize() - from_id_range.min.as_usize();\n-            let to_id_min = tcx.sess.reserve_node_ids(cnt);\n-            let to_id_max = NodeId::new(to_id_min.as_usize() + cnt);\n-            IdRange { min: to_id_min, max: to_id_max }\n+impl<'doc> rbml::Doc<'doc> {\n+    pub fn decoder<'tcx>(self) -> DecodeContext<'doc, 'tcx> {\n+        let id_range = IdRange {\n+            min: NodeId::from_u32(u32::MIN),\n+            max: NodeId::from_u32(u32::MAX)\n         };\n-\n         DecodeContext {\n-            rbml_r: reader::Decoder::new(doc),\n-            cdata: cdata,\n-            tcx: tcx,\n-            from_id_range: from_id_range,\n-            to_id_range: to_id_range,\n+            rbml_r: reader::Decoder::new(self),\n+            cdata: None,\n+            tcx: None,\n+            from_id_range: id_range,\n+            to_id_range: id_range,\n             last_filemap_index: 0\n         }\n     }\n+}\n+\n+impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+    }\n+\n+    pub fn cdata(&self) -> &'a cstore::CrateMetadata {\n+        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n+    }\n \n     fn read_ty_encoded<F, R>(&mut self, op: F) -> R\n         where F: for<'x> FnOnce(&mut TyDecoder<'x,'tcx>) -> R\n     {\n         self.read_opaque(|this, doc| {\n             Ok(op(&mut TyDecoder::with_doc(\n-                this.tcx, this.cdata.cnum, doc,\n-                &mut |d| translate_def_id(&this.cdata, d))))\n+                this.tcx(), this.cdata().cnum, doc,\n+                &mut |d| translate_def_id(this.cdata(), d))))\n         }).unwrap()\n     }\n }\n@@ -142,9 +143,9 @@ impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n         let cnum = CrateNum::from_u32(u32::decode(self)?);\n         if cnum == LOCAL_CRATE {\n-            Ok(self.cdata.cnum)\n+            Ok(self.cdata().cnum)\n         } else {\n-            Ok(self.cdata.cnum_map.borrow()[cnum])\n+            Ok(self.cdata().cnum_map.borrow()[cnum])\n         }\n     }\n }\n@@ -154,6 +155,12 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n \n+        let tcx = if let Some(tcx) = self.tcx {\n+            tcx\n+        } else {\n+            return Ok(syntax_pos::mk_sp(lo, hi));\n+        };\n+\n         let (lo, hi) = if lo > hi {\n             // Currently macro expansion sometimes produces invalid Span values\n             // where lo > hi. In order not to crash the compiler when trying to\n@@ -167,7 +174,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             (lo, hi)\n         };\n \n-        let imported_filemaps = self.cdata.imported_filemaps(&self.tcx.sess.codemap());\n+        let imported_filemaps = self.cdata().imported_filemaps(&tcx.sess.codemap());\n         let filemap = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same filemap.\n@@ -224,23 +231,23 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n         let r = ty::Region::decode(self)?;\n-        Ok(self.tcx.mk_region(r))\n+        Ok(self.tcx().mk_region(r))\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ty::ClosureSubsts<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::ClosureSubsts<'tcx>, Self::Error> {\n         Ok(ty::ClosureSubsts {\n             func_substs: Decodable::decode(self)?,\n-            upvar_tys: self.tcx.mk_type_list(Decodable::decode(self)?)\n+            upvar_tys: self.tcx().mk_type_list(Decodable::decode(self)?)\n         })\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n         let def_id = DefId::decode(self)?;\n-        Ok(self.tcx.lookup_adt_def(def_id))\n+        Ok(self.tcx().lookup_adt_def(def_id))\n     }\n }\n \n@@ -739,14 +746,14 @@ pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n pub fn get_stability(cdata: Cmd, id: DefIndex) -> Option<attr::Stability> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_stability).map(|doc| {\n-        Decodable::decode(&mut doc.opaque()).unwrap()\n+        Decodable::decode(&mut doc.decoder()).unwrap()\n     })\n }\n \n pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_deprecation).map(|doc| {\n-        Decodable::decode(&mut doc.opaque()).unwrap()\n+        Decodable::decode(&mut doc.decoder()).unwrap()\n     })\n }\n \n@@ -764,7 +771,7 @@ pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     reader::maybe_get_doc(item, tag_items_data_item_repr).map_or(vec![], |doc| {\n-        Decodable::decode(&mut doc.opaque()).unwrap()\n+        Decodable::decode(&mut doc.decoder()).unwrap()\n     })\n }\n \n@@ -786,7 +793,7 @@ pub fn get_custom_coerce_unsized_kind(\n {\n     let item_doc = cdata.lookup_item(id);\n     reader::maybe_get_doc(item_doc, tag_impl_coerce_unsized_kind).map(|kind_doc| {\n-        Decodable::decode(&mut kind_doc.opaque()).unwrap()\n+        Decodable::decode(&mut kind_doc.decoder()).unwrap()\n     })\n }\n \n@@ -982,8 +989,9 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     let item_doc = cdata.lookup_item(id);\n \n     reader::maybe_get_doc(item_doc, tag_mir).map(|mir_doc| {\n-        let id_range = IdRange { min: NodeId::new(0), max: NodeId::new(0) };\n-        let mut dcx = DecodeContext::new(tcx, cdata, id_range, mir_doc);\n+        let mut dcx = mir_doc.decoder();\n+        dcx.tcx = Some(tcx);\n+        dcx.cdata = Some(cdata);\n         Decodable::decode(&mut dcx).unwrap()\n     })\n }\n@@ -1123,7 +1131,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n     let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n-    Decodable::decode(&mut variance_doc.opaque()).unwrap()\n+    Decodable::decode(&mut variance_doc.decoder()).unwrap()\n }\n \n pub fn get_provided_trait_methods<'a, 'tcx>(cdata: Cmd,\n@@ -1242,7 +1250,7 @@ pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n \n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n     reader::maybe_get_doc(md, tag_attributes).map_or(vec![], |attrs_doc| {\n-        let mut attrs = Vec::<ast::Attribute>::decode(&mut attrs_doc.opaque()).unwrap();\n+        let mut attrs = Vec::<ast::Attribute>::decode(&mut attrs_doc.decoder()).unwrap();\n \n         // Need new unique IDs: old thread-local IDs won't map to new threads.\n         for attr in attrs.iter_mut() {\n@@ -1647,14 +1655,14 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n     let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n \n     reader::tagged_docs(cm_doc, tag_codemap_filemap).map(|filemap_doc| {\n-        Decodable::decode(&mut filemap_doc.opaque()).unwrap()\n+        Decodable::decode(&mut filemap_doc.decoder()).unwrap()\n     }).collect()\n }\n \n pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n     let closure_doc = cdata.lookup_item(closure_id);\n     let closure_kind_doc = reader::get_doc(closure_doc, tag_items_closure_kind);\n-    ty::ClosureKind::decode(&mut closure_kind_doc.opaque()).unwrap()\n+    ty::ClosureKind::decode(&mut closure_kind_doc.decoder()).unwrap()\n }\n \n pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -1674,7 +1682,7 @@ pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n     match reader::maybe_get_doc(item_doc, tag_def_key) {\n         Some(def_key_doc) => {\n-            let simple_key = def_key::DefKey::decode(&mut def_key_doc.opaque()).unwrap();\n+            let simple_key = def_key::DefKey::decode(&mut def_key_doc.decoder()).unwrap();\n             let name = reader::maybe_get_doc(item_doc, tag_paths_data_name).map(|name| {\n                 token::intern(name.as_str()).as_str()\n             });"}, {"sha": "9773823c77ded4b71737c7c5684d312d7b26abf4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -108,7 +108,7 @@ fn encode_def_id(ecx: &mut EncodeContext, id: DefId) {\n fn encode_def_key(ecx: &mut EncodeContext, key: DefKey) {\n     let simple_key = def_key::simplify_def_key(key);\n     ecx.start_tag(tag_def_key);\n-    simple_key.encode(&mut ecx.opaque());\n+    simple_key.encode(ecx);\n     ecx.end_tag();\n }\n \n@@ -146,7 +146,7 @@ pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n     let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n     ecx.start_tag(tag_item_variances);\n-    v.encode(&mut ecx.opaque());\n+    v.encode(ecx);\n     ecx.end_tag();\n }\n \n@@ -761,7 +761,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                                                     attr));\n         }\n         self.start_tag(tag_items_data_item_repr);\n-        repr_attrs.encode(&mut self.opaque());\n+        repr_attrs.encode(self.ecx);\n         self.end_tag();\n     }\n \n@@ -796,15 +796,15 @@ fn encode_inherent_implementations(ecx: &mut EncodeContext,\n fn encode_stability(ecx: &mut EncodeContext, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n         ecx.start_tag(tag_items_data_item_stability);\n-        stab.encode(&mut ecx.opaque()).unwrap();\n+        stab.encode(ecx).unwrap();\n         ecx.end_tag();\n     });\n }\n \n fn encode_deprecation(ecx: &mut EncodeContext, depr_opt: Option<attr::Deprecation>) {\n     depr_opt.map(|depr| {\n         ecx.start_tag(tag_items_data_item_deprecation);\n-        depr.encode(&mut ecx.opaque()).unwrap();\n+        depr.encode(ecx).unwrap();\n         ecx.end_tag();\n     });\n }\n@@ -1043,7 +1043,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                 {\n                     Some(&kind) => {\n                         self.start_tag(tag_impl_coerce_unsized_kind);\n-                        kind.encode(&mut self.opaque());\n+                        kind.encode(self.ecx);\n                         self.end_tag();\n                     }\n                     None => {}\n@@ -1361,7 +1361,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         self.end_tag();\n \n         self.start_tag(tag_items_closure_kind);\n-        tcx.closure_kind(def_id).encode(&mut self.opaque()).unwrap();\n+        tcx.closure_kind(def_id).encode(self.ecx).unwrap();\n         self.end_tag();\n \n         assert!(self.mir_map.map.contains_key(&def_id));\n@@ -1403,7 +1403,7 @@ fn encode_item_index(ecx: &mut EncodeContext, index: IndexData) {\n \n fn encode_attributes(ecx: &mut EncodeContext, attrs: &[ast::Attribute]) {\n     ecx.start_tag(tag_attributes);\n-    attrs.encode(&mut ecx.opaque()).unwrap();\n+    attrs.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n@@ -1538,7 +1538,7 @@ fn encode_codemap(ecx: &mut EncodeContext) {\n         }\n \n         ecx.start_tag(tag_codemap_filemap);\n-        filemap.encode(&mut ecx.opaque()).unwrap();\n+        filemap.encode(ecx).unwrap();\n         ecx.end_tag();\n     }\n "}, {"sha": "d66ca38e6244d792a834aa89cc2b7be86163370e", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -123,7 +123,6 @@ use std::str;\n \n use rustc_serialize as serialize;\n \n-use rbml::opaque;\n use rbml::Error;\n use rbml::Error::*;\n \n@@ -158,10 +157,6 @@ impl<'doc> Doc<'doc> {\n     pub fn to_string(&self) -> String {\n         self.as_str().to_string()\n     }\n-\n-    pub fn opaque(&self) -> opaque::Decoder<'doc> {\n-        opaque::Decoder::new(self.data, self.start)\n-    }\n }\n \n pub struct TaggedDoc<'a> {"}, {"sha": "f22a9d1cd003e6cb392a9c0df3d67228dc66fbdf", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -254,15 +254,11 @@ impl Encoder {\n         }\n     }\n \n-    pub fn opaque(&mut self) -> opaque::Encoder {\n-        opaque::Encoder::new(&mut self.writer)\n-    }\n-\n     pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n         where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n     {\n         self.start_tag(EsOpaque as usize)?;\n-        f(&mut self.opaque())?;\n+        f(&mut opaque::Encoder::new(&mut self.writer))?;\n         self.mark_stable_position();\n         self.end_tag()\n     }"}]}