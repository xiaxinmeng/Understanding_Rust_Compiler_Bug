{"sha": "fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmMxYTc3ZDI0MmZhZmExMzkzMTI3ZGVmYTdmZmVjMGJjYjllNTQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-17T01:21:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-17T01:21:22Z"}, "message": "Rewrite everything to use [] instead of vec() in value position.", "tree": {"sha": "ec83e08cb3fb8c95c24b7566ba8ab0904ced9aae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec83e08cb3fb8c95c24b7566ba8ab0904ced9aae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "html_url": "https://github.com/rust-lang/rust/commit/fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae030c5bf277e90b9aeea7e301fd3001f3a66b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae030c5bf277e90b9aeea7e301fd3001f3a66b8d", "html_url": "https://github.com/rust-lang/rust/commit/ae030c5bf277e90b9aeea7e301fd3001f3a66b8d"}], "stats": {"total": 2271, "additions": 1137, "deletions": 1134}, "files": [{"sha": "b1b533c84d6a88fc0d592e176f20d9f01867ccfe", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -63,8 +63,8 @@ type upcalls = rec(\n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n     fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n             TypeRef rv) -> ValueRef {\n-        let vec[TypeRef] arg_tys = vec(T_taskptr(tn));\n-        for (TypeRef t in tys) { arg_tys += vec(t); }\n+        let vec[TypeRef] arg_tys = [T_taskptr(tn)];\n+        for (TypeRef t in tys) { arg_tys += [t]; }\n         auto fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n@@ -74,61 +74,61 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n \n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n-    let vec[TypeRef] empty_vec = vec();\n+    let vec[TypeRef] empty_vec = [];\n \n     ret @rec(\n-        grow_task=dv(\"grow_task\", vec(T_size_t())),\n-        log_int=dv(\"log_int\", vec(T_i32(), T_i32())),\n-        log_float=dv(\"log_float\", vec(T_i32(), T_f32())),\n-        log_double=dv(\"log_double\", vec(T_i32(), T_ptr(T_f64()))),\n-        log_str=dv(\"log_str\", vec(T_i32(), T_ptr(T_str()))),\n-        trace_word=dv(\"trace_word\", vec(T_int())),\n-        trace_str=dv(\"trace_str\", vec(T_ptr(T_i8()))),\n-        new_port=d(\"new_port\", vec(T_size_t()), T_opaque_port_ptr()),\n-        del_port=dv(\"del_port\", vec(T_opaque_port_ptr())),\n-        new_chan=d(\"new_chan\", vec(T_opaque_port_ptr()), T_opaque_chan_ptr()),\n-        flush_chan=dv(\"flush_chan\", vec(T_opaque_chan_ptr())),\n-        del_chan=dv(\"del_chan\", vec(T_opaque_chan_ptr())),\n-        clone_chan=d(\"clone_chan\", vec(T_taskptr(tn), T_opaque_chan_ptr()),\n+        grow_task=dv(\"grow_task\", [T_size_t()]),\n+        log_int=dv(\"log_int\", [T_i32(), T_i32()]),\n+        log_float=dv(\"log_float\", [T_i32(), T_f32()]),\n+        log_double=dv(\"log_double\", [T_i32(), T_ptr(T_f64())]),\n+        log_str=dv(\"log_str\", [T_i32(), T_ptr(T_str())]),\n+        trace_word=dv(\"trace_word\", [T_int()]),\n+        trace_str=dv(\"trace_str\", [T_ptr(T_i8())]),\n+        new_port=d(\"new_port\", [T_size_t()], T_opaque_port_ptr()),\n+        del_port=dv(\"del_port\", [T_opaque_port_ptr()]),\n+        new_chan=d(\"new_chan\", [T_opaque_port_ptr()], T_opaque_chan_ptr()),\n+        flush_chan=dv(\"flush_chan\", [T_opaque_chan_ptr()]),\n+        del_chan=dv(\"del_chan\", [T_opaque_chan_ptr()]),\n+        clone_chan=d(\"clone_chan\", [T_taskptr(tn), T_opaque_chan_ptr()],\n                      T_opaque_chan_ptr()),\n         _yield=dv(\"yield\", empty_vec),\n-        sleep=dv(\"sleep\", vec(T_size_t())),\n-        _join=dv(\"join\", vec(T_taskptr(tn))),\n-        send=dv(\"send\", vec(T_opaque_chan_ptr(), T_ptr(T_i8()))),\n-        recv=dv(\"recv\", vec(T_ptr(T_ptr(T_i8())), T_opaque_port_ptr())),\n-        _fail=dv(\"fail\", vec(T_ptr(T_i8()), T_ptr(T_i8()), T_size_t())),\n-        kill=dv(\"kill\", vec(T_taskptr(tn))),\n+        sleep=dv(\"sleep\", [T_size_t()]),\n+        _join=dv(\"join\", [T_taskptr(tn)]),\n+        send=dv(\"send\", [T_opaque_chan_ptr(), T_ptr(T_i8())]),\n+        recv=dv(\"recv\", [T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n+        _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+        kill=dv(\"kill\", [T_taskptr(tn)]),\n         exit=dv(\"exit\", empty_vec),\n-        malloc=d(\"malloc\", vec(T_size_t(), T_ptr(T_tydesc(tn))),\n+        malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n                                T_ptr(T_i8())),\n-        free=dv(\"free\", vec(T_ptr(T_i8()), T_int())),\n-        mark=d(\"mark\", vec(T_ptr(T_i8())), T_int()),\n-        new_str=d(\"new_str\", vec(T_ptr(T_i8()), T_size_t()), T_ptr(T_str())),\n-        new_vec=d(\"new_vec\", vec(T_size_t(), T_ptr(T_tydesc(tn))),\n+        free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+        mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n+        new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()], T_ptr(T_str())),\n+        new_vec=d(\"new_vec\", [T_size_t(), T_ptr(T_tydesc(tn))],\n                                  T_opaque_vec_ptr()),\n-        vec_grow=d(\"vec_grow\", vec(T_opaque_vec_ptr(), T_size_t(),\n-                                   T_ptr(T_int()), T_ptr(T_tydesc(tn))),\n+        vec_grow=d(\"vec_grow\", [T_opaque_vec_ptr(), T_size_t(),\n+                                   T_ptr(T_int()), T_ptr(T_tydesc(tn))],\n                    T_opaque_vec_ptr()),\n         require_rust_sym=d(\"require_rust_sym\",\n-                           vec(T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n+                           [T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n                                T_size_t(), T_ptr(T_i8()),\n-                               T_ptr(T_ptr(T_i8()))),\n+                               T_ptr(T_ptr(T_i8()))],\n                            T_int()),\n         require_c_sym=d(\"require_c_sym\",\n-                        vec(T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n-                            T_ptr(T_i8()), T_ptr(T_i8())),\n+                        [T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n+                            T_ptr(T_i8()), T_ptr(T_i8())],\n                         T_int()),\n         get_type_desc=d(\"get_type_desc\",\n-                        vec(T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n-                            T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))),\n+                        [T_ptr(T_crate(tn)), T_size_t(), T_size_t(),\n+                            T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))],\n                         T_ptr(T_tydesc(tn))),\n-        new_task=d(\"new_task\", vec(T_ptr(T_i8())), T_taskptr(tn)),\n-        start_task=d(\"start_task\", vec(T_taskptr(tn), T_int(), T_int(),\n-                                       T_int(), T_size_t()),\n+        new_task=d(\"new_task\", [T_ptr(T_i8())], T_taskptr(tn)),\n+        start_task=d(\"start_task\", [T_taskptr(tn), T_int(), T_int(),\n+                                       T_int(), T_size_t()],\n                      T_taskptr(tn)),\n-        new_thread=d(\"new_thread\", vec(T_ptr(T_i8())), T_taskptr(tn)),\n-        start_thread=d(\"start_thread\", vec(T_taskptr(tn), T_int(), T_int(),\n-                                           T_int(), T_size_t()),\n+        new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n+        start_thread=d(\"start_thread\", [T_taskptr(tn), T_int(), T_int(),\n+                                           T_int(), T_size_t()],\n                        T_taskptr(tn))\n     );\n }"}, {"sha": "fffb82053f6769dfc563725e65cfdf2dbbea9285", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -12,78 +12,78 @@ fn wstr(int i) -> str {\n }\n \n fn start() -> vec[str] {\n-    ret vec(\".cfi_startproc\");\n+    ret [\".cfi_startproc\"];\n }\n \n fn end() -> vec[str] {\n-    ret vec(\".cfi_endproc\");\n+    ret [\".cfi_endproc\"];\n }\n \n fn save_callee_saves() -> vec[str] {\n-    ret vec(\"pushl %ebp\",\n+    ret [\"pushl %ebp\",\n             \"pushl %edi\",\n             \"pushl %esi\",\n-            \"pushl %ebx\");\n+            \"pushl %ebx\"];\n }\n \n fn save_callee_saves_with_cfi() -> vec[str] {\n     auto offset = 8;\n     auto t;\n-    t  = vec(\"pushl %ebp\");\n-    t += vec(\".cfi_def_cfa_offset \" + istr(offset));\n-    t += vec(\".cfi_offset %ebp, -\" + istr(offset));\n+    t  = [\"pushl %ebp\"];\n+    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n+    t += [\".cfi_offset %ebp, -\" + istr(offset)];\n \n-    t += vec(\"pushl %edi\");\n+    t += [\"pushl %edi\"];\n     offset += 4;\n-    t += vec(\".cfi_def_cfa_offset \" + istr(offset));\n+    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n \n-    t += vec(\"pushl %esi\");\n+    t += [\"pushl %esi\"];\n     offset += 4;\n-    t += vec(\".cfi_def_cfa_offset \" + istr(offset));\n+    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n \n-    t += vec(\"pushl %ebx\");\n+    t += [\"pushl %ebx\"];\n     offset += 4;\n-    t += vec(\".cfi_def_cfa_offset \" + istr(offset));\n+    t += [\".cfi_def_cfa_offset \" + istr(offset)];\n     ret t;\n }\n \n fn restore_callee_saves() -> vec[str] {\n-    ret vec(\"popl  %ebx\",\n+    ret [\"popl  %ebx\",\n             \"popl  %esi\",\n             \"popl  %edi\",\n-            \"popl  %ebp\");\n+            \"popl  %ebp\"];\n }\n \n fn load_esp_from_rust_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%ecx), %esp\");\n+    ret [\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%ecx), %esp\"];\n }\n \n fn load_esp_from_runtime_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%ecx), %esp\");\n+    ret [\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%ecx), %esp\"];\n }\n \n fn store_esp_to_rust_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\");\n+    ret [\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\"];\n }\n \n fn store_esp_to_runtime_sp_first_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%ecx)\");\n+    ret [\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%ecx)\"];\n }\n \n fn load_esp_from_rust_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%edx), %esp\");\n+    ret [\"movl  \" + wstr(abi::task_field_rust_sp) + \"(%edx), %esp\"];\n }\n \n fn load_esp_from_runtime_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%edx), %esp\");\n+    ret [\"movl  \" + wstr(abi::task_field_runtime_sp) + \"(%edx), %esp\"];\n }\n \n fn store_esp_to_rust_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%edx)\");\n+    ret [\"movl  %esp, \" + wstr(abi::task_field_rust_sp) + \"(%edx)\"];\n }\n \n fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n-    ret vec(\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%edx)\");\n+    ret [\"movl  %esp, \" + wstr(abi::task_field_runtime_sp) + \"(%edx)\"];\n }\n \n \n@@ -105,7 +105,7 @@ fn store_esp_to_runtime_sp_second_arg() -> vec[str] {\n  */\n \n fn rust_activate_glue() -> vec[str] {\n-    ret vec(\"movl  4(%esp), %ecx    # ecx = rust_task\")\n+    ret [\"movl  4(%esp), %ecx    # ecx = rust_task\"]\n         + save_callee_saves()\n         + store_esp_to_runtime_sp_first_arg()\n         + load_esp_from_rust_sp_first_arg()\n@@ -157,7 +157,7 @@ fn rust_activate_glue() -> vec[str] {\n          *      will be a no-op. Esp won't move, and the task's stack won't\n          *      grow.\n          */\n-        + vec(\"addl  $20, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\")\n+        + [\"addl  $20, \" + wstr(abi::task_field_rust_sp) + \"(%ecx)\"]\n \n \n         /*\n@@ -167,10 +167,10 @@ fn rust_activate_glue() -> vec[str] {\n          * activating, the task needs to be in the fastcall 2nd parameter\n          * expected by the rust main function. That's edx.\n          */\n-        + vec(\"mov  %ecx, %edx\")\n+        + [\"mov  %ecx, %edx\"]\n \n         + restore_callee_saves()\n-        + vec(\"ret\");\n+        + [\"ret\"];\n }\n \n /* More glue code, this time the 'bottom half' of yielding.\n@@ -200,13 +200,13 @@ fn rust_activate_glue() -> vec[str] {\n  */\n \n fn rust_yield_glue() -> vec[str] {\n-    ret vec(\"movl  0(%esp), %ecx    # ecx = rust_task\")\n+    ret [\"movl  0(%esp), %ecx    # ecx = rust_task\"]\n         + load_esp_from_rust_sp_first_arg()\n         + save_callee_saves()\n         + store_esp_to_rust_sp_first_arg()\n         + load_esp_from_runtime_sp_first_arg()\n         + restore_callee_saves()\n-        + vec(\"ret\");\n+        + [\"ret\"];\n }\n \n fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n@@ -239,8 +239,8 @@ fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n         } else {\n             src_off = wstr(5 + (i as int));\n         }\n-        auto m = vec(\"movl  \" + src_off + \"(%ebp),%eax\",\n-                     \"movl  %eax,\" + dst_off + \"(%esp)\");\n+        auto m = [\"movl  \" + src_off + \"(%ebp),%eax\",\n+                     \"movl  %eax,\" + dst_off + \"(%esp)\"];\n         ret _str::connect(m, \"\\n\\t\");\n     }\n \n@@ -250,24 +250,24 @@ fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n         start()\n         + save_callee_saves_with_cfi()\n \n-        + vec(\"movl  %esp, %ebp     # ebp = rust_sp\")\n-        + vec(\".cfi_def_cfa_register %ebp\")\n+        + [\"movl  %esp, %ebp     # ebp = rust_sp\"]\n+        + [\".cfi_def_cfa_register %ebp\"]\n \n         + store_esp_to_rust_sp_second_arg()\n         + load_esp_from_runtime_sp_second_arg()\n \n-        + vec(\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n-              \"andl  $~0xf, %esp    # align esp down\")\n+        + [\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n+              \"andl  $~0xf, %esp    # align esp down\"]\n \n         + _vec::init_fn[str](carg, (n_args) as uint)\n \n-        +  vec(\"movl  %edx, %edi     # save task from edx to edi\",\n+        +  [\"movl  %edx, %edi     # save task from edx to edi\",\n                \"call  *%ecx          # call *%ecx\",\n-               \"movl  %edi, %edx     # restore edi-saved task to edx\")\n+               \"movl  %edi, %edx     # restore edi-saved task to edx\"]\n \n         + load_esp_from_rust_sp_second_arg()\n         + restore_callee_saves()\n-        + vec(\"ret\")\n+        + [\"ret\"]\n         + end();\n \n }\n@@ -305,13 +305,13 @@ fn get_module_asm() -> str {\n     auto prefix = get_symbol_prefix();\n \n     auto glues =\n-        vec(decl_glue(align, prefix,\n+        [decl_glue(align, prefix,\n                       abi::activate_glue_name(),\n                       rust_activate_glue()),\n \n             decl_glue(align, prefix,\n                       abi::yield_glue_name(),\n-                      rust_yield_glue()))\n+                      rust_yield_glue())]\n \n         + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n             abi::ngt_rust, _), (abi::n_native_glues + 1) as uint)"}, {"sha": "f2f082323fac376921a8a3bc5adaec42ba7619bb", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -44,7 +44,7 @@ fn default_environment(session::session sess,\n     }\n \n     ret\n-        vec(\n+        [\n             // Target bindings.\n             tup(\"target_os\", eval::val_str(std::os::target_os())),\n             tup(\"target_arch\", eval::val_str(\"x86\")),\n@@ -53,7 +53,7 @@ fn default_environment(session::session sess,\n             // Build bindings.\n             tup(\"build_compiler\", eval::val_str(argv0)),\n             tup(\"build_input\", eval::val_str(input))\n-            );\n+            ];\n }\n \n fn parse_input(session::session sess,\n@@ -205,7 +205,7 @@ fn main(vec[str] args) {\n              uint_type = common::ty_u32,\n              float_type = common::ty_f64);\n \n-    auto opts = vec(optflag(\"h\"), optflag(\"help\"),\n+    auto opts = [optflag(\"h\"), optflag(\"help\"),\n                     optflag(\"v\"), optflag(\"version\"),\n                     optflag(\"glue\"), optflag(\"emit-llvm\"),\n                     optflag(\"pretty\"), optflag(\"ls\"), optflag(\"parse-only\"),\n@@ -214,7 +214,7 @@ fn main(vec[str] args) {\n                     optflag(\"save-temps\"), optopt(\"sysroot\"),\n                     optflag(\"stats\"),\n                     optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n-                    optflag(\"no-typestate\"), optflag(\"noverify\"));\n+                    optflag(\"no-typestate\"), optflag(\"noverify\")];\n     auto binary = _vec::shift[str](args);\n     auto match;\n     alt (getopts::getopts(args, opts)) {\n@@ -287,7 +287,7 @@ fn main(vec[str] args) {\n \n     auto crate_cache = common::new_int_hash[session::crate_metadata]();\n     auto target_crate_num = 0;\n-    let vec[@ast::meta_item] md = vec();\n+    let vec[@ast::meta_item] md = [];\n     auto sess =\n         session::session(target_crate_num, target_cfg, sopts,\n                         crate_cache, md, front::codemap::new_codemap());\n@@ -323,13 +323,13 @@ fn main(vec[str] args) {\n                 _vec::pop[str](parts);\n                 saved_out_filename = parts.(0);\n                 alt (output_type) {\n-                    case (link::output_type_none) { parts += vec(\"pp\"); }\n-                    case (link::output_type_bitcode) { parts += vec(\"bc\"); }\n-                    case (link::output_type_assembly) { parts += vec(\"s\"); }\n+                    case (link::output_type_none) { parts += [\"pp\"]; }\n+                    case (link::output_type_bitcode) { parts += [\"bc\"]; }\n+                    case (link::output_type_assembly) { parts += [\"s\"]; }\n \n                     // Object and exe output both use the '.o' extension here\n-                    case (link::output_type_object) { parts += vec(\"o\"); }\n-                    case (link::output_type_exe) { parts += vec(\"o\"); }\n+                    case (link::output_type_object) { parts += [\"o\"]; }\n+                    case (link::output_type_exe) { parts += [\"o\"]; }\n                 }\n                 auto ofile = _str::connect(parts, \".\");\n                 compile_input(sess, env, ifile, ofile);\n@@ -353,33 +353,33 @@ fn main(vec[str] args) {\n         let str exe_suffix = \"\";\n \n         // The invocations of gcc share some flags across platforms\n-        let vec[str] common_cflags = vec(\"-fno-strict-aliasing\", \"-fPIC\",\n-                           \"-Wall\", \"-fno-rtti\", \"-fno-exceptions\", \"-g\");\n-        let vec[str] common_libs = vec(stage, \"-Lrustllvm\", \"-Lrt\",\n-                           \"-lrustrt\", \"-lrustllvm\", \"-lstd\", \"-lm\");\n+        let vec[str] common_cflags = [\"-fno-strict-aliasing\", \"-fPIC\",\n+                           \"-Wall\", \"-fno-rtti\", \"-fno-exceptions\", \"-g\"];\n+        let vec[str] common_libs = [stage, \"-Lrustllvm\", \"-Lrt\",\n+                           \"-lrustrt\", \"-lrustllvm\", \"-lstd\", \"-lm\"];\n \n         alt (sess.get_targ_cfg().os) {\n             case (session::os_win32) {\n                 exe_suffix = \".exe\";\n-                gcc_args = common_cflags + vec(\n+                gcc_args = common_cflags + [\n                             \"-march=i686\", \"-O2\",\n                             glu, \"-o\",\n                             saved_out_filename + exe_suffix,\n-                            saved_out_filename + \".o\") + common_libs;\n+                            saved_out_filename + \".o\"] + common_libs;\n             }\n             case (session::os_macos) {\n-                gcc_args = common_cflags + vec(\n+                gcc_args = common_cflags + [\n                            \"-arch i386\", \"-O0\", \"-m32\",\n                            glu, \"-o\",\n                            saved_out_filename + exe_suffix,\n-                           saved_out_filename + \".o\") + common_libs;\n+                           saved_out_filename + \".o\"] + common_libs;\n             }\n             case (session::os_linux) {\n-                gcc_args = common_cflags + vec(\n+                gcc_args = common_cflags + [\n                            \"-march=i686\", \"-O2\", \"-m32\",\n                            glu, \"-o\",\n                            saved_out_filename + exe_suffix,\n-                           saved_out_filename + \".o\") + common_libs;\n+                           saved_out_filename + \".o\"] + common_libs;\n             }\n         }\n \n@@ -388,12 +388,12 @@ fn main(vec[str] args) {\n \n         // Clean up on Darwin\n         if (sess.get_targ_cfg().os == session::os_macos) {\n-            run::run_program(\"dsymutil\", vec(saved_out_filename));\n+            run::run_program(\"dsymutil\", [saved_out_filename]);\n         }\n \n         // Remove the temporary object file if we aren't saving temps\n         if (!save_temps) {\n-            run::run_program(\"rm\", vec(saved_out_filename + \".o\"));\n+            run::run_program(\"rm\", [saved_out_filename + \".o\"]);\n         }\n     }\n }"}, {"sha": "cd959d9d88deb49db61ea5a8954e52f9093bafa3", "filename": "src/comp/front/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -13,14 +13,14 @@ type codemap = @rec(mutable vec[filemap] files);\n type loc = rec(str filename, uint line, uint col);\n \n fn new_codemap() -> codemap {\n-    let vec[filemap] files = vec();\n+    let vec[filemap] files = [];\n     ret @rec(mutable files=files);\n }\n \n fn new_filemap(str filename, uint start_pos) -> filemap {\n     ret @rec(name=filename,\n              start_pos=start_pos,\n-             mutable lines=vec(0u));\n+             mutable lines=[0u]);\n }\n \n fn next_line(filemap file, uint pos) {"}, {"sha": "3ac7b3638e1e6087a480f9cd4e59a5a39bca1d07", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -90,9 +90,9 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('t') {\n             assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n-            let vec[ty::t] params = vec();\n+            let vec[ty::t] params = [];\n             while (peek(st) as char != ']') {\n-                params += vec(parse_ty(st, sd));\n+                params += [parse_ty(st, sd)];\n             }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tag(st.tcx, def, params);\n@@ -104,23 +104,23 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         case ('C') { ret ty::mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n             assert (next(st) as char == '[');\n-            let vec[ty::mt] params = vec();\n+            let vec[ty::mt] params = [];\n             while (peek(st) as char != ']') {\n-                params += vec(parse_mt(st, sd));\n+                params += [parse_mt(st, sd)];\n             }\n             st.pos = st.pos + 1u;\n             ret ty::mk_tup(st.tcx, params);\n         }\n         case ('R') {\n             assert (next(st) as char == '[');\n-            let vec[ty::field] fields = vec();\n+            let vec[ty::field] fields = [];\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n                 while (peek(st) as char != '=') {\n                     name += _str::unsafe_from_byte(next(st));\n                 }\n                 st.pos = st.pos + 1u;\n-                fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n+                fields += [rec(ident=name, mt=parse_mt(st, sd))];\n             }\n             st.pos = st.pos + 1u;\n             ret ty::mk_rec(st.tcx, fields);\n@@ -146,7 +146,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n-            let vec[ty::method] methods = vec();\n+            let vec[ty::method] methods = [];\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n@@ -158,10 +158,10 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                     name += _str::unsafe_from_byte(next(st));\n                 }\n                 auto func = parse_ty_fn(st, sd);\n-                methods += vec(rec(proto=proto,\n+                methods += [rec(proto=proto,\n                                    ident=name,\n                                    inputs=func._0,\n-                                   output=func._1));\n+                                   output=func._1)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);\n@@ -242,14 +242,14 @@ fn parse_hex(@pstate st) -> uint {\n \n fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t) {\n     assert (next(st) as char == '[');\n-    let vec[ty::arg] inputs = vec();\n+    let vec[ty::arg] inputs = [];\n     while (peek(st) as char != ']') {\n         auto mode = ty::mo_val;\n         if (peek(st) as char == '&') {\n             mode = ty::mo_alias;\n             st.pos = st.pos + 1u;\n         }\n-        inputs += vec(rec(mode=mode, ty=parse_ty(st, sd)));\n+        inputs += [rec(mode=mode, ty=parse_ty(st, sd))];\n     }\n     st.pos = st.pos + 1u;\n     ret tup(inputs, parse_ty(st, sd));\n@@ -285,7 +285,7 @@ fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n     auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n     auto bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n-    let vec[ebml::doc] result = vec();\n+    let vec[ebml::doc] result = [];\n     auto belt = metadata::tag_index_buckets_bucket_elt;\n     for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n         auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n@@ -306,7 +306,7 @@ fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n     auto md = ebml::new_doc(data);\n     auto paths = ebml::get_doc(md, metadata::tag_paths);\n     auto eqer = bind eq_item(_, s);\n-    let vec[ast::def_id] result = vec();\n+    let vec[ast::def_id] result = [];\n     for (ebml::doc doc in lookup_hash(paths, eqer, metadata::hash_path(s))) {\n         auto did_doc = ebml::get_doc(doc, metadata::tag_def_id);\n         _vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n@@ -380,7 +380,7 @@ fn item_ty_param_count(&ebml::doc item, int this_cnum) -> uint {\n }\n \n fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n-    let vec[ast::def_id] ids = vec();\n+    let vec[ast::def_id] ids = [];\n     auto v = metadata::tag_items_data_item_variant;\n     for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n         auto ext = parse_def_id(ebml::doc_data(p));\n@@ -544,23 +544,23 @@ fn get_tag_variants(session::session sess, ty::ctxt tcx, ast::def_id def)\n     auto items = ebml::get_doc(ebml::new_doc(data), metadata::tag_items);\n     auto item = find_item(def._1, items);\n \n-    let vec[trans::variant_info] infos = vec();\n+    let vec[trans::variant_info] infos = [];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n         auto ctor_ty = item_type(item, external_crate_id, tcx);\n-        let vec[ty::t] arg_tys = vec();\n+        let vec[ty::t] arg_tys = [];\n         alt (ty::struct(tcx, ctor_ty)) {\n             case (ty::ty_fn(_, ?args, _)) {\n                 for (ty::arg a in args) {\n-                    arg_tys += vec(a.ty);\n+                    arg_tys += [a.ty];\n                 }\n             }\n             case (_) {\n                 // Nullary tag variant.\n             }\n         }\n-        infos += vec(rec(args=arg_tys, ctor_ty=ctor_ty, id=did));\n+        infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n     }\n \n     ret infos;"}, {"sha": "c44af3d0926bed9c19fd0ca682aaddf1768a02ca", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -38,7 +38,7 @@ type ctx = @rec(parser p,\n                 mutable uint next_ann);\n \n fn mk_env() -> env {\n-    let env e = vec();\n+    let env e = [];\n     ret e;\n }\n \n@@ -249,8 +249,8 @@ fn eval_crate_directives(ctx cx,\n fn eval_crate_directives_to_mod(ctx cx, env e,\n                                        vec[@ast::crate_directive] cdirs,\n                                        str prefix) -> ast::_mod {\n-    let vec[@ast::view_item] view_items = vec();\n-    let vec[@ast::item] items = vec();\n+    let vec[@ast::view_item] view_items = [];\n+    let vec[@ast::item] items = [];\n \n     eval_crate_directives(cx, e, cdirs, prefix,\n                           view_items, items);\n@@ -356,7 +356,7 @@ fn eval_crate_directive(ctx cx,\n \n         case (ast::cdir_let(?id, ?x, ?cdirs)) {\n             auto v = eval_expr(cx, e, x);\n-            auto e0 = vec(tup(id, v)) + e;\n+            auto e0 = [tup(id, v)] + e;\n             eval_crate_directives(cx, e0, cdirs, prefix,\n                                   view_items, items);\n         }\n@@ -379,7 +379,7 @@ fn eval_crate_directive(ctx cx,\n             auto full_path = prefix + std::fs::path_sep() + file_path;\n \n             if (cx.mode == mode_depend) {\n-                cx.deps += vec(full_path);\n+                cx.deps += [full_path];\n                 ret;\n             }\n "}, {"sha": "9c15d11e4c434971bb33df08d63af4473bf2633a", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -118,7 +118,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n \n     fn make_path_expr(parser p, common::span sp, vec[ast::ident] idents)\n             -> @ast::expr {\n-        let vec[@ast::ty] types = vec();\n+        let vec[@ast::ty] types = [];\n         auto path = rec(idents=idents, types=types);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path, p.get_ann());\n@@ -143,14 +143,14 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n \n     fn make_rec_expr(parser p, common::span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n-        let vec[ast::field] astfields = vec();\n+        let vec[ast::field] astfields = [];\n         for (tup(ast::ident, @ast::expr) field in fields) {\n             auto ident = field._0;\n             auto val = field._1;\n             auto astfield = rec(mut = ast::imm,\n                                 ident = ident,\n                                 expr = val);\n-            astfields += vec(astfield);\n+            astfields += [astfield];\n         }\n \n         auto recexpr = ast::expr_rec(astfields,\n@@ -163,7 +163,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n     fn make_path_vec(str ident) -> vec[str] {\n         // FIXME: #fmt can't currently be used from within std\n         // because we're explicitly referencing the 'std' crate here\n-        ret vec(\"std\", \"extfmt\", \"rt\", ident);\n+        ret [\"std\", \"extfmt\", \"rt\", ident];\n     }\n \n     fn make_rt_path_expr(parser p, common::span sp, str ident) -> @ast::expr {\n@@ -177,7 +177,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n \n         fn make_flags(parser p, common::span sp, vec[flag] flags)\n                 -> @ast::expr {\n-            let vec[@ast::expr] flagexprs = vec();\n+            let vec[@ast::expr] flagexprs = [];\n             for (flag f in flags) {\n                 auto fstr;\n                 alt (f) {\n@@ -197,14 +197,14 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n                         fstr = \"flag_alternate\";\n                     }\n                 }\n-                flagexprs += vec(make_rt_path_expr(p, sp, fstr));\n+                flagexprs += [make_rt_path_expr(p, sp, fstr)];\n             }\n \n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n             if (_vec::len[@ast::expr](flagexprs) == 0u) {\n-                flagexprs += vec(make_rt_path_expr(p, sp, \"flag_none\"));\n+                flagexprs += [make_rt_path_expr(p, sp, \"flag_none\")];\n             }\n \n             ret make_vec_expr(p, sp, flagexprs);\n@@ -218,7 +218,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n                 case (count_is(?c)) {\n                     auto count_lit = make_new_int(p, sp, c);\n                     auto count_is_path = make_path_vec(\"count_is\");\n-                    auto count_is_args = vec(count_lit);\n+                    auto count_is_args = [count_lit];\n                     ret make_call(p, sp, count_is_path, count_is_args);\n                 }\n                 case (_) {\n@@ -261,10 +261,10 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n                          @ast::expr width_expr,\n                          @ast::expr precision_expr,\n                          @ast::expr ty_expr) -> @ast::expr {\n-            ret make_rec_expr(p, sp, vec(tup(\"flags\", flags_expr),\n+            ret make_rec_expr(p, sp, [tup(\"flags\", flags_expr),\n                                          tup(\"width\", width_expr),\n                                          tup(\"precision\", precision_expr),\n-                                         tup(\"ty\", ty_expr)));\n+                                         tup(\"ty\", ty_expr)]);\n         }\n \n         auto rt_conv_flags = make_flags(p, sp, cnv.flags);\n@@ -284,7 +284,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n         auto cnv_expr = make_rt_conv_expr(p, sp, cnv);\n-        auto args = vec(cnv_expr, arg);\n+        auto args = [cnv_expr, arg];\n         ret make_call(p, arg.span, path, args);\n     }\n "}, {"sha": "c151dc2f7be1a397304e0ddff82bbf46f1639130", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -91,7 +91,7 @@ fn new_reader(session sess, io::reader rdr,\n         }\n     }\n     auto file = _str::unsafe_from_bytes(rdr.read_whole_stream());\n-    let vec[str] strs = vec();\n+    let vec[str] strs = [];\n     auto rd = reader(sess, file, _str::byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      strs, filemap, itr);\n@@ -228,11 +228,11 @@ fn scan_exponent(reader rdr) -> option::t[str] {\n     auto res = \"\";\n \n     if (c == 'e' || c == 'E') {\n-        res += _str::from_bytes(vec(c as u8));\n+        res += _str::from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '-' || c == '+') {\n-            res += _str::from_bytes(vec(c as u8));\n+            res += _str::from_bytes([c as u8]);\n             rdr.bump();\n         }\n         auto exponent = scan_dec_digits(rdr);\n@@ -256,7 +256,7 @@ fn scan_dec_digits(reader rdr) -> str {\n \n     while (is_dec_digit (c) || c == '_') {\n         if (c != '_') {\n-            res += _str::from_bytes(vec(c as u8));\n+            res += _str::from_bytes([c as u8]);\n         }\n         rdr.bump();\n         c = rdr.curr();\n@@ -766,7 +766,7 @@ fn read_block_comment(reader rdr) -> cmnt {\n     auto p = rdr.get_chpos();\n     rdr.bump(); rdr.bump();\n     while (rdr.curr() == ' ') {rdr.bump();}\n-    let vec[str] lines = vec();\n+    let vec[str] lines = [];\n     auto val = \"\";\n     auto level = 1;\n     while (true) {\n@@ -802,7 +802,7 @@ fn gather_comments(session sess, str path) -> vec[cmnt] {\n     auto srdr = io::file_reader(path);\n     auto itr = @interner::mk_interner[str](_str::hash, _str::eq);\n     auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n-    let vec[cmnt] comments = vec();\n+    let vec[cmnt] comments = [];\n     while (!rdr.is_eof()) {\n         while (true) {\n             consume_whitespace(rdr);"}, {"sha": "3fa25857d3f4973f973811f44ea7c9b20d86095f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -422,7 +422,7 @@ fn parse_ty_constr(parser p) -> @ast::constr {\n fn parse_constrs(parser p) -> common::spanned[vec[@ast::constr]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n-    let vec[@ast::constr] constrs = vec();\n+    let vec[@ast::constr] constrs = [];\n     if (p.peek() == token::COLON) {\n         p.bump();\n         while (true) {\n@@ -580,7 +580,7 @@ fn parse_seq_to_end[T](token::token ket,\n                               uint hi,\n                               parser p) -> vec[T] {\n     let bool first = true;\n-    let vec[T] v = vec();\n+    let vec[T] v = [];\n     while (p.peek() != ket) {\n         alt(sep) {\n             case (some[token::token](?t)) {\n@@ -595,7 +595,7 @@ fn parse_seq_to_end[T](token::token ket,\n         }\n         // FIXME: v += f(p) doesn't work at the moment.\n         let T t = f(p);\n-        v += vec(t);\n+        v += [t];\n     }\n     hi = p.get_hi_pos();\n     expect(p, ket);\n@@ -677,7 +677,7 @@ fn parse_ty_args(parser p, uint hi) ->\n                                some(token::COMMA),\n                                pf, p);\n     }\n-    let vec[@ast::ty] v = vec();\n+    let vec[@ast::ty] v = [];\n     auto pos = p.get_lo_pos();\n     ret spanned(hi, hi, v);\n }\n@@ -687,12 +687,12 @@ fn parse_path(parser p) -> ast::path {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n \n-    let vec[ast::ident] ids = vec();\n+    let vec[ast::ident] ids = [];\n     while (true) {\n         alt (p.peek()) {\n             case (token::IDENT(?i, _)) {\n                 hi = p.get_hi_pos();\n-                ids += vec(p.get_str(i));\n+                ids += [p.get_str(i)];\n                 p.bump();\n                 if (p.peek() == token::MOD_SEP) {\n                     p.bump();\n@@ -797,7 +797,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n                   pf, hi, p));\n         }\n \n-        let vec[@ast::method] meths = vec();\n+        let vec[@ast::method] meths = [];\n         let option::t[ast::ident] with_obj = none[ast::ident];\n \n         expect(p, token::LBRACE);\n@@ -830,7 +830,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n \n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n-        auto fields = vec(parse_field(p));\n+        auto fields = [parse_field(p)];\n \n         auto more = true;\n         auto base = none[@ast::expr];\n@@ -846,7 +846,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n                 more = false;\n             } else if (p.peek() == token::COMMA) {\n                 p.bump();\n-                fields += vec(parse_field(p));\n+                fields += [parse_field(p)];\n             } else {\n                 unexpected(p, p.peek());\n             }\n@@ -1151,7 +1151,7 @@ type op_spec = rec(token::token tok, ast::binop op, int prec);\n \n // FIXME make this a const, don't store it in parser state\n fn prec_table() -> vec[op_spec] {\n-    ret vec(rec(tok=token::BINOP(token::STAR), op=ast::mul, prec=11),\n+    ret [rec(tok=token::BINOP(token::STAR), op=ast::mul, prec=11),\n             rec(tok=token::BINOP(token::SLASH), op=ast::div, prec=11),\n             rec(tok=token::BINOP(token::PERCENT), op=ast::rem, prec=11),\n             rec(tok=token::BINOP(token::PLUS), op=ast::add, prec=10),\n@@ -1170,7 +1170,7 @@ fn prec_table() -> vec[op_spec] {\n             rec(tok=token::EQEQ, op=ast::eq, prec=3),\n             rec(tok=token::NE, op=ast::ne, prec=3),\n             rec(tok=token::ANDAND, op=ast::and, prec=2),\n-            rec(tok=token::OROR, op=ast::or, prec=1));\n+            rec(tok=token::OROR, op=ast::or, prec=1)];\n }\n \n fn parse_binops(parser p) -> @ast::expr {\n@@ -1342,14 +1342,14 @@ fn parse_alt_expr(parser p) -> @ast::expr {\n     expect(p, token::RPAREN);\n     expect(p, token::LBRACE);\n \n-    let vec[ast::arm] arms = vec();\n+    let vec[ast::arm] arms = [];\n     while (p.peek() != token::RBRACE) {\n         if (eat_word(p, \"case\")) {\n             expect(p, token::LPAREN);\n             auto pat = parse_pat(p);\n             expect(p, token::RPAREN);\n             auto block = parse_block(p);\n-            arms += vec(rec(pat=pat, block=block));\n+            arms += [rec(pat=pat, block=block)];\n         } else if (p.peek() == token::RBRACE) {\n             /* empty */\n         } else {\n@@ -1480,7 +1480,7 @@ fn parse_pat(parser p) -> @ast::pat {\n                         args = a.node;\n                         hi = a.span.hi;\n                     }\n-                    case (_) { args = vec(); }\n+                    case (_) { args = []; }\n                 }\n \n                 pat = ast::pat_tag(tag_path, args, p.get_ann());\n@@ -1630,7 +1630,7 @@ fn stmt_ends_with_semi(@ast::stmt stmt) -> bool {\n fn parse_block(parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n \n-    let vec[@ast::stmt] stmts = vec();\n+    let vec[@ast::stmt] stmts = [];\n     let option::t[@ast::expr] expr = none[@ast::expr];\n \n     expect(p, token::LBRACE);\n@@ -1650,7 +1650,7 @@ fn parse_block(parser p) -> ast::block {\n                         alt (p.peek()) {\n                             case (token::SEMI) {\n                                 p.bump();\n-                                stmts += vec(stmt);\n+                                stmts += [stmt];\n                             }\n                             case (token::RBRACE) { expr = some(e); }\n                             case (?t) {\n@@ -1660,13 +1660,13 @@ fn parse_block(parser p) -> ast::block {\n                                           token::to_str(p.get_reader(), t));\n                                     fail;\n                                 }\n-                                stmts += vec(stmt);\n+                                stmts += [stmt];\n                             }\n                         }\n                     }\n                     case (none[@ast::expr]) {\n                         // Not an expression statement.\n-                        stmts += vec(stmt);\n+                        stmts += [stmt];\n                         // FIXME: crazy differentiation between conditions\n                         // used in branches and binary expressions in rustboot\n                         // means we cannot use && here. I know, right?\n@@ -1693,7 +1693,7 @@ fn parse_ty_param(parser p) -> ast::ty_param {\n }\n \n fn parse_ty_params(parser p) -> vec[ast::ty_param] {\n-    let vec[ast::ty_param] ty_params = vec();\n+    let vec[ast::ty_param] ty_params = [];\n     if (p.peek() == token::LBRACKET) {\n         auto f = parse_ty_param;   // FIXME: pass as lval directly\n         ty_params = parse_seq[ast::ty_param](token::LBRACKET, token::RBRACKET,\n@@ -1775,7 +1775,7 @@ fn parse_method(parser p) -> @ast::method {\n fn parse_dtor(parser p) -> @ast::method {\n     auto lo = p.get_last_lo_pos();\n     let ast::block b = parse_block(p);\n-    let vec[ast::arg] inputs = vec();\n+    let vec[ast::arg] inputs = [];\n     let @ast::ty output = @spanned(lo, lo, ast::ty_nil);\n     let ast::fn_decl d = rec(inputs=inputs,\n                             output=output,\n@@ -1802,7 +1802,7 @@ fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n          some(token::COMMA),\n          pf, p);\n \n-    let vec[@ast::method] meths = vec();\n+    let vec[@ast::method] meths = [];\n     let option::t[@ast::method] dtor = none[@ast::method];\n \n     expect(p, token::LBRACE);\n@@ -1829,9 +1829,9 @@ fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n \n fn parse_mod_items(parser p, token::token term) -> ast::_mod {\n     auto view_items = parse_view(p);\n-    let vec[@ast::item] items = vec();\n+    let vec[@ast::item] items = [];\n     while (p.peek() != term) {\n-        items += vec(parse_item(p));\n+        items += [parse_item(p)];\n     }\n     ret rec(view_items=view_items, items=items);\n }\n@@ -1899,12 +1899,12 @@ fn parse_native_item(parser p) -> @ast::native_item {\n fn parse_native_mod_items(parser p,\n                                  str native_name,\n                                  ast::native_abi abi) -> ast::native_mod {\n-    let vec[@ast::native_item] items = vec();\n+    let vec[@ast::native_item] items = [];\n \n     auto view_items = parse_native_view(p);\n \n     while (p.peek() != token::RBRACE) {\n-        items += vec(parse_native_item(p));\n+        items += [parse_native_item(p)];\n     }\n     ret rec(native_name=native_name, abi=abi,\n             view_items=view_items,\n@@ -1982,7 +1982,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n \n-    let vec[ast::variant] variants = vec();\n+    let vec[ast::variant] variants = [];\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n         auto tok = p.peek();\n@@ -1992,7 +1992,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n                 auto vlo = p.get_lo_pos();\n                 p.bump();\n \n-                let vec[ast::variant_arg] args = vec();\n+                let vec[ast::variant_arg] args = [];\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto f = parse_ty;\n@@ -2001,7 +2001,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n                                                           some(token::COMMA),\n                                                           f, p);\n                         for (@ast::ty ty in arg_tys.node) {\n-                            args += vec(rec(ty=ty, id=p.next_def_id()));\n+                            args += [rec(ty=ty, id=p.next_def_id())];\n                         }\n                     }\n                     case (_) { /* empty */ }\n@@ -2013,7 +2013,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n                 auto id = p.next_def_id();\n                 auto vr = rec(name=p.get_str(name), args=args,\n                               id=id, ann=p.get_ann());\n-                variants += vec(spanned[ast::variant_](vlo, vhi, vr));\n+                variants += [spanned[ast::variant_](vlo, vhi, vr)];\n             }\n             case (token::RBRACE) { /* empty */ }\n             case (_) {\n@@ -2135,7 +2135,7 @@ fn parse_optional_meta(parser p) -> vec[@ast::meta_item] {\n             ret parse_meta(p);\n         }\n         case (_) {\n-            let vec[@ast::meta_item] v = vec();\n+            let vec[@ast::meta_item] v = [];\n             ret v;\n         }\n     }\n@@ -2156,11 +2156,11 @@ fn parse_rest_import_name(parser p, ast::ident first,\n                                  option::t[ast::ident] def_ident)\n         -> @ast::view_item {\n     auto lo = p.get_lo_pos();\n-    let vec[ast::ident] identifiers = vec(first);\n+    let vec[ast::ident] identifiers = [first];\n     while (p.peek() != token::SEMI) {\n         expect(p, token::MOD_SEP);\n         auto i = parse_ident(p);\n-        identifiers += vec(i);\n+        identifiers += [i];\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n@@ -2248,17 +2248,17 @@ fn is_view_item(&parser p) -> bool {\n }\n \n fn parse_view(parser p) -> vec[@ast::view_item] {\n-    let vec[@ast::view_item] items = vec();\n+    let vec[@ast::view_item] items = [];\n     while (is_view_item(p)) {\n-        items += vec(parse_view_item(p));\n+        items += [parse_view_item(p)];\n     }\n     ret items;\n }\n \n fn parse_native_view(parser p) -> vec[@ast::view_item] {\n-    let vec[@ast::view_item] items = vec();\n+    let vec[@ast::view_item] items = [];\n     while (is_view_item(p)) {\n-        items += vec(parse_view_item(p));\n+        items += [parse_view_item(p)];\n     }\n     ret items;\n }\n@@ -2267,7 +2267,7 @@ fn parse_native_view(parser p) -> vec[@ast::view_item] {\n fn parse_crate_from_source_file(parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto m = parse_mod_items(p, token::EOF);\n-    let vec[@ast::crate_directive] cdirs = vec();\n+    let vec[@ast::crate_directive] cdirs = [];\n     ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs,\n                                          module=m));\n }\n@@ -2362,7 +2362,7 @@ fn parse_crate_directive(parser p) -> ast::crate_directive\n fn parse_crate_directives(parser p, token::token term)\n     -> vec[@ast::crate_directive] {\n \n-    let vec[@ast::crate_directive] cdirs = vec();\n+    let vec[@ast::crate_directive] cdirs = [];\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n@@ -2376,7 +2376,7 @@ fn parse_crate_from_crate_file(parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n     auto cdirs = parse_crate_directives(p, token::EOF);\n-    let vec[str] deps = vec();\n+    let vec[str] deps = [];\n     auto cx = @rec(p=p,\n                    mode=eval::mode_parse,\n                    mutable deps = deps,"}, {"sha": "4a8e42a42d000c3fd4648200aacab2c75030ee68", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1395,7 +1395,7 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         let ValueRef T = llvm::LLVMGetNamedFunction(M,\n                                                     _str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n-        let vec[ValueRef] Args = vec();\n+        let vec[ValueRef] Args = [];\n         ret llvm::LLVMBuildCall(B, T,\n                                _vec::buf[ValueRef](Args),\n                                _vec::len[ValueRef](Args),\n@@ -1467,7 +1467,7 @@ fn mk_type_names() -> type_names {\n }\n \n fn type_to_str(type_names names, TypeRef ty) -> str {\n-    let vec[TypeRef] v = vec();\n+    let vec[TypeRef] v = [];\n     ret type_to_str_inner(names, v, ty);\n }\n \n@@ -1478,7 +1478,7 @@ fn type_to_str_inner(type_names names,\n         ret names.get_name(ty);\n     }\n \n-    auto outer = outer0 + vec(ty);\n+    auto outer = outer0 + [ty];\n \n     let int kind = llvm::LLVMGetTypeKind(ty);\n "}, {"sha": "606b37e49fc33d5ca2ee029fcf884468b57cb99e", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -358,7 +358,7 @@ type ast_fold[ENV] =\n //// Fold drivers.\n \n fn fold_path[ENV](&ENV env, &ast_fold[ENV] fld, &path p) -> path {\n-    let vec[@ast::ty] tys_ = vec();\n+    let vec[@ast::ty] tys_ = [];\n     for (@ast::ty t in p.node.types) {\n         _vec::push[@ast::ty](tys_, fold_ty(env, fld, t));\n     }\n@@ -398,7 +398,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n         }\n \n         case (ast::ty_tup(?elts)) {\n-            let vec[mt] elts_ = vec();\n+            let vec[mt] elts_ = [];\n             for (mt elt in elts) {\n                 auto ty_ = fold_ty(env, fld, elt.ty);\n                 _vec::push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n@@ -407,7 +407,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n         }\n \n         case (ast::ty_rec(?flds)) {\n-            let vec[ast::ty_field] flds_ = vec();\n+            let vec[ast::ty_field] flds_ = [];\n             for (ast::ty_field f in flds) {\n                 auto ty_ = fold_ty(env, fld, f.mt.ty);\n                 _vec::push[ast::ty_field]\n@@ -417,7 +417,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n         }\n \n         case (ast::ty_obj(?meths)) {\n-            let vec[ast::ty_method] meths_ = vec();\n+            let vec[ast::ty_method] meths_ = [];\n             for (ast::ty_method m in meths) {\n                 auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n                                       m.inputs, m.output);\n@@ -458,11 +458,11 @@ fn fold_ty_fn[ENV](&ENV env, &ast_fold[ENV] fld, &span sp,\n                    &vec[rec(ast::mode mode, @ty ty)] inputs,\n                    &@ty output) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n-    let vec[rec(ast::mode mode, @ty ty)] inputs_ = vec();\n+    let vec[rec(ast::mode mode, @ty ty)] inputs_ = [];\n     for (rec(ast::mode mode, @ty ty) input in inputs) {\n         auto ty_ = fold_ty(env, fld, input.ty);\n         auto input_ = rec(ty=ty_ with input);\n-        inputs_ += vec(input_);\n+        inputs_ += [input_];\n     }\n     ret fld.fold_ty_fn(env, sp, proto, inputs_, output_);\n }\n@@ -524,9 +524,9 @@ fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast::pat p) -> @ast::pat {\n         case (ast::pat_tag(?path, ?pats, ?t)) {\n             auto ppath = fold_path(env, fld, path);\n \n-            let vec[@ast::pat] ppats = vec();\n+            let vec[@ast::pat] ppats = [];\n             for (@ast::pat pat in pats) {\n-                ppats += vec(fold_pat(env_, fld, pat));\n+                ppats += [fold_pat(env_, fld, pat)];\n             }\n \n             ret fld.fold_pat_tag(env_, p.span, ppath, ppats, t);\n@@ -536,7 +536,7 @@ fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast::pat p) -> @ast::pat {\n \n fn fold_exprs[ENV](&ENV env, &ast_fold[ENV] fld,\n                    &vec[@expr] es) -> vec[@expr] {\n-    let vec[@expr] exprs = vec();\n+    let vec[@expr] exprs = [];\n     for (@expr e in es) {\n         _vec::push[@expr](exprs, fold_expr(env, fld, e));\n     }\n@@ -568,19 +568,19 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n         }\n \n         case (ast::expr_tup(?es, ?t)) {\n-            let vec[ast::elt] elts = vec();\n+            let vec[ast::elt] elts = [];\n             for (ast::elt e in es) {\n-                elts += vec(fold_tup_elt[ENV](env, fld, e));\n+                elts += [fold_tup_elt[ENV](env, fld, e)];\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_tup(env_, e.span, elts, t2);\n         }\n \n         case (ast::expr_rec(?fs, ?base, ?t)) {\n-            let vec[ast::field] fields = vec();\n+            let vec[ast::field] fields = [];\n             let option::t[@expr] b = none[@expr];\n             for (ast::field f in fs) {\n-                fields += vec(fold_rec_field(env, fld, f));\n+                fields += [fold_rec_field(env, fld, f)];\n             }\n             alt (base) {\n                 case (none[@ast::expr]) { }\n@@ -606,14 +606,14 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n \n         case (ast::expr_bind(?f, ?args_opt, ?t)) {\n             auto ff = fold_expr(env_, fld, f);\n-            let vec[option::t[@ast::expr]] aargs_opt = vec();\n+            let vec[option::t[@ast::expr]] aargs_opt = [];\n             for (option::t[@ast::expr] t_opt in args_opt) {\n                 alt (t_opt) {\n                     case (none[@ast::expr]) {\n-                        aargs_opt += vec(none[@ast::expr]);\n+                        aargs_opt += [none[@ast::expr]];\n                     }\n                     case (some[@ast::expr](?e)) {\n-                        aargs_opt += vec(some(fold_expr(env_, fld, e)));\n+                        aargs_opt += [some(fold_expr(env_, fld, e))];\n                     }\n                     case (none[@ast::expr]) { /* empty */ }\n                 }\n@@ -700,9 +700,9 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n \n         case (ast::expr_alt(?expr, ?arms, ?t)) {\n             auto eexpr = fold_expr(env_, fld, expr);\n-            let vec[ast::arm] aarms = vec();\n+            let vec[ast::arm] aarms = [];\n             for (ast::arm a in arms) {\n-                aarms += vec(fold_arm(env_, fld, a));\n+                aarms += [fold_arm(env_, fld, a)];\n             }\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_alt(env_, e.span, eexpr, aarms, t2);\n@@ -887,7 +887,7 @@ fn fold_block[ENV](&ENV env, &ast_fold[ENV] fld, &block blk) -> block {\n         ret blk;\n     }\n \n-    let vec[@ast::stmt] stmts = vec();\n+    let vec[@ast::stmt] stmts = [];\n     for (@ast::stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n         _vec::push[@ast::stmt](stmts, new_stmt);\n@@ -921,9 +921,9 @@ fn fold_arg[ENV](&ENV env, &ast_fold[ENV] fld, &arg a) -> arg {\n \n fn fold_fn_decl[ENV](&ENV env, &ast_fold[ENV] fld,\n                      &ast::fn_decl decl) -> ast::fn_decl {\n-    let vec[ast::arg] inputs = vec();\n+    let vec[ast::arg] inputs = [];\n     for (ast::arg a in decl.inputs) {\n-        inputs += vec(fold_arg(env, fld, a));\n+        inputs += [fold_arg(env, fld, a)];\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n     ret fld.fold_fn_decl(env, inputs, output, decl.purity);\n@@ -953,10 +953,10 @@ fn fold_method[ENV](&ENV env, &ast_fold[ENV] fld,\n \n fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n \n-    let vec[ast::obj_field] fields = vec();\n-    let vec[@ast::method] meths = vec();\n+    let vec[ast::obj_field] fields = [];\n+    let vec[@ast::method] meths = [];\n     for (ast::obj_field f in ob.fields) {\n-        fields += vec(fold_obj_field(env, fld, f));\n+        fields += [fold_obj_field(env, fld, f)];\n     }\n     let option::t[@ast::method] dtor = none[@ast::method];\n     alt (ob.dtor) {\n@@ -965,7 +965,7 @@ fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n             dtor = some[@ast::method](fold_method[ENV](env, fld, m));\n         }\n     }\n-    let vec[ast::ty_param] tp = vec();\n+    let vec[ast::ty_param] tp = [];\n     for (@ast::method m in ob.methods) {\n         // Fake-up an ast::item for this method.\n         // FIXME: this is kinda awful. Maybe we should reformulate\n@@ -990,9 +990,9 @@ fn fold_anon_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::anon_obj ob)\n     alt (ob.fields) {\n         case (none[vec[ast::obj_field]]) { }\n         case (some[vec[ast::obj_field]](?v)) {\n-            let vec[ast::obj_field] fields = vec();\n+            let vec[ast::obj_field] fields = [];\n             for (ast::obj_field f in v) {\n-                fields += vec(fold_obj_field(env, fld, f));\n+                fields += [fold_obj_field(env, fld, f)];\n             }\n         }\n     }\n@@ -1007,8 +1007,8 @@ fn fold_anon_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::anon_obj ob)\n     }\n \n     // Methods\n-    let vec[@ast::method] meths = vec();\n-    let vec[ast::ty_param] tp = vec();\n+    let vec[@ast::method] meths = [];\n+    let vec[ast::ty_param] tp = [];\n     for (@ast::method m in ob.methods) {\n         // Fake-up an ast::item for this method.\n         // FIXME: this is kinda awful. Maybe we should reformulate\n@@ -1089,16 +1089,16 @@ fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n         }\n \n         case (ast::item_tag(?ident, ?variants, ?ty_params, ?id, ?ann)) {\n-            let vec[ast::variant] new_variants = vec();\n+            let vec[ast::variant] new_variants = [];\n             for (ast::variant v in variants) {\n-                let vec[ast::variant_arg] new_args = vec();\n+                let vec[ast::variant_arg] new_args = [];\n                 for (ast::variant_arg va in v.node.args) {\n                     auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n-                    new_args += vec(rec(ty=new_ty, id=va.id));\n+                    new_args += [rec(ty=new_ty, id=va.id)];\n                 }\n                 auto new_v = rec(name=v.node.name, args=new_args,\n                                  id=v.node.id, ann=v.node.ann);\n-                new_variants += vec(respan[ast::variant_](v.span, new_v));\n+                new_variants += [respan[ast::variant_](v.span, new_v)];\n             }\n             ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n                                   ty_params, id, ann);\n@@ -1116,8 +1116,8 @@ fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n \n fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast::_mod m) -> ast::_mod {\n \n-    let vec[@view_item] view_items = vec();\n-    let vec[@item] items = vec();\n+    let vec[@view_item] view_items = [];\n+    let vec[@item] items = [];\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n@@ -1154,8 +1154,8 @@ fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n \n fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n                         &ast::native_mod m) -> ast::native_mod {\n-    let vec[@view_item] view_items = vec();\n-    let vec[@native_item] items = vec();\n+    let vec[@view_item] view_items = [];\n+    let vec[@native_item] items = [];\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);"}, {"sha": "daf52f7fbdeda08362310009051d447b749991f7", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -299,8 +299,8 @@ fn add_to_index(&ebml::writer ebml_w,\n                 &vec[str] path,\n                 &mutable vec[tup(str, uint)] index,\n                 &str name) {\n-    auto full_path = path + vec(name);\n-    index += vec(tup(_str::connect(full_path, \"::\"), ebml_w.writer.tell()));\n+    auto full_path = path + [name];\n+    index += [tup(_str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n }\n \n fn encode_native_module_item_paths(&ebml::writer ebml_w,\n@@ -353,15 +353,15 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                encode_module_item_paths(ebml_w, _mod, path + vec(id), index);\n+                encode_module_item_paths(ebml_w, _mod, path + [id], index);\n                 ebml::end_tag(ebml_w);\n             }\n             case (ast::item_native_mod(?id, ?nmod, ?did)) {\n                 add_to_index(ebml_w, path, index, id);\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, did);\n-                encode_native_module_item_paths(ebml_w, nmod, path + vec(id),\n+                encode_native_module_item_paths(ebml_w, nmod, path + [id],\n                                                 index);\n                 ebml::end_tag(ebml_w);\n             }\n@@ -400,8 +400,8 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n \n fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate)\n         -> vec[tup(str, uint)] {\n-    let vec[tup(str, uint)] index = vec();\n-    let vec[str] path = vec();\n+    let vec[tup(str, uint)] index = [];\n+    let vec[str] path = [];\n     ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n     ebml::end_tag(ebml_w);\n@@ -413,7 +413,7 @@ fn encode_item_paths(&ebml::writer ebml_w, &@ast::crate crate)\n \n fn encode_kind(&ebml::writer ebml_w, u8 c) {\n     ebml::start_tag(ebml_w, tag_items_data_item_kind);\n-    ebml_w.writer.write(vec(c));\n+    ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n@@ -470,7 +470,7 @@ fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                            &mutable vec[tup(int, uint)] index,\n                            &vec[ast::ty_param] ty_params) {\n     for (ast::variant variant in variants) {\n-        index += vec(tup(variant.node.id._1, ebml_w.writer.tell()));\n+        index += [tup(variant.node.id._1, ebml_w.writer.tell())];\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n@@ -549,7 +549,7 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n             encode_symbol(cx, ebml_w, odid.ctor);\n             ebml::end_tag(ebml_w);\n \n-            index += vec(tup(odid.ty._1, ebml_w.writer.tell()));\n+            index += [tup(odid.ty._1, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n@@ -582,16 +582,16 @@ fn encode_info_for_native_item(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n \n fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w)\n         -> vec[tup(int, uint)] {\n-    let vec[tup(int, uint)] index = vec();\n+    let vec[tup(int, uint)] index = [];\n \n     ebml::start_tag(ebml_w, tag_items_data);\n     for each (@tup(ast::def_id, @ast::item) kvp in cx.items.items()) {\n-        index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n+        index += [tup(kvp._0._1, ebml_w.writer.tell())];\n         encode_info_for_item(cx, ebml_w, kvp._1, index);\n     }\n     for each (@tup(ast::def_id, @ast::native_item) kvp in\n             cx.native_items.items()) {\n-        index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n+        index += [tup(kvp._0._1, ebml_w.writer.tell())];\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n     ebml::end_tag(ebml_w);\n@@ -618,15 +618,15 @@ fn hash_path(&str s) -> uint {\n \n fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n-    let vec[vec[tup(T, uint)]] buckets = vec();\n+    let vec[vec[tup(T, uint)]] buckets = [];\n     for each (uint i in _uint::range(0u, 256u)) {\n-        let vec[tup(T, uint)] bucket = vec();\n-        buckets += vec(bucket);\n+        let vec[tup(T, uint)] bucket = [];\n+        buckets += [bucket];\n     }\n \n     for (tup(T, uint) elt in index) {\n         auto h = hash_fn(elt._0);\n-        buckets.(h % 256u) += vec(elt);\n+        buckets.(h % 256u) += [elt];\n     }\n \n     ret buckets;\n@@ -638,10 +638,10 @@ fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n \n     ebml::start_tag(ebml_w, tag_index);\n \n-    let vec[uint] bucket_locs = vec();\n+    let vec[uint] bucket_locs = [];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n     for (vec[tup(T, uint)] bucket in buckets) {\n-        bucket_locs += vec(ebml_w.writer.tell());\n+        bucket_locs += [ebml_w.writer.tell()];\n \n         ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n         for (tup(T, uint) elt in bucket) {\n@@ -698,7 +698,7 @@ fn encode_metadata(&@trans::crate_ctxt cx, &@ast::crate crate)\n \n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n-    buf_w.write(vec(0u8, 0u8, 0u8, 0u8));\n+    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n \n     ret C_postr(string_w.get_str());\n }\n@@ -709,7 +709,7 @@ fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n         llmeta = encode_metadata(cx, crate);\n     }\n \n-    auto llconst = trans::C_struct(vec(llmeta));\n+    auto llconst = trans::C_struct([llmeta]);\n     auto llglobal = llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n                                        _str::buf(\"rust_metadata\"));\n     llvm::LLVMSetInitializer(llglobal, llconst);"}, {"sha": "07667e114fa72c5053db62419d84495665841663", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -253,7 +253,7 @@ fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n }\n \n fn push_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n-    let vec[ast::ty_param] tp = vec();\n+    let vec[ast::ty_param] tp = [];\n     let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n                                               m.node.meth,\n                                               tp,\n@@ -686,7 +686,7 @@ fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n     if (defid._0 != ast::local_crate) { // Not in this crate\n         auto cached = e.ext_cache.find(tup(defid,id,ns));\n         if (!option::is_none(cached)) { ret cached; }\n-        auto path = vec(id);\n+        auto path = [id];\n         if (defid._1 != -1) {\n             path = e.ext_map.get(defid) + path;\n         }"}, {"sha": "4c9f170ecd44cae8a6a5a9ecbe91190ded2940eb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 464, "deletions": 464, "changes": 928, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54"}, {"sha": "ee02a21ace327647fe0026a1ca8142f408cec01c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -420,9 +420,9 @@ fn mk_tup(&ctxt cx, &vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n     // TODO: map\n-    let vec[ty::mt] mts = vec();\n+    let vec[ty::mt] mts = [];\n     for (t typ in tys) {\n-        mts += vec(rec(ty=typ, mut=ast::imm));\n+        mts += [rec(ty=typ, mut=ast::imm)];\n     }\n     ret mk_tup(cx, mts);\n }\n@@ -625,12 +625,12 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         }\n \n         case (ty_param(?id)) {\n-            s += \"'\" + _str::unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n+            s += \"'\" + _str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n \n         case (ty_bound_param(?id)) {\n-            s += \"''\" + _str::unsafe_from_bytes(vec(('a' as u8) +\n-                                                    (id as u8)));\n+            s += \"''\" + _str::unsafe_from_bytes([('a' as u8) +\n+                                                    (id as u8)]);\n         }\n     }\n \n@@ -693,7 +693,7 @@ fn walk_ty(ctxt cx, ty_walk walker, t ty) {\n             walk_ty(cx, walker, ret_ty);\n         }\n         case (ty_obj(?methods)) {\n-            let vec[method] new_methods = vec();\n+            let vec[method] new_methods = [];\n             for (method m in methods) {\n                 for (arg a in m.inputs) {\n                     walk_ty(cx, walker, a.ty);\n@@ -740,58 +740,58 @@ fn fold_ty(ctxt cx, ty_fold fld, t ty_0) -> t {\n             ty = copy_cname(cx, mk_chan(cx, fold_ty(cx, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n-            let vec[t] new_subtys = vec();\n+            let vec[t] new_subtys = [];\n             for (t subty in subtys) {\n-                new_subtys += vec(fold_ty(cx, fld, subty));\n+                new_subtys += [fold_ty(cx, fld, subty)];\n             }\n             ty = copy_cname(cx, mk_tag(cx, tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n-            let vec[mt] new_mts = vec();\n+            let vec[mt] new_mts = [];\n             for (mt tm in mts) {\n                 auto new_subty = fold_ty(cx, fld, tm.ty);\n-                new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n+                new_mts += [rec(ty=new_subty, mut=tm.mut)];\n             }\n             ty = copy_cname(cx, mk_tup(cx, new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n-            let vec[field] new_fields = vec();\n+            let vec[field] new_fields = [];\n             for (field fl in fields) {\n                 auto new_ty = fold_ty(cx, fld, fl.mt.ty);\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n-                new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n+                new_fields += [rec(ident=fl.ident, mt=new_mt)];\n             }\n             ty = copy_cname(cx, mk_rec(cx, new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n-            let vec[arg] new_args = vec();\n+            let vec[arg] new_args = [];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n-                new_args += vec(rec(mode=a.mode, ty=new_ty));\n+                new_args += [rec(mode=a.mode, ty=new_ty)];\n             }\n             ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n                                       fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n-            let vec[arg] new_args = vec();\n+            let vec[arg] new_args = [];\n             for (arg a in args) {\n                 auto new_ty = fold_ty(cx, fld, a.ty);\n-                new_args += vec(rec(mode=a.mode, ty=new_ty));\n+                new_args += [rec(mode=a.mode, ty=new_ty)];\n             }\n             ty = copy_cname(cx, mk_native_fn(cx, abi, new_args,\n                                              fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_obj(?methods)) {\n-            let vec[method] new_methods = vec();\n+            let vec[method] new_methods = [];\n             for (method m in methods) {\n-                let vec[arg] new_args = vec();\n+                let vec[arg] new_args = [];\n                 for (arg a in m.inputs) {\n-                    new_args += vec(rec(mode=a.mode,\n-                                        ty=fold_ty(cx, fld, a.ty)));\n+                    new_args += [rec(mode=a.mode,\n+                                        ty=fold_ty(cx, fld, a.ty))];\n                 }\n-                new_methods += vec(rec(proto=m.proto, ident=m.ident,\n+                new_methods += [rec(proto=m.proto, ident=m.ident,\n                                        inputs=new_args,\n-                                       output=fold_ty(cx, fld, m.output)));\n+                                       output=fold_ty(cx, fld, m.output))];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n@@ -1443,7 +1443,7 @@ fn ann_to_type(&node_type_table ntt, &ast::ann ann) -> t {\n fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     alt (ann_to_ty_param_substs_opt_and_ty(ntt, ann)._0) {\n         case (none[vec[t]]) {\n-            let vec[t] result = vec();\n+            let vec[t] result = [];\n             ret result;\n         }\n         case (some[vec[t]](?tps)) { ret tps; }\n@@ -1492,14 +1492,14 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n                     }\n                 }\n                 if (!seen) {\n-                    *param_indices += vec(param_idx);\n+                    *param_indices += [param_idx];\n                 }\n             }\n             case (_) { /* fall through */ }\n         }\n     }\n \n-    let vec[uint] v = vec();    // FIXME: typechecker botch\n+    let vec[uint] v = [];    // FIXME: typechecker botch\n     let @mutable vec[uint] param_indices = @mutable v;\n     auto f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n@@ -1873,7 +1873,7 @@ mod unify {\n         }\n \n         // TODO: as above, we should have an iter2 iterator.\n-        let vec[arg] result_ins = vec();\n+        let vec[arg] result_ins = [];\n         auto i = 0u;\n         while (i < expected_len) {\n             auto expected_input = expected_inputs.(i);\n@@ -1897,7 +1897,7 @@ mod unify {\n \n             alt (result) {\n                 case (ures_ok(?rty)) {\n-                    result_ins += vec(rec(mode=result_mode, ty=rty));\n+                    result_ins += [rec(mode=result_mode, ty=rty)];\n                 }\n \n                 case (_) {\n@@ -1979,7 +1979,7 @@ mod unify {\n                  &t actual,\n                  &vec[method] expected_meths,\n                  &vec[method] actual_meths) -> result {\n-      let vec[method] result_meths = vec();\n+      let vec[method] result_meths = [];\n       let uint i = 0u;\n       let uint expected_len = _vec::len[method](expected_meths);\n       let uint actual_len = _vec::len[method](actual_meths);\n@@ -2004,9 +2004,9 @@ mod unify {\n             case (ures_ok(?tfn)) {\n                 alt (struct(cx.tcx, tfn)) {\n                     case (ty_fn(?proto, ?ins, ?out)) {\n-                        result_meths += vec(rec(inputs = ins,\n+                        result_meths += [rec(inputs = ins,\n                                                 output = out\n-                                                with e_meth));\n+                                                with e_meth)];\n                     }\n                 }\n             }\n@@ -2057,10 +2057,10 @@ mod unify {\n                         // Just bind the type variable to the expected type.\n                         auto vlen = _vec::len[vec[t]](cx.types);\n                         if (actual_n < vlen) {\n-                            cx.types.(actual_n) += vec(expected);\n+                            cx.types.(actual_n) += [expected];\n                         } else {\n                             assert (actual_n == vlen);\n-                            cx.types += vec(mutable vec(expected));\n+                            cx.types += [mutable [expected]];\n                         }\n                     }\n                 }\n@@ -2120,7 +2120,7 @@ mod unify {\n \n                         // TODO: factor this cruft out, see the TODO in the\n                         // ty::ty_tup case\n-                        let vec[t] result_tps = vec();\n+                        let vec[t] result_tps = [];\n                         auto i = 0u;\n                         auto expected_len = _vec::len[t](expected_tps);\n                         while (i < expected_len) {\n@@ -2272,7 +2272,7 @@ mod unify {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[ty::mt] result_elems = vec();\n+                        let vec[ty::mt] result_elems = [];\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -2294,7 +2294,7 @@ mod unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    result_elems += vec(mt);\n+                                    result_elems += [mt];\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -2326,7 +2326,7 @@ mod unify {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[field] result_fields = vec();\n+                        let vec[field] result_fields = [];\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_field = expected_fields.(i);\n@@ -2425,10 +2425,10 @@ mod unify {\n                 auto expected_n = get_or_create_set(cx, expected_id);\n                 auto vlen = _vec::len[vec[t]](cx.types);\n                 if (expected_n < vlen) {\n-                    cx.types.(expected_n) += vec(actual);\n+                    cx.types.(expected_n) += [actual];\n                 } else {\n                     assert (expected_n == vlen);\n-                    cx.types += vec(mutable vec(actual));\n+                    cx.types += [mutable [actual]];\n                 }\n                 ret ures_ok(expected);\n             }\n@@ -2485,13 +2485,13 @@ mod unify {\n     }\n \n     fn unify_sets(&@ctxt cx) -> vec[t] {\n-        let vec[t] throwaway = vec();\n-        let vec[mutable vec[t]] set_types = vec(mutable throwaway);\n+        let vec[t] throwaway = [];\n+        let vec[mutable vec[t]] set_types = [mutable throwaway];\n         _vec::pop[vec[t]](set_types);   // FIXME: botch\n \n         for (ufind::node node in cx.sets.nodes) {\n-            let vec[t] v = vec();\n-            set_types += vec(mutable v);\n+            let vec[t] v = [];\n+            set_types += [mutable v];\n         }\n \n         auto i = 0u;\n@@ -2501,14 +2501,14 @@ mod unify {\n             i += 1u;\n         }\n \n-        let vec[t] result = vec();\n+        let vec[t] result = [];\n         for (vec[t] types in set_types) {\n             if (_vec::len[t](types) > 1u) {\n                 log_err \"unification of > 1 types in a type set is \" +\n                     \"unimplemented\";\n                 fail;\n             }\n-            result += vec(types.(0));\n+            result += [types.(0)];\n         }\n \n         ret result;\n@@ -2518,8 +2518,8 @@ mod unify {\n              &t actual,\n              &unify_handler handler,\n              &ty_ctxt tcx) -> result {\n-        let vec[t] throwaway = vec();\n-        let vec[mutable vec[t]] types = vec(mutable throwaway);\n+        let vec[t] throwaway = [];\n+        let vec[mutable vec[t]] types = [mutable throwaway];\n         _vec::pop[vec[t]](types);   // FIXME: botch\n \n         auto cx = @rec(sets=ufind::make(),"}, {"sha": "d9c144f3fbfb9bcadabbdf8ef9335de4c06352ed", "filename": "src/comp/middle/type_glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftype_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftype_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftype_glue.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -37,17 +37,17 @@ fn rc_shape_of(&ty::ctxt tcx, variant_getter getter, ty::t t) -> rc_shape {\n         case (ty::ty_char) { ret rs_none; }\n         case (ty::ty_str) { ret rs_none; }\n         case (ty::ty_tag(?did, ?params)) {\n-            let vec[vec[@rc_shape]] result = vec();\n+            let vec[vec[@rc_shape]] result = [];\n \n             auto vinfos = getter(did);\n             for (variant_info vinfo in vinfos) {\n-                let vec[@rc_shape] variant_rcs = vec();\n+                let vec[@rc_shape] variant_rcs = [];\n                 for (ty::t typ in vinfo.args) {\n                     auto ty_1 = ty::bind_params_in_type(tcx, typ);\n                     ty_1 = ty::substitute_type_params(tcx, params, ty_1);\n-                    variant_rcs += vec(@rc_shape_of(tcx, getter, ty_1));\n+                    variant_rcs += [@rc_shape_of(tcx, getter, ty_1)];\n                 }\n-                result += vec(variant_rcs);\n+                result += [variant_rcs];\n             }\n \n             ret rs_tag(result);\n@@ -58,16 +58,16 @@ fn rc_shape_of(&ty::ctxt tcx, variant_getter getter, ty::t t) -> rc_shape {\n         case (ty::ty_chan(_)) { ret rs_ref; }\n         case (ty::ty_task) { ret rs_ref; }\n         case (ty::ty_tup(?mts)) {\n-            let vec[@rc_shape] result = vec();\n+            let vec[@rc_shape] result = [];\n             for (ty::mt tm in mts) {\n-                result += vec(@rc_shape_of(tcx, getter, tm.ty));\n+                result += [@rc_shape_of(tcx, getter, tm.ty)];\n             }\n             ret rs_tup(result);\n         }\n         case (ty::ty_rec(?fields)) {\n-            let vec[@rc_shape] result = vec();\n+            let vec[@rc_shape] result = [];\n             for (ty::field fld in fields) {\n-                result += vec(@rc_shape_of(tcx, getter, fld.mt.ty));\n+                result += [@rc_shape_of(tcx, getter, fld.mt.ty)];\n             }\n             ret rs_tup(result);\n         }"}, {"sha": "42a06d398fd5ee541eba3ab622c79b0cb0950502", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -188,10 +188,10 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     auto ty_substs_opt;\n     auto ty_substs_len = _vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n-        let vec[ty::t] ty_substs = vec();\n+        let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_substs_len) {\n-            ty_substs += vec(ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i)));\n+            ty_substs += [ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i))];\n             i += 1u;\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n@@ -203,10 +203,10 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n-        let vec[ty::t] ty_substs = vec();\n+        let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            ty_substs += vec(next_ty_var(fcx.ccx));\n+            ty_substs += [next_ty_var(fcx.ccx)];\n             i += 1u;\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n@@ -259,9 +259,9 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         // TODO: Make sure the number of supplied bindings matches the number\n         // of type parameters in the typedef. Emit a friendly error otherwise.\n         auto bound_ty = bind_params_in_type(tcx, params_opt_and_ty._1);\n-        let vec[ty::t] param_bindings = vec();\n+        let vec[ty::t] param_bindings = [];\n         for (@ast::ty ast_ty in args) {\n-            param_bindings += vec(ast_ty_to_ty(tcx, getter, ast_ty));\n+            param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n         ret ty::substitute_type_params(tcx, param_bindings, bound_ty);\n     }\n@@ -294,14 +294,14 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         }\n \n         case (ast::ty_tup(?fields)) {\n-            let vec[ty::mt] flds = vec();\n+            let vec[ty::mt] flds = [];\n             for (ast::mt field in fields) {\n                 _vec::push[ty::mt](flds, ast_mt_to_mt(tcx, getter, field));\n             }\n             typ = ty::mk_tup(tcx, flds);\n         }\n         case (ast::ty_rec(?fields)) {\n-            let vec[field] flds = vec();\n+            let vec[field] flds = [];\n             for (ast::ty_field f in fields) {\n                 auto tm = ast_mt_to_mt(tcx, getter, f.mt);\n                 _vec::push[field](flds, rec(ident=f.ident, mt=tm));\n@@ -336,7 +336,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         }\n \n         case (ast::ty_obj(?meths)) {\n-            let vec[ty::method] tmeths = vec();\n+            let vec[ty::method] tmeths = [];\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             for (ast::ty_method m in meths) {\n                 auto ins = _vec::map[ast::ty_arg, arg](f, m.inputs);\n@@ -502,7 +502,7 @@ mod collect {\n             -> ty::ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n \n-        let vec[arg] t_inputs = vec();\n+        let vec[arg] t_inputs = [];\n         for (ast::obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n@@ -561,11 +561,11 @@ mod collect {\n \n             case (ast::item_tag(_, _, ?tps, ?def_id, _)) {\n                 // Create a new generic polytype.\n-                let vec[ty::t] subtys = vec();\n+                let vec[ty::t] subtys = [];\n \n                 auto i = 0u;\n                 for (ast::ty_param tp in tps) {\n-                    subtys += vec(ty::mk_param(cx.tcx, i));\n+                    subtys += [ty::mk_param(cx.tcx, i)];\n                     i += 1u;\n                 }\n \n@@ -613,13 +613,13 @@ mod collect {\n                              &vec[ast::variant] variants,\n                              &vec[ast::ty_param] ty_params)\n             -> vec[ast::variant] {\n-        let vec[ast::variant] result = vec();\n+        let vec[ast::variant] result = [];\n \n         // Create a set of parameter types shared among all the variants.\n-        let vec[ty::t] ty_param_tys = vec();\n+        let vec[ty::t] ty_param_tys = [];\n         auto i = 0u;\n         for (ast::ty_param tp in ty_params) {\n-            ty_param_tys += vec(ty::mk_param(cx.tcx, i));\n+            ty_param_tys += [ty::mk_param(cx.tcx, i)];\n             i += 1u;\n         }\n \n@@ -636,10 +636,10 @@ mod collect {\n                 // should be called to resolve named types.\n                 auto f = bind getter(cx, _);\n \n-                let vec[arg] args = vec();\n+                let vec[arg] args = [];\n                 for (ast::variant_arg va in variant.node.args) {\n                     auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += vec(rec(mode=ty::mo_alias, ty=arg_ty));\n+                    args += [rec(mode=ty::mo_alias, ty=arg_ty)];\n                 }\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t);\n@@ -653,7 +653,7 @@ mod collect {\n             );\n             write_type_only(cx.node_types, ast::ann_tag(variant.node.ann),\n                             result_ty);\n-            result += vec(fold::respan(variant.span, variant_t));\n+            result += [fold::respan(variant.span, variant_t)];\n         }\n \n         ret result;\n@@ -750,7 +750,7 @@ mod collect {\n                     case (none[@ast::method]) { /* nothing to do */ }\n                     case (some[@ast::method](?m)) {\n                         // TODO: typechecker botch\n-                        let vec[arg] no_args = vec();\n+                        let vec[arg] no_args = [];\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, no_args,\n                                            ty::mk_nil(cx.tcx));\n                         write_type_only(cx.node_types,\n@@ -795,7 +795,7 @@ mod collect {\n         auto id_to_ty_item = @common::new_def_hash[any_item]();\n \n         let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n-            vec(mutable);\n+            [mutable];\n         let node_type_table ntt = @mutable ntt_sub;\n \n         auto visit = rec(\n@@ -837,7 +837,7 @@ mod unify {\n               &ty::t actual) -> ty::unify::result {\n         // FIXME: horrid botch\n         let vec[mutable ty::t] param_substs =\n-            vec(mutable ty::mk_nil(fcx.ccx.tcx));\n+            [mutable ty::mk_nil(fcx.ccx.tcx)];\n         _vec::pop(param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n@@ -884,9 +884,9 @@ mod unify {\n                 }\n \n                 // TODO: \"freeze\"\n-                let vec[ty::t] param_substs_1 = vec();\n+                let vec[ty::t] param_substs_1 = [];\n                 for (ty::t subst in param_substs) {\n-                    param_substs_1 += vec(subst);\n+                    param_substs_1 += [subst];\n                 }\n \n                 unified_type =\n@@ -968,13 +968,13 @@ type ty_param_substs_and_ty = tup(vec[ty::t], ty::t);\n mod Demand {\n     fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual)\n         -> ty::t {\n-        let vec[ty::t] tps = vec();\n+        let vec[ty::t] tps = [];\n         ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n     }\n \n     fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n-        let vec[ty::t] tps = vec();\n+        let vec[ty::t] tps = [];\n         ret full(fcx, sp, expected, actual, tps, adk)._1;\n     }\n \n@@ -996,18 +996,18 @@ mod Demand {\n         }\n \n         let vec[mutable ty::t] ty_param_substs =\n-            vec(mutable ty::mk_nil(fcx.ccx.tcx));\n+            [mutable ty::mk_nil(fcx.ccx.tcx)];\n         _vec::pop(ty_param_substs);   // FIXME: horrid botch\n         for (ty::t ty_param_subst in ty_param_substs_0) {\n-            ty_param_substs += vec(mutable ty_param_subst);\n+            ty_param_substs += [mutable ty_param_subst];\n         }\n \n         alt (unify::with_params(fcx, expected_1, actual_1, ty_param_substs)) {\n             case (ures_ok(?t)) {\n                 // TODO: Use \"freeze\", when we have it.\n-                let vec[ty::t] result_ty_param_substs = vec();\n+                let vec[ty::t] result_ty_param_substs = [];\n                 for (ty::t ty_param_subst in ty_param_substs) {\n-                    result_ty_param_substs += vec(ty_param_subst);\n+                    result_ty_param_substs += [ty_param_subst];\n                 }\n \n                 ret tup(result_ty_param_substs,\n@@ -1042,7 +1042,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                      &vec[ty::t] tag_ty_params) -> vec[ty::t] {\n     auto ty_param_count = _vec::len[ty::t](tag_ty_params);\n \n-    let vec[ty::t] result = vec();\n+    let vec[ty::t] result = [];\n \n     auto tpt = ty::lookup_item_type(ccx.sess, ccx.tcx, ccx.type_cache, vid);\n     alt (struct(ccx.tcx, tpt._1)) {\n@@ -1052,7 +1052,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                 auto arg_ty = bind_params_in_type(ccx.tcx, arg.ty);\n                 arg_ty = substitute_ty_params(ccx, arg_ty, ty_param_count,\n                                               tag_ty_params, sp);\n-                result += vec(arg_ty);\n+                result += [arg_ty];\n             }\n         }\n         case (_) {\n@@ -1163,11 +1163,11 @@ mod Pushdown {\n \n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[@ast::expr] es_1 = vec();\n+                let vec[@ast::expr] es_1 = [];\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n                         for (@ast::expr e_0 in es_0) {\n-                            es_1 += vec(pushdown_expr(fcx, mt.ty, e_0));\n+                            es_1 += [pushdown_expr(fcx, mt.ty, e_0)];\n                         }\n                     }\n                     case (_) {\n@@ -1182,14 +1182,14 @@ mod Pushdown {\n             case (ast::expr_tup(?es_0, ?ann)) {\n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[ast::elt] elts_1 = vec();\n+                let vec[ast::elt] elts_1 = [];\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast::elt elt_0 in es_0) {\n                             auto e_1 = pushdown_expr(fcx, mts.(i).ty,\n                                                      elt_0.expr);\n-                            elts_1 += vec(rec(mut=elt_0.mut, expr=e_1));\n+                            elts_1 += [rec(mut=elt_0.mut, expr=e_1)];\n                             i += 1u;\n                         }\n                     }\n@@ -1207,7 +1207,7 @@ mod Pushdown {\n \n                 auto t = Demand::simple(fcx, e.span, expected,\n                                        ann_to_type(fcx.ccx.node_types, ann));\n-                let vec[ast::field] fields_1 = vec();\n+                let vec[ast::field] fields_1 = [];\n                 alt (struct(fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n@@ -1220,9 +1220,9 @@ mod Pushdown {\n                                         pushdown_expr(fcx,\n                                                       field_mts.(i).mt.ty,\n                                                       field_0.expr);\n-                                    fields_1 += vec(rec(mut=field_0.mut,\n+                                    fields_1 += [rec(mut=field_0.mut,\n                                                         ident=field_0.ident,\n-                                                        expr=e_1));\n+                                                        expr=e_1)];\n                                     i += 1u;\n                                 }\n                             }\n@@ -1231,7 +1231,7 @@ mod Pushdown {\n                                 base_1 = some[@ast::expr]\n                                     (pushdown_expr(fcx, t, bx));\n \n-                                let vec[field] base_fields = vec();\n+                                let vec[field] base_fields = [];\n \n                                 for (ast::field field_0 in fields_0) {\n \n@@ -1242,9 +1242,9 @@ mod Pushdown {\n                                                 pushdown_expr(fcx, ft.mt.ty,\n                                                               field_0.expr);\n                                             fields_1 +=\n-                                                vec(rec(mut=field_0.mut,\n+                                                [rec(mut=field_0.mut,\n                                                         ident=field_0.ident,\n-                                                        expr=e_1));\n+                                                        expr=e_1)];\n                                         }\n                                     }\n                                 }\n@@ -1479,13 +1479,13 @@ mod Pushdown {\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n                 auto t = expected;\n-                let vec[ast::arm] arms_1 = vec();\n+                let vec[ast::arm] arms_1 = [];\n                 for (ast::arm arm_0 in arms_0) {\n                     auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n                     t = Demand::simple(fcx, e.span, t,\n                         block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_1));\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n-                    arms_1 += vec(arm_1);\n+                    arms_1 += [arm_1];\n                 }\n                 e_1 = ast::expr_alt(discrim, arms_1,\n                                     triv_ann(ast::ann_tag(ann), t));\n@@ -1848,21 +1848,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         auto f_0 = check_expr(fcx, f);\n \n         // Check the arguments and generate the argument signature.\n-        let vec[option::t[@ast::expr]] args_0 = vec();\n-        let vec[arg] arg_tys_0 = vec();\n+        let vec[option::t[@ast::expr]] args_0 = [];\n+        let vec[arg] arg_tys_0 = [];\n         for (option::t[@ast::expr] a_opt in args) {\n             alt (a_opt) {\n                 case (some[@ast::expr](?a)) {\n                     auto a_0 = check_expr(fcx, a);\n-                    args_0 += vec(some[@ast::expr](a_0));\n+                    args_0 += [some[@ast::expr](a_0)];\n \n                     auto arg_ty = rec(mode=mo_either,\n                                       ty=expr_ty(fcx.ccx.tcx,\n                                                  fcx.ccx.node_types, a_0));\n                     _vec::push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast::expr]) {\n-                    args_0 += vec(none[@ast::expr]);\n+                    args_0 += [none[@ast::expr]];\n \n                     auto typ = next_ty_var(fcx.ccx);\n                     _vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n@@ -1920,18 +1920,18 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n     fn check_call(&@fn_ctxt fcx, &@ast::expr f, &vec[@ast::expr] args)\n         -> tup(@ast::expr, vec[@ast::expr]) {\n \n-        let vec[option::t[@ast::expr]] args_opt_0 = vec();\n+        let vec[option::t[@ast::expr]] args_opt_0 = [];\n         for (@ast::expr arg in args) {\n-            args_opt_0 += vec(some[@ast::expr](arg));\n+            args_opt_0 += [some[@ast::expr](arg)];\n         }\n \n         // Call the generic checker.\n         auto result = check_call_or_bind(fcx, f, args_opt_0);\n \n         // Pull out the arguments.\n-        let vec[@ast::expr] args_1 = vec();\n+        let vec[@ast::expr] args_1 = [];\n         for (option::t[@ast::expr] arg in result._1) {\n-            args_1 += vec(option::get[@ast::expr](arg));\n+            args_1 += [option::get[@ast::expr](arg)];\n         }\n \n         ret tup(result._0, args_1);\n@@ -2397,12 +2397,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_0);\n \n-            let vec[@ast::pat] pats = vec();\n+            let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n                 check_pat(fcx, arm.pat);\n                 pattern_ty = Demand::simple(fcx, arm.pat.span, pattern_ty,\n                     pat_ty(fcx.ccx.tcx, fcx.ccx.node_types, arm.pat));\n-                pats += vec(arm.pat);\n+                pats += [arm.pat];\n             }\n \n             for (@ast::pat pat in pats) {\n@@ -2412,23 +2412,23 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             // Now typecheck the blocks.\n             auto result_ty = next_ty_var(fcx.ccx);\n \n-            let vec[ast::block] blocks_0 = vec();\n+            let vec[ast::block] blocks_0 = [];\n             for (ast::arm arm in arms) {\n                 auto block_0 = check_block(fcx, arm.block);\n                 result_ty = Demand::simple(fcx, block_0.span, result_ty,\n                     block_ty(fcx.ccx.tcx, fcx.ccx.node_types, block_0));\n-                blocks_0 += vec(block_0);\n+                blocks_0 += [block_0];\n             }\n \n-            let vec[ast::arm] arms_1 = vec();\n+            let vec[ast::arm] arms_1 = [];\n             auto i = 0u;\n             for (ast::block block_0 in blocks_0) {\n                 auto block_1 = Pushdown::pushdown_block(fcx, result_ty,\n                                                        block_0);\n                 auto pat = pats.(i);\n                 auto arm = arms.(i);\n                 auto arm_1 = rec(pat=pat, block=block_1);\n-                arms_1 += vec(arm_1);\n+                arms_1 += [arm_1];\n                 i += 1u;\n             }\n \n@@ -2464,7 +2464,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // Pull the argument and return types out.\n             auto proto_1;\n-            let vec[ty::arg] arg_tys_1 = vec();\n+            let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n             alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                              result._0))) {\n@@ -2479,7 +2479,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                         alt (args.(i)) {\n                             case (some[@ast::expr](_)) { /* no-op */ }\n                             case (none[@ast::expr]) {\n-                                arg_tys_1 += vec(arg_tys.(i));\n+                                arg_tys_1 += [arg_tys.(i)];\n                             }\n                         }\n                         i += 1u;\n@@ -2624,7 +2624,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         case (ast::expr_vec(?args, ?mut, ?a)) {\n-            let vec[@ast::expr] args_1 = vec();\n+            let vec[@ast::expr] args_1 = [];\n \n             let ty::t t;\n             if (_vec::len[@ast::expr](args) == 0u) {\n@@ -2650,15 +2650,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         case (ast::expr_tup(?elts, ?a)) {\n-            let vec[ast::elt] elts_1 = vec();\n-            let vec[ty::mt] elts_mt = vec();\n+            let vec[ast::elt] elts_1 = [];\n+            let vec[ty::mt] elts_mt = [];\n \n             for (ast::elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_1);\n                 _vec::push[ast::elt](elts_1, rec(expr=expr_1 with e));\n-                elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n+                elts_mt += [rec(ty=expr_t, mut=e.mut)];\n             }\n \n             auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n@@ -2678,8 +2678,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 }\n             }\n \n-            let vec[ast::field] fields_1 = vec();\n-            let vec[field] fields_t = vec();\n+            let vec[ast::field] fields_1 = [];\n+            let vec[field] fields_t = [];\n \n             for (ast::field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n@@ -2705,7 +2705,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto bexpr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                            bexpr_1);\n \n-                    let vec[field] base_fields = vec();\n+                    let vec[field] base_fields = [];\n \n                     alt (struct(fcx.ccx.tcx, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) {\n@@ -3000,7 +3000,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n }\n \n fn check_block(&@fn_ctxt fcx, &ast::block block) -> ast::block {\n-    let vec[@ast::stmt] stmts = vec();\n+    let vec[@ast::stmt] stmts = [];\n     for (@ast::stmt s in block.node.stmts) {\n         _vec::push[@ast::stmt](stmts, check_stmt(fcx, s));\n     }\n@@ -3093,10 +3093,10 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast::ident ident, &ast::_fn f,\n     // and return type translated to typeck::ty values. We don't need do to it\n     // again here, we can extract them.\n \n-    let vec[arg] inputs = vec();\n+    let vec[arg] inputs = [];\n     for (ast::arg arg in f.decl.inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n-        inputs += vec(rec(mode=ast_mode_to_mode(arg.mode), ty=input_ty));\n+        inputs += [rec(mode=ast_mode_to_mode(arg.mode), ty=input_ty)];\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n@@ -3182,7 +3182,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n     auto sess = tcx.sess;\n     auto result = collect::collect_item_types(sess, tcx, crate);\n \n-    let vec[ast::obj_field] fields = vec();\n+    let vec[ast::obj_field] fields = [];\n \n     auto hasher = hash_unify_cache_entry;\n     auto eqer = eq_unify_cache_entry;"}, {"sha": "4e89863e43f3d3019ee7f6eb87865910050601a0", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -797,10 +797,10 @@ fn find_pre_post_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     find_pre_post_expr(dm, fm, enclosing, index);\n     find_pre_post_block(dm, fm, enclosing, body);\n     auto loop_precond = declare_var(enclosing, decl_lhs(d),\n-           seq_preconds(enclosing, vec(expr_pp(index),\n-                                       block_pp(body))));\n+           seq_preconds(enclosing, [expr_pp(index),\n+                                       block_pp(body)]));\n     auto loop_postcond = intersect_postconds\n-        (vec(expr_postcond(index), block_postcond(body)));\n+        ([expr_postcond(index), block_postcond(body)]);\n     set_pre_and_post(a, rec(precondition=loop_precond,\n                             postcondition=loop_postcond));\n }\n@@ -897,7 +897,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             }\n             // doesn't check that lhs is an lval, but\n             // that's probably ok\n-            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n         }\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n@@ -918,12 +918,12 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             }\n             // doesn't check that lhs is an lval, but\n             // that's probably ok\n-            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n         }\n         case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n-            find_pre_post_exprs(dm, fm, enclosing, vec(lhs, rhs), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [lhs, rhs], a);\n         }\n         case (expr_lit(_,?a)) {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n@@ -955,8 +955,8 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n                     auto precond_res = seq_preconds(enclosing,\n-                                                    vec(expr_pp(antec),\n-                                                        block_pp(conseq)));\n+                                                    [expr_pp(antec),\n+                                                        block_pp(conseq)]);\n                     set_pre_and_post(a, rec(precondition=precond_res,\n                                             postcondition=\n                                             expr_poststate(antec)));\n@@ -965,21 +965,21 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                     find_pre_post_expr(dm, fm, enclosing, altern);\n                     auto precond_true_case =\n                         seq_preconds(enclosing,\n-                                     vec(expr_pp(antec), block_pp(conseq)));\n+                                     [expr_pp(antec), block_pp(conseq)]);\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(antec), block_postcond(conseq)));\n+                         [expr_postcond(antec), block_postcond(conseq)]);\n                     auto precond_false_case = seq_preconds\n                         (enclosing,\n-                         vec(expr_pp(antec), expr_pp(altern)));\n+                         [expr_pp(antec), expr_pp(altern)]);\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(antec), expr_postcond(altern)));\n+                         [expr_postcond(antec), expr_postcond(altern)]);\n                     auto precond_res = union_postconds\n                         (num_local_vars,\n-                         vec(precond_true_case, precond_false_case));\n+                         [precond_true_case, precond_false_case]);\n                     auto postcond_res = intersect_postconds\n-                        (vec(postcond_true_case, postcond_false_case));\n+                        ([postcond_true_case, postcond_false_case]);\n                     set_pre_and_post(a, rec(precondition=precond_res,\n                                             postcondition=postcond_res));\n                 }\n@@ -988,10 +988,10 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         case (expr_binary(?bop,?l,?r,?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n              FIXME */\n-            find_pre_post_exprs(dm, fm, enclosing, vec(l, r), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [l, r], a);\n         }\n         case (expr_send(?l, ?r, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, vec(l, r), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [l, r], a);\n         }\n         case (expr_unary(_,?operand,?a)) {\n             find_pre_post_expr(dm, fm, enclosing, operand);\n@@ -1007,18 +1007,18 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             set_pre_and_post(a,\n               rec(precondition=\n                   seq_preconds(enclosing,\n-                                 vec(expr_pp(test), \n-                                     block_pp(body))),\n+                                 [expr_pp(test), \n+                                     block_pp(body)]),\n                   postcondition=\n-                  intersect_postconds(vec(expr_postcond(test),\n-                                          block_postcond(body)))));\n+                  intersect_postconds([expr_postcond(test),\n+                                          block_postcond(body)])));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             find_pre_post_block(dm, fm, enclosing, body);\n             find_pre_post_expr(dm, fm, enclosing, test);\n    \n             auto loop_postcond = union_postconds(num_local_vars,\n-                            vec(block_postcond(body), expr_postcond(test)));\n+                            [block_postcond(body), expr_postcond(test)]);\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n             if (has_nonlocal_exits(body)) {\n@@ -1027,8 +1027,8 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n             set_pre_and_post(a, \n                              rec(precondition=seq_preconds(enclosing,\n-                                             vec(block_pp(body),\n-                                                 expr_pp(test))),\n+                                             [block_pp(body),\n+                                                 expr_pp(test)]),\n                    postcondition=loop_postcond));\n         }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n@@ -1038,7 +1038,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             find_pre_post_loop(dm, fm, enclosing, d, index, body, a);\n         }\n         case (expr_index(?e, ?sub, ?a)) {\n-            find_pre_post_exprs(dm, fm, enclosing, vec(e, sub), a);\n+            find_pre_post_exprs(dm, fm, enclosing, [e, sub], a);\n         }\n         case (expr_alt(?e, ?alts, ?a)) {\n             find_pre_post_expr(dm, fm, enclosing, e);\n@@ -1053,7 +1053,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n                 union(pp.precondition, seq_preconds(enclosing,\n-                                         vec(antec, next)));\n+                                         [antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n@@ -1214,7 +1214,7 @@ fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     auto do_inner = bind do_inner_(dm, fm, enclosing, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n \n-    let vec[pre_and_post] pps = vec();\n+    let vec[pre_and_post] pps = [];\n \n     fn get_pp_stmt(&@stmt s) -> pre_and_post {\n         ret stmt_pp(*s);\n@@ -1408,8 +1408,8 @@ fn find_pre_post_state_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n        (poststate of index, poststate of body) */\n     changed = find_pre_post_state_block(dm, fm, enclosing,\n                 expr_poststate(index), body) || changed;\n-    auto res_p = intersect_postconds(vec(expr_poststate(index),\n-                                         block_poststate(body)));\n+    auto res_p = intersect_postconds([expr_poststate(index),\n+                                         block_poststate(body)]);\n   \n     changed = extend_poststate_ann(a, res_p) || changed;\n     ret changed;\n@@ -1603,7 +1603,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr(dm, fm, enclosing,\n                    expr_poststate(antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n-                    (vec(block_poststate(conseq), expr_poststate(altern)));\n+                    ([block_poststate(conseq), expr_poststate(altern)]);\n                 changed = extend_poststate_ann(a, poststate_res) || changed;\n             }\n         }\n@@ -1660,8 +1660,8 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_block(dm, fm, \n                    enclosing, expr_poststate(test), body) || changed; \n         changed = extend_poststate_ann(a,\n-                    intersect_postconds(vec(expr_poststate(test),\n-                                        block_poststate(body)))) || changed;\n+                    intersect_postconds([expr_poststate(test),\n+                                        block_poststate(body)])) || changed;\n         ret changed;\n     }\n     case (expr_do_while(?body, ?test, ?a)) {\n@@ -2335,7 +2335,7 @@ fn annotate_stmt(&fn_info_map fm, &@stmt s) -> @stmt {\n     }\n }\n fn annotate_block(&fn_info_map fm, &block b) -> block {\n-    let vec[@stmt] new_stmts = vec();\n+    let vec[@stmt] new_stmts = [];\n \n     for (@stmt s in b.node.stmts) {\n         auto new_s = annotate_stmt(fm, s);\n@@ -2357,7 +2357,7 @@ fn annotate_fn(&fn_info_map fm, &ast::_fn f) -> ast::_fn {\n     ret rec(body=annotate_block(fm, f.body) with f);\n }\n fn annotate_mod(&fn_info_map fm, &ast::_mod m) -> ast::_mod {\n-    let vec[@item] new_items = vec();\n+    let vec[@item] new_items = [];\n \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n@@ -2470,7 +2470,7 @@ fn annotate_item(&fn_info_map fm, &@ast::item item) -> @ast::item {\n }\n \n fn annotate_module(&fn_info_map fm, &ast::_mod module) -> ast::_mod {\n-    let vec[@item] new_items = vec();\n+    let vec[@item] new_items = [];\n \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);"}, {"sha": "45b555439cdae7480d676f35312c866be6cc47b5", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -31,9 +31,9 @@ type ps = @rec(mutable vec[context] context,\n                mutable bool potential_brk);\n \n fn mkstate(io::writer out, uint width) -> ps {\n-  let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n-  let vec[token] buff = vec();\n-  let vec[boxtype] sd = vec();\n+  let vec[context] stack = [rec(tp=cx_v, indent=0u)];\n+  let vec[token] buff = [];\n+  let vec[boxtype] sd = [];\n   ret @rec(mutable context=stack,\n            width=width,\n            out=out,\n@@ -81,7 +81,7 @@ fn direct_token(ps p, token tok) {\n }\n \n fn buffer_token(ps p, token tok) {\n-  p.buffered += vec(tok);\n+  p.buffered += [tok];\n   auto col = p.scancol;\n   p.scancol = col + token_size(tok);\n   if (p.scancol > p.width) {\n@@ -140,13 +140,13 @@ fn finish_scan(ps p, bool fits) {\n       push_context(p, cx_h, base_indent(p) + ind);\n     }\n   }\n-  p.scandepth = vec();\n+  p.scandepth = [];\n   p.scanning = scan_none;\n   for (token t in buf) { add_token(p, t); }\n }\n \n fn start_scan(ps p, token tok, scantype tp) {\n-  p.buffered = vec();\n+  p.buffered = [];\n   p.scancol = p.col;\n   p.scanning = tp;\n   buffer_token(p, tok);"}, {"sha": "a6ab26dc618d8980d9bf492db454c0327134c6ab", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -307,7 +307,7 @@ fn print_item(ps s, @ast::item item) {\n             bopen(s);\n             for (@ast::method meth in _obj.methods) {\n                 hbox(s);\n-                let vec[ast::ty_param] typarams = vec();\n+                let vec[ast::ty_param] typarams = [];\n                 maybe_print_comment(s, meth.span.lo);\n                 print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n                 space(s.s);\n@@ -360,7 +360,7 @@ fn print_literal(ps s, @ast::lit lit) {\n     alt (lit.node) {\n         case (ast::lit_str(?st)) {print_string(s, st);}\n         case (ast::lit_char(?ch)) {\n-            wrd(s.s, \"'\" + escape_str(_str::from_bytes(vec(ch as u8)), '\\'')\n+            wrd(s.s, \"'\" + escape_str(_str::from_bytes([ch as u8]), '\\'')\n                 + \"'\");\n         }\n         case (ast::lit_int(?val)) {"}, {"sha": "59426664b4a673e3f3edce94ce4dd8a96206c788", "filename": "src/comp/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fcomp%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Finterner.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -20,7 +20,7 @@ type interner[T] = rec(\n \n fn mk_interner[T](hashfn[T] hasher, eqfn[T] eqer) -> interner[T] {\n     auto m = map::mk_hashmap[T,uint](hasher, eqer);\n-    let vec[T] vect = vec();\n+    let vec[T] vect = [];\n     ret rec(map=m, mutable vect=vect, hasher=hasher, eqer=eqer);\n }\n \n@@ -30,7 +30,7 @@ fn intern[T](&interner[T] itr, &T val) -> uint {\n         case (none[uint]) {\n             auto new_idx = _vec::len[T](itr.vect);\n             itr.map.insert(val, new_idx);\n-            itr.vect += vec(val);\n+            itr.vect += [val];\n             ret new_idx;\n         }\n     }"}, {"sha": "1ab1b014410983596687df7b62fd45dc83e5dce4", "filename": "src/lib/_str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -141,7 +141,7 @@ fn unsafe_from_bytes(vec[mutable? u8] v) -> str {\n }\n \n fn unsafe_from_byte(u8 u) -> str {\n-    ret rustrt::str_from_vec(vec(u));\n+    ret rustrt::str_from_vec([u]);\n }\n \n fn str_from_cstr(sbuf cstr) -> str {\n@@ -248,7 +248,7 @@ fn char_len(str s) -> uint {\n }\n \n fn to_chars(str s) -> vec[char] {\n-    let vec[char] buf = vec();\n+    let vec[char] buf = [];\n     auto i = 0u;\n     auto len = byte_len(s);\n     while (i < len) {\n@@ -419,12 +419,12 @@ fn unshift_byte(&mutable str s, u8 b) {\n }\n \n fn split(str s, u8 sep) -> vec[str] {\n-    let vec[str] v = vec();\n+    let vec[str] v = [];\n     let str accum = \"\";\n     let bool ends_with_sep = false;\n     for (u8 c in s) {\n         if (c == sep) {\n-            v += vec(accum);\n+            v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n         } else {\n@@ -434,7 +434,7 @@ fn split(str s, u8 sep) -> vec[str] {\n     }\n     if (_str::byte_len(accum) != 0u ||\n         ends_with_sep) {\n-        v += vec(accum);\n+        v += [accum];\n     }\n     ret v;\n }\n@@ -486,5 +486,5 @@ fn to_upper(str s) -> str {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "70446e0f39fe39c6a8ab6eaaa18d9b76d562ebeb", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -75,7 +75,7 @@ fn init_fn[T](&init_op[T] op, uint n_elts) -> vec[T] {\n     let vec[T] v = alloc[T](n_elts);\n     let uint i = 0u;\n     while (i < n_elts) {\n-        v += vec(op(i));\n+        v += [op(i)];\n         i += 1u;\n     }\n     ret v;\n@@ -85,7 +85,7 @@ fn init_fn_mut[T](&init_op[T] op, uint n_elts) -> vec[mutable T] {\n     let vec[mutable T] v = alloc_mut[T](n_elts);\n     let uint i = 0u;\n     while (i < n_elts) {\n-        v += vec(mutable op(i));\n+        v += [mutable op(i)];\n         i += 1u;\n     }\n     ret v;\n@@ -103,7 +103,7 @@ fn init_elt[T](&T t, uint n_elts) -> vec[T] {\n     let uint i = n_elts;\n     while (i > 0u) {\n         i -= 1u;\n-        v += vec(t);\n+        v += [t];\n     }\n     ret v;\n }\n@@ -113,7 +113,7 @@ fn init_elt_mut[T](&T t, uint n_elts) -> vec[mutable T] {\n     let uint i = n_elts;\n     while (i > 0u) {\n         i -= 1u;\n-        v += vec(mutable t);\n+        v += [mutable t];\n     }\n     ret v;\n }\n@@ -156,7 +156,7 @@ fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n     auto result = alloc[T](end - start);\n     let uint i = start;\n     while (i < end) {\n-        result += vec(v.(i));\n+        result += [v.(i)];\n         i += 1u;\n     }\n     ret result;\n@@ -180,12 +180,12 @@ fn pop[T](&mutable array[T] v) -> T {\n }\n \n fn push[T](&mutable array[T] v, &T t) {\n-    v += vec(t);\n+    v += [t];\n }\n \n fn unshift[T](&mutable array[T] v, &T t) {\n     auto res = alloc[T](len[T](v) + 1u);\n-    res += vec(t);\n+    res += [t];\n     res += v;\n     v = res;\n }\n@@ -194,7 +194,7 @@ fn grow[T](&array[T] v, uint n, &T initval) {\n     let uint i = n;\n     while (i > 0u) {\n         i -= 1u;\n-        v += vec(initval);\n+        v += [initval];\n     }\n }\n \n@@ -209,7 +209,7 @@ fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n fn map[T, U](&option::operator[T,U] f, &array[T] v) -> vec[U] {\n     let vec[U] u = alloc[U](len[T](v));\n     for (T ve in v) {\n-        u += vec(f(ve));\n+        u += [f(ve)];\n     }\n     ret u;\n }\n@@ -223,7 +223,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &array[T] v0, &array[U] v1) -> vec[V] {\n     let vec[V] u = alloc[V](v0_len);\n     auto i = 0u;\n     while (i < v0_len) {\n-        u += vec(f(v0.(i), v1.(i)));\n+        u += [f(v0.(i), v1.(i))];\n         i += 1u;\n     }\n \n@@ -262,8 +262,8 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n     else {\n         auto rest = slice[tup(T, U)](v, 1u, sz);\n         auto tl   = unzip[T, U](rest);\n-        auto a    = vec(v.(0)._0);\n-        auto b    = vec(v.(0)._1);\n+        auto a    = [v.(0)._0];\n+        auto b    = [v.(0)._1];\n         ret tup(a + tl._0, b + tl._1);\n     }\n }\n@@ -280,18 +280,18 @@ fn clone[T](&vec[T] v) -> vec[T] {\n fn plus_option[T](&vec[T] v, &option::t[T] o) -> () {\n     alt (o) {\n         case (none[T]) {}\n-        case (some[T](?x)) { v += vec(x); }\n+        case (some[T](?x)) { v += [x]; }\n     }\n }\n \n fn cat_options[T](&vec[option::t[T]] v) -> vec[T] {\n-    let vec[T] res = vec();\n+    let vec[T] res = [];\n \n     for (option::t[T] o in v) {\n         alt (o) {\n             case (none[T]) { }\n             case (some[T](?t)) {\n-                res += vec(t);\n+                res += [t];\n             }\n         }\n     }\n@@ -301,9 +301,9 @@ fn cat_options[T](&vec[option::t[T]] v) -> vec[T] {\n \n // TODO: Remove in favor of built-in \"freeze\" operation when it's implemented.\n fn freeze[T](vec[mutable T] v) -> vec[T] {\n-    let vec[T] result = vec();\n+    let vec[T] result = [];\n     for (T elem in v) {\n-        result += vec(elem);\n+        result += [elem];\n     }\n     ret result;\n }"}, {"sha": "f34ce56524ed1959feb055782cb22e3bf13f6cab", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -217,6 +217,6 @@ fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}, {"sha": "0a5831d73333049245a17dee768296aef54251ff", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -122,22 +122,22 @@ fn write_sized_vint(&io::buf_writer w, uint n, uint size) {\n     let vec[u8] buf;\n     alt (size) {\n         case (1u) {\n-            buf = vec(0x80u8 | (n as u8));\n+            buf = [0x80u8 | (n as u8)];\n         }\n         case (2u) {\n-            buf = vec(0x40u8 | ((n >> 8u) as u8),\n-                      (n & 0xffu) as u8);\n+            buf = [0x40u8 | ((n >> 8u) as u8),\n+                      (n & 0xffu) as u8];\n         }\n         case (3u) {\n-            buf = vec(0x20u8 | ((n >> 16u) as u8),\n+            buf = [0x20u8 | ((n >> 16u) as u8),\n                       ((n >> 8u) & 0xffu) as u8,\n-                      (n & 0xffu) as u8);\n+                      (n & 0xffu) as u8];\n         }\n         case (4u) {\n-            buf = vec(0x10u8 | ((n >> 24u) as u8),\n+            buf = [0x10u8 | ((n >> 24u) as u8),\n                       ((n >> 16u) & 0xffu) as u8,\n                       ((n >> 8u) & 0xffu) as u8,\n-                      (n & 0xffu) as u8);\n+                      (n & 0xffu) as u8];\n         }\n         case (_) {\n             log_err \"vint to write too big\";\n@@ -158,7 +158,7 @@ fn write_vint(&io::buf_writer w, uint n) {\n }\n \n fn create_writer(&io::buf_writer w) -> writer {\n-    let vec[uint] size_positions = vec();\n+    let vec[uint] size_positions = [];\n     ret rec(writer=w, mutable size_positions=size_positions);\n }\n \n@@ -169,8 +169,8 @@ fn start_tag(&writer w, uint tag_id) {\n     write_vint(w.writer, tag_id);\n \n     // Write a placeholder four-byte size.\n-    w.size_positions += vec(w.writer.tell());\n-    let vec[u8] zeroes = vec(0u8, 0u8, 0u8, 0u8);\n+    w.size_positions += [w.writer.tell()];\n+    let vec[u8] zeroes = [0u8, 0u8, 0u8, 0u8];\n     w.writer.write(zeroes);\n }\n "}, {"sha": "04c823c7cf1322589a6722234d2d6c4cc16125b8", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -79,14 +79,14 @@ mod ct {\n     }\n \n     fn parse_fmt_string(str s) -> vec[piece] {\n-        let vec[piece] pieces = vec();\n+        let vec[piece] pieces = [];\n         auto lim = _str::byte_len(s);\n         auto buf = \"\";\n \n         fn flush_buf(str buf, &vec[piece] pieces) -> str {\n             if (_str::byte_len(buf) > 0u) {\n                 auto piece = piece_string(buf);\n-                pieces += vec(piece);\n+                pieces += [piece];\n             }\n             ret \"\";\n         }\n@@ -106,7 +106,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     auto res = parse_conversion(s, i, lim);\n-                    pieces += vec(res._0);\n+                    pieces += [res._0];\n                     i = res._1;\n                 }\n             } else {\n@@ -180,7 +180,7 @@ mod ct {\n     }\n \n     fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n-        let vec[flag] noflags = vec();\n+        let vec[flag] noflags = [];\n \n         if (i >= lim) {\n             ret tup(noflags, i);\n@@ -190,7 +190,7 @@ mod ct {\n             auto next = parse_flags(s, i + 1u, lim);\n             auto rest = next._0;\n             auto j = next._1;\n-            let vec[flag] curr = vec(f);\n+            let vec[flag] curr = [f];\n             ret tup(curr + rest, j);\n         }\n \n@@ -539,7 +539,7 @@ mod rt {\n                 || head == '-' as u8\n                 || head == ' ' as u8) {\n \n-                auto headstr = _str::unsafe_from_bytes(vec(head));\n+                auto headstr = _str::unsafe_from_bytes([head]);\n                 auto bytelen = _str::byte_len(s);\n                 auto numpart = _str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;\n@@ -793,7 +793,7 @@ mod RT {\n                 || head == '-' as u8\n                 || head == ' ' as u8) {\n \n-                auto headstr = _str::unsafe_from_bytes(vec(head));\n+                auto headstr = _str::unsafe_from_bytes([head]);\n                 auto bytelen = _str::byte_len(s);\n                 auto numpart = _str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;"}, {"sha": "c726fc0985c6a9c5288589cdab0314357e15ed59", "filename": "src/lib/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -36,7 +36,7 @@ fn list_dir(path p) -> vec[str] {\n   if (pl == 0u || p.(pl - 1u) as char != os_fs::path_sep) {\n     p += path_sep();\n   }\n-  let vec[str] full_paths = vec();\n+  let vec[str] full_paths = [];\n   for (str filename in os_fs::list_dir(p)) {\n     if (!_str::eq(filename, \".\")) {if (!_str::eq(filename, \"..\")) {\n       _vec::push[str](full_paths, p + filename);"}, {"sha": "a553b7e4128b6724176b62dfc04a2cdae8f9c698", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -106,7 +106,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n     fn empty_(uint x) -> vec[optval]{ret _vec::empty[optval]();}\n     auto f = empty_;\n     auto vals = _vec::init_fn_mut[vec[optval]](f, n_opts);\n-    let vec[str] free = vec();\n+    let vec[str] free = [];\n \n     auto l = _vec::len[str](args);\n     auto i = 0u;\n@@ -125,15 +125,15 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 auto tail = _str::slice(cur, 2u, curlen);\n                 auto eq = _str::index(tail, '=' as u8);\n                 if (eq == -1) {\n-                    names = vec(long(tail));\n+                    names = [long(tail)];\n                 } else {\n-                    names = vec(long(_str::slice(tail, 0u, eq as uint)));\n+                    names = [long(_str::slice(tail, 0u, eq as uint))];\n                     i_arg = option::some[str]\n                         (_str::slice(tail, (eq as uint) + 1u, curlen - 2u));\n                 }\n             } else {\n                 auto j = 1u;\n-                names = vec();\n+                names = [];\n                 while (j < curlen) {\n                     auto range = _str::char_range_at(cur, j);\n                     _vec::push[name](names, short(range._0));\n@@ -221,7 +221,7 @@ fn opt_str(match m, str nm) -> str {\n     }\n }\n fn opt_strs(match m, str nm) -> vec[str] {\n-    let vec[str] acc = vec();\n+    let vec[str] acc = [];\n     for (optval v in opt_vals(m, nm)) {\n         alt (v) {\n             case (val(?s)) { _vec::push[str](acc, s); }"}, {"sha": "57675916f46724f6684af9fa0ea4ddebff4aebc4", "filename": "src/lib/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -120,7 +120,7 @@ state obj new_reader(buf_reader rdr) {\n         ret rdr.eof();\n     }\n     fn read_line() -> str {\n-        let vec[u8] buf = vec();\n+        let vec[u8] buf = [];\n         // No break yet in rustc\n         auto go_on = true;\n         while (go_on) {\n@@ -131,7 +131,7 @@ state obj new_reader(buf_reader rdr) {\n         ret _str::unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> str {\n-        let vec[u8] buf = vec();\n+        let vec[u8] buf = [];\n         auto go_on = true;\n         while (go_on) {\n             auto ch = rdr.read_byte();\n@@ -172,7 +172,7 @@ state obj new_reader(buf_reader rdr) {\n         ret val;\n     }\n     fn read_whole_stream() -> vec[u8] {\n-        let vec[u8] buf = vec();\n+        let vec[u8] buf = [];\n         while (!rdr.eof()) {\n             buf += rdr.read(2048u);\n         }\n@@ -366,20 +366,20 @@ type writer =\n     };\n \n fn uint_to_le_bytes(uint n, uint size) -> vec[u8] {\n-    let vec[u8] bytes = vec();\n+    let vec[u8] bytes = [];\n     while (size > 0u) {\n-        bytes += vec((n & 255u) as u8);\n+        bytes += [(n & 255u) as u8];\n         n >>= 8u;\n         size -= 1u;\n     }\n     ret bytes;\n }\n \n fn uint_to_be_bytes(uint n, uint size) -> vec[u8] {\n-    let vec[u8] bytes = vec();\n+    let vec[u8] bytes = [];\n     auto i = (size - 1u) as int;\n     while (i >= 0) {\n-        bytes += vec(((n >> ((i * 8) as uint)) & 255u) as u8);\n+        bytes += [((n >> ((i * 8) as uint)) & 255u) as u8];\n         i -= 1;\n     }\n     ret bytes;\n@@ -466,7 +466,7 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n         while (vpos < vlen) {\n             auto b = v.(vpos);\n             if (buf.pos == _vec::len(buf.buf)) {\n-                buf.buf += vec(mutable b);\n+                buf.buf += [mutable b];\n             } else {\n                 buf.buf.(buf.pos) = b;\n             }\n@@ -486,7 +486,7 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n \n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n-    let vec[mutable u8] b = vec(mutable 0u8);\n+    let vec[mutable u8] b = [mutable 0u8];\n     _vec::pop(b);\n \n     let mutable_byte_buf buf = @rec(mutable buf = b, mutable pos = 0u);"}, {"sha": "f014c9c0df2f1dc7fb86163d227e0753c7123619", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -65,7 +65,7 @@ fn dylib_filename(str base) -> str {\n }\n \n fn pipe() -> tup(int, int) {\n-    let vec[mutable int] fds = vec(mutable 0, 0);\n+    let vec[mutable int] fds = [mutable 0, 0];\n     assert (os::libc::pipe(_vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n@@ -75,7 +75,7 @@ fn fd_FILE(int fd) -> libc::FILE {\n }\n \n fn waitpid(int pid) -> int {\n-    let vec[mutable int] status = vec(mutable 0);\n+    let vec[mutable int] status = [mutable 0];\n     assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n     ret status.(0);\n }"}, {"sha": "0e37051278b97d72939127e50a973193398fa2c3", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -62,7 +62,7 @@ fn dylib_filename(str base) -> str {\n }\n \n fn pipe() -> tup(int, int) {\n-    let vec[mutable int] fds = vec(mutable 0, 0);\n+    let vec[mutable int] fds = [mutable 0, 0];\n     assert (os::libc::pipe(_vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n@@ -72,7 +72,7 @@ fn fd_FILE(int fd) -> libc::FILE {\n }\n \n fn waitpid(int pid) -> int {\n-    let vec[mutable int] status = vec(mutable 0);\n+    let vec[mutable int] status = [mutable 0];\n     assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n     ret status.(0);\n }"}, {"sha": "7a0606ec89151fd5fcf12eabd3d0b1ab9f2d1f53", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,7 +6,7 @@ fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n   auto dir = os::libc::opendir(_str::buf(path));\n   assert (dir as uint != 0u);\n-  let vec[str] result = vec();\n+  let vec[str] result = [];\n   while (true) {\n     auto ent = os::libc::readdir(dir);\n     if (ent as int == 0) {"}, {"sha": "06fe23596c061d83f624d2d557f3d365c1172680", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -5,8 +5,8 @@ native \"rust\" mod rustrt {\n     fn rust_run_program(vbuf argv, int in_fd, int out_fd, int err_fd) -> int;\n }\n \n-fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n-    auto argptrs = vec(_str::buf(prog));\n+fn arg_vec(str prog, vec[str] args) -> vec[sbuf] {\n+    auto argptrs = [_str::buf(prog)];\n     for (str arg in args) {\n         _vec::push[sbuf](argptrs, _str::buf(arg));\n     }\n@@ -15,7 +15,7 @@ fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n }\n \n fn run_program(str prog, vec[str] args) -> int {\n-    auto pid = rustrt::rust_run_program(_vec::buf[sbuf](argvec(prog, args)),\n+    auto pid = rustrt::rust_run_program(_vec::buf[sbuf](arg_vec(prog, args)),\n                                        0, 0, 0);\n     ret os::waitpid(pid);\n }\n@@ -33,7 +33,7 @@ fn start_program(str prog, vec[str] args) -> @program {\n     auto pipe_input = os::pipe();\n     auto pipe_output = os::pipe();\n     auto pid = rustrt::rust_run_program\n-        (_vec::buf[sbuf](argvec(prog, args)),\n+        (_vec::buf[sbuf](arg_vec(prog, args)),\n          pipe_input._0, pipe_output._1, 0);\n     if (pid == -1) {fail;}\n     os::libc::close(pipe_input._0);\n@@ -92,5 +92,5 @@ fn program_output(str prog, vec[str] args)\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "4ae004079c36eca0b471d1f7b3ac8bb8dee7c1c7", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -174,13 +174,13 @@ fn mk_sha1() -> sha1 {\n             st.computed = true;\n         }\n \n-        let vec[u8] res = vec();\n+        let vec[u8] res = [];\n         for (u32 hpart in st.h) {\n             auto a = (hpart >> 24u32) & 0xFFu32 as u8;\n             auto b = (hpart >> 16u32) & 0xFFu32 as u8;\n             auto c = (hpart >> 8u32) & 0xFFu32 as u8;\n             auto d = (hpart & 0xFFu32 as u8);\n-            res += vec(a,b,c,d);\n+            res += [a,b,c,d];\n         }\n         ret res;\n     }"}, {"sha": "f74a7d7df71c7155353fc8a76b0c3d170bd2dcb9", "filename": "src/lib/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,17 +6,17 @@ type lteq[T] = fn(&T a, &T b) -> bool;\n fn merge_sort[T](lteq[T] le, vec[T] v) -> vec[T] {\n \n     fn merge[T](lteq[T] le, vec[T] a, vec[T] b) -> vec[T] {\n-        let vec[T] res = vec();\n+        let vec[T] res = [];\n         let uint a_len = len[T](a);\n         let uint a_ix = 0u;\n         let uint b_len = len[T](b);\n         let uint b_ix = 0u;\n         while (a_ix < a_len && b_ix < b_len) {\n             if (le(a.(a_ix), b.(b_ix))) {\n-                res += vec(a.(a_ix));\n+                res += [a.(a_ix)];\n                 a_ix += 1u;\n             } else {\n-                res += vec(b.(b_ix));\n+                res += [b.(b_ix)];\n                 b_ix += 1u;\n             }\n         }"}, {"sha": "46525e47bda27a14f38ceba9ae1644b28936cbaf", "filename": "src/lib/term.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -22,12 +22,12 @@ const u8 color_bright_cyan = 14u8;\n const u8 color_bright_white = 15u8;\n \n fn esc(io::buf_writer writer) {\n-    writer.write(vec(0x1bu8, '[' as u8));\n+    writer.write([0x1bu8, '[' as u8]);\n }\n \n fn reset(io::buf_writer writer) {\n     esc(writer);\n-    writer.write(vec('0' as u8, 'm' as u8));\n+    writer.write(['0' as u8, 'm' as u8]);\n }\n \n fn color_supported() -> bool {\n@@ -39,10 +39,10 @@ fn set_color(io::buf_writer writer, u8 first_char, u8 color) {\n \n     esc(writer);\n     if (color >= 8u8) {\n-        writer.write(vec('1' as u8, ';' as u8));\n+        writer.write(['1' as u8, ';' as u8]);\n         color -= 8u8;\n     }\n-    writer.write(vec(first_char, ('0' as u8) + color, 'm' as u8));\n+    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }\n \n fn fg(io::buf_writer writer, u8 color) {"}, {"sha": "c7790049be22fb87b2ba1eed840e86f31d95cc4a", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -7,14 +7,14 @@ type node = option::t[uint];\n type ufind = rec(mutable vec[mutable node] nodes);\n \n fn make() -> ufind {\n-    let vec[mutable node] v = vec(mutable none[uint]);\n+    let vec[mutable node] v = [mutable none[uint]];\n     _vec::pop(v);  // FIXME: botch\n     ret rec(mutable nodes=v);\n }\n \n fn make_set(&ufind ufnd) -> uint {\n     auto idx = _vec::len(ufnd.nodes);\n-    ufnd.nodes += vec(mutable none[uint]);\n+    ufnd.nodes += [mutable none[uint]];\n     ret idx;\n }\n "}, {"sha": "2baed39cac1bf1d1f368a9c3ae015f0dee261ffc", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -52,7 +52,7 @@ fn dylib_filename(str base) -> str {\n }\n \n fn pipe() -> tup(int, int) {\n-    let vec[mutable int] fds = vec(mutable 0, 0);\n+    let vec[mutable int] fds = [mutable 0, 0];\n     assert (os::libc::_pipe(_vec::buf(fds), 1024u,\n                         libc_constants::O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));"}, {"sha": "21c73a81d717e0203cdc7da967269ea1b763e18d", "filename": "src/snapshots.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,4 +1,7 @@\n-T\n+T 2011-05-16 ae030c5\n+  linux-i386 83a6f52df4029b61ebd628795b0a400265c98179\n+  macos-i386 1167e8b782165be738cbd08eeab104ede0d61df6\n+  winnt-i386 456bc38c2bc7ebb27fd008e3ccd05f16f6a31fe6\n \n S 2011-05-12 b1d3364\n   linux-i386 7671ac0de19d9ea981616b3c58c1d48f1b43820a"}, {"sha": "b7a890971e334bf8aa87eb8e22bef58de4c7ac15", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -28,10 +28,10 @@ type aminoacids = tup(char, u32);\n \n fn make_cumulative(vec[aminoacids] aa) -> vec[aminoacids] {\n   let u32 cp = 0u32;\n-  let vec[aminoacids] ans = vec();\n+  let vec[aminoacids] ans = [];\n   for (aminoacids a in aa) {\n     cp += a._1;\n-    ans += vec(tup(a._0, cp));\n+    ans += [tup(a._0, cp)];\n   }\n   ret ans;\n }\n@@ -91,7 +91,7 @@ fn make_repeat_fasta(str id, str desc, str s, int n) {\n }\n \n fn main(vec[str] args) {\n-  let vec[aminoacids] iub = make_cumulative(vec(tup( 'a', 27u32 ),\n+  let vec[aminoacids] iub = make_cumulative([tup( 'a', 27u32 ),\n                                                 tup( 'c', 12u32 ),\n                                                 tup( 'g', 12u32 ),\n                                                 tup( 't', 27u32 ),\n@@ -106,12 +106,12 @@ fn main(vec[str] args) {\n                                                 tup( 'S', 2u32 ),\n                                                 tup( 'V', 2u32 ),\n                                                 tup( 'W', 2u32 ),\n-                                                tup( 'Y', 2u32 )));\n+                                                tup( 'Y', 2u32 )]);\n \n-  let vec[aminoacids] homosapiens = make_cumulative(vec(tup( 'a', 30u32 ),\n+  let vec[aminoacids] homosapiens = make_cumulative([tup( 'a', 30u32 ),\n                                                         tup( 'c', 20u32 ),\n                                                         tup( 'g', 20u32 ),\n-                                                        tup( 't', 30u32 )));\n+                                                        tup( 't', 30u32 )]);\n \n   let str alu =\n     \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +"}, {"sha": "152291c7145e4a46ec467a35d27dfddb76fcec87", "filename": "src/test/bench/shootout/nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fnbody.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -7,7 +7,7 @@ native \"llvm\" mod llvm {\n \n fn main() {\n \n-    let vec[int] inputs = vec(\n+    let vec[int] inputs = [\n                               50000,\n                               500000\n                               //\n@@ -16,7 +16,7 @@ fn main() {\n                               // during 'make check' under valgrind\n                               // 5000000\n                               // 50000000\n-        );\n+        ];\n \n     let vec[Body::props] bodies = NBodySystem::MakeNBodySystem();\n \n@@ -38,13 +38,13 @@ fn main() {\n mod NBodySystem {\n \n     fn MakeNBodySystem() -> vec[Body::props] {\n-        let vec[Body::props] bodies = vec(\n+        let vec[Body::props] bodies = [\n             // these each return a Body::props\n             Body::sun(), \n             Body::jupiter(), \n             Body::saturn(), \n             Body::uranus(), \n-            Body::neptune());\n+            Body::neptune()];\n \n         let float px = 0.0;\n         let float py = 0.0;"}, {"sha": "9a2cd3237ba3fcbc6b6561e49835741fd5a15297", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -8,5 +8,5 @@\n type x = vec[x];\n \n fn main() {\n-  let x b = vec();\n+  let x b = [];\n }"}, {"sha": "2872d11fc800419d3eda9bcde9b7525aae7863b5", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -3,6 +3,6 @@\n // xfail-stage2\n // error-pattern: writing to immutable type\n fn main() {\n-  let vec[int] v = vec(1, 2, 3);\n+  let vec[int] v = [1, 2, 3];\n   v.(1) = 4;\n }\n\\ No newline at end of file"}, {"sha": "a6d782809c7de6310f32910eff62111c434b86b8", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,7 +6,7 @@\n // error-pattern:bounds check\n \n fn main() {\n-  let vec[int] v = vec(10);\n+  let vec[int] v = [10];\n   let int x = 0;\n   assert (v.(x) == 10);\n   // Bounds-check failure."}, {"sha": "ac691bb85aed081c3b5a61da572b458337033dc3", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,7 +6,7 @@\n // error-pattern:bounds check\n \n fn main() {\n-  let vec[int] v = vec(10, 20);\n+  let vec[int] v = [10, 20];\n   let int x = 0;\n   assert (v.(x) == 10);\n   // Bounds-check failure."}, {"sha": "3d6d6313085dfc5cc9b31c7b510c7e4b143cc7dd", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -7,7 +7,7 @@ import std::option::some;\n fn foo[T](&option::t[T] y) {\n   let int x;\n   \n-  let vec[int] res = vec();\n+  let vec[int] res = [];\n   \n   /* tests that x doesn't get put in the precondition for the \n      entire if expression */\n@@ -22,7 +22,7 @@ fn foo[T](&option::t[T] y) {\n         x = 42;\n       }\n     }\n-    res += vec(x);\n+    res += [x];\n   }\n \n   ret;"}, {"sha": "a84d3192f7b9cafa367fced8a7078e65c82f6bae", "filename": "src/test/run-pass/argv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,6 +1,6 @@\n fn main(vec[str] args) {\n-  let vec[str] vs = vec(\"hi\", \"there\", \"this\", \"is\", \"a\", \"vec\");\n-  let vec[vec[str]] vvs = vec(args, vs);\n+  let vec[str] vs = [\"hi\", \"there\", \"this\", \"is\", \"a\", \"vec\"];\n+  let vec[vec[str]] vvs = [args, vs];\n   for (vec[str] vs in vvs) {\n     for (str s in vs) {\n       log s;"}, {"sha": "65f0f57a14ad97bb23c435d2e1439b135988f916", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -13,7 +13,7 @@ fn main() {\n   } while (i < 30);\n   assert (i == 20);\n \n-  for (int x in vec(1, 2, 3, 4, 5, 6)) {\n+  for (int x in [1, 2, 3, 4, 5, 6]) {\n     if (x == 3) { break; }\n     assert (x <= 3);\n   }\n@@ -32,7 +32,7 @@ fn main() {\n     assert (i % 2 != 0);\n   } while (i < 10);\n \n-  for (int x in vec(1, 2, 3, 4, 5, 6)) {\n+  for (int x in [1, 2, 3, 4, 5, 6]) {\n     if (x % 2 == 0) { cont; }\n     assert (x % 2 != 0);\n   }"}, {"sha": "7faf162b889029fcc00c7cc50d275f8cf81fab76", "filename": "src/test/run-pass/empty-mutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let vec[mutable int] v = vec(mutable);\n+    let vec[mutable int] v = [mutable];\n }\n "}, {"sha": "3b6cadc7202a0a5dac2f2a643ed64003b0993154", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -16,7 +16,7 @@ fn test_vec() {\n     ret v1 == v2;\n   }\n   auto eq = bind compare_vec(_, _);\n-  test_generic[vec[int]](vec(1, 2, 3), eq);\n+  test_generic[vec[int]]([1, 2, 3], eq);\n }\n \n fn main() {"}, {"sha": "2c9d85d5d96d452112f591e8ccd6360ca7d6cc23", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -12,7 +12,7 @@ fn test_vec() {\n     ret v1 == v2;\n   }\n   auto eq = bind compare_vec(_, _);\n-  test_generic[vec[int]](vec(1, 2), eq);\n+  test_generic[vec[int]]([1, 2], eq);\n }\n \n fn main() {"}, {"sha": "c0224fffcd21695fde48c0e4a1f037af5dde47ab", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -12,7 +12,7 @@ fn test_vec() {\n     ret v1 == v2;\n   }\n   auto eq = bind compare_vec(_, _);\n-  test_generic[vec[int]](vec(1, 2), vec(2, 3), eq);\n+  test_generic[vec[int]]([1, 2], [2, 3], eq);\n }\n \n fn main() {"}, {"sha": "423821ab16caaa737b685952243ad04906b8a095", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -15,7 +15,7 @@ iter range(int start, int stop) -> int {\n \n fn main() {\n     let vec[mutable int] a =\n-      vec(mutable -1, -1, -1, -1, -1, -1, -1, -1);\n+      [mutable -1, -1, -1, -1, -1, -1, -1, -1];\n     let int p = 0;\n \n     for each (int i in two()) {"}, {"sha": "dd431a808903e9727cf0089f9f6772a28e6e037f", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,7 +6,7 @@ iter two() -> int {\n }\n \n fn main() {\n-    let vec[mutable int] a = vec(mutable -1, -1, -1, -1);\n+    let vec[mutable int] a = [mutable -1, -1, -1, -1];\n     let int p = 0;\n \n     for each (int i in two()) {"}, {"sha": "f7207295685f15e9d0af630712b59ed43ee53c9f", "filename": "src/test/run-pass/integral-indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -2,7 +2,7 @@\n \n fn main() {\n \n-  let vec[int] v = vec(0, 1, 2, 3, 4, 5);\n+  let vec[int] v = [0, 1, 2, 3, 4, 5];\n   let str s = \"abcdef\";\n   assert (v.(3u) == 3);\n   assert (v.(3u8) == 3);"}, {"sha": "706f3c22cd58211df2aa0e5787c4485140d530c2", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -16,22 +16,22 @@ fn test_1_element() {\n   auto act;\n \n   act = bitv::create(1u, false);\n-  assert (bitv::eq_vec(act, vec(0u)));\n+  assert (bitv::eq_vec(act, [0u]));\n \n   act = bitv::create(1u, true);\n-  assert (bitv::eq_vec(act, vec(1u)));\n+  assert (bitv::eq_vec(act, [1u]));\n }\n \n fn test_10_elements() {\n   auto act;\n \n   // all 0\n   act = bitv::create(10u, false);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // all 1\n   act = bitv::create(10u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(10u, false);\n@@ -40,7 +40,7 @@ fn test_10_elements() {\n   bitv::set(act, 2u, true);\n   bitv::set(act, 3u, true);\n   bitv::set(act, 4u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n \n   // mixed\n   act = bitv::create(10u, false);\n@@ -49,33 +49,33 @@ fn test_10_elements() {\n   bitv::set(act, 7u, true);\n   bitv::set(act, 8u, true);\n   bitv::set(act, 9u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(10u, false);\n   bitv::set(act, 0u, true);\n   bitv::set(act, 3u, true);\n   bitv::set(act, 6u, true);\n   bitv::set(act, 9u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+  assert (bitv::eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n }\n \n fn test_31_elements() {\n   auto act;\n \n   // all 0\n   act = bitv::create(31u, false);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // all 1\n   act = bitv::create(31u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+                             1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(31u, false);\n@@ -87,10 +87,10 @@ fn test_31_elements() {\n   bitv::set(act, 5u, true);\n   bitv::set(act, 6u, true);\n   bitv::set(act, 7u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // mixed\n   act = bitv::create(31u, false);\n@@ -102,10 +102,10 @@ fn test_31_elements() {\n   bitv::set(act, 21u, true);\n   bitv::set(act, 22u, true);\n   bitv::set(act, 23u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // mixed\n   act = bitv::create(31u, false);\n@@ -116,38 +116,38 @@ fn test_31_elements() {\n   bitv::set(act, 28u, true);\n   bitv::set(act, 29u, true);\n   bitv::set(act, 30u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+                             1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(31u, false);\n   bitv::set(act, 3u, true);\n   bitv::set(act, 17u, true);\n   bitv::set(act, 30u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 1u]));\n }\n \n fn test_32_elements() {\n   auto act;\n \n   // all 0\n   act = bitv::create(32u, false);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // all 1\n   act = bitv::create(32u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+                             1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(32u, false);\n@@ -159,10 +159,10 @@ fn test_32_elements() {\n   bitv::set(act, 5u, true);\n   bitv::set(act, 6u, true);\n   bitv::set(act, 7u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // mixed\n   act = bitv::create(32u, false);\n@@ -174,10 +174,10 @@ fn test_32_elements() {\n   bitv::set(act, 21u, true);\n   bitv::set(act, 22u, true);\n   bitv::set(act, 23u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n \n   // mixed\n   act = bitv::create(32u, false);\n@@ -189,41 +189,41 @@ fn test_32_elements() {\n   bitv::set(act, 29u, true);\n   bitv::set(act, 30u, true);\n   bitv::set(act, 31u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+                             1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n \n   // mixed\n   act = bitv::create(32u, false);\n   bitv::set(act, 3u, true);\n   bitv::set(act, 17u, true);\n   bitv::set(act, 30u, true);\n   bitv::set(act, 31u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n+                             0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u]));\n }\n \n fn test_33_elements() {\n   auto act;\n \n   // all 0\n   act = bitv::create(33u, false);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u)));\n+                             0u]));\n \n   // all 1\n   act = bitv::create(33u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              1u)));\n+                             1u]));\n \n   // mixed\n   act = bitv::create(33u, false);\n@@ -235,11 +235,11 @@ fn test_33_elements() {\n   bitv::set(act, 5u, true);\n   bitv::set(act, 6u, true);\n   bitv::set(act, 7u, true);\n-  assert (bitv::eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u)));\n+                             0u]));\n \n   // mixed\n   act = bitv::create(33u, false);\n@@ -251,11 +251,11 @@ fn test_33_elements() {\n   bitv::set(act, 21u, true);\n   bitv::set(act, 22u, true);\n   bitv::set(act, 23u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                              0u)));\n+                              0u]));\n \n   // mixed\n   act = bitv::create(33u, false);\n@@ -267,11 +267,11 @@ fn test_33_elements() {\n   bitv::set(act, 29u, true);\n   bitv::set(act, 30u, true);\n   bitv::set(act, 31u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                              0u)));\n+                             0u]));\n \n   // mixed\n   act = bitv::create(33u, false);\n@@ -280,11 +280,11 @@ fn test_33_elements() {\n   bitv::set(act, 30u, true);\n   bitv::set(act, 31u, true);\n   bitv::set(act, 32u, true);\n-  assert (bitv::eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv::eq_vec(act, [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                              1u)));\n+                             1u]));\n }\n \n fn main() {"}, {"sha": "3462e93f7c51290875e0d7ab1b82793126e97f2a", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -14,7 +14,7 @@ fn test_simple(str tmpfilebase) {\n   log frood;\n \n   {\n-    let io::writer out = io::file_writer(tmpfile, vec(io::create));\n+    let io::writer out = io::file_writer(tmpfile, [io::create]);\n     out.write_str(frood);\n   }\n "}, {"sha": "473950cd8644288102c26515a2fe2ad50f5cacc2", "filename": "src/test/run-pass/lib-qsort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -19,32 +19,32 @@ fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n \n fn main() {\n   {\n-    auto v1 = vec(mutable 3,7,4,5,2,9,5,8);\n-    auto v2 = vec(mutable 2,3,4,5,5,7,8,9);\n+    auto v1 = [mutable 3,7,4,5,2,9,5,8];\n+    auto v2 = [mutable 2,3,4,5,5,7,8,9];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(mutable 1,1,1);\n-    auto v2 = vec(mutable 1,1,1);\n+    auto v1 = [mutable 1,1,1];\n+    auto v2 = [mutable 1,1,1];\n     check_sort(v1, v2);\n   }\n \n   {\n-    let vec[mutable int] v1 = vec(mutable);\n-    let vec[mutable int] v2 = vec(mutable);\n+    let vec[mutable int] v1 = [mutable];\n+    let vec[mutable int] v2 = [mutable];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(mutable 9);\n-    auto v2 = vec(mutable 9);\n+    auto v1 = [mutable 9];\n+    auto v2 = [mutable 9];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(mutable 9,3,3,3,9);\n-    auto v2 = vec(mutable 3,3,3,9,9);\n+    auto v1 = [mutable 9,3,3,3,9];\n+    auto v2 = [mutable 3,3,3,9,9];\n     check_sort(v1, v2);\n   }\n "}, {"sha": "7f137cb871c15154a31a677698b5f6a993df125a", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -24,44 +24,44 @@ fn main() {\n \n     // Test messages from FIPS 180-1\n     let vec[test] fips_180_1_tests =\n-        vec(\n+        [\n             rec(input = \"abc\",\n-                output = vec(0xA9u8, 0x99u8, 0x3Eu8, 0x36u8, 0x47u8,\n+                output = [0xA9u8, 0x99u8, 0x3Eu8, 0x36u8, 0x47u8,\n                              0x06u8, 0x81u8, 0x6Au8, 0xBAu8, 0x3Eu8,\n                              0x25u8, 0x71u8, 0x78u8, 0x50u8, 0xC2u8,\n-                             0x6Cu8, 0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8)\n+                             0x6Cu8, 0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]\n                 ),\n             rec(input = \"abcdbcdecdefdefgefghfghighij\"\n                       + \"hijkijkljklmklmnlmnomnopnopq\",\n-                output = vec(0x84u8, 0x98u8, 0x3Eu8, 0x44u8, 0x1Cu8,\n+                output = [0x84u8, 0x98u8, 0x3Eu8, 0x44u8, 0x1Cu8,\n                              0x3Bu8, 0xD2u8, 0x6Eu8, 0xBAu8, 0xAEu8,\n                              0x4Au8, 0xA1u8, 0xF9u8, 0x51u8, 0x29u8,\n-                             0xE5u8, 0xE5u8, 0x46u8, 0x70u8, 0xF1u8)\n+                             0xE5u8, 0xE5u8, 0x46u8, 0x70u8, 0xF1u8]\n                 ),\n             rec(input = a_million_letter_a(),\n-                output = vec(0x34u8, 0xAAu8, 0x97u8, 0x3Cu8, 0xD4u8,\n+                output = [0x34u8, 0xAAu8, 0x97u8, 0x3Cu8, 0xD4u8,\n                              0xC4u8, 0xDAu8, 0xA4u8, 0xF6u8, 0x1Eu8,\n                              0xEBu8, 0x2Bu8, 0xDBu8, 0xADu8, 0x27u8,\n-                             0x31u8, 0x65u8, 0x34u8, 0x01u8, 0x6Fu8)\n+                             0x31u8, 0x65u8, 0x34u8, 0x01u8, 0x6Fu8]\n                 )\n-            );\n+            ];\n \n     // Examples from wikipedia\n     let vec[test] wikipedia_tests =\n-        vec(\n+        [\n             rec(input = \"The quick brown fox jumps over the lazy dog\",\n-                output = vec(0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8, 0x7au8,\n+                output = [0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8, 0x7au8,\n                              0x2du8, 0x28u8, 0xfcu8, 0xedu8, 0x84u8,\n                              0x9eu8, 0xe1u8, 0xbbu8, 0x76u8, 0xe7u8,\n-                             0x39u8, 0x1bu8, 0x93u8, 0xebu8, 0x12u8)\n+                             0x39u8, 0x1bu8, 0x93u8, 0xebu8, 0x12u8]\n                 ),\n             rec(input = \"The quick brown fox jumps over the lazy cog\",\n-                output = vec(0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8, 0xd2u8,\n+                output = [0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8, 0xd2u8,\n                              0x5eu8, 0x1bu8, 0x3au8, 0xfau8, 0xd3u8,\n                              0xe8u8, 0x5au8, 0x0bu8, 0xd1u8, 0x7du8,\n-                             0x9bu8, 0x10u8, 0x0du8, 0xb4u8, 0xb3u8)\n+                             0x9bu8, 0x10u8, 0x0du8, 0xb4u8, 0xb3u8]\n                 )\n-            );\n+            ];\n \n     auto tests = fips_180_1_tests + wikipedia_tests;\n "}, {"sha": "fe0c9e9473fb9c090f012cddbd74c1c5bd2b928d", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -17,32 +17,32 @@ fn check_sort(vec[int] v1, vec[int] v2) {\n \n fn main() {\n   {\n-    auto v1 = vec(3,7,4,5,2,9,5,8);\n-    auto v2 = vec(2,3,4,5,5,7,8,9);\n+    auto v1 = [3,7,4,5,2,9,5,8];\n+    auto v2 = [2,3,4,5,5,7,8,9];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(1,1,1);\n-    auto v2 = vec(1,1,1);\n+    auto v1 = [1,1,1];\n+    auto v2 = [1,1,1];\n     check_sort(v1, v2);\n   }\n \n   {\n-    let vec[int] v1 = vec();\n-    let vec[int] v2 = vec();\n+    let vec[int] v1 = [];\n+    let vec[int] v2 = [];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(9);\n-    auto v2 = vec(9);\n+    auto v1 = [9];\n+    auto v2 = [9];\n     check_sort(v1, v2);\n   }\n \n   {\n-    auto v1 = vec(9,3,3,3,9);\n-    auto v2 = vec(3,3,3,9,9);\n+    auto v1 = [9,3,3,3,9];\n+    auto v2 = [3,3,3,9,9];\n     check_sort(v1, v2);\n   }\n "}, {"sha": "185694a25a1bba3c308105060a919d10c37d51a4", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -73,21 +73,21 @@ fn test_concat() {\n     assert (_str::eq(_str::concat(v), s));\n   }\n \n-  t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \"youknowI'mnogood\");\n-  let vec[str] v = vec();\n+  t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n+  let vec[str] v = [];\n   t(v, \"\");\n-  t(vec(\"hi\"), \"hi\");\n+  t([\"hi\"], \"hi\");\n }\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n     assert (_str::eq(_str::connect(v, sep), s));\n   }\n \n-  t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \" \", \"you know I'm no good\");\n-  let vec[str] v = vec();\n+  t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n+  let vec[str] v = [];\n   t(v, \" \", \"\");\n-  t(vec(\"hi\"), \" \", \"hi\");\n+  t([\"hi\"], \" \", \"hi\");\n }\n \n fn test_to_upper() {"}, {"sha": "63e903d2d8ebf7d0768331eb7dbc7fa6705d9b8d", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -23,7 +23,7 @@ fn test_init_fn() {\n }\n \n fn test_slice() {\n-  let vec[int] v = vec(1,2,3,4,5);\n+  let vec[int] v = [1,2,3,4,5];\n   auto v2 = std::_vec::slice[int](v, 2u, 4u);\n   assert (std::_vec::len[int](v2) == 2u);\n   assert (v2.(0) == 3);\n@@ -33,7 +33,7 @@ fn test_slice() {\n fn test_map() {\n   fn square(&int x) -> int { ret x * x; }\n   let std::option::operator[int, int] op = square;\n-  let vec[int] v = vec(1, 2, 3, 4, 5);\n+  let vec[int] v = [1, 2, 3, 4, 5];\n   let vec[int] s = std::_vec::map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n@@ -45,8 +45,8 @@ fn test_map() {\n fn test_map2() {\n   fn times(&int x, &int y) -> int { ret x * y; }\n   auto f = times;\n-  auto v0 = vec(1, 2, 3, 4, 5);\n-  auto v1 = vec(5, 4, 3, 2, 1);\n+  auto v0 = [1, 2, 3, 4, 5];\n+  auto v1 = [5, 4, 3, 2, 1];\n   auto u = std::_vec::map2[int,int,int](f, v0, v1);\n \n   auto i = 0;"}, {"sha": "6345e43acf517e889d4609a68e12741b5e2f1193", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-  auto x = vec(1,2,3);\n+  auto x = [1,2,3];\n   auto y = 0;\n   for (int i in x) {\n     log i;"}, {"sha": "7b8781d2f81e5d499a6b9aa806b25a9cc35850ec", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -9,9 +9,9 @@ fn len(vec[mutable? int] v) -> uint {\n }\n \n fn main() {\n-    auto v0 = vec(1, 2, 3, 4, 5);\n+    auto v0 = [1, 2, 3, 4, 5];\n     log len(v0);\n-    auto v1 = vec(mutable 1, 2, 3, 4, 5);\n+    auto v1 = [mutable 1, 2, 3, 4, 5];\n     log len(v1);\n }\n "}, {"sha": "a09d8dc4ab8a691d0b4c9991d6a52d3f0407e42e", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -3,11 +3,11 @@\n use std;\n \n fn grow(&mutable vec[int] v) {\n-  v += vec(1);\n+  v += [1];\n }\n \n fn main() {\n-  let vec[int] v = vec();\n+  let vec[int] v = [];\n   grow(v);\n   grow(v);\n   grow(v);"}, {"sha": "15c36f46b68810f34d43a8c7c734480df9a982ef", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -2,5 +2,5 @@ fn main() {\n   // This just tests whether the vec leaks its members.\n \n   let vec[mutable @tup(int,int)] pvec =\n-    vec(mutable @tup(1,2), @tup(3,4), @tup(5,6));\n+    [mutable @tup(1,2), @tup(3,4), @tup(5,6)];\n }"}, {"sha": "7b807b9a76f6b131bef3beb4f2b046da92d15a17", "filename": "src/test/run-pass/obj-with-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -5,7 +5,7 @@ fn main() {\n       ret data.(i);\n     }\n   }\n-  auto b = buf(vec(1 as u8, 2 as u8, 3 as u8));\n+  auto b = buf([1 as u8, 2 as u8, 3 as u8]);\n   log b.get(1);\n   assert (b.get(1) == (2 as u8));\n }"}, {"sha": "9a8eca74af479856c45dcea5ceb3f5560e41748e", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -3,13 +3,13 @@ fn main() {\n   assert (\"hello \" > \"hello\");\n   assert (\"hello\" != \"there\");\n \n-  assert (vec(1,2,3,4) > vec(1,2,3));\n-  assert (vec(1,2,3) < vec(1,2,3,4));\n-  assert (vec(1,2,4,4) > vec(1,2,3,4));\n-  assert (vec(1,2,3,4) < vec(1,2,4,4));\n-  assert (vec(1,2,3) <= vec(1,2,3));\n-  assert (vec(1,2,3) <= vec(1,2,3,3));\n-  assert (vec(1,2,3,4) > vec(1,2,3));\n-  assert (vec(1,2,3) == vec(1,2,3));\n-  assert (vec(1,2,3) != vec(1,1,3));\n+  assert ([1,2,3,4] > [1,2,3]);\n+  assert ([1,2,3] < [1,2,3,4]);\n+  assert ([1,2,4,4] > [1,2,3,4]);\n+  assert ([1,2,3,4] < [1,2,4,4]);\n+  assert ([1,2,3] <= [1,2,3]);\n+  assert ([1,2,3] <= [1,2,3,3]);\n+  assert ([1,2,3,4] > [1,2,3]);\n+  assert ([1,2,3] == [1,2,3]);\n+  assert ([1,2,3] != [1,1,3]);\n }"}, {"sha": "8412d51d8c76ea70ffef79e4341bc27264ed5ca9", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -13,6 +13,6 @@ fn uhoh[T](vec[clam[T]] v) {\n }\n \n fn main() {\n-  let vec[clam[int]] v = vec(b[int], b[int], a[int](42, 17));\n+  let vec[clam[int]] v = [b[int], b[int], a[int](42, 17)];\n   uhoh[int](v);\n }"}, {"sha": "9a533bca036fbb1cfc93aa6a371e487bcb14bf27", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -22,7 +22,7 @@ fn test_rec() {\n fn test_vec() {\n   let port[vec[int]] po = port();\n   let chan[vec[int]] ch = chan(po);\n-  let vec[int] v0 = vec(0, 1, 2);\n+  let vec[int] v0 = [0, 1, 2];\n \n   ch <| v0;\n "}, {"sha": "e856f0bbef2c9a88625f75c7b00d2f0d372ca409", "filename": "src/test/run-pass/task-comm-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-2.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -21,13 +21,13 @@ fn test00(bool create_threads) {\n     let int number_of_tasks = 8;\n     \n     let int i = 0;\n-    let vec[task] tasks = vec();\n+    let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n         if (create_threads) {\n-            tasks += vec(spawn thread start(i));\n+            tasks += [spawn thread start(i)];\n         } else {\n-            tasks += vec(spawn start(i));\n+            tasks += [spawn start(i)];\n         }\n     }\n     "}, {"sha": "907a7f280353c2ef18e6cd51383da7c38720f784", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -31,13 +31,13 @@ fn test00(bool is_multithreaded) {\n     let int i = 0;\n     \n     // Create and spawn tasks...\n-    let vec[task] tasks = vec();\n+    let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         if (is_multithreaded) {\n-            tasks += vec(\n-                spawn thread test00_start(ch, i, number_of_messages));\n+            tasks += [\n+                spawn thread test00_start(ch, i, number_of_messages)];\n         } else {\n-            tasks += vec(spawn test00_start(ch, i, number_of_messages));\n+            tasks += [spawn test00_start(ch, i, number_of_messages)];\n         }\n         i = i + 1;\n     }"}, {"sha": "826743d0937fa28f73ef062cb295747b6eaeed0a", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -33,14 +33,14 @@ fn test00(bool is_multithreaded) {\n     \n     let int i = 0;\n     \n-    let vec[task] tasks = vec();\n+    let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n         if (is_multithreaded) {\n-            tasks += vec(\n-                spawn thread test00_start(ch, i, number_of_messages));\n+            tasks += [\n+                spawn thread test00_start(ch, i, number_of_messages)];\n         } else {\n-            tasks += vec(spawn test00_start(ch, i, number_of_messages));\n+            tasks += [spawn test00_start(ch, i, number_of_messages)];\n         }\n     }\n     \n@@ -147,11 +147,11 @@ fn test06() {\n     \n     let int i = 0;\n     \n-    let vec[task] tasks = vec();\n+    let vec[task] tasks = [];\n     while (i < number_of_tasks) {\n         i = i + 1;\n-        tasks += vec(spawn thread test06_start(i));\n-        // tasks += vec(spawn test06_start(i));\n+        tasks += [spawn thread test06_start(i)];\n+        // tasks += [spawn test06_start(i)];\n     }\n     \n     for (task t in tasks) {"}, {"sha": "1394643929e795e20f995b36efee1b5766fe1b95", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -9,7 +9,7 @@ iter range(uint lo, uint hi) -> uint {\n \n fn create_index[T](vec[tup(T, uint)] index, fn(&T) -> uint hash_fn) {\n     for each (uint i in range(0u, 256u)) {\n-        let vec[T] bucket = vec();\n+        let vec[T] bucket = [];\n     }\n }\n "}, {"sha": "22a97ed7002080531d5265fb1cb914cd82c76188", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -8,7 +8,7 @@ import std::io;\n \n fn main() {\n   // Chars of 1, 2, 3, and 4 bytes\n-  let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n+  let vec[char] chs = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n   let str s = _str::from_chars(chs);\n \n   assert (_str::byte_len(s) == 10u);\n@@ -19,9 +19,9 @@ fn main() {\n   assert (_str::char_at(s, 1u) == '\u00e9');\n \n   assert (_str::is_utf8(_str::bytes(s)));\n-  assert (!_str::is_utf8(vec(0x80_u8)));\n-  assert (!_str::is_utf8(vec(0xc0_u8)));\n-  assert (!_str::is_utf8(vec(0xc0_u8, 0x10_u8)));\n+  assert (!_str::is_utf8([0x80_u8]));\n+  assert (!_str::is_utf8([0xc0_u8]));\n+  assert (!_str::is_utf8([0xc0_u8, 0x10_u8]));\n \n   auto stack = \"a\u00d7c\u20ac\";\n   assert (_str::pop_char(stack) == '\u20ac');"}, {"sha": "c61d4cc967baccf9aa27e933f02ae0b3ed17816a", "filename": "src/test/run-pass/vec-alloc-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-alloc-append.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -13,5 +13,5 @@ fn slice[T](vec[T] e) {\n }\n \n fn main() {\n-  slice[str](vec(\"a\"));\n+  slice[str]([\"a\"]);\n }"}, {"sha": "1d0d2509570b45211243fd4a3bb4cf2ffc692265", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -13,8 +13,8 @@ import std::_vec;\n const uint const_refcount = 0x7bad_face_u;\n \n fn fast_growth() {\n-  let vec[int] v = vec(1,2,3,4,5);\n-  v += vec(6,7,8,9,0);\n+  let vec[int] v = [1,2,3,4,5];\n+  v += [6,7,8,9,0];\n \n   log v.(9);\n   assert (v.(0) == 1);\n@@ -23,9 +23,9 @@ fn fast_growth() {\n }\n \n fn slow_growth() {\n-  let vec[int] v = vec();\n+  let vec[int] v = [];\n   let vec[int] u = v;\n-  v += vec(17);\n+  v += [17];\n \n   log v.(0);\n   assert (v.(0) == 17);\n@@ -34,7 +34,7 @@ fn slow_growth() {\n fn slow_growth2_helper(str s) {   // ref up: s\n \n   obj acc(vec[str] v) {\n-    fn add(&str s) { v += vec(s); }\n+    fn add(&str s) { v += [s]; }\n   }\n \n   let str ss = s;                 // ref up: s\n@@ -50,7 +50,7 @@ fn slow_growth2_helper(str s) {   // ref up: s\n      * copy of existing elements should increment the ref count of\n      * mumble, the existing str in the originally- shared vec.\n      */\n-    let vec[str] v = vec(mumble); // ref up: v, mumble\n+    let vec[str] v = [mumble]; // ref up: v, mumble\n     let acc a = acc(v);           // ref up: a, v\n \n     log _vec::refcount[str](v);"}, {"sha": "3ef6b1dec5606d72a0172c18d4f3f9c45540ef5f", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n fn main() {\n-  let vec[int] a = vec(1,2,3,4,5);\n-  let vec[int] b = vec(6,7,8,9,0);\n+  let vec[int] a = [1,2,3,4,5];\n+  let vec[int] b = [6,7,8,9,0];\n   let vec[int] v = a + b;\n   log v.(9);\n   assert (v.(0) == 1);"}, {"sha": "6b46102faf4fc3b0c69a05c88c2d0ceae068eca0", "filename": "src/test/run-pass/vec-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-drop.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n   // This just tests whether the vec leaks its members.\n-  let vec[@tup(int,int)] pvec = vec(@tup(1,2),@tup(3,4),@tup(5,6));\n+  let vec[@tup(int,int)] pvec = [@tup(1,2),@tup(3,4),@tup(5,6)];\n }"}, {"sha": "3c010e19e9131ea9e52ba3f9206a55761a2bd156", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n-    auto v = vec(1);\n-    v += vec(2);\n-    v += vec(3);\n-    v += vec(4);\n-    v += vec(5);\n+    auto v = [1];\n+    v += [2];\n+    v += [3];\n+    v += [4];\n+    v += [5];\n     assert (v.(0) == 1);\n     assert (v.(1) == 2);\n     assert (v.(2) == 3);"}, {"sha": "e1c0a78bd9af2a44929123cb0f3e31c2cb945a11", "filename": "src/test/run-pass/vec-in-tup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-  let tup(mutable vec[int]) i = tup(mutable vec(1,2,3));\n-  i._0 = vec(4,5,6);\n+  let tup(mutable vec[int]) i = tup(mutable [1,2,3]);\n+  i._0 = [4,5,6];\n }"}, {"sha": "48e91dcd213c4f9d528d86aeb0845233f0f244d8", "filename": "src/test/run-pass/vec-late-init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-late-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-late-init.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n   let vec[int] later;\n   if (true) {\n-    later = vec(1);\n+    later = [1];\n   } else {\n-    later = vec(2);\n+    later = [2];\n   }\n   log later.(0);\n }\n\\ No newline at end of file"}, {"sha": "09416d67fef0e8531a35a98cb1cea5a252c74a83", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,9 +1,9 @@\n fn push[T](&mutable vec[mutable? T] v, &T t) {\n-    v += vec(t);\n+    v += [t];\n }\n \n fn main() {\n-    auto v = @vec(1, 2, 3);\n+    auto v = @[1, 2, 3];\n     push[int](*v, 1);\n }\n "}, {"sha": "cb26e4845d5eb33183353003f30c0ee5bcf36f67", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::_vec;\n \n fn main() {\n-    auto v = vec(1, 2, 3);\n+    auto v = [1, 2, 3];\n     log_err _vec::refcount[int](v);\n     log_err _vec::refcount[int](v);\n     log_err _vec::refcount[int](v);"}, {"sha": "fb60210fbfcaf666f4e132e56cba338b1683b7df", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage1\n // xfail-stage2\n fn main() {\n-  let vec[int] v = vec(1,2,3,4,5);\n+  let vec[int] v = [1,2,3,4,5];\n   auto v2 = v.(1,2);\n   assert (v2.(0) == 2);\n   assert (v2.(1) == 3);"}, {"sha": "5e97fa81465aa0e5417713306a24eb32781988bf", "filename": "src/test/run-pass/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n fn main() {\n-  let vec[int] v = vec(10, 20);\n+  let vec[int] v = [10, 20];\n   assert (v.(0) == 10);\n   assert (v.(1) == 20);\n   let int x = 0;"}, {"sha": "64dc59af3d689a90f696949e21760cd4c7010b05", "filename": "src/test/run-pass/while-with-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbbc1a77d242fafa1393127defa7ffec0bcb9e54/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs?ref=fbbc1a77d242fafa1393127defa7ffec0bcb9e54", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     log i;\n     i = i + 1;\n     if (i == 95) { \n-      let vec[int] v = vec(1,2,3,4,5); // we check that it is freed by break\n+      let vec[int] v = [1,2,3,4,5]; // we check that it is freed by break\n       log \"breaking\"; \n       break; \n     }"}]}