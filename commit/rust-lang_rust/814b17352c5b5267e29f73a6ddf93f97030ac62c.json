{"sha": "814b17352c5b5267e29f73a6ddf93f97030ac62c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNGIxNzM1MmM1YjUyNjdlMjlmNzNhNmRkZjkzZjk3MDMwYWM2MmM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-13T18:00:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-14T00:35:13Z"}, "message": "Use new module namespace syntax.", "tree": {"sha": "128555c6e8bc6c13c19a576aa76a064ac51a9aff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/128555c6e8bc6c13c19a576aa76a064ac51a9aff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/814b17352c5b5267e29f73a6ddf93f97030ac62c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/814b17352c5b5267e29f73a6ddf93f97030ac62c", "html_url": "https://github.com/rust-lang/rust/commit/814b17352c5b5267e29f73a6ddf93f97030ac62c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/814b17352c5b5267e29f73a6ddf93f97030ac62c/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f35c6a4b7b91399e9338fa29d91781f3bf2797", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f35c6a4b7b91399e9338fa29d91781f3bf2797", "html_url": "https://github.com/rust-lang/rust/commit/b6f35c6a4b7b91399e9338fa29d91781f3bf2797"}], "stats": {"total": 160, "additions": 76, "deletions": 84}, "files": [{"sha": "d795d6c236324034b4b9ac3d2c39e52caff3c666", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=814b17352c5b5267e29f73a6ddf93f97030ac62c", "patch": "@@ -374,10 +374,10 @@ type _obj = rec(vec[obj_field] fields,\n \n type anon_obj = rec(\n     // New fields and methods, if they exist.\n-    Option.t[vec[obj_field]] fields,\n+    option::t[vec[obj_field]] fields,\n     vec[@method] methods,\n     // with_obj: the original object being extended, if it exists.\n-    Option.t[ident] with_obj);\n+    option::t[ident] with_obj);\n \n type _mod = rec(vec[@view_item] view_items,\n                 vec[@item] items);"}, {"sha": "8eb6c398f9c98ff73993beca26312b4839b443ef", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=814b17352c5b5267e29f73a6ddf93f97030ac62c", "patch": "@@ -773,58 +773,21 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n                                                some(token::COMMA),\n                                                pf, hi, p);\n         ex = ast::expr_vec(es, mut, p.get_ann());\n-    } else if (eat_word(p, \"rec\")) {\n-        expect(p, token::LPAREN);\n-        auto fields = vec(parse_field(p));\n-\n-        auto more = true;\n-        auto base = none[@ast::expr];\n-        while (more) {\n-            if (p.peek() == token::RPAREN) {\n-                hi = p.get_hi_pos();\n-                p.bump();\n-                more = false;\n-            } else if (eat_word(p, \"with\")) {\n-                base = some[@ast::expr](parse_expr(p));\n-                hi = p.get_hi_pos();\n-                expect(p, token::RPAREN);\n-                more = false;\n-            } else if (p.peek() == token::COMMA) {\n-                p.bump();\n-                fields += vec(parse_field(p));\n-            } else {\n-                unexpected(p, p.peek());\n-            }\n-        }\n-\n-        ex = ast::expr_rec(fields, base, p.get_ann());\n-    }\n-    // Anonymous object\n-    else if (eat_word(p, \"obj\")) {\n+    } else if (eat_word(p, \"obj\")) {\n+        // Anonymous object\n \n         // FIXME: Can anonymous objects have ty params?\n         auto ty_params = parse_ty_params(p);\n \n         // Only make people type () if they're actually adding new fields\n-        let option.t[vec[ast::obj_field]] fields = none[vec[ast::obj_field]];\n+        let option::t[vec[ast::obj_field]] fields = \n+            none[vec[ast::obj_field]];\n         if (p.peek() == token::LPAREN) {\n             auto pf = parse_obj_field;\n-            expect(p, token::LBRACE);\n-            while (p.peek() != token::RBRACE) {\n-                alt (p.peek()) {\n-                    case (token.WITH) { \n-                        p.bump();\n-                        with_obj = some[ast::ident](parse_ident(p));\n-                    }\n-                    case (_) {\n-                        Vec.push[@ast::method](meths,\n-                                              parse_method(p));\n-                    }\n-                }\n-            }\n-\n             hi = p.get_hi_pos();\n             expect(p, token::LPAREN);\n+\n+\n             fields = some[vec[ast::obj_field]]\n                 (parse_seq_to_end[ast::obj_field] \n                  (token::RPAREN,\n@@ -833,36 +796,65 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         }\n \n         let vec[@ast::method] meths = vec();\n-        let option.t[ast::ident] with_obj = none[ast::ident];\n+        let option::t[ast::ident] with_obj = none[ast::ident];\n \n         expect(p, token::LBRACE);\n+\n         while (p.peek() != token::RBRACE) {\n             alt (p.peek()) {\n                 case (token::WITH) { \n+                    p.bump();\n                     with_obj = some[ast::ident](parse_ident(p));\n                 }\n                 case (_) {\n-                    // fall through\n+                    _vec::push[@ast::method](meths,\n+                                             parse_method(p));\n                 }\n             }\n         }\n+\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n \n-        // fields and methods may be *additional* or *overriding* fields and\n-        // methods if there's a with_obj, or they may be the *only* fields and\n-        // methods if there's no with_obj.\n+        // fields and methods may be *additional* or *overriding* fields\n+        // and methods if there's a with_obj, or they may be the *only*\n+        // fields and methods if there's no with_obj.\n \n         // We don't need to pull \".node\" out of fields because it's not a\n         // \"spanned\".\n         let ast::anon_obj ob = rec(fields=fields,\n-                                  methods=meths,\n-                                  with_obj=with_obj);\n+                                   methods=meths,\n+                                   with_obj=with_obj);\n \n         auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n \n-        ex = ast::expr_anon_obj(ob, ty_params, odid, ast::ann_none);\n+        ex = ast::expr_anon_obj(ob, ty_params, odid, p.get_ann());\n+\n+    } else if (eat_word(p, \"rec\")) {\n+        expect(p, token::LPAREN);\n+        auto fields = vec(parse_field(p));\n+\n+        auto more = true;\n+        auto base = none[@ast::expr];\n+        while (more) {\n+            if (p.peek() == token::RPAREN) {\n+                hi = p.get_hi_pos();\n+                p.bump();\n+                more = false;\n+            } else if (eat_word(p, \"with\")) {\n+                base = some[@ast::expr](parse_expr(p));\n+                hi = p.get_hi_pos();\n+                expect(p, token::RPAREN);\n+                more = false;\n+            } else if (p.peek() == token::COMMA) {\n+                p.bump();\n+                fields += vec(parse_field(p));\n+            } else {\n+                unexpected(p, p.peek());\n+            }\n+        }\n \n+        ex = ast::expr_rec(fields, base, p.get_ann());\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(parser p) -> option::t[@ast::expr] {"}, {"sha": "bd5f93f94d64304a0539a0e45ed4e2a61692308d", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=814b17352c5b5267e29f73a6ddf93f97030ac62c", "patch": "@@ -210,9 +210,9 @@ type ast_fold[ENV] =\n          &@expr e, &ann a) -> @expr)              fold_expr_chan,\n \n      (fn(&ENV e, &span sp,\n-         &ast.anon_obj ob, // TODO: Is the ob arg supposed to be & or not?\n-         vec[ast.ty_param] tps,\n-         ast.obj_def_ids odid, ann a) -> @expr)   fold_expr_anon_obj,\n+         &ast::anon_obj ob, // TODO: Is the ob arg supposed to be & or not?\n+         vec[ast::ty_param] tps,\n+         ast::obj_def_ids odid, ann a) -> @expr)   fold_expr_anon_obj,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n@@ -327,9 +327,9 @@ type ast_fold[ENV] =\n       -> ast::_obj)                                fold_obj,\n \n      (fn(&ENV e,\n-         Option.t[vec[ast.obj_field]] fields,\n-         vec[@ast.method] methods,\n-         Option.t[ident] with_obj) -> ast.anon_obj) fold_anon_obj,\n+         option::t[vec[ast::obj_field]] fields,\n+         vec[@ast::method] methods,\n+         option::t[ident] with_obj) -> ast::anon_obj) fold_anon_obj,\n \n      // Env updates.\n      (fn(&ENV e, &@ast::crate c) -> ENV) update_env_for_crate,\n@@ -838,7 +838,7 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_chan(env_, e.span, ee, t2);\n         }\n \n-        case (ast.expr_anon_obj(?ob, ?tps, ?odid, ?t)) {\n+        case (ast::expr_anon_obj(?ob, ?tps, ?odid, ?t)) {\n             auto ee = fold_anon_obj(env_, fld, ob);\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_anon_obj(env_, e.span, ee, tps, odid, t2);\n@@ -976,45 +976,45 @@ fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n \n-fn fold_anon_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast.anon_obj ob) \n-    -> ast.anon_obj {\n+fn fold_anon_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast::anon_obj ob) \n+    -> ast::anon_obj {\n \n     // Fields\n-    let Option.t[vec[ast.obj_field]] fields = none[vec[ast.obj_field]];\n+    let option::t[vec[ast::obj_field]] fields = none[vec[ast::obj_field]];\n     alt (ob.fields) {\n-        case (none[vec[ast.obj_field]]) { }\n-        case (some[vec[ast.obj_field]](?v)) {\n-            let vec[ast.obj_field] fields = vec();\n-            for (ast.obj_field f in v) {\n+        case (none[vec[ast::obj_field]]) { }\n+        case (some[vec[ast::obj_field]](?v)) {\n+            let vec[ast::obj_field] fields = vec();\n+            for (ast::obj_field f in v) {\n                 fields += vec(fold_obj_field(env, fld, f));\n             }\n         }\n     }\n \n     // with_obj\n-    let Option.t[ast.ident] with_obj = none[ast.ident];\n+    let option::t[ast::ident] with_obj = none[ast::ident];\n     alt (ob.with_obj) {\n-        case (none[ast.ident]) { }\n-        case (some[ast.ident](?i)) {\n-            with_obj = some[ast.ident](i);\n+        case (none[ast::ident]) { }\n+        case (some[ast::ident](?i)) {\n+            with_obj = some[ast::ident](i);\n         }\n     }\n \n     // Methods\n-    let vec[@ast.method] meths = vec();\n-    let vec[ast.ty_param] tp = vec();\n-    for (@ast.method m in ob.methods) {\n-        // Fake-up an ast.item for this method.\n+    let vec[@ast::method] meths = vec();\n+    let vec[ast::ty_param] tp = vec();\n+    for (@ast::method m in ob.methods) {\n+        // Fake-up an ast::item for this method.\n         // FIXME: this is kinda awful. Maybe we should reformulate\n         // the way we store methods in the AST?\n-        let @ast.item i = @rec(node=ast.item_fn(m.node.ident,\n+        let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n                                                 m.node.meth,\n                                                 tp,\n                                                 m.node.id,\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        Vec.push[@ast.method](meths, fold_method(_env, fld, m));\n+        _vec::push[@ast::method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_anon_obj(env, fields, meths, with_obj);\n }\n@@ -1468,9 +1468,9 @@ fn identity_fold_expr_chan[ENV](&ENV e, &span sp, &@expr x,\n }\n \n fn identity_fold_expr_anon_obj[ENV](&ENV e, &span sp,\n-                                    &ast.anon_obj ob, vec[ast.ty_param] tps,\n-                                    ast.obj_def_ids odid, ann a) -> @expr {\n-    ret @respan(sp, ast.expr_anon_obj(ob, tps, odid, a));\n+                                    &ast::anon_obj ob, vec[ast::ty_param] tps,\n+                                    ast::obj_def_ids odid, ann a) -> @expr {\n+    ret @respan(sp, ast::expr_anon_obj(ob, tps, odid, a));\n }\n \n // Decl identities.\n@@ -1648,9 +1648,9 @@ fn identity_fold_obj[ENV](&ENV e,\n }\n \n fn identity_fold_anon_obj[ENV](&ENV e,\n-                               Option.t[vec[ast.obj_field]] fields,\n-                               vec[@ast.method] methods,\n-                               Option.t[ident] with_obj) -> ast.anon_obj {\n+                               option::t[vec[ast::obj_field]] fields,\n+                               vec[@ast::method] methods,\n+                               option::t[ident] with_obj) -> ast::anon_obj {\n     ret rec(fields=fields, methods=methods, with_obj=with_obj);\n }\n "}, {"sha": "fdc32f1108e15baf3f99754916c47fb9998f8ce8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/814b17352c5b5267e29f73a6ddf93f97030ac62c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=814b17352c5b5267e29f73a6ddf93f97030ac62c", "patch": "@@ -2889,7 +2889,7 @@ fn iter_sequence(@block_ctxt cx,\n \n             cx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n                                     \"trans::iter_sequence: \" +\n-                                    ty.ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                                    ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n             fail; \n         }\n     }"}]}