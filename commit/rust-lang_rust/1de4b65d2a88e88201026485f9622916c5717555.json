{"sha": "1de4b65d2a88e88201026485f9622916c5717555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZTRiNjVkMmE4OGU4ODIwMTAyNjQ4NWY5NjIyOTE2YzU3MTc1NTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-10T21:05:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-16T06:22:06Z"}, "message": "Updates with core::fmt changes\n\n1. Wherever the `buf` field of a `Formatter` was used, the `Formatter` is used\n   instead.\n2. The usage of `write_fmt` is minimized as much as possible, the `write!` macro\n   is preferred wherever possible.\n3. Usage of `fmt::write` is minimized, favoring the `write!` macro instead.", "tree": {"sha": "1aa5e8506b8367075cfa4f1546c27df2a943dff9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aa5e8506b8367075cfa4f1546c27df2a943dff9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1de4b65d2a88e88201026485f9622916c5717555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1de4b65d2a88e88201026485f9622916c5717555", "html_url": "https://github.com/rust-lang/rust/commit/1de4b65d2a88e88201026485f9622916c5717555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1de4b65d2a88e88201026485f9622916c5717555/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8767093eb98358a1d62a934a58e1c89c72223cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8767093eb98358a1d62a934a58e1c89c72223cd6", "html_url": "https://github.com/rust-lang/rust/commit/8767093eb98358a1d62a934a58e1c89c72223cd6"}], "stats": {"total": 566, "additions": 275, "deletions": 291}, "files": [{"sha": "ba83ad8d37c9a77dfd901f4eae13afbc97b210c8", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -425,8 +425,8 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Leaf<K, V> {\n     ///Returns a string representation of a Leaf.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \" // \")) }\n-            try!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f, \" // \")) }\n+            try!(write!(f, \"{}\", *s))\n         }\n         Ok(())\n     }\n@@ -654,10 +654,10 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Branch<K, V> {\n     ///Returns a string representation of a Branch.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, s) in self.elts.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \" // \")) }\n-            try!(write!(f.buf, \"{}\", *s))\n+            if i != 0 { try!(write!(f, \" // \")) }\n+            try!(write!(f, \"{}\", *s))\n         }\n-        write!(f.buf, \" // rightmost child: ({}) \", *self.rightmost_child)\n+        write!(f, \" // rightmost child: ({}) \", *self.rightmost_child)\n     }\n }\n \n@@ -715,7 +715,7 @@ impl<K: TotalOrd, V: TotalEq> TotalOrd for LeafElt<K, V> {\n impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for LeafElt<K, V> {\n     ///Returns a string representation of a LeafElt.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Key: {}, value: {};\", self.key, self.value)\n+        write!(f, \"Key: {}, value: {};\", self.key, self.value)\n     }\n }\n \n@@ -765,7 +765,7 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for BranchElt<K, V> {\n     /// Returns string containing key, value, and child (which should recur to a\n     /// leaf) Consider changing in future to be more readable.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Key: {}, value: {}, (child: {})\",\n+        write!(f, \"Key: {}, value: {}, (child: {})\",\n                self.key, self.value, *self.left)\n     }\n }"}, {"sha": "4259f458e00643baacdd6ac9fb2435d4390a025c", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -1418,14 +1418,14 @@ impl<K: TotalEq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n \n impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \", \")); }\n-            try!(write!(f.buf, \"{}: {}\", *k, *v));\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}: {}\", *k, *v));\n         }\n \n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n \n@@ -1605,14 +1605,14 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n \n         for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f.buf, \", \")); }\n-            try!(write!(f.buf, \"{}\", *x));\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n         }\n \n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n "}, {"sha": "8fdc0e095bf411096cb4caa6bc162fb4182d2e65", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -205,20 +205,20 @@ impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"));\n+        try!(write!(f, r\"\\{\"));\n         let mut cur = self.head;\n         for i in range(0, self.len()) {\n-            if i > 0 { try!(write!(f.buf, \", \")) }\n+            if i > 0 { try!(write!(f, \", \")) }\n             unsafe {\n                 cur = (*cur).next;\n-                try!(write!(f.buf, \"{}\", (*cur).key));\n+                try!(write!(f, \"{}\", (*cur).key));\n             }\n-            try!(write!(f.buf, \": \"));\n+            try!(write!(f, \": \"));\n             unsafe {\n-                try!(write!(f.buf, \"{}\", (*cur).value));\n+                try!(write!(f, \"{}\", (*cur).value));\n             }\n         }\n-        write!(f.buf, r\"\\}\")\n+        write!(f, r\"\\}\")\n     }\n }\n "}, {"sha": "2c6b0af8d94e6b34d2bc62d809c519c4ae90b11d", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -35,7 +35,7 @@ pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Signed, Unsigned};\n+pub use num::{Signed, Unsigned, Float};\n pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n pub use ptr::RawPtr;\n pub use str::{Str, StrSlice};"}, {"sha": "1921eef9f60d46d4d6fa28dc2f22485265ac0e7a", "filename": "src/libgreen/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -51,11 +51,9 @@ macro_rules! rtabort (\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io;\n     use std::rt;\n-\n     let mut w = rt::Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "5981f87b4f2b6fbe988a7ea5fbc762d75ac5fae8", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -188,7 +188,7 @@ impl fmt::Show for LogLevel {\n impl fmt::Signed for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n-        write!(fmt.buf, \"{}\", level)\n+        write!(fmt, \"{}\", level)\n     }\n }\n "}, {"sha": "ecc48d5569c0e20a3a91f6be9a7c811893d9f67b", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -120,7 +120,7 @@ impl Default for BigUint {\n \n impl fmt::Show for BigUint {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_str_radix(10))\n+        write!(f, \"{}\", self.to_str_radix(10))\n     }\n }\n \n@@ -843,7 +843,7 @@ impl Default for BigInt {\n \n impl fmt::Show for BigInt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_str_radix(10))\n+        write!(f, \"{}\", self.to_str_radix(10))\n     }\n }\n "}, {"sha": "3bc2408188da00b66dab362f53261a076960c6ea", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -171,9 +171,9 @@ impl<T: Clone + Num> One for Complex<T> {\n impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.im < Zero::zero() {\n-            write!(f.buf, \"{}-{}i\", self.re, -self.im)\n+            write!(f, \"{}-{}i\", self.re, -self.im)\n         } else {\n-            write!(f.buf, \"{}+{}i\", self.re, self.im)\n+            write!(f, \"{}+{}i\", self.re, self.im)\n         }\n     }\n }"}, {"sha": "cd5c82acf6e9a17fb11f9395371123231a0b05a9", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -276,7 +276,7 @@ impl<T: Clone + Integer + Ord>\n impl<T: fmt::Show> fmt::Show for Ratio<T> {\n     /// Renders as `numer/denom`.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}/{}\", self.numer, self.denom)\n+        write!(f, \"{}/{}\", self.numer, self.denom)\n     }\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {"}, {"sha": "a695da9fa163e6cc592c585672eaf0f605beffde", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -37,7 +37,7 @@ pub struct Error {\n \n impl fmt::Show for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"Regex syntax error near position {}: {}\",\n+        write!(f, \"Regex syntax error near position {}: {}\",\n                self.pos, self.msg)\n     }\n }"}, {"sha": "899c54d601bdb1a9625e23e10db35fda4595e74f", "filename": "src/libregex/re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -117,7 +117,7 @@ pub struct Regex {\n impl fmt::Show for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.original)\n+        write!(f, \"{}\", self.original)\n     }\n }\n "}, {"sha": "c885fc49de25f7009e8321d5828f92d4a8659f52", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -15,9 +15,7 @@\n \n use std::cell::RefCell;\n use collections::HashMap;\n-use std::io;\n use std::io::MemWriter;\n-use std::fmt;\n \n use middle::ty::param_ty;\n use middle::ty;\n@@ -28,9 +26,7 @@ use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n \n-macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n-    format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n-) )\n+macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n \n pub struct ctxt<'a> {\n     pub diag: &'a SpanHandler,\n@@ -52,10 +48,6 @@ pub struct ty_abbrev {\n \n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n-fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n-    fmt::write(&mut *w as &mut io::Writer, fmt);\n-}\n-\n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs.borrow_mut().find(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }"}, {"sha": "1954c6d4123eebb92f7fa440ea72142f5a19ada5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -183,13 +183,13 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n impl fmt::Show for LiveNode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"ln({})\", self.get())\n+        write!(f, \"ln({})\", self.get())\n     }\n }\n \n impl fmt::Show for Variable {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"v({})\", self.get())\n+        write!(f, \"v({})\", self.get())\n     }\n }\n "}, {"sha": "517be1bde2f3a980ecb45115a643cc3d789bbb40", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -388,7 +388,7 @@ pub struct t { inner: *t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write_str(\"*t_opaque\")\n+        \"*t_opaque\".fmt(f)\n     }\n }\n \n@@ -912,7 +912,7 @@ impl Vid for TyVid {\n \n impl fmt::Show for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n-        write!(f.buf, \"<generic \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -922,7 +922,7 @@ impl Vid for IntVid {\n \n impl fmt::Show for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"<generic integer \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic integer \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -932,7 +932,7 @@ impl Vid for FloatVid {\n \n impl fmt::Show for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"<generic float \\\\#{}>\", self.to_uint())\n+        write!(f, \"<generic float \\\\#{}>\", self.to_uint())\n     }\n }\n \n@@ -949,7 +949,7 @@ impl fmt::Show for RegionVid {\n impl fmt::Show for FnSig {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // grr, without tcx not much we can do.\n-        write!(f.buf, \"(...)\")\n+        write!(f, \"(...)\")\n     }\n }\n \n@@ -1987,7 +1987,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl fmt::Show for TypeContents {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"TypeContents({:t})\", self.bits)\n+        write!(f, \"TypeContents({:t})\", self.bits)\n     }\n }\n "}, {"sha": "42850f8876338d002114ee3b88ef054e40022258", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -240,9 +240,9 @@ enum VarianceTerm<'a> {\n impl<'a> fmt::Show for VarianceTerm<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ConstantTerm(c1) => write!(f.buf, \"{}\", c1),\n-            TransformTerm(v1, v2) => write!(f.buf, \"({} \\u00D7 {})\", v1, v2),\n-            InferredTerm(id) => write!(f.buf, \"[{}]\", { let InferredIndex(i) = id; i })\n+            ConstantTerm(c1) => write!(f, \"{}\", c1),\n+            TransformTerm(v1, v2) => write!(f, \"({} \\u00D7 {})\", v1, v2),\n+            InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n         }\n     }\n }"}, {"sha": "fe93dbbc081f8b688963eb8e9461073c62057ded", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n+                    try!(fmt.write(pile_o_bits.slice(last, i).as_bytes()));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    try!(fmt.buf.write(s.as_bytes()));\n+                    try!(fmt.write(s.as_bytes()));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            try!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n+            try!(fmt.write(pile_o_bits.slice_from(last).as_bytes()));\n         }\n         Ok(())\n     }"}, {"sha": "7b8021976159e007df78214667e687f91a51bcae", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -16,7 +16,6 @@\n //! them in the future to instead emit any format desired.\n \n use std::fmt;\n-use std::io;\n use std::strbuf::StrBuf;\n \n use syntax::ast;\n@@ -52,46 +51,46 @@ impl FnStyleSpace {\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n-        try!(f.buf.write(\"&lt;\".as_bytes()));\n+        try!(f.write(\"&lt;\".as_bytes()));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                try!(f.buf.write(\", \".as_bytes()));\n+                try!(f.write(\", \".as_bytes()));\n             }\n-            try!(write!(f.buf, \"{}\", *life));\n+            try!(write!(f, \"{}\", *life));\n         }\n \n         if self.type_params.len() > 0 {\n             if self.lifetimes.len() > 0 {\n-                try!(f.buf.write(\", \".as_bytes()));\n+                try!(f.write(\", \".as_bytes()));\n             }\n \n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.buf.write(\", \".as_bytes()))\n+                    try!(f.write(\", \".as_bytes()))\n                 }\n-                try!(f.buf.write(tp.name.as_bytes()));\n+                try!(f.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    try!(f.buf.write(\": \".as_bytes()));\n+                    try!(f.write(\": \".as_bytes()));\n                     for (i, bound) in tp.bounds.iter().enumerate() {\n                         if i > 0 {\n-                            try!(f.buf.write(\" + \".as_bytes()));\n+                            try!(f.write(\" + \".as_bytes()));\n                         }\n-                        try!(write!(f.buf, \"{}\", *bound));\n+                        try!(write!(f, \"{}\", *bound));\n                     }\n                 }\n             }\n         }\n-        try!(f.buf.write(\"&gt;\".as_bytes()));\n+        try!(f.write(\"&gt;\".as_bytes()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.buf.write(\"'\".as_bytes()));\n-        try!(f.buf.write(self.get_ref().as_bytes()));\n+        try!(f.write(\"'\".as_bytes()));\n+        try!(f.write(self.get_ref().as_bytes()));\n         Ok(())\n     }\n }\n@@ -100,10 +99,10 @@ impl fmt::Show for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::RegionBound => {\n-                f.buf.write(\"'static\".as_bytes())\n+                f.write(\"::\".as_bytes())\n             }\n             clean::TraitBound(ref ty) => {\n-                write!(f.buf, \"{}\", *ty)\n+                write!(f, \"{}\", *ty)\n             }\n         }\n     }\n@@ -112,32 +111,33 @@ impl fmt::Show for clean::TyParamBound {\n impl fmt::Show for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            try!(f.buf.write(\"::\".as_bytes()))\n+            try!(f.write(\"::\".as_bytes()))\n         }\n+\n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                try!(f.buf.write(\"::\".as_bytes()))\n+                try!(f.write(\"::\".as_bytes()))\n             }\n-            try!(f.buf.write(seg.name.as_bytes()));\n+            try!(f.write(seg.name.as_bytes()));\n \n             if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                try!(f.buf.write(\"&lt;\".as_bytes()));\n+                try!(f.write(\"&lt;\".as_bytes()));\n                 let mut comma = false;\n                 for lifetime in seg.lifetimes.iter() {\n                     if comma {\n-                        try!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    try!(write!(f.buf, \"{}\", *lifetime));\n+                    try!(write!(f, \"{}\", *lifetime));\n                 }\n                 for ty in seg.types.iter() {\n                     if comma {\n-                        try!(f.buf.write(\", \".as_bytes()));\n+                        try!(f.write(\", \".as_bytes()));\n                     }\n                     comma = true;\n-                    try!(write!(f.buf, \"{}\", *ty));\n+                    try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.buf.write(\"&gt;\".as_bytes()));\n+                try!(f.write(\"&gt;\".as_bytes()));\n             }\n         }\n         Ok(())\n@@ -146,7 +146,7 @@ impl fmt::Show for clean::Path {\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n@@ -170,7 +170,7 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId, p: &clean::Path,\n         })\n }\n \n-fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n+fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[StrBuf]| -> Option<StrBuf>,\n         info: |&render::Cache| -> Option<(Vec<StrBuf> , ItemType)>)\n     -> fmt::Result\n@@ -264,7 +264,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n }\n \n /// Helper to render type parameters\n-fn tybounds(w: &mut io::Writer,\n+fn tybounds(w: &mut fmt::Formatter,\n             typarams: &Option<Vec<clean::TyParamBound> >) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n@@ -286,13 +286,13 @@ impl fmt::Show for clean::Type {\n         match *self {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 let m = cache_key.get().unwrap();\n-                f.buf.write(m.typarams.get(&id).as_bytes())\n+                f.write(m.typarams.get(&id).as_bytes())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path} => {\n-                try!(resolved_path(f.buf, did, path, false));\n+                try!(resolved_path(f, did, path, false));\n                 tybounds(f.buf, typarams)\n             }\n-            clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n+            clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n                     ast::TyInt(ast::TyI) => \"int\",\n@@ -312,11 +312,11 @@ impl fmt::Show for clean::Type {\n                     ast::TyBool => \"bool\",\n                     ast::TyChar => \"char\",\n                 };\n-                f.buf.write(s.as_bytes())\n+                f.write(s.as_bytes())\n             }\n             clean::Closure(ref decl, ref region) => {\n-                write!(f.buf, \"{style}{lifetimes}|{args}|{bounds}\\\n-                               {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}|{args}|{bounds}\\\n+                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_owned()\n@@ -351,8 +351,8 @@ impl fmt::Show for clean::Type {\n                        })\n             }\n             clean::Proc(ref decl) => {\n-                write!(f.buf, \"{style}{lifetimes}proc({args}){bounds}\\\n-                               {arrow, select, yes{ -&gt; {ret}} other{}}\",\n+                write!(f, \"{style}{lifetimes}proc({args}){bounds}\\\n+                           {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_strbuf()\n@@ -374,7 +374,7 @@ impl fmt::Show for clean::Type {\n                        ret = decl.decl.output)\n             }\n             clean::BareFunction(ref decl) => {\n-                write!(f.buf, \"{}{}fn{}{}\",\n+                write!(f, \"{}{}fn{}{}\",\n                        FnStyleSpace(decl.fn_style),\n                        match decl.abi.as_slice() {\n                            \"\" => \" extern \".to_strbuf(),\n@@ -385,35 +385,35 @@ impl fmt::Show for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                try!(f.buf.write(\"(\".as_bytes()));\n+                try!(f.write(\"(\".as_bytes()));\n                 for (i, typ) in typs.iter().enumerate() {\n                     if i > 0 {\n-                        try!(f.buf.write(\", \".as_bytes()))\n+                        try!(f.write(\", \".as_bytes()))\n                     }\n-                    try!(write!(f.buf, \"{}\", *typ));\n+                    try!(write!(f, \"{}\", *typ));\n                 }\n-                f.buf.write(\")\".as_bytes())\n+                f.write(\")\".as_bytes())\n             }\n-            clean::Vector(ref t) => write!(f.buf, \"[{}]\", **t),\n+            clean::Vector(ref t) => write!(f, \"[{}]\", **t),\n             clean::FixedVector(ref t, ref s) => {\n-                write!(f.buf, \"[{}, ..{}]\", **t, *s)\n-            }\n-            clean::String => f.buf.write(\"str\".as_bytes()),\n-            clean::Bool => f.buf.write(\"bool\".as_bytes()),\n-            clean::Unit => f.buf.write(\"()\".as_bytes()),\n-            clean::Bottom => f.buf.write(\"!\".as_bytes()),\n-            clean::Unique(ref t) => write!(f.buf, \"~{}\", **t),\n-            clean::Managed(ref t) => write!(f.buf, \"@{}\", **t),\n+                write!(f, \"[{}, ..{}]\", **t, *s)\n+            }\n+            clean::String => f.write(\"str\".as_bytes()),\n+            clean::Bool => f.write(\"bool\".as_bytes()),\n+            clean::Unit => f.write(\"()\".as_bytes()),\n+            clean::Bottom => f.write(\"!\".as_bytes()),\n+            clean::Unique(ref t) => write!(f, \"~{}\", **t),\n+            clean::Managed(ref t) => write!(f, \"@{}\", **t),\n             clean::RawPointer(m, ref t) => {\n-                write!(f.buf, \"*{}{}\",\n+                write!(f, \"*{}{}\",\n                        match m {\n                            clean::Mutable => \"mut \",\n                            clean::Immutable => \"\",\n                        }, **t)\n             }\n             clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n                 let lt = match *l { Some(ref l) => format!(\"{} \", *l), _ => \"\".to_owned() };\n-                write!(f.buf, \"&amp;{}{}{}\",\n+                write!(f, \"&amp;{}{}{}\",\n                        lt,\n                        match mutability {\n                            clean::Mutable => \"mut \",\n@@ -428,19 +428,19 @@ impl fmt::Show for clean::Type {\n impl fmt::Show for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n-            if i > 0 { try!(write!(f.buf, \", \")); }\n+            if i > 0 { try!(write!(f, \", \")); }\n             if input.name.len() > 0 {\n-                try!(write!(f.buf, \"{}: \", input.name));\n+                try!(write!(f, \"{}: \", input.name));\n             }\n-            try!(write!(f.buf, \"{}\", input.type_));\n+            try!(write!(f, \"{}\", input.type_));\n         }\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+        write!(f, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = self.inputs,\n                arrow = match self.output { clean::Unit => \"no\", _ => \"yes\" },\n                ret = self.output)\n@@ -475,7 +475,7 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_));\n         }\n-        write!(f.buf,\n+        write!(f,\n                \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n@@ -486,7 +486,7 @@ impl<'a> fmt::Show for Method<'a> {\n impl fmt::Show for VisSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n-            Some(ast::Public) => write!(f.buf, \"pub \"),\n+            Some(ast::Public) => write!(f, \"pub \"),\n             Some(ast::Inherited) | None => Ok(())\n         }\n     }\n@@ -495,7 +495,7 @@ impl fmt::Show for VisSpace {\n impl fmt::Show for FnStyleSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n-            ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n+            ast::UnsafeFn => write!(f, \"unsafe \"),\n             ast::NormalFn => Ok(())\n         }\n     }\n@@ -506,23 +506,23 @@ impl fmt::Show for clean::ViewPath {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n-                    write!(f.buf, \"use {};\", *src)\n+                    write!(f, \"use {};\", *src)\n                 } else {\n-                    write!(f.buf, \"use {} = {};\", *name, *src)\n+                    write!(f, \"use {} = {};\", *name, *src)\n                 }\n             }\n             clean::GlobImport(ref src) => {\n-                write!(f.buf, \"use {}::*;\", *src)\n+                write!(f, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                try!(write!(f.buf, \"use {}::\\\\{\", *src));\n+                try!(write!(f, \"use {}::\\\\{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f.buf, \", \"));\n+                        try!(write!(f, \", \"));\n                     }\n-                    try!(write!(f.buf, \"{}\", *n));\n+                    try!(write!(f, \"{}\", *n));\n                 }\n-                write!(f.buf, \"\\\\};\")\n+                write!(f, \"\\\\};\")\n             }\n         }\n     }\n@@ -531,13 +531,13 @@ impl fmt::Show for clean::ViewPath {\n impl fmt::Show for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f.buf, did, &self.path, true),\n+            Some(did) => resolved_path(f, did, &self.path, true),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f.buf, \"::\"))\n+                        try!(write!(f, \"::\"))\n                     }\n-                    try!(write!(f.buf, \"{}\", seg.name));\n+                    try!(write!(f, \"{}\", seg.name));\n                 }\n                 Ok(())\n             }\n@@ -557,9 +557,9 @@ impl fmt::Show for clean::ViewListIdent {\n                         types: Vec::new(),\n                     })\n                 };\n-                resolved_path(f.buf, did, &path, false)\n+                resolved_path(f, did, &path, false)\n             }\n-            _ => write!(f.buf, \"{}\", self.name),\n+            _ => write!(f, \"{}\", self.name),\n         }\n     }\n }"}, {"sha": "dd465df1db7e4a3f5c1d217dff7d02d88b5308dc", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -26,7 +26,7 @@ pub struct Page<'a> {\n \n pub fn render<T: fmt::Show, S: fmt::Show>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n-    -> fmt::Result\n+    -> io::IoResult<()>\n {\n     write!(dst,\n r##\"<!DOCTYPE html>"}, {"sha": "b64e77615e1f5905f1632d5971b3bd1de453f064", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -29,7 +29,6 @@\n use libc;\n use std::cell::RefCell;\n use std::fmt;\n-use std::io;\n use std::slice;\n use std::str;\n use collections::HashMap;\n@@ -141,7 +140,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n \n local_data_key!(used_header_map: RefCell<HashMap<StrBuf, uint>>)\n \n-pub fn render(w: &mut io::Writer, s: &str, print_toc: bool) -> fmt::Result {\n+pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n                     lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n@@ -355,13 +354,13 @@ impl<'a> fmt::Show for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return Ok(()) }\n-        render(fmt.buf, md.as_slice(), false)\n+        render(fmt, md.as_slice(), false)\n     }\n }\n \n impl<'a> fmt::Show for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt.buf, md.as_slice(), true)\n+        render(fmt, md.as_slice(), true)\n     }\n }"}, {"sha": "8ae29d7d273c2d89ca03303d7e403507e534f17a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -587,7 +587,7 @@ impl<'a> SourceCollector<'a> {\n             root_path: root_path.as_slice(),\n         };\n         try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n-                              &page, &(\"\"), &Source(contents)));\n+                            &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n         return Ok(());\n     }\n@@ -925,8 +925,8 @@ impl Context {\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n             try!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                                  &Sidebar{ cx: cx, item: it },\n-                                  &Item{ cx: cx, item: it }));\n+                                &Sidebar{ cx: cx, item: it },\n+                                &Item{ cx: cx, item: it }));\n             writer.flush()\n         }\n \n@@ -997,17 +997,17 @@ impl<'a> Item<'a> {\n impl<'a> fmt::Show for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n-        try!(write!(fmt.buf, \"\\n<h1 class='fqn'>\"));\n+        try!(write!(fmt, \"\\n<h1 class='fqn'>\"));\n         match self.item.inner {\n             clean::ModuleItem(ref m) => if m.is_crate {\n-                    try!(write!(fmt.buf, \"Crate \"));\n+                    try!(write!(fmt, \"Crate \"));\n                 } else {\n-                    try!(write!(fmt.buf, \"Module \"));\n+                    try!(write!(fmt, \"Module \"));\n                 },\n-            clean::FunctionItem(..) => try!(write!(fmt.buf, \"Function \")),\n-            clean::TraitItem(..) => try!(write!(fmt.buf, \"Trait \")),\n-            clean::StructItem(..) => try!(write!(fmt.buf, \"Struct \")),\n-            clean::EnumItem(..) => try!(write!(fmt.buf, \"Enum \")),\n+            clean::FunctionItem(..) => try!(write!(fmt, \"Function \")),\n+            clean::TraitItem(..) => try!(write!(fmt, \"Trait \")),\n+            clean::StructItem(..) => try!(write!(fmt, \"Struct \")),\n+            clean::EnumItem(..) => try!(write!(fmt, \"Enum \")),\n             _ => {}\n         }\n         let cur = self.cx.current.as_slice();\n@@ -1017,16 +1017,16 @@ impl<'a> fmt::Show for Item<'a> {\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n-            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n-                          trail, component.as_slice()));\n+            try!(write!(fmt, \"<a href='{}index.html'>{}</a>::\",\n+                        trail, component.as_slice()));\n         }\n-        try!(write!(fmt.buf, \"<a class='{}' href=''>{}</a>\",\n-                      shortty(self.item), self.item.name.get_ref().as_slice()));\n+        try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+                    shortty(self.item), self.item.name.get_ref().as_slice()));\n \n         // Write stability attributes\n         match attr::find_stability(self.item.attrs.iter()) {\n             Some(ref stability) => {\n-                try!(write!(fmt.buf,\n+                try!(write!(fmt,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n@@ -1039,22 +1039,22 @@ impl<'a> fmt::Show for Item<'a> {\n \n         // Write `src` tag\n         if self.cx.include_sources {\n-            try!(write!(fmt.buf, \"<a class='source' href='{}'>[src]</a>\",\n+            try!(write!(fmt, \"<a class='source' href='{}'>[src]</a>\",\n                         self.link()));\n         }\n-        try!(write!(fmt.buf, \"</h1>\\n\"));\n+        try!(write!(fmt, \"</h1>\\n\"));\n \n         match self.item.inner {\n             clean::ModuleItem(ref m) => {\n-                item_module(fmt.buf, self.cx, self.item, m.items.as_slice())\n+                item_module(fmt, self.cx, self.item, m.items.as_slice())\n             }\n             clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-                item_function(fmt.buf, self.item, f),\n-            clean::TraitItem(ref t) => item_trait(fmt.buf, self.item, t),\n-            clean::StructItem(ref s) => item_struct(fmt.buf, self.item, s),\n-            clean::EnumItem(ref e) => item_enum(fmt.buf, self.item, e),\n-            clean::TypedefItem(ref t) => item_typedef(fmt.buf, self.item, t),\n-            clean::MacroItem(ref m) => item_macro(fmt.buf, self.item, m),\n+                item_function(fmt, self.item, f),\n+            clean::TraitItem(ref t) => item_trait(fmt, self.item, t),\n+            clean::StructItem(ref s) => item_struct(fmt, self.item, s),\n+            clean::EnumItem(ref e) => item_enum(fmt, self.item, e),\n+            clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n+            clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n             _ => Ok(())\n         }\n     }\n@@ -1097,7 +1097,7 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n+fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     match item.doc_value() {\n         Some(s) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n@@ -1107,7 +1107,7 @@ fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn item_module(w: &mut Writer, cx: &Context,\n+fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     debug!(\"{:?}\", items);\n@@ -1196,13 +1196,12 @@ fn item_module(w: &mut Writer, cx: &Context,\n                     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                         let Initializer(s, item) = *self;\n                         if s.len() == 0 { return Ok(()); }\n-                        try!(write!(f.buf, \"<code> = </code>\"));\n+                        try!(write!(f, \"<code> = </code>\"));\n                         if s.contains(\"\\n\") {\n-                            write!(f.buf,\n-                                   \"<a href='{}'>[definition]</a>\",\n+                            write!(f, \"<a href='{}'>[definition]</a>\",\n                                    item.link())\n                         } else {\n-                            write!(f.buf, \"<code>{}</code>\", s.as_slice())\n+                            write!(f, \"<code>{}</code>\", s.as_slice())\n                         }\n                     }\n                 }\n@@ -1262,7 +1261,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n     write!(w, \"</table>\")\n }\n \n-fn item_function(w: &mut Writer, it: &clean::Item,\n+fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust fn'>{vis}{fn_style}fn \\\n                     {name}{generics}{decl}</pre>\",\n@@ -1274,7 +1273,7 @@ fn item_function(w: &mut Writer, it: &clean::Item,\n     document(w, it)\n }\n \n-fn item_trait(w: &mut Writer, it: &clean::Item,\n+fn item_trait(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut parents = StrBuf::new();\n     if t.parents.len() > 0 {\n@@ -1318,7 +1317,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn meth(w: &mut Writer, m: &clean::TraitMethod) -> fmt::Result {\n+    fn meth(w: &mut fmt::Formatter, m: &clean::TraitMethod) -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n                       shortty(m.item()),\n                       *m.item().name.get_ref()));\n@@ -1374,8 +1373,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n-    fn fun(w: &mut Writer, it: &clean::Item, fn_style: ast::FnStyle,\n+fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n+    fn fun(w: &mut fmt::Formatter, it: &clean::Item, fn_style: ast::FnStyle,\n            g: &clean::Generics, selfty: &clean::SelfTy,\n            d: &clean::FnDecl) -> fmt::Result {\n         write!(w, \"{}fn <a href='\\\\#{ty}.{name}' class='fnname'>{name}</a>\\\n@@ -1400,7 +1399,7 @@ fn render_method(w: &mut Writer, meth: &clean::Item) -> fmt::Result {\n     }\n }\n \n-fn item_struct(w: &mut Writer, it: &clean::Item,\n+fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust struct'>\"));\n     try!(render_struct(w,\n@@ -1437,7 +1436,8 @@ fn item_struct(w: &mut Writer, it: &clean::Item,\n     render_methods(w, it)\n }\n \n-fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n+fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n+             e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>{}enum {}{}\",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n@@ -1533,7 +1533,7 @@ fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_struct(w: &mut Writer, it: &clean::Item,\n+fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n@@ -1597,7 +1597,7 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n+fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache_key.get().unwrap().impls.find(&it.id) {\n         Some(v) => {\n             let mut non_trait = v.iter().filter(|p| {\n@@ -1642,7 +1642,7 @@ fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_impl(w: &mut Writer, i: &clean::Impl,\n+fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n                dox: &Option<StrBuf>) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n@@ -1664,8 +1664,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n         None => {}\n     }\n \n-    fn docmeth(w: &mut Writer, item: &clean::Item,\n-               dox: bool) -> io::IoResult<()> {\n+    fn docmeth(w: &mut fmt::Formatter, item: &clean::Item,\n+               dox: bool) -> fmt::Result {\n         try!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n                       *item.name.get_ref()));\n         try!(render_method(w, item));\n@@ -1714,7 +1714,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl,\n     Ok(())\n }\n \n-fn item_typedef(w: &mut Writer, it: &clean::Item,\n+fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n                   it.name.get_ref().as_slice(),\n@@ -1728,21 +1728,21 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n-        try!(write!(fmt.buf, \"<p class='location'>\"));\n+        try!(write!(fmt, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n             if i > 0 {\n-                try!(write!(fmt.buf, \"&\\\\#8203;::\"));\n+                try!(write!(fmt, \"&\\\\#8203;::\"));\n             }\n-            try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n+            try!(write!(fmt, \"<a href='{}index.html'>{}</a>\",\n                           cx.root_path\n                             .as_slice()\n                             .slice_to((cx.current.len() - i - 1) * 3),\n                           *name));\n         }\n-        try!(write!(fmt.buf, \"</p>\"));\n+        try!(write!(fmt, \"</p>\"));\n \n-        fn block(w: &mut Writer, short: &str, longty: &str,\n+        fn block(w: &mut fmt::Formatter, short: &str, longty: &str,\n                  cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),\n@@ -1770,12 +1770,12 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             Ok(())\n         }\n \n-        try!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n-        try!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n-        try!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n-        try!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n-        try!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n-        try!(block(fmt.buf, \"macro\", \"Macros\", it, cx));\n+        try!(block(fmt, \"mod\", \"Modules\", it, cx));\n+        try!(block(fmt, \"struct\", \"Structs\", it, cx));\n+        try!(block(fmt, \"enum\", \"Enums\", it, cx));\n+        try!(block(fmt, \"trait\", \"Traits\", it, cx));\n+        try!(block(fmt, \"fn\", \"Functions\", it, cx));\n+        try!(block(fmt, \"macro\", \"Macros\", it, cx));\n         Ok(())\n     }\n }\n@@ -1808,19 +1808,18 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        try!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n+        try!(write!(fmt, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            try!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n+            try!(write!(fmt, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n-        try!(write!(fmt.buf, \"</pre>\"));\n-        try!(write!(fmt.buf, \"{}\", highlight::highlight(s.as_slice(), None)));\n+        try!(write!(fmt, \"</pre>\"));\n+        try!(write!(fmt, \"{}\", highlight::highlight(s.as_slice(), None)));\n         Ok(())\n     }\n }\n \n-fn item_macro(w: &mut Writer, it: &clean::Item,\n+fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n-                                          Some(\"macro\")).as_slice()));\n+    try!(w.write(highlight::highlight(t.source.as_slice(), Some(\"macro\")).as_bytes()));\n     document(w, it)\n }"}, {"sha": "4dabdf64f8102da691d785e5ead46326bacb6165", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -174,17 +174,17 @@ impl TocBuilder {\n \n impl fmt::Show for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt.buf, \"<ul>\"));\n+        try!(write!(fmt, \"<ul>\"));\n         for entry in self.entries.iter() {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n-            try!(write!(fmt.buf,\n+            try!(write!(fmt,\n                         \"\\n<li><a href=\\\"\\\\#{id}\\\">{num} {name}</a>{children}</li>\",\n                         id = entry.id,\n                         num = entry.sec_number, name = entry.name,\n                         children = entry.children))\n         }\n-        write!(fmt.buf, \"</ul>\")\n+        write!(fmt, \"</ul>\")\n     }\n }\n "}, {"sha": "141e3e515ac96ab9f759f8ffd5597205a6c8c366", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -379,7 +379,7 @@ impl UvError {\n \n impl fmt::Show for UvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}: {}\", self.name(), self.desc())\n+        write!(f, \"{}: {}\", self.name(), self.desc())\n     }\n }\n "}, {"sha": "deb7036848f96413bd1c26c7038f8eebda416f9e", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -28,9 +28,7 @@ macro_rules! uvdebug (\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io;\n     use std::rt;\n-\n     let mut w = rt::Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }"}, {"sha": "2f1d59b23a280b8326a68eee0ecb245d8668ed00", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -96,18 +96,18 @@ pub struct Version {\n impl fmt::Show for Version {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}.{}.{}\", self.major, self.minor, self.patch))\n+        try!(write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch))\n         if !self.pre.is_empty() {\n-            try!(write!(f.buf, \"-\"));\n+            try!(write!(f, \"-\"));\n             for (i, x) in self.pre.iter().enumerate() {\n-                if i != 0 { try!(write!(f.buf, \".\")) };\n+                if i != 0 { try!(write!(f, \".\")) };\n                 try!(x.fmt(f));\n             }\n         }\n         if !self.build.is_empty() {\n-            try!(write!(f.buf, \"+\"));\n+            try!(write!(f, \"+\"));\n             for (i, x) in self.build.iter().enumerate() {\n-                if i != 0 { try!(write!(f.buf, \".\")) };\n+                if i != 0 { try!(write!(f, \".\")) };\n                 try!(x.fmt(f));\n             }\n         }"}, {"sha": "5ed778b49ebdd99367defc3a32f1b54b99d271db", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -170,8 +170,8 @@ impl fmt::Show for FromBase64Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidBase64Character(ch, idx) =>\n-                write!(f.buf, \"Invalid character '{}' at position {}\", ch, idx),\n-            InvalidBase64Length => write!(f.buf, \"Invalid length\"),\n+                write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidBase64Length => write!(f, \"Invalid length\"),\n         }\n     }\n }"}, {"sha": "623bf85424a289faec8ac88fa3c1b943f114bfcb", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -69,8 +69,8 @@ impl fmt::Show for FromHexError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n-                write!(f.buf, \"Invalid character '{}' at position {}\", ch, idx),\n-            InvalidHexLength => write!(f.buf, \"Invalid input length\"),\n+                write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n+            InvalidHexLength => write!(f, \"Invalid input length\"),\n         }\n     }\n }"}, {"sha": "17a864d286232b12ee1b7281babfea4bb57d757c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -2267,7 +2267,7 @@ impl<A:ToJson> ToJson for Option<A> {\n impl fmt::Show for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f.buf)\n+        self.to_writer(f).map_err(|_| fmt::WriteError)\n     }\n }\n "}, {"sha": "6b3939872811d4874af371baa2b120aeaf221201", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -59,7 +59,7 @@\n //!\n //! impl fmt::Show for Flags {\n //!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f.buf, \"hi!\")\n+//!         write!(f, \"hi!\")\n //!     }\n //! }\n //!"}, {"sha": "c6885c6b4be7379b5cf7639c5d6d91782702a1d3", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -549,7 +549,7 @@ pub trait Poly {\n /// ```\n pub fn format(args: &Arguments) -> ~str {\n     let mut output = io::MemWriter::new();\n-    output.write_fmt(args).unwrap();\n+    let _ = write!(&mut output, \"{}\", args);\n     str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned()\n }\n "}, {"sha": "2880365cf348f5c6a15f63988af56ded515bb8b9", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -16,7 +16,7 @@ use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;"}, {"sha": "a043722581ba26d337d839bfed215c293b41a312", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -381,9 +381,9 @@ impl IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(fmt.buf.write_str(self.desc));\n+        try!(write!(fmt, \"{}\", self.desc));\n         match self.detail {\n-            Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n+            Some(ref s) => write!(fmt, \" ({})\", *s),\n             None => Ok(())\n         }\n     }"}, {"sha": "f469c419e8ef7962b0994a7a8f1c8082aed5fd1b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -35,22 +35,22 @@ impl fmt::Show for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Ipv4Addr(a, b, c, d) =>\n-                write!(fmt.buf, \"{}.{}.{}.{}\", a, b, c, d),\n+                write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n \n             // Ipv4 Compatible address\n             Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n-                write!(fmt.buf, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n                        (h >> 8) as u8, h as u8)\n             }\n \n             // Ipv4-Mapped address\n             Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n-                write!(fmt.buf, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                write!(fmt, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n                        (h >> 8) as u8, h as u8)\n             }\n \n             Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-                write!(fmt.buf, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n+                write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n                        a, b, c, d, e, f, g, h)\n         }\n     }\n@@ -65,8 +65,8 @@ pub struct SocketAddr {\n impl fmt::Show for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {\n-            Ipv4Addr(..) => write!(f.buf, \"{}:{}\", self.ip, self.port),\n-            Ipv6Addr(..) => write!(f.buf, \"[{}]:{}\", self.ip, self.port),\n+            Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),\n+            Ipv6Addr(..) => write!(f, \"[{}]:{}\", self.ip, self.port),\n         }\n     }\n }"}, {"sha": "875dd01be823bfcf6f99bb6235824a98e2f65b61", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -384,8 +384,6 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n-        use result::ResultUnwrap;\n-\n         let server = UdpSocket::bind(addr);\n \n         assert!(server.is_ok());"}, {"sha": "88ed7e9c0d3f0f16db0fd66daf8c091bc2d1f29d", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -361,8 +361,8 @@ impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n-            ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n+            ExitStatus(code) =>  write!(f, \"exit code: {}\", code),\n+            ExitSignal(code) =>  write!(f, \"signal: {}\", code),\n         }\n     }\n }"}, {"sha": "e6d416164d008831ad2af668ba3154916f7298d5", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -36,7 +36,7 @@ use mem::replace;\n use option::{Option, Some, None};\n use owned::Box;\n use prelude::drop;\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n@@ -276,13 +276,13 @@ pub fn println(s: &str) {\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| fmt::write(io, fmt))\n+    with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {\n-    with_task_stdout(|io| fmt::writeln(io, fmt))\n+    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n \n /// Representation of a reader of a standard input stream"}, {"sha": "b260f685a34777fbe488d49044d18bff81f64a51", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -269,10 +269,9 @@ macro_rules! write(\n /// the message is written.\n #[macro_export]\n macro_rules! writeln(\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => ({\n-        format_args!(|args| { $dst.write_fmt(args) },\n-                     concat!($fmt, \"\\n\") $($arg)*)\n-    })\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n )\n \n /// Equivalent to the `println!` macro except that a newline is not printed at"}, {"sha": "c2ec5c75fc134e543d6110e1d7f9ccc1af6912d9", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -820,7 +820,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -857,7 +856,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -894,7 +892,6 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use f64;\n-        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn float_to_str(b: &mut Bencher) {"}, {"sha": "a4705b78caab7419c9a53e3727c095a9dcfc2340", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -1073,19 +1073,19 @@ impl fmt::Show for MapError {\n             ErrAlreadyExists => \"File mapping for specified file already exists\",\n             ErrZeroLength => \"Zero-length mapping not allowed\",\n             ErrUnknown(code) => {\n-                return write!(out.buf, \"Unknown error = {}\", code)\n+                return write!(out, \"Unknown error = {}\", code)\n             },\n             ErrVirtualAlloc(code) => {\n-                return write!(out.buf, \"VirtualAlloc failure = {}\", code)\n+                return write!(out, \"VirtualAlloc failure = {}\", code)\n             },\n             ErrCreateFileMappingW(code) => {\n-                return write!(out.buf, \"CreateFileMappingW failure = {}\", code)\n+                return write!(out, \"CreateFileMappingW failure = {}\", code)\n             },\n             ErrMapViewOfFile(code) => {\n-                return write!(out.buf, \"MapViewOfFile failure = {}\", code)\n+                return write!(out, \"MapViewOfFile failure = {}\", code)\n             }\n         };\n-        write!(out.buf, \"{}\", str)\n+        write!(out, \"{}\", str)\n     }\n }\n "}, {"sha": "35f32d0872802d3e3b8ad11b869d08022c5ba4d2", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -25,7 +25,7 @@ use option::{Some, None, Option};\n use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n-use result::{Ok, Err, ResultUnwrap};\n+use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n use slice::Vector;"}, {"sha": "1cc513825a707e50831692cd7af452d8b70cb442", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -390,9 +390,9 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n                 Some(mut stderr) => {\n                     Local::put(task);\n                     // FIXME: what to do when the task printing fails?\n-                    let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n-                                            \"task '{}' failed at '{}', {}:{}\",\n-                                            n, msg_s, file, line);\n+                    let _err = write!(stderr,\n+                                      \"task '{}' failed at '{}', {}:{}\\n\",\n+                                      n, msg_s, file, line);\n                     if backtrace::log_enabled() {\n                         let _err = backtrace::write(stderr);\n                     }"}, {"sha": "5f9ea14a64711467c432ea1474a4d09b7c5e493a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -110,8 +110,9 @@ impl io::Writer for Stdio {\n }\n \n pub fn dumb_println(args: &fmt::Arguments) {\n+    use io::Writer;\n     let mut w = Stderr;\n-    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = writeln!(&mut w, \"{}\", args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "bc53d2bec8d6e3ca2b7004af7c940b2fd9f735cf", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -155,7 +155,7 @@ impl Architecture {\n \n impl fmt::Show for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"\\\"{}\\\"\", self.name())\n+        write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }\n "}, {"sha": "edcb8c32ecc40dc2b3dec63d81fa495efb9d8779", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -711,7 +711,7 @@ pub enum IntTy {\n \n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\",\n+        write!(f, \"{}\",\n                ast_util::int_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n@@ -727,7 +727,7 @@ pub enum UintTy {\n \n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\",\n+        write!(f, \"{}\",\n                ast_util::uint_ty_to_str(*self, None, ast_util::AutoSuffix))\n     }\n }\n@@ -741,7 +741,7 @@ pub enum FloatTy {\n \n impl fmt::Show for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", ast_util::float_ty_to_str(*self))\n+        write!(f, \"{}\", ast_util::float_ty_to_str(*self))\n     }\n }\n "}, {"sha": "f1561ea31f91bcae60fe5f511e09c5c58a332f91", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -41,7 +41,7 @@ impl PathElem {\n impl fmt::Show for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let slot = token::get_name(self.name());\n-        write!(f.buf, \"{}\", slot)\n+        write!(f, \"{}\", slot)\n     }\n }\n "}, {"sha": "b7700cf396d48dba6d2e3266ea70bcac685d5e53", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -33,16 +33,16 @@ pub struct CrateId {\n \n impl fmt::Show for CrateId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n         let version = match self.version {\n             None => \"0.0\",\n             Some(ref version) => version.as_slice(),\n         };\n         if self.path == self.name ||\n                 self.path.as_slice().ends_with(format!(\"/{}\", self.name)) {\n-            write!(f.buf, \"\\\\#{}\", version)\n+            write!(f, \"\\\\#{}\", version)\n         } else {\n-            write!(f.buf, \"\\\\#{}:{}\", self.name, version)\n+            write!(f, \"\\\\#{}:{}\", self.name, version)\n         }\n     }\n }"}, {"sha": "5dfd18392a9c0da2a8c1b53eeaeb76c2e221af9f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -594,7 +594,7 @@ impl BytesContainer for InternedString {\n \n impl fmt::Show for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.string.as_slice())\n+        write!(f, \"{}\", self.string.as_slice())\n     }\n }\n "}, {"sha": "5fc567f06d38d8fbed9fee6d5b4b7275bf6e9d2f", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -427,8 +427,8 @@ fn split_char_first(s: &str, c: char) -> (StrBuf, StrBuf) {\n impl fmt::Show for UserInfo {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.pass {\n-            Some(ref pass) => write!(f.buf, \"{}:{}@\", self.user, *pass),\n-            None => write!(f.buf, \"{}@\", self.user),\n+            Some(ref pass) => write!(f, \"{}:{}@\", self.user, *pass),\n+            None => write!(f, \"{}@\", self.user),\n         }\n     }\n }\n@@ -824,30 +824,30 @@ impl fmt::Show for Url {\n      * result in just \"http://somehost.com\".\n      */\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}:\", self.scheme));\n+        try!(write!(f, \"{}:\", self.scheme));\n \n         if !self.host.is_empty() {\n-            try!(write!(f.buf, \"//\"));\n+            try!(write!(f, \"//\"));\n             match self.user {\n-                Some(ref user) => try!(write!(f.buf, \"{}\", *user)),\n+                Some(ref user) => try!(write!(f, \"{}\", *user)),\n                 None => {}\n             }\n             match self.port {\n-                Some(ref port) => try!(write!(f.buf, \"{}:{}\", self.host,\n+                Some(ref port) => try!(write!(f, \"{}:{}\", self.host,\n                                                 *port)),\n-                None => try!(write!(f.buf, \"{}\", self.host)),\n+                None => try!(write!(f, \"{}\", self.host)),\n             }\n         }\n \n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n \n         if !self.query.is_empty() {\n-            try!(write!(f.buf, \"?{}\", query_to_str(&self.query)));\n+            try!(write!(f, \"?{}\", query_to_str(&self.query)));\n         }\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(()),\n         }\n@@ -856,14 +856,14 @@ impl fmt::Show for Url {\n \n impl fmt::Show for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"{}\", self.path));\n+        try!(write!(f, \"{}\", self.path));\n         if !self.query.is_empty() {\n-            try!(write!(f.buf, \"?{}\", self.query))\n+            try!(write!(f, \"?{}\", self.query))\n         }\n \n         match self.fragment {\n             Some(ref fragment) => {\n-                write!(f.buf, \"\\\\#{}\", encode_component(fragment.as_slice()))\n+                write!(f, \"\\\\#{}\", encode_component(fragment.as_slice()))\n             }\n             None => Ok(())\n         }"}, {"sha": "94f1239cc08465cfebe60f7fd3ecb98957a98d39", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -154,17 +154,17 @@ impl fmt::Show for ParseError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ErrorInvalidLength(found) =>\n-                write!(f.buf, \"Invalid length; expecting 32, 36 or 45 chars, \\\n-                               found {}\", found),\n+                write!(f, \"Invalid length; expecting 32, 36 or 45 chars, \\\n+                           found {}\", found),\n             ErrorInvalidCharacter(found, pos) =>\n-                write!(f.buf, \"Invalid character; found `{}` (0x{:02x}) at \\\n-                               offset {}\", found, found as uint, pos),\n+                write!(f, \"Invalid character; found `{}` (0x{:02x}) at \\\n+                           offset {}\", found, found as uint, pos),\n             ErrorInvalidGroups(found) =>\n-                write!(f.buf, \"Malformed; wrong number of groups: expected 1 \\\n-                               or 5, found {}\", found),\n+                write!(f, \"Malformed; wrong number of groups: expected 1 \\\n+                           or 5, found {}\", found),\n             ErrorInvalidGroupLength(group, found, expecting) =>\n-                write!(f.buf, \"Malformed; length of group {} was {}, \\\n-                               expecting {}\", group, found, expecting),\n+                write!(f, \"Malformed; length of group {} was {}, \\\n+                           expecting {}\", group, found, expecting),\n         }\n     }\n }\n@@ -474,7 +474,7 @@ impl FromStr for Uuid {\n /// Convert the UUID to a hexadecimal-based string representation\n impl fmt::Show for Uuid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.to_simple_str())\n+        write!(f, \"{}\", self.to_simple_str())\n     }\n }\n "}, {"sha": "c4c2f407423f5031c04f0bc529e804d8ae9e2e16", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -19,7 +19,7 @@ pub mod kitty {\n \n     impl fmt::Show for cat {\n         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f.buf, \"{}\", self.name)\n+            write!(f, \"{}\", self.name)\n         }\n     }\n "}, {"sha": "897717971bc1735e1e863d854b6e5ae0fa5c9438", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     format!(\"{:d}\", \"3\");\n-    //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n+    //~^ ERROR: failed to find an implementation of trait core::fmt::Signed\n }"}, {"sha": "753c91d1dc9580ffde569ad6e219f1294ca0ea94", "filename": "src/test/compile-fail/use-after-move-implicity-coerced-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-implicity-coerced-object.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -18,7 +18,7 @@ struct Number {\n \n impl fmt::Show for Number {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.n)\n+        write!(f, \"{}\", self.n)\n     }\n }\n "}, {"sha": "bb101140ec39351650e880b8e5b59794499e34d4", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -26,7 +26,7 @@ struct MyWriter(ChanWriter);\n impl Logger for MyWriter {\n     fn log(&mut self, record: &LogRecord) {\n         let MyWriter(ref mut inner) = *self;\n-        fmt::writeln(inner as &mut Writer, record.args);\n+        write!(inner, \"{}\", record.args);\n     }\n }\n \n@@ -45,5 +45,7 @@ fn main() {\n         debug!(\"debug\");\n         info!(\"info\");\n     });\n-    assert_eq!(r.read_to_str().unwrap(), \"info\\n\".to_owned());\n+    let s = r.read_to_str().unwrap();\n+    assert!(s.contains(\"info\"));\n+    assert!(!s.contains(\"debug\"));\n }"}, {"sha": "fdd44740d0531021b8ec20403ae95130f850064f", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -53,7 +53,7 @@ fn cat(in_x : uint, in_y : int, in_name: StrBuf) -> cat {\n \n impl fmt::Show for cat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.name)\n+        write!(f, \"{}\", self.name)\n     }\n }\n "}, {"sha": "e9b3251518743c0fe03013c4251bfed70fd63262", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(unused_must_use, dead_code)]\n+#![feature(macro_rules)]\n \n use std::io::MemWriter;\n "}, {"sha": "41650b680512977c99f7c45dfaf1608558e67628", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -36,7 +36,7 @@ struct J(Custom);\n struct Custom;\n impl fmt::Show for Custom {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"yay\")\n+        write!(f, \"yay\")\n     }\n }\n "}, {"sha": "ee142aa8e6dbcdd0240dd60c5ae71c970b1af0d5", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -25,12 +25,12 @@ struct B;\n \n impl fmt::Signed for A {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write(\"aloha\".as_bytes())\n+        f.write(\"aloha\".as_bytes())\n     }\n }\n impl fmt::Signed for B {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.buf.write(\"adios\".as_bytes())\n+        f.write(\"adios\".as_bytes())\n     }\n }\n \n@@ -195,9 +195,9 @@ fn test_format_args() {\n     let mut buf = MemWriter::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { fmt::write(w, args); }, \"{}\", 1);\n-        format_args!(|args| { fmt::write(w, args); }, \"test\");\n-        format_args!(|args| { fmt::write(w, args); }, \"{test}\", test=3);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1);\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n+        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3);\n     }\n     let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"1test3\");"}, {"sha": "2ce3cb931e5d9772b12ab7f6ed13dedc36465bee", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -29,7 +29,7 @@ enum square {\n \n impl fmt::Show for square {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", match *self {\n+        write!(f, \"{}\", match *self {\n           bot => { \"R\".to_owned() }\n           wall => { \"#\".to_owned() }\n           rock => { \"*\".to_owned() }"}, {"sha": "cdc07c026772e3bcff717ea5b00572717010c227", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -106,7 +106,7 @@ impl fmt::Show for AsciiArt {\n                               .collect::<Vec<StrBuf>>();\n \n         // Concatenate the lines together using a new-line.\n-        write!(f.buf, \"{}\", lines.connect(\"\\n\"))\n+        write!(f, \"{}\", lines.connect(\"\\n\"))\n     }\n }\n "}, {"sha": "7431340e413a9f78f8fd1bd5d263df722ca18ba0", "filename": "src/test/run-pass/new-impl-syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de4b65d2a88e88201026485f9622916c5717555/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-impl-syntax.rs?ref=1de4b65d2a88e88201026485f9622916c5717555", "patch": "@@ -17,7 +17,7 @@ struct Thingy {\n \n impl fmt::Show for Thingy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"\\\\{ x: {}, y: {} \\\\}\", self.x, self.y)\n+        write!(f, \"\\\\{ x: {}, y: {} \\\\}\", self.x, self.y)\n     }\n }\n \n@@ -27,7 +27,7 @@ struct PolymorphicThingy<T> {\n \n impl<T:fmt::Show> fmt::Show for PolymorphicThingy<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}\", self.x)\n+        write!(f, \"{}\", self.x)\n     }\n }\n "}]}