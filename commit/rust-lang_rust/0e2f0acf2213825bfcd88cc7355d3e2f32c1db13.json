{"sha": "0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMmYwYWNmMjIxMzgyNWJmY2Q4OGNjNzM1NWQzZTJmMzJjMWRiMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-06T07:37:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-06T07:37:19Z"}, "message": "auto merge of #17781 : P1start/rust/bitflags-lints, r=alexcrichton\n\nCloses #17773.", "tree": {"sha": "11c05d78301f0c0c1c488661ca0d4802d765b28c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11c05d78301f0c0c1c488661ca0d4802d765b28c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "html_url": "https://github.com/rust-lang/rust/commit/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50b56c62b1dbdcc0c80ac44200e3b100bc2f656", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50b56c62b1dbdcc0c80ac44200e3b100bc2f656", "html_url": "https://github.com/rust-lang/rust/commit/f50b56c62b1dbdcc0c80ac44200e3b100bc2f656"}, {"sha": "8e58771965d677da2c39dbfeee1055db851a2e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e58771965d677da2c39dbfeee1055db851a2e30", "html_url": "https://github.com/rust-lang/rust/commit/8e58771965d677da2c39dbfeee1055db851a2e30"}], "stats": {"total": 293, "additions": 173, "deletions": 120}, "files": [{"sha": "7dcfa1a931530a4498e62529777c6f6b426f1ca6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -1196,7 +1196,7 @@ fn compose_and_run_compiler(\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    fs::mkdir(path, io::UserRWX).unwrap();\n+    fs::mkdir(path, io::USER_RWX).unwrap();\n }\n \n fn compose_and_run(config: &Config, testfile: &Path,"}, {"sha": "295768d468eac9385944e0a008f50c47b1d099e3", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -466,7 +466,7 @@ pub fn invalid_output_for_target(sess: &Session,\n fn is_writeable(p: &Path) -> bool {\n     match p.stat() {\n         Err(..) => true,\n-        Ok(m) => m.perm & io::UserWrite == io::UserWrite\n+        Ok(m) => m.perm & io::USER_WRITE == io::USER_WRITE\n     }\n }\n \n@@ -1322,7 +1322,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 // Fix up permissions of the copy, as fs::copy() preserves\n                 // permissions, but the original file may have been installed\n                 // by a package manager and may be read-only.\n-                match fs::chmod(&dst, io::UserRead | io::UserWrite) {\n+                match fs::chmod(&dst, io::USER_READ | io::USER_WRITE) {\n                     Ok(..) => {}\n                     Err(e) => {\n                         sess.err(format!(\"failed to chmod {} when preparing \\"}, {"sha": "aa230496d9423badaf98a4ce5c75cdf35a4c903e", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -1467,7 +1467,7 @@ pub fn process_crate(sess: &Session,\n         },\n     };\n \n-    match fs::mkdir_recursive(&root_path, io::UserRWX) {\n+    match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n         Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n                            root_path.display(), e).as_slice()),\n         _ => (),"}, {"sha": "a062c68d998a9e6790167b6c269353efba5e4fd3", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -68,7 +68,7 @@ mod test {\n         let linkdir = tmpdir.join(\"test3\");\n \n         File::create(&file).unwrap();\n-        mkdir(&dir, io::UserRWX).unwrap();\n+        mkdir(&dir, io::USER_RWX).unwrap();\n         symlink(&file, &link).unwrap();\n         symlink(&dir, &linkdir).unwrap();\n \n@@ -91,8 +91,8 @@ mod test {\n         let e = d.join(\"e\");\n         let f = a.join(\"f\");\n \n-        mkdir_recursive(&b, io::UserRWX).unwrap();\n-        mkdir_recursive(&d, io::UserRWX).unwrap();\n+        mkdir_recursive(&b, io::USER_RWX).unwrap();\n+        mkdir_recursive(&d, io::USER_RWX).unwrap();\n         File::create(&f).unwrap();\n         symlink(&Path::new(\"../d/e\"), &c).unwrap();\n         symlink(&Path::new(\"../f\"), &e).unwrap();"}, {"sha": "cef44c2b262610f85f180557bf1a3f22b1a41e11", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -618,7 +618,7 @@ fn write(dst: Path, contents: &[u8]) -> io::IoResult<()> {\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) -> io::IoResult<()> {\n     if !path.exists() {\n-        fs::mkdir(path, io::UserRWX)\n+        fs::mkdir(path, io::USER_RWX)\n     } else {\n         Ok(())\n     }"}, {"sha": "7966040ed7bc666c879f9e78585d4188dc73c822", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -24,22 +24,22 @@\n /// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FlagA       = 0x00000001,\n-///         static FlagB       = 0x00000010,\n-///         static FlagC       = 0x00000100,\n-///         static FlagABC     = FlagA.bits\n-///                            | FlagB.bits\n-///                            | FlagC.bits,\n+///         static FLAG_A       = 0x00000001,\n+///         static FLAG_B       = 0x00000010,\n+///         static FLAG_C       = 0x00000100,\n+///         static FLAG_ABC     = FLAG_A.bits\n+///                             | FLAG_B.bits\n+///                             | FLAG_C.bits,\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FlagA | FlagC;\n-///     let e2 = FlagB | FlagC;\n-///     assert!((e1 | e2) == FlagABC);   // union\n-///     assert!((e1 & e2) == FlagC);     // intersection\n-///     assert!((e1 - e2) == FlagA);     // set difference\n-///     assert!(!e2 == FlagA);           // set complement\n+///     let e1 = FLAG_A | FLAG_C;\n+///     let e2 = FLAG_B | FLAG_C;\n+///     assert!((e1 | e2) == FLAG_ABC);   // union\n+///     assert!((e1 & e2) == FLAG_C);     // intersection\n+///     assert!((e1 - e2) == FLAG_A);     // set difference\n+///     assert!(!e2 == FLAG_A);           // set complement\n /// }\n /// ```\n ///\n@@ -50,8 +50,8 @@\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n-///         static FlagA   = 0x00000001,\n-///         static FlagB   = 0x00000010,\n+///         static FLAG_A   = 0x00000001,\n+///         static FLAG_B   = 0x00000010,\n ///     }\n /// }\n ///\n@@ -69,7 +69,7 @@\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FlagA | FlagB;\n+///     let mut flags = FLAG_A | FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n@@ -123,10 +123,7 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $(\n-            #[allow(non_uppercase_statics)]\n-            $(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };\n-         )+\n+        $($(#[$Flag_attr])* pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n \n         impl $BitFlags {\n             /// Returns an empty set of flags.\n@@ -243,16 +240,14 @@ macro_rules! bitflags {\n         bitflags! {\n             $(#[$attr])*\n             flags $BitFlags: $T {\n-                $(\n-                    #[allow(non_uppercase_statics)]\n-                    $(#[$Flag_attr])* static $Flag = $value\n-                 ),+\n+                $($(#[$Flag_attr])* static $Flag = $value),+\n             }\n         }\n     };\n }\n \n #[cfg(test)]\n+#[allow(non_uppercase_statics)]\n mod tests {\n     use hash;\n     use option::{Some, None};"}, {"sha": "24cc53e784e65a3ca24009f28ef0101e884a0109", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -295,9 +295,9 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n                     Ok(stat) => stat,\n                     Err(..) => return Err(e),\n                 };\n-                if stat.perm.intersects(io::UserWrite) { return Err(e) }\n+                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n \n-                match chmod(path, stat.perm | io::UserWrite) {\n+                match chmod(path, stat.perm | io::USER_WRITE) {\n                     Ok(()) => do_unlink(path),\n                     Err(..) => {\n                         // Try to put it back as we found it\n@@ -501,10 +501,10 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// use std::io;\n /// use std::io::fs;\n ///\n-/// fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n-/// fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n-/// fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n-/// fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::USER_FILE);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::USER_READ | io::USER_WRITE);\n+/// fs::chmod(&Path::new(\"dir\"),      io::USER_DIR);\n+/// fs::chmod(&Path::new(\"file.exe\"), io::USER_EXEC);\n /// ```\n ///\n /// # Error\n@@ -578,7 +578,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// use std::io::fs;\n ///\n /// let p = Path::new(\"/some/dir\");\n-/// fs::mkdir(&p, io::UserRWX);\n+/// fs::mkdir(&p, io::USER_RWX);\n /// ```\n ///\n /// # Error\n@@ -996,7 +996,7 @@ mod test {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        check!(io::fs::mkdir(&ret, io::UserRWX));\n+        check!(io::fs::mkdir(&ret, io::USER_RWX));\n         TempDir(ret)\n     }\n \n@@ -1180,7 +1180,7 @@ mod test {\n     fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(mkdir(filename, io::UserRWX));\n+        check!(mkdir(filename, io::USER_RWX));\n         let stat_res_fn = check!(stat(filename));\n         assert!(stat_res_fn.kind == io::TypeDirectory);\n         let stat_res_meth = check!(filename.stat());\n@@ -1192,7 +1192,7 @@ mod test {\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(mkdir(dir, io::UserRWX));\n+        check!(mkdir(dir, io::USER_RWX));\n         assert!(dir.is_file() == false);\n         check!(rmdir(dir));\n     }\n@@ -1212,7 +1212,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        check!(mkdir(dir, io::UserRWX));\n+        check!(mkdir(dir, io::USER_RWX));\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n         check!(rmdir(dir));\n@@ -1224,7 +1224,7 @@ mod test {\n         use str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        check!(mkdir(dir, io::UserRWX));\n+        check!(mkdir(dir, io::USER_RWX));\n         let prefix = \"foo\";\n         for n in range(0i,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n@@ -1255,14 +1255,14 @@ mod test {\n     fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n-        check!(mkdir(dir, io::UserRWX));\n+        check!(mkdir(dir, io::USER_RWX));\n \n         let dir1 = &dir.join(\"01/02/03\");\n-        check!(mkdir_recursive(dir1, io::UserRWX));\n+        check!(mkdir_recursive(dir1, io::USER_RWX));\n         check!(File::create(&dir1.join(\"04\")));\n \n         let dir2 = &dir.join(\"11/12/13\");\n-        check!(mkdir_recursive(dir2, io::UserRWX));\n+        check!(mkdir_recursive(dir2, io::USER_RWX));\n         check!(File::create(&dir2.join(\"14\")));\n \n         let mut files = check!(walk_dir(dir));\n@@ -1282,7 +1282,7 @@ mod test {\n     fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");\n-        check!(mkdir_recursive(&dir, io::UserRWX));\n+        check!(mkdir_recursive(&dir, io::USER_RWX));\n         assert!(dir.is_dir())\n     }\n \n@@ -1292,10 +1292,10 @@ mod test {\n         let dir = tmpdir.join(\"d1\");\n         let file = dir.join(\"f1\");\n \n-        check!(mkdir_recursive(&dir, io::UserRWX));\n+        check!(mkdir_recursive(&dir, io::USER_RWX));\n         check!(File::create(&file));\n \n-        let result = mkdir_recursive(&file, io::UserRWX);\n+        let result = mkdir_recursive(&file, io::USER_RWX);\n \n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n@@ -1305,7 +1305,7 @@ mod test {\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n+        check!(mkdir_recursive(&Path::new(\"/\"), io::USER_RWX));\n     }\n \n     // FIXME(#12795) depends on lstat to work on windows\n@@ -1318,8 +1318,8 @@ mod test {\n         let dtt = dt.join(\"t\");\n         let d2 = tmpdir.join(\"d2\");\n         let canary = d2.join(\"do_not_delete\");\n-        check!(mkdir_recursive(&dtt, io::UserRWX));\n-        check!(mkdir_recursive(&d2, io::UserRWX));\n+        check!(mkdir_recursive(&dtt, io::USER_RWX));\n+        check!(mkdir_recursive(&d2, io::USER_RWX));\n         check!(File::create(&canary).write(b\"foo\"));\n         check!(symlink(&d2, &dt.join(\"d2\")));\n         check!(rmdir_recursive(&d1));\n@@ -1337,7 +1337,7 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        check!(mkdir(&dirpath, io::UserRWX));\n+        check!(mkdir(&dirpath, io::USER_RWX));\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n@@ -1355,7 +1355,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        check!(mkdir(&unicode, io::UserRWX));\n+        check!(mkdir(&unicode, io::USER_RWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     }\n@@ -1436,12 +1436,12 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(File::create(&input));\n-        check!(chmod(&input, io::UserRead));\n+        check!(chmod(&input, io::USER_READ));\n         check!(copy(&input, &out));\n-        assert!(!check!(out.stat()).perm.intersects(io::UserWrite));\n+        assert!(!check!(out.stat()).perm.intersects(io::USER_WRITE));\n \n-        check!(chmod(&input, io::UserFile));\n-        check!(chmod(&out, io::UserFile));\n+        check!(chmod(&input, io::USER_FILE));\n+        check!(chmod(&out, io::USER_FILE));\n     }\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1517,16 +1517,16 @@ mod test {\n         let file = tmpdir.join(\"in.txt\");\n \n         check!(File::create(&file));\n-        assert!(check!(stat(&file)).perm.contains(io::UserWrite));\n-        check!(chmod(&file, io::UserRead));\n-        assert!(!check!(stat(&file)).perm.contains(io::UserWrite));\n+        assert!(check!(stat(&file)).perm.contains(io::USER_WRITE));\n+        check!(chmod(&file, io::USER_READ));\n+        assert!(!check!(stat(&file)).perm.contains(io::USER_WRITE));\n \n-        match chmod(&tmpdir.join(\"foo\"), io::UserRWX) {\n+        match chmod(&tmpdir.join(\"foo\"), io::USER_RWX) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n \n-        check!(chmod(&file, io::UserFile));\n+        check!(chmod(&file, io::USER_FILE));\n     }\n \n     #[test]\n@@ -1677,7 +1677,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"file\");\n         check!(File::create(&path));\n-        check!(chmod(&path, io::UserRead));\n+        check!(chmod(&path, io::USER_READ));\n         check!(unlink(&path));\n     }\n }"}, {"sha": "e52a67cc32f3e774c1e849d44e836ac5b881d62d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -1803,35 +1803,93 @@ bitflags! {\n     #[doc = \"A set of permissions for a file or directory is represented\"]\n     #[doc = \"by a set of flags which are or'd together.\"]\n     flags FilePermission: u32 {\n-        static UserRead     = 0o400,\n-        static UserWrite    = 0o200,\n-        static UserExecute  = 0o100,\n-        static GroupRead    = 0o040,\n-        static GroupWrite   = 0o020,\n-        static GroupExecute = 0o010,\n-        static OtherRead    = 0o004,\n-        static OtherWrite   = 0o002,\n-        static OtherExecute = 0o001,\n-\n-        static UserRWX  = UserRead.bits | UserWrite.bits | UserExecute.bits,\n-        static GroupRWX = GroupRead.bits | GroupWrite.bits | GroupExecute.bits,\n-        static OtherRWX = OtherRead.bits | OtherWrite.bits | OtherExecute.bits,\n+        static USER_READ     = 0o400,\n+        static USER_WRITE    = 0o200,\n+        static USER_EXECUTE  = 0o100,\n+        static GROUP_READ    = 0o040,\n+        static GROUP_WRITE   = 0o020,\n+        static GROUP_EXECUTE = 0o010,\n+        static OTHER_READ    = 0o004,\n+        static OTHER_WRITE   = 0o002,\n+        static OTHER_EXECUTE = 0o001,\n+\n+        static USER_RWX  = USER_READ.bits | USER_WRITE.bits | USER_EXECUTE.bits,\n+        static GROUP_RWX = GROUP_READ.bits | GROUP_WRITE.bits | GROUP_EXECUTE.bits,\n+        static OTHER_RWX = OTHER_READ.bits | OTHER_WRITE.bits | OTHER_EXECUTE.bits,\n \n         #[doc = \"Permissions for user owned files, equivalent to 0644 on\"]\n         #[doc = \"unix-like systems.\"]\n-        static UserFile = UserRead.bits | UserWrite.bits | GroupRead.bits | OtherRead.bits,\n+        static USER_FILE = USER_READ.bits | USER_WRITE.bits | GROUP_READ.bits | OTHER_READ.bits,\n \n         #[doc = \"Permissions for user owned directories, equivalent to 0755 on\"]\n         #[doc = \"unix-like systems.\"]\n-        static UserDir  = UserRWX.bits | GroupRead.bits | GroupExecute.bits |\n-                   OtherRead.bits | OtherExecute.bits,\n+        static USER_DIR  = USER_RWX.bits | GROUP_READ.bits | GROUP_EXECUTE.bits |\n+                   OTHER_READ.bits | OTHER_EXECUTE.bits,\n \n         #[doc = \"Permissions for user owned executables, equivalent to 0755\"]\n         #[doc = \"on unix-like systems.\"]\n-        static UserExec = UserDir.bits,\n+        static USER_EXEC = USER_DIR.bits,\n \n         #[doc = \"All possible permissions enabled.\"]\n-        static AllPermissions = UserRWX.bits | GroupRWX.bits | OtherRWX.bits,\n+        static ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n+\n+        // Deprecated names\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_READ instead\"]\n+        static UserRead     = USER_READ.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_WRITE instead\"]\n+        static UserWrite    = USER_WRITE.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_EXECUTE instead\"]\n+        static UserExecute  = USER_EXECUTE.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use GROUP_READ instead\"]\n+        static GroupRead    = GROUP_READ.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use GROUP_WRITE instead\"]\n+        static GroupWrite   = GROUP_WRITE.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use GROUP_EXECUTE instead\"]\n+        static GroupExecute = GROUP_EXECUTE.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use OTHER_READ instead\"]\n+        static OtherRead    = OTHER_READ.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use OTHER_WRITE instead\"]\n+        static OtherWrite   = OTHER_WRITE.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use OTHER_EXECUTE instead\"]\n+        static OtherExecute = OTHER_EXECUTE.bits,\n+\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_RWX instead\"]\n+        static UserRWX  = USER_RWX.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use GROUP_RWX instead\"]\n+        static GroupRWX = GROUP_RWX.bits,\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use OTHER_RWX instead\"]\n+        static OtherRWX = OTHER_RWX.bits,\n+\n+        #[doc = \"Deprecated: use `USER_FILE` instead.\"]\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_FILE instead\"]\n+        static UserFile = USER_FILE.bits,\n+\n+        #[doc = \"Deprecated: use `USER_DIR` instead.\"]\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_DIR instead\"]\n+        static UserDir  = USER_DIR.bits,\n+        #[doc = \"Deprecated: use `USER_EXEC` instead.\"]\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use USER_EXEC instead\"]\n+        static UserExec = USER_EXEC.bits,\n+\n+        #[doc = \"Deprecated: use `ALL_PERMISSIONS` instead\"]\n+        #[allow(non_uppercase_statics)]\n+        #[deprecated = \"use ALL_PERMISSIONS instead\"]\n+        static AllPermissions = ALL_PERMISSIONS.bits,\n     }\n }\n \n@@ -1954,13 +2012,13 @@ mod tests {\n     fn test_show() {\n         use super::*;\n \n-        assert_eq!(format!(\"{}\", UserRead), \"0400\".to_string());\n-        assert_eq!(format!(\"{}\", UserFile), \"0644\".to_string());\n-        assert_eq!(format!(\"{}\", UserExec), \"0755\".to_string());\n-        assert_eq!(format!(\"{}\", UserRWX),  \"0700\".to_string());\n-        assert_eq!(format!(\"{}\", GroupRWX), \"0070\".to_string());\n-        assert_eq!(format!(\"{}\", OtherRWX), \"0007\".to_string());\n-        assert_eq!(format!(\"{}\", AllPermissions), \"0777\".to_string());\n-        assert_eq!(format!(\"{}\", UserRead | UserWrite | OtherWrite), \"0602\".to_string());\n+        assert_eq!(format!(\"{}\", USER_READ), \"0400\".to_string());\n+        assert_eq!(format!(\"{}\", USER_FILE), \"0644\".to_string());\n+        assert_eq!(format!(\"{}\", USER_EXEC), \"0755\".to_string());\n+        assert_eq!(format!(\"{}\", USER_RWX),  \"0700\".to_string());\n+        assert_eq!(format!(\"{}\", GROUP_RWX), \"0070\".to_string());\n+        assert_eq!(format!(\"{}\", OTHER_RWX), \"0007\".to_string());\n+        assert_eq!(format!(\"{}\", ALL_PERMISSIONS), \"0777\".to_string());\n+        assert_eq!(format!(\"{}\", USER_READ | USER_WRITE | OTHER_WRITE), \"0602\".to_string());\n     }\n }"}, {"sha": "1d8aedb172bae39d19673ee9b1977a9759de1cc7", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -48,7 +48,7 @@ impl TempDir {\n                         unsafe { CNT.fetch_add(1, atomic::SeqCst) },\n                         suffix);\n             let p = tmpdir.join(filename);\n-            match fs::mkdir(&p, io::UserRWX) {\n+            match fs::mkdir(&p, io::USER_RWX) {\n                 Err(error) => {\n                     if attempts >= 1000 {\n                         return Err(error)"}, {"sha": "6ab14417265c83967ce7d77c9533c05651ff4545", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -91,10 +91,10 @@ use std::iter;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        static Unrestricted               = 0b0000,\n-        static RestrictionStmtExpr        = 0b0001,\n-        static RestrictionNoBarOp         = 0b0010,\n-        static RestrictionNoStructLiteral = 0b0100\n+        static UNRESTRICTED                  = 0b0000,\n+        static RESTRICTION_STMT_EXPR         = 0b0001,\n+        static RESTRICTION_NO_BAR_OP         = 0b0010,\n+        static RESTRICTION_NO_STRUCT_LITERAL = 0b0100\n     }\n }\n \n@@ -383,7 +383,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restrictions: Unrestricted,\n+            restrictions: UNRESTRICTED,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2242,7 +2242,7 @@ impl<'a> Parser<'a> {\n                     if self.token == token::LBRACE {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if !self.restrictions.contains(RestrictionNoStructLiteral) {\n+                        if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n                             // It's a struct literal.\n                             self.bump();\n                             let mut fields = Vec::new();\n@@ -2771,7 +2771,7 @@ impl<'a> Parser<'a> {\n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n         if self.token == token::BINOP(token::OR) &&\n-            self.restrictions.contains(RestrictionNoBarOp) {\n+            self.restrictions.contains(RESTRICTION_NO_BAR_OP) {\n             return lhs;\n         }\n \n@@ -2812,7 +2812,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_assign_expr(&mut self) -> P<Expr> {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        let restrictions = self.restrictions & RestrictionNoStructLiteral;\n+        let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n         match self.token {\n           token::EQ => {\n               self.bump();\n@@ -2850,7 +2850,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr();\n         }\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let thn = self.parse_block();\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2868,7 +2868,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let);\n         let pat = self.parse_pat();\n         self.expect(&token::EQ);\n-        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let thn = self.parse_block();\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr();\n@@ -2928,7 +2928,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = self.parse_pat();\n         self.expect_keyword(keywords::In);\n-        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let loop_block = self.parse_block();\n         let hi = self.span.hi;\n \n@@ -2937,7 +2937,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident));\n@@ -2952,7 +2952,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> P<Expr> {\n         let lo = self.last_span.lo;\n-        let discriminant = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL);\n         self.commit_expr_expecting(&*discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n@@ -2971,7 +2971,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr());\n         }\n         self.expect(&token::FAT_ARROW);\n-        let expr = self.parse_expr_res(RestrictionStmtExpr);\n+        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR);\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2993,7 +2993,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> P<Expr> {\n-        return self.parse_expr_res(Unrestricted);\n+        return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     /// Parse an expression, subject to the given restrictions\n@@ -3290,9 +3290,9 @@ impl<'a> Parser<'a> {\n                     self.look_ahead(2, |t| {\n                         *t != token::COMMA && *t != token::RBRACKET\n                     }) {\n-                let start = self.parse_expr_res(RestrictionNoBarOp);\n+                let start = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n                 self.eat(&token::DOTDOTDOT);\n-                let end = self.parse_expr_res(RestrictionNoBarOp);\n+                let end = self.parse_expr_res(RESTRICTION_NO_BAR_OP);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n                 let id = self.parse_ident();\n@@ -3593,7 +3593,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(RestrictionStmtExpr);\n+                    let e = self.parse_expr_res(RESTRICTION_STMT_EXPR);\n                     P(spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID)))\n                 }\n             }\n@@ -3602,7 +3602,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(RestrictionStmtExpr) &&\n+        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}, {"sha": "f04bc62bf7f396ebbdae064bcaff9c9408de0c8e", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -51,7 +51,7 @@ fn main() {\n         let child_path     = cwd.join(child_filename.clone());\n \n         // make a separate directory for the child\n-        drop(fs::mkdir(&cwd, io::UserRWX).is_ok());\n+        drop(fs::mkdir(&cwd, io::USER_RWX).is_ok());\n         assert!(fs::copy(&my_path, &child_path).is_ok());\n \n         // run child"}, {"sha": "43a62524717dbe52b68eac00a196cdeddd85648a", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -26,7 +26,7 @@ fn rename_directory() {\n         let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n         let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n-        fs::mkdir_recursive(&old_path, io::UserRWX);\n+        fs::mkdir_recursive(&old_path, io::USER_RWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n@@ -47,7 +47,7 @@ fn rename_directory() {\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n-        fs::mkdir_recursive(&new_path, io::UserRWX);\n+        fs::mkdir_recursive(&new_path, io::USER_RWX);\n         fs::rename(&old_path, &new_path.join(\"newdir\"));\n         assert!(new_path.join(\"newdir\").is_dir());\n         assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());"}, {"sha": "64fd96bd924b958f2f2dcb7e725103a8932401b1", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f0acf2213825bfcd88cc7355d3e2f32c1db13/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=0e2f0acf2213825bfcd88cc7355d3e2f32c1db13", "patch": "@@ -128,38 +128,38 @@ fn recursive_mkdir_rel() {\n     let cwd = os::getcwd();\n     println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::USER_RWX);\n     assert!(path.is_dir());\n-    fs::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::USER_RWX);\n     assert!(path.is_dir());\n }\n \n fn recursive_mkdir_dot() {\n     let dot = Path::new(\".\");\n-    fs::mkdir_recursive(&dot, io::UserRWX);\n+    fs::mkdir_recursive(&dot, io::USER_RWX);\n     let dotdot = Path::new(\"..\");\n-    fs::mkdir_recursive(&dotdot, io::UserRWX);\n+    fs::mkdir_recursive(&dotdot, io::USER_RWX);\n }\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd();\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{:?}]\", path.display(),\n            cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, io::UserRWX);\n+    fs::mkdir_recursive(&path, io::USER_RWX);\n     assert!(path.is_dir());\n     assert!(path.dir_path().is_dir());\n     let path2 = Path::new(\"quux/blat\");\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n-    fs::mkdir_recursive(&path2, io::UserRWX);\n+    fs::mkdir_recursive(&path2, io::USER_RWX);\n     assert!(path2.is_dir());\n     assert!(path2.dir_path().is_dir());\n }\n \n // Ideally this would be in core, but needs TempFile\n pub fn test_rmdir_recursive_ok() {\n-    let rwx = io::UserRWX;\n+    let rwx = io::USER_RWX;\n \n     let tmpdir = TempDir::new(\"test\").ok().expect(\"test_rmdir_recursive_ok: \\\n                                                    couldn't create temp dir\");"}]}