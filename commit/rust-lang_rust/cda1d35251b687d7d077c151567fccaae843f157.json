{"sha": "cda1d35251b687d7d077c151567fccaae843f157", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYTFkMzUyNTFiNjg3ZDdkMDc3YzE1MTU2N2ZjY2FhZTg0M2YxNTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-27T21:23:03Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-27T21:40:53Z"}, "message": "Finish de-exporting box, char, float. Part of #3583.", "tree": {"sha": "f1006b67784019f283d7edb54017513922f6dfb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1006b67784019f283d7edb54017513922f6dfb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cda1d35251b687d7d077c151567fccaae843f157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cda1d35251b687d7d077c151567fccaae843f157", "html_url": "https://github.com/rust-lang/rust/commit/cda1d35251b687d7d077c151567fccaae843f157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cda1d35251b687d7d077c151567fccaae843f157/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dd87689eeaebb809d6a79ad18e0c1f123f82826", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd87689eeaebb809d6a79ad18e0c1f123f82826", "html_url": "https://github.com/rust-lang/rust/commit/3dd87689eeaebb809d6a79ad18e0c1f123f82826"}], "stats": {"total": 77, "additions": 25, "deletions": 52}, "files": [{"sha": "b76571864e070cdd7d1a99b2913f79838eedef72", "filename": "src/libcore/char.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cda1d35251b687d7d077c151567fccaae843f157", "patch": "@@ -39,14 +39,6 @@ use cmp::Eq;\n     Cn  Unassigned  a reserved unassigned code point or a noncharacter\n */\n \n-export is_alphabetic,\n-       is_XID_start, is_XID_continue,\n-       is_lowercase, is_uppercase,\n-       is_whitespace, is_alphanumeric,\n-       is_ascii, is_digit,\n-       to_digit, cmp,\n-       escape_default, escape_unicode;\n-\n pub use is_alphabetic = unicode::derived_property::Alphabetic;\n pub use is_XID_start = unicode::derived_property::XID_Start;\n pub use is_XID_continue = unicode::derived_property::XID_Continue;\n@@ -56,15 +48,15 @@ pub use is_XID_continue = unicode::derived_property::XID_Continue;\n  * Indicates whether a character is in lower case, defined\n  * in terms of the Unicode General Category 'Ll'\n  */\n-pure fn is_lowercase(c: char) -> bool {\n+pub pure fn is_lowercase(c: char) -> bool {\n     return unicode::general_category::Ll(c);\n }\n \n /**\n  * Indicates whether a character is in upper case, defined\n  * in terms of the Unicode General Category 'Lu'.\n  */\n-pure fn is_uppercase(c: char) -> bool {\n+pub pure fn is_uppercase(c: char) -> bool {\n     return unicode::general_category::Lu(c);\n }\n \n@@ -73,7 +65,7 @@ pure fn is_uppercase(c: char) -> bool {\n  * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n-pure fn is_whitespace(c: char) -> bool {\n+pub pure fn is_whitespace(c: char) -> bool {\n     return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n@@ -85,20 +77,20 @@ pure fn is_whitespace(c: char) -> bool {\n  * defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n  * and the Derived Core Property 'Alphabetic'.\n  */\n-pure fn is_alphanumeric(c: char) -> bool {\n+pub pure fn is_alphanumeric(c: char) -> bool {\n     return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n /// Indicates whether the character is an ASCII character\n-pure fn is_ascii(c: char) -> bool {\n+pub pure fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n-pure fn is_digit(c: char) -> bool {\n+pub pure fn is_digit(c: char) -> bool {\n     return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n@@ -114,7 +106,7 @@ pure fn is_digit(c: char) -> bool {\n  * 'b' or 'B', 11, etc. Returns none if the char does not\n  * refer to a digit in the given radix.\n  */\n-pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n+pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n       'a' .. 'z' => c as uint + 10u - ('a' as uint),\n@@ -134,7 +126,7 @@ pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-fn escape_unicode(c: char) -> ~str {\n+pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n@@ -159,7 +151,7 @@ fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-fn escape_default(c: char) -> ~str {\n+pub fn escape_default(c: char) -> ~str {\n     match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\",\n@@ -179,7 +171,7 @@ fn escape_default(c: char) -> ~str {\n  *\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n-pure fn cmp(a: char, b: char) -> int {\n+pub pure fn cmp(a: char, b: char) -> int {\n     return  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }"}, {"sha": "7147efc90d0f393761a27dd975b3a4842463b5cf", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=cda1d35251b687d7d077c151567fccaae843f157", "patch": "@@ -196,11 +196,8 @@ mod u64 {\n }\n \n \n-#[legacy_exports]\n mod box;\n-#[legacy_exports]\n mod char;\n-#[legacy_exports]\n mod float;\n #[legacy_exports]\n mod f32;"}, {"sha": "aff6db3c10f389625f2c4250702f65d04fcc5bc0", "filename": "src/libcore/float.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda1d35251b687d7d077c151567fccaae843f157/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=cda1d35251b687d7d077c151567fccaae843f157", "patch": "@@ -7,26 +7,10 @@\n // Even though this module exports everything defined in it,\n // because it contains re-exports, we also have to explicitly\n // export locally defined things. That's a bit annoying.\n-export to_str_common, to_str_exact, to_str, from_str;\n-export add, sub, mul, div, rem, lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative, is_nonpositive, is_nonnegative;\n-export is_zero, is_infinite, is_finite;\n-export NaN, is_NaN, infinity, neg_infinity;\n-export consts;\n-export logarithm;\n-export acos, asin, atan, atan2, cbrt, ceil, copysign, cos, cosh, floor;\n-export erf, erfc, exp, expm1, exp2, abs, abs_sub;\n-export mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp;\n-export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n-export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n-export signbit;\n-export pow_with_uint;\n-\n-export num;\n+\n \n // export when m_float == c_double\n \n-export j0, j1, jn, y0, y1, yn;\n \n // PORT this must match in width according to architecture\n \n@@ -44,11 +28,11 @@ use f64::{j0, j1, jn, y0, y1, yn};\n use cmp::{Eq, Ord};\n use num::from_int;\n \n-const NaN: float = 0.0/0.0;\n+pub const NaN: float = 0.0/0.0;\n \n-const infinity: float = 1.0/0.0;\n+pub const infinity: float = 1.0/0.0;\n \n-const neg_infinity: float = -1.0/0.0;\n+pub const neg_infinity: float = -1.0/0.0;\n \n /* Module: consts */\n pub mod consts {\n@@ -107,7 +91,7 @@ pub mod consts {\n  * * digits - The number of significant digits\n  * * exact - Whether to enforce the exact number of significant digits\n  */\n-fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n+pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     if is_NaN(num) { return ~\"NaN\"; }\n     if num == infinity { return ~\"inf\"; }\n     if num == neg_infinity { return ~\"-inf\"; }\n@@ -414,22 +398,22 @@ pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n-    pure fn eq(other: &float) -> bool { self == (*other) }\n-    pure fn ne(other: &float) -> bool { self != (*other) }\n+    pub pure fn eq(other: &float) -> bool { self == (*other) }\n+    pub pure fn ne(other: &float) -> bool { self != (*other) }\n }\n \n impl float : Ord {\n-    pure fn lt(other: &float) -> bool { self < (*other) }\n-    pure fn le(other: &float) -> bool { self <= (*other) }\n-    pure fn ge(other: &float) -> bool { self >= (*other) }\n-    pure fn gt(other: &float) -> bool { self > (*other) }\n+    pub pure fn lt(other: &float) -> bool { self < (*other) }\n+    pub pure fn le(other: &float) -> bool { self <= (*other) }\n+    pub pure fn ge(other: &float) -> bool { self >= (*other) }\n+    pub pure fn gt(other: &float) -> bool { self > (*other) }\n }\n \n impl float: num::Num {\n-    pure fn add(other: &float)    -> float { return self + *other; }\n-    pure fn sub(other: &float)    -> float { return self - *other; }\n-    pure fn mul(other: &float)    -> float { return self * *other; }\n-    pure fn div(other: &float)    -> float { return self / *other; }\n+    pub pure fn add(other: &float)    -> float { return self + *other; }\n+    pub pure fn sub(other: &float)    -> float { return self - *other; }\n+    pub pure fn mul(other: &float)    -> float { return self * *other; }\n+    pub pure fn div(other: &float)    -> float { return self / *other; }\n     pure fn modulo(other: &float) -> float { return self % *other; }\n     pure fn neg()                  -> float { return -self;        }\n "}]}