{"sha": "cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYTM5ZWJjMjRkM2RmY2ZjYmIyNTY1ODQzZWU5ZjcwODkxY2IxMzk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T22:49:32Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-11T22:49:32Z"}, "message": "Merge #491\n\n491: Fix assertion error in unification (hopefully) r=flodiebold a=flodiebold\n\nCurrently, all types that we handle during inference need to be resolved as far\r\nas possible at the time. It's maybe too brittle of an invariant; I need to think\r\nhow we can do this better. This should fix #484 though, I hope (if\r\nit's the same case as I managed to reproduce).\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "e2996f670efd50d346cfa8dd0f836bcb65aca4dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2996f670efd50d346cfa8dd0f836bcb65aca4dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "html_url": "https://github.com/rust-lang/rust/commit/cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "f60153ee9e1d598c170743633448aa3ede8cb72e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f60153ee9e1d598c170743633448aa3ede8cb72e", "html_url": "https://github.com/rust-lang/rust/commit/f60153ee9e1d598c170743633448aa3ede8cb72e"}, {"sha": "1212e59beed25d768bfaf7bb202aa955a87106e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1212e59beed25d768bfaf7bb202aa955a87106e9", "html_url": "https://github.com/rust-lang/rust/commit/1212e59beed25d768bfaf7bb202aa955a87106e9"}], "stats": {"total": 57, "additions": 50, "deletions": 7}, "files": [{"sha": "2d533eb6a9157ccd1a07267ecf7fc37ff255f861", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "patch": "@@ -18,6 +18,7 @@ mod primitive;\n #[cfg(test)]\n mod tests;\n \n+use std::borrow::Cow;\n use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n@@ -671,7 +672,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        match (ty1, ty2) {\n+        // try to resolve type vars first\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        match (&*ty1, &*ty2) {\n             (Ty::Unknown, ..) => true,\n             (.., Ty::Unknown) => true,\n             (Ty::Bool, _)\n@@ -698,10 +702,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .zip(ts2.iter())\n                 .all(|(t1, t2)| self.unify(t1, t2)),\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2))) => {\n+                // both type vars are unknown since we tried to resolve them\n                 self.var_unification_table.union(*tv1, *tv2);\n                 true\n             }\n             (Ty::Infer(InferTy::TypeVar(tv)), other) | (other, Ty::Infer(InferTy::TypeVar(tv))) => {\n+                // the type var is unknown since we tried to resolve it\n                 self.var_unification_table\n                     .union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true\n@@ -746,6 +752,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n+        match ty {\n+            Ty::Infer(InferTy::TypeVar(tv)) => {\n+                match self.var_unification_table.probe_value(*tv).known() {\n+                    Some(known_ty) => {\n+                        // The known_ty can't be a type var itself\n+                        Cow::Owned(known_ty.clone())\n+                    }\n+                    _ => Cow::Borrowed(ty),\n+                }\n+            }\n+            _ => Cow::Borrowed(ty),\n+        }\n+    }\n+\n     /// Resolves the type completely; type variables without known type are\n     /// replaced by Ty::Unknown.\n     fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n@@ -816,12 +839,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n                 let then_ty = self.infer_expr(*then_branch, expected)?;\n-                if let Some(else_branch) = else_branch {\n-                    self.infer_expr(*else_branch, expected)?;\n-                } else {\n-                    // no else branch -> unit\n-                    self.unify(&expected.ty, &Ty::unit()); // actually coerce\n-                }\n+                match else_branch {\n+                    Some(else_branch) => {\n+                        self.infer_expr(*else_branch, expected)?;\n+                    }\n+                    None => {\n+                        // no else branch -> unit\n+                        self.unify(&then_ty, &Ty::unit()); // actually coerce\n+                    }\n+                };\n                 then_ty\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected)?,"}, {"sha": "815aecda76cc8bd28257bad707b30bab32138297", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "patch": "@@ -230,6 +230,18 @@ fn test2(a1: *const A, a2: *mut A) {\n     );\n }\n \n+#[test]\n+fn infer_bug_484() {\n+    check_inference(\n+        r#\"\n+fn test() {\n+   let x = if true {};\n+}\n+\"#,\n+        \"bug_484.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "300530551368cee2c9e240172e57dd700499c3f7", "filename": "crates/ra_hir/src/ty/tests/data/bug_484.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbug_484.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cca39ebc24d3dfcfcbb2565843ee9f70891cb139/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbug_484.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbug_484.txt?ref=cca39ebc24d3dfcfcbb2565843ee9f70891cb139", "patch": "@@ -0,0 +1,5 @@\n+[11; 37) '{    l... {}; }': ()\n+[20; 21) 'x': ()\n+[24; 34) 'if true {}': ()\n+[27; 31) 'true': bool\n+[32; 34) '{}': ()"}]}