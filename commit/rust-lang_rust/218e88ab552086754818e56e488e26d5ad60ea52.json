{"sha": "218e88ab552086754818e56e488e26d5ad60ea52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOGU4OGFiNTUyMDg2NzU0ODE4ZTU2ZTQ4OGUyNmQ1YWQ2MGVhNTI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-19T14:15:02Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-19T14:15:02Z"}, "message": "Add API for mapping `Attr` back to its syntax node", "tree": {"sha": "182896cefeba1929965bc550d4376cf7ce54f924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/182896cefeba1929965bc550d4376cf7ce54f924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/218e88ab552086754818e56e488e26d5ad60ea52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/218e88ab552086754818e56e488e26d5ad60ea52", "html_url": "https://github.com/rust-lang/rust/commit/218e88ab552086754818e56e488e26d5ad60ea52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/218e88ab552086754818e56e488e26d5ad60ea52/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd270cbc024f56596c315061d10732ebbe16eef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd270cbc024f56596c315061d10732ebbe16eef9", "html_url": "https://github.com/rust-lang/rust/commit/bd270cbc024f56596c315061d10732ebbe16eef9"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "042e119b12e35fd5f25757b016817e3b62c36f3e", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/218e88ab552086754818e56e488e26d5ad60ea52/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218e88ab552086754818e56e488e26d5ad60ea52/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=218e88ab552086754818e56e488e26d5ad60ea52", "patch": "@@ -75,32 +75,31 @@ impl RawAttrs {\n     pub(crate) const EMPTY: Self = Self { entries: None };\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Self {\n-        let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n-            .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n-\n-        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n-        let attrs = outer_attrs\n-            .chain(inner_attrs.into_iter().flatten())\n-            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n-\n-        let outer_docs =\n-            ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n-        let docs = outer_docs.chain(inner_docs.into_iter().flatten()).map(|docs_text| {\n-            (\n-                docs_text.syntax().text_range().start(),\n-                docs_text.doc_comment().map(|doc| Attr {\n-                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                    path: ModPath::from(hir_expand::name!(doc)),\n-                }),\n-            )\n-        });\n-        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let attrs: Vec<_> = collect_attrs(owner).collect();\n         let entries = if attrs.is_empty() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n+            Some(\n+                attrs\n+                    .into_iter()\n+                    .enumerate()\n+                    .flat_map(|(i, attr)| match attr {\n+                        Either::Left(attr) => Attr::from_src(attr, hygiene).map(|attr| (i, attr)),\n+                        Either::Right(comment) => comment.doc_comment().map(|doc| {\n+                            (\n+                                i,\n+                                Attr {\n+                                    index: 0,\n+                                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                                    path: ModPath::from(hir_expand::name!(doc)),\n+                                },\n+                            )\n+                        }),\n+                    })\n+                    .map(|(i, attr)| Attr { index: i as u32, ..attr })\n+                    .collect(),\n+            )\n         };\n         Self { entries }\n     }\n@@ -316,6 +315,7 @@ fn inner_attributes(\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n+    index: u32,\n     pub(crate) path: ModPath,\n     pub(crate) input: Option<AttrInput>,\n }\n@@ -342,7 +342,19 @@ impl Attr {\n         } else {\n             None\n         };\n-        Some(Attr { path, input })\n+        Some(Attr { index: 0, path, input })\n+    }\n+\n+    /// Maps this lowered `Attr` back to its original syntax node.\n+    ///\n+    /// `owner` must be the original owner of the attribute.\n+    ///\n+    /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n+    /// the attribute represented by `Attr`.\n+    pub fn to_src(&self, owner: &dyn AttrsOwner) -> Either<ast::Attr, ast::Comment> {\n+        collect_attrs(owner).nth(self.index as usize).unwrap_or_else(|| {\n+            panic!(\"cannot find `Attr` at index {} in {}\", self.index, owner.syntax())\n+        })\n     }\n \n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n@@ -432,3 +444,23 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n     let mod_item = N::id_to_mod_item(id.value);\n     tree.raw_attrs(mod_item.into()).clone()\n }\n+\n+fn collect_attrs(owner: &dyn AttrsOwner) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n+    let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n+        .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n+\n+    let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n+    let attrs = outer_attrs\n+        .chain(inner_attrs.into_iter().flatten())\n+        .map(|attr| (attr.syntax().text_range().start(), Either::Left(attr)));\n+\n+    let outer_docs =\n+        ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n+    let docs = outer_docs\n+        .chain(inner_docs.into_iter().flatten())\n+        .map(|docs_text| (docs_text.syntax().text_range().start(), Either::Right(docs_text)));\n+    // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n+    let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+\n+    attrs.into_iter().map(|(_, attr)| attr)\n+}"}]}