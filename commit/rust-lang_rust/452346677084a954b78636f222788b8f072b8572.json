{"sha": "452346677084a954b78636f222788b8f072b8572", "node_id": "C_kwDOAAsO6NoAKDQ1MjM0NjY3NzA4NGE5NTRiNzg2MzZmMjIyNzg4YjhmMDcyYjg1NzI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-07T06:54:16Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-07T06:54:16Z"}, "message": "expand: Import more AST enums", "tree": {"sha": "4eda2a4b558e2b2272ae6307d2f40d890db52fdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eda2a4b558e2b2272ae6307d2f40d890db52fdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/452346677084a954b78636f222788b8f072b8572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/452346677084a954b78636f222788b8f072b8572", "html_url": "https://github.com/rust-lang/rust/commit/452346677084a954b78636f222788b8f072b8572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/452346677084a954b78636f222788b8f072b8572/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "800ba8f8e862d72707200f77a51981de62f38b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/800ba8f8e862d72707200f77a51981de62f38b3a", "html_url": "https://github.com/rust-lang/rust/commit/800ba8f8e862d72707200f77a51981de62f38b3a"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "07ce901fb417aa2b1c1fe47da35c4d9123c14622", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/452346677084a954b78636f222788b8f072b8572/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452346677084a954b78636f222788b8f072b8572/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=452346677084a954b78636f222788b8f072b8572", "patch": "@@ -11,9 +11,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, AstLikeWrapper, Block, Inline, ItemKind, MacArgs, MacCall};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n-use rustc_ast::{NodeId, Path, StmtKind};\n+use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n+use rustc_ast::{NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -317,10 +317,10 @@ pub enum InvocationKind {\n         pos: usize,\n         item: Annotatable,\n         // Required for resolving derive helper attributes.\n-        derives: Vec<Path>,\n+        derives: Vec<ast::Path>,\n     },\n     Derive {\n-        path: Path,\n+        path: ast::Path,\n         item: Annotatable,\n     },\n }\n@@ -678,7 +678,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             krate,\n                         ),\n                         Annotatable::Item(item_inner)\n-                            if matches!(attr.style, ast::AttrStyle::Inner)\n+                            if matches!(attr.style, AttrStyle::Inner)\n                                 && matches!(\n                                     item_inner.kind,\n                                     ItemKind::Mod(\n@@ -746,7 +746,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n-                    let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n+                    let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n@@ -808,7 +808,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(_, mod_kind)\n+                    ItemKind::Mod(_, mod_kind)\n                         if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n                     {\n                         feature_err(\n@@ -836,7 +836,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         toks: TokenStream,\n         kind: AstFragmentKind,\n-        path: &Path,\n+        path: &ast::Path,\n         span: Span,\n     ) -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(toks);\n@@ -928,7 +928,7 @@ pub fn parse_ast_fragment<'a>(\n \n pub fn ensure_complete_parse<'a>(\n     this: &mut Parser<'a>,\n-    macro_path: &Path,\n+    macro_path: &ast::Path,\n     kind_name: &str,\n     span: Span,\n ) {\n@@ -1053,12 +1053,12 @@ impl InvocationCollectorNode for P<ast::Item> {\n         noop_flat_map_item(self, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.kind, ast::ItemKind::MacCall(..))\n+        matches!(self.kind, ItemKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            ast::ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1067,13 +1067,13 @@ impl InvocationCollectorNode for P<ast::Item> {\n         collector: &mut InvocationCollector<'_, '_>,\n         noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n     ) -> Result<Self::OutputTy, Self> {\n-        if !matches!(node.kind, ast::ItemKind::Mod(..)) {\n+        if !matches!(node.kind, ItemKind::Mod(..)) {\n             return Ok(noop_flat_map(node, collector));\n         }\n \n         // Work around borrow checker not seeing through `P`'s deref.\n         let (ident, span, mut attrs) = (node.ident, node.span, mem::take(&mut node.attrs));\n-        let ast::ItemKind::Mod(_, mod_kind) = &mut node.kind else {\n+        let ItemKind::Mod(_, mod_kind) = &mut node.kind else {\n             unreachable!()\n         };\n \n@@ -1157,12 +1157,12 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag>\n         noop_flat_map_assoc_item(self.wrapped, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.wrapped.kind, ast::AssocItemKind::MacCall(..))\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let item = self.wrapped.into_inner();\n         match item.kind {\n-            ast::AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1185,12 +1185,12 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag>\n         noop_flat_map_assoc_item(self.wrapped, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.wrapped.kind, ast::AssocItemKind::MacCall(..))\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let item = self.wrapped.into_inner();\n         match item.kind {\n-            ast::AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1211,12 +1211,12 @@ impl InvocationCollectorNode for P<ast::ForeignItem> {\n         noop_flat_map_foreign_item(self, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.kind, ast::ForeignItemKind::MacCall(..))\n+        matches!(self.kind, ForeignItemKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            ast::ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1353,7 +1353,7 @@ impl InvocationCollectorNode for ast::Stmt {\n         match &self.kind {\n             StmtKind::MacCall(..) => true,\n             StmtKind::Item(item) => matches!(item.kind, ItemKind::MacCall(..)),\n-            StmtKind::Semi(expr) => matches!(expr.kind, ast::ExprKind::MacCall(..)),\n+            StmtKind::Semi(expr) => matches!(expr.kind, ExprKind::MacCall(..)),\n             StmtKind::Expr(..) => unreachable!(),\n             StmtKind::Local(..) | StmtKind::Empty => false,\n         }\n@@ -1363,7 +1363,7 @@ impl InvocationCollectorNode for ast::Stmt {\n         // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n         let (add_semicolon, mac, attrs) = match self.kind {\n             StmtKind::MacCall(mac) => {\n-                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n+                let ast::MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n                 (style == MacStmtStyle::Semicolon, mac, attrs)\n             }\n             StmtKind::Item(item) => match item.into_inner() {\n@@ -1373,7 +1373,7 @@ impl InvocationCollectorNode for ast::Stmt {\n                 _ => unreachable!(),\n             },\n             StmtKind::Semi(expr) => match expr.into_inner() {\n-                ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n+                ast::Expr { kind: ExprKind::MacCall(mac), attrs, .. } => {\n                     (mac.args.need_semicolon(), mac, attrs)\n                 }\n                 _ => unreachable!(),\n@@ -1431,7 +1431,7 @@ impl InvocationCollectorNode for P<ast::Ty> {\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            ast::TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1453,12 +1453,12 @@ impl InvocationCollectorNode for P<ast::Pat> {\n         noop_visit_pat(self, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.kind, ast::PatKind::MacCall(..))\n+        matches!(self.kind, PatKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            ast::PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1481,12 +1481,12 @@ impl InvocationCollectorNode for P<ast::Expr> {\n         noop_visit_expr(self, visitor)\n     }\n     fn is_mac_call(&self) -> bool {\n-        matches!(self.kind, ast::ExprKind::MacCall(..))\n+        matches!(self.kind, ExprKind::MacCall(..))\n     }\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            ast::ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1516,7 +1516,7 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n     fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n         let node = self.wrapped.into_inner();\n         match node.kind {\n-            ast::ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1560,7 +1560,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        (attr, pos, derives): (ast::Attribute, usize, Vec<Path>),\n+        (attr, pos, derives): (ast::Attribute, usize, Vec<ast::Path>),\n         item: Annotatable,\n         kind: AstFragmentKind,\n     ) -> AstFragment {\n@@ -1573,7 +1573,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn take_first_attr(\n         &self,\n         item: &mut impl AstLike,\n-    ) -> Option<(ast::Attribute, usize, Vec<Path>)> {\n+    ) -> Option<(ast::Attribute, usize, Vec<ast::Path>)> {\n         let mut attr = None;\n \n         item.visit_attrs(|attrs| {\n@@ -1609,7 +1609,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n-    fn check_attributes(&self, attrs: &[ast::Attribute], call: &MacCall) {\n+    fn check_attributes(&self, attrs: &[ast::Attribute], call: &ast::MacCall) {\n         let features = self.cx.ecfg.features.unwrap();\n         let mut attrs = attrs.iter().peekable();\n         let mut span: Option<Span> = None;\n@@ -1764,7 +1764,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             let mut node = configure!(self, node);\n             return match &node.kind {\n                 StmtKind::Expr(expr)\n-                    if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) =>\n+                    if matches!(**expr, ast::Expr { kind: ExprKind::MacCall(..), .. }) =>\n                 {\n                     self.cx.current_expansion.is_trailing_mac = true;\n                     // Don't use `assign_id` for this statement - it may get removed\n@@ -1801,7 +1801,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.flat_map_node(AstLikeWrapper::new(node, OptExprTag))\n     }\n \n-    fn visit_block(&mut self, node: &mut P<Block>) {\n+    fn visit_block(&mut self, node: &mut P<ast::Block>) {\n         let orig_dir_ownership = mem::replace(\n             &mut self.cx.current_expansion.dir_ownership,\n             DirOwnership::UnownedViaBlock,\n@@ -1810,7 +1810,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n-    fn visit_id(&mut self, id: &mut ast::NodeId) {\n+    fn visit_id(&mut self, id: &mut NodeId) {\n         // We may have already assigned a `NodeId`\n         // by calling `assign_id`\n         if self.monotonic && *id == ast::DUMMY_NODE_ID {"}]}