{"sha": "36195eb91f15975fed7555a3aa52807ecd5698a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MTk1ZWI5MWYxNTk3NWZlZDc1NTVhM2FhNTI4MDdlY2Q1Njk4YTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-16T17:45:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-22T21:42:01Z"}, "message": "libstd: Remove `~str` from all `libstd` modules except `fmt` and `str`.", "tree": {"sha": "d0e99310be4a24e76b8d6b13f05ec79c1f89b6ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0e99310be4a24e76b8d6b13f05ec79c1f89b6ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36195eb91f15975fed7555a3aa52807ecd5698a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36195eb91f15975fed7555a3aa52807ecd5698a1", "html_url": "https://github.com/rust-lang/rust/commit/36195eb91f15975fed7555a3aa52807ecd5698a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36195eb91f15975fed7555a3aa52807ecd5698a1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e402e75f4eb79af09b9451f0f232f994b3e2c998", "url": "https://api.github.com/repos/rust-lang/rust/commits/e402e75f4eb79af09b9451f0f232f994b3e2c998", "html_url": "https://github.com/rust-lang/rust/commit/e402e75f4eb79af09b9451f0f232f994b3e2c998"}], "stats": {"total": 3592, "additions": 2099, "deletions": 1493}, "files": [{"sha": "de764d02064b353cc960649888e8beac06dfa8d3", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -96,7 +96,7 @@ pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n     let args_ = args.tail();\n     if args.get(1).as_slice() == \"-h\" || args.get(1).as_slice() == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message, groups.as_slice()));\n+        println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }\n@@ -109,7 +109,7 @@ pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(message, groups.as_slice()));\n+        println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }"}, {"sha": "55fca1784ded56cae84fb8cc5fed4dbacd814f44", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -157,9 +157,14 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n         let ln = ln.unwrap();\n-        if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n+        if ln.as_slice().starts_with(\"fn\") ||\n+                ln.as_slice().starts_with(\"mod\") {\n             return true;\n-        } else { if !(it(ln.trim())) { return false; } }\n+        } else {\n+            if !(it(ln.as_slice().trim())) {\n+                return false;\n+            }\n+        }\n     }\n     return true;\n }"}, {"sha": "d8ca94ab46424f38c688c916bcf0a409b9ef207f", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -538,7 +538,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     // Set breakpoints on every line that contains the string \"#break\"\n     for line in breakpoint_lines.iter() {\n-        script_str.push_str(format!(\"breakpoint set --line {}\\n\", line));\n+        script_str.push_str(format!(\"breakpoint set --line {}\\n\",\n+                                    line).as_slice());\n     }\n \n     // Append the other commands\n@@ -620,18 +621,18 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n     for line in reader.lines() {\n         match line {\n             Ok(line) => {\n-                if line.contains(\"#break\") {\n+                if line.as_slice().contains(\"#break\") {\n                     breakpoint_lines.push(counter);\n                 }\n \n                 header::parse_name_value_directive(\n-                        line,\n+                        line.as_slice(),\n                         command_directive.to_strbuf()).map(|cmd| {\n                     commands.push(cmd)\n                 });\n \n                 header::parse_name_value_directive(\n-                        line,\n+                        line.as_slice(),\n                         check_directive.to_strbuf()).map(|cmd| {\n                     check_lines.push(cmd)\n                 });"}, {"sha": "0e146505d5411893479a195d2dc8a2706835c260", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -274,12 +274,13 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(\n-                    format!(\"expected `{}` but found `{}`\", c, other));\n+                self.err(format!(\"expected `{}` but found `{}`\",\n+                                 c,\n+                                 other).as_slice());\n             }\n             None => {\n-                self.err(\n-                    format!(\"expected `{}` but string was terminated\", c));\n+                self.err(format!(\"expected `{}` but string was terminated\",\n+                                 c).as_slice());\n             }\n         }\n     }\n@@ -307,7 +308,8 @@ impl<'a> Parser<'a> {\n             Some((_, c @ '#')) | Some((_, c @ '{')) |\n             Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n             Some((_, c)) => {\n-                self.err(format!(\"invalid escape character `{}`\", c));\n+                self.err(format!(\"invalid escape character `{}`\",\n+                                 c).as_slice());\n                 c\n             }\n             None => {\n@@ -459,7 +461,7 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             method => {\n-                self.err(format!(\"unknown method: `{}`\", method));\n+                self.err(format!(\"unknown method: `{}`\", method).as_slice());\n                 return None;\n             }\n         }\n@@ -526,7 +528,7 @@ impl<'a> Parser<'a> {\n                         let word = self.word();\n                         if word != \"offset\" {\n                             self.err(format!(\"expected `offset`, found `{}`\",\n-                                             word));\n+                                             word).as_slice());\n                         } else {\n                             self.must_consume(':');\n                             match self.integer() {\n@@ -566,7 +568,7 @@ impl<'a> Parser<'a> {\n                     \"many\"  => Keyword(Many),\n                     word    => {\n                         self.err(format!(\"unexpected plural selector `{}`\",\n-                                         word));\n+                                         word).as_slice());\n                         if word == \"\" {\n                             break\n                         } else {"}, {"sha": "eddf17b34b9ff070075b53a44f73bd54fc20c150", "filename": "src/libgreen/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -46,7 +46,7 @@ macro_rules! rtassert (\n \n macro_rules! rtabort (\n     ($($arg:tt)*) => ( {\n-        ::macros::abort(format!($($arg)*));\n+        ::macros::abort(format!($($arg)*).as_slice());\n     } )\n )\n "}, {"sha": "9f731637a3b513c65170a2c2a0fc5c86ce063917", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -147,7 +147,10 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             Some((err_pos, err_str)) => {\n                 let pos = expr.span.lo + syntax::codemap::Pos::from_uint(err_pos + 1);\n                 let span = syntax::codemap::mk_sp(pos,pos);\n-                cx.span_err(span, format!(\"invalid hex float literal in hexfloat!: {}\", err_str));\n+                cx.span_err(span,\n+                            format!(\"invalid hex float literal in hexfloat!: \\\n+                                     {}\",\n+                                    err_str).as_slice());\n                 return base::DummyResult::expr(sp);\n             }\n             _ => ()"}, {"sha": "a9c0501ee3e095caf1a99f9033c763c772e3c6ee", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -302,8 +302,10 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     enabled(level, module, unsafe { (*DIRECTIVES).iter() })\n }\n \n-fn enabled(level: u32, module: &str,\n-           iter: slice::Items<directive::LogDirective>) -> bool {\n+fn enabled(level: u32,\n+           module: &str,\n+           iter: slice::Items<directive::LogDirective>)\n+           -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n@@ -322,7 +324,7 @@ fn enabled(level: u32, module: &str,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let mut directives = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec),\n+        Some(spec) => directive::parse_logging_spec(spec.as_slice()),\n         None => Vec::new(),\n     };\n "}, {"sha": "64b082d9f3f58e940e7b50ee00efb247e0a47e5a", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -104,9 +104,10 @@ fn get_error(_: c_int) -> IoError {\n #[cfg(not(windows))]\n fn get_error(s: c_int) -> IoError {\n     use std::io;\n-    use std::str::raw::from_c_str;\n \n-    let err_str = unsafe { from_c_str(gai_strerror(s)) };\n+    let err_str = unsafe {\n+        CString::new(gai_strerror(s), false).as_str().unwrap().to_strbuf()\n+    };\n     IoError {\n         kind: io::OtherIoError,\n         desc: \"unable to resolve host\","}, {"sha": "748eea2ea93e1fcc5a71c896398e61e235c14015", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -604,7 +604,7 @@ impl_to_biguint!(u32,  FromPrimitive::from_u32)\n impl_to_biguint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigUint {\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n@@ -627,15 +627,17 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n-        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n-            if v.is_empty() { return \"0\".to_owned() }\n+        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> StrBuf {\n+            if v.is_empty() {\n+                return \"0\".to_strbuf()\n+            }\n             let mut s = StrBuf::with_capacity(v.len() * l);\n             for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n-                s.push_str(ss);\n+                s.push_str(ss.as_slice());\n             }\n-            s.as_slice().trim_left_chars('0').to_owned()\n+            s.as_slice().trim_left_chars('0').to_strbuf()\n         }\n     }\n }\n@@ -1209,11 +1211,11 @@ impl_to_bigint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigInt {\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n-            Zero  => \"0\".to_owned(),\n-            Minus => \"-\".to_owned() + self.data.to_str_radix(radix)\n+            Zero  => \"0\".to_strbuf(),\n+            Minus => format_strbuf!(\"-{}\", self.data.to_str_radix(radix)),\n         }\n     }\n }"}, {"sha": "37d9453fabfc6e3b3a8dff99a393a6428a895759", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -175,11 +175,15 @@ impl<T: fmt::Show + Num + Ord> fmt::Show for Complex<T> {\n }\n \n impl<T: ToStrRadix + Num + Ord> ToStrRadix for Complex<T> {\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n         if self.im < Zero::zero() {\n-            format!(\"{}-{}i\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n+            format_strbuf!(\"{}-{}i\",\n+                           self.re.to_str_radix(radix),\n+                           (-self.im).to_str_radix(radix))\n         } else {\n-            format!(\"{}+{}i\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n+            format_strbuf!(\"{}+{}i\",\n+                           self.re.to_str_radix(radix),\n+                           self.im.to_str_radix(radix))\n         }\n     }\n }"}, {"sha": "ac1982c3735d28d26a72265daac640ac205aa970", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -281,8 +281,10 @@ impl<T: fmt::Show> fmt::Show for Ratio<T> {\n }\n impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     /// Renders as `numer/denom` where the numbers are in base `radix`.\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        format!(\"{}/{}\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+        format_strbuf!(\"{}/{}\",\n+                       self.numer.to_str_radix(radix),\n+                       self.denom.to_str_radix(radix))\n     }\n }\n "}, {"sha": "1356cef87682f44eddce450b3e6b626bba1725a0", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -278,16 +278,22 @@ impl<'a> Parser<'a> {\n     fn noteof(&mut self, expected: &str) -> Result<(), Error> {\n         match self.next_char() {\n             true => Ok(()),\n-            false => self.err(format!(\"Expected {} but got EOF.\", expected)),\n+            false => {\n+                self.err(format!(\"Expected {} but got EOF.\",\n+                                 expected).as_slice())\n+            }\n         }\n     }\n \n     fn expect(&mut self, expected: char) -> Result<(), Error> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n             true => self.err(format!(\"Expected '{}' but got '{}'.\",\n-                                     expected, self.cur())),\n-            false => self.err(format!(\"Expected '{}' but got EOF.\", expected)),\n+                                     expected, self.cur()).as_slice()),\n+            false => {\n+                self.err(format!(\"Expected '{}' but got EOF.\",\n+                                 expected).as_slice())\n+            }\n         }\n     }\n \n@@ -429,8 +435,10 @@ impl<'a> Parser<'a> {\n                         try!(self.noteof(\"not a ']'\"))\n                         let c2 = self.cur();\n                         if c2 < c {\n-                            return self.err(format!(\n-                                \"Invalid character class range '{}-{}'\", c, c2))\n+                            return self.err(format!(\"Invalid character class \\\n+                                                     range '{}-{}'\",\n+                                                    c,\n+                                                    c2).as_slice())\n                         }\n                         ranges.push((c, self.cur()))\n                     } else {\n@@ -491,9 +499,12 @@ impl<'a> Parser<'a> {\n         let closer =\n             match self.pos('}') {\n                 Some(i) => i,\n-                None => return self.err(format!(\n-                    \"No closing brace for counted repetition starting at \\\n-                     position {}.\", start)),\n+                None => {\n+                    return self.err(format!(\"No closing brace for counted \\\n+                                             repetition starting at position \\\n+                                             {}.\",\n+                                            start).as_slice())\n+                }\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n@@ -525,19 +536,19 @@ impl<'a> Parser<'a> {\n         if min > MAX_REPEAT {\n             return self.err(format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT));\n+                min, MAX_REPEAT).as_slice());\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n                 return self.err(format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT));\n+                    m, MAX_REPEAT).as_slice());\n             }\n             if m < min {\n                 return self.err(format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min));\n+                     repetitions ({}).\", m, min).as_slice());\n             }\n         }\n \n@@ -600,7 +611,10 @@ impl<'a> Parser<'a> {\n                 if c.is_uppercase() { flags |= FLAG_NEGATED }\n                 Ok(Class(ranges, flags))\n             }\n-            _ => self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)),\n+            _ => {\n+                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\",\n+                                 c).as_slice())\n+            }\n         }\n     }\n \n@@ -619,7 +633,7 @@ impl<'a> Parser<'a> {\n                     Some(i) => i,\n                     None => return self.err(format!(\n                         \"Missing '\\\\}' for unclosed '\\\\{' at position {}\",\n-                        self.chari)),\n+                        self.chari).as_slice()),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -634,8 +648,10 @@ impl<'a> Parser<'a> {\n             self.chari += 1;\n         }\n         match find_class(UNICODE_CLASSES, name.as_slice()) {\n-            None => return self.err(format!(\n-                \"Could not find Unicode class '{}'\", name)),\n+            None => {\n+                return self.err(format!(\"Could not find Unicode class '{}'\",\n+                                        name).as_slice())\n+            }\n             Some(ranges) => {\n                 Ok(Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n             }\n@@ -659,8 +675,10 @@ impl<'a> Parser<'a> {\n         let s = self.slice(start, end);\n         match num::from_str_radix::<u32>(s.as_slice(), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n-            None => self.err(format!(\n-                \"Could not parse '{}' as octal number.\", s)),\n+            None => {\n+                self.err(format!(\"Could not parse '{}' as octal number.\",\n+                                 s).as_slice())\n+            }\n         }\n     }\n \n@@ -674,8 +692,11 @@ impl<'a> Parser<'a> {\n         let start = self.chari + 2;\n         let closer =\n             match self.pos('}') {\n-                None => return self.err(format!(\n-                    \"Missing '\\\\}' for unclosed '\\\\{' at position {}\", start)),\n+                None => {\n+                    return self.err(format!(\"Missing '\\\\}' for unclosed \\\n+                                             '\\\\{' at position {}\",\n+                                            start).as_slice())\n+                }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n@@ -689,16 +710,19 @@ impl<'a> Parser<'a> {\n     fn parse_hex_two(&mut self) -> Result<Ast, Error> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n-        try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\", bad)))\n+        try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\",\n+                                 bad).as_slice()))\n         self.parse_hex_digits(self.slice(start, end).as_slice())\n     }\n \n     // Parses `s` as a hexadecimal number.\n     fn parse_hex_digits(&self, s: &str) -> Result<Ast, Error> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n-            None => self.err(format!(\n-                \"Could not parse '{}' as hex number.\", s)),\n+            None => {\n+                self.err(format!(\"Could not parse '{}' as hex number.\",\n+                                 s).as_slice())\n+            }\n         }\n     }\n \n@@ -722,7 +746,8 @@ impl<'a> Parser<'a> {\n                 \"Capture names can only have underscores, letters and digits.\")\n         }\n         if self.names.contains(&name) {\n-            return self.err(format!(\"Duplicate capture group name '{}'.\", name))\n+            return self.err(format!(\"Duplicate capture group name '{}'.\",\n+                                    name).as_slice())\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -754,7 +779,7 @@ impl<'a> Parser<'a> {\n                     if sign < 0 {\n                         return self.err(format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1)))\n+                            self.slice(start, self.chari + 1)).as_slice())\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -765,7 +790,7 @@ impl<'a> Parser<'a> {\n                         if !saw_flag {\n                             return self.err(format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1)))\n+                                self.slice(start, self.chari + 1)).as_slice())\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -777,7 +802,7 @@ impl<'a> Parser<'a> {\n                     return Ok(())\n                 }\n                 _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur())),\n+                    \"Unrecognized flag '{}'.\", self.cur()).as_slice()),\n             }\n         }\n     }\n@@ -871,16 +896,21 @@ impl<'a> Parser<'a> {\n     fn parse_uint(&self, s: &str) -> Result<uint, Error> {\n         match from_str::<uint>(s) {\n             Some(i) => Ok(i),\n-            None => self.err(format!(\n-                \"Expected an unsigned integer but got '{}'.\", s)),\n+            None => {\n+                self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n+                                 s).as_slice())\n+            }\n         }\n     }\n \n     fn char_from_u32(&self, n: u32) -> Result<char, Error> {\n         match char::from_u32(n) {\n             Some(c) => Ok(c),\n-            None => self.err(format!(\n-                \"Could not decode '{}' to unicode character.\", n)),\n+            None => {\n+                self.err(format!(\"Could not decode '{}' to unicode \\\n+                                  character.\",\n+                                 n).as_slice())\n+            }\n         }\n     }\n "}, {"sha": "300562e04f2ce4a6f0cf54671a85316e9bd34c8e", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -85,7 +85,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n     let re = match Regex::new(regex.to_owned()) {\n         Ok(re) => re,\n         Err(err) => {\n-            cx.span_err(sp, err.to_str());\n+            cx.span_err(sp, err.to_str().as_slice());\n             return DummyResult::any(sp)\n         }\n     };\n@@ -612,15 +612,15 @@ fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<StrBuf> {\n                 _ => {\n                     cx.span_err(entry.span, format!(\n                         \"expected string literal but got `{}`\",\n-                        pprust::lit_to_str(lit)));\n+                        pprust::lit_to_str(lit)).as_slice());\n                     return None\n                 }\n             }\n         }\n         _ => {\n             cx.span_err(entry.span, format!(\n                 \"expected string literal but got `{}`\",\n-                pprust::expr_to_str(entry)));\n+                pprust::expr_to_str(entry)).as_slice());\n             return None\n         }\n     };"}, {"sha": "ba3796211f259cdd29bf0f7f093bab23ebe1312b", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -56,17 +56,24 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                sess.err(format!(\"{} failed with: {}\", cmd, o.status));\n+                sess.err(format!(\"{} failed with: {}\",\n+                                 cmd,\n+                                 o.status).as_slice());\n                 sess.note(format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(o.output.as_slice()).unwrap()));\n+                                  str::from_utf8(o.output\n+                                                  .as_slice()).unwrap())\n+                          .as_slice());\n                 sess.note(format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(o.error.as_slice()).unwrap()));\n+                                  str::from_utf8(o.error\n+                                                  .as_slice()).unwrap())\n+                          .as_slice());\n                 sess.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec `{}`: {}\", ar.as_slice(), e));\n+            sess.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n+                             e).as_slice());\n             sess.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -158,7 +165,7 @@ impl<'a> Archive<'a> {\n             if skip.iter().any(|s| *s == filename) { continue }\n             if filename.contains(\".SYMDEF\") { continue }\n \n-            let filename = format!(\"r-{}-{}\", name, filename);\n+            let filename = format_strbuf!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n             try!(fs::rename(file, &new_filename));\n             inputs.push(new_filename);\n@@ -178,8 +185,8 @@ impl<'a> Archive<'a> {\n         };\n         // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n-        let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n-        let unixlibname = format!(\"lib{}.a\", name);\n+        let oslibname = format_strbuf!(\"{}{}.{}\", osprefix, name, osext);\n+        let unixlibname = format_strbuf!(\"lib{}.a\", name);\n \n         let mut rustpath = filesearch::rust_path();\n         rustpath.push(self.sess.target_filesearch().get_lib_path());\n@@ -194,7 +201,8 @@ impl<'a> Archive<'a> {\n             }\n         }\n         self.sess.fatal(format!(\"could not find native static library `{}`, \\\n-                                 perhaps an -L flag is missing?\", name));\n+                                 perhaps an -L flag is missing?\",\n+                                name).as_slice());\n     }\n }\n "}, {"sha": "cd6e74beb30fd1d457acb611020a601a03255b2c", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 50, "deletions": 25, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -167,7 +167,9 @@ pub mod write {\n                 \"dynamic-no-pic\" => lib::llvm::RelocDynamicNoPic,\n                 _ => {\n                     sess.err(format!(\"{} is not a valid relocation mode\",\n-                             sess.opts.cg.relocation_model));\n+                                     sess.opts\n+                                         .cg\n+                                         .relocation_model).as_slice());\n                     sess.abort_if_errors();\n                     return;\n                 }\n@@ -219,7 +221,8 @@ pub mod write {\n             for pass in sess.opts.cg.passes.iter() {\n                 pass.as_slice().with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n-                        sess.warn(format!(\"unknown pass {}, ignoring\", *pass));\n+                        sess.warn(format!(\"unknown pass {}, ignoring\",\n+                                          *pass).as_slice());\n                     }\n                 })\n             }\n@@ -360,16 +363,20 @@ pub mod write {\n         match cmd.output() {\n             Ok(prog) => {\n                 if !prog.status.success() {\n-                    sess.err(format!(\"linking with `{}` failed: {}\", pname, prog.status));\n-                    sess.note(format!(\"{}\", &cmd));\n+                    sess.err(format!(\"linking with `{}` failed: {}\",\n+                                     pname,\n+                                     prog.status).as_slice());\n+                    sess.note(format!(\"{}\", &cmd).as_slice());\n                     let mut note = prog.error.clone();\n                     note.push_all(prog.output.as_slice());\n                     sess.note(str::from_utf8(note.as_slice()).unwrap().to_owned());\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\", pname, e));\n+                sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                                 pname,\n+                                 e).as_slice());\n                 sess.abort_if_errors();\n             }\n         }\n@@ -666,7 +673,7 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n \n     fn push(n: &mut StrBuf, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani));\n+        n.push_str(format!(\"{}{}\", sani.len(), sani).as_slice());\n     }\n \n     // First, connect each component with <len, name> pairs.\n@@ -774,7 +781,9 @@ fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n-            sess.err(format!(\"failed to remove {}: {}\", path.display(), e));\n+            sess.err(format!(\"failed to remove {}: {}\",\n+                             path.display(),\n+                             e).as_slice());\n         }\n     }\n }\n@@ -815,7 +824,7 @@ pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n     let libname = output_lib_filename(id);\n     match crate_type {\n         config::CrateTypeRlib => {\n-            out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n+            out_filename.with_filename(format_strbuf!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n             let (prefix, suffix) = match sess.targ_cfg.os {\n@@ -825,10 +834,13 @@ pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n                 abi::OsAndroid => (loader::ANDROID_DLL_PREFIX, loader::ANDROID_DLL_SUFFIX),\n                 abi::OsFreebsd => (loader::FREEBSD_DLL_PREFIX, loader::FREEBSD_DLL_SUFFIX),\n             };\n-            out_filename.with_filename(format!(\"{}{}{}\", prefix, libname, suffix))\n+            out_filename.with_filename(format_strbuf!(\"{}{}{}\",\n+                                                      prefix,\n+                                                      libname,\n+                                                      suffix))\n         }\n         config::CrateTypeStaticlib => {\n-            out_filename.with_filename(format!(\"lib{}.a\", libname))\n+            out_filename.with_filename(format_strbuf!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => out_filename.clone(),\n     }\n@@ -855,12 +867,14 @@ fn link_binary_output(sess: &Session,\n     let obj_is_writeable = is_writeable(&obj_filename);\n     let out_is_writeable = is_writeable(&out_filename);\n     if !out_is_writeable {\n-        sess.fatal(format!(\"output file {} is not writeable -- check its permissions.\",\n-                           out_filename.display()));\n+        sess.fatal(format!(\"output file {} is not writeable -- check its \\\n+                            permissions.\",\n+                           out_filename.display()).as_slice());\n     }\n     else if !obj_is_writeable {\n-        sess.fatal(format!(\"object file {} is not writeable -- check its permissions.\",\n-                           obj_filename.display()));\n+        sess.fatal(format!(\"object file {} is not writeable -- check its \\\n+                            permissions.\",\n+                           obj_filename.display()).as_slice());\n     }\n \n     match crate_type {\n@@ -936,7 +950,8 @@ fn link_rlib<'a>(sess: &'a Session,\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n-                                     metadata.display(), e));\n+                                     metadata.display(),\n+                                     e).as_slice());\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -956,7 +971,9 @@ fn link_rlib<'a>(sess: &'a Session,\n             }) {\n                 Ok(()) => {}\n                 Err(e) => {\n-                    sess.err(format!(\"failed to write compressed bytecode: {}\", e));\n+                    sess.err(format!(\"failed to write compressed bytecode: \\\n+                                      {}\",\n+                                     e).as_slice());\n                     sess.abort_if_errors()\n                 }\n             }\n@@ -1003,7 +1020,8 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let name = sess.cstore.get_crate_data(cnum).name.clone();\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n-                sess.err(format!(\"could not find rlib for: `{}`\", name));\n+                sess.err(format!(\"could not find rlib for: `{}`\",\n+                                 name).as_slice());\n                 continue\n             }\n         };\n@@ -1015,7 +1033,9 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n                 cstore::NativeUnknown => \"library\",\n                 cstore::NativeFramework => \"framework\",\n             };\n-            sess.warn(format!(\"unlinked native {}: {}\", name, *lib));\n+            sess.warn(format!(\"unlinked native {}: {}\",\n+                              name,\n+                              *lib).as_slice());\n         }\n     }\n }\n@@ -1049,16 +1069,20 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\", pname, prog.status));\n-                sess.note(format!(\"{}\", &cmd));\n+                sess.err(format!(\"linking with `{}` failed: {}\",\n+                                 pname,\n+                                 prog.status).as_slice());\n+                sess.note(format!(\"{}\", &cmd).as_slice());\n                 let mut output = prog.error.clone();\n                 output.push_all(prog.output.as_slice());\n                 sess.note(str::from_utf8(output.as_slice()).unwrap().to_owned());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\", pname, e));\n+            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                             pname,\n+                             e).as_slice());\n             sess.abort_if_errors();\n         }\n     }\n@@ -1070,7 +1094,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).status() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e));\n+                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n                 sess.abort_if_errors();\n             }\n         }\n@@ -1409,7 +1433,8 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = sess.cstore.get_crate_data(cnum).name.clone();\n-            time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n+            time(sess.time_passes(),\n+                 format!(\"altering {}.rlib\", name).as_slice(),\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1418,12 +1443,12 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e));\n+                                         e).as_slice());\n                         sess.abort_if_errors();\n                     }\n                 }\n                 let mut archive = Archive::open(sess, dst.clone());\n-                archive.remove_file(format!(\"{}.o\", name));\n+                archive.remove_file(format!(\"{}.o\", name).as_slice());\n                 let files = archive.files();\n                 if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {\n                     cmd.arg(dst);"}, {"sha": "9f12b9d58951c9a23b522e36fccedf7b32af01e0", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -47,29 +47,46 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let path = match path {\n             Some(p) => p,\n             None => {\n-                sess.fatal(format!(\"could not find rlib for: `{}`\", name));\n+                sess.fatal(format!(\"could not find rlib for: `{}`\",\n+                                   name).as_slice());\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         debug!(\"reading {}\", name);\n-        let bc = time(sess.time_passes(), format!(\"read {}.bc.deflate\", name), (), |_|\n-                      archive.read(format!(\"{}.bc.deflate\", name)));\n+        let bc = time(sess.time_passes(),\n+                      format!(\"read {}.bc.deflate\", name).as_slice(),\n+                      (),\n+                      |_| {\n+                          archive.read(format!(\"{}.bc.deflate\",\n+                                               name).as_slice())\n+                      });\n         let bc = bc.expect(\"missing compressed bytecode in archive!\");\n-        let bc = time(sess.time_passes(), format!(\"inflate {}.bc\", name), (), |_|\n-                      match flate::inflate_bytes(bc) {\n-                          Some(bc) => bc,\n-                          None => sess.fatal(format!(\"failed to decompress bc of `{}`\", name))\n+        let bc = time(sess.time_passes(),\n+                      format!(\"inflate {}.bc\", name).as_slice(),\n+                      (),\n+                      |_| {\n+                          match flate::inflate_bytes(bc) {\n+                              Some(bc) => bc,\n+                              None => {\n+                                  sess.fatal(format!(\"failed to decompress \\\n+                                                      bc of `{}`\",\n+                                                     name).as_slice())\n+                              }\n+                          }\n                       });\n         let ptr = bc.as_slice().as_ptr();\n         debug!(\"linking {}\", name);\n-        time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {\n+        time(sess.time_passes(),\n+             format!(\"ll link {}\", name).as_slice(),\n+             (),\n+             |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *libc::c_char,\n                                                     bc.len() as libc::size_t) {\n                 link::llvm_err(sess,\n-                               (format_strbuf!(\"failed to load bc of `{}`\",\n-                                               name)));\n+                               format_strbuf!(\"failed to load bc of `{}`\",\n+                                               name.as_slice()));\n             }\n         });\n     }"}, {"sha": "e8e970150fd375cf2c6a8ed9cbdcc3b514ba5e7e", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -328,18 +328,23 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n             if option_to_lookup.as_slice() != candidate { continue }\n             if !setter(&mut cg, value) {\n                 match value {\n-                    Some(..) => early_error(format!(\"codegen option `{}` takes \\\n-                                                     no value\", key)),\n-                    None => early_error(format!(\"codegen option `{0}` requires \\\n-                                                 a value (-C {0}=<value>)\",\n-                                                key))\n+                    Some(..) => {\n+                        early_error(format!(\"codegen option `{}` takes no \\\n+                                             value\", key).as_slice())\n+                    }\n+                    None => {\n+                        early_error(format!(\"codegen option `{0}` requires \\\n+                                             a value (-C {0}=<value>)\",\n+                                            key).as_slice())\n+                    }\n                 }\n             }\n             found = true;\n             break;\n         }\n         if !found {\n-            early_error(format!(\"unknown codegen option: `{}`\", key));\n+            early_error(format!(\"unknown codegen option: `{}`\",\n+                                key).as_slice());\n         }\n     }\n     return cg;\n@@ -570,7 +575,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 \"staticlib\" => CrateTypeStaticlib,\n                 \"dylib\"     => CrateTypeDylib,\n                 \"bin\"       => CrateTypeExecutable,\n-                _ => early_error(format!(\"unknown crate type: `{}`\", part))\n+                _ => {\n+                    early_error(format!(\"unknown crate type: `{}`\",\n+                                        part).as_slice())\n+                }\n             };\n             crate_types.push(new_part)\n         }\n@@ -589,14 +597,17 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = matches.opt_strs(level_short).move_iter().collect::<Vec<_>>().append(\n-                                   matches.opt_strs(level_name).as_slice());\n+        let flags = matches.opt_strs(level_short.as_slice())\n+                           .move_iter()\n+                           .collect::<Vec<_>>()\n+                           .append(matches.opt_strs(level_name).as_slice());\n         for lint_name in flags.iter() {\n-            let lint_name = lint_name.replace(\"-\", \"_\");\n+            let lint_name = lint_name.replace(\"-\", \"_\").into_strbuf();\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n                 early_error(format!(\"unknown {} flag: {}\",\n-                                    level_name, lint_name));\n+                                    level_name,\n+                                    lint_name).as_slice());\n               }\n               Some(lint) => {\n                 lint_opts.push((lint.lint, *level));\n@@ -618,7 +629,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n         if this_bit == 0 {\n-            early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n+            early_error(format!(\"unknown debug flag: {}\",\n+                                *debug_flag).as_slice())\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -638,7 +650,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"bc\"   => link::OutputTypeBitcode,\n                     \"obj\"  => link::OutputTypeObject,\n                     \"link\" => link::OutputTypeExe,\n-                    _ => early_error(format!(\"unknown emission type: `{}`\", part))\n+                    _ => {\n+                        early_error(format!(\"unknown emission type: `{}`\",\n+                                            part).as_slice())\n+                    }\n                 };\n                 output_types.push(output_type)\n             }\n@@ -671,8 +686,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(\"2\") => Default,\n                 Some(\"3\") => Aggressive,\n                 Some(arg) => {\n-                    early_error(format!(\"optimization level needs to be between 0-3 \\\n-                                        (instead was `{}`)\", arg));\n+                    early_error(format!(\"optimization level needs to be \\\n+                                         between 0-3 (instead was `{}`)\",\n+                                        arg).as_slice());\n                 }\n             }\n         } else {\n@@ -692,8 +708,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None      |\n             Some(\"2\") => FullDebugInfo,\n             Some(arg) => {\n-                early_error(format!(\"optimization level needs to be between 0-3 \\\n-                                    (instead was `{}`)\", arg));\n+                early_error(format!(\"optimization level needs to be between \\\n+                                     0-3 (instead was `{}`)\",\n+                                    arg).as_slice());\n             }\n         }\n     } else {\n@@ -725,9 +742,11 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n         None => Auto,\n \n-        Some(arg) => early_error(format!(\n-            \"argument for --color must be auto, always or never (instead was `{}`)\",\n-            arg))\n+        Some(arg) => {\n+            early_error(format!(\"argument for --color must be auto, always \\\n+                                 or never (instead was `{}`)\",\n+                                arg).as_slice())\n+        }\n     };\n \n     Options {"}, {"sha": "4e682e8e34bb2d2848e27244741c5ce46dfa8c38", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -511,7 +511,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e));\n+                               deps_filename.display(), e).as_slice());\n         }\n     }\n }\n@@ -705,7 +705,8 @@ fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n             let m = \"graphviz::render failed\";\n             io::IoError {\n                 detail: Some(match orig_detail {\n-                    None => m.into_owned(), Some(d) => format!(\"{}: {}\", m, d)\n+                    None => m.into_strbuf(),\n+                    Some(d) => format_strbuf!(\"{}: {}\", m, d)\n                 }),\n                 ..ioerr\n             }"}, {"sha": "eea6b78d3c88039088d89542e9a8e1a01c61f46b", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -120,7 +120,8 @@ Additional help:\n     -C help             Print codegen options\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc\\n\",\n-              getopts::usage(message, config::optgroups().as_slice()));\n+              getopts::usage(message.as_slice(),\n+                             config::optgroups().as_slice()));\n }\n \n fn describe_warnings() {\n@@ -305,16 +306,18 @@ pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n         (arg, \"flowgraph\") => {\n              match arg.and_then(from_str) {\n                  Some(id) => PpmFlowGraph(id),\n-                 None => sess.fatal(format_strbuf!(\"`pretty flowgraph=<nodeid>` needs \\\n-                                                     an integer <nodeid>; got {}\",\n-                                                   arg.unwrap_or(\"nothing\")).as_slice())\n+                 None => {\n+                     sess.fatal(format!(\"`pretty flowgraph=<nodeid>` needs \\\n+                                         an integer <nodeid>; got {}\",\n+                                        arg.unwrap_or(\"nothing\")).as_slice())\n+                 }\n              }\n         }\n         _ => {\n             sess.fatal(format!(\n                 \"argument to `pretty` must be one of `normal`, \\\n                  `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n-                 or `expanded,identified`; got {}\", name));\n+                 or `expanded,identified`; got {}\", name).as_slice());\n         }\n     }\n }\n@@ -406,9 +409,13 @@ fn monitor(f: proc():Send) {\n \n                 match r.read_to_str() {\n                     Ok(s) => println!(\"{}\", s),\n-                    Err(e) => emitter.emit(None,\n-                                           format!(\"failed to read internal stderr: {}\", e),\n-                                           diagnostic::Error),\n+                    Err(e) => {\n+                        emitter.emit(None,\n+                                     format!(\"failed to read internal \\\n+                                              stderr: {}\",\n+                                             e).as_slice(),\n+                                     diagnostic::Error)\n+                    }\n                 }\n             }\n "}, {"sha": "19cc3a75e052b3ca69106e140e4719313ec1f3ef", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -141,7 +141,8 @@ impl Session {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, format!(\"impossible case reached: {}\", msg));\n+        self.span_bug(sp,\n+                      format!(\"impossible case reached: {}\", msg).as_slice());\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }"}, {"sha": "ac863d82c9b7099ecb75f900d0f14d70fe929718", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -109,7 +109,7 @@ impl<'a> Context<'a> {\n             self.sess.span_err(span, explain);\n             self.sess.span_note(span, format!(\"add \\\\#![feature({})] to the \\\n                                                   crate attributes to enable\",\n-                                                 feature));\n+                                                 feature).as_slice());\n         }\n     }\n "}, {"sha": "efaeeaa557510074e3f07315815f43f43852651f", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -65,7 +65,7 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n         _ => {\n             Some((token::intern_and_get_ident(format!(\"{}\\\\#{}\",\n                                                       krate,\n-                                                      VERSION)),\n+                                                      VERSION).as_slice()),\n                   ast::CookedStr))\n         }\n     }"}, {"sha": "e7a5aeb9ef5aa00a25ed63fe6c59bd2efae7c6a3", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n         pub fn main() {\n             #![main]\n             use std::slice::Vector;\n-            test::test_main_static_x(::std::os::args().as_slice(), TESTS);\n+            test::test_main_static(::std::os::args().as_slice(), TESTS);\n         }\n     )).unwrap();\n "}, {"sha": "06a043b172fa78f518432611fe1b61f6d3686548", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -91,7 +91,8 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     for ((name, _), dupes) in map.move_iter() {\n         if dupes.len() == 1 { continue }\n         diag.handler().warn(\n-            format!(\"using multiple versions of crate `{}`\", name));\n+            format!(\"using multiple versions of crate `{}`\",\n+                    name).as_slice());\n         for dupe in dupes.move_iter() {\n             let data = cstore.get_crate_data(dupe);\n             diag.span_note(data.span, \"used here\");\n@@ -161,7 +162,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                         Some(id) => id\n                     }\n                 }\n-                None => from_str(ident.get().to_str()).unwrap()\n+                None => from_str(ident.get().to_str().as_slice()).unwrap()\n             };\n             Some(CrateInfo {\n                 ident: ident.get().to_strbuf(),\n@@ -224,7 +225,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                                     cstore::NativeUnknown\n                                 } else {\n                                     e.sess.span_err(m.span,\n-                                        format!(\"unknown kind: `{}`\", k));\n+                                        format!(\"unknown kind: `{}`\",\n+                                                k).as_slice());\n                                     cstore::NativeUnknown\n                                 }\n                             }\n@@ -243,7 +245,9 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             }\n                         };\n                         if n.get().is_empty() {\n-                            e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n+                            e.sess.span_err(m.span,\n+                                            \"#[link(name = \\\"\\\")] given with \\\n+                                             empty name\");\n                         } else {\n                             e.sess\n                              .cstore\n@@ -425,7 +429,7 @@ impl<'a> CrateLoader for Loader<'a> {\n                     let message = format!(\"crate `{}` contains a macro_registrar fn but \\\n                                   only a version for triple `{}` could be found (need {})\",\n                                   info.ident, target_triple, driver::host_triple());\n-                    self.env.sess.span_err(krate.span, message);\n+                    self.env.sess.span_err(krate.span, message.as_slice());\n                     // need to abort now because the syntax expansion\n                     // code will shortly attempt to load and execute\n                     // code from the found library."}, {"sha": "607db8e63c83f5fd8b8205f51741d9543987af91", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -248,7 +248,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id));\n+                format!(\"encode_symbol: id not found {}\", id).as_slice());\n         }\n     }\n     ebml_w.end_tag();\n@@ -375,7 +375,7 @@ fn encode_reexported_static_method(ebml_w: &mut Encoder,\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n     ebml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_ident(method_ident)));\n+                          token::get_ident(method_ident)).as_slice());\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -1439,7 +1439,10 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n         attr::mk_attr_inner(\n             attr::mk_name_value_item_str(\n                 InternedString::new(\"crate_id\"),\n-                token::intern_and_get_ident(ecx.link_meta.crateid.to_str())))\n+                token::intern_and_get_ident(ecx.link_meta\n+                                               .crateid\n+                                               .to_str()\n+                                               .as_slice())))\n     }\n \n     let mut attrs = Vec::new();"}, {"sha": "bcaa3f4c31ffcc72ecb60baf9490bed7a7b501fc", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -137,15 +137,17 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message);\n+        self.sess.span_err(self.span, message.as_slice());\n \n         let mismatches = self.rejected_via_triple.iter();\n         if self.rejected_via_triple.len() > 0 {\n-            self.sess.span_note(self.span, format!(\"expected triple of {}\", self.triple));\n+            self.sess.span_note(self.span,\n+                                format!(\"expected triple of {}\",\n+                                        self.triple).as_slice());\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path \\\\#{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()));\n+                            self.ident, i+1, got, path.display()).as_slice());\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -155,15 +157,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path \\\\#{}: {}\",\n-                            self.ident, i+1, path.display()));\n+                            self.ident, i+1, path.display()).as_slice());\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path \\\\#{}: {}\",\n-                                    r.ident, i+1, path.display()));\n+                                    r.ident, i+1, path.display()).as_slice());\n                     }\n                 }\n             }\n@@ -198,9 +200,10 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            if file.starts_with(rlib_prefix) && file.ends_with(\".rlib\") {\n+            if file.starts_with(rlib_prefix.as_slice()) &&\n+                    file.ends_with(\".rlib\") {\n                 info!(\"rlib candidate: {}\", path.display());\n-                match self.try_match(file, rlib_prefix, \".rlib\") {\n+                match self.try_match(file, rlib_prefix.as_slice(), \".rlib\") {\n                     Some(hash) => {\n                         info!(\"rlib accepted, hash: {}\", hash);\n                         let slot = candidates.find_or_insert_with(hash, |_| {\n@@ -215,9 +218,12 @@ impl<'a> Context<'a> {\n                         FileDoesntMatch\n                     }\n                 }\n-            } else if file.starts_with(dylib_prefix) && file.ends_with(dysuffix){\n+            } else if file.starts_with(dylib_prefix.as_slice()) &&\n+                    file.ends_with(dysuffix){\n                 info!(\"dylib candidate: {}\", path.display());\n-                match self.try_match(file, dylib_prefix, dysuffix) {\n+                match self.try_match(file,\n+                                     dylib_prefix.as_slice(),\n+                                     dysuffix) {\n                     Some(hash) => {\n                         info!(\"dylib accepted, hash: {}\", hash);\n                         let slot = candidates.find_or_insert_with(hash, |_| {\n@@ -271,18 +277,20 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_id.name));\n+                            self.crate_id.name).as_slice());\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\", p.display()));\n+                            self.sess.note(format!(\"path: {}\",\n+                                                   p.display()).as_slice());\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\", p.display()));\n+                            self.sess.note(format!(\"path: {}\",\n+                                                   p.display()).as_slice());\n                         }\n                         None => {}\n                     }\n@@ -375,18 +383,21 @@ impl<'a> Context<'a> {\n             if ret.is_some() {\n                 self.sess.span_err(self.span,\n                                    format!(\"multiple {} candidates for `{}` \\\n-                                            found\", flavor, self.crate_id.name));\n+                                            found\",\n+                                           flavor,\n+                                           self.crate_id.name).as_slice());\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate \\#1: {}\",\n-                                            ret.get_ref().display()));\n+                                            ret.get_ref()\n+                                               .display()).as_slice());\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate \\#{}: {}\", error,\n-                                            lib.display()));\n+                                            lib.display()).as_slice());\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -450,7 +461,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crateid_attr(diag: &SpanHandler, crateid: &CrateId) {\n-    diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n+    diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()).as_slice());\n }\n \n impl ArchiveMetadata {"}, {"sha": "1a6521c5b5d4bd000c06db34147ff20d101ed854", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -155,7 +155,10 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st, conv), parse_mutability(st)),\n-        c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n+        c => {\n+            st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n+                                    c).as_slice())\n+        }\n     }\n }\n "}, {"sha": "8956beb33f453d8f4cf51a25eb215848bc385d79", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -1312,7 +1312,8 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n         match c::astencode_tag::from_uint(tag) {\n             None => {\n                 xcx.dcx.tcx.sess.bug(\n-                    format!(\"unknown tag found in side tables: {:x}\", tag));\n+                    format!(\"unknown tag found in side tables: {:x}\",\n+                            tag).as_slice());\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1376,7 +1377,8 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     }\n                     _ => {\n                         xcx.dcx.tcx.sess.bug(\n-                            format!(\"unknown tag found in side tables: {:x}\", tag));\n+                            format!(\"unknown tag found in side tables: {:x}\",\n+                                    tag).as_slice());\n                     }\n                 }\n             }"}, {"sha": "65ecec2d2ed9f8ab467a8afdb22d40ac28d1eee9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -243,7 +243,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             if restr.loan_path != loan2.loan_path { continue; }\n \n             let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n-                \"it\".to_owned()\n+                \"it\".to_strbuf()\n             } else {\n                 format!(\"`{}`\",\n                         self.bccx.loan_path_to_str(&*old_loan.loan_path))\n@@ -255,7 +255,8 @@ impl<'a> CheckLoanCtxt<'a> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(\n+                                    &*new_loan.loan_path)).as_slice());\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n@@ -264,7 +265,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed\",\n                                 self.bccx.loan_path_to_str(&*new_loan.loan_path),\n-                                old_pronoun));\n+                                old_pronoun).as_slice());\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n@@ -273,7 +274,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                         format!(\"cannot borrow `{}` as {} because \\\n                                 previous closure requires unique access\",\n                                 self.bccx.loan_path_to_str(&*new_loan.loan_path),\n-                                new_loan.kind.to_user_str()));\n+                                new_loan.kind.to_user_str()).as_slice());\n                 }\n \n                 (_, _) => {\n@@ -284,7 +285,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                                 self.bccx.loan_path_to_str(&*new_loan.loan_path),\n                                 new_loan.kind.to_user_str(),\n                                 old_pronoun,\n-                                old_loan.kind.to_user_str()));\n+                                old_loan.kind.to_user_str()).as_slice());\n                 }\n             }\n \n@@ -293,7 +294,8 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_str(&*new_loan.loan_path)));\n+                                self.bccx.loan_path_to_str(\n+                                    &*new_loan.loan_path)).as_slice());\n                 }\n                 _ => { }\n             }\n@@ -303,7 +305,8 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_str(&*old_loan.loan_path))\n+                            self.bccx.loan_path_to_str(\n+                                &*old_loan.loan_path))\n                 }\n \n                 ty::ImmBorrow => {\n@@ -340,7 +343,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary));\n+                format!(\"{}; {}\", borrow_summary, rule_summary).as_slice());\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope);\n             self.bccx.span_end_note(old_loan_span,\n@@ -428,14 +431,14 @@ impl<'a> CheckLoanCtxt<'a> {\n                     format!(\"cannot assign to {} {} `{}`\",\n                             cmt.mutbl.to_user_str(),\n                             self.bccx.cmt_to_str(&*cmt),\n-                            self.bccx.loan_path_to_str(&*lp)));\n+                            self.bccx.loan_path_to_str(&*lp)).as_slice());\n             }\n             None => {\n                 self.bccx.span_err(\n                     expr.span,\n                     format!(\"cannot assign to {} {}\",\n                             cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_str(&*cmt)));\n+                            self.bccx.cmt_to_str(&*cmt)).as_slice());\n             }\n         }\n         return;\n@@ -672,11 +675,11 @@ impl<'a> CheckLoanCtxt<'a> {\n         self.bccx.span_err(\n             expr.span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                 self.bccx.loan_path_to_str(loan_path)));\n+                    self.bccx.loan_path_to_str(loan_path)).as_slice());\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                 self.bccx.loan_path_to_str(loan_path)));\n+                    self.bccx.loan_path_to_str(loan_path)).as_slice());\n     }\n \n     fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n@@ -702,11 +705,13 @@ impl<'a> CheckLoanCtxt<'a> {\n                         span,\n                         format!(\"cannot move out of `{}` \\\n                                 because it is borrowed\",\n-                             self.bccx.loan_path_to_str(move_path)));\n+                                self.bccx.loan_path_to_str(\n+                                    move_path)).as_slice());\n                     self.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                self.bccx.loan_path_to_str(&*loan_path)));\n+                                self.bccx.loan_path_to_str(\n+                                    &*loan_path)).as_slice());\n                 }\n             }\n             true\n@@ -745,11 +750,13 @@ impl<'a> CheckLoanCtxt<'a> {\n                         freevar.span,\n                         format!(\"cannot move `{}` into closure \\\n                                 because it is borrowed\",\n-                                this.bccx.loan_path_to_str(move_path)));\n+                                this.bccx.loan_path_to_str(\n+                                    move_path)).as_slice());\n                     this.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                                this.bccx.loan_path_to_str(&*loan_path)));\n+                                this.bccx.loan_path_to_str(\n+                                    &*loan_path)).as_slice());\n                 }\n             }\n         }"}, {"sha": "d34ce7f6a5f24579a57972f95c3b43cdfcd031fe", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -174,8 +174,9 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n                     // static item resides in immutable memory and mutating it would\n                     // cause segfaults.\n                     bccx.tcx.sess.span_err(borrow_span,\n-                                           format!(\"borrow of immutable static items with \\\n-                                                    unsafe interior is not allowed\"));\n+                                           \"borrow of immutable static items \\\n+                                            with unsafe interior is not \\\n+                                            allowed\");\n                     Err(())\n                 }\n                 mc::InteriorSafe => {\n@@ -290,7 +291,8 @@ impl<'a> GatherLoanCtxt<'a> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {:?}\", loan_region));\n+                            format!(\"invalid borrow lifetime: {:?}\",\n+                                    loan_region).as_slice());\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "925244849bc8ab408f340242155d4c9f3812a742", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -131,7 +131,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_str(&*move_from)));\n+                        bccx.cmt_to_str(&*move_from)).as_slice());\n         }\n \n         mc::cat_downcast(ref b) |\n@@ -143,7 +143,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n                         move_from.span,\n                         format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)));\n+                                b.ty.user_string(bccx.tcx)).as_slice());\n                 },\n                 _ => fail!(\"this path should not cause illegal move\")\n             }\n@@ -163,10 +163,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             format!(\"attempting to move value to here (to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference)\",\n-                    pat_name));\n+                    pat_name).as_slice());\n     } else {\n         bccx.span_note(move_to_span,\n                        format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name));\n+                               pat_name).as_slice());\n     }\n }"}, {"sha": "2060932875de6d4bd8e6e014a633c77384c1ca23", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -460,17 +460,17 @@ impl<'a> BorrowckCtxt<'a> {\n                 self.tcx.sess.span_err(\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n-                         verb,\n-                         self.loan_path_to_str(lp)));\n+                            verb,\n+                            self.loan_path_to_str(lp)).as_slice());\n             }\n             _ => {\n                 let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n                 self.tcx.sess.span_err(\n                     use_span,\n                     format!(\"{} of {}moved value: `{}`\",\n-                         verb,\n-                         partially,\n-                         self.loan_path_to_str(lp)));\n+                            verb,\n+                            partially,\n+                            self.loan_path_to_str(lp)).as_slice());\n             }\n         }\n \n@@ -482,44 +482,55 @@ impl<'a> BorrowckCtxt<'a> {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n-                    r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n-                                                   move.id, r))\n+                    r => {\n+                        self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to \\\n+                                                   {:?}, not Expr\",\n+                                                  move.id,\n+                                                  r).as_slice())\n+                    }\n                 };\n                 let suggestion = move_suggestion(self.tcx, expr_ty,\n                         \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved here because it has type `{}`, which is {}\",\n-                         self.loan_path_to_str(moved_lp),\n-                         expr_ty.user_string(self.tcx), suggestion));\n+                            self.loan_path_to_str(moved_lp),\n+                            expr_ty.user_string(self.tcx),\n+                            suggestion).as_slice());\n             }\n \n             move_data::MovePat => {\n                 let pat_ty = ty::node_id_to_type(self.tcx, move.id);\n                 self.tcx.sess.span_note(self.tcx.map.span(move.id),\n                     format!(\"`{}` moved here because it has type `{}`, \\\n-                          which is moved by default (use `ref` to override)\",\n-                         self.loan_path_to_str(moved_lp),\n-                         pat_ty.user_string(self.tcx)));\n+                             which is moved by default (use `ref` to \\\n+                             override)\",\n+                            self.loan_path_to_str(moved_lp),\n+                            pat_ty.user_string(self.tcx)).as_slice());\n             }\n \n             move_data::Captured => {\n                 let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {\n                     Some(ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n-                    r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n-                                                   move.id, r))\n+                    r => {\n+                        self.tcx.sess.bug(format!(\"Captured({:?}) maps to \\\n+                                                   {:?}, not Expr\",\n+                                                  move.id,\n+                                                  r).as_slice())\n+                    }\n                 };\n                 let suggestion = move_suggestion(self.tcx, expr_ty,\n                         \"moved by default (make a copy and \\\n                          capture that instead to override)\");\n                 self.tcx.sess.span_note(\n                     expr_span,\n                     format!(\"`{}` moved into closure environment here because it \\\n-                          has type `{}`, which is {}\",\n-                         self.loan_path_to_str(moved_lp),\n-                         expr_ty.user_string(self.tcx), suggestion));\n+                            has type `{}`, which is {}\",\n+                            self.loan_path_to_str(moved_lp),\n+                            expr_ty.user_string(self.tcx),\n+                            suggestion).as_slice());\n             }\n         }\n \n@@ -547,10 +558,8 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                 self.loan_path_to_str(lp)));\n-        self.tcx.sess.span_note(\n-            assign.span,\n-            format!(\"prior assignment occurs here\"));\n+                    self.loan_path_to_str(lp)).as_slice());\n+        self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n     pub fn span_err(&self, s: Span, m: &str) {\n@@ -657,23 +666,23 @@ impl<'a> BorrowckCtxt<'a> {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in an aliasable location\",\n-                             prefix));\n+                             prefix).as_slice());\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix));\n+                    format!(\"{} in a static location\", prefix).as_slice());\n             }\n             mc::AliasableManaged => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `@` pointer\", prefix));\n+                    format!(\"{} in a `@` pointer\", prefix).as_slice());\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix));\n+                    format!(\"{} in a `&` reference\", prefix).as_slice());\n             }\n         }\n     }\n@@ -710,12 +719,13 @@ impl<'a> BorrowckCtxt<'a> {\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} would have to be valid for \", descr),\n+                    format!(\"{} would have to be valid for \",\n+                            descr).as_slice(),\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr),\n+                    format!(\"...but {} is only valid for \", descr).as_slice(),\n                     ptr_scope,\n                     \"\");\n             }\n@@ -739,7 +749,7 @@ impl<'a> BorrowckCtxt<'a> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here\n-                        out.push_str(idx.to_str());\n+                        out.push_str(idx.to_str().as_slice());\n                     }\n                 }\n             }"}, {"sha": "acf2442f6c16bd33168f53775dad97edad0e3bed", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -508,7 +508,9 @@ impl<'a> CFGBuilder<'a> {\n     fn add_returning_edge(&mut self,\n                           _from_expr: @ast::Expr,\n                           from_index: CFGIndex) {\n-        let mut data = CFGEdgeData {exiting_scopes: vec!() };\n+        let mut data = CFGEdgeData {\n+            exiting_scopes: vec!(),\n+        };\n         for &LoopScope { loop_id: id, .. } in self.loop_scopes.iter().rev() {\n             data.exiting_scopes.push(id);\n         }\n@@ -533,13 +535,15 @@ impl<'a> CFGBuilder<'a> {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"no loop scope for id {:?}\", loop_id));\n+                            format!(\"no loop scope for id {:?}\",\n+                                    loop_id).as_slice());\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\", r));\n+                            format!(\"bad entry `{:?}` in def_map for label\",\n+                                    r).as_slice());\n                     }\n                 }\n             }"}, {"sha": "0d94fdb6e00ade3515f9dacc5b29e62efa8c8890", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -82,7 +82,9 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n             let s = self.ast_map.node_to_str(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label = label.append(format!(\"exiting scope_{} {}\", i, s.as_slice()));\n+            label = label.append(format!(\"exiting scope_{} {}\",\n+                                         i,\n+                                         s.as_slice()).as_slice());\n         }\n         dot::EscStr(label.into_maybe_owned())\n     }"}, {"sha": "64b7977c2351ed71430661b6bba57804e70df3da", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -107,7 +107,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                  .span_err(e.span,\n                            format!(\"can not cast to `{}` in a constant \\\n                                     expression\",\n-                                   ppaux::ty_to_str(v.tcx, ety).as_slice()))\n+                                   ppaux::ty_to_str(v.tcx, ety)).as_slice())\n             }\n           }\n           ExprPath(ref pth) => {"}, {"sha": "6e738b143083301dc63f4dad06ab660cb886b2cf", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -57,10 +57,14 @@ impl<'a> CheckLoopVisitor<'a> {\n         match cx {\n             Loop => {}\n             Closure => {\n-                self.sess.span_err(span, format!(\"`{}` inside of a closure\", name));\n+                self.sess.span_err(span,\n+                                   format!(\"`{}` inside of a closure\",\n+                                           name).as_slice());\n             }\n             Normal => {\n-                self.sess.span_err(span, format!(\"`{}` outside of loop\", name));\n+                self.sess.span_err(span,\n+                                   format!(\"`{}` outside of loop\",\n+                                           name).as_slice());\n             }\n         }\n     }"}, {"sha": "fb797a027956f7ae4323f488cfa8e3293257d6e5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -74,7 +74,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                // We know the type is inhabited, so this must be wrong\n                cx.tcx.sess.span_err(ex.span, format!(\"non-exhaustive patterns: \\\n                             type {} is non-empty\",\n-                            ty_to_str(cx.tcx, pat_ty)));\n+                            ty_to_str(cx.tcx, pat_ty)).as_slice());\n            }\n            // If the type *is* empty, it's vacuously exhaustive\n            return;\n@@ -164,8 +164,8 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match *ctor {\n-                        val(const_bool(true)) => Some(\"true\".to_owned()),\n-                        val(const_bool(false)) => Some(\"false\".to_owned()),\n+                        val(const_bool(true)) => Some(\"true\".to_strbuf()),\n+                        val(const_bool(false)) => Some(\"false\".to_strbuf()),\n                         _ => None\n                     }\n                 }\n@@ -177,27 +177,33 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: Vec<@Pat> ) {\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n                     match variants.iter().find(|v| v.id == vid) {\n-                        Some(v) => Some(token::get_ident(v.name).get().to_str()),\n+                        Some(v) => {\n+                            Some(token::get_ident(v.name).get()\n+                                                         .to_str()\n+                                                         .into_strbuf())\n+                        }\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n                         }\n                     }\n                 }\n                 ty::ty_vec(..) | ty::ty_rptr(..) => {\n                     match *ctor {\n-                        vec(n) => Some(format!(\"vectors of length {}\", n)),\n+                        vec(n) => {\n+                            Some(format_strbuf!(\"vectors of length {}\", n))\n+                        }\n                         _ => None\n                     }\n                 }\n                 _ => None\n             }\n         }\n     };\n-    let msg = \"non-exhaustive patterns\".to_owned() + match ext {\n-        Some(ref s) => format!(\": {} not covered\",  *s),\n-        None => \"\".to_owned()\n-    };\n-    cx.tcx.sess.span_err(sp, msg);\n+    let msg = format_strbuf!(\"non-exhaustive patterns{}\", match ext {\n+        Some(ref s) => format_strbuf!(\": {} not covered\", *s),\n+        None => \"\".to_strbuf()\n+    });\n+    cx.tcx.sess.span_err(sp, msg.as_slice());\n }\n \n type matrix = Vec<Vec<@Pat> > ;\n@@ -739,7 +745,8 @@ fn specialize(cx: &MatchCheckCtxt,\n                                     pat_span,\n                                     format!(\"struct pattern resolved to {}, \\\n                                           not a struct\",\n-                                         ty_to_str(cx.tcx, left_ty)));\n+                                         ty_to_str(cx.tcx,\n+                                                   left_ty)).as_slice());\n                             }\n                         }\n                         let args = class_fields.iter().map(|class_field| {\n@@ -980,9 +987,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,\n-                            format!(\"binding pattern {} is \\\n-                                  not an identifier: {:?}\",\n-                                 p.id, p.node));\n+                            format!(\"binding pattern {} is not an \\\n+                                     identifier: {:?}\",\n+                                    p.id,\n+                                    p.node).as_slice());\n                     }\n                 }\n             }"}, {"sha": "2a1334db2d085f29693b529e799b7054fd6d1115", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -436,10 +436,11 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n         // (#5900). Fall back to doing a limited lookup to get past it.\n         let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n                 .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), target_ty))\n-                .unwrap_or_else(|| tcx.ty_ctxt().sess.span_fatal(\n-                    target_ty.span,\n-                    format!(\"target type not found for const cast\")\n-                ));\n+                .unwrap_or_else(|| {\n+                    tcx.ty_ctxt().sess.span_fatal(target_ty.span,\n+                                                  \"target type not found for \\\n+                                                   const cast\")\n+                });\n \n         let base = eval_const_expr_partial(tcx, base);\n         match base {"}, {"sha": "a1de47f2fa8a64565f806bbd1536502241d16542", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -102,14 +102,14 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_str(gens))\n             } else {\n-                \"\".to_owned()\n+                \"\".to_strbuf()\n             };\n \n             let kills = self.kills.slice(start, end);\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_str(kills))\n             } else {\n-                \"\".to_owned()\n+                \"\".to_strbuf()\n             };\n \n             try!(ps.synth_comment(format_strbuf!(\"id {}: {}{}{}\",\n@@ -652,8 +652,9 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                     tcx.sess.span_bug(\n                         from_expr.span,\n                         format!(\"pop_scopes(from_expr={}, to_scope={:?}) \\\n-                              to_scope does not enclose from_expr\",\n-                             from_expr.repr(tcx), to_scope.loop_id));\n+                                 to_scope does not enclose from_expr\",\n+                                from_expr.repr(tcx),\n+                                to_scope.loop_id).as_slice());\n                 }\n             }\n         }\n@@ -765,15 +766,17 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n                             None => {\n                                 self.tcx().sess.span_bug(\n                                     expr.span,\n-                                    format!(\"no loop scope for id {:?}\", loop_id));\n+                                    format!(\"no loop scope for id {:?}\",\n+                                            loop_id).as_slice());\n                             }\n                         }\n                     }\n \n                     r => {\n                         self.tcx().sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\", r));\n+                            format!(\"bad entry `{:?}` in def_map for label\",\n+                                    r).as_slice());\n                     }\n                 }\n             }\n@@ -789,7 +792,9 @@ impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n \n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n-        for b in bits.mut_iter() { *b = e; }\n+        for b in bits.mut_iter() {\n+            *b = e;\n+        }\n     }\n \n     fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n@@ -841,7 +846,7 @@ fn bits_to_str(words: &[uint]) -> StrBuf {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push_char(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF));\n+            result.push_str(format!(\"{:02x}\", v & 0xFF).as_slice());\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "b9288fd9fe56fe8c53668fea721b4ddb0bb9a20a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name));\n+                                 data.name).as_slice());\n             });\n             return Vec::new();\n         }\n@@ -187,7 +187,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 }));\n+                                 }).as_slice());\n             }\n         }\n     }\n@@ -211,7 +211,8 @@ fn add_library(sess: &session::Session,\n             if link2 != link || link == cstore::RequireStatic {\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n-                                  shows up once\", data.name));\n+                                  shows up once\",\n+                                 data.name).as_slice());\n                 sess.note(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "b3b09ba631e264e2aa821cab8e479b13f9f8989b", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -48,8 +48,9 @@ impl<'a> EffectCheckVisitor<'a> {\n             SafeContext => {\n                 // Report an error.\n                 self.tcx.sess.span_err(span,\n-                                  format!(\"{} requires unsafe function or block\",\n-                                       description))\n+                                  format!(\"{} requires unsafe function or \\\n+                                           block\",\n+                                          description).as_slice())\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this."}, {"sha": "9d735dbaeae56cb952e0294f3970d482e131e0cc", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -422,7 +422,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.tcx().sess.span_bug(\n                     callee.span,\n                     format!(\"unxpected callee type {}\",\n-                            callee_ty.repr(self.tcx())));\n+                            callee_ty.repr(self.tcx())).as_slice());\n             }\n         }\n     }\n@@ -448,9 +448,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::StmtMac(..) => {\n-                self.tcx().sess.span_bug(\n-                    stmt.span,\n-                    format!(\"unexpanded stmt macro\"));\n+                self.tcx().sess.span_bug(stmt.span, \"unexpanded stmt macro\");\n             }\n         }\n     }\n@@ -518,7 +516,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     with_expr.span,\n-                    format!(\"with expression doesn't evaluate to a struct\"));\n+                    \"with expression doesn't evaluate to a struct\");\n             }\n         };\n \n@@ -601,7 +599,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())))\n+                                    method_ty.repr(self.tcx())).as_slice())\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,"}, {"sha": "64fa1a7270c9c6ee0168877923c7665a347fb59b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -127,10 +127,12 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n     check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n-                  trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n+                    trait\",\n+                    ty_to_str(cx.tcx, self_ty),\n+                    missing.user_string(cx.tcx)).as_slice());\n         cx.tcx.sess.span_note(self_type.span,\n             format!(\"types implementing this trait must fulfill `{}`\",\n-                 trait_def.bounds.user_string(cx.tcx)));\n+                    trait_def.bounds.user_string(cx.tcx)).as_slice());\n     });\n \n     // If this is a destructor, check kinds.\n@@ -210,8 +212,9 @@ fn with_appropriate_checker(cx: &Context,\n             b(check_for_bare)\n         }\n         ref s => {\n-            cx.tcx.sess.bug(\n-                format!(\"expect fn type in kind checker, not {:?}\", s));\n+            cx.tcx.sess.bug(format!(\"expect fn type in kind checker, not \\\n+                                     {:?}\",\n+                                    s).as_slice());\n         }\n     }\n }\n@@ -390,9 +393,9 @@ pub fn check_typaram_bounds(cx: &Context,\n         cx.tcx.sess.span_err(\n             sp,\n             format!(\"instantiating a type parameter with an incompatible type \\\n-                  `{}`, which does not fulfill `{}`\",\n-                 ty_to_str(cx.tcx, ty),\n-                 missing.user_string(cx.tcx)));\n+                     `{}`, which does not fulfill `{}`\",\n+                    ty_to_str(cx.tcx, ty),\n+                    missing.user_string(cx.tcx)).as_slice());\n     });\n }\n \n@@ -403,19 +406,26 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n         // Will be Some if the freevar is implicitly borrowed (stack closure).\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n-            Some(rty) => cx.tcx.sess.span_err(sp,\n-                format!(\"cannot implicitly borrow variable of type `{}` in a bounded \\\n-                      stack closure (implicit reference does not fulfill `{}`)\",\n-                     ty_to_str(cx.tcx, rty), missing.user_string(cx.tcx))),\n-            None => cx.tcx.sess.span_err(sp,\n+            Some(rty) => {\n+                cx.tcx.sess.span_err(sp,\n+                format!(\"cannot implicitly borrow variable of type `{}` in a \\\n+                         bounded stack closure (implicit reference does not \\\n+                         fulfill `{}`)\",\n+                        ty_to_str(cx.tcx, rty),\n+                        missing.user_string(cx.tcx)).as_slice())\n+            }\n+            None => {\n+                cx.tcx.sess.span_err(sp,\n                 format!(\"cannot capture variable of type `{}`, which does \\\n-                      not fulfill `{}`, in a bounded closure\",\n-                     ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx))),\n+                         not fulfill `{}`, in a bounded closure\",\n+                        ty_to_str(cx.tcx, ty),\n+                        missing.user_string(cx.tcx)).as_slice())\n+            }\n         }\n         cx.tcx.sess.span_note(\n             sp,\n             format!(\"this closure's environment must satisfy `{}`\",\n-                 bounds.user_string(cx.tcx)));\n+                    bounds.user_string(cx.tcx)).as_slice());\n     });\n }\n \n@@ -424,9 +434,9 @@ pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n     check_builtin_bounds(cx, ty, bounds, |missing| {\n         cx.tcx.sess.span_err(sp,\n             format!(\"cannot pack type `{}`, which does not fulfill \\\n-                  `{}`, as a trait bounded by {}\",\n-                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n-                 bounds.user_string(cx.tcx)));\n+                     `{}`, as a trait bounded by {}\",\n+                    ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n+                    bounds.user_string(cx.tcx)).as_slice());\n     });\n }\n \n@@ -436,9 +446,10 @@ fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n            ty::type_contents(cx.tcx, ty).to_str());\n     if ty::type_moves_by_default(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, format!(\"copying a value of non-copyable type `{}`\",\n-                     ty_to_str(cx.tcx, ty)));\n-        cx.tcx.sess.span_note(sp, format!(\"{}\", reason));\n+            sp,\n+            format!(\"copying a value of non-copyable type `{}`\",\n+                    ty_to_str(cx.tcx, ty)).as_slice());\n+        cx.tcx.sess.span_note(sp, format!(\"{}\", reason).as_slice());\n     }\n }\n \n@@ -448,7 +459,8 @@ pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n           ty::ty_param(..) => {\n             tcx.sess.span_err(sp,\n                 format!(\"value may contain references; \\\n-                         add `'static` bound to `{}`\", ty_to_str(tcx, ty)));\n+                         add `'static` bound to `{}`\",\n+                        ty_to_str(tcx, ty)).as_slice());\n           }\n           _ => {\n             tcx.sess.span_err(sp, \"value may contain references\");\n@@ -564,8 +576,11 @@ pub fn check_cast_for_escaping_regions(\n // Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: StrBuf, sp: Span) {\n     if !ty::type_is_sized(tcx, ty) {\n-        tcx.sess.span_err(sp, format!(\"variable `{}` has dynamically sized type `{}`\",\n-                                      name, ty_to_str(tcx, ty)));\n+        tcx.sess.span_err(sp,\n+                          format!(\"variable `{}` has dynamically sized type \\\n+                                   `{}`\",\n+                                  name,\n+                                  ty_to_str(tcx, ty)).as_slice());\n     }\n }\n "}, {"sha": "4c381aff1e3da03be9aa3ad32c61a6380982096c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -152,7 +152,8 @@ impl<'a> LanguageItemCollector<'a> {\n         match self.items.items.get(item_index) {\n             &Some(original_def_id) if original_def_id != item_def_id => {\n                 self.session.err(format!(\"duplicate entry for `{}`\",\n-                                      LanguageItems::item_name(item_index)));\n+                                         LanguageItems::item_name(\n+                                             item_index)).as_slice());\n             }\n             &Some(_) | &None => {\n                 // OK."}, {"sha": "8feacba6e006de8639905346b799ab3203ecb58b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -506,8 +506,10 @@ impl<'a> Context<'a> {\n         let mut note = None;\n         let msg = match src {\n             Default => {\n-                format!(\"{}, \\\\#[{}({})] on by default\", msg,\n-                    level_to_str(level), self.lint_to_str(lint))\n+                format_strbuf!(\"{}, \\\\#[{}({})] on by default\",\n+                               msg,\n+                               level_to_str(level),\n+                               self.lint_to_str(lint))\n             },\n             CommandLine => {\n                 format!(\"{} [-{} {}]\", msg,\n@@ -522,8 +524,8 @@ impl<'a> Context<'a> {\n             }\n         };\n         match level {\n-            Warn =>          { self.tcx.sess.span_warn(span, msg); }\n-            Deny | Forbid => { self.tcx.sess.span_err(span, msg);  }\n+            Warn => self.tcx.sess.span_warn(span, msg.as_slice()),\n+            Deny | Forbid => self.tcx.sess.span_err(span, msg.as_slice()),\n             Allow => fail!(),\n         }\n \n@@ -552,16 +554,17 @@ impl<'a> Context<'a> {\n                         UnrecognizedLint,\n                         meta.span,\n                         format!(\"unknown `{}` attribute: `{}`\",\n-                        level_to_str(level), lintname));\n+                                level_to_str(level), lintname).as_slice());\n                 }\n                 Some(lint) => {\n                     let lint = lint.lint;\n                     let now = self.get_level(lint);\n                     if now == Forbid && level != Forbid {\n                         self.tcx.sess.span_err(meta.span,\n                         format!(\"{}({}) overruled by outer forbid({})\",\n-                        level_to_str(level),\n-                        lintname, lintname));\n+                                level_to_str(level),\n+                                lintname,\n+                                lintname).as_slice());\n                     } else if now != level {\n                         let src = self.get_source(lint);\n                         self.lint_stack.push((lint, now, src));\n@@ -965,13 +968,13 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n         if n_uniq > 0 && lint != ManagedHeapMemory {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m);\n+            cx.span_lint(lint, span, m.as_slice());\n         }\n \n         if n_box > 0 && lint != OwnedHeapMemory {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-            cx.span_lint(lint, span, m);\n+            cx.span_lint(lint, span, m.as_slice());\n         }\n     }\n }\n@@ -1122,7 +1125,8 @@ fn check_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n         for &(obs_attr, obs_alter) in obsolete_attrs.iter() {\n             if name.equiv(&obs_attr) {\n                 cx.span_lint(AttributeUsage, attr.span,\n-                             format!(\"obsolete attribute: {:s}\", obs_alter));\n+                             format!(\"obsolete attribute: {:s}\",\n+                                     obs_alter).as_slice());\n                 return;\n             }\n         }\n@@ -1233,7 +1237,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n             cx.span_lint(\n                 NonCamelCaseTypes, span,\n                 format!(\"{} `{}` should have a camel case identifier\",\n-                    sort, token::get_ident(ident)));\n+                    sort, token::get_ident(ident)).as_slice());\n         }\n     }\n \n@@ -1331,7 +1335,8 @@ fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n     match value.node {\n         ast::ExprParen(_) => {\n             cx.span_lint(UnnecessaryParens, value.span,\n-                         format!(\"unnecessary parentheses around {}\", msg))\n+                         format!(\"unnecessary parentheses around {}\",\n+                                 msg).as_slice())\n         }\n         _ => {}\n     }\n@@ -1506,8 +1511,10 @@ fn check_missing_doc_attrs(cx: &Context,\n         }\n     });\n     if !has_doc {\n-        cx.span_lint(MissingDoc, sp,\n-                     format!(\"missing documentation for {}\", desc));\n+        cx.span_lint(MissingDoc,\n+                     sp,\n+                     format!(\"missing documentation for {}\",\n+                             desc).as_slice());\n     }\n }\n \n@@ -1675,7 +1682,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         _ => format!(\"use of {} item\", label)\n     };\n \n-    cx.span_lint(lint, e.span, msg);\n+    cx.span_lint(lint, e.span, msg.as_slice());\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n@@ -1906,8 +1913,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n-            tcx.sess.span_bug(span, format!(\"unprocessed lint {:?} at {}: {}\",\n-                                            lint, tcx.map.node_to_str(*id), *msg))\n+            tcx.sess.span_bug(span,\n+                              format!(\"unprocessed lint {:?} at {}: {}\",\n+                                      lint,\n+                                      tcx.map.node_to_str(*id),\n+                                      *msg).as_slice())\n         }\n     }\n "}, {"sha": "322674a5c9b7d55675f74f91fef92c230c09aefd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -317,7 +317,7 @@ impl<'a> IrMaps<'a> {\n             self.tcx\n                 .sess\n                 .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id));\n+                                        node_id).as_slice());\n           }\n         }\n     }\n@@ -606,8 +606,9 @@ impl<'a> Liveness<'a> {\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n             self.ir.tcx.sess.span_bug(\n-                span, format!(\"no live node registered for node {}\",\n-                           node_id));\n+                span,\n+                format!(\"no live node registered for node {}\",\n+                        node_id).as_slice());\n           }\n         }\n     }"}, {"sha": "3198c0e839877f8ef10e01fafed1076c27f6fbb2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -224,7 +224,7 @@ pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n       None => {\n         tcx.sess.bug(\n             format!(\"deref_cat() invoked on non-derefable type {}\",\n-                 ty_to_str(tcx, t)));\n+                    ty_to_str(tcx, t)).as_slice());\n       }\n     }\n }\n@@ -578,7 +578,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                       self.tcx().sess.span_bug(\n                           span,\n                           format!(\"Upvar of non-closure {} - {}\",\n-                                  fn_node_id, ty.repr(self.tcx())));\n+                                  fn_node_id,\n+                                  ty.repr(self.tcx())).as_slice());\n                   }\n               }\n           }\n@@ -727,7 +728,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                 self.tcx().sess.span_bug(\n                     node.span(),\n                     format!(\"Explicit deref of non-derefable type: {}\",\n-                            base_cmt.ty.repr(self.tcx())));\n+                            base_cmt.ty.repr(self.tcx())).as_slice());\n             }\n         }\n     }\n@@ -800,7 +801,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             self.tcx().sess.span_bug(\n                 elt.span(),\n                 format!(\"Explicit index of non-index type `{}`\",\n-                     base_cmt.ty.repr(self.tcx())));\n+                        base_cmt.ty.repr(self.tcx())).as_slice());\n           }\n         };\n \n@@ -884,9 +885,8 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                 },\n \n                 _ => {\n-                    tcx.sess.span_bug(\n-                        pat.span,\n-                        format!(\"Type of slice pattern is not a slice\"));\n+                    tcx.sess.span_bug(pat.span,\n+                                      \"type of slice pattern is not a slice\");\n                 }\n             }\n         }"}, {"sha": "191ac9aa9a37758c6e8fb554a2789344a91ca81e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -632,7 +632,7 @@ impl<'a> PrivacyVisitor<'a> {\n             UnnamedField(idx) => format!(\"field \\\\#{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg);\n+        self.tcx.sess.span_err(span, msg.as_slice());\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -647,7 +647,8 @@ impl<'a> PrivacyVisitor<'a> {\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,\n-                                             format!(\"method `{}`\", string)));\n+                                             format!(\"method `{}`\",\n+                                                     string).as_slice()));\n     }\n \n     // Checks that a path is in scope.\n@@ -661,8 +662,12 @@ impl<'a> PrivacyVisitor<'a> {\n                                                 .unwrap()\n                                                 .identifier);\n                 let origdid = def_id_of_def(orig_def);\n-                self.ensure_public(span, def, Some(origdid),\n-                                   format!(\"{} `{}`\", tyname, name))\n+                self.ensure_public(span,\n+                                   def,\n+                                   Some(origdid),\n+                                   format!(\"{} `{}`\",\n+                                           tyname,\n+                                           name).as_slice())\n             };\n \n             match *self.last_private_map.get(&path_id) {"}, {"sha": "3e4ebe845d7d5a8a11dd0362be8086bac00c8527", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -234,7 +234,7 @@ impl<'a> ReachableContext<'a> {\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item))\n+                                              search_item).as_slice())\n                 }\n             }\n         }\n@@ -324,9 +324,12 @@ impl<'a> ReachableContext<'a> {\n             ast_map::NodeVariant(_) |\n             ast_map::NodeStructCtor(_) => {}\n             _ => {\n-                self.tcx.sess.bug(format!(\"found unexpected thingy in \\\n-                                           worklist: {}\",\n-                                          self.tcx.map.node_to_str(search_item)))\n+                self.tcx\n+                    .sess\n+                    .bug(format!(\"found unexpected thingy in worklist: {}\",\n+                                 self.tcx\n+                                     .map\n+                                     .node_to_str(search_item)).as_slice())\n             }\n         }\n     }"}, {"sha": "0a7da6e6d088fec9a3278cb07dcbdac6e8344983", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 93, "deletions": 69, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -1085,14 +1085,14 @@ impl<'a> Resolver<'a> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_str(duplicate_type),\n-                             token::get_ident(name)));\n+                             token::get_ident(name)).as_slice());\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_str(duplicate_type),\n-                                      token::get_ident(name)));\n+                                      token::get_ident(name)).as_slice());\n                         }\n                     }\n                 }\n@@ -2054,7 +2054,7 @@ impl<'a> Resolver<'a> {\n                                        import_directive.module_path\n                                                        .as_slice(),\n                                        import_directive.subclass));\n-                    self.resolve_error(import_directive.span, msg);\n+                    self.resolve_error(import_directive.span, msg.as_slice());\n                 }\n                 Indeterminate => {\n                     // Bail out. We'll come around next time.\n@@ -2427,7 +2427,7 @@ impl<'a> Resolver<'a> {\n                                `{}` in `{}`\",\n                               token::get_ident(source),\n                               self.module_to_str(&*containing_module));\n-            self.resolve_error(directive.span, msg);\n+            self.resolve_error(directive.span, msg.as_slice());\n             return Failed;\n         }\n         let value_used_public = value_used_reexport || value_used_public;\n@@ -2651,14 +2651,17 @@ impl<'a> Resolver<'a> {\n                             expn_info: span.expn_info,\n                         };\n                         self.resolve_error(span,\n-                                              format!(\"unresolved import. maybe \\\n+                                           format!(\"unresolved import. maybe \\\n                                                     a missing `extern crate \\\n                                                     {}`?\",\n-                                                    segment_name));\n+                                                   segment_name).as_slice());\n                         return Failed;\n                     }\n-                    self.resolve_error(span, format!(\"unresolved import: could not find `{}` in \\\n-                                                     `{}`.\", segment_name, module_name));\n+                    self.resolve_error(span,\n+                                       format!(\"unresolved import: could not \\\n+                                                find `{}` in `{}`.\",\n+                                               segment_name,\n+                                               module_name).as_slice());\n                     return Failed;\n                 }\n                 Indeterminate => {\n@@ -2675,8 +2678,11 @@ impl<'a> Resolver<'a> {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n-                                    self.resolve_error(span, format!(\"not a module `{}`\",\n-                                                                 token::get_ident(name)));\n+                                    self.resolve_error(\n+                                        span,\n+                                        format!(\"not a module `{}`\",\n+                                                token::get_ident(name))\n+                                                .as_slice());\n                                     return Failed;\n                                 }\n                                 Some(ref module_def) => {\n@@ -2717,9 +2723,10 @@ impl<'a> Resolver<'a> {\n                         }\n                         None => {\n                             // There are no type bindings at all.\n-                            self.resolve_error(span,\n-                                                  format!(\"not a module `{}`\",\n-                                                       token::get_ident(name)));\n+                            self.resolve_error(\n+                                span,\n+                                format!(\"not a module `{}`\",\n+                                        token::get_ident(name)).as_slice());\n                             return Failed;\n                         }\n                     }\n@@ -2764,16 +2771,15 @@ impl<'a> Resolver<'a> {\n                 let mpath = self.idents_to_str(module_path);\n                 match mpath.as_slice().rfind(':') {\n                     Some(idx) => {\n-                        self.resolve_error(span,\n-                                           format!(\"unresolved import: could \\\n-                                                    not find `{}` in `{}`\",\n-                                                   // idx +- 1 to account for\n-                                                   // the colons on either\n-                                                   // side\n-                                                   mpath.as_slice()\n-                                                        .slice_from(idx + 1),\n-                                                   mpath.as_slice()\n-                                                        .slice_to(idx - 1)));\n+                        self.resolve_error(\n+                            span,\n+                            format!(\"unresolved import: could not find `{}` \\\n+                                     in `{}`\",\n+                                    // idx +- 1 to account for the colons on \\\n+                                    // either side\n+                                    mpath.as_slice().slice_from(idx + 1),\n+                                    mpath.as_slice()\n+                                         .slice_to(idx - 1)).as_slice());\n                     },\n                     None => (),\n                 };\n@@ -3200,7 +3206,7 @@ impl<'a> Resolver<'a> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn.as_slice().slice(0, sn.len()));\n-                self.resolve_error(imports.get(index).span, err);\n+                self.resolve_error(imports.get(index).span, err.as_slice());\n             }\n         }\n \n@@ -3870,7 +3876,7 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg);\n+                self.resolve_error(trait_reference.path.span, msg.as_slice());\n             }\n             Some(def) => {\n                 debug!(\"(resolving trait) found trait def: {:?}\", def);\n@@ -4071,7 +4077,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern \\\\#1 is \\\n                                   not bound in pattern \\\\#{}\",\n                                 token::get_name(key),\n-                                i + 1));\n+                                i + 1).as_slice());\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -4080,7 +4086,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern \\\\#{} than in pattern \\\\#1\",\n                                     token::get_name(key),\n-                                    i + 1));\n+                                    i + 1).as_slice());\n                     }\n                   }\n                 }\n@@ -4093,7 +4099,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"variable `{}` from pattern \\\\#{} is \\\n                                   not bound in pattern \\\\#1\",\n                                 token::get_name(key),\n-                                i + 1));\n+                                i + 1).as_slice());\n                 }\n             }\n         }\n@@ -4220,7 +4226,7 @@ impl<'a> Resolver<'a> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_idents_to_str(path));\n-                        self.resolve_error(ty.span, msg);\n+                        self.resolve_error(ty.span, msg.as_slice());\n                     }\n                 }\n \n@@ -4285,12 +4291,12 @@ impl<'a> Resolver<'a> {\n                             self.record_def(pattern.id, (def, lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            self.resolve_error(pattern.span,\n-                                                  format!(\"declaration of `{}` \\\n-                                                        shadows an enum \\\n-                                                        variant or unit-like \\\n-                                                        struct in scope\",\n-                                                        token::get_name(renamed)));\n+                            self.resolve_error(\n+                                pattern.span,\n+                                format!(\"declaration of `{}` shadows an enum \\\n+                                         variant or unit-like struct in \\\n+                                         scope\",\n+                                        token::get_name(renamed)).as_slice());\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -4359,9 +4365,10 @@ impl<'a> Resolver<'a> {\n                                       // in the same disjunct, which is an\n                                       // error\n                                      self.resolve_error(pattern.span,\n-                                       format!(\"identifier `{}` is bound more \\\n-                                             than once in the same pattern\",\n-                                            path_to_str(path)));\n+                                       format!(\"identifier `{}` is bound \\\n+                                                more than once in the same \\\n+                                                pattern\",\n+                                               path_to_str(path)).as_slice());\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n@@ -4406,8 +4413,11 @@ impl<'a> Resolver<'a> {\n                             self.resolve_error(\n                                 path.span,\n                                 format!(\"`{}` is not an enum variant or constant\",\n-                                     token::get_ident(\n-                                         path.segments.last().unwrap().identifier)))\n+                                        token::get_ident(\n+                                            path.segments\n+                                                .last()\n+                                                .unwrap()\n+                                                .identifier)).as_slice())\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n@@ -4435,16 +4445,20 @@ impl<'a> Resolver<'a> {\n                         Some(_) => {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n-                                    token::get_ident(path.segments\n-                                                         .last().unwrap()\n-                                                         .identifier)));\n+                                    token::get_ident(\n+                                        path.segments\n+                                            .last()\n+                                            .unwrap()\n+                                            .identifier)).as_slice());\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n-                                    token::get_ident(path.segments\n-                                                         .last().unwrap()\n-                                                         .identifier)));\n+                                    token::get_ident(\n+                                        path.segments\n+                                            .last()\n+                                            .unwrap()\n+                                            .identifier)).as_slice());\n                         }\n                     }\n \n@@ -4485,7 +4499,7 @@ impl<'a> Resolver<'a> {\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_idents_to_str(path));\n-                            self.resolve_error(path.span, msg);\n+                            self.resolve_error(path.span, msg.as_slice());\n                         }\n                     }\n                 }\n@@ -4705,7 +4719,7 @@ impl<'a> Resolver<'a> {\n             Failed => {\n                 let msg = format!(\"use of undeclared module `{}`\",\n                                   self.idents_to_str(module_path_idents.as_slice()));\n-                self.resolve_error(path.span, msg);\n+                self.resolve_error(path.span, msg.as_slice());\n                 return None;\n             }\n \n@@ -4776,7 +4790,7 @@ impl<'a> Resolver<'a> {\n             Failed => {\n                 let msg = format!(\"use of undeclared module `::{}`\",\n                                   self.idents_to_str(module_path_idents.as_slice()));\n-                self.resolve_error(path.span, msg);\n+                self.resolve_error(path.span, msg.as_slice());\n                 return None;\n             }\n \n@@ -5096,12 +5110,12 @@ impl<'a> Resolver<'a> {\n                                         format!(\"`{}` is a structure name, but \\\n                                                  this expression \\\n                                                  uses it like a function name\",\n-                                                wrong_name));\n+                                                wrong_name).as_slice());\n \n                                 self.session.span_note(expr.span,\n                                     format!(\"Did you mean to write: \\\n                                             `{} \\\\{ /* fields */ \\\\}`?\",\n-                                            wrong_name));\n+                                            wrong_name).as_slice());\n \n                             }\n                             _ => {\n@@ -5119,18 +5133,19 @@ impl<'a> Resolver<'a> {\n \n                                 if method_scope && token::get_name(self.self_ident.name).get()\n                                                                         == wrong_name.as_slice() {\n-                                        self.resolve_error(expr.span,\n-                                                            format!(\"`self` is not available in a \\\n-                                                                    static method. Maybe a `self` \\\n-                                                                    argument is missing?\"));\n+                                        self.resolve_error(\n+                                            expr.span,\n+                                            \"`self` is not available \\\n+                                             in a static method. Maybe a \\\n+                                             `self` argument is missing?\");\n                                 } else {\n                                     let name = path_to_ident(path).name;\n                                     let mut msg = match self.find_fallback_in_self_type(name) {\n                                         NoSuggestion => {\n                                             // limit search to 5 to reduce the number\n                                             // of stupid suggestions\n                                             self.find_best_match_for_name(wrong_name.as_slice(), 5)\n-                                                                .map_or(\"\".into_owned(),\n+                                                                .map_or(\"\".to_strbuf(),\n                                                                         |x| format!(\"`{}`\", x))\n                                         }\n                                         Field =>\n@@ -5147,8 +5162,11 @@ impl<'a> Resolver<'a> {\n                                         msg = format!(\" Did you mean {}?\", msg)\n                                     }\n \n-                                    self.resolve_error(expr.span, format!(\"unresolved name `{}`.{}\",\n-                                                                            wrong_name, msg));\n+                                    self.resolve_error(\n+                                        expr.span,\n+                                        format!(\"unresolved name `{}`.{}\",\n+                                                wrong_name,\n+                                                msg).as_slice());\n                                 }\n                             }\n                         }\n@@ -5182,7 +5200,7 @@ impl<'a> Resolver<'a> {\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_idents_to_str(path));\n-                        self.resolve_error(path.span, msg);\n+                        self.resolve_error(path.span, msg.as_slice());\n                     }\n                 }\n \n@@ -5211,10 +5229,12 @@ impl<'a> Resolver<'a> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_ribs(self.label_ribs.borrow().as_slice(),\n                                        renamed, expr.span) {\n-                    None =>\n-                        self.resolve_error(expr.span,\n-                                              format!(\"use of undeclared label `{}`\",\n-                                                   token::get_ident(label))),\n+                    None => {\n+                        self.resolve_error(\n+                            expr.span,\n+                            format!(\"use of undeclared label `{}`\",\n+                                    token::get_ident(label)).as_slice())\n+                    }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n                         self.record_def(expr.id, (def, LastMod(AllPublic)))\n@@ -5343,8 +5363,12 @@ impl<'a> Resolver<'a> {\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             if def != *old_value {\n-                self.session.bug(format!(\"node_id {:?} resolved first to {:?} \\\n-                                      and then {:?}\", node_id, *old_value, def));\n+                self.session\n+                    .bug(format!(\"node_id {:?} resolved first to {:?} and \\\n+                                  then {:?}\",\n+                                 node_id,\n+                                 *old_value,\n+                                 def).as_slice());\n             }\n         });\n     }\n@@ -5356,10 +5380,10 @@ impl<'a> Resolver<'a> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                self.resolve_error(\n-                    pat.span,\n-                    format!(\"cannot use `ref` binding mode with {}\",\n-                         descr));\n+                self.resolve_error(pat.span,\n+                                   format!(\"cannot use `ref` binding mode \\\n+                                            with {}\",\n+                                           descr).as_slice());\n             }\n         }\n     }"}, {"sha": "7065772d74f6cc438ba8421129202084fb4b5706", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -341,7 +341,7 @@ impl<'a> LifetimeContext<'a> {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `'{}`\",\n-                    token::get_name(lifetime_ref.name)));\n+                    token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n     fn check_lifetime_names(&self, lifetimes: &Vec<ast::Lifetime>) {\n@@ -354,7 +354,7 @@ impl<'a> LifetimeContext<'a> {\n                     self.sess.span_err(\n                         lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.name)));\n+                                token::get_name(lifetime.name)).as_slice());\n                 }\n             }\n \n@@ -366,7 +366,7 @@ impl<'a> LifetimeContext<'a> {\n                         lifetime_j.span,\n                         format!(\"lifetime name `'{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.name)));\n+                                token::get_name(lifetime_j.name)).as_slice());\n                 }\n             }\n         }"}, {"sha": "ebce96b0abbbb0bd2f752ce4cd01327b71288d95", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -112,14 +112,17 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                     let root_msg = match self.root_ty {\n                         Some(root) => format!(\" in the substitution of `{}`\",\n                                               root.repr(self.tcx)),\n-                        None => \"\".to_owned()\n+                        None => \"\".to_strbuf()\n                     };\n                     let m = format!(\"can't use type parameters from outer \\\n                                     function{}; try using a local type \\\n-                                    parameter instead\", root_msg);\n+                                    parameter instead\",\n+                                    root_msg);\n                     match self.span {\n-                        Some(span) => self.tcx.sess.span_err(span, m),\n-                        None => self.tcx.sess.err(m)\n+                        Some(span) => {\n+                            self.tcx.sess.span_err(span, m.as_slice())\n+                        }\n+                        None => self.tcx.sess.err(m.as_slice())\n                     }\n                     ty::mk_err()\n                 }\n@@ -131,12 +134,15 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n                         let root_msg = match self.root_ty {\n                             Some(root) => format!(\" in the substitution of `{}`\",\n                                                   root.repr(self.tcx)),\n-                            None => \"\".to_owned()\n+                            None => \"\".to_strbuf()\n                         };\n-                        let m = format!(\"missing `Self` type param{}\", root_msg);\n+                        let m = format!(\"missing `Self` type param{}\",\n+                                        root_msg);\n                         match self.span {\n-                            Some(span) => self.tcx.sess.span_err(span, m),\n-                            None => self.tcx.sess.err(m)\n+                            Some(span) => {\n+                                self.tcx.sess.span_err(span, m.as_slice())\n+                            }\n+                            None => self.tcx.sess.err(m.as_slice())\n                         }\n                         ty::mk_err()\n                     }"}, {"sha": "d86d414da43cb1d54ef01439dfb32455e0d6eb77", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -462,7 +462,7 @@ fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n         bcx.sess().span_bug(\n             p.span,\n             format!(\"expected an identifier pattern but found p: {}\",\n-                 p.repr(bcx.tcx())));\n+                    p.repr(bcx.tcx())).as_slice());\n     }\n }\n \n@@ -1229,8 +1229,10 @@ fn compare_values<'a>(\n                        rhs: ValueRef,\n                        rhs_t: ty::t)\n                        -> Result<'a> {\n-        let did = langcall(cx, None,\n-                           format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n+        let did = langcall(cx,\n+                           None,\n+                           format!(\"comparison of `{}`\",\n+                                   cx.ty_to_str(rhs_t)).as_slice(),\n                            StrEqFnLangItem);\n         let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n         Result {\n@@ -1252,8 +1254,10 @@ fn compare_values<'a>(\n                 Store(cx, lhs, scratch_lhs);\n                 let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n                 Store(cx, rhs, scratch_rhs);\n-                let did = langcall(cx, None,\n-                                   format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n+                let did = langcall(cx,\n+                                   None,\n+                                   format!(\"comparison of `{}`\",\n+                                           cx.ty_to_str(rhs_t)).as_slice(),\n                                    UniqStrEqFnLangItem);\n                 let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n                 Result {\n@@ -2154,7 +2158,7 @@ fn bind_irrefutable_pat<'a>(\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                              pat.repr(bcx.tcx())));\n+                                 pat.repr(bcx.tcx())).as_slice());\n     }\n \n     let _indenter = indenter();\n@@ -2273,7 +2277,7 @@ fn bind_irrefutable_pat<'a>(\n         }\n         ast::PatVec(..) => {\n             bcx.sess().span_bug(pat.span,\n-                format!(\"vector patterns are never irrefutable!\"));\n+                                \"vector patterns are never irrefutable!\");\n         }\n         ast::PatWild | ast::PatWildMulti | ast::PatLit(_) | ast::PatRange(_, _) => ()\n     }"}, {"sha": "45baf07c07c0eb9c41d240ab543710930bb513ef", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -192,7 +192,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n-                                      ty::item_path_str(cx.tcx(), def_id)))\n+                                      ty::item_path_str(cx.tcx(),\n+                                                        def_id)).as_slice())\n             }\n \n             if cases.len() == 1 {"}, {"sha": "e208097e99b33a27cd8261bf66aad140039878ff", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -341,7 +341,8 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n         Ok(id) => id,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n-                                     bcx.ty_to_str(info_ty), s));\n+                                     bcx.ty_to_str(info_ty),\n+                                     s).as_slice());\n         }\n     }\n }\n@@ -476,7 +477,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: StrBuf) {\n     if ccx.all_llvm_symbols.borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym));\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).as_slice());\n     }\n     ccx.all_llvm_symbols.borrow_mut().insert(sym);\n }\n@@ -739,8 +740,11 @@ pub fn iter_structural_ty<'r,\n \n                   for variant in (*variants).iter() {\n                       let variant_cx =\n-                          fcx.new_temp_block(\"enum-iter-variant-\".to_owned() +\n-                                             variant.disr_val.to_str());\n+                          fcx.new_temp_block(\n+                              format_strbuf!(\"enum-iter-variant-{}\",\n+                                             variant.disr_val\n+                                                    .to_str()\n+                                                    .as_slice()).as_slice());\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -839,7 +843,7 @@ pub fn fail_if_zero<'a>(\n       }\n       _ => {\n         cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                              ty_to_str(cx.tcx(), rhs_t)));\n+                              ty_to_str(cx.tcx(), rhs_t)).as_slice());\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n@@ -1503,8 +1507,8 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n-                  unexpected ctor return type {}\",\n-                 ty_to_str(ccx.tcx(), ctor_ty)))\n+                     unexpected ctor return type {}\",\n+                    ty_to_str(ccx.tcx(), ctor_ty)).as_slice())\n     };\n \n     let arena = TypedArena::new();\n@@ -2052,7 +2056,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                           variant))\n+                                   variant).as_slice())\n         }\n     };\n \n@@ -2116,7 +2120,9 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let compressed = Vec::from_slice(encoder::metadata_encoding_version)\n                      .append(match flate::deflate_bytes(metadata.as_slice()) {\n                          Some(compressed) => compressed,\n-                         None => cx.sess().fatal(format!(\"failed to compress metadata\"))\n+                         None => {\n+                             cx.sess().fatal(\"failed to compress metadata\")\n+                         }\n                      }.as_slice());\n     let llmeta = C_bytes(cx, compressed.as_slice());\n     let llconst = C_struct(cx, [llmeta], false);"}, {"sha": "f82a609d69572f0d90fb027aa079f4beceaedfed", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -750,9 +750,11 @@ impl<'a> Builder<'a> {\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n         if self.ccx.sess().asm_comments() {\n-            let s = format!(\"{} ({})\", text, self.ccx.sess().codemap().span_to_str(sp));\n-            debug!(\"{}\", s);\n-            self.add_comment(s);\n+            let s = format!(\"{} ({})\",\n+                            text,\n+                            self.ccx.sess().codemap().span_to_str(sp));\n+            debug!(\"{}\", s.as_slice());\n+            self.add_comment(s.as_slice());\n         }\n     }\n \n@@ -761,7 +763,7 @@ impl<'a> Builder<'a> {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = comment_text.with_c_str(|c| {\n+            let asm = comment_text.as_slice().with_c_str(|c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func([], &Type::void(self.ccx)).to_ref(),\n                                              c, noname(), False, False)"}, {"sha": "fe9581c638e7751cf886de89d2090334f37d1974", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -102,8 +102,9 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n             _ => {\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n-                    format!(\"type of callee is neither bare-fn nor closure: {}\",\n-                         bcx.ty_to_str(datum.ty)));\n+                    format!(\"type of callee is neither bare-fn nor closure: \\\n+                             {}\",\n+                            bcx.ty_to_str(datum.ty)).as_slice());\n             }\n         }\n     }\n@@ -151,7 +152,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {:?} \\\n-                          to a callable thing!\", def));\n+                             to a callable thing!\", def).as_slice());\n             }\n         }\n     }"}, {"sha": "68e66724d0c26914c239036f96c007090309306a", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -329,7 +329,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx.map.node_to_str(cleanup_scope)));\n+                    self.ccx.tcx.map.node_to_str(cleanup_scope)).as_slice());\n     }\n \n     fn schedule_clean_in_custom_scope(&self,\n@@ -531,7 +531,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {:?}, \\\n-                                not in scope\", id));\n+                                not in scope\", id).as_slice());\n                     }\n                 }\n             }\n@@ -878,7 +878,8 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n             r\n         }\n         None => {\n-            tcx.sess.bug(format!(\"no temporary scope available for expr {}\", id))\n+            tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n+                                 id).as_slice())\n         }\n     }\n }"}, {"sha": "c804cb77fb29d0e8201195e4bc609e2a45b21eb0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -205,7 +205,7 @@ pub fn store_environment<'a>(\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                  bv.to_str(ccx)));\n+                                     bv.to_str(ccx)).as_slice());\n         }\n \n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n@@ -386,8 +386,9 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                    expected a statically resolved fn, got {:?}\",\n-                                    def));\n+                                    expected a statically resolved fn, got \\\n+                                    {:?}\",\n+                                    def).as_slice());\n         }\n     };\n \n@@ -405,7 +406,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n                                     expected a closure ty, got {}\",\n-                                    closure_ty.repr(tcx)));\n+                                    closure_ty.repr(tcx)).as_slice());\n         }\n     };\n "}, {"sha": "a7bce0019f15be06a6d560967686b1170671b7c5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -108,7 +108,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name);\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(format!(\"{}:{}\", name, num)))\n+    PathName(token::gensym(format!(\"{}:{}\", name, num).as_slice()))\n }\n \n pub struct tydesc_info {\n@@ -459,7 +459,7 @@ impl<'a> Block<'a> {\n             Some(&v) => v,\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {:?}\", nid));\n+                    \"no def associated with node id {:?}\", nid).as_slice());\n             }\n         }\n     }\n@@ -747,9 +747,10 @@ pub fn node_id_substs(bcx: &Block,\n \n     if !substs.tps.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n-            format!(\"type parameters for node {:?} include inference types: {}\",\n+            format!(\"type parameters for node {:?} include inference types: \\\n+                     {}\",\n                     node,\n-                    substs.repr(bcx.tcx())));\n+                    substs.repr(bcx.tcx())).as_slice());\n     }\n \n     substs.substp(tcx, bcx.fcx.param_substs)\n@@ -816,7 +817,7 @@ pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                 _ => {\n                     tcx.sess.bug(format!(\n                         \"resolve_vtable_under_param_substs: asked to lookup \\\n-                         but no vtables in the fn_ctxt!\"))\n+                         but no vtables in the fn_ctxt!\").as_slice())\n                 }\n             }\n         }\n@@ -870,8 +871,8 @@ pub fn langcall(bcx: &Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => { bcx.tcx().sess.span_fatal(span, msg); }\n-                None => { bcx.tcx().sess.fatal(msg); }\n+                Some(span) => bcx.tcx().sess.span_fatal(span, msg.as_slice()),\n+                None => bcx.tcx().sess.fatal(msg.as_slice()),\n             }\n         }\n     }"}, {"sha": "8b43e99b6ac6d47c1eac313bef993ecaadce291d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -55,8 +55,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n-                        format!(\"integer literal has type {} (expected int or uint)\",\n-                                ty_to_str(cx.tcx(), lit_int_ty)))\n+                        format!(\"integer literal has type {} (expected int \\\n+                                 or uint)\",\n+                                ty_to_str(cx.tcx(), lit_int_ty)).as_slice())\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -150,14 +151,14 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_str(cx.tcx(), t)))\n+                                          ty_to_str(cx.tcx(), t)).as_slice())\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n             cx.sess().bug(format!(\"can't dereference const of type {}\",\n-                                  ty_to_str(cx.tcx(), t)))\n+                                  ty_to_str(cx.tcx(), t)).as_slice())\n         }\n     }\n }\n@@ -206,7 +207,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {:?}\",\n-                                        store))\n+                                        store).as_slice())\n                 }\n                 ty::AutoObject(..) => {\n                     cx.sess()\n@@ -256,11 +257,11 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     }\n                                 }\n                                 _ => {\n-                                    cx.sess().span_bug(e.span,\n-                                                       format!(\"unimplemented \\\n-                                                                const autoref \\\n-                                                                {:?}\",\n-                                                               autoref))\n+                                    cx.sess()\n+                                      .span_bug(e.span,\n+                                                format!(\"unimplemented const \\\n+                                                         autoref {:?}\",\n+                                                        autoref).as_slice())\n                                 }\n                             }\n                         }\n@@ -281,7 +282,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_str(cx.tcx(), ety),\n-                         csize, tsize));\n+                         csize, tsize).as_slice());\n     }\n     (llconst, inlineable)\n }"}, {"sha": "419b4f1e110a2944f750e7f36718824f5ba40286", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -165,7 +165,7 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name, thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(name.as_slice(), thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n     debuginfo::clear_source_location(bcx.fcx);\n \n@@ -287,7 +287,8 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n             match bcx.tcx().def_map.borrow().find(&expr_id) {\n                 Some(&ast::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\", r))\n+                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n+                                               r).as_slice())\n                 }\n             }\n         }"}, {"sha": "48b429c6976c2bd89753e032ccd6702be96bc144", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -317,16 +317,21 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemStatic(..) => (item.ident, item.span),\n-                _ => cx.sess().span_bug(item.span,\n-                                        format!(\"debuginfo::create_global_var_metadata() -\n-                                                Captured var-id refers to unexpected ast_item\n-                                                variant: {:?}\",\n-                                                var_item))\n+                _ => {\n+                    cx.sess()\n+                      .span_bug(item.span,\n+                                format!(\"debuginfo::\\\n+                                         create_global_var_metadata() -\n+                                         Captured var-id refers to \\\n+                                         unexpected ast_item variant: {:?}\",\n+                                        var_item).as_slice())\n+                }\n             }\n         },\n-        _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() - Captured var-id \\\n-                                   refers to unexpected ast_map variant: {:?}\",\n-                                   var_item))\n+        _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n+                                    - Captured var-id refers to unexpected \\\n+                                    ast_map variant: {:?}\",\n+                                   var_item).as_slice())\n     };\n \n     let filename = span_start(cx, span).file.name.clone();\n@@ -340,7 +345,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_str();\n-    let linkage_name = namespace_node.mangled_name_of_contained_item(var_name);\n+    let linkage_name =\n+        namespace_node.mangled_name_of_contained_item(var_name.as_slice());\n     let var_scope = namespace_node.scope;\n \n     var_name.as_slice().with_c_str(|var_name| {\n@@ -380,7 +386,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {:?}\",\n-                            node_id));\n+                            node_id).as_slice());\n             }\n         };\n \n@@ -430,13 +436,17 @@ pub fn create_captured_var_metadata(bcx: &Block,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                 ast_item));\n+                                 ast_item).as_slice());\n                 }\n             }\n         }\n         _ => {\n-            cx.sess().span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n-                Captured var-id refers to unexpected ast_map variant: {:?}\", ast_item));\n+            cx.sess()\n+              .span_bug(span,\n+                        format!(\"debuginfo::create_captured_var_metadata() - \\\n+                                 Captured var-id refers to unexpected \\\n+                                 ast_map variant: {:?}\",\n+                                ast_item).as_slice());\n         }\n     };\n \n@@ -519,7 +529,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in llargs table for {:?}\",\n-                            node_id));\n+                            node_id).as_slice());\n             }\n         };\n \n@@ -653,7 +663,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 ast::ExprFnBlock(fn_decl, top_level_block) |\n                 ast::ExprProc(fn_decl, top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name);\n+                    let name = token::str_to_ident(name.as_slice());\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n@@ -681,7 +691,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                    fnitem))\n+                                    fnitem).as_slice())\n                 }\n             }\n         }\n@@ -691,7 +701,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\", fnitem))\n+                                    unexpected sort of node: {:?}\",\n+                                   fnitem).as_slice())\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1124,7 +1135,8 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx.map.get(node_id);\n \n             fcx.ccx.sess().span_bug(span,\n-                format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n+                format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                        node).as_slice());\n         }\n     }\n }\n@@ -1499,14 +1511,17 @@ fn describe_enum_variant(cx: &CrateContext,\n     // Get the argument names from the enum variant info\n     let mut arg_names: Vec<_> = match variant_info.arg_names {\n         Some(ref names) => {\n-            names.iter().map(|ident| token::get_ident(*ident).get().to_str()).collect()\n+            names.iter()\n+                 .map(|ident| {\n+                     token::get_ident(*ident).get().to_str().into_strbuf()\n+                 }).collect()\n         }\n-        None => variant_info.args.iter().map(|_| \"\".to_owned()).collect()\n+        None => variant_info.args.iter().map(|_| \"\".to_strbuf()).collect()\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n     if discriminant_type_metadata.is_some() {\n-        arg_names.insert(0, \"\".to_owned());\n+        arg_names.insert(0, \"\".to_strbuf());\n     }\n \n     // Build an array of (field name, field type) pairs to be captured in the factory closure.\n@@ -1861,7 +1876,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                     -> DICompositeType {\n     let box_type_name = match content_type_name {\n         Some(content_type_name) => format!(\"Boxed<{}>\", content_type_name),\n-        None                    => \"BoxedType\".to_owned()\n+        None                    => \"BoxedType\".to_strbuf()\n     };\n \n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n@@ -1913,7 +1928,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n     return composite_type_metadata(\n         cx,\n         box_llvm_type,\n-        box_type_name,\n+        box_type_name.as_slice(),\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n@@ -1971,7 +1986,9 @@ fn vec_metadata(cx: &CrateContext,\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n     let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx(), element_type));\n+    let vec_type_name = format!(\"[{}]\",\n+                                ppaux::ty_to_str(cx.tcx(), element_type));\n+    let vec_type_name = vec_type_name.as_slice();\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -2254,7 +2271,11 @@ fn type_metadata(cx: &CrateContext,\n                                    elements.as_slice(),\n                                    usage_site_span).finalize(cx)\n         }\n-        _ => cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n+        _ => {\n+            cx.sess().bug(format!(\"debuginfo: unexpected type in \\\n+                                   type_metadata: {:?}\",\n+                                  sty).as_slice())\n+        }\n     };\n \n     debug_context(cx).created_types.borrow_mut().insert(cache_id, type_metadata);\n@@ -2852,13 +2873,13 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len()));\n+            output.push_str(format!(\"{}\", string.get().len()).as_slice());\n             output.push_str(string.get());\n         }\n \n         let mut name = StrBuf::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len()));\n+        name.push_str(format!(\"{}\", item_name.len()).as_slice());\n         name.push_str(item_name);\n         name.push_char('E');\n         name\n@@ -2941,7 +2962,8 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             Some(node) => node,\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n-                    path too short for {:?}\", def_id));\n+                                       path too short for {:?}\",\n+                                      def_id).as_slice());\n             }\n         }\n     })"}, {"sha": "024d47ac0ef0a635aca7570662f66bde7bbd6185", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -421,8 +421,8 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n-                      fall-through case: {:?}\",\n-                     expr.node));\n+                         fall-through case: {:?}\",\n+                        expr.node).as_slice());\n         }\n     }\n }\n@@ -635,8 +635,8 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                      fall-through case: {:?}\",\n-                     expr.node));\n+                         fall-through case: {:?}\",\n+                        expr.node).as_slice());\n         }\n     }\n }\n@@ -765,8 +765,9 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_dps_unadjusted reached fall-through case: {:?}\",\n-                     expr.node));\n+                format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n+                         case: {:?}\",\n+                        expr.node).as_slice());\n         }\n     }\n }\n@@ -815,7 +816,7 @@ fn trans_def_dps_unadjusted<'a>(\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_str(ref_expr.id)));\n+                def, bcx.node_id_to_str(ref_expr.id)).as_slice());\n         }\n     }\n }\n@@ -839,7 +840,7 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(bcx.tcx())));\n+                    ref_expr.repr(bcx.tcx())).as_slice());\n         }\n     };\n \n@@ -865,7 +866,8 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n                 Some(&val) => Datum(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n-                        \"trans_local_var: no llval for upvar {:?} found\", nid));\n+                        \"trans_local_var: no llval for upvar {:?} found\",\n+                        nid).as_slice());\n                 }\n             }\n         }\n@@ -877,7 +879,8 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n-                \"unsupported def type in trans_local_var: {:?}\", def));\n+                \"unsupported def type in trans_local_var: {:?}\",\n+                def).as_slice());\n         }\n     };\n \n@@ -889,7 +892,8 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n             Some(&v) => v,\n             None => {\n                 bcx.sess().bug(format!(\n-                    \"trans_local_var: no datum for local/arg {:?} found\", nid));\n+                    \"trans_local_var: no datum for local/arg {:?} found\",\n+                    nid).as_slice());\n             }\n         };\n         debug!(\"take_local(nid={:?}, v={}, ty={})\",\n@@ -922,7 +926,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                     tcx.sess.bug(format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)));\n+                        ty.repr(tcx)).as_slice());\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow().get_copy(&node_id);\n@@ -947,7 +951,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n         _ => {\n             tcx.sess.bug(format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)));\n+                ty.repr(tcx)).as_slice());\n         }\n     }\n }\n@@ -1586,16 +1590,22 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                                           val_ty(lldiscrim_a),\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                _ => {\n+                    ccx.sess().bug(format!(\"translating unsupported cast: \\\n                                             {} ({:?}) -> {} ({:?})\",\n-                                            t_in.repr(bcx.tcx()), k_in,\n-                                            t_out.repr(bcx.tcx()), k_out))\n+                                            t_in.repr(bcx.tcx()),\n+                                            k_in,\n+                                            t_out.repr(bcx.tcx()),\n+                                            k_out).as_slice())\n+                }\n             }\n         }\n         _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n                                     {} ({:?}) -> {} ({:?})\",\n-                                    t_in.repr(bcx.tcx()), k_in,\n-                                    t_out.repr(bcx.tcx()), k_out))\n+                                    t_in.repr(bcx.tcx()),\n+                                    k_in,\n+                                    t_out.repr(bcx.tcx()),\n+                                    k_out).as_slice())\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -1757,7 +1767,7 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())));\n+                        datum.ty.repr(bcx.tcx())).as_slice());\n         }\n     };\n "}, {"sha": "46c987270e3af6ce3de9ab7d198aad52c1d793c5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -81,13 +81,12 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n         match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n-                ccx.sess().bug(format!(\"asked to register intrinsic fn\"));\n+                ccx.sess().bug(\"asked to register intrinsic fn\");\n             }\n \n             Rust => {\n                 // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess().unimpl(\n-                    format!(\"foreign functions with Rust ABI\"));\n+                ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n             }\n \n             // It's the ABI's job to select this, not us.\n@@ -202,14 +201,14 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n                 Some(s) => {\n                     ccx.sess().span_fatal(s,\n                         format!(\"ABI `{}` has no suitable calling convention \\\n-                              for target architecture\",\n-                              abi.user_string(ccx.tcx())))\n+                                 for target architecture\",\n+                                abi.user_string(ccx.tcx())).as_slice())\n                 }\n                 None => {\n                     ccx.sess().fatal(\n                         format!(\"ABI `{}` has no suitable calling convention \\\n-                              for target architecture\",\n-                              abi.user_string(ccx.tcx())))\n+                                 for target architecture\",\n+                                abi.user_string(ccx.tcx())).as_slice())\n                 }\n             }\n         }\n@@ -370,8 +369,8 @@ pub fn trans_native_call<'a>(\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n-                        for target architecture\",\n-                        fn_abi.user_string(ccx.tcx())));\n+                         for target architecture\",\n+                         fn_abi.user_string(ccx.tcx())).as_slice());\n         }\n     };\n \n@@ -555,9 +554,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             }\n             _ => {\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n-                                       expected a bare fn ty\",\n+                                        expected a bare fn ty\",\n                                        ccx.tcx.map.path_to_str(id),\n-                                       t.repr(tcx)));\n+                                       t.repr(tcx)).as_slice());\n             }\n         };\n "}, {"sha": "aeb7a4641c08c60f4405e727174053a58da0b903", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -396,7 +396,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                             intype = ty_to_str(ccx.tcx(), in_type),\n                             insize = in_type_size as uint,\n                             outtype = ty_to_str(ccx.tcx(), out_type),\n-                            outsize = out_type_size as uint));\n+                            outsize = out_type_size as uint).as_slice());\n             }\n \n             if !return_type_is_void(ccx, out_type) {"}, {"sha": "3076a19228c39dc2acf04a79dbca156b3818c204", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -205,7 +205,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         hash_id.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n-        exported_name(path, format!(\"h{}\", state.result()),\n+        exported_name(path,\n+                      format!(\"h{}\", state.result()).as_slice(),\n                       ccx.link_meta.crateid.version_or_default())\n     });\n     debug!(\"monomorphize_fn mangled to {}\", s);\n@@ -287,7 +288,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                 }\n                 _ => {\n                     ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n-                                           map_node))\n+                                           map_node).as_slice())\n                 }\n             }\n         }\n@@ -311,7 +312,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {:?}\", map_node))\n+            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+                                   map_node).as_slice())\n         }\n     };\n "}, {"sha": "ff485a9cf5dfb7996831f838cbc029b1a9dd6928", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -155,7 +155,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) |\n         ty::ty_err(..) | ty::ty_vec(_, None) | ty::ty_str => {\n             cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n-                                  ty::get(t).sty))\n+                                  ty::get(t).sty).as_slice())\n         }\n     };\n "}, {"sha": "6a7ad8f0bd9170e8677cd94d49d4084331639f2a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -2620,7 +2620,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n         Some(t) => t.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                cx.map.node_to_str(id)))\n+                    cx.map.node_to_str(id)).as_slice())\n     }\n }\n \n@@ -2633,7 +2633,7 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n        Some(t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-               cx.map.node_to_str(id)))\n+                   cx.map.node_to_str(id)).as_slice())\n     }\n }\n \n@@ -2717,7 +2717,8 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on in appropriate ty: {:?}\", s));\n+                format!(\"ty_region() invoked on in appropriate ty: {:?}\",\n+                        s).as_slice());\n         }\n     }\n }\n@@ -2774,11 +2775,12 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         }\n         Some(f) => {\n             cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n-                                id, f));\n+                                id,\n+                                f).as_slice());\n         }\n         None => {\n             cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id));\n+                                in the node map\", id).as_slice());\n         }\n     }\n }\n@@ -2793,14 +2795,15 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 _ => {\n                     cx.sess.bug(\n                         format!(\"Variable id {} maps to {:?}, not local\",\n-                                id, pat));\n+                                id,\n+                                pat).as_slice());\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(\n-                format!(\"Variable id {} maps to {:?}, not local\",\n-                        id, r));\n+            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n+                                id,\n+                                r).as_slice());\n         }\n     }\n }\n@@ -2832,7 +2835,7 @@ pub fn adjust_ty(cx: &ctxt,\n                             cx.sess.bug(\n                                 format!(\"add_env adjustment on non-bare-fn: \\\n                                          {:?}\",\n-                                        b));\n+                                        b).as_slice());\n                         }\n                     }\n                 }\n@@ -2857,7 +2860,8 @@ pub fn adjust_ty(cx: &ctxt,\n                                         format!(\"the {}th autoderef failed: \\\n                                                 {}\",\n                                                 i,\n-                                                ty_to_str(cx, adjusted_ty)));\n+                                                ty_to_str(cx, adjusted_ty))\n+                                                          .as_slice());\n                                 }\n                             }\n                         }\n@@ -2923,15 +2927,17 @@ pub fn adjust_ty(cx: &ctxt,\n                 _ => {\n                     cx.sess.span_bug(\n                         span,\n-                        format!(\"borrow-vec associated with bad sty: {:?}\", get(ty).sty));\n+                        format!(\"borrow-vec associated with bad sty: {:?}\",\n+                                get(ty).sty).as_slice());\n                 }\n             },\n             ty_vec(mt, Some(_)) => ty::mk_slice(cx, r, ty::mt {ty: mt.ty, mutbl: m}),\n \n             ref s => {\n                 cx.sess.span_bug(\n                     span,\n-                    format!(\"borrow-vec associated with bad sty: {:?}\", s));\n+                    format!(\"borrow-vec associated with bad sty: {:?}\",\n+                            s).as_slice());\n             }\n         }\n     }\n@@ -2947,7 +2953,7 @@ pub fn adjust_ty(cx: &ctxt,\n                 cx.sess.span_bug(\n                     span,\n                     format!(\"borrow-trait-obj associated with bad sty: {:?}\",\n-                         s));\n+                            s).as_slice());\n             }\n         }\n     }\n@@ -2996,7 +3002,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {:?}\", expr.id));\n+                \"no def-map entry for expr {:?}\", expr.id).as_slice());\n         }\n     }\n }\n@@ -3070,9 +3076,11 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 ast::DefLocal(..) => LvalueExpr,\n \n                 def => {\n-                    tcx.sess.span_bug(expr.span, format!(\n-                        \"uncategorized def for expr {:?}: {:?}\",\n-                        expr.id, def));\n+                    tcx.sess.span_bug(\n+                        expr.span,\n+                        format!(\"uncategorized def for expr {:?}: {:?}\",\n+                                expr.id,\n+                                def).as_slice());\n                 }\n             }\n         }\n@@ -3193,7 +3201,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_ident(f.ident).get().to_strbuf())\n-              .collect::<Vec<StrBuf>>()));\n+              .collect::<Vec<StrBuf>>()).as_slice());\n }\n \n pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n@@ -3444,10 +3452,18 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n                         let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n                         p.iter().map(|m| method(cx, ast_util::local_def(m.id))).collect()\n                     }\n-                    _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n+                    _ => {\n+                        cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n+                                             not a trait\",\n+                                            id).as_slice())\n+                    }\n                 }\n             }\n-            _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n+            _ => {\n+                cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n+                                     trait\",\n+                                    id).as_slice())\n+            }\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)\n@@ -3800,7 +3816,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                                         cx.sess\n                                           .span_err(e.span,\n                                                     format!(\"expected constant: {}\",\n-                                                            *err));\n+                                                            *err).as_slice());\n                                     }\n                                 },\n                                 None => {}\n@@ -3963,7 +3979,7 @@ fn each_super_struct(cx: &ctxt, mut did: ast::DefId, f: |ast::DefId|) {\n             None => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to super-struct: {}\",\n-                        cx.map.node_to_str(did.node)));\n+                            cx.map.node_to_str(did.node)).as_slice());\n             }\n         }\n     }\n@@ -3985,7 +4001,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n                 _ => {\n                     cx.sess.bug(\n                         format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_str(did.node)));\n+                                cx.map.node_to_str(did.node)).as_slice());\n                 }\n             }\n         });"}, {"sha": "9cc5d2d73ca1d71fc0e9cc0e199bceb24f84a1f7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -180,7 +180,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n                 format!(\"wrong number of lifetime parameters: \\\n                         expected {} but found {}\",\n                         expected_num_region_params,\n-                        supplied_num_region_params));\n+                        supplied_num_region_params).as_slice());\n         }\n \n         match anon_regions {\n@@ -204,7 +204,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         };\n         this.tcx().sess.span_fatal(path.span,\n             format!(\"wrong number of type arguments: {} {} but found {}\",\n-                expected, required_ty_param_count, supplied_ty_param_count));\n+                    expected,\n+                    required_ty_param_count,\n+                    supplied_ty_param_count).as_slice());\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n@@ -213,7 +215,9 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n         };\n         this.tcx().sess.span_fatal(path.span,\n             format!(\"wrong number of type arguments: {} {} but found {}\",\n-                expected, formal_ty_param_count, supplied_ty_param_count));\n+                    expected,\n+                    formal_ty_param_count,\n+                    supplied_ty_param_count).as_slice());\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -317,8 +321,11 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match tcx.def_map.borrow().find(&id) {\n-                None => tcx.sess.span_bug(\n-                    ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n+                None => {\n+                    tcx.sess.span_bug(ast_ty.span,\n+                                      format!(\"unbound path {}\",\n+                                              path_to_str(path)).as_slice())\n+                }\n                 Some(&d) => d\n             };\n             match a_def {\n@@ -382,8 +389,13 @@ pub fn ast_ty_to_builtin_ty<AC:AstConv,\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match this.tcx().def_map.borrow().find(&id) {\n-                None => this.tcx().sess.span_bug(\n-                    ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n+                None => {\n+                    this.tcx()\n+                        .sess\n+                        .span_bug(ast_ty.span,\n+                                  format!(\"unbound path {}\",\n+                                          path_to_str(path)).as_slice())\n+                }\n                 Some(&d) => d\n             };\n \n@@ -493,8 +505,11 @@ fn mk_pointer<AC:AstConv,\n                         RPtr(r) => {\n                             return ty::mk_str_slice(tcx, r, ast::MutImmutable);\n                         }\n-                        _ => tcx.sess.span_err(path.span,\n-                                               format!(\"managed strings are not supported\")),\n+                        _ => {\n+                            tcx.sess\n+                               .span_err(path.span,\n+                                         \"managed strings are not supported\")\n+                        }\n                     }\n                 }\n                 Some(&ast::DefTrait(trait_def_id)) => {\n@@ -635,8 +650,12 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().find(&id) {\n-                    None => tcx.sess.span_bug(\n-                        ast_ty.span, format!(\"unbound path {}\", path_to_str(path))),\n+                    None => {\n+                        tcx.sess\n+                           .span_bug(ast_ty.span,\n+                                     format!(\"unbound path {}\",\n+                                             path_to_str(path)).as_slice())\n+                    }\n                     Some(&d) => d\n                 };\n                 // Kind bounds on path types are only supported for traits.\n@@ -653,8 +672,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         let path_str = path_to_str(path);\n                         tcx.sess.span_err(\n                             ast_ty.span,\n-                            format!(\"reference to trait `{name}` where a type is expected; \\\n-                                    try `Box<{name}>` or `&{name}`\", name=path_str));\n+                            format!(\"reference to trait `{name}` where a \\\n+                                     type is expected; try `Box<{name}>` or \\\n+                                     `&{name}`\",\n+                                    name=path_str).as_slice());\n                         ty::mk_err()\n                     }\n                     ast::DefTy(did) | ast::DefStruct(did) => {\n@@ -675,14 +696,16 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     ast::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_str(id.node)));\n+                                    tcx.map.node_to_str(id.node)).as_slice());\n                     }\n                     ast::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n-                            format!(\"found value name used as a type: {:?}\", a_def));\n+                                            format!(\"found value name used \\\n+                                                     as a type: {:?}\",\n+                                                    a_def).as_slice());\n                     }\n                 }\n             }\n@@ -705,7 +728,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     Err(ref r) => {\n                         tcx.sess.span_fatal(\n                             ast_ty.span,\n-                            format!(\"expected constant expr for vector length: {}\", *r));\n+                            format!(\"expected constant expr for vector \\\n+                                     length: {}\",\n+                                    *r).as_slice());\n                     }\n                 }\n             }\n@@ -897,8 +922,8 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n                         }\n                         tcx.sess.span_fatal(\n                             b.path.span,\n-                            format!(\"only the builtin traits can be used \\\n-                                  as closure or object bounds\"));\n+                            \"only the builtin traits can be used as closure \\\n+                             or object bounds\");\n                     }\n                     ast::StaticRegionTyParamBound => {\n                         builtin_bounds.add(ty::BoundStatic);\n@@ -907,8 +932,8 @@ fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OwnedSlice<ast::TyPar\n                         if !tcx.sess.features.issue_5723_bootstrap.get() {\n                             tcx.sess.span_err(\n                                 span,\n-                                format!(\"only the 'static lifetime is \\\n-                                         accepted here.\"));\n+                                \"only the 'static lifetime is accepted \\\n+                                 here.\");\n                         }\n                     }\n                 }"}, {"sha": "6e164d07015d2cd104111e9b4a0d795d9c392259", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -263,7 +263,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                          npat = subpats_len,\n                          kind = kind_name,\n                          narg = arg_len);\n-            tcx.sess.span_err(pat.span, s);\n+            tcx.sess.span_err(pat.span, s.as_slice());\n             error_happened = true;\n         }\n \n@@ -280,7 +280,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                                    {npat, plural, =1{# field} other{# fields}}, \\\n                                    but the corresponding {kind} has no fields\",\n                                npat = subpats_len,\n-                               kind = kind_name));\n+                               kind = kind_name).as_slice());\n         error_happened = true;\n     }\n \n@@ -324,7 +324,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             Some(&(_, true)) => {\n                 tcx.sess.span_err(span,\n                     format!(\"field `{}` bound twice in pattern\",\n-                            token::get_ident(field.ident)));\n+                            token::get_ident(field.ident)).as_slice());\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n@@ -343,8 +343,8 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 check_pat(pcx, field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n                     format!(\"struct `{}` does not have a field named `{}`\",\n-                         name,\n-                         token::get_ident(field.ident)));\n+                            name,\n+                            token::get_ident(field.ident)).as_slice());\n             }\n         }\n     }\n@@ -356,9 +356,10 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 continue;\n             }\n \n-            tcx.sess.span_err(span,\n-                              format!(\"pattern does not mention field `{}`\",\n-                                  token::get_name(field.name)));\n+            tcx.sess\n+               .span_err(span,\n+                         format!(\"pattern does not mention field `{}`\",\n+                                 token::get_name(field.name)).as_slice());\n         }\n     }\n }\n@@ -381,10 +382,12 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n         }\n         Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n             let name = pprust::path_to_str(path);\n-            tcx.sess.span_err(span,\n-                              format!(\"mismatched types: expected `{}` but found `{}`\",\n-                                   fcx.infcx().ty_to_str(expected),\n-                                   name));\n+            tcx.sess\n+               .span_err(span,\n+                         format!(\"mismatched types: expected `{}` but found \\\n+                                  `{}`\",\n+                                 fcx.infcx().ty_to_str(expected),\n+                                 name).as_slice());\n         }\n         _ => {\n             tcx.sess.span_bug(span, \"resolve didn't write in struct ID\");\n@@ -421,9 +424,9 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n             let name = pprust::path_to_str(path);\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n-                                    found `{}`\",\n-                                   fcx.infcx().ty_to_str(expected),\n-                                   name));\n+                                       found `{}`\",\n+                                      fcx.infcx().ty_to_str(expected),\n+                                      name).as_slice());\n         }\n         _ => {\n             tcx.sess.span_bug(span, \"resolve didn't write in variant\");"}, {"sha": "d512de670bc80a79f1364a95719bbf1e76dcf96d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -284,7 +284,7 @@ fn construct_transformed_self_ty_for_object(\n                 _ => {\n                     tcx.sess.span_bug(span,\n                         format!(\"'impossible' transformed_self_ty: {}\",\n-                                transformed_self_ty.repr(tcx)));\n+                                transformed_self_ty.repr(tcx)).as_slice());\n                 }\n             }\n         }\n@@ -950,7 +950,7 @@ impl<'a> LookupContext<'a> {\n \n             ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"unexpected type: {}\",\n-                              self.ty_to_str(self_ty)));\n+                                 self.ty_to_str(self_ty)).as_slice());\n             }\n         }\n     }\n@@ -1235,9 +1235,10 @@ impl<'a> LookupContext<'a> {\n                                 rcvr_ty, transformed_self_ty) {\n             Ok(_) => {}\n             Err(_) => {\n-                self.bug(format!(\"{} was a subtype of {} but now is not?\",\n-                              self.ty_to_str(rcvr_ty),\n-                              self.ty_to_str(transformed_self_ty)));\n+                self.bug(format!(\n+                        \"{} was a subtype of {} but now is not?\",\n+                        self.ty_to_str(rcvr_ty),\n+                        self.ty_to_str(transformed_self_ty)).as_slice());\n             }\n         }\n \n@@ -1465,25 +1466,25 @@ impl<'a> LookupContext<'a> {\n         self.tcx().sess.span_note(\n             span,\n             format!(\"candidate \\\\#{} is `{}`\",\n-                 idx+1u,\n-                 ty::item_path_str(self.tcx(), did)));\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n     fn report_param_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.span,\n             format!(\"candidate \\\\#{} derives from the bound `{}`\",\n-                 idx+1u,\n-                 ty::item_path_str(self.tcx(), did)));\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n     fn report_trait_candidate(&self, idx: uint, did: DefId) {\n         self.tcx().sess.span_note(\n             self.span,\n             format!(\"candidate \\\\#{} derives from the type of the receiver, \\\n-                  which is the trait `{}`\",\n-                 idx+1u,\n-                 ty::item_path_str(self.tcx(), did)));\n+                     which is the trait `{}`\",\n+                    idx + 1u,\n+                    ty::item_path_str(self.tcx(), did)).as_slice());\n     }\n \n     fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {"}, {"sha": "cc9bff899478aa978bd7cc3dc085ccd65bdf09be", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 99, "deletions": 65, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -546,8 +546,11 @@ fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -\n                 _ => false,\n             }) {\n                 Some(f) => f.span,\n-                None => tcx.sess.bug(format!(\"Could not find field {}\",\n-                                             token::get_name(field.name))),\n+                None => {\n+                    tcx.sess\n+                       .bug(format!(\"Could not find field {}\",\n+                                    token::get_name(field.name)).as_slice())\n+                }\n             }\n         },\n         _ => tcx.sess.bug(\"Field found outside of a struct?\"),\n@@ -569,8 +572,9 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n                 match super_fields.iter().find(|sf| f.name == sf.name) {\n                     Some(prev_field) => {\n                         tcx.sess.span_err(span_for_field(tcx, f, id),\n-                            format!(\"field `{}` hides field declared in super-struct\",\n-                                    token::get_name(f.name)));\n+                            format!(\"field `{}` hides field declared in \\\n+                                     super-struct\",\n+                                    token::get_name(f.name)).as_slice());\n                         tcx.sess.span_note(span_for_field(tcx, prev_field, parent_id),\n                             \"previously declared here\");\n                     },\n@@ -593,11 +597,13 @@ fn check_fields_sized(tcx: &ty::ctxt,\n         if !ty::type_is_sized(tcx, t) {\n             match f.node.kind {\n                 ast::NamedField(ident, _) => {\n-                    tcx.sess.span_err(f.span, format!(\"type `{}` is dynamically sized. \\\n-                                                       dynamically sized types may only \\\n-                                                       appear as the type of the final \\\n-                                                       field in a struct\",\n-                                                      token::get_ident(ident)));\n+                    tcx.sess.span_err(\n+                        f.span,\n+                        format!(\"type `{}` is dynamically sized. \\\n+                                 dynamically sized types may only \\\n+                                 appear as the type of the final \\\n+                                 field in a struct\",\n+                                 token::get_ident(ident)).as_slice());\n                 }\n                 ast::UnnamedField(_) => {\n                     tcx.sess.span_err(f.span, \"dynamically sized type in field\");\n@@ -814,9 +820,10 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n             None => {\n                 tcx.sess.span_err(\n                     impl_method.span,\n-                    format!(\"method `{}` is not a member of trait `{}`\",\n-                            token::get_ident(impl_method_ty.ident),\n-                            pprust::path_to_str(&ast_trait_ref.path)));\n+                    format!(\n+                        \"method `{}` is not a member of trait `{}`\",\n+                        token::get_ident(impl_method_ty.ident),\n+                        pprust::path_to_str(&ast_trait_ref.path)).as_slice());\n             }\n         }\n     }\n@@ -842,7 +849,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n         tcx.sess.span_err(\n             impl_span,\n             format!(\"not all trait methods implemented, missing: {}\",\n-                    missing_methods.connect(\", \")));\n+                    missing_methods.connect(\", \")).as_slice());\n     }\n }\n \n@@ -886,7 +893,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(impl_m.explicit_self)));\n+                        pprust::explicit_self_to_str(\n+                            impl_m.explicit_self)).as_slice());\n             return;\n         }\n         (_, &ast::SelfStatic) => {\n@@ -895,7 +903,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(trait_m.explicit_self)));\n+                        pprust::explicit_self_to_str(\n+                            trait_m.explicit_self)).as_slice());\n             return;\n         }\n         _ => {\n@@ -914,7 +923,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                                                                  other{# type parameters}}\",\n                     method = token::get_ident(trait_m.ident),\n                     nimpl = num_impl_m_type_params,\n-                    ntrait = num_trait_m_type_params));\n+                    ntrait = num_trait_m_type_params).as_slice());\n         return;\n     }\n \n@@ -927,7 +936,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                  method = token::get_ident(trait_m.ident),\n                  nimpl = impl_m.fty.sig.inputs.len(),\n                  trait = ty::item_path_str(tcx, trait_m.def_id),\n-                 ntrait = trait_m.fty.sig.inputs.len()));\n+                 ntrait = trait_m.fty.sig.inputs.len()).as_slice());\n         return;\n     }\n \n@@ -950,7 +959,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                        in the trait declaration\",\n                        token::get_ident(trait_m.ident),\n                        i,\n-                       extra_bounds.user_string(tcx)));\n+                       extra_bounds.user_string(tcx)).as_slice());\n            return;\n         }\n \n@@ -971,7 +980,9 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                         method = token::get_ident(trait_m.ident),\n                         typaram = i,\n                         nimpl = impl_param_def.bounds.trait_bounds.len(),\n-                        ntrait = trait_param_def.bounds.trait_bounds.len()));\n+                        ntrait = trait_param_def.bounds\n+                                                .trait_bounds\n+                                                .len()).as_slice());\n             return;\n         }\n     }\n@@ -1040,7 +1051,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 impl_m_span,\n                 format!(\"method `{}` has an incompatible type for trait: {}\",\n                         token::get_ident(trait_m.ident),\n-                        ty::type_err_to_str(tcx, terr)));\n+                        ty::type_err_to_str(tcx, terr)).as_slice());\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n     }\n@@ -1099,7 +1110,8 @@ impl<'a> FnCtxt<'a> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"no type for local variable {:?}\", nid));\n+                    format!(\"no type for local variable {:?}\",\n+                            nid).as_slice());\n             }\n         }\n     }\n@@ -1173,7 +1185,7 @@ impl<'a> FnCtxt<'a> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag()));\n+                                            self.tag()).as_slice());\n             }\n         }\n     }\n@@ -1185,7 +1197,7 @@ impl<'a> FnCtxt<'a> {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_str(id),\n-                            self.tag()));\n+                            self.tag()).as_slice());\n             }\n         }\n     }\n@@ -1197,7 +1209,7 @@ impl<'a> FnCtxt<'a> {\n                 self.tcx().sess.bug(\n                     format!(\"no method entry for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_str(id),\n-                            self.tag()));\n+                            self.tag()).as_slice());\n             }\n         }\n     }\n@@ -1350,7 +1362,7 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     // We've reached the recursion limit, error gracefully.\n     fcx.tcx().sess.span_err(sp,\n         format!(\"reached the recursion limit while auto-dereferencing {}\",\n-                base_ty.repr(fcx.tcx())));\n+                base_ty.repr(fcx.tcx())).as_slice());\n     (ty::mk_err(), 0, None)\n }\n \n@@ -1607,7 +1619,7 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                                        found {nsupplied, plural, =1{# lifetime parameter} \\\n                                                               other{# lifetime parameters}}\",\n                                       nexpected = trait_region_parameter_count,\n-                                      nsupplied = supplied_region_parameter_count));\n+                                      nsupplied = supplied_region_parameter_count).as_slice());\n             }\n \n             // Make sure the number of type parameters supplied on the trait\n@@ -1638,7 +1650,8 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                             nexpected = required_ty_param_count,\n                             nsupplied = supplied_ty_param_count)\n                 };\n-                function_context.tcx().sess.span_err(path.span, msg)\n+                function_context.tcx().sess.span_err(path.span,\n+                                                     msg.as_slice())\n             } else if supplied_ty_param_count > formal_ty_param_count {\n                 let msg = if required_ty_param_count < generics.type_param_defs().len() {\n                     format!(\"the {trait_or_impl} referenced by this path needs at most \\\n@@ -1659,7 +1672,8 @@ fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                             nexpected = formal_ty_param_count,\n                             nsupplied = supplied_ty_param_count)\n                 };\n-                function_context.tcx().sess.span_err(path.span, msg)\n+                function_context.tcx().sess.span_err(path.span,\n+                                                     msg.as_slice())\n             }\n         }\n         _ => {\n@@ -1727,9 +1741,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     fty.sig.output\n                 }\n                 _ => {\n-                    fcx.tcx().sess.span_bug(\n-                        callee_expr.span,\n-                        format!(\"method without bare fn type\"));\n+                    fcx.tcx().sess.span_bug(callee_expr.span,\n+                                            \"method without bare fn type\");\n                 }\n             }\n         }\n@@ -1768,7 +1781,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                      nexpected = expected_arg_count,\n                      nsupplied = supplied_arg_count);\n \n-                tcx.sess.span_err(sp, msg);\n+                tcx.sess.span_err(sp, msg.as_slice());\n \n                 err_args(supplied_arg_count)\n             }\n@@ -1781,7 +1794,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                  nexpected = expected_arg_count,\n                  nsupplied = supplied_arg_count);\n \n-            tcx.sess.span_err(sp, msg);\n+            tcx.sess.span_err(sp, msg.as_slice());\n \n             err_args(supplied_arg_count)\n         };\n@@ -2484,7 +2497,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     tcx.sess.span_err(\n                         field.ident.span,\n                         format!(\"field `{}` specified more than once\",\n-                            token::get_ident(field.ident.node)));\n+                                token::get_ident(field.ident\n+                                                      .node)).as_slice());\n                     error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n@@ -2517,14 +2531,16 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let name = class_field.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n-                        missing_fields.push(\"`\".to_owned() + token::get_name(name).get() + \"`\");\n+                        missing_fields.push(\n+                            format!(\"`{}`\", token::get_name(name).get()))\n                     }\n                 }\n \n                 tcx.sess.span_err(span,\n-                    format!(\"missing {nfields, plural, =1{field} other{fields}}: {fields}\",\n-                            nfields = missing_fields.len(),\n-                            fields = missing_fields.connect(\", \")));\n+                    format!(\n+                        \"missing {nfields, plural, =1{field} other{fields}}: {fields}\",\n+                        nfields = missing_fields.len(),\n+                        fields = missing_fields.connect(\", \")).as_slice());\n              }\n         }\n \n@@ -3589,7 +3605,7 @@ pub fn check_representable(tcx: &ty::ctxt,\n         tcx.sess.span_err(\n           sp, format!(\"illegal recursive {} type; \\\n                        wrap the inner value in a box to make it representable\",\n-                      designation));\n+                      designation).as_slice());\n         return false\n       }\n       ty::Representable | ty::ContainsRecursive => (),\n@@ -3614,10 +3630,12 @@ pub fn check_instantiable(tcx: &ty::ctxt,\n                           -> bool {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess.span_err(sp, format!(\"this type cannot be instantiated \\\n-                  without an instance of itself; \\\n-                  consider using `Option<{}>`\",\n-                                   ppaux::ty_to_str(tcx, item_ty)));\n+        tcx.sess\n+           .span_err(sp,\n+                     format!(\"this type cannot be instantiated without an \\\n+                              instance of itself; consider using \\\n+                              `Option<{}>`\",\n+                             ppaux::ty_to_str(tcx, item_ty)).as_slice());\n         false\n     } else {\n         true\n@@ -3670,11 +3688,16 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     // A struct value with an unsized final field is itself\n                     // unsized and we must track this in the type system.\n                     if !ty::type_is_sized(ccx.tcx, *t) {\n-                        ccx.tcx.sess.span_err(args.get(i).ty.span,\n-                                              format!(\"type `{}` is dynamically sized. \\\n-                                                       dynamically sized types may only \\\n-                                                       appear as the final type in a variant\",\n-                                                      ppaux::ty_to_str(ccx.tcx, *t)));\n+                        ccx.tcx\n+                           .sess\n+                           .span_err(\n+                               args.get(i).ty.span,\n+                               format!(\"type `{}` is dynamically sized. \\\n+                                        dynamically sized types may only \\\n+                                        appear as the final type in a \\\n+                                        variant\",\n+                                       ppaux::ty_to_str(ccx.tcx,\n+                                                        *t)).as_slice());\n                     }\n                 }\n             },\n@@ -3755,7 +3778,11 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                             ccx.tcx.sess.span_err(e.span, \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            ccx.tcx.sess.span_err(e.span, format!(\"expected constant: {}\", *err));\n+                            ccx.tcx\n+                               .sess\n+                               .span_err(e.span,\n+                                         format!(\"expected constant: {}\",\n+                                                 *err).as_slice());\n                         }\n                     }\n                 },\n@@ -3906,7 +3933,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                          found {nsupplied, plural, =1{# lifetime parameter} \\\n                                                 other{# lifetime parameters}}\",\n                         nexpected = num_expected_regions,\n-                        nsupplied = num_supplied_regions));\n+                        nsupplied = num_supplied_regions).as_slice());\n         }\n \n         fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.as_slice())\n@@ -3945,18 +3972,20 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         fcx.ccx.tcx.sess.span_err\n             (span,\n              format!(\"too many type parameters provided: {} {}, found {}\",\n-                  expected, user_ty_param_count, ty_substs_len));\n+                  expected, user_ty_param_count, ty_substs_len).as_slice());\n         (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else if ty_substs_len < user_ty_param_req {\n         let expected = if user_ty_param_req < user_ty_param_count {\n             \"expected at least\"\n         } else {\n             \"expected\"\n         };\n-        fcx.ccx.tcx.sess.span_err\n-            (span,\n-             format!(\"not enough type parameters provided: {} {}, found {}\",\n-                  expected, user_ty_param_req, ty_substs_len));\n+        fcx.ccx.tcx.sess.span_err(\n+            span,\n+            format!(\"not enough type parameters provided: {} {}, found {}\",\n+                    expected,\n+                    user_ty_param_req,\n+                    ty_substs_len).as_slice());\n         (fcx.infcx().next_ty_vars(ty_param_count), regions)\n     } else {\n         if ty_substs_len > user_ty_param_req\n@@ -4128,8 +4157,9 @@ pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n                     }\n                 }\n                 _ => {\n-                    fcx.ccx.tcx.sess.span_bug(\n-                        e.span, format!(\"vstore with unexpected contents\"))\n+                    fcx.ccx.tcx.sess.span_bug(e.span,\n+                                              \"vstore with unexpected \\\n+                                               contents\")\n                 }\n             }\n         }\n@@ -4184,8 +4214,9 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {\n             ccx.tcx.sess.span_err(\n-                span, format!(\"type parameter `{}` is unused\",\n-                              token::get_ident(tps.get(i).ident)));\n+                span,\n+                format!(\"type parameter `{}` is unused\",\n+                        token::get_ident(tps.get(i).ident)).as_slice());\n         }\n     }\n }\n@@ -4222,8 +4253,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             }\n             op => {\n                 tcx.sess.span_err(it.span,\n-                                  format!(\"unrecognized atomic operation function: `{}`\",\n-                                       op));\n+                                  format!(\"unrecognized atomic operation \\\n+                                           function: `{}`\",\n+                                          op).as_slice());\n                 return;\n             }\n         }\n@@ -4450,7 +4482,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             ref other => {\n                 tcx.sess.span_err(it.span,\n                                   format!(\"unrecognized intrinsic function: `{}`\",\n-                                       *other));\n+                                          *other).as_slice());\n                 return;\n             }\n         }\n@@ -4468,9 +4500,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs().len();\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span, format!(\"intrinsic has wrong number \\\n-                                         of type parameters: found {}, \\\n-                                         expected {}\", i_n_tps, n_tps));\n+        tcx.sess.span_err(it.span,\n+                          format!(\"intrinsic has wrong number of type \\\n+                                   parameters: found {}, expected {}\",\n+                                  i_n_tps,\n+                                  n_tps).as_slice());\n     } else {\n         require_same_types(tcx,\n                            None,"}, {"sha": "34e8b5e169ff8f68c54a7566ba1ffeaad24d15ca", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -183,7 +183,7 @@ fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n-                              def))\n+                                 def).as_slice())\n         }\n     }\n }\n@@ -880,7 +880,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n-                                method.ty.repr(rcx.tcx())))\n+                                    method.ty.repr(rcx.tcx())).as_slice())\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx);\n@@ -1235,7 +1235,8 @@ fn link_region(rcx: &Rcx,\n                                 rcx.tcx().sess.span_bug(\n                                     span,\n                                     format!(\"Illegal upvar id: {}\",\n-                                            upvar_id.repr(rcx.tcx())));\n+                                            upvar_id.repr(\n+                                                rcx.tcx())).as_slice());\n                             }\n                         }\n                     }"}, {"sha": "5e67cb54ccc66eede8067cef4a99bfb51f7d6cf2", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -154,7 +154,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n                          vcx.infcx.trait_ref_to_str(&*trait_ref),\n-                         vcx.infcx.ty_to_str(ty)));\n+                         vcx.infcx.ty_to_str(ty)).as_slice());\n             }\n         }\n         true\n@@ -206,9 +206,9 @@ fn relate_trait_refs(vcx: &VtableContext,\n                 let tcx = vcx.tcx();\n                 tcx.sess.span_err(span,\n                     format!(\"expected {}, but found {} ({})\",\n-                         ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n-                         ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n-                         ty::type_err_to_str(tcx, err)));\n+                            ppaux::trait_ref_to_str(tcx, &r_exp_trait_ref),\n+                            ppaux::trait_ref_to_str(tcx, &r_act_trait_ref),\n+                            ty::type_err_to_str(tcx, err)).as_slice());\n             }\n         }\n     }\n@@ -491,9 +491,9 @@ fn fixup_ty(vcx: &VtableContext,\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(span,\n-                format!(\"cannot determine a type \\\n-                      for this bounded type parameter: {}\",\n-                     fixup_err_to_str(e)))\n+                format!(\"cannot determine a type for this bounded type \\\n+                         parameter: {}\",\n+                        fixup_err_to_str(e)).as_slice())\n         }\n         Err(_) => {\n             None\n@@ -550,8 +550,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n               match (&ty::get(ty).sty, store) {\n                   (&ty::ty_rptr(_, mt), ty::RegionTraitStore(_, mutbl))\n                     if !mutability_allowed(mt.mutbl, mutbl) => {\n-                      fcx.tcx().sess.span_err(ex.span,\n-                                              format!(\"types differ in mutability\"));\n+                      fcx.tcx()\n+                         .sess\n+                         .span_err(ex.span, \"types differ in mutability\");\n                   }\n \n                   (&ty::ty_uniq(..), ty::UniqTraitStore) |\n@@ -609,15 +610,15 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                           ex.span,\n                           format!(\"can only cast an boxed pointer \\\n                                    to a boxed object, not a {}\",\n-                               ty::ty_sort_str(fcx.tcx(), ty)));\n+                               ty::ty_sort_str(fcx.tcx(), ty)).as_slice());\n                   }\n \n                   (_, ty::RegionTraitStore(..)) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n                           format!(\"can only cast an &-pointer \\\n-                                to an &-object, not a {}\",\n-                               ty::ty_sort_str(fcx.tcx(), ty)));\n+                                   to an &-object, not a {}\",\n+                                  ty::ty_sort_str(fcx.tcx(), ty)).as_slice());\n                   }\n               }\n           }"}, {"sha": "133fc9b1530abeeee6dcee392a79f2a98260712a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -402,23 +402,23 @@ impl<'cx> Resolver<'cx> {\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this expression: {}\",\n-                                infer::fixup_err_to_str(e)))\n+                                infer::fixup_err_to_str(e)).as_slice())\n                 }\n \n                 ResolvingLocal(span) => {\n                     self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this local variable: {}\",\n-                                infer::fixup_err_to_str(e)))\n+                                infer::fixup_err_to_str(e)).as_slice())\n                 }\n \n                 ResolvingPattern(span) => {\n                     self.tcx.sess.span_err(\n                         span,\n                         format!(\"cannot determine a type for \\\n                                  this pattern binding: {}\",\n-                                infer::fixup_err_to_str(e)))\n+                                infer::fixup_err_to_str(e)).as_slice())\n                 }\n \n                 ResolvingUpvar(upvar_id) => {\n@@ -430,13 +430,15 @@ impl<'cx> Resolver<'cx> {\n                                 ty::local_var_name_str(\n                                     self.tcx,\n                                     upvar_id.var_id).get().to_str(),\n-                                infer::fixup_err_to_str(e)));\n+                                infer::fixup_err_to_str(e)).as_slice());\n                 }\n \n                 ResolvingImplRes(span) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot determine a type for impl supertrait\"));\n+                    self.tcx\n+                        .sess\n+                        .span_err(span,\n+                                  \"cannot determine a type for impl \\\n+                                   supertrait\");\n                 }\n             }\n         }"}, {"sha": "042bebf573f753ba0eb42de6f5555488e6e7a8ef", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -431,8 +431,9 @@ impl<'a> CoherenceChecker<'a> {\n                         session.span_err(\n                             self.span_of_impl(impl_a),\n                             format!(\"conflicting implementations for trait `{}`\",\n-                                 ty::item_path_str(self.crate_context.tcx,\n-                                                   trait_def_id)));\n+                                    ty::item_path_str(\n+                                        self.crate_context.tcx,\n+                                        trait_def_id)).as_slice());\n                         if impl_b.krate == LOCAL_CRATE {\n                             session.span_note(self.span_of_impl(impl_b),\n                                               \"note conflicting implementation here\");\n@@ -442,7 +443,7 @@ impl<'a> CoherenceChecker<'a> {\n                             session.note(\n                                 format!(\"conflicting implementation in crate \\\n                                          `{}`\",\n-                                        cdata.name));\n+                                        cdata.name).as_slice());\n                         }\n                     }\n                 }"}, {"sha": "447f8dfa278d609ffb6d62cb05909495b257e0c8", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -123,7 +123,8 @@ impl<'a> AstConv for CrateCtxt<'a> {\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_ty(): {:?}\", x));\n+                                           in get_item_ty(): {:?}\",\n+                                          x).as_slice());\n             }\n         }\n     }\n@@ -134,7 +135,8 @@ impl<'a> AstConv for CrateCtxt<'a> {\n \n     fn ty_infer(&self, span: Span) -> ty::t {\n         self.tcx.sess.span_err(span, \"the type placeholder `_` is not \\\n-                                      allowed within types on item signatures.\");\n+                                      allowed within types on item \\\n+                                      signatures.\");\n         ty::mk_err()\n     }\n }\n@@ -573,7 +575,8 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n-                format!(\"trait bounds are not allowed in {} definitions\", thing));\n+                format!(\"trait bounds are not allowed in {} definitions\",\n+                        thing).as_slice());\n         }\n     }\n }\n@@ -711,10 +714,12 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.find(&result.name) {\n                 Some(prev_span) => {\n-                    tcx.sess.span_err(f.span,\n-                        format!(\"field `{}` is already declared\", token::get_name(result.name)));\n+                    tcx.sess.span_err(\n+                        f.span,\n+                        format!(\"field `{}` is already declared\",\n+                                token::get_name(result.name)).as_slice());\n                     tcx.sess.span_note(*prev_span,\n-                        \"previously declared here\");\n+                                       \"previously declared here\");\n                     true\n                 },\n                 None => false,\n@@ -840,7 +845,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 format!(\"`{}` is not a trait\",\n-                    path_to_str(&ast_trait_ref.path)));\n+                        path_to_str(&ast_trait_ref.path)).as_slice());\n         }\n     }\n }\n@@ -852,8 +857,10 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n \n     match ccx.tcx.map.get(trait_id.node) {\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, item),\n-        _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                   trait_id.node))\n+        _ => {\n+            ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n+                                     trait_id.node).as_slice())\n+        }\n     }\n }\n \n@@ -889,7 +896,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {:?}\", s));\n+                format!(\"trait_def_of_item invoked on {:?}\", s).as_slice());\n         }\n     }\n }\n@@ -960,9 +967,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return tpt;\n         }\n         ast::ItemTrait(..) => {\n-            tcx.sess.span_bug(\n-                it.span,\n-                format!(\"invoked ty_of_item on trait\"));\n+            tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n@@ -1113,8 +1118,7 @@ fn ty_generics(ccx: &CrateCtxt,\n                     if !ccx.tcx.sess.features.issue_5723_bootstrap.get() {\n                         ccx.tcx.sess.span_err(\n                             span,\n-                            format!(\"only the 'static lifetime is \\\n-                                     accepted here.\"));\n+                            \"only the 'static lifetime is accepted here.\");\n                     }\n                 }\n             }\n@@ -1151,7 +1155,8 @@ fn ty_generics(ccx: &CrateCtxt,\n                         format!(\"incompatible bounds on type parameter {}, \\\n                                  bound {} does not allow unsized type\",\n                         token::get_ident(ident),\n-                        ppaux::trait_ref_to_str(tcx, &*trait_ref)));\n+                        ppaux::trait_ref_to_str(tcx,\n+                                                &*trait_ref)).as_slice());\n                 }\n                 true\n             });"}, {"sha": "819a69cfad18eb0da58c5c20bb5b9c6031606028", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -212,7 +212,7 @@ impl<'f> Coerce<'f> {\n                 self.get_ref().infcx.tcx.sess.span_bug(\n                     self.get_ref().trace.origin.span(),\n                     format!(\"failed to resolve even without \\\n-                          any force options: {:?}\", e));\n+                          any force options: {:?}\", e).as_slice());\n             }\n         }\n     }"}, {"sha": "d80e8400a3a89f646ef70fbcb5cdc64a427e628f", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -118,10 +118,9 @@ pub trait Combine {\n                 // I think it should never happen that we unify two\n                 // substs and one of them has a self_ty and one\n                 // doesn't...? I could be wrong about this.\n-                self.infcx().tcx.sess.bug(\n-                                          format!(\"substitution a had a self_ty \\\n-                                               and substitution b didn't, \\\n-                                               or vice versa\"));\n+                self.infcx().tcx.sess.bug(\"substitution a had a self_ty \\\n+                                           and substitution b didn't, or \\\n+                                           vice versa\");\n             }\n         }\n     }\n@@ -403,9 +402,9 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n-                 this.tag(),\n-                 a.inf_str(this.infcx()),\n-                 b.inf_str(this.infcx())));\n+                    this.tag(),\n+                    a.inf_str(this.infcx()),\n+                    b.inf_str(this.infcx())).as_slice());\n       }\n \n         // Relate integral variables to other types"}, {"sha": "6b6b9fab5c6b75ffbf97ec9f89c691020d6b694f", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -355,7 +355,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr)));\n+                 ty::type_err_to_str(self.tcx, terr)).as_slice());\n     }\n \n     fn report_and_explain_type_error(&self,\n@@ -430,7 +430,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     span,\n                     format!(\"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n-                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()));\n+                            ty::local_var_name_str(self.tcx,\n+                                                   upvar_id.var_id)\n+                                .get()\n+                                .to_str()).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -439,7 +442,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"...but `{}` is only valid for \",\n-                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()),\n+                            ty::local_var_name_str(self.tcx,\n+                                                   upvar_id.var_id)\n+                                .get()\n+                                .to_str()).as_slice(),\n                     sup,\n                     \"\");\n             }\n@@ -483,7 +489,9 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     span,\n                     format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n-                            ty::local_var_name_str(self.tcx, id).get().to_str()));\n+                            ty::local_var_name_str(self.tcx,\n+                                                   id).get()\n+                                                      .to_str()).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -496,9 +504,8 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"index of slice outside its lifetime\"));\n+                self.tcx.sess.span_err(span,\n+                                       \"index of slice outside its lifetime\");\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the slice is only valid for \",\n@@ -591,7 +598,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                     span,\n                     format!(\"in type `{}`, pointer has a longer lifetime than \\\n                           the data it references\",\n-                         ty.user_string(self.tcx)));\n+                         ty.user_string(self.tcx)).as_slice());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -1022,8 +1029,13 @@ impl<'a> Rebuilder<'a> {\n                 }\n                 ast::TyPath(ref path, _, id) => {\n                     let a_def = match self.tcx.def_map.borrow().find(&id) {\n-                        None => self.tcx.sess.fatal(format!(\"unbound path {}\",\n-                                                    pprust::path_to_str(path))),\n+                        None => {\n+                            self.tcx\n+                                .sess\n+                                .fatal(format!(\n+                                        \"unbound path {}\",\n+                                        pprust::path_to_str(path)).as_slice())\n+                        }\n                         Some(&d) => d\n                     };\n                     match a_def {\n@@ -1209,18 +1221,18 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_note(span, msg);\n+        self.tcx.sess.span_note(span, msg.as_slice());\n     }\n \n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n-            infer::MiscVariable(_) => \"\".to_owned(),\n-            infer::PatternRegion(_) => \" for pattern\".to_owned(),\n-            infer::AddrOfRegion(_) => \" for borrow expression\".to_owned(),\n-            infer::AddrOfSlice(_) => \" for slice expression\".to_owned(),\n-            infer::Autoref(_) => \" for autoref\".to_owned(),\n-            infer::Coercion(_) => \" for automatic coercion\".to_owned(),\n+            infer::MiscVariable(_) => \"\".to_strbuf(),\n+            infer::PatternRegion(_) => \" for pattern\".to_strbuf(),\n+            infer::AddrOfRegion(_) => \" for borrow expression\".to_strbuf(),\n+            infer::AddrOfSlice(_) => \" for slice expression\".to_strbuf(),\n+            infer::Autoref(_) => \" for autoref\".to_strbuf(),\n+            infer::Coercion(_) => \" for automatic coercion\".to_strbuf(),\n             infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n                         bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n@@ -1247,7 +1259,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             var_origin.span(),\n             format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description));\n+                    var_description).as_slice());\n     }\n \n     fn note_region_origin(&self, origin: SubregionOrigin) {\n@@ -1282,7 +1294,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             format!(\"...so that {} ({})\",\n-                                    desc, values_str));\n+                                    desc, values_str).as_slice());\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1291,7 +1303,7 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc));\n+                            format!(\"...so that {}\", desc).as_slice());\n                     }\n                 }\n             }\n@@ -1304,8 +1316,11 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that closure can access `{}`\",\n-                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()))\n+                    format!(\n+                        \"...so that closure can access `{}`\",\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id)\n+                            .get()\n+                            .to_str()).as_slice())\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1328,7 +1343,9 @@ impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n                     span,\n                     format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n-                            ty::local_var_name_str(self.tcx, id).get().to_str()));\n+                            ty::local_var_name_str(\n+                                self.tcx,\n+                                id).get().to_str()).as_slice());\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "73684a63ac12447c82693cacf3e62203cd38fee9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -249,7 +249,8 @@ impl<'f> Combine for Glb<'f> {\n             }\n             this.get_ref().infcx.tcx.sess.span_bug(\n                 this.get_ref().trace.origin.span(),\n-                format!(\"could not find original bound region for {:?}\", r))\n+                format!(\"could not find original bound region for {:?}\",\n+                        r).as_slice())\n         }\n \n         fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {"}, {"sha": "41a59dae740831ad74682f377ec4ad2fd3c5eb21", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -529,7 +529,7 @@ pub fn var_ids<T:Combine>(this: &T,\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n-                    format!(\"found non-region-vid: {:?}\", r));\n+                    format!(\"found non-region-vid: {:?}\", r).as_slice());\n             }\n         }).collect()\n }"}, {"sha": "1df16f868013d50a860be7348942adfcbe3579e3", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -185,8 +185,9 @@ impl<'f> Combine for Lub<'f> {\n \n             this.get_ref().infcx.tcx.sess.span_bug(\n                 this.get_ref().trace.origin.span(),\n-                format!(\"Region {:?} is not associated with \\\n-                        any bound region from A!\", r0))\n+                format!(\"region {:?} is not associated with \\\n+                         any bound region from A!\",\n+                        r0).as_slice())\n         }\n     }\n "}, {"sha": "7fed5e4ee1ae9ed65ec67c24f889e9c6ccc06896", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -693,9 +693,9 @@ impl<'a> InferCtxt<'a> {\n             _ => {\n                 self.tcx.sess.bug(\n                     format!(\"resolve_type_vars_if_possible() yielded {} \\\n-                          when supplied with {}\",\n-                         self.ty_to_str(dummy0),\n-                         self.ty_to_str(dummy1)));\n+                             when supplied with {}\",\n+                            self.ty_to_str(dummy0),\n+                            self.ty_to_str(dummy1)).as_slice());\n             }\n         }\n     }\n@@ -729,19 +729,27 @@ impl<'a> InferCtxt<'a> {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = err.map_or(\"\".to_owned(), |t_err| {\n+        let error_str = err.map_or(\"\".to_strbuf(), |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n         });\n         let resolved_expected = expected_ty.map(|e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n         });\n         if !resolved_expected.map_or(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n-                None => self.tcx.sess.span_err(sp,\n-                            format!(\"{}{}\", mk_msg(None, actual_ty), error_str)),\n+                None => {\n+                    self.tcx\n+                        .sess\n+                        .span_err(sp,\n+                                  format!(\"{}{}\",\n+                                          mk_msg(None, actual_ty),\n+                                          error_str).as_slice())\n+                }\n                 Some(e) => {\n                     self.tcx.sess.span_err(sp,\n-                        format!(\"{}{}\", mk_msg(Some(self.ty_to_str(e)), actual_ty), error_str));\n+                        format!(\"{}{}\",\n+                                mk_msg(Some(self.ty_to_str(e)), actual_ty),\n+                                error_str).as_slice());\n                 }\n             }\n             for err in err.iter() {"}, {"sha": "1178e1dfa46e97acb22e68c8094debaf2b3eb7d1", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -297,7 +297,7 @@ impl<'a> RegionVarBindings<'a> {\n                 origin.span(),\n                 format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx)));\n+                        sup.repr(self.tcx)).as_slice());\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -369,8 +369,8 @@ impl<'a> RegionVarBindings<'a> {\n             None => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins.borrow().get(rid.to_uint()).span(),\n-                    format!(\"attempt to resolve region variable before \\\n-                             values have been computed!\"))\n+                    \"attempt to resolve region variable before values have \\\n+                     been computed!\")\n             }\n             Some(ref values) => *values.get(rid.to_uint())\n         };\n@@ -546,7 +546,7 @@ impl<'a> RegionVarBindings<'a> {\n             self.tcx.sess.bug(\n                 format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx)));\n+                        b.repr(self.tcx)).as_slice());\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -561,7 +561,9 @@ impl<'a> RegionVarBindings<'a> {\n             self.tcx.sess.span_bug(\n                 self.var_origins.borrow().get(v_id.to_uint()).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n-                      non-concrete regions: {:?}, {:?}\", a, b));\n+                         non-concrete regions: {:?}, {:?}\",\n+                        a,\n+                        b).as_slice());\n           }\n \n           (f @ ReFree(ref fr), ReScope(s_id)) |\n@@ -647,7 +649,7 @@ impl<'a> RegionVarBindings<'a> {\n               self.tcx.sess.bug(\n                   format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx)));\n+                          b.repr(self.tcx)).as_slice());\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -665,7 +667,9 @@ impl<'a> RegionVarBindings<'a> {\n                 self.tcx.sess.span_bug(\n                     self.var_origins.borrow().get(v_id.to_uint()).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n-                          non-concrete regions: {:?}, {:?}\", a, b));\n+                             non-concrete regions: {:?}, {:?}\",\n+                            a,\n+                            b).as_slice());\n             }\n \n             (ReFree(ref fr), s @ ReScope(s_id)) |\n@@ -1175,7 +1179,7 @@ impl<'a> RegionVarBindings<'a> {\n                  upper_bounds.iter()\n                              .map(|x| x.region)\n                              .collect::<Vec<ty::Region>>()\n-                             .repr(self.tcx)));\n+                             .repr(self.tcx)).as_slice());\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1222,7 +1226,7 @@ impl<'a> RegionVarBindings<'a> {\n                  upper_bounds.iter()\n                              .map(|x| x.region)\n                              .collect::<Vec<ty::Region>>()\n-                             .repr(self.tcx)));\n+                             .repr(self.tcx)).as_slice());\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "f36b98628507da66f4787a0d6c6a00089493a6ac", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -87,7 +87,7 @@ impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n                 Some(&ref var_val) => (*var_val).clone(),\n                 None => {\n                     tcx.sess.bug(format!(\n-                        \"failed lookup of vid `{}`\", vid_u));\n+                        \"failed lookup of vid `{}`\", vid_u).as_slice());\n                 }\n             };\n             match var_val {"}, {"sha": "253ab22d4704c525e85cf76ecb625f70cc5335ee", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -311,7 +311,8 @@ pub fn require_same_types(tcx: &ty::ctxt,\n             tcx.sess.span_err(span,\n                               format!(\"{}: {}\",\n                                       msg(),\n-                                      ty::type_err_to_str(tcx, terr)));\n+                                      ty::type_err_to_str(tcx,\n+                                                          terr)).as_slice());\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -359,8 +360,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              format!(\"main has a non-function type: found `{}`\",\n-                                   ppaux::ty_to_str(tcx, main_t)));\n+                              format!(\"main has a non-function type: found \\\n+                                       `{}`\",\n+                                      ppaux::ty_to_str(tcx,\n+                                                       main_t)).as_slice());\n         }\n     }\n }\n@@ -411,8 +414,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              format!(\"start has a non-function type: found `{}`\",\n-                                   ppaux::ty_to_str(tcx, start_t)));\n+                              format!(\"start has a non-function type: found \\\n+                                       `{}`\",\n+                                      ppaux::ty_to_str(tcx,\n+                                                       start_t)).as_slice());\n         }\n     }\n }"}, {"sha": "a6bf8e109c48587f033c29a29750d8b0ebe5c9c8", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -538,8 +538,8 @@ impl<'a> ConstraintContext<'a> {\n             Some(&index) => index,\n             None => {\n                 self.tcx().sess.bug(format!(\n-                        \"No inferred index entry for {}\",\n-                        self.tcx().map.node_to_str(param_id)));\n+                        \"no inferred index entry for {}\",\n+                        self.tcx().map.node_to_str(param_id)).as_slice());\n             }\n         }\n     }\n@@ -787,7 +787,7 @@ impl<'a> ConstraintContext<'a> {\n                 self.tcx().sess.bug(\n                     format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx())));\n+                            ty.repr(self.tcx())).as_slice());\n             }\n         }\n     }\n@@ -858,9 +858,11 @@ impl<'a> ConstraintContext<'a> {\n             ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n-                self.tcx().sess.bug(format!(\"unexpected region encountered in \\\n-                                            variance inference: {}\",\n-                                            region.repr(self.tcx())));\n+                self.tcx()\n+                    .sess\n+                    .bug(format!(\"unexpected region encountered in variance \\\n+                                  inference: {}\",\n+                                 region.repr(self.tcx())).as_slice());\n             }\n         }\n     }"}, {"sha": "982ccceb5ee1017b7c2db81260bf064d7f7a5109", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -50,11 +50,11 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix));\n+            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix));\n+            format!(\"{}{}{}\", prefix, *str, suffix).as_slice());\n       }\n     }\n }\n@@ -255,13 +255,13 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n         match fn_style {\n             ast::NormalFn => {}\n             _ => {\n-                s.push_str(fn_style.to_str());\n+                s.push_str(fn_style.to_str().as_slice());\n                 s.push_char(' ');\n             }\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_str()));\n+            s.push_str(format!(\"extern {} \", abi.to_str()).as_slice());\n         };\n \n         s.push_str(\"fn\");\n@@ -292,7 +292,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> StrBuf {\n         match cty.fn_style {\n             ast::NormalFn => {}\n             _ => {\n-                s.push_str(cty.fn_style.to_str());\n+                s.push_str(cty.fn_style.to_str().as_slice());\n                 s.push_char(' ');\n             }\n         };"}, {"sha": "133e8c64042d9d8e38c625585eb2933446c052cf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -184,12 +184,12 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         for lifetime in last.lifetimes.iter() {\n             if counter > 0 { generics.push_str(\", \"); }\n             counter += 1;\n-            generics.push_str(format!(\"{}\", *lifetime));\n+            generics.push_str(format!(\"{}\", *lifetime).as_slice());\n         }\n         for ty in last.types.iter() {\n             if counter > 0 { generics.push_str(\", \"); }\n             counter += 1;\n-            generics.push_str(format!(\"{}\", *ty));\n+            generics.push_str(format!(\"{}\", *ty).as_slice());\n         }\n         generics.push_str(\"&gt;\");\n     }\n@@ -323,18 +323,22 @@ impl fmt::Show for clean::Type {\n                            {arrow, select, yes{ -&gt; {ret}} other{}}\",\n                        style = FnStyleSpace(decl.fn_style),\n                        lifetimes = if decl.lifetimes.len() == 0 {\n-                           \"\".to_owned()\n+                           \"\".to_strbuf()\n                        } else {\n                            format!(\"&lt;{:#}&gt;\", decl.lifetimes)\n                        },\n                        args = decl.decl.inputs,\n-                       arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n+                       arrow = match decl.decl.output {\n+                           clean::Unit => \"no\",\n+                           _ => \"yes\",\n+                       },\n                        ret = decl.decl.output,\n                        bounds = {\n                            let mut ret = StrBuf::new();\n                            match *region {\n                                Some(ref lt) => {\n-                                   ret.push_str(format!(\": {}\", *lt));\n+                                   ret.push_str(format!(\": {}\",\n+                                                        *lt).as_slice());\n                                }\n                                None => {}\n                            }\n@@ -347,7 +351,8 @@ impl fmt::Show for clean::Type {\n                                         } else {\n                                             ret.push_str(\" + \");\n                                         }\n-                                        ret.push_str(format!(\"{}\", *t));\n+                                        ret.push_str(format!(\"{}\",\n+                                                             *t).as_slice());\n                                     }\n                                 }\n                            }\n@@ -416,7 +421,10 @@ impl fmt::Show for clean::Type {\n                        }, **t)\n             }\n             clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-                let lt = match *l { Some(ref l) => format!(\"{} \", *l), _ => \"\".to_owned() };\n+                let lt = match *l {\n+                    Some(ref l) => format!(\"{} \", *l),\n+                    _ => \"\".to_strbuf(),\n+                };\n                 write!(f, \"&amp;{}{}{}\",\n                        lt,\n                        match mutability {\n@@ -460,10 +468,10 @@ impl<'a> fmt::Show for Method<'a> {\n             clean::SelfValue => args.push_str(\"self\"),\n             clean::SelfOwned => args.push_str(\"~self\"),\n             clean::SelfBorrowed(Some(ref lt), clean::Immutable) => {\n-                args.push_str(format!(\"&amp;{} self\", *lt));\n+                args.push_str(format!(\"&amp;{} self\", *lt).as_slice());\n             }\n             clean::SelfBorrowed(Some(ref lt), clean::Mutable) => {\n-                args.push_str(format!(\"&amp;{} mut self\", *lt));\n+                args.push_str(format!(\"&amp;{} mut self\", *lt).as_slice());\n             }\n             clean::SelfBorrowed(None, clean::Mutable) => {\n                 args.push_str(\"&amp;mut self\");\n@@ -475,9 +483,9 @@ impl<'a> fmt::Show for Method<'a> {\n         for (i, input) in d.inputs.values.iter().enumerate() {\n             if i > 0 || args.len() > 0 { args.push_str(\", \"); }\n             if input.name.len() > 0 {\n-                args.push_str(format!(\"{}: \", input.name));\n+                args.push_str(format!(\"{}: \", input.name).as_slice());\n             }\n-            args.push_str(format!(\"{}\", input.type_));\n+            args.push_str(format!(\"{}\", input.type_).as_slice());\n         }\n         write!(f,\n                \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\","}, {"sha": "94bd4d818b476fcce5a06d5d5c2e6a74779cdd32", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -407,8 +407,11 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             if path.exists() {\n                 for line in BufferedReader::new(File::open(path)).lines() {\n                     let line = try!(line);\n-                    if !line.starts_with(key) { continue }\n-                    if line.starts_with(format!(\"{}['{}']\", key, krate)) {\n+                    if !line.as_slice().starts_with(key) {\n+                        continue\n+                    }\n+                    if line.as_slice().starts_with(\n+                            format!(\"{}['{}']\", key, krate).as_slice()) {\n                         continue\n                     }\n                     ret.push(line.to_strbuf());\n@@ -646,7 +649,7 @@ impl<'a> SourceCollector<'a> {\n \n         let title = format!(\"{} -- source\", cur.filename_display());\n         let page = layout::Page {\n-            title: title,\n+            title: title.as_slice(),\n             ty: \"source\",\n             root_path: root_path.as_slice(),\n         };\n@@ -1344,7 +1347,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         parents.push_str(\": \");\n         for (i, p) in t.parents.iter().enumerate() {\n             if i > 0 { parents.push_str(\" + \"); }\n-            parents.push_str(format!(\"{}\", *p));\n+            parents.push_str(format!(\"{}\", *p).as_slice());\n         }\n     }\n "}, {"sha": "984ef458c8f4512a44fbe067430719850ff8f1f7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -132,7 +132,7 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n \n pub fn usage(argv0: &str) {\n     println!(\"{}\",\n-             getopts::usage(format!(\"{} [options] <input>\", argv0),\n+             getopts::usage(format!(\"{} [options] <input>\", argv0).as_slice(),\n                             opts().as_slice()));\n }\n "}, {"sha": "de9c2839e739861c70cc7e3f822aaf4a691500b5", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -80,7 +80,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     let mut css = StrBuf::new();\n     for name in matches.opt_strs(\"markdown-css\").iter() {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n-        css.push_str(s)\n+        css.push_str(s.as_slice())\n     }\n \n     let input_str = load_or_return!(input, 1, 2);"}, {"sha": "949cd17fe9a8159f4fcbb42c6f972dc4299bc64a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -213,7 +213,8 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> StrBuf {\n \n     if !s.contains(\"extern crate\") {\n         if s.contains(cratename) {\n-            prog.push_str(format!(\"extern crate {};\\n\", cratename));\n+            prog.push_str(format!(\"extern crate {};\\n\",\n+                                  cratename).as_slice());\n         }\n     }\n     if s.contains(\"fn main\") {"}, {"sha": "857e07a2af17a32ee902909a6687232344263ad1", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -387,7 +387,7 @@ impl fmt::Show for UvError {\n #[test]\n fn error_smoke_test() {\n     let err: UvError = UvError(uvll::EOF);\n-    assert_eq!(err.to_str(), \"EOF: end of file\".to_owned());\n+    assert_eq!(err.to_str(), \"EOF: end of file\".to_strbuf());\n }\n \n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {"}, {"sha": "3a387972ff7c1fa5b1ba87c3fb9e76b26499979b", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -663,7 +663,7 @@ pub mod writer {\n             _ => Err(io::IoError {\n                 kind: io::OtherIoError,\n                 desc: \"int too big\",\n-                detail: Some(format!(\"{}\", n))\n+                detail: Some(format_strbuf!(\"{}\", n))\n             })\n         }\n     }\n@@ -676,7 +676,7 @@ pub mod writer {\n         Err(io::IoError {\n             kind: io::OtherIoError,\n             desc: \"int too big\",\n-            detail: Some(format!(\"{}\", n))\n+            detail: Some(format_strbuf!(\"{}\", n))\n         })\n     }\n "}, {"sha": "8240211a83991ab6494083ed8f3045665893659e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 64, "deletions": 59, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -16,10 +16,9 @@ use iter::Iterator;\n use mem;\n use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n-use str::OwnedStr;\n-use str::Str;\n-use str::{StrAllocating, StrSlice};\n+use str::{OwnedStr, Str, StrAllocating, StrSlice};\n use str;\n+use strbuf::StrBuf;\n use to_str::{IntoStr};\n use vec::Vec;\n \n@@ -249,15 +248,15 @@ impl OwnedAsciiCast for ~[u8] {\n     }\n }\n \n-impl OwnedAsciiCast for ~str {\n+impl OwnedAsciiCast for StrBuf {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.as_slice().is_ascii()\n     }\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        let v: ~[u8] = mem::transmute(self);\n+        let v: Vec<u8> = mem::transmute(self);\n         v.into_ascii_nocheck()\n     }\n }\n@@ -314,17 +313,18 @@ impl<'a> AsciiStr for &'a [Ascii] {\n \n impl IntoStr for ~[Ascii] {\n     #[inline]\n-    fn into_str(self) -> ~str {\n-        unsafe { mem::transmute(self) }\n+    fn into_str(self) -> StrBuf {\n+        let vector: Vec<Ascii> = self.as_slice().iter().map(|x| *x).collect();\n+        vector.into_str()\n     }\n }\n \n impl IntoStr for Vec<Ascii> {\n     #[inline]\n-    fn into_str(self) -> ~str {\n+    fn into_str(self) -> StrBuf {\n         unsafe {\n             let s: &str = mem::transmute(self.as_slice());\n-            s.to_owned()\n+            s.to_strbuf()\n         }\n     }\n }\n@@ -346,25 +346,25 @@ pub trait OwnedStrAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn into_ascii_upper(self) -> ~str;\n+    fn into_ascii_upper(self) -> StrBuf;\n \n     /// Convert the string to ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn into_ascii_lower(self) -> ~str;\n+    fn into_ascii_lower(self) -> StrBuf;\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n pub trait StrAsciiExt {\n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_upper(&self) -> ~str;\n+    fn to_ascii_upper(&self) -> StrBuf;\n \n     /// Makes a copy of the string in ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lower(&self) -> ~str;\n+    fn to_ascii_lower(&self) -> StrBuf;\n \n     /// Check that two strings are an ASCII case-insensitive match.\n     /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n@@ -374,12 +374,12 @@ pub trait StrAsciiExt {\n \n impl<'a> StrAsciiExt for &'a str {\n     #[inline]\n-    fn to_ascii_upper(&self) -> ~str {\n+    fn to_ascii_upper(&self) -> StrBuf {\n         unsafe { str_copy_map_bytes(*self, ASCII_UPPER_MAP) }\n     }\n \n     #[inline]\n-    fn to_ascii_lower(&self) -> ~str {\n+    fn to_ascii_lower(&self) -> StrBuf {\n         unsafe { str_copy_map_bytes(*self, ASCII_LOWER_MAP) }\n     }\n \n@@ -394,36 +394,36 @@ impl<'a> StrAsciiExt for &'a str {\n     }\n }\n \n-impl OwnedStrAsciiExt for ~str {\n+impl OwnedStrAsciiExt for StrBuf {\n     #[inline]\n-    fn into_ascii_upper(self) -> ~str {\n+    fn into_ascii_upper(self) -> StrBuf {\n         unsafe { str_map_bytes(self, ASCII_UPPER_MAP) }\n     }\n \n     #[inline]\n-    fn into_ascii_lower(self) -> ~str {\n+    fn into_ascii_lower(self) -> StrBuf {\n         unsafe { str_map_bytes(self, ASCII_LOWER_MAP) }\n     }\n }\n \n #[inline]\n-unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n+unsafe fn str_map_bytes(string: StrBuf, map: &'static [u8]) -> StrBuf {\n     let mut bytes = string.into_bytes();\n \n     for b in bytes.mut_iter() {\n         *b = map[*b as uint];\n     }\n \n-    str::raw::from_utf8_owned(bytes)\n+    str::from_utf8(bytes.as_slice()).unwrap().to_strbuf()\n }\n \n #[inline]\n-unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n+unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> StrBuf {\n     let mut s = string.to_owned();\n     for b in str::raw::as_owned_vec(&mut s).mut_iter() {\n         *b = map[*b as uint];\n     }\n-    s\n+    s.into_strbuf()\n }\n \n static ASCII_LOWER_MAP: &'static [u8] = &[\n@@ -552,15 +552,17 @@ mod tests {\n         assert_eq!(\"( ;\".to_ascii(),                 v2ascii!([40, 32, 59]));\n         // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n         // if chained-from directly\n-        let v = box [40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n-        let v = \"( ;\".to_owned();              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = box [40u8, 32u8, 59u8];\n+        assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = \"( ;\".to_strbuf();\n+        assert_eq!(v.as_slice().to_ascii(), v2ascii!([40, 32, 59]));\n \n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_strbuf());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_strbuf());\n \n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_owned());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_owned());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_owned());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_strbuf());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_strbuf());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_strbuf());\n \n         assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n \n@@ -572,16 +574,16 @@ mod tests {\n \n     #[test]\n     fn test_ascii_vec_ng() {\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_owned());\n-        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_owned());\n-        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_owned());\n-        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_owned());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_strbuf());\n+        assert_eq!(\"abCDef&?#\".to_ascii().to_upper().into_str(), \"ABCDEF&?#\".to_strbuf());\n+        assert_eq!(\"\".to_ascii().to_lower().into_str(), \"\".to_strbuf());\n+        assert_eq!(\"YMCA\".to_ascii().to_lower().into_str(), \"ymca\".to_strbuf());\n+        assert_eq!(\"abcDEFxyz:.;\".to_ascii().to_upper().into_str(), \"ABCDEFXYZ:.;\".to_strbuf());\n     }\n \n     #[test]\n     fn test_owned_ascii_vec() {\n-        assert_eq!((\"( ;\".to_owned()).into_ascii(), vec2ascii![40, 32, 59]);\n+        assert_eq!((\"( ;\".to_strbuf()).into_ascii(), vec2ascii![40, 32, 59]);\n         assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n     }\n \n@@ -593,8 +595,8 @@ mod tests {\n \n     #[test]\n     fn test_ascii_into_str() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_owned());\n-        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_owned());\n+        assert_eq!(vec2ascii![40, 32, 59].into_str(), \"( ;\".to_strbuf());\n+        assert_eq!(vec2ascii!(40, 32, 59).into_str(), \"( ;\".to_strbuf());\n     }\n \n     #[test]\n@@ -641,70 +643,70 @@ mod tests {\n         assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n         assert_eq!((vec![127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n-        assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n-        assert_eq!((\"zo\u00e4\u534e\".to_owned()).into_ascii_opt(), None);\n+        assert_eq!((\"( ;\".to_strbuf()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n+        assert_eq!((\"zo\u00e4\u534e\".to_strbuf()).into_ascii_opt(), None);\n     }\n \n     #[test]\n     fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_owned());\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_owned());\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\".to_strbuf());\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\".to_strbuf());\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()))\n+                       from_char(from_u32(upper).unwrap()).to_strbuf())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_owned());\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\".to_strbuf());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_owned());\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\".to_strbuf());\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()))\n+                       from_char(from_u32(lower).unwrap()).to_strbuf())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_into_ascii_upper() {\n-        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_owned()).into_ascii_upper(),\n-                   \"URL()URL()URL()\u00fcRL\".to_owned());\n-        assert_eq!((\"h\u0131\u212a\u00df\".to_owned()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_owned());\n+        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_strbuf()).into_ascii_upper(),\n+                   \"URL()URL()URL()\u00fcRL\".to_strbuf());\n+        assert_eq!((\"h\u0131\u212a\u00df\".to_strbuf()).into_ascii_upper(), \"H\u0131\u212a\u00df\".to_strbuf());\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).into_ascii_upper(),\n-                       from_char(from_u32(upper).unwrap()))\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_strbuf().into_ascii_upper(),\n+                       from_char(from_u32(upper).unwrap()).to_strbuf())\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_into_ascii_lower() {\n-        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_owned()).into_ascii_lower(),\n-                   \"url()url()url()\u00dcrl\".to_owned());\n+        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_strbuf()).into_ascii_lower(),\n+                   \"url()url()url()\u00dcrl\".to_strbuf());\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((\"H\u0130\u212a\u00df\".to_owned()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_owned());\n+        assert_eq!((\"H\u0130\u212a\u00df\".to_strbuf()).into_ascii_lower(), \"h\u0130\u212a\u00df\".to_strbuf());\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).into_ascii_lower(),\n-                       from_char(from_u32(lower).unwrap()))\n+            assert_eq!(from_char(from_u32(i).unwrap()).to_strbuf().into_ascii_lower(),\n+                       from_char(from_u32(lower).unwrap()).to_strbuf())\n             i += 1;\n         }\n     }\n@@ -724,21 +726,24 @@ mod tests {\n             let c = i;\n             let lower = if 'A' as u32 <= c && c <= 'Z' as u32 { c + 'a' as u32 - 'A' as u32 }\n                         else { c };\n-            assert!(from_char(from_u32(i).unwrap()).\n-                eq_ignore_ascii_case(from_char(from_u32(lower).unwrap())));\n+            assert!(from_char(from_u32(i).unwrap()).as_slice()\n+                                                   .eq_ignore_ascii_case(\n+                                                       from_char(\n+                                                           from_u32(lower)\n+                                                            .unwrap())));\n             i += 1;\n         }\n     }\n \n     #[test]\n     fn test_to_str() {\n         let s = Ascii{ chr: 't' as u8 }.to_str();\n-        assert_eq!(s, \"t\".to_owned());\n+        assert_eq!(s, \"t\".to_strbuf());\n     }\n \n     #[test]\n     fn test_show() {\n         let c = Ascii { chr: 't' as u8 };\n-        assert_eq!(format!(\"{}\", c), \"t\".to_owned());\n+        assert_eq!(format_strbuf!(\"{}\", c), \"t\".to_strbuf());\n     }\n }"}, {"sha": "b2521f2978a541d1d3a9006d2c1606b359e383ec", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -990,7 +990,7 @@ mod test {\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val).unwrap(),\n+            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n             None => 1,\n         }\n     }\n@@ -1523,7 +1523,7 @@ mod sync_tests {\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => from_str::<uint>(val).unwrap(),\n+            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n             None => 1,\n         }\n     }"}, {"sha": "db23a5f1720221b12f096bc1cd0f8817a477ba05", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -27,9 +27,9 @@ general case.\n \n The `format!` macro is intended to be familiar to those coming from C's\n printf/fprintf functions or Python's `str.format` function. In its current\n-revision, the `format!` macro returns a `~str` type which is the result of the\n-formatting. In the future it will also be able to pass in a stream to format\n-arguments directly while performing minimal allocations.\n+revision, the `format!` macro returns a `StrBuf` type which is the result of\n+the formatting. In the future it will also be able to pass in a stream to\n+format arguments directly while performing minimal allocations.\n \n Some examples of the `format!` extension are:\n \n@@ -282,7 +282,7 @@ use std::io;\n \n # #[allow(unused_must_use)]\n # fn main() {\n-format_args!(fmt::format, \"this returns {}\", \"~str\");\n+format_args!(fmt::format, \"this returns {}\", \"StrBuf\");\n \n let some_writer: &mut io::Writer = &mut io::stdout();\n format_args!(|args| { write!(some_writer, \"{}\", args) }, \"print with a {}\", \"closure\");\n@@ -488,7 +488,7 @@ use io;\n use option::None;\n use repr;\n use result::{Ok, Err};\n-use str::{StrAllocating};\n+use str::{Str, StrAllocating};\n use str;\n use strbuf::StrBuf;\n use slice::Vector;\n@@ -545,10 +545,10 @@ pub trait Poly {\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\".to_owned());\n /// ```\n-pub fn format(args: &Arguments) -> ~str {\n+pub fn format(args: &Arguments) -> StrBuf{\n     let mut output = io::MemWriter::new();\n     let _ = write!(&mut output, \"{}\", args);\n-    str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned()\n+    str::from_utf8(output.unwrap().as_slice()).unwrap().into_strbuf()\n }\n \n /// Temporary transition utility\n@@ -572,7 +572,7 @@ impl<T> Poly for T {\n             // this allocation of a new string\n             _ => {\n                 let s = repr::repr_to_str(self);\n-                f.pad(s)\n+                f.pad(s.as_slice())\n             }\n         }\n     }"}, {"sha": "1dad1667ebd45ef811cb53bea7d351a99a427531", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -23,7 +23,7 @@\n  * #[deriving(Hash)]\n  * struct Person {\n  *     id: uint,\n- *     name: ~str,\n+ *     name: StrBuf,\n  *     phone: u64,\n  * }\n  *\n@@ -43,7 +43,7 @@\n  *\n  * struct Person {\n  *     id: uint,\n- *     name: ~str,\n+ *     name: StrBuf,\n  *     phone: u64,\n  * }\n  *\n@@ -145,13 +145,6 @@ impl<'a, S: Writer> Hash<S> for &'a str {\n     }\n }\n \n-impl<S: Writer> Hash<S> for ~str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-\n macro_rules! impl_hash_tuple(\n     () => (\n         impl<S: Writer> Hash<S> for () {"}, {"sha": "1434e3c7ad71e693f60ea4a57615087f02e5f1f8", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -458,12 +458,12 @@ mod tests {\n         let mut state_inc = SipState::new_with_keys(k0, k1);\n         let mut state_full = SipState::new_with_keys(k0, k1);\n \n-        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n+        fn to_hex_str(r: &[u8, ..8]) -> StrBuf {\n             let mut s = StrBuf::new();\n             for b in r.iter() {\n-                s.push_str((*b as uint).to_str_radix(16u));\n+                s.push_str((*b as uint).to_str_radix(16u).as_slice());\n             }\n-            s.into_owned()\n+            s\n         }\n \n         fn result_bytes(h: u64) -> ~[u8] {\n@@ -478,13 +478,13 @@ mod tests {\n             ]\n         }\n \n-        fn result_str(h: u64) -> ~str {\n+        fn result_str(h: u64) -> StrBuf {\n             let r = result_bytes(h);\n             let mut s = StrBuf::new();\n             for b in r.iter() {\n-                s.push_str((*b as uint).to_str_radix(16u));\n+                s.push_str((*b as uint).to_str_radix(16u).as_slice());\n             }\n-            s.into_owned()\n+            s\n         }\n \n         while t < 64 {\n@@ -636,15 +636,13 @@ officia deserunt mollit anim id est laborum.\";\n     struct Compound {\n         x: u8,\n         y: u64,\n-        z: ~str,\n     }\n \n     #[bench]\n     fn bench_compound_1(b: &mut Bencher) {\n         let compound = Compound {\n             x: 1,\n             y: 2,\n-            z: \"foobarbaz\".to_owned(),\n         };\n         b.iter(|| {\n             assert_eq!(hash(&compound), 15783192367317361799);"}, {"sha": "c7b0d66062460c4b7fea342ac6f389925740c5c8", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -537,9 +537,9 @@ mod test {\n     fn test_read_line() {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_owned()));\n-        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_owned()));\n-        assert_eq!(reader.read_line(), Ok(\"c\".to_owned()));\n+        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_strbuf()));\n+        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_strbuf()));\n+        assert_eq!(reader.read_line(), Ok(\"c\".to_strbuf()));\n         assert!(reader.read_line().is_err());\n     }\n \n@@ -548,9 +548,9 @@ mod test {\n         let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_owned())));\n-        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_owned())));\n-        assert_eq!(it.next(), Some(Ok(\"c\".to_owned())));\n+        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_strbuf())));\n+        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_strbuf())));\n+        assert_eq!(it.next(), Some(Ok(\"c\".to_strbuf())));\n         assert_eq!(it.next(), None);\n     }\n "}, {"sha": "6feaf10d5c5c57ccf75904031e8e3127e77a525d", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -745,7 +745,8 @@ mod test {\n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n-        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        let ret = os::tmpdir().join(\n+            format_strbuf!(\"rust-{}\", rand::random::<u32>()));\n         check!(io::fs::mkdir(&ret, io::UserRWX));\n         TempDir(ret)\n     }\n@@ -952,9 +953,10 @@ mod test {\n         check!(mkdir(dir, io::UserRWX));\n         let prefix = \"foo\";\n         for n in range(0,3) {\n-            let f = dir.join(format!(\"{}.txt\", n));\n+            let f = dir.join(format_strbuf!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n-            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n+            let msg_str =\n+                (prefix + n.to_str().into_owned()).to_owned();\n             let msg = msg_str.as_bytes();\n             check!(w.write(msg));\n         }\n@@ -1039,7 +1041,7 @@ mod test {\n         let tmpdir = tmpdir();\n \n         let mut dirpath = tmpdir.path().clone();\n-        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n+        dirpath.push(format_strbuf!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n         check!(mkdir(&dirpath, io::UserRWX));\n         assert!(dirpath.is_dir());\n \n@@ -1056,7 +1058,7 @@ mod test {\n \n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n-        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n+        let unicode = unicode.join(format_strbuf!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n         check!(mkdir(&unicode, io::UserRWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());"}, {"sha": "c1e228cd693b59890cb2dd7f7cdafe5efd0e4557", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -497,7 +497,7 @@ mod test {\n         writer.write_line(\"testing\").unwrap();\n         writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_owned());\n+        assert_eq!(r.read_to_str().unwrap(), \"testingtesting\\ntesting\".to_strbuf());\n     }\n \n     #[test]\n@@ -507,7 +507,7 @@ mod test {\n         writer.write_char('\\n').unwrap();\n         writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_owned());\n+        assert_eq!(r.read_to_str().unwrap(), \"a\\n\u1ec7\".to_strbuf());\n     }\n \n     #[test]"}, {"sha": "50bd3e7067c85db49e7c0a30a0cf74249a758219", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -76,7 +76,7 @@ Some examples of obvious things you might want to do\n \n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n-    let lines: Vec<~str> = file.lines().map(|x| x.unwrap()).collect();\n+    let lines: Vec<StrBuf> = file.lines().map(|x| x.unwrap()).collect();\n     ```\n \n * Make a simple TCP client connection and request\n@@ -228,6 +228,7 @@ use result::{Ok, Err, Result};\n use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n+use strbuf::StrBuf;\n use uint;\n use vec::Vec;\n \n@@ -292,7 +293,7 @@ pub struct IoError {\n     /// A human-readable description about the error\n     pub desc: &'static str,\n     /// Detailed information about this error, not always available\n-    pub detail: Option<~str>\n+    pub detail: Option<StrBuf>\n }\n \n impl IoError {\n@@ -364,7 +365,11 @@ impl IoError {\n         IoError {\n             kind: kind,\n             desc: desc,\n-            detail: if detail {Some(os::error_string(errno))} else {None},\n+            detail: if detail {\n+                Some(os::error_string(errno))\n+            } else {\n+                None\n+            },\n         }\n     }\n \n@@ -490,8 +495,10 @@ pub trait Reader {\n     /// bytes are read.\n     fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n         if min > buf.len() {\n-            return Err(IoError { detail: Some(\"the buffer is too short\".to_owned()),\n-                                 ..standard_error(InvalidInput) });\n+            return Err(IoError {\n+                detail: Some(\"the buffer is too short\".to_strbuf()),\n+                ..standard_error(InvalidInput)\n+            });\n         }\n         let mut read = 0;\n         while read < min {\n@@ -556,8 +563,10 @@ pub trait Reader {\n     /// bytes are read.\n     fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n         if min > len {\n-            return Err(IoError { detail: Some(\"the buffer is too short\".to_owned()),\n-                                 ..standard_error(InvalidInput) });\n+            return Err(IoError {\n+                detail: Some(\"the buffer is too short\".to_strbuf()),\n+                ..standard_error(InvalidInput)\n+            });\n         }\n \n         let start_len = buf.len();\n@@ -623,10 +632,10 @@ pub trait Reader {\n     /// This function returns all of the same errors as `read_to_end` with an\n     /// additional error if the reader's contents are not a valid sequence of\n     /// UTF-8 bytes.\n-    fn read_to_str(&mut self) -> IoResult<~str> {\n+    fn read_to_str(&mut self) -> IoResult<StrBuf> {\n         self.read_to_end().and_then(|s| {\n             match str::from_utf8(s.as_slice()) {\n-                Some(s) => Ok(s.to_owned()),\n+                Some(s) => Ok(s.to_strbuf()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         })\n@@ -1235,8 +1244,8 @@ pub struct Lines<'r, T> {\n     buffer: &'r mut T,\n }\n \n-impl<'r, T: Buffer> Iterator<IoResult<~str>> for Lines<'r, T> {\n-    fn next(&mut self) -> Option<IoResult<~str>> {\n+impl<'r, T: Buffer> Iterator<IoResult<StrBuf>> for Lines<'r, T> {\n+    fn next(&mut self) -> Option<IoResult<StrBuf>> {\n         match self.buffer.read_line() {\n             Ok(x) => Some(Ok(x)),\n             Err(IoError { kind: EndOfFile, ..}) => None,\n@@ -1321,10 +1330,10 @@ pub trait Buffer: Reader {\n     ///\n     /// Additionally, this function can fail if the line of input read is not a\n     /// valid UTF-8 sequence of bytes.\n-    fn read_line(&mut self) -> IoResult<~str> {\n+    fn read_line(&mut self) -> IoResult<StrBuf> {\n         self.read_until('\\n' as u8).and_then(|line|\n             match str::from_utf8(line.as_slice()) {\n-                Some(s) => Ok(s.to_owned()),\n+                Some(s) => Ok(s.to_strbuf()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         )"}, {"sha": "4bf71b5480e2f84552c7aa55361ff649aeaf86d0", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -445,8 +445,8 @@ mod test {\n     #[test]\n     fn ipv6_addr_to_str() {\n         let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_owned() ||\n-                a1.to_str() == \"::FFFF:192.0.2.128\".to_owned());\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_owned());\n+        assert!(a1.to_str() == \"::ffff:192.0.2.128\".to_strbuf() ||\n+                a1.to_str() == \"::FFFF:192.0.2.128\".to_strbuf());\n+        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), \"8:9:a:b:c:d:e:f\".to_strbuf());\n     }\n }"}, {"sha": "ac17bc1de13799b1c9da39122f50acc947bee69b", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -434,7 +434,7 @@ mod test {\n         let socket_addr = next_test_ip4();\n         let ip_str = socket_addr.ip.to_str();\n         let port = socket_addr.port;\n-        let listener = TcpListener::bind(ip_str, port);\n+        let listener = TcpListener::bind(ip_str.as_slice(), port);\n         let mut acceptor = listener.listen();\n \n         spawn(proc() {\n@@ -452,7 +452,7 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect(\"localhost\", addr.port);\n@@ -469,7 +469,7 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect(\"127.0.0.1\", addr.port);\n@@ -486,7 +486,7 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect(\"::1\", addr.port);\n@@ -503,10 +503,10 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str, port);\n+            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -520,10 +520,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let mut stream = TcpStream::connect(ip_str, port);\n+            let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n             stream.write([99]).unwrap();\n         });\n \n@@ -537,10 +537,10 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -554,10 +554,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -571,10 +571,10 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -596,10 +596,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -621,10 +621,10 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -648,10 +648,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let _stream = TcpStream::connect(ip_str, port);\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port);\n             // Close\n         });\n \n@@ -676,11 +676,11 @@ mod test {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -697,11 +697,11 @@ mod test {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n         let max = 10u;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             for _ in range(0, max) {\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 stream.write([99]).unwrap();\n             }\n         });\n@@ -718,7 +718,7 @@ mod test {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str, port).listen();\n+        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -743,7 +743,7 @@ mod test {\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -757,7 +757,7 @@ mod test {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n         static MAX: int = 10;\n-        let acceptor = TcpListener::bind(ip_str, port).listen();\n+        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -782,7 +782,7 @@ mod test {\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -796,7 +796,7 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str, port).listen();\n+        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -821,7 +821,7 @@ mod test {\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -835,7 +835,7 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str, port).listen();\n+        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n             let mut acceptor = acceptor;\n@@ -860,7 +860,7 @@ mod test {\n \n             spawn(proc() {\n                 debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(ip_str, port);\n+                let mut stream = TcpStream::connect(ip_str.as_slice(), port);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n@@ -872,7 +872,7 @@ mod test {\n     pub fn socket_name(addr: SocketAddr) {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut listener = TcpListener::bind(ip_str, port).unwrap();\n+        let mut listener = TcpListener::bind(ip_str.as_slice(), port).unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n@@ -884,13 +884,13 @@ mod test {\n     pub fn peer_name(addr: SocketAddr) {\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let acceptor = TcpListener::bind(ip_str, port).listen();\n+        let acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n         spawn(proc() {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        let stream = TcpStream::connect(ip_str, port);\n+        let stream = TcpStream::connect(ip_str.as_slice(), port);\n \n         assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n@@ -920,7 +920,7 @@ mod test {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let ip_str = addr.ip.to_str();\n-            let mut srv = TcpListener::bind(ip_str, port).listen().unwrap();\n+            let mut srv = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n@@ -931,7 +931,7 @@ mod test {\n \n         rx.recv();\n         let ip_str = addr.ip.to_str();\n-        let mut c = TcpStream::connect(ip_str, port).unwrap();\n+        let mut c = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n@@ -942,9 +942,9 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let listener = TcpListener::bind(ip_str, port).unwrap().listen();\n+        let listener = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n         assert!(listener.is_ok());\n-        match TcpListener::bind(ip_str, port).listen() {\n+        match TcpListener::bind(ip_str.as_slice(), port).listen() {\n             Ok(..) => fail!(),\n             Err(e) => {\n                 assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n@@ -960,14 +960,14 @@ mod test {\n         spawn(proc() {\n             let ip_str = addr.ip.to_str();\n             rx.recv();\n-            let _stream = TcpStream::connect(ip_str, port).unwrap();\n+            let _stream = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             // Close\n             rx.recv();\n         });\n \n         {\n             let ip_str = addr.ip.to_str();\n-            let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+            let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n             tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n@@ -976,17 +976,17 @@ mod test {\n             }\n             // Close listener\n         }\n-        let _listener = TcpListener::bind(addr.ip.to_str(), port);\n+        let _listener = TcpListener::bind(addr.ip.to_str().as_slice(), port);\n     })\n \n     iotest!(fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port);\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(buf), Ok(1));\n             assert_eq!(buf[0], 1);\n@@ -1014,12 +1014,12 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port);\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n             s.write([1]).unwrap();\n             rx.recv();\n             s.write([2]).unwrap();\n@@ -1048,10 +1048,10 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut acceptor = TcpListener::bind(ip_str, port).listen();\n+        let mut acceptor = TcpListener::bind(ip_str.as_slice(), port).listen();\n \n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port);\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port);\n             let mut buf = [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n@@ -1077,15 +1077,15 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let a = TcpListener::bind(ip_str, port).unwrap().listen();\n+        let a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen();\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n-        let mut s = TcpStream::connect(ip_str, port).unwrap();\n+        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n@@ -1095,7 +1095,7 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str, port).unwrap().listen().unwrap();\n+        let mut a = TcpListener::bind(ip_str.as_slice(), port).unwrap().listen().unwrap();\n \n         a.set_timeout(Some(10));\n \n@@ -1114,7 +1114,8 @@ mod test {\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n+                tx.send(TcpStream::connect(addr.ip.to_str().as_slice(),\n+                                           port).unwrap());\n             });\n             let _l = rx.recv();\n             for i in range(0, 1001) {\n@@ -1131,7 +1132,8 @@ mod test {\n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         spawn(proc() {\n-            drop(TcpStream::connect(addr.ip.to_str(), port).unwrap());\n+            drop(TcpStream::connect(addr.ip.to_str().as_slice(),\n+                                    port).unwrap());\n         });\n         a.accept().unwrap();\n     })\n@@ -1140,7 +1142,7 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n@@ -1149,7 +1151,7 @@ mod test {\n         });\n \n         let mut b = [0];\n-        let mut s = TcpStream::connect(ip_str, port).unwrap();\n+        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n         let mut s2 = s.clone();\n \n         // closing should prevent reads/writes\n@@ -1178,15 +1180,15 @@ mod test {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n         spawn(proc() {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv_opt();\n         });\n \n-        let mut s = TcpStream::connect(ip_str, port).unwrap();\n+        let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n         spawn(proc() {\n@@ -1205,10 +1207,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port).unwrap();\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1239,10 +1241,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port).unwrap();\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n@@ -1269,10 +1271,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port).unwrap();\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             rx.recv();\n             assert!(s.write([0]).is_ok());\n             let _ = rx.recv_opt();\n@@ -1298,10 +1300,10 @@ mod test {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_str();\n         let port = addr.port;\n-        let mut a = TcpListener::bind(ip_str, port).listen().unwrap();\n+        let mut a = TcpListener::bind(ip_str.as_slice(), port).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let mut s = TcpStream::connect(ip_str, port).unwrap();\n+            let mut s = TcpStream::connect(ip_str.as_slice(), port).unwrap();\n             rx.recv();\n             assert_eq!(s.write([0]), Ok(()));\n             let _ = rx.recv_opt();"}, {"sha": "f1f3e0a468a541fbb05cd9bfa1e4c06b63a33739", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -583,11 +583,11 @@ mod tests {\n         }\n     })\n \n-    pub fn read_all(input: &mut Reader) -> ~str {\n+    pub fn read_all(input: &mut Reader) -> StrBuf {\n         input.read_to_str().unwrap()\n     }\n \n-    pub fn run_output(cmd: Command) -> ~str {\n+    pub fn run_output(cmd: Command) -> StrBuf {\n         let p = cmd.spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n@@ -601,7 +601,7 @@ mod tests {\n     iotest!(fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"foobar\\n\".to_owned());\n+        assert_eq!(run_output(cmd), \"foobar\\n\".to_strbuf());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -610,7 +610,7 @@ mod tests {\n         cmd.arg(\"-c\").arg(\"pwd\")\n            .cwd(&Path::new(\"/\"))\n            .stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"/\\n\".to_owned());\n+        assert_eq!(run_output(cmd), \"/\\n\".to_strbuf());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -624,7 +624,7 @@ mod tests {\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n-        assert_eq!(out, \"foobar\\n\".to_owned());\n+        assert_eq!(out, \"foobar\\n\".to_strbuf());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -682,7 +682,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n+        assert_eq!(output_str.trim().to_strbuf(), \"hello\".to_strbuf());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -719,7 +719,7 @@ mod tests {\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n+        assert_eq!(output_str.trim().to_strbuf(), \"hello\".to_strbuf());\n         // FIXME #7224\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n@@ -749,9 +749,9 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_owned();\n+                                        .output.as_slice()).unwrap().to_strbuf();\n         let parent_dir = os::getcwd();\n-        let child_dir = Path::new(output.trim());\n+        let child_dir = Path::new(output.as_slice().trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -768,8 +768,8 @@ mod tests {\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_owned();\n-        let child_dir = Path::new(output.trim());\n+                                        .output.as_slice()).unwrap().to_strbuf();\n+        let child_dir = Path::new(output.as_slice().trim().into_strbuf());\n \n         let parent_stat = parent_dir.stat().unwrap();\n         let child_stat = child_dir.stat().unwrap();\n@@ -803,12 +803,14 @@ mod tests {\n \n         let prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output().unwrap()\n-                                        .output.as_slice()).unwrap().to_owned();\n+                                        .output.as_slice()).unwrap().to_strbuf();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n-            assert!(k.is_empty() || output.contains(format!(\"{}={}\", *k, *v)));\n+            assert!(k.is_empty() ||\n+                    output.as_slice()\n+                          .contains(format!(\"{}={}\", *k, *v).as_slice()));\n         }\n     })\n     #[cfg(target_os=\"android\")]\n@@ -819,14 +821,18 @@ mod tests {\n         let mut prog = env_cmd().spawn().unwrap();\n         let output = str::from_utf8(prog.wait_with_output()\n                                         .unwrap().output.as_slice())\n-                                   .unwrap().to_owned();\n+                                   .unwrap().to_strbuf();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n-            if *k != \"RANDOM\".to_owned() {\n-                assert!(output.contains(format!(\"{}={}\", *k, *v)) ||\n-                        output.contains(format!(\"{}=\\'{}\\'\", *k, *v)));\n+            if *k != \"RANDOM\".to_strbuf() {\n+                assert!(output.contains(format!(\"{}={}\",\n+                                                *k,\n+                                                *v).as_slice()) ||\n+                        output.contains(format!(\"{}=\\'{}\\'\",\n+                                                *k,\n+                                                *v).as_slice()));\n             }\n         }\n     })\n@@ -835,9 +841,9 @@ mod tests {\n         let new_env = box [(\"RUN_TEST_NEW_ENV\", \"123\")];\n         let prog = env_cmd().env(new_env).spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n-        let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_strbuf();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+        assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     })\n "}, {"sha": "3a103651d635f6693e50033795d014ef98b35137", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -409,7 +409,7 @@ mod tests {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_owned());\n+        assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_strbuf());\n     })\n \n     iotest!(fn capture_stderr() {\n@@ -422,6 +422,6 @@ mod tests {\n             fail!(\"my special message\");\n         });\n         let s = r.read_to_str().unwrap();\n-        assert!(s.contains(\"my special message\"));\n+        assert!(s.as_slice().contains(\"my special message\"));\n     })\n }"}, {"sha": "806df838c919e36d491b15913543d2539144382e", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -42,10 +42,11 @@ impl TempDir {\n         static mut CNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n \n         for _ in range(0u, 1000) {\n-            let filename = format!(\"rs-{}-{}-{}\",\n-                                   unsafe { libc::getpid() },\n-                                   unsafe { CNT.fetch_add(1, atomics::SeqCst) },\n-                                   suffix);\n+            let filename =\n+                format_strbuf!(\"rs-{}-{}-{}\",\n+                               unsafe { libc::getpid() },\n+                               unsafe { CNT.fetch_add(1, atomics::SeqCst) },\n+                               suffix);\n             let p = tmpdir.join(filename);\n             match fs::mkdir(&p, io::UserRWX) {\n                 Err(..) => {}"}, {"sha": "de8a6f4beb5ea3102bad955d034d578bbe409cb0", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -67,14 +67,14 @@ pub fn next_test_unix() -> Path {\n     // base port and pid are an attempt to be unique between multiple\n     // test-runners of different configurations running on one\n     // buildbot, the count is to be unique within this executable.\n-    let string = format!(\"rust-test-unix-path-{}-{}-{}\",\n-                         base_port(),\n-                         unsafe {libc::getpid()},\n-                         unsafe {COUNT.fetch_add(1, Relaxed)});\n+    let string = format_strbuf!(\"rust-test-unix-path-{}-{}-{}\",\n+                                base_port(),\n+                                unsafe {libc::getpid()},\n+                                unsafe {COUNT.fetch_add(1, Relaxed)});\n     if cfg!(unix) {\n         os::tmpdir().join(string)\n     } else {\n-        Path::new(r\"\\\\.\\pipe\\\" + string)\n+        Path::new(format_strbuf!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n }\n "}, {"sha": "b91817930512ae81a4d0b43cce2884e7b17a30d6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -284,4 +284,5 @@ mod std {\n \n     // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n     #[cfg(test)] pub use slice;\n+    #[cfg(test)] pub use strbuf;\n }"}, {"sha": "8798c035fcaf18036bad53f0d39e2e8f2762961c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -274,12 +274,12 @@ mod tests {\n \n     #[test]\n     fn test_tls_multitask() {\n-        static my_key: Key<~str> = &Key;\n-        my_key.replace(Some(\"parent data\".to_owned()));\n+        static my_key: Key<StrBuf> = &Key;\n+        my_key.replace(Some(\"parent data\".to_strbuf()));\n         task::spawn(proc() {\n             // TLS shouldn't carry over.\n             assert!(my_key.get().is_none());\n-            my_key.replace(Some(\"child data\".to_owned()));\n+            my_key.replace(Some(\"child data\".to_strbuf()));\n             assert!(my_key.get().get_ref().as_slice() == \"child data\");\n             // should be cleaned up for us\n         });\n@@ -292,17 +292,17 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite() {\n-        static my_key: Key<~str> = &Key;\n-        my_key.replace(Some(\"first data\".to_owned()));\n-        my_key.replace(Some(\"next data\".to_owned())); // Shouldn't leak.\n+        static my_key: Key<StrBuf> = &Key;\n+        my_key.replace(Some(\"first data\".to_strbuf()));\n+        my_key.replace(Some(\"next data\".to_strbuf())); // Shouldn't leak.\n         assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n-        static my_key: Key<~str> = &Key;\n-        my_key.replace(Some(\"weasel\".to_owned()));\n-        assert!(my_key.replace(None).unwrap() == \"weasel\".to_owned());\n+        static my_key: Key<StrBuf> = &Key;\n+        my_key.replace(Some(\"weasel\".to_strbuf()));\n+        assert!(my_key.replace(None).unwrap() == \"weasel\".to_strbuf());\n         // Pop must remove the data from the map.\n         assert!(my_key.replace(None).is_none());\n     }\n@@ -315,32 +315,32 @@ mod tests {\n         // to get recorded as something within a rust stack segment. Then a\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n-        static my_key: Key<~str> = &Key;\n+        static my_key: Key<StrBuf> = &Key;\n         task::spawn(proc() {\n-            my_key.replace(Some(\"hax\".to_owned()));\n+            my_key.replace(Some(\"hax\".to_strbuf()));\n         });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n-        static str_key: Key<~str> = &Key;\n+        static str_key: Key<StrBuf> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_owned()));\n+            str_key.replace(Some(\"string data\".to_strbuf()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n         });\n     }\n \n     #[test]\n     fn test_tls_overwrite_multiple_types() {\n-        static str_key: Key<~str> = &Key;\n+        static str_key: Key<StrBuf> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_owned()));\n-            str_key.replace(Some(\"string data 2\".to_owned()));\n+            str_key.replace(Some(\"string data\".to_strbuf()));\n+            str_key.replace(Some(\"string data 2\".to_strbuf()));\n             box_key.replace(Some(@()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n@@ -354,13 +354,13 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_tls_cleanup_on_failure() {\n-        static str_key: Key<~str> = &Key;\n+        static str_key: Key<StrBuf> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        str_key.replace(Some(\"parent data\".to_owned()));\n+        str_key.replace(Some(\"parent data\".to_strbuf()));\n         box_key.replace(Some(@()));\n         task::spawn(proc() {\n-            str_key.replace(Some(\"string data\".to_owned()));\n+            str_key.replace(Some(\"string data\".to_strbuf()));\n             box_key.replace(Some(@()));\n             int_key.replace(Some(42));\n             fail!();"}, {"sha": "66d93c230a57c1eb430f28aa24327899ce9a3f63", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -20,6 +20,7 @@ use intrinsics;\n use libc::c_int;\n use num::strconv;\n use num;\n+use strbuf::StrBuf;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -242,7 +243,7 @@ impl FloatMath for f32 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f32) -> ~str {\n+pub fn to_str(num: f32) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -254,7 +255,7 @@ pub fn to_str(num: f32) -> ~str {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str_hex(num: f32) -> ~str {\n+pub fn to_str_hex(num: f32) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -268,7 +269,7 @@ pub fn to_str_hex(num: f32) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: uint) -> (StrBuf, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n@@ -281,7 +282,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f32, dig: uint) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n@@ -295,7 +296,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f32, dig: uint) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n@@ -310,7 +311,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str {\n+pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n@@ -325,7 +326,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> ~str {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> ~str {\n+pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n@@ -345,7 +346,7 @@ impl num::ToStrRadix for f32 {\n     /// possible misinterpretation of the result at higher bases. If those values\n     /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> StrBuf {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\"}, {"sha": "be4e4dc0d66f6013950837044779cc652dd93583", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -19,6 +19,7 @@ use intrinsics;\n use libc::c_int;\n use num::strconv;\n use num;\n+use strbuf::StrBuf;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -250,7 +251,7 @@ impl FloatMath for f64 {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str(num: f64) -> ~str {\n+pub fn to_str(num: f64) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -262,7 +263,7 @@ pub fn to_str(num: f64) -> ~str {\n ///\n /// * num - The float value\n #[inline]\n-pub fn to_str_hex(num: f64) -> ~str {\n+pub fn to_str_hex(num: f64) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n@@ -276,7 +277,7 @@ pub fn to_str_hex(num: f64) -> ~str {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: uint) -> (StrBuf, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n                            strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n@@ -289,7 +290,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n+pub fn to_str_exact(num: f64, dig: uint) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n@@ -303,7 +304,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n+pub fn to_str_digits(num: f64, dig: uint) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n@@ -318,7 +319,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str {\n+pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpDec, upper);\n     r\n@@ -333,7 +334,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> ~str {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> ~str {\n+pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> StrBuf {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpDec, upper);\n     r\n@@ -353,7 +354,7 @@ impl num::ToStrRadix for f64 {\n     /// possible misinterpretation of the result at higher bases. If those values\n     /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> ~str {\n+    fn to_str_radix(&self, rdx: uint) -> StrBuf {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\"}, {"sha": "7d08c181e9e391e4959ae8caeea99424fb071285", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "2504d3f576627b050b9a9628456a6499dae8e061", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "7fc6a091dfcf1c133a1363b049d76745795194f4", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "a39a6ced07742e1558633bf8d1bfe75b50c9e0d5", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "2a23a35be6d6a93a1a67e6ae67eed7fcc356535e", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "31a0edfbc389c8337730b684c35161c78061ffb0", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -77,8 +77,8 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+        format_strbuf!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }\n \n@@ -136,39 +136,39 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_owned());\n-        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_owned());\n-        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_owned());\n-        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_owned());\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_strbuf());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_strbuf());\n+        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_strbuf());\n+        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_strbuf());\n+        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_strbuf());\n \n     }\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_str(), \"127\".to_owned());\n+        assert_eq!(i8_val.to_str(), \"127\".to_strbuf());\n \n         i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_str(), \"-128\".to_owned());\n+        assert_eq!(i8_val.to_str(), \"-128\".to_strbuf());\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_str(), \"32767\".to_owned());\n+        assert_eq!(i16_val.to_str(), \"32767\".to_strbuf());\n \n         i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_str(), \"-32768\".to_owned());\n+        assert_eq!(i16_val.to_str(), \"-32768\".to_strbuf());\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_str(), \"2147483647\".to_owned());\n+        assert_eq!(i32_val.to_str(), \"2147483647\".to_strbuf());\n \n         i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_str(), \"-2147483648\".to_owned());\n+        assert_eq!(i32_val.to_str(), \"-2147483648\".to_strbuf());\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_owned());\n+        assert_eq!(i64_val.to_str(), \"9223372036854775807\".to_strbuf());\n \n         i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_owned());\n+        assert_eq!(i64_val.to_str(), \"-9223372036854775808\".to_strbuf());\n     }\n \n     #[test]"}, {"sha": "c1d6bbb492db88faaa08ddb42e06974dc585d67c", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,7 +15,8 @@\n \n #![allow(missing_doc)]\n \n-use option::{Option};\n+use option::Option;\n+use strbuf::StrBuf;\n \n #[cfg(test)] use fmt::Show;\n \n@@ -111,7 +112,7 @@ pub trait FloatMath: Float {\n \n /// A generic trait for converting a value to a string with a radix (base)\n pub trait ToStrRadix {\n-    fn to_str_radix(&self, radix: uint) -> ~str;\n+    fn to_str_radix(&self, radix: uint) -> StrBuf;\n }\n \n /// A generic trait for converting a string with a radix (base) to a value"}, {"sha": "795534dc283722feb234ae2d53412ffb89cc7815", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -19,9 +19,9 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use slice::{CloneableVector, ImmutableVector, MutableVector};\n+use slice::{ImmutableVector, MutableVector};\n use std::cmp::{Ord, Eq};\n-use str::{StrAllocating, StrSlice};\n+use str::StrSlice;\n use strbuf::StrBuf;\n use vec::Vec;\n \n@@ -496,10 +496,10 @@ pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n-        ) -> (~str, bool) {\n+        ) -> (StrBuf, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n                                negative_zero, sign, digits, exp_format, exp_capital);\n-    (StrBuf::from_utf8(bytes).unwrap().into_owned(), special)\n+    (StrBuf::from_utf8(bytes).unwrap(), special)\n }\n \n // Some constants for from_str_bytes_common's input validation,"}, {"sha": "6d68af998909415efab953195579e6eb5e7af6cd", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "130ca2c48557e84c01b1b2389c6a0b5089788f1a", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "559fcf6e7d16350f3112b2b23fa2861061e3c020", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "f855c8c4951115c2675cc50cc0e87291bcb4689f", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "f651cf72ccaf102c4c898a05ea932480b417f4a7", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,6 +15,7 @@ use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n use slice::ImmutableVector;\n+use strbuf::StrBuf;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ba329065a6eaa628a6e8d155e6ff163aac2d3ce6", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -78,8 +78,8 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n+    fn to_str_radix(&self, radix: uint) -> StrBuf {\n+        format_strbuf!(\"{}\", ::fmt::radix(*self, radix as u8))\n     }\n }\n \n@@ -94,13 +94,13 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_owned());\n-        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_owned());\n-        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_owned());\n-        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_owned());\n-        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_owned());\n-        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_owned());\n+        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_strbuf());\n+        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_strbuf());\n+        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_strbuf());\n+        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_strbuf());\n+        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_strbuf());\n+        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_strbuf());\n+        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_strbuf());\n     }\n \n     #[test]\n@@ -133,28 +133,28 @@ mod tests {\n     #[test]\n     fn test_uint_to_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n-        assert_eq!(u8_val.to_str(), \"255\".to_owned());\n+        assert_eq!(u8_val.to_str(), \"255\".to_strbuf());\n \n         u8_val += 1 as u8;\n-        assert_eq!(u8_val.to_str(), \"0\".to_owned());\n+        assert_eq!(u8_val.to_str(), \"0\".to_strbuf());\n \n         let mut u16_val: u16 = 65_535_u16;\n-        assert_eq!(u16_val.to_str(), \"65535\".to_owned());\n+        assert_eq!(u16_val.to_str(), \"65535\".to_strbuf());\n \n         u16_val += 1 as u16;\n-        assert_eq!(u16_val.to_str(), \"0\".to_owned());\n+        assert_eq!(u16_val.to_str(), \"0\".to_strbuf());\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n-        assert_eq!(u32_val.to_str(), \"4294967295\".to_owned());\n+        assert_eq!(u32_val.to_str(), \"4294967295\".to_strbuf());\n \n         u32_val += 1 as u32;\n-        assert_eq!(u32_val.to_str(), \"0\".to_owned());\n+        assert_eq!(u32_val.to_str(), \"0\".to_strbuf());\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_owned());\n+        assert_eq!(u64_val.to_str(), \"18446744073709551615\".to_strbuf());\n \n         u64_val += 1 as u64;\n-        assert_eq!(u64_val.to_str(), \"0\".to_owned());\n+        assert_eq!(u64_val.to_str(), \"0\".to_strbuf());\n     }\n \n     #[test]"}, {"sha": "349f50b8ac79e9d1483a2405f7b8e371d45b2607", "filename": "src/libstd/os.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -30,21 +30,22 @@\n \n use clone::Clone;\n use container::Container;\n-use libc;\n+use fmt;\n+use iter::Iterator;\n use libc::{c_void, c_int};\n+use libc;\n+use ops::Drop;\n use option::{Some, None, Option};\n use os;\n-use ops::Drop;\n-use result::{Err, Ok, Result};\n+use path::{Path, GenericPath};\n+use ptr::RawPtr;\n use ptr;\n-use str;\n+use result::{Err, Ok, Result};\n+use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n use str::{Str, StrSlice, StrAllocating};\n-use fmt;\n+use str;\n+use strbuf::StrBuf;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n-use path::{Path, GenericPath};\n-use iter::Iterator;\n-use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n-use ptr::RawPtr;\n use vec::Vec;\n \n #[cfg(unix)]\n@@ -108,7 +109,7 @@ pub mod win32 {\n     use vec::Vec;\n \n     pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n-        -> Option<~str> {\n+        -> Option<StrBuf> {\n \n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -174,10 +175,10 @@ fn with_env_lock<T>(f: || -> T) -> T {\n ///\n /// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n /// for details.\n-pub fn env() -> Vec<(~str,~str)> {\n+pub fn env() -> Vec<(StrBuf,StrBuf)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = str::from_utf8_lossy(k).into_owned();\n-        let v = str::from_utf8_lossy(v).into_owned();\n+        let k = str::from_utf8_lossy(k).to_strbuf();\n+        let v = str::from_utf8_lossy(v).to_strbuf();\n         (k,v)\n     }).collect()\n }\n@@ -273,8 +274,8 @@ pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n /// # Failure\n ///\n /// Fails if `n` has any interior NULs.\n-pub fn getenv(n: &str) -> Option<~str> {\n-    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v).into_owned())\n+pub fn getenv(n: &str) -> Option<StrBuf> {\n+    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v).to_strbuf())\n }\n \n #[cfg(unix)]\n@@ -302,7 +303,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n #[cfg(windows)]\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n-pub fn getenv(n: &str) -> Option<~str> {\n+pub fn getenv(n: &str) -> Option<StrBuf> {\n     unsafe {\n         with_env_lock(|| {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n@@ -432,8 +433,8 @@ pub fn pipe() -> Pipe {\n }\n \n /// Returns the proper dll filename for the given basename of a file.\n-pub fn dll_filename(base: &str) -> ~str {\n-    format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n+pub fn dll_filename(base: &str) -> StrBuf {\n+    format_strbuf!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n \n /// Optionally returns the filesystem path of the current executable which is\n@@ -688,11 +689,11 @@ pub fn errno() -> uint {\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n-pub fn error_string(errnum: uint) -> ~str {\n+pub fn error_string(errnum: uint) -> StrBuf {\n     return strerror(errnum);\n \n     #[cfg(unix)]\n-    fn strerror(errnum: uint) -> ~str {\n+    fn strerror(errnum: uint) -> StrBuf {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n@@ -732,12 +733,12 @@ pub fn error_string(errnum: uint) -> ~str {\n                 fail!(\"strerror_r failure\");\n             }\n \n-            str::raw::from_c_str(p as *c_char)\n+            str::raw::from_c_str(p as *c_char).into_strbuf()\n         }\n     }\n \n     #[cfg(windows)]\n-    fn strerror(errnum: uint) -> ~str {\n+    fn strerror(errnum: uint) -> StrBuf {\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPWSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -789,7 +790,7 @@ pub fn error_string(errnum: uint) -> ~str {\n }\n \n /// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> ~str {\n+pub fn last_os_error() -> StrBuf {\n     error_string(errno() as uint)\n }\n \n@@ -851,12 +852,14 @@ fn real_args_as_bytes() -> Vec<~[u8]> {\n }\n \n #[cfg(not(windows))]\n-fn real_args() -> Vec<~str> {\n-    real_args_as_bytes().move_iter().map(|v| str::from_utf8_lossy(v).into_owned()).collect()\n+fn real_args() -> Vec<StrBuf> {\n+    real_args_as_bytes().move_iter()\n+                        .map(|v| str::from_utf8_lossy(v).into_strbuf())\n+                        .collect()\n }\n \n #[cfg(windows)]\n-fn real_args() -> Vec<~str> {\n+fn real_args() -> Vec<StrBuf> {\n     use slice;\n     use option::Expect;\n \n@@ -910,10 +913,17 @@ extern \"system\" {\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `str::from_utf8_lossy` for details.\n-pub fn args() -> Vec<~str> {\n+#[cfg(not(test))]\n+pub fn args() -> Vec<StrBuf> {\n     real_args()\n }\n \n+#[cfg(test)]\n+#[allow(missing_doc)]\n+pub fn args() -> ::realstd::vec::Vec<::realstd::strbuf::StrBuf> {\n+    ::realstd::os::args()\n+}\n+\n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n pub fn args_as_bytes() -> Vec<~[u8]> {\n@@ -1509,54 +1519,54 @@ mod tests {\n         assert!(a.len() >= 1);\n     }\n \n-    fn make_rand_name() -> ~str {\n+    fn make_rand_name() -> StrBuf {\n         let mut rng = rand::task_rng();\n         let n = format_strbuf!(\"TEST{}\", rng.gen_ascii_str(10u).as_slice());\n         assert!(getenv(n.as_slice()).is_none());\n-        n.into_owned()\n+        n\n     }\n \n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n-        setenv(n, \"VALUE\");\n-        assert_eq!(getenv(n), option::Some(\"VALUE\".to_owned()));\n+        setenv(n.as_slice(), \"VALUE\");\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"VALUE\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_unsetenv() {\n         let n = make_rand_name();\n-        setenv(n, \"VALUE\");\n-        unsetenv(n);\n-        assert_eq!(getenv(n), option::None);\n+        setenv(n.as_slice(), \"VALUE\");\n+        unsetenv(n.as_slice());\n+        assert_eq!(getenv(n.as_slice()), option::None);\n     }\n \n     #[test]\n     #[ignore]\n     fn test_setenv_overwrite() {\n         let n = make_rand_name();\n-        setenv(n, \"1\");\n-        setenv(n, \"2\");\n-        assert_eq!(getenv(n), option::Some(\"2\".to_owned()));\n-        setenv(n, \"\");\n-        assert_eq!(getenv(n), option::Some(\"\".to_owned()));\n+        setenv(n.as_slice(), \"1\");\n+        setenv(n.as_slice(), \"2\");\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"2\".to_strbuf()));\n+        setenv(n.as_slice(), \"\");\n+        assert_eq!(getenv(n.as_slice()), option::Some(\"\".to_strbuf()));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n     // the buffer the variable is copied into is the right size\n     #[test]\n     #[ignore]\n     fn test_getenv_big() {\n-        let mut s = \"\".to_owned();\n+        let mut s = \"\".to_strbuf();\n         let mut i = 0;\n         while i < 100 {\n-            s = s + \"aaaaaaaaaa\";\n+            s.push_str(\"aaaaaaaaaa\");\n             i += 1;\n         }\n         let n = make_rand_name();\n-        setenv(n, s);\n+        setenv(n.as_slice(), s.as_slice());\n         debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(n), option::Some(s));\n+        assert_eq!(getenv(n.as_slice()), option::Some(s));\n     }\n \n     #[test]\n@@ -1589,7 +1599,7 @@ mod tests {\n         for p in e.iter() {\n             let (n, v) = (*p).clone();\n             debug!(\"{:?}\", n.clone());\n-            let v2 = getenv(n);\n+            let v2 = getenv(n.as_slice());\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n@@ -1600,23 +1610,23 @@ mod tests {\n     #[test]\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n-        let s = \"x\".repeat(10000);\n-        setenv(n, s);\n-        assert_eq!(getenv(n), Some(s));\n-        unsetenv(n);\n-        assert_eq!(getenv(n), None);\n+        let s = \"x\".repeat(10000).to_strbuf();\n+        setenv(n.as_slice(), s.as_slice());\n+        assert_eq!(getenv(n.as_slice()), Some(s));\n+        unsetenv(n.as_slice());\n+        assert_eq!(getenv(n.as_slice()), None);\n     }\n \n     #[test]\n     fn test_env_setenv() {\n         let n = make_rand_name();\n \n         let mut e = env();\n-        setenv(n, \"VALUE\");\n-        assert!(!e.contains(&(n.clone(), \"VALUE\".to_owned())));\n+        setenv(n.as_slice(), \"VALUE\");\n+        assert!(!e.contains(&(n.clone(), \"VALUE\".to_strbuf())));\n \n         e = env();\n-        assert!(e.contains(&(n, \"VALUE\".to_owned())));\n+        assert!(e.contains(&(n, \"VALUE\".to_strbuf())));\n     }\n \n     #[test]\n@@ -1641,7 +1651,9 @@ mod tests {\n         setenv(\"HOME\", \"\");\n         assert!(os::homedir().is_none());\n \n-        for s in oldhome.iter() { setenv(\"HOME\", *s) }\n+        for s in oldhome.iter() {\n+            setenv(\"HOME\", s.as_slice())\n+        }\n     }\n \n     #[test]"}, {"sha": "1bd099e5d244d1900c026fde28693c3dc9cf1b26", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -519,28 +519,12 @@ impl<'a> BytesContainer for &'a str {\n     fn is_str(_: Option<&'a str>) -> bool { true }\n }\n \n-impl BytesContainer for ~str {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(self.as_slice())\n-    }\n-    #[inline]\n-    fn is_str(_: Option<~str>) -> bool { true }\n-}\n impl BytesContainer for StrBuf {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_bytes()\n     }\n     #[inline]\n-    fn container_into_owned_bytes(self) -> Vec<u8> {\n-        self.into_bytes()\n-    }\n-    #[inline]\n     fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n         Some(self.as_slice())\n     }"}, {"sha": "8a939a928465904b8cdbcc6593046bd926cebc26", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -781,7 +781,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_owned(), \"e\".to_owned()], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n@@ -886,7 +886,7 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n-        t!(s: \"a/b/c\", [\"d\".to_owned(), \"e\".to_owned()], \"a/b/c/d/e\");\n+        t!(s: \"a/b/c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n     }"}, {"sha": "1c671b30e80d95a0b65bfb05786cd9127a9ade63", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -136,10 +136,17 @@ impl<'a> ToCStr for &'a Path {\n }\n \n impl<S: Writer> ::hash::Hash<S> for Path {\n+    #[cfg(not(test))]\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.repr.hash(state)\n     }\n+\n+    #[cfg(test)]\n+    #[inline]\n+    fn hash(&self, _: &mut S) {\n+        // No-op because the `hash` implementation will be wrong.\n+    }\n }\n \n impl BytesContainer for Path {\n@@ -589,7 +596,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect(\"\\\\\")))\n+            Some(Path::new(comps.connect(\"\\\\\").into_strbuf()))\n         }\n     }\n \n@@ -754,7 +761,10 @@ impl Path {\n                                 let mut s = StrBuf::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    *v.get_mut(0) = v.get(0).to_ascii().to_upper().to_byte();\n+                                    *v.get_mut(0) = v.get(0)\n+                                                     .to_ascii()\n+                                                     .to_upper()\n+                                                     .to_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n@@ -913,7 +923,7 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\\\{}\", repr.slice_from(7)))\n+            Path::new(format_strbuf!(r\"\\\\{}\", repr.slice_from(7)))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -1331,9 +1341,9 @@ mod tests {\n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n-        assert_eq!(path.display().to_str(), \"foo\".to_owned());\n+        assert_eq!(path.display().to_str(), \"foo\".to_strbuf());\n         let path = Path::new(b!(\"\\\\\"));\n-        assert_eq!(path.filename_display().to_str(), \"\".to_owned());\n+        assert_eq!(path.filename_display().to_str(), \"\".to_strbuf());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();\n@@ -1594,7 +1604,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_owned(), \"e\".to_owned()], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n@@ -1735,7 +1745,7 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n-        t!(s: \"a\\\\b\\\\c\", [\"d\".to_owned(), \"e\".to_owned()], \"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", [\"d\".to_strbuf(), \"e\".to_strbuf()], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n            b!(\"a\\\\b\\\\c\\\\d\\\\e\"));"}, {"sha": "8da906d85219a49ce32e833e1ace02629710ee99", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -16,21 +16,22 @@ More runtime type reflection\n \n #![allow(missing_doc)]\n \n-use mem::transmute;\n use char;\n use container::Container;\n+use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use io;\n use iter::Iterator;\n+use mem::transmute;\n use option::{Some, None, Option};\n use ptr::RawPtr;\n-use reflect;\n+use raw;\n use reflect::{MovePtr, align};\n+use reflect;\n use result::{Ok, Err};\n-use str::StrSlice;\n-use to_str::ToStr;\n use slice::Vector;\n-use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-use raw;\n+use str::{Str, StrSlice};\n+use strbuf::StrBuf;\n+use to_str::ToStr;\n use vec::Vec;\n \n macro_rules! try( ($me:expr, $e:expr) => (\n@@ -296,10 +297,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_estr_uniq(&mut self) -> bool {\n-        self.get::<~str>(|this, s| {\n-            try!(this, this.writer.write(['~' as u8]));\n-            this.write_escaped_slice(*s)\n-        })\n+        true\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n@@ -604,14 +602,14 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     }\n }\n \n-pub fn repr_to_str<T>(t: &T) -> ~str {\n+pub fn repr_to_str<T>(t: &T) -> StrBuf {\n     use str;\n     use str::StrAllocating;\n     use io;\n \n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8(result.unwrap().as_slice()).unwrap().to_owned()\n+    str::from_utf8(result.unwrap().as_slice()).unwrap().to_strbuf()\n }\n \n #[cfg(test)]\n@@ -638,8 +636,6 @@ fn test_repr() {\n     exact_test(&false, \"false\");\n     exact_test(&1.234, \"1.234f64\");\n     exact_test(&(\"hello\"), \"\\\"hello\\\"\");\n-    // FIXME What do I do about this one?\n-    exact_test(&(\"he\\u10f3llo\".to_owned()), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n     exact_test(&(box 10), \"box 10\");\n@@ -659,14 +655,6 @@ fn test_repr() {\n                \"@repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(box P{a:10, b:1.234}),\n                \"box repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(10u8, \"hello\".to_owned()),\n-               \"(10u8, ~\\\"hello\\\")\");\n-    exact_test(&(10u16, \"hello\".to_owned()),\n-               \"(10u16, ~\\\"hello\\\")\");\n-    exact_test(&(10u32, \"hello\".to_owned()),\n-               \"(10u32, ~\\\"hello\\\")\");\n-    exact_test(&(10u64, \"hello\".to_owned()),\n-               \"(10u64, ~\\\"hello\\\")\");\n \n     exact_test(&(&[1, 2]), \"&[1, 2]\");\n     exact_test(&(&mut [1, 2]), \"&mut [1, 2]\");"}, {"sha": "c9e5cae60e46c7aebc4f3916a9ef4963e88e5944", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -13,6 +13,7 @@\n use from_str::from_str;\n use option::{Some, None, Expect};\n use os;\n+use str::Str;\n \n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n@@ -25,15 +26,19 @@ static mut DEBUG_BORROW: bool = false;\n pub fn init() {\n     unsafe {\n         match os::getenv(\"RUST_MIN_STACK\") {\n-            Some(s) => match from_str(s) {\n+            Some(s) => match from_str(s.as_slice()) {\n                 Some(i) => MIN_STACK = i,\n                 None => ()\n             },\n             None => ()\n         }\n         match os::getenv(\"RUST_MAX_CACHED_STACKS\") {\n-            Some(max) => MAX_CACHED_STACKS = from_str(max).expect(\"expected positive integer in \\\n-                                                                   RUST_MAX_CACHED_STACKS\"),\n+            Some(max) => {\n+                MAX_CACHED_STACKS =\n+                    from_str(max.as_slice()).expect(\"expected positive \\\n+                                                     integer in \\\n+                                                     RUST_MAX_CACHED_STACKS\")\n+            }\n             None => ()\n         }\n         match os::getenv(\"RUST_DEBUG_BORROW\") {"}, {"sha": "aef41de925ffafa259651b735adbf5092277fc19", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -43,6 +43,7 @@ macro_rules! rtassert (\n \n macro_rules! rtabort (\n     ($($arg:tt)*) => ( {\n-        ::rt::util::abort(format!($($arg)*));\n+        use str::Str;\n+        ::rt::util::abort(format!($($arg)*).as_slice());\n     } )\n )"}, {"sha": "749f44d1c9d2c0e37837a0d64527c86b0426f8bc", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -420,11 +420,11 @@ mod test {\n \n     #[test]\n     fn tls() {\n-        local_data_key!(key: @~str)\n-        key.replace(Some(@\"data\".to_owned()));\n+        local_data_key!(key: @StrBuf)\n+        key.replace(Some(@\"data\".to_strbuf()));\n         assert_eq!(key.get().unwrap().as_slice(), \"data\");\n-        local_data_key!(key2: @~str)\n-        key2.replace(Some(@\"data\".to_owned()));\n+        local_data_key!(key2: @StrBuf)\n+        key2.replace(Some(@\"data\".to_strbuf()));\n         assert_eq!(key2.get().unwrap().as_slice(), \"data\");\n     }\n "}, {"sha": "8f2df8311969b924b2d6e28ae7e37d062d6cb77c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -71,6 +71,7 @@ use rt::backtrace;\n use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n+use strbuf::StrBuf;\n use task::TaskResult;\n \n use uw = rt::libunwind;\n@@ -353,7 +354,7 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str,\n     // required with the current scheme, and (b) we don't handle\n     // failure + OOM properly anyway (see comment in begin_unwind\n     // below).\n-    begin_unwind_inner(box fmt::format(msg), file, line)\n+    begin_unwind_inner(box fmt::format_strbuf(msg), file, line)\n }\n \n /// This is the entry point of unwinding for fail!() and assert!().\n@@ -388,7 +389,7 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n     {\n         let msg_s = match msg.as_ref::<&'static str>() {\n             Some(s) => *s,\n-            None => match msg.as_ref::<~str>() {\n+            None => match msg.as_ref::<StrBuf>() {\n                 Some(s) => s.as_slice(),\n                 None => \"Box<Any>\",\n             }"}, {"sha": "7aebb6e4796078bc81d36810dd7f5e1bf3973c7c", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -18,7 +18,7 @@ use libc;\n use option::{Some, None, Option};\n use os;\n use result::Ok;\n-use str::StrSlice;\n+use str::{Str, StrSlice};\n use unstable::running_on_valgrind;\n use slice::ImmutableVector;\n \n@@ -55,7 +55,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n         Some(nstr) => {\n-            let opt_n: Option<uint> = FromStr::from_str(nstr);\n+            let opt_n: Option<uint> = FromStr::from_str(nstr.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => rtabort!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)"}, {"sha": "ae1caa16d28adb61bacb0fcc149e6daacb5adc3f", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -1853,16 +1853,18 @@ mod tests {\n             })\n         )\n         let empty: ~[int] = box [];\n-        test_show_vec!(empty, \"[]\".to_owned());\n-        test_show_vec!(box [1], \"[1]\".to_owned());\n-        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_owned());\n-        test_show_vec!(box [box [], box [1u], box [1u, 1u]], \"[[], [1], [1, 1]]\".to_owned());\n+        test_show_vec!(empty, \"[]\".to_strbuf());\n+        test_show_vec!(box [1], \"[1]\".to_strbuf());\n+        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_strbuf());\n+        test_show_vec!(box [box [], box [1u], box [1u, 1u]],\n+                       \"[[], [1], [1, 1]]\".to_strbuf());\n \n         let empty_mut: &mut [int] = &mut[];\n-        test_show_vec!(empty_mut, \"[]\".to_owned());\n-        test_show_vec!(&mut[1], \"[1]\".to_owned());\n-        test_show_vec!(&mut[1, 2, 3], \"[1, 2, 3]\".to_owned());\n-        test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]], \"[[], [1], [1, 1]]\".to_owned());\n+        test_show_vec!(empty_mut, \"[]\".to_strbuf());\n+        test_show_vec!(&mut[1], \"[1]\".to_strbuf());\n+        test_show_vec!(&mut[1, 2, 3], \"[1, 2, 3]\".to_strbuf());\n+        test_show_vec!(&mut[&mut[], &mut[1u], &mut[1u, 1u]],\n+                       \"[[], [1], [1, 1]]\".to_strbuf());\n     }\n \n     #[test]"}, {"sha": "0b4db05545cfa5c47097cc01aeaf1c342f215cfb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -569,7 +569,9 @@ impl<'a> IntoMaybeOwned<'a> for ~str {\n \n impl<'a> IntoMaybeOwned<'a> for StrBuf {\n     #[inline]\n-    fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self.into_owned()) }\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> {\n+        Owned(self.into_owned())\n+    }\n }\n \n impl<'a> IntoMaybeOwned<'a> for &'a str {\n@@ -657,7 +659,7 @@ impl<'a, H: Writer> ::hash::Hash<H> for MaybeOwned<'a> {\n     fn hash(&self, hasher: &mut H) {\n         match *self {\n             Slice(s) => s.hash(hasher),\n-            Owned(ref s) => s.hash(hasher),\n+            Owned(ref s) => s.as_slice().hash(hasher),\n         }\n     }\n }\n@@ -1085,7 +1087,7 @@ mod tests {\n     #[test]\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n-            assert_eq!(v.concat(), s.to_str());\n+            assert_eq!(v.concat(), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n           \"no\".to_owned(), \"good\".to_owned()], \"youknowI'mnogood\");\n@@ -1097,7 +1099,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep), s.to_str());\n+            assert_eq!(v.connect(sep), s.to_str().into_owned());\n         }\n         t([\"you\".to_owned(), \"know\".to_owned(), \"I'm\".to_owned(),\n            \"no\".to_owned(), \"good\".to_owned()],\n@@ -1110,7 +1112,7 @@ mod tests {\n     #[test]\n     fn test_concat_slices() {\n         fn t(v: &[&str], s: &str) {\n-            assert_eq!(v.concat(), s.to_str());\n+            assert_eq!(v.concat(), s.to_str().into_owned());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n         let v: &[&str] = [];\n@@ -1121,7 +1123,7 @@ mod tests {\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n-            assert_eq!(v.connect(sep), s.to_str());\n+            assert_eq!(v.connect(sep), s.to_str().into_owned());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n@@ -2176,16 +2178,16 @@ mod tests {\n         let s = Slice(\"abcde\");\n         assert_eq!(s.len(), 5);\n         assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str(), \"abcde\".to_owned());\n-        assert_eq!(format!(\"{}\", s), \"abcde\".to_owned());\n+        assert_eq!(s.to_str(), \"abcde\".to_strbuf());\n+        assert_eq!(format_strbuf!(\"{}\", s), \"abcde\".to_strbuf());\n         assert!(s.lt(&Owned(\"bcdef\".to_owned())));\n         assert_eq!(Slice(\"\"), Default::default());\n \n         let o = Owned(\"abcde\".to_owned());\n         assert_eq!(o.len(), 5);\n         assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str(), \"abcde\".to_owned());\n-        assert_eq!(format!(\"{}\", o), \"abcde\".to_owned());\n+        assert_eq!(o.to_str(), \"abcde\".to_strbuf());\n+        assert_eq!(format_strbuf!(\"{}\", o), \"abcde\".to_strbuf());\n         assert!(o.lt(&Slice(\"bcdef\")));\n         assert_eq!(Owned(\"\".to_owned()), Default::default());\n "}, {"sha": "bb5b94d86faa59c639030b36193e55e65f367cd6", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -12,6 +12,7 @@\n \n use c_vec::CVec;\n use char::Char;\n+use cmp::Equiv;\n use container::{Container, Mutable};\n use fmt;\n use io::Writer;\n@@ -337,6 +338,13 @@ impl<H:Writer> ::hash::Hash<H> for StrBuf {\n     }\n }\n \n+impl<'a, S: Str> Equiv<S> for StrBuf {\n+    #[inline]\n+    fn equiv(&self, other: &S) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "314f659550d4112454ccd9361943ab45d183a8d9", "filename": "src/libstd/task.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -51,6 +51,7 @@ use str::{Str, SendStr, IntoMaybeOwned};\n #[cfg(test)] use owned::AnyOwnExt;\n #[cfg(test)] use result;\n #[cfg(test)] use str::StrAllocating;\n+#[cfg(test)] use strbuf::StrBuf;\n \n /// Indicates the manner in which a task exited.\n ///\n@@ -496,12 +497,12 @@ fn test_try_fail_message_static_str() {\n #[test]\n fn test_try_fail_message_owned_str() {\n     match try(proc() {\n-        fail!(\"owned string\".to_owned());\n+        fail!(\"owned string\".to_strbuf());\n     }) {\n         Err(e) => {\n-            type T = ~str;\n+            type T = StrBuf;\n             assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_owned());\n+            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_strbuf());\n         }\n         Ok(()) => fail!()\n     }"}, {"sha": "fbc4227e726460b76b85c7d65fb74982d574345e", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,21 +15,24 @@ The `ToStr` trait for converting to strings\n */\n \n use fmt;\n+use strbuf::StrBuf;\n \n /// A generic trait for converting a value to a string\n pub trait ToStr {\n     /// Converts the value of `self` to an owned string\n-    fn to_str(&self) -> ~str;\n+    fn to_str(&self) -> StrBuf;\n }\n \n /// Trait for converting a type to a string, consuming it in the process.\n pub trait IntoStr {\n     /// Consume and convert to a string.\n-    fn into_str(self) -> ~str;\n+    fn into_str(self) -> StrBuf;\n }\n \n impl<T: fmt::Show> ToStr for T {\n-    fn to_str(&self) -> ~str { format!(\"{}\", *self) }\n+    fn to_str(&self) -> StrBuf {\n+        format_strbuf!(\"{}\", *self)\n+    }\n }\n \n #[cfg(test)]\n@@ -39,23 +42,23 @@ mod tests {\n \n     #[test]\n     fn test_simple_types() {\n-        assert_eq!(1i.to_str(), \"1\".to_owned());\n-        assert_eq!((-1i).to_str(), \"-1\".to_owned());\n-        assert_eq!(200u.to_str(), \"200\".to_owned());\n-        assert_eq!(2u8.to_str(), \"2\".to_owned());\n-        assert_eq!(true.to_str(), \"true\".to_owned());\n-        assert_eq!(false.to_str(), \"false\".to_owned());\n-        assert_eq!(().to_str(), \"()\".to_owned());\n-        assert_eq!((\"hi\".to_owned()).to_str(), \"hi\".to_owned());\n+        assert_eq!(1i.to_str(), \"1\".to_strbuf());\n+        assert_eq!((-1i).to_str(), \"-1\".to_strbuf());\n+        assert_eq!(200u.to_str(), \"200\".to_strbuf());\n+        assert_eq!(2u8.to_str(), \"2\".to_strbuf());\n+        assert_eq!(true.to_str(), \"true\".to_strbuf());\n+        assert_eq!(false.to_str(), \"false\".to_strbuf());\n+        assert_eq!(().to_str(), \"()\".to_strbuf());\n+        assert_eq!((\"hi\".to_strbuf()).to_str(), \"hi\".to_strbuf());\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = box [];\n-        assert_eq!(x.to_str(), \"[]\".to_owned());\n-        assert_eq!((box [1]).to_str(), \"[1]\".to_owned());\n-        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_owned());\n+        assert_eq!(x.to_str(), \"[]\".to_strbuf());\n+        assert_eq!((box [1]).to_str(), \"[1]\".to_strbuf());\n+        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_strbuf());\n         assert!((box [box [], box [1], box [1, 1]]).to_str() ==\n-               \"[[], [1], [1, 1]]\".to_owned());\n+               \"[[], [1], [1, 1]]\".to_strbuf());\n     }\n }"}, {"sha": "f73ebc2255b4f4ba9b6614264464d52ecd566522", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -27,6 +27,7 @@ use path::{Path,GenericPath};\n use result::*;\n use slice::{Vector,ImmutableVector};\n use str;\n+use strbuf::StrBuf;\n use vec::Vec;\n \n pub struct DynamicLibrary { handle: *u8}\n@@ -56,7 +57,7 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open<T: ToCStr>(filename: Option<T>)\n-                        -> Result<DynamicLibrary, ~str> {\n+                        -> Result<DynamicLibrary, StrBuf> {\n         unsafe {\n             let mut filename = filename;\n             let maybe_library = dl::check_for_errors_in(|| {\n@@ -128,7 +129,7 @@ impl DynamicLibrary {\n     }\n \n     /// Access the value at the symbol of the dynamic library\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, ~str> {\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, StrBuf> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n@@ -203,10 +204,12 @@ mod test {\n pub mod dl {\n     use prelude::*;\n \n-    use c_str::ToCStr;\n+    use c_str::{CString, ToCStr};\n     use libc;\n     use ptr;\n-    use str;\n+    use result::*;\n+    use str::StrAllocating;\n+    use strbuf::StrBuf;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         filename.with_c_str(|raw_name| {\n@@ -218,7 +221,7 @@ pub mod dl {\n         dlopen(ptr::null(), Lazy as libc::c_int) as *u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, StrBuf> {\n         use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         unsafe {\n@@ -233,7 +236,9 @@ pub mod dl {\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n-                Err(str::raw::from_c_str(last_error))\n+                Err(CString::new(last_error, false).as_str()\n+                                                   .unwrap()\n+                                                   .to_strbuf())\n             };\n \n             ret\n@@ -287,7 +292,7 @@ pub mod dl {\n         handle as *u8\n     }\n \n-    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, StrBuf> {\n         unsafe {\n             SetLastError(0);\n "}, {"sha": "1776b6fbe6ec690ae2cde10eff1f6162f1776726", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -671,7 +671,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let v = vec!(\"a\".to_owned(), \"b\".to_owned());\n     /// for s in v.move_iter() {\n-    ///     // s has type ~str, not &~str\n+    ///     // s has type StrBuf, not &StrBuf\n     ///     println!(\"{}\", s);\n     /// }\n     /// ```\n@@ -1849,9 +1849,9 @@ mod tests {\n         let b: ~[u8] = FromVec::from_vec(a);\n         assert_eq!(b.as_slice(), &[]);\n \n-        let a = vec![\"one\".to_owned(), \"two\".to_owned()];\n-        let b: ~[~str] = FromVec::from_vec(a);\n-        assert_eq!(b.as_slice(), &[\"one\".to_owned(), \"two\".to_owned()]);\n+        let a = vec![\"one\".to_strbuf(), \"two\".to_strbuf()];\n+        let b: ~[StrBuf] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[\"one\".to_strbuf(), \"two\".to_strbuf()]);\n \n         struct Foo {\n             x: uint,"}, {"sha": "bc660798240e9a633dc90e2063c99c980b8fc874", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -396,7 +396,8 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n \n         if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n-                                  format!(\"duplicate meta item `{}`\", name));\n+                                  format!(\"duplicate meta item `{}`\",\n+                                          name).as_slice());\n         }\n     }\n }"}, {"sha": "c2b5804ecee39716afcb7eae964316b2a9b5eef0", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -39,7 +39,9 @@ impl fmt::Show for CrateId {\n             Some(ref version) => version.as_slice(),\n         };\n         if self.path == self.name ||\n-                self.path.as_slice().ends_with(format!(\"/{}\", self.name)) {\n+                self.path\n+                    .as_slice()\n+                    .ends_with(format!(\"/{}\", self.name).as_slice()) {\n             write!(f, \"\\\\#{}\", version)\n         } else {\n             write!(f, \"\\\\#{}:{}\", self.name, version)"}, {"sha": "aa8f397f74731ad6dbdbc7e3ba1738ca1bc38cbf", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -143,13 +143,13 @@ impl Handler {\n         let s;\n         match self.err_count.get() {\n           0u => return,\n-          1u => s = \"aborting due to previous error\".to_owned(),\n+          1u => s = \"aborting due to previous error\".to_strbuf(),\n           _  => {\n             s = format!(\"aborting due to {} previous errors\",\n-                     self.err_count.get());\n+                        self.err_count.get());\n           }\n         }\n-        self.fatal(s);\n+        self.fatal(s.as_slice());\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, Warning);\n@@ -267,9 +267,12 @@ fn print_diagnostic(dst: &mut EmitterWriter,\n         try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n \n-    try!(print_maybe_styled(dst, format!(\"{}: \", lvl.to_str()),\n+    try!(print_maybe_styled(dst,\n+                            format!(\"{}: \", lvl.to_str()).as_slice(),\n                             term::attr::ForegroundColor(lvl.color())));\n-    try!(print_maybe_styled(dst, format!(\"{}\\n\", msg), term::attr::Bold));\n+    try!(print_maybe_styled(dst,\n+                            format!(\"{}\\n\", msg).as_slice(),\n+                            term::attr::Bold));\n     Ok(())\n }\n \n@@ -495,7 +498,8 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n         };\n         try!(print_diagnostic(w, ss.as_slice(), Note,\n                               format!(\"in expansion of {}{}{}\", pre,\n-                                      ei.callee.name, post)));\n+                                      ei.callee.name,\n+                                      post).as_slice()));\n         let ss = cm.span_to_str(ei.call_site);\n         try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\"));\n         try!(print_macro_backtrace(w, cm, ei.call_site));"}, {"sha": "2fa1c13f5d7cf4613213f92363ac8c3161e24dad", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -208,7 +208,8 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // Append an input operand, with the form of (\"0\", expr)\n     // that links to an output operand.\n     for &(i, out) in read_write_operands.iter() {\n-        inputs.push((token::intern_and_get_ident(i.to_str()), out));\n+        inputs.push((token::intern_and_get_ident(i.to_str().as_slice()),\n+                                                 out));\n     }\n \n     MacExpr::new(@ast::Expr {"}, {"sha": "854f1d022198cf57a04d455e2a79b4902ed417a9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -533,7 +533,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, format!(\"{} takes no arguments\", name));\n+        cx.span_err(sp, format!(\"{} takes no arguments\", name).as_slice());\n     }\n }\n \n@@ -545,14 +545,17 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                name: &str)\n                                -> Option<StrBuf> {\n     if tts.len() != 1 {\n-        cx.span_err(sp, format!(\"{} takes 1 argument.\", name));\n+        cx.span_err(sp, format!(\"{} takes 1 argument.\", name).as_slice());\n     } else {\n         match tts[0] {\n             ast::TTTok(_, token::LIT_STR(ident))\n             | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n                 return Some(token::get_ident(ident).get().to_strbuf())\n             }\n-            _ => cx.span_err(sp, format!(\"{} requires a string.\", name)),\n+            _ => {\n+                cx.span_err(sp,\n+                            format!(\"{} requires a string.\", name).as_slice())\n+            }\n         }\n     }\n     None"}, {"sha": "314d63c2d3b2861c9b915d6f7cd682f654c5ab79", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -38,14 +38,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                         accumulator.push_char(c);\n                     }\n                     ast::LitInt(i, _) | ast::LitIntUnsuffixed(i) => {\n-                        accumulator.push_str(format!(\"{}\", i));\n+                        accumulator.push_str(format!(\"{}\", i).as_slice());\n                     }\n                     ast::LitUint(u, _) => {\n-                        accumulator.push_str(format!(\"{}\", u));\n+                        accumulator.push_str(format!(\"{}\", u).as_slice());\n                     }\n                     ast::LitNil => {}\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(format!(\"{}\", b));\n+                        accumulator.push_str(format!(\"{}\", b).as_slice());\n                     }\n                     ast::LitBinary(..) => {\n                         cx.span_err(e.span, \"cannot concatenate a binary literal\");"}, {"sha": "d90c7f37213b7181773641fd62ca8d16a9ad657c", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -25,12 +25,18 @@ pub fn expand_deriving_bound(cx: &mut ExtCtxt,\n                 \"Copy\" => \"Copy\",\n                 \"Send\" => \"Send\",\n                 \"Share\" => \"Share\",\n-                ref tname => cx.span_bug(span,\n-                                         format!(\"expected built-in trait name but found {}\",\n-                                                 *tname))\n+                ref tname => {\n+                    cx.span_bug(span,\n+                                format!(\"expected built-in trait name but \\\n+                                         found {}\",\n+                                        *tname).as_slice())\n+                }\n             }\n         },\n-        _ => return cx.span_err(span, \"unexpected value in deriving, expected a trait\")\n+        _ => {\n+            return cx.span_err(span, \"unexpected value in deriving, expected \\\n+                                      a trait\")\n+        }\n     };\n \n     let trait_def = TraitDef {"}, {"sha": "89c94891b3380875057fb3c6b575eb4397671cc3", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -66,12 +66,17 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) => cx.span_bug(trait_span,\n-                                           format!(\"non-matching enum variants in `deriving({})`\",\n-                                                  name)),\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span,\n-                                                         format!(\"static method in `deriving({})`\",\n-                                                                 name))\n+        EnumNonMatching(..) => {\n+            cx.span_bug(trait_span,\n+                        format!(\"non-matching enum variants in \\\n+                                 `deriving({})`\",\n+                                name).as_slice())\n+        }\n+        StaticEnum(..) | StaticStruct(..) => {\n+            cx.span_bug(trait_span,\n+                        format!(\"static method in `deriving({})`\",\n+                                name).as_slice())\n+        }\n     }\n \n     if all_fields.len() >= 1 && all_fields.get(0).name.is_none() {\n@@ -83,9 +88,12 @@ fn cs_clone(\n         let fields = all_fields.iter().map(|field| {\n             let ident = match field.name {\n                 Some(i) => i,\n-                None => cx.span_bug(trait_span,\n-                                    format!(\"unnamed field in normal struct in `deriving({})`\",\n-                                            name))\n+                None => {\n+                    cx.span_bug(trait_span,\n+                                format!(\"unnamed field in normal struct in \\\n+                                         `deriving({})`\",\n+                                        name).as_slice())\n+                }\n             };\n             cx.field_imm(field.span, ident, subcall(field))\n         }).collect::<Vec<_>>();"}, {"sha": "172ae8dca6279017677cfc078cdf5cc50cdbad45", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -168,7 +168,7 @@ fn decode_static_fields(cx: &mut ExtCtxt,\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n                            token::intern_and_get_ident(format!(\"_field{}\",\n-                                                               i)),\n+                                                               i).as_slice()),\n                            i)\n                 }).collect();\n "}, {"sha": "b8a3eea0014a0717536a1956afc6bccb93144089", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -154,7 +154,8 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(format!(\"_field{}\", i))\n+                        token::intern_and_get_ident(format!(\"_field{}\",\n+                                                            i).as_slice())\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));"}, {"sha": "0875daddc0f9fb3e0855bc475de3c75811272816", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -574,7 +574,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(format!(\"__arg_{}\", i));\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i).as_slice());\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -674,9 +674,13 @@ impl<'a> MethodDef<'a> {\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n         for i in range(0u, self_args.len()) {\n-            let (pat, ident_expr) = trait_.create_struct_pattern(cx, type_ident, struct_def,\n-                                                                 format!(\"__self_{}\", i),\n-                                                                 ast::MutImmutable);\n+            let (pat, ident_expr) =\n+                trait_.create_struct_pattern(cx,\n+                                             type_ident,\n+                                             struct_def,\n+                                             format!(\"__self_{}\",\n+                                                     i).as_slice(),\n+                                             ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -875,7 +879,7 @@ impl<'a> MethodDef<'a> {\n \n         } else {  // there are still matches to create\n             let current_match_str = if match_count == 0 {\n-                \"__self\".to_owned()\n+                \"__self\".to_strbuf()\n             } else {\n                 format!(\"__arg_{}\", match_count)\n             };\n@@ -895,10 +899,11 @@ impl<'a> MethodDef<'a> {\n \n                 // matching-variant match\n                 let variant = *enum_def.variants.get(index);\n-                let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n-                                                                           variant,\n-                                                                           current_match_str,\n-                                                                           ast::MutImmutable);\n+                let (pattern, idents) = trait_.create_enum_variant_pattern(\n+                    cx,\n+                    variant,\n+                    current_match_str.as_slice(),\n+                    ast::MutImmutable);\n \n                 matches_so_far.push((index, variant, idents));\n                 let arm_expr = self.build_enum_match(cx,\n@@ -926,10 +931,12 @@ impl<'a> MethodDef<'a> {\n             } else {\n                 // create an arm matching on each variant\n                 for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n-                                                                               variant,\n-                                                                               current_match_str,\n-                                                                               ast::MutImmutable);\n+                    let (pattern, idents) =\n+                        trait_.create_enum_variant_pattern(\n+                            cx,\n+                            variant,\n+                            current_match_str.as_slice(),\n+                            ast::MutImmutable);\n \n                     matches_so_far.push((index, variant, idents));\n                     let new_matching =\n@@ -1081,7 +1088,11 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `deriving`\");\n                 }\n             };\n-            let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n+            let path =\n+                cx.path_ident(sp,\n+                              cx.ident_of(format!(\"{}_{}\",\n+                                                  prefix,\n+                                                  i).as_slice()));\n             paths.push(path.clone());\n             let val = cx.expr(\n                 sp, ast::ExprParen(\n@@ -1127,7 +1138,11 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n+                    let path =\n+                        cx.path_ident(sp,\n+                                      cx.ident_of(format!(\"{}_{}\",\n+                                                          prefix,\n+                                                          i).as_slice()));\n \n                     paths.push(path.clone());\n                     let val = cx.expr("}, {"sha": "aeff36a49e60e70b0b66fa4c07a0e6b1aa62618b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -96,8 +96,10 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             \"Copy\" => expand!(bounds::expand_deriving_bound),\n \n                             ref tname => {\n-                                cx.span_err(titem.span, format!(\"unknown \\\n-                                    `deriving` trait: `{}`\", *tname));\n+                                cx.span_err(titem.span,\n+                                            format!(\"unknown `deriving` \\\n+                                                     trait: `{}`\",\n+                                                    *tname).as_slice());\n                             }\n                         };\n                     }"}, {"sha": "d1a4d2f3ee3b6c594477768b9832fd40b0ef92bb", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -53,7 +53,7 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                    cx.ident_of(\"Some\")),\n                               vec!(cx.expr_str(sp,\n                                                token::intern_and_get_ident(\n-                                          s))))\n+                                          s.as_slice()))))\n       }\n     };\n     MacExpr::new(e)\n@@ -80,7 +80,7 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         1 => {\n             token::intern_and_get_ident(format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var))\n+                                                var).as_slice())\n         }\n         2 => {\n             match expr_to_str(cx, *exprs.get(1), \"expected string literal\") {\n@@ -99,7 +99,7 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s))\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s.as_slice()))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "989d0a463c387a653ac884152bd2890062e0f8d7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -47,10 +47,9 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                 // Token-tree macros:\n                 MacInvocTT(ref pth, ref tts, _) => {\n                     if pth.segments.len() > 1u {\n-                        fld.cx.span_err(\n-                            pth.span,\n-                            format!(\"expected macro name without module \\\n-                                  separators\"));\n+                        fld.cx.span_err(pth.span,\n+                                        \"expected macro name without module \\\n+                                         separators\");\n                         // let compilation continue\n                         return DummyResult::raw_expr(e.span);\n                     }\n@@ -62,7 +61,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             fld.cx.span_err(\n                                 pth.span,\n                                 format!(\"macro undefined: '{}'\",\n-                                        extnamestr.get()));\n+                                        extnamestr.get()).as_slice());\n \n                             // let compilation continue\n                             return DummyResult::raw_expr(e.span);\n@@ -93,11 +92,10 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                 None => {\n                                     fld.cx.span_err(\n                                         pth.span,\n-                                        format!(\n-                                            \"non-expr macro in expr pos: {}\",\n-                                            extnamestr.get()\n-                                        )\n-                                    );\n+                                        format!(\"non-expr macro in expr pos: \\\n+                                                 {}\",\n+                                                extnamestr.get().as_slice()\n+                                        ).as_slice());\n                                     return DummyResult::raw_expr(e.span);\n                                 }\n                             };\n@@ -109,8 +107,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             fld.cx.span_err(\n                                 pth.span,\n                                 format!(\"'{}' is not a tt-style macro\",\n-                                        extnamestr.get())\n-                            );\n+                                        extnamestr.get()).as_slice());\n                             return DummyResult::raw_expr(e.span);\n                         }\n                     };\n@@ -384,18 +381,19 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         None => {\n             fld.cx.span_err(pth.span,\n                             format!(\"macro undefined: '{}!'\",\n-                                    extnamestr));\n+                                    extnamestr).as_slice());\n             // let compilation continue\n             return SmallVector::zero();\n         }\n \n         Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n-                fld.cx.span_err(pth.span,\n-                                format!(\"macro {}! expects no ident argument, \\\n-                                        given '{}'\",\n-                                        extnamestr,\n-                                        token::get_ident(it.ident)));\n+                fld.cx\n+                   .span_err(pth.span,\n+                             format!(\"macro {}! expects no ident argument, \\\n+                                      given '{}'\",\n+                                     extnamestr,\n+                                     token::get_ident(it.ident)).as_slice());\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n@@ -414,7 +412,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n             if it.ident.name == parse::token::special_idents::invalid.name {\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro {}! expects an ident argument\",\n-                                        extnamestr.get()));\n+                                        extnamestr.get()).as_slice());\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n@@ -432,7 +430,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         _ => {\n             fld.cx.span_err(it.span,\n                             format!(\"{}! is not legal in item position\",\n-                                    extnamestr.get()));\n+                                    extnamestr.get()).as_slice());\n             return SmallVector::zero();\n         }\n     };\n@@ -459,7 +457,7 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 None => {\n                     fld.cx.span_err(pth.span,\n                                     format!(\"expr macro in item position: {}\",\n-                                            extnamestr.get()));\n+                                            extnamestr.get()).as_slice());\n                     return SmallVector::zero();\n                 }\n             }\n@@ -532,15 +530,15 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n         // this is fatal: there are almost certainly macros we need\n         // inside this crate, so continue would spew \"macro undefined\"\n         // errors\n-        Err(err) => fld.cx.span_fatal(krate.span, err)\n+        Err(err) => fld.cx.span_fatal(krate.span, err.as_slice())\n     };\n \n     unsafe {\n         let registrar: MacroCrateRegistrationFun =\n             match lib.symbol(registrar.as_slice()) {\n                 Ok(registrar) => registrar,\n                 // again fatal if we can't register macros\n-                Err(err) => fld.cx.span_fatal(krate.span, err)\n+                Err(err) => fld.cx.span_fatal(krate.span, err.as_slice())\n             };\n         registrar(|name, extension| {\n             let extension = match extension {\n@@ -581,7 +579,9 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     let extnamestr = token::get_ident(extname);\n     let marked_after = match fld.extsbox.find(&extname.name) {\n         None => {\n-            fld.cx.span_err(pth.span, format!(\"macro undefined: '{}'\", extnamestr));\n+            fld.cx.span_err(pth.span,\n+                            format!(\"macro undefined: '{}'\",\n+                                    extnamestr).as_slice());\n             return SmallVector::zero();\n         }\n \n@@ -609,7 +609,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n                 None => {\n                     fld.cx.span_err(pth.span,\n                                     format!(\"non-stmt macro in stmt pos: {}\",\n-                                            extnamestr));\n+                                            extnamestr).as_slice());\n                     return SmallVector::zero();\n                 }\n             };\n@@ -619,7 +619,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n \n         _ => {\n             fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\",\n-                                              extnamestr));\n+                                              extnamestr).as_slice());\n             return SmallVector::zero();\n         }\n     };"}, {"sha": "ad4b798cfe5b85c66d505a16b2a8500131d09054", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -130,7 +130,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, but found `{}`\",\n-                                         p.this_token_to_str()));\n+                                         p.this_token_to_str()).as_slice());\n                     return (invocation, None);\n                 }\n             };\n@@ -141,7 +141,9 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             match names.find_equiv(&name) {\n                 None => {}\n                 Some(prev) => {\n-                    ecx.span_err(e.span, format!(\"duplicate argument named `{}`\", name));\n+                    ecx.span_err(e.span,\n+                                 format!(\"duplicate argument named `{}`\",\n+                                         name).as_slice());\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -246,13 +248,15 @@ impl<'a, 'b> Context<'a, 'b> {\n                         match arm.selector {\n                             parse::Keyword(name) => {\n                                 self.ecx.span_err(self.fmtsp,\n-                                                  format!(\"duplicate selector \\\n-                                                           `{}`\", name));\n+                                                  format!(\"duplicate \\\n+                                                           selector `{}`\",\n+                                                          name).as_slice());\n                             }\n                             parse::Literal(idx) => {\n                                 self.ecx.span_err(self.fmtsp,\n-                                                  format!(\"duplicate selector \\\n-                                                           `={}`\", idx));\n+                                                  format!(\"duplicate \\\n+                                                           selector `={}`\",\n+                                                          idx).as_slice());\n                             }\n                         }\n                     }\n@@ -267,7 +271,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     if !seen_cases.insert(arm.selector) {\n                         self.ecx.span_err(self.fmtsp,\n                                           format!(\"duplicate selector `{}`\",\n-                                               arm.selector));\n+                                                  arm.selector).as_slice());\n                     } else if arm.selector == \"\" {\n                         self.ecx.span_err(self.fmtsp,\n                                           \"empty selector in `select`\");\n@@ -286,7 +290,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 if self.args.len() <= arg {\n                     let msg = format!(\"invalid reference to argument `{}` (there \\\n                                     are {} arguments)\", arg, self.args.len());\n-                    self.ecx.span_err(self.fmtsp, msg);\n+                    self.ecx.span_err(self.fmtsp, msg.as_slice());\n                     return;\n                 }\n                 {\n@@ -306,7 +310,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, msg);\n+                        self.ecx.span_err(self.fmtsp, msg.as_slice());\n                         return;\n                     }\n                 };\n@@ -349,19 +353,19 @@ impl<'a, 'b> Context<'a, 'b> {\n                                   format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur));\n+                                          *cur).as_slice());\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur));\n+                                           *cur).as_slice());\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty));\n+                                           *ty).as_slice());\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -480,7 +484,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             }).collect();\n                         let (lr, selarg) = match arm.selector {\n                             parse::Keyword(t) => {\n-                                let p = self.rtpath(t.to_str());\n+                                let p = self.rtpath(t.to_str().as_slice());\n                                 let p = self.ecx.path_global(sp, p);\n                                 (self.rtpath(\"Keyword\"), self.ecx.expr_path(p))\n                             }\n@@ -516,7 +520,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                     ), None);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n         let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n-                                                    self.method_statics.len()));\n+                                                    self.method_statics\n+                                                        .len()).as_slice());\n         let item = self.ecx.item(sp, static_name, self.static_attrs(), st);\n         self.method_statics.push(item);\n         self.ecx.expr_ident(sp, static_name)\n@@ -662,7 +667,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 continue // error already generated\n             }\n \n-            let name = self.ecx.ident_of(format!(\"__arg{}\", i));\n+            let name = self.ecx.ident_of(format!(\"__arg{}\", i).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, name));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n             locals.push(self.format_arg(e.span, Exact(i),\n@@ -674,7 +679,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 Some(..) | None => continue\n             };\n \n-            let lname = self.ecx.ident_of(format!(\"__arg{}\", *name));\n+            let lname = self.ecx.ident_of(format!(\"__arg{}\",\n+                                                  *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n             *names.get_mut(*self.name_positions.get(name)) =\n@@ -786,8 +792,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => \"secret_lower_hex\",\n                     \"X\" => \"secret_upper_hex\",\n                     _ => {\n-                        self.ecx.span_err(sp, format!(\"unknown format trait `{}`\",\n-                                                      *tyname));\n+                        self.ecx\n+                            .span_err(sp,\n+                                      format!(\"unknown format trait `{}`\",\n+                                              *tyname).as_slice());\n                         \"dummy\"\n                     }\n                 }"}, {"sha": "52f262b052bc404958e80c0880091bf41240f841", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -111,7 +111,10 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n+            cx.span_err(sp,\n+                        format!(\"couldn't read {}: {}\",\n+                                file.display(),\n+                                e).as_slice());\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n@@ -127,7 +130,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         None => {\n-            cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n+            cx.span_err(sp,\n+                        format!(\"{} wasn't a utf-8 file\",\n+                                file.display()).as_slice());\n             return DummyResult::expr(sp);\n         }\n     }\n@@ -142,7 +147,10 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n+            cx.span_err(sp,\n+                        format!(\"couldn't read {}: {}\",\n+                                file.display(),\n+                                e).as_slice());\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "f234b0c234d16ecb8c2cd6ec53a9aa8716916244", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -52,7 +52,7 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, msg);\n+            parser.span_err(span, msg.as_slice());\n         }\n     }\n }"}, {"sha": "6d799eeae6c75bc2c8dfadb6b3cf55b834c81b91", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -89,9 +89,10 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> Rc<NamedMatch> {\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n-            r.sp_diag.span_fatal(r.cur_span,\n-                                 format!(\"unknown macro variable `{}`\",\n-                                         token::get_ident(name)));\n+            r.sp_diag\n+             .span_fatal(r.cur_span,\n+                         format!(\"unknown macro variable `{}`\",\n+                                 token::get_ident(name)).as_slice());\n         }\n     }\n }\n@@ -269,7 +270,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                         r.sp_diag.span_fatal(\n                             r.cur_span, /* blame the macro writer */\n                             format!(\"variable '{}' is still repeating at this depth\",\n-                                    token::get_ident(ident)));\n+                                    token::get_ident(ident)).as_slice());\n                     }\n                 }\n             }"}, {"sha": "6f17412fa6385733eff5e9277a286209bc676aaa", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -88,7 +88,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `\\\\#` but found `{}`\",\n-                                   token_str));\n+                                   token_str).as_slice());\n             }\n         };\n "}, {"sha": "31a67ff92f5c0fe6664a6558683089dbe363400e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -224,7 +224,9 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     let bytes = match File::open(path).read_to_end() {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            err(format!(\"couldn't read {}: {}\", path.display(), e));\n+            err(format!(\"couldn't read {}: {}\",\n+                        path.display(),\n+                        e).as_slice());\n             unreachable!()\n         }\n     };\n@@ -233,7 +235,9 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             return string_to_filemap(sess, s.to_strbuf(),\n                                      path.as_str().unwrap().to_strbuf())\n         }\n-        None => err(format!(\"{} is not UTF-8 encoded\", path.display())),\n+        None => {\n+            err(format!(\"{} is not UTF-8 encoded\", path.display()).as_slice())\n+        }\n     }\n     unreachable!()\n }"}, {"sha": "394b68d4a72e7f4a57dc2ee83b3065f121c7929a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -158,10 +158,14 @@ impl<'a> ParserObsoleteMethods for Parser<'a> {\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str) {\n-        self.span_err(sp, format!(\"obsolete syntax: {}\", kind_str));\n+        self.span_err(sp,\n+                      format!(\"obsolete syntax: {}\", kind_str).as_slice());\n \n         if !self.obsolete_set.contains(&kind) {\n-            self.sess.span_diagnostic.handler().note(format!(\"{}\", desc));\n+            self.sess\n+                .span_diagnostic\n+                .handler()\n+                .note(format!(\"{}\", desc).as_slice());\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "6bddb45201c110ffee6d716ecfe995ca78446ab9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 76, "deletions": 51, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -371,12 +371,12 @@ impl<'a> Parser<'a> {\n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n         let token_str = Parser::token_to_str(t);\n         self.span_fatal(self.last_span, format!(\"unexpected token: `{}`\",\n-                                                token_str));\n+                                                token_str).as_slice());\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n         let this_token = self.this_token_to_str();\n-        self.fatal(format!(\"unexpected token: `{}`\", this_token));\n+        self.fatal(format!(\"unexpected token: `{}`\", this_token).as_slice());\n     }\n \n     // expect and consume the token t. Signal an error if\n@@ -389,7 +389,7 @@ impl<'a> Parser<'a> {\n             let this_token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `{}` but found `{}`\",\n                                token_str,\n-                               this_token_str))\n+                               this_token_str).as_slice())\n         }\n     }\n \n@@ -420,11 +420,15 @@ impl<'a> Parser<'a> {\n             let expect = tokens_to_str(expected.as_slice());\n             let actual = self.this_token_to_str();\n             self.fatal(\n-                if expected.len() != 1 {\n-                    format!(\"expected one of `{}` but found `{}`\", expect, actual)\n+                (if expected.len() != 1 {\n+                    (format!(\"expected one of `{}` but found `{}`\",\n+                             expect,\n+                             actual))\n                 } else {\n-                    format!(\"expected `{}` but found `{}`\", expect, actual)\n-                }\n+                    (format!(\"expected `{}` but found `{}`\",\n+                             expect,\n+                             actual))\n+                }).as_slice()\n             )\n         }\n     }\n@@ -501,7 +505,8 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_str();\n-                self.fatal(format!( \"expected ident, found `{}`\", token_str))\n+                self.fatal((format!(\"expected ident, found `{}`\",\n+                                    token_str)).as_slice())\n             }\n         }\n     }\n@@ -545,7 +550,7 @@ impl<'a> Parser<'a> {\n             let id_interned_str = token::get_ident(kw.to_ident());\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str, token_str))\n+                               id_interned_str, token_str).as_slice())\n         }\n     }\n \n@@ -554,15 +559,17 @@ impl<'a> Parser<'a> {\n         if token::is_strict_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n             self.span_err(self.span,\n-                          format!(\"found `{}` in ident position\", token_str));\n+                          format!(\"found `{}` in ident position\",\n+                                  token_str).as_slice());\n         }\n     }\n \n     // signal an error if the current token is a reserved keyword\n     pub fn check_reserved_keywords(&mut self) {\n         if token::is_reserved_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n-            self.fatal(format!(\"`{}` is a reserved keyword\", token_str))\n+            self.fatal(format!(\"`{}` is a reserved keyword\",\n+                               token_str).as_slice())\n         }\n     }\n \n@@ -581,7 +588,7 @@ impl<'a> Parser<'a> {\n                     Parser::token_to_str(&token::BINOP(token::AND));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n-                                   token_str))\n+                                   token_str).as_slice())\n             }\n         }\n     }\n@@ -600,7 +607,8 @@ impl<'a> Parser<'a> {\n                 let token_str =\n                     Parser::token_to_str(&token::BINOP(token::OR));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n-                                   token_str, found_token))\n+                                   token_str,\n+                                   found_token).as_slice())\n             }\n         }\n     }\n@@ -650,7 +658,8 @@ impl<'a> Parser<'a> {\n             let found_token = self.this_token_to_str();\n             let token_str = Parser::token_to_str(&token::LT);\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               token_str, found_token))\n+                               token_str,\n+                               found_token).as_slice())\n         }\n     }\n \n@@ -690,7 +699,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n-                                   this_token_str))\n+                                   this_token_str).as_slice())\n             }\n         }\n     }\n@@ -1186,8 +1195,8 @@ impl<'a> Parser<'a> {\n \n               _ => {\n                   let token_str = p.this_token_to_str();\n-                  p.fatal(format!(\"expected `;` or `\\\\{` but found `{}`\",\n-                                  token_str))\n+                  p.fatal((format!(\"expected `;` or `\\\\{` but found `{}`\",\n+                                   token_str)).as_slice())\n               }\n             }\n         })\n@@ -1359,7 +1368,7 @@ impl<'a> Parser<'a> {\n             TyInfer\n         } else {\n             let msg = format!(\"expected type, found token {:?}\", self.token);\n-            self.fatal(msg);\n+            self.fatal(msg.as_slice());\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1631,7 +1640,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             _ => {\n-                self.fatal(format!(\"expected a lifetime name\"));\n+                self.fatal(format!(\"expected a lifetime name\").as_slice());\n             }\n         }\n     }\n@@ -1667,7 +1676,7 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n                                       name, got: {:?}\",\n                                       self.token);\n-                    self.fatal(msg);\n+                    self.fatal(msg.as_slice());\n                 }\n             }\n         }\n@@ -2122,7 +2131,7 @@ impl<'a> Parser<'a> {\n                   };\n                   let token_str = p.this_token_to_str();\n                   p.fatal(format!(\"incorrect close delimiter: `{}`\",\n-                                  token_str))\n+                                  token_str).as_slice())\n               },\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if p.quote_depth > 0u => {\n@@ -2773,7 +2782,7 @@ impl<'a> Parser<'a> {\n                 if self.token != token::RBRACE {\n                     let token_str = self.this_token_to_str();\n                     self.fatal(format!(\"expected `\\\\}`, found `{}`\",\n-                                       token_str))\n+                                       token_str).as_slice())\n                 }\n                 etc = true;\n                 break;\n@@ -2793,7 +2802,8 @@ impl<'a> Parser<'a> {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_str();\n-                        self.fatal(format!(\"unexpected `{}`\", token_str))\n+                        self.fatal(format!(\"unexpected `{}`\",\n+                                           token_str).as_slice())\n                     }\n                     _ => {}\n                 }\n@@ -3202,7 +3212,8 @@ impl<'a> Parser<'a> {\n                     };\n                     let tok_str = self.this_token_to_str();\n                     self.fatal(format!(\"expected {}`(` or `\\\\{`, but found `{}`\",\n-                                       ident_str, tok_str))\n+                                       ident_str,\n+                                       tok_str).as_slice())\n                 }\n             };\n \n@@ -3606,7 +3617,8 @@ impl<'a> Parser<'a> {\n     fn expect_self_ident(&mut self) {\n         if !self.is_self_ident() {\n             let token_str = self.this_token_to_str();\n-            self.fatal(format!(\"expected `self` but found `{}`\", token_str))\n+            self.fatal(format!(\"expected `self` but found `{}`\",\n+                               token_str).as_slice())\n         }\n         self.bump();\n     }\n@@ -3738,7 +3750,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     let token_str = self.this_token_to_str();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str))\n+                                       token_str).as_slice())\n                 }\n             }\n         } else {\n@@ -4005,8 +4017,9 @@ impl<'a> Parser<'a> {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n-                self.fatal(format!(\"unit-like struct definition should be written as `struct {};`\",\n-                                   token::get_ident(class_name)));\n+                self.fatal(format!(\"unit-like struct definition should be \\\n+                                    written as `struct {};`\",\n+                                   token::get_ident(class_name)).as_slice());\n             }\n             self.bump();\n         } else if self.token == token::LPAREN {\n@@ -4036,7 +4049,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `\\\\{`, `(`, or `;` after struct \\\n                                 name but found `{}`\",\n-                               token_str))\n+                               token_str).as_slice())\n         }\n \n         let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n@@ -4066,7 +4079,7 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_to_str();\n                 self.span_fatal(self.span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n-                                        token_str))\n+                                        token_str).as_slice())\n             }\n         }\n         a_var\n@@ -4147,7 +4160,7 @@ impl<'a> Parser<'a> {\n               _ => {\n                   let token_str = self.this_token_to_str();\n                   self.fatal(format!(\"expected item but found `{}`\",\n-                                     token_str))\n+                                     token_str).as_slice())\n               }\n             }\n         }\n@@ -4260,12 +4273,19 @@ impl<'a> Parser<'a> {\n                     (true, false) => (default_path, false),\n                     (false, true) => (secondary_path, true),\n                     (false, false) => {\n-                        self.span_fatal(id_sp, format!(\"file not found for module `{}`\", mod_name));\n+                        self.span_fatal(id_sp,\n+                                        format!(\"file not found for module \\\n+                                                 `{}`\",\n+                                                 mod_name).as_slice());\n                     }\n                     (true, true) => {\n-                        self.span_fatal(id_sp,\n-                                        format!(\"file for module `{}` found at both {} and {}\",\n-                                             mod_name, default_path_str, secondary_path_str));\n+                        self.span_fatal(\n+                            id_sp,\n+                            format!(\"file for module `{}` found at both {} \\\n+                                     and {}\",\n+                                    mod_name,\n+                                    default_path_str,\n+                                    secondary_path_str).as_slice());\n                     }\n                 }\n             }\n@@ -4348,12 +4368,14 @@ impl<'a> Parser<'a> {\n         let ty = self.parse_ty(false);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::ForeignItem { ident: ident,\n-                            attrs: attrs,\n-                            node: ForeignItemStatic(ty, mutbl),\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: mk_sp(lo, hi),\n-                            vis: vis }\n+        @ast::ForeignItem {\n+            ident: ident,\n+            attrs: attrs,\n+            node: ForeignItemStatic(ty, mutbl),\n+            id: ast::DUMMY_NODE_ID,\n+            span: mk_sp(lo, hi),\n+            vis: vis,\n+        }\n     }\n \n     // parse safe/unsafe and fn\n@@ -4418,8 +4440,9 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_str();\n                 self.span_fatal(self.span,\n-                                format!(\"expected extern crate name but found `{}`\",\n-                                        token_str));\n+                                format!(\"expected extern crate name but \\\n+                                         found `{}`\",\n+                                        token_str).as_slice());\n             }\n         };\n \n@@ -4586,11 +4609,10 @@ impl<'a> Parser<'a> {\n                     None => {\n                         self.span_err(\n                             self.span,\n-                            format!(\"illegal ABI: \\\n-                                  expected one of [{}], \\\n-                                  found `{}`\",\n-                                 abi::all_names().connect(\", \"),\n-                                 the_string));\n+                            format!(\"illegal ABI: expected one of [{}], \\\n+                                     found `{}`\",\n+                                    abi::all_names().connect(\", \"),\n+                                    the_string).as_slice());\n                         None\n                     }\n                 }\n@@ -4645,7 +4667,8 @@ impl<'a> Parser<'a> {\n                    self.span_err(mk_sp(lo, self.last_span.hi),\n                                  format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n-                                          to refer to external crates.\"))\n+                                          to refer to external \\\n+                                          crates.\").as_slice())\n                 }\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n@@ -4670,7 +4693,8 @@ impl<'a> Parser<'a> {\n \n             let token_str = self.this_token_to_str();\n             self.span_fatal(self.span,\n-                            format!(\"expected `\\\\{` or `fn` but found `{}`\", token_str));\n+                            format!(\"expected `\\\\{` or `fn` but found `{}`\",\n+                                    token_str).as_slice());\n         }\n \n         let is_virtual = self.eat_keyword(keywords::Virtual);\n@@ -5076,7 +5100,8 @@ impl<'a> Parser<'a> {\n                         }\n                         ViewItemExternCrate(..) if !extern_mod_allowed => {\n                             self.span_err(view_item.span,\n-                                          \"\\\"extern crate\\\" declarations are not allowed here\");\n+                                          \"\\\"extern crate\\\" declarations are \\\n+                                           not allowed here\");\n                         }\n                         ViewItemExternCrate(..) => {}\n                     }"}, {"sha": "b334aa632706e2af6695da1d46b69de95e00362e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -135,7 +135,9 @@ pub fn buf_str(toks: Vec<Token>,\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(format!(\"{}={}\", szs.get(i), tok_str(toks.get(i).clone())));\n+        s.push_str(format!(\"{}={}\",\n+                           szs.get(i),\n+                           tok_str(toks.get(i).clone())).as_slice());\n         i += 1u;\n         i %= n;\n     }"}, {"sha": "785ab6be0dd8808650bcf1c401ab1bdbf48affdb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -623,7 +623,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abi.to_str()));\n+                try!(self.word_nbsp(nmod.abi.to_str().as_slice()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n@@ -2247,7 +2247,7 @@ impl<'a> State<'a> {\n                                               ast_util::ForceSuffix).as_slice())\n             }\n             ast::LitIntUnsuffixed(i) => {\n-                word(&mut self.s, format!(\"{}\", i))\n+                word(&mut self.s, format!(\"{}\", i).as_slice())\n             }\n             ast::LitFloat(ref f, t) => {\n                 word(&mut self.s,\n@@ -2261,8 +2261,13 @@ impl<'a> State<'a> {\n             ast::LitBinary(ref arr) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_cmnt(Inconsistent, arr.as_slice(),\n-                                        |s, u| word(&mut s.s, format!(\"{}\", *u)),\n+                try!(self.commasep_cmnt(Inconsistent,\n+                                        arr.as_slice(),\n+                                        |s, u| {\n+                                            word(&mut s.s,\n+                                                 format!(\"{}\",\n+                                                         *u).as_slice())\n+                                        },\n                                         |_| lit.span));\n                 try!(word(&mut self.s, \"]\"));\n                 self.end()\n@@ -2354,11 +2359,16 @@ impl<'a> State<'a> {\n     pub fn print_string(&mut self, st: &str,\n                         style: ast::StrStyle) -> IoResult<()> {\n         let st = match style {\n-            ast::CookedStr => format!(\"\\\"{}\\\"\", st.escape_default()),\n-            ast::RawStr(n) => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                                      delim=\"#\".repeat(n), string=st)\n+            ast::CookedStr => {\n+                (format!(\"\\\"{}\\\"\", st.escape_default()))\n+            }\n+            ast::RawStr(n) => {\n+                (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                         delim=\"#\".repeat(n),\n+                         string=st))\n+            }\n         };\n-        word(&mut self.s, st)\n+        word(&mut self.s, st.as_slice())\n     }\n \n     pub fn next_comment(&mut self) -> Option<comments::Comment> {\n@@ -2389,7 +2399,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_str())\n+                self.word_nbsp(abi.to_str().as_slice())\n             }\n             None => Ok(())\n         }\n@@ -2400,7 +2410,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_str())\n+                self.word_nbsp(abi.to_str().as_slice())\n             }\n             None => Ok(())\n         }\n@@ -2416,7 +2426,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abi.to_str()));\n+            try!(self.word_nbsp(abi.to_str().as_slice()));\n         }\n \n         word(&mut self.s, \"fn\")"}, {"sha": "7562bf2d163dc4941510fa659456e622be9ba434", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -81,9 +81,11 @@ impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n             }\n         };\n \n-        let entry = open(term);\n+        let entry = open(term.as_slice());\n         if entry.is_err() {\n-            if os::getenv(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n+            if os::getenv(\"MSYSCON\").map_or(false, |s| {\n+                    \"mintty.exe\" == s.as_slice()\n+                }) {\n                 // msys terminal\n                 return Some(TerminfoTerminal {out: out, ti: msys_terminfo(), num_colors: 8});\n             }"}, {"sha": "ac5737c46ed41d93d653de1cdb052ec58411e6ee", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -36,11 +36,11 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {\n-                Some(dirs) => for i in dirs.split(':') {\n+                Some(dirs) => for i in dirs.as_slice().split(':') {\n                     if i == \"\" {\n                         dirs_to_search.push(Path::new(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(Path::new(i.to_owned()));\n+                        dirs_to_search.push(Path::new(i.to_strbuf()));\n                     }\n                 },\n                 // Found nothing in TERMINFO_DIRS, use the default paths:"}, {"sha": "80517328c2643da57bb108789ef34e2f43cadb26", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -355,7 +355,8 @@ Test Attributes:\n                      normal test runs. Running with --ignored will run these\n                      tests. This may also be written as \\#[ignore(cfg(...))] to\n                      ignore the test on certain configurations.\",\n-             usage = getopts::usage(message, optgroups().as_slice()));\n+             usage = getopts::usage(message.as_slice(),\n+                                    optgroups().as_slice()));\n }\n \n // Parses command line arguments into test options\n@@ -568,13 +569,13 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_run_start(&mut self, len: uint) -> io::IoResult<()> {\n         self.total = len;\n         let noun = if len != 1 { \"tests\" } else { \"test\" };\n-        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun))\n+        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun).as_slice())\n     }\n \n     pub fn write_test_start(&mut self, test: &TestDesc,\n                             align: NamePadding) -> io::IoResult<()> {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.write_plain(format!(\"test {} ... \", name))\n+        self.write_plain(format!(\"test {} ... \", name).as_slice())\n     }\n \n     pub fn write_result(&mut self, result: &TestResult) -> io::IoResult<()> {\n@@ -584,11 +585,12 @@ impl<T: Writer> ConsoleTestState<T> {\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n                 try!(self.write_metric());\n-                self.write_plain(format!(\": {}\", fmt_metrics(mm)))\n+                self.write_plain(format!(\": {}\", fmt_metrics(mm)).as_slice())\n             }\n             TrBench(ref bs) => {\n                 try!(self.write_bench());\n-                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)))\n+                self.write_plain(format!(\": {}\",\n+                                         fmt_bench_samples(bs)).as_slice())\n             }\n         });\n         self.write_plain(\"\\n\")\n@@ -619,7 +621,7 @@ impl<T: Writer> ConsoleTestState<T> {\n             failures.push(f.name.to_str());\n             if stdout.len() > 0 {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n-                                  f.name.as_slice()));\n+                                          f.name.as_slice()).as_slice());\n                 let output = str::from_utf8_lossy(stdout.as_slice());\n                 fail_out.push_str(output.as_slice().replace(\"\\n\", \"\\n\\t\"));\n                 fail_out.push_str(\"\\n\");\n@@ -633,7 +635,8 @@ impl<T: Writer> ConsoleTestState<T> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         failures.as_mut_slice().sort();\n         for name in failures.iter() {\n-            try!(self.write_plain(format!(\"    {}\\n\", name.as_slice())));\n+            try!(self.write_plain(format!(\"    {}\\n\",\n+                                          name.as_slice()).as_slice()));\n         }\n         Ok(())\n     }\n@@ -651,32 +654,34 @@ impl<T: Writer> ConsoleTestState<T> {\n                 MetricAdded => {\n                     added += 1;\n                     try!(self.write_added());\n-                    try!(self.write_plain(format!(\": {}\\n\", *k)));\n+                    try!(self.write_plain(format!(\": {}\\n\", *k).as_slice()));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     try!(self.write_removed());\n-                    try!(self.write_plain(format!(\": {}\\n\", *k)));\n+                    try!(self.write_plain(format!(\": {}\\n\", *k).as_slice()));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    try!(self.write_plain(format!(\": {}\", *k)));\n+                    try!(self.write_plain(format!(\": {}\", *k).as_slice()));\n                     try!(self.write_improved());\n-                    try!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n+                    try!(self.write_plain(format!(\" by {:.2f}%\\n\",\n+                                                  pct as f64).as_slice()));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    try!(self.write_plain(format!(\": {}\", *k)));\n+                    try!(self.write_plain(format!(\": {}\", *k).as_slice()));\n                     try!(self.write_regressed());\n-                    try!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n+                    try!(self.write_plain(format!(\" by {:.2f}%\\n\",\n+                                                  pct as f64).as_slice()));\n                 }\n             }\n         }\n         try!(self.write_plain(format!(\"result of ratchet: {} metrics added, \\\n                                         {} removed, {} improved, {} regressed, \\\n                                         {} noise\\n\",\n                                        added, removed, improved, regressed,\n-                                       noise)));\n+                                       noise).as_slice()));\n         if regressed == 0 {\n             try!(self.write_plain(\"updated ratchet file\\n\"));\n         } else {\n@@ -694,13 +699,13 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => true,\n             Some(ref pth) => {\n                 try!(self.write_plain(format!(\"\\nusing metrics ratchet: {}\\n\",\n-                                        pth.display())));\n+                                              pth.display()).as_slice()));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n                         try!(self.write_plain(format!(\"with noise-tolerance \\\n                                                          forced to: {}%\\n\",\n-                                                        pct)))\n+                                                        pct).as_slice()))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n                 try!(self.write_metric_diff(&diff));\n@@ -724,7 +729,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed, self.failed, self.ignored, self.measured);\n-        try!(self.write_plain(s));\n+        try!(self.write_plain(s.as_slice()));\n         return Ok(success);\n     }\n }\n@@ -813,7 +818,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoR\n         Some(ref pth) => {\n             try!(st.metrics.save(pth));\n             try!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n-                                          pth.display())));\n+                                          pth.display()).as_slice()));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -936,7 +941,7 @@ fn get_concurrency() -> uint {\n     use std::rt;\n     match os::getenv(\"RUST_TEST_TASKS\") {\n         Some(s) => {\n-            let opt_n: Option<uint> = FromStr::from_str(s);\n+            let opt_n: Option<uint> = FromStr::from_str(s.as_slice());\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => fail!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)"}, {"sha": "e75afa04cd40d6b0194e564b07acb37dbf8d3520", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -164,10 +164,10 @@ fn encode_inner(s: &str, full_url: bool) -> StrBuf {\n                     out.push_char(ch);\n                   }\n \n-                  _ => out.push_str(format!(\"%{:X}\", ch as uint))\n+                  _ => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n                 }\n             } else {\n-                out.push_str(format!(\"%{:X}\", ch as uint));\n+                out.push_str(format!(\"%{:X}\", ch as uint).as_slice());\n             }\n           }\n         }\n@@ -292,7 +292,7 @@ fn encode_plus(s: &str) -> StrBuf {\n             out.push_char(ch);\n           }\n           ' ' => out.push_char('+'),\n-          _ => out.push_str(format!(\"%{:X}\", ch as uint))\n+          _ => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n         }\n     }\n \n@@ -319,7 +319,7 @@ pub fn encode_form_urlencoded(m: &HashMap<StrBuf, Vec<StrBuf>>) -> StrBuf {\n \n             out.push_str(format!(\"{}={}\",\n                                  key,\n-                                 encode_plus(value.as_slice())));\n+                                 encode_plus(value.as_slice())).as_slice());\n         }\n     }\n "}, {"sha": "b546935939f9fda9f11f272241f5841a5b2b4f2e", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -326,8 +326,8 @@ impl Uuid {\n         let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n         for i in range(0u, 16u) {\n             let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n-            *s.get_mut(i*2+0) = digit[0];\n-            *s.get_mut(i*2+1) = digit[1];\n+            *s.get_mut(i*2+0) = digit.as_slice()[0];\n+            *s.get_mut(i*2+1) = digit.as_slice()[1];\n         }\n         str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n     }"}, {"sha": "bbbe29cc1341121f229d37f1438f25de72ff7007", "filename": "src/test/run-fail/assert-macro-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fassert-macro-owned.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -11,5 +11,5 @@\n // error-pattern:failed at 'test-assert-owned'\n \n fn main() {\n-    assert!(false, \"test-assert-owned\".to_owned());\n+    assert!(false, \"test-assert-owned\".to_strbuf());\n }"}, {"sha": "9160b760c92d60a7e46ef7f4693593914f49466b", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let mut a = 1;\n     if 1 == 1 { a = 2; }\n-    fail!(\"woooo\".to_owned() + \"o\");\n+    fail!(format_strbuf!(\"woooo{}\", \"o\"));\n }"}, {"sha": "f160b92552504d478661cc435088a76f0e948ec9", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -22,9 +22,9 @@ fn main() {\n     let mut map = collections::HashMap::new();\n     let mut arr = Vec::new();\n     for _i in range(0u, 10u) {\n-        arr.push(@\"key stuff\".to_owned());\n+        arr.push(@\"key stuff\".to_strbuf());\n         map.insert(arr.clone(),\n-                   arr.clone().append([@\"value stuff\".to_owned()]));\n+                   arr.clone().append([@\"value stuff\".to_strbuf()]));\n         if arr.len() == 5 {\n             fail!();\n         }"}, {"sha": "5e7b9d9560e381794df09e73205090b79d22cee2", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -92,6 +92,6 @@ fn main() {\n     } else if args.len() >= 2 && args[1].as_slice() == \"double-fail\" {\n         double();\n     } else {\n-        runtest(args[0]);\n+        runtest(args[0].as_slice());\n     }\n }"}, {"sha": "636e879fe32a8283fa414bacf1f268df7ff4badd", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -46,6 +46,6 @@ fn main() {\n         info!(\"info\");\n     });\n     let s = r.read_to_str().unwrap();\n-    assert!(s.contains(\"info\"));\n-    assert!(!s.contains(\"debug\"));\n+    assert!(s.as_slice().contains(\"info\"));\n+    assert!(!s.as_slice().contains(\"debug\"));\n }"}, {"sha": "0c372deae2c12c1e364d5f7d4adf59e3e979f03e", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     // expression was never evaluated, we wound up trying to clean\n     // uninitialized memory.\n \n-    if args.len() >= 2 && args[1] == \"signal\".to_owned() {\n+    if args.len() >= 2 && args[1].as_slice() == \"signal\" {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     }"}, {"sha": "c94887f16a981cdba0ceaaec7f161d1c5905b0a9", "filename": "src/test/run-pass/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconcat.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), \"foobarbaz\".to_owned());\n-    assert_eq!(format!(concat!()), \"\".to_owned());\n+    assert_eq!(format!(concat!(\"foo\", \"bar\", \"{}\"), \"baz\"), \"foobarbaz\".to_strbuf());\n+    assert_eq!(format!(concat!()), \"\".to_strbuf());\n \n     assert_eq!(\n         concat!(1, 2i, 3u, 4f32, 4.0, 'a', true, ()),"}, {"sha": "1bcc8bbc2b7c02d4fcb1ba9461ae8ce5e2220c0e", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -41,15 +41,15 @@ impl fmt::Show for Custom {\n }\n \n pub fn main() {\n-    assert_eq!(B1.to_str(), \"B1\".to_owned());\n-    assert_eq!(B2.to_str(), \"B2\".to_owned());\n-    assert_eq!(C1(3).to_str(), \"C1(3)\".to_owned());\n-    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_owned());\n-    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_owned());\n-    assert_eq!(E.to_str(), \"E\".to_owned());\n-    assert_eq!(F(3).to_str(), \"F(3)\".to_owned());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_owned());\n-    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_owned());\n-    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_owned());\n-    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_owned());\n+    assert_eq!(B1.to_str(), \"B1\".to_strbuf());\n+    assert_eq!(B2.to_str(), \"B2\".to_strbuf());\n+    assert_eq!(C1(3).to_str(), \"C1(3)\".to_strbuf());\n+    assert_eq!(C2(B2).to_str(), \"C2(B2)\".to_strbuf());\n+    assert_eq!(D1{ a: 2 }.to_str(), \"D1 { a: 2 }\".to_strbuf());\n+    assert_eq!(E.to_str(), \"E\".to_strbuf());\n+    assert_eq!(F(3).to_str(), \"F(3)\".to_strbuf());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_strbuf());\n+    assert_eq!(G(3, 4).to_str(), \"G(3, 4)\".to_strbuf());\n+    assert_eq!(I{ a: 2, b: 4 }.to_str(), \"I { a: 2, b: 4 }\".to_strbuf());\n+    assert_eq!(J(Custom).to_str(), \"J(yay)\".to_strbuf());\n }"}, {"sha": "7254ed7d5301a930b879faca23a4cbf8b4f7cf1f", "filename": "src/test/run-pass/deriving-show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -28,7 +28,7 @@ enum Enum {\n \n macro_rules! t {\n     ($x:expr, $expected:expr) => {\n-        assert_eq!(format!(\"{}\", $x), $expected.to_owned())\n+        assert_eq!(format!(\"{}\", $x), $expected.to_strbuf())\n     }\n }\n "}, {"sha": "f028d871c20def9fa27c4522c4f1f8a00dfc3d27", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -23,8 +23,8 @@ macro_rules! check {\n                 assert_eq!(size_of::<E>(), size_of::<$t>());\n                 assert_eq!(V as $t, $v);\n                 assert_eq!(C as $t, $v);\n-                assert_eq!(format!(\"{:?}\", V), \"V\".to_owned());\n-                assert_eq!(format!(\"{:?}\", C), \"V\".to_owned());\n+                assert_eq!(format!(\"{:?}\", V), \"V\".to_strbuf());\n+                assert_eq!(format!(\"{:?}\", C), \"V\".to_strbuf());\n             }\n         }\n         $m::check();"}, {"sha": "b4bd4a8201ed5729fe733bb37c851866066c0b59", "filename": "src/test/run-pass/exec-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fexec-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fexec-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexec-env.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -13,5 +13,5 @@\n use std::os;\n \n pub fn main() {\n-    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_owned()));\n+    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_strbuf()));\n }"}, {"sha": "efe0e0de40ebc84463a91ceac589df5c28696965", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -13,7 +13,7 @@\n use s = std::num::strconv;\n use to_str = std::num::strconv::float_to_str_common;\n \n-macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_owned()) } })\n+macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_strbuf()) } })\n \n pub fn main() {\n     // Basic usage"}, {"sha": "9c9f0e82d14ac7c5b6e3c436c480e02a19d5901f", "filename": "src/test/run-pass/fixed_length_vec_glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed_length_vec_glue.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -17,5 +17,5 @@ pub fn main() {\n     let arr = [1,2,3];\n     let struc = Struc {a: 13u8, b: arr, c: 42};\n     let s = repr::repr_to_str(&struc);\n-    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_owned());\n+    assert_eq!(s, \"Struc{a: 13u8, b: [1, 2, 3], c: 42}\".to_strbuf());\n }"}, {"sha": "a033fc01df389874cc249c4c7105c21dc9c7d1a3", "filename": "src/test/run-pass/format-ref-cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fformat-ref-cell.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n     let name = RefCell::new(\"rust\");\n     let what = RefCell::new(\"rocks\");\n     let msg = format!(\"{name:?} {:?}\", &*what.borrow(), name=&*name.borrow());\n-    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_owned());\n+    assert_eq!(msg, \"&\\\"rust\\\" &\\\"rocks\\\"\".to_strbuf());\n }"}, {"sha": "ca2420bc573208ab0cbde52e580f6e3cb1ee4afc", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -222,5 +222,5 @@ fn test_order() {\n     }\n     assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n                        foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n-               \"1 2 4 5 3 6\".to_owned());\n+               \"1 2 4 5 3 6\".to_strbuf());\n }"}, {"sha": "044087ec0ca0ea31dc79030501c688c10dc68259", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -22,8 +22,8 @@ fn check_strs(actual: &str, expected: &str) -> bool {\n \n pub fn main() {\n     let mut table = HashMap::new();\n-    table.insert(\"one\".to_owned(), 1);\n-    table.insert(\"two\".to_owned(), 2);\n-    assert!(check_strs(table.to_str(), \"{one: 1, two: 2}\") ||\n-            check_strs(table.to_str(), \"{two: 2, one: 1}\"));\n+    table.insert(\"one\".to_strbuf(), 1);\n+    table.insert(\"two\".to_strbuf(), 2);\n+    assert!(check_strs(table.to_str().as_slice(), \"{one: 1, two: 2}\") ||\n+            check_strs(table.to_str().as_slice(), \"{two: 2, one: 1}\"));\n }"}, {"sha": "cc63b6223981201771aeca95fd7225767dc92cf6", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -159,7 +159,7 @@ pub fn check_strs(actual: &str, expected: &str) -> bool {\n \n fn test_ascii_art_ctor() {\n     let art = AsciiArt(3, 3, '*');\n-    assert!(check_strs(art.to_str(), \"...\\n...\\n...\"));\n+    assert!(check_strs(art.to_str().as_slice(), \"...\\n...\\n...\"));\n }\n \n \n@@ -168,15 +168,15 @@ fn test_add_pt() {\n     art.add_pt(0, 0);\n     art.add_pt(0, -10);\n     art.add_pt(1, 2);\n-    assert!(check_strs(art.to_str(), \"*..\\n...\\n.*.\"));\n+    assert!(check_strs(art.to_str().as_slice(), \"*..\\n...\\n.*.\"));\n }\n \n \n fn test_shapes() {\n     let mut art = AsciiArt(4, 4, '*');\n     art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n     art.add_point(Point {x: 2, y: 2});\n-    assert!(check_strs(art.to_str(), \"****\\n*..*\\n*.**\\n****\"));\n+    assert!(check_strs(art.to_str().as_slice(), \"****\\n*..*\\n*.**\\n****\"));\n }\n \n pub fn main() {"}, {"sha": "cdbb1fe84dc5a22f591515feb492b8c495b7bc1c", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -36,12 +36,13 @@ fn main() {\n     let blah       = \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\";\n \n     let child_name = \"child\";\n-    let child_dir  = \"process-spawn-with-unicode-params-\" + blah;\n+    let child_dir  = format_strbuf!(\"process-spawn-with-unicode-params-{}\",\n+                                    blah);\n \n     // parameters sent to child / expected to be received from parent\n     let arg = blah;\n     let cwd = my_dir.join(Path::new(child_dir.clone()));\n-    let env = (\"RUST_TEST_PROC_SPAWN_UNICODE\".to_owned(), blah.to_owned());\n+    let env = (\"RUST_TEST_PROC_SPAWN_UNICODE\".to_strbuf(), blah.to_strbuf());\n \n     // am I the parent or the child?\n     if my_args.len() == 1 {             // parent"}, {"sha": "0edb0a9670ee18f5977512ce48d1bc431218d06c", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -64,6 +64,6 @@ pub fn main() {\n         // because `inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::size());\n \n-        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u32}}\".to_owned());\n+        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u32}}\".to_strbuf());\n     }\n }"}, {"sha": "aeb6adddcac53241a9a050b659163fecfd2768ec", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -86,6 +86,6 @@ pub fn main() {\n         // because `Inner`s alignment was 4.\n         assert_eq!(mem::size_of::<Outer>(), m::m::size());\n \n-        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u64}}\".to_owned());\n+        assert_eq!(y, \"Outer{c8: 22u8, t: Inner{c64: 44u64}}\".to_strbuf());\n     }\n }"}, {"sha": "869dd3f7ff15f788ce956b1ee29f73efc737f429", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -54,18 +54,8 @@ pub fn main() {\n     assert_eq!(map.find_equiv(&(\"cde\")), Some(&c));\n     assert_eq!(map.find_equiv(&(\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&(\"abc\".to_owned())), Some(&a));\n-    assert_eq!(map.find_equiv(&(\"bcd\".to_owned())), Some(&b));\n-    assert_eq!(map.find_equiv(&(\"cde\".to_owned())), Some(&c));\n-    assert_eq!(map.find_equiv(&(\"def\".to_owned())), Some(&d));\n-\n     assert_eq!(map.find_equiv(&Slice(\"abc\")), Some(&a));\n     assert_eq!(map.find_equiv(&Slice(\"bcd\")), Some(&b));\n     assert_eq!(map.find_equiv(&Slice(\"cde\")), Some(&c));\n     assert_eq!(map.find_equiv(&Slice(\"def\")), Some(&d));\n-\n-    assert_eq!(map.find_equiv(&Owned(\"abc\".to_owned())), Some(&a));\n-    assert_eq!(map.find_equiv(&Owned(\"bcd\".to_owned())), Some(&b));\n-    assert_eq!(map.find_equiv(&Owned(\"cde\".to_owned())), Some(&c));\n-    assert_eq!(map.find_equiv(&Owned(\"def\".to_owned())), Some(&d));\n }"}, {"sha": "1989b638680c6e6f255c68221cbb96f4c29c569d", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -26,7 +26,7 @@ use std::io::process::{Command, ExitSignal, ExitStatus};\n pub fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n-    if args.len() >= 2 && args[1] == \"signal\".to_owned() {\n+    if args.len() >= 2 && args[1].as_slice() == \"signal\" {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {"}, {"sha": "700cfacb856042f7f77ec2faacd4a864f16feb03", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -22,5 +22,5 @@ pub fn main() {\n     let x = t_rec {c8: 22u8, t: a_tag(44u64)};\n     let y = format!(\"{:?}\", x);\n     println!(\"y = {}\", y);\n-    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag(44u64)}\".to_owned());\n+    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag(44u64)}\".to_strbuf());\n }"}, {"sha": "a795881cd6de24f73a3ee94adeced0bba3ef5941", "filename": "src/test/run-pass/tag-disr-val-shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-disr-val-shape.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -19,7 +19,7 @@ enum color {\n pub fn main() {\n     let act = format!(\"{:?}\", red);\n     println!(\"{}\", act);\n-    assert_eq!(\"red\".to_owned(), act);\n-    assert_eq!(\"green\".to_owned(), format!(\"{:?}\", green));\n-    assert_eq!(\"white\".to_owned(), format!(\"{:?}\", white));\n+    assert_eq!(\"red\".to_strbuf(), act);\n+    assert_eq!(\"green\".to_strbuf(), format!(\"{:?}\", green));\n+    assert_eq!(\"white\".to_strbuf(), format!(\"{:?}\", white));\n }"}, {"sha": "6116ed29e1aa89fca8eca361d971de52dcd68d04", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -63,7 +63,7 @@ iotest!(fn eventual_timeout() {\n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n     native::task::spawn(proc() {\n-        let _l = TcpListener::bind(host, port).unwrap().listen();\n+        let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();\n     });\n@@ -84,7 +84,7 @@ iotest!(fn timeout_success() {\n     let addr = next_test_ip4();\n     let host = addr.ip.to_str();\n     let port = addr.port;\n-    let _l = TcpListener::bind(host, port).unwrap().listen();\n+    let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n \n     assert!(TcpStream::connect_timeout(addr, 1000).is_ok());\n })"}, {"sha": "799d07891db0cfff2e367fd4258e74fc870bb7a8", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -64,7 +64,7 @@ fn main() {\n         builder.spawn(proc() {\n             let host = addr.ip.to_str();\n             let port = addr.port;\n-            match TcpStream::connect(host, port) {\n+            match TcpStream::connect(host.as_slice(), port) {\n                 Ok(stream) => {\n                     let mut stream = stream;\n                     stream.write([1]);"}, {"sha": "c3387a963a701d44c8e4d1f84f80394ac8160327", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -27,10 +27,10 @@ fn checktests() {\n     let tests = __test::TESTS;\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str() == \"shouldignore\".to_owned() &&\n+        tests.iter().any(|t| t.desc.name.to_str().as_slice() == \"shouldignore\" &&\n                          t.desc.ignore));\n \n     assert!(\n-        tests.iter().any(|t| t.desc.name.to_str() == \"shouldnotignore\".to_owned() &&\n+        tests.iter().any(|t| t.desc.name.to_str().as_slice() == \"shouldnotignore\" &&\n                          !t.desc.ignore));\n }"}, {"sha": "190007a7811646c32f49ed41d0393f9395ad94ea", "filename": "src/test/run-pass/vec-to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36195eb91f15975fed7555a3aa52807ecd5698a1/src%2Ftest%2Frun-pass%2Fvec-to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-to_str.rs?ref=36195eb91f15975fed7555a3aa52807ecd5698a1", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub fn main() {\n-    assert_eq!((vec!(0, 1)).to_str(), \"[0, 1]\".to_owned());\n-    assert_eq!((&[1, 2]).to_str(), \"[1, 2]\".to_owned());\n+    assert_eq!((vec!(0, 1)).to_str(), \"[0, 1]\".to_strbuf());\n+    assert_eq!((&[1, 2]).to_str(), \"[1, 2]\".to_strbuf());\n \n     let foo = vec!(3, 4);\n     let bar = &[4, 5];\n \n-    assert_eq!(foo.to_str(), \"[3, 4]\".to_owned());\n-    assert_eq!(bar.to_str(), \"[4, 5]\".to_owned());\n+    assert_eq!(foo.to_str(), \"[3, 4]\".to_strbuf());\n+    assert_eq!(bar.to_str(), \"[4, 5]\".to_strbuf());\n }"}]}