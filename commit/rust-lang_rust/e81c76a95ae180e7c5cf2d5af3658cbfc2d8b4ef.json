{"sha": "e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MWM3NmE5NWFlMTgwZTdjNWNmMmQ1YWYzNjU4Y2JmYzJkOGI0ZWY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-05-18T19:25:23Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-05-22T15:32:49Z"}, "message": "Use Chalk's built-in representations of primitive types\n\nFor references, we make sure Chalk actually gets a lifetime here.", "tree": {"sha": "5446a8b8ee524025f9f69912dabcbcff087b803e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5446a8b8ee524025f9f69912dabcbcff087b803e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef", "html_url": "https://github.com/rust-lang/rust/commit/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb71349156619e26a15ae21d7730eb9ce020446", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb71349156619e26a15ae21d7730eb9ce020446", "html_url": "https://github.com/rust-lang/rust/commit/0fb71349156619e26a15ae21d7730eb9ce020446"}], "stats": {"total": 170, "additions": 160, "deletions": 10}, "files": [{"sha": "b80b67a7a1413b1dbd6df1bcc999fbd953e0d371", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 160, "deletions": 10, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=e81c76a95ae180e7c5cf2d5af3658cbfc2d8b4ef", "patch": "@@ -5,18 +5,25 @@ use log::debug;\n \n use chalk_ir::{\n     cast::Cast, fold::shift::Shift, interner::HasInterner, GenericArg, Goal, GoalData,\n-    PlaceholderIndex, TypeName, UniverseIndex,\n+    PlaceholderIndex, Scalar, TypeName, UniverseIndex,\n };\n \n-use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n+use hir_def::{\n+    type_ref::Mutability, AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup,\n+    TypeAliasId,\n+};\n use ra_db::{\n     salsa::{InternId, InternKey},\n     CrateId,\n };\n \n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    method_resolution::TyFingerprint,\n+    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n+    utils::generics,\n     ApplicationTy, DebruijnIndex, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n@@ -330,6 +337,9 @@ impl ToChalk for Ty {\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n         match self {\n             Ty::Apply(apply_ty) => {\n+                if let TypeCtor::Ref(m) = apply_ty.ctor {\n+                    return ref_to_chalk(db, m, apply_ty.parameters);\n+                }\n                 let name = apply_ty.ctor.to_chalk(db);\n                 let substitution = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n@@ -373,6 +383,7 @@ impl ToChalk for Ty {\n         match chalk.data(&Interner).clone() {\n             chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n                 TypeName::Error => Ty::Unknown,\n+                TypeName::Ref(m) => ref_from_chalk(db, m, apply_ty.substitution),\n                 _ => {\n                     let ctor = from_chalk(db, apply_ty.name);\n                     let parameters = from_chalk(db, apply_ty.substitution);\n@@ -409,6 +420,41 @@ impl ToChalk for Ty {\n     }\n }\n \n+const LIFETIME_PLACEHOLDER: PlaceholderIndex =\n+    PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::MAX };\n+\n+/// We currently don't model lifetimes, but Chalk does. So, we have to insert a\n+/// fake lifetime here, because Chalks built-in logic may expect it to be there.\n+fn ref_to_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: Mutability,\n+    subst: Substs,\n+) -> chalk_ir::Ty<Interner> {\n+    let arg = subst[0].clone().to_chalk(db);\n+    let lifetime = LIFETIME_PLACEHOLDER.to_lifetime(&Interner);\n+    chalk_ir::ApplicationTy {\n+        name: TypeName::Ref(mutability.to_chalk(db)),\n+        substitution: chalk_ir::Substitution::from(\n+            &Interner,\n+            vec![lifetime.cast(&Interner), arg.cast(&Interner)],\n+        ),\n+    }\n+    .intern(&Interner)\n+}\n+\n+/// Here we remove the lifetime from the type we got from Chalk.\n+fn ref_from_chalk(\n+    db: &dyn HirDatabase,\n+    mutability: chalk_ir::Mutability,\n+    subst: chalk_ir::Substitution<Interner>,\n+) -> Ty {\n+    let tys = subst\n+        .iter(&Interner)\n+        .filter_map(|p| Some(from_chalk(db, p.ty(&Interner)?.clone())))\n+        .collect();\n+    Ty::apply(TypeCtor::Ref(from_chalk(db, mutability)), Substs(tys))\n+}\n+\n impl ToChalk for Substs {\n     type Chalk = chalk_ir::Substitution<Interner>;\n \n@@ -465,7 +511,31 @@ impl ToChalk for TypeCtor {\n                 let type_id = type_alias.to_chalk(db);\n                 TypeName::AssociatedType(type_id)\n             }\n-            _ => {\n+\n+            TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n+            TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n+            TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n+            }\n+            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 })) => {\n+                TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n+            }\n+\n+            TypeCtor::Tuple { cardinality } => TypeName::Tuple(cardinality.into()),\n+            TypeCtor::RawPtr(mutability) => TypeName::Raw(mutability.to_chalk(db)),\n+            TypeCtor::Slice => TypeName::Slice,\n+            TypeCtor::Ref(mutability) => TypeName::Ref(mutability.to_chalk(db)),\n+            TypeCtor::Str => TypeName::Str,\n+\n+            TypeCtor::Int(Uncertain::Unknown)\n+            | TypeCtor::Float(Uncertain::Unknown)\n+            | TypeCtor::Adt(_)\n+            | TypeCtor::Array\n+            | TypeCtor::FnDef(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Never\n+            | TypeCtor::Closure { .. } => {\n                 // other TypeCtors get interned and turned into a chalk StructId\n                 let struct_id = db.intern_type_ctor(self).into();\n                 TypeName::Adt(struct_id)\n@@ -479,12 +549,27 @@ impl ToChalk for TypeCtor {\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n             TypeName::OpaqueType(_) => unreachable!(),\n \n-            TypeName::Scalar(_) => unreachable!(),\n-            TypeName::Tuple(_) => unreachable!(),\n-            TypeName::Raw(_) => unreachable!(),\n-            TypeName::Slice => unreachable!(),\n-            TypeName::Ref(_) => unreachable!(),\n-            TypeName::Str => unreachable!(),\n+            TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n+            TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n+            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Signed,\n+                bitness: bitness_from_chalk_int(int_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+                signedness: Signedness::Unsigned,\n+                bitness: bitness_from_chalk_uint(uint_ty),\n+            })),\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 }))\n+            }\n+            TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n+                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 }))\n+            }\n+            TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n+            TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n+            TypeName::Slice => TypeCtor::Slice,\n+            TypeName::Ref(mutability) => TypeCtor::Ref(from_chalk(db, mutability)),\n+            TypeName::Str => TypeCtor::Str,\n \n             TypeName::FnDef(_) => unreachable!(),\n \n@@ -496,6 +581,71 @@ impl ToChalk for TypeCtor {\n     }\n }\n \n+fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n+    use chalk_ir::UintTy;\n+\n+    match uint_ty {\n+        UintTy::Usize => IntBitness::Xsize,\n+        UintTy::U8 => IntBitness::X8,\n+        UintTy::U16 => IntBitness::X16,\n+        UintTy::U32 => IntBitness::X32,\n+        UintTy::U64 => IntBitness::X64,\n+        UintTy::U128 => IntBitness::X128,\n+    }\n+}\n+\n+fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n+    use chalk_ir::IntTy;\n+\n+    match int_ty {\n+        IntTy::Isize => IntBitness::Xsize,\n+        IntTy::I8 => IntBitness::X8,\n+        IntTy::I16 => IntBitness::X16,\n+        IntTy::I32 => IntBitness::X32,\n+        IntTy::I64 => IntBitness::X64,\n+        IntTy::I128 => IntBitness::X128,\n+    }\n+}\n+\n+fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n+    use chalk_ir::{IntTy, UintTy};\n+\n+    match int_ty.signedness {\n+        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n+            IntBitness::Xsize => IntTy::Isize,\n+            IntBitness::X8 => IntTy::I8,\n+            IntBitness::X16 => IntTy::I16,\n+            IntBitness::X32 => IntTy::I32,\n+            IntBitness::X64 => IntTy::I64,\n+            IntBitness::X128 => IntTy::I128,\n+        }),\n+        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n+            IntBitness::Xsize => UintTy::Usize,\n+            IntBitness::X8 => UintTy::U8,\n+            IntBitness::X16 => UintTy::U16,\n+            IntBitness::X32 => UintTy::U32,\n+            IntBitness::X64 => UintTy::U64,\n+            IntBitness::X128 => UintTy::U128,\n+        }),\n+    }\n+}\n+\n+impl ToChalk for Mutability {\n+    type Chalk = chalk_ir::Mutability;\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {\n+        match self {\n+            Mutability::Shared => chalk_ir::Mutability::Not,\n+            Mutability::Mut => chalk_ir::Mutability::Mut,\n+        }\n+    }\n+    fn from_chalk(_db: &dyn HirDatabase, chalk: Self::Chalk) -> Self {\n+        match chalk {\n+            chalk_ir::Mutability::Mut => Mutability::Mut,\n+            chalk_ir::Mutability::Not => Mutability::Shared,\n+        }\n+    }\n+}\n+\n impl ToChalk for Impl {\n     type Chalk = ImplId;\n "}]}