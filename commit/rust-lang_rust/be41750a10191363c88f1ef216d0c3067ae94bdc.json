{"sha": "be41750a10191363c88f1ef216d0c3067ae94bdc", "node_id": "C_kwDOAAsO6NoAKGJlNDE3NTBhMTAxOTEzNjNjODhmMWVmMjE2ZDBjMzA2N2FlOTRiZGM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-12-20T14:42:08Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-04-18T18:59:08Z"}, "message": "Greatly improve rustdoc search", "tree": {"sha": "4f12bc7a1f97098cddd8b087c19d85c859e4de28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f12bc7a1f97098cddd8b087c19d85c859e4de28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be41750a10191363c88f1ef216d0c3067ae94bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be41750a10191363c88f1ef216d0c3067ae94bdc", "html_url": "https://github.com/rust-lang/rust/commit/be41750a10191363c88f1ef216d0c3067ae94bdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be41750a10191363c88f1ef216d0c3067ae94bdc/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "html_url": "https://github.com/rust-lang/rust/commit/6fd7e9010db6be7605241c39eab7c5078ee2d5bd"}], "stats": {"total": 996, "additions": 602, "deletions": 394}, "files": [{"sha": "026b4f911c3011e1d2be2780636c8e4616718552", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be41750a10191363c88f1ef216d0c3067ae94bdc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/be41750a10191363c88f1ef216d0c3067ae94bdc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=be41750a10191363c88f1ef216d0c3067ae94bdc", "patch": "@@ -8,10 +8,30 @@ function initSearch(searchIndex){}\n \n /**\n  * @typedef {{\n- *   raw: string,\n- *   query: string,\n- *   type: string,\n- *   id: string,\n+ *     isExact: boolean,\n+ *     name: string,\n+ *     fullPath: Array<string>,\n+ *     pathWithoutLast: Array<string>,\n+ *     pathLast: string,\n+ *     generics: Array<QueryElement>,\n+ * }}\n+ */\n+var QueryElement;\n+\n+/**\n+ * @typedef {{\n+ *     original: string,\n+ *     val: string,\n+ *     length: number,\n+ *     pos: number,\n+ *     typeFilter: number,\n+ *     elems: Array<QueryElement>,\n+ *     elemName: (string|null),\n+ *     args: Array<QueryElement>,\n+ *     returned: Array<QueryElement>,\n+ *     foundElems: number,\n+ *     id: string,\n+ *     nameSplit: (string|null),\n  * }}\n  */\n var ParsedQuery;"}, {"sha": "fa0d5d51b46633eb946808440cd3852e735c0a89", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 578, "deletions": 390, "changes": 968, "blob_url": "https://github.com/rust-lang/rust/blob/be41750a10191363c88f1ef216d0c3067ae94bdc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/be41750a10191363c88f1ef216d0c3067ae94bdc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=be41750a10191363c88f1ef216d0c3067ae94bdc", "patch": "@@ -61,15 +61,6 @@ function printTab(nb) {\n     });\n }\n \n-function removeEmptyStringsFromArray(x) {\n-    for (var i = 0, len = x.length; i < len; ++i) {\n-        if (x[i] === \"\") {\n-            x.splice(i, 1);\n-            i -= 1;\n-        }\n-    }\n-}\n-\n /**\n  * A function to compute the Levenshtein distance between two strings\n  * Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported\n@@ -168,16 +159,196 @@ window.initSearch = function(rawSearchIndex) {\n \n     /**\n      * Executes the query and returns a list of results for each results tab.\n-     * @param  {Object}        query          - The user query\n-     * @param  {Array<string>} searchWords    - The list of search words to query against\n-     * @param  {string}        [filterCrates] - Crate to search in\n-     * @return {{\n-     *   in_args: Array<?>,\n-     *   returned: Array<?>,\n-     *   others: Array<?>\n-     * }}\n+     *\n+     * @param  {string} val     - The user query\n+     * @return {ParsedQuery}    - The parsed query\n      */\n-    function execQuery(query, searchWords, filterCrates) {\n+    function parseQuery(val) {\n+        function isWhitespace(c) {\n+            return \" \\t\\n\\r\".indexOf(c) !== -1;\n+        }\n+        function isSpecialStartCharacter(c) {\n+            return \"(<\\\"\".indexOf(c) !== -1;\n+        }\n+        function isStopCharacter(c) {\n+            return isWhitespace(c) || \"),>-=\".indexOf(c) !== -1;\n+        }\n+        function getStringElem(query) {\n+            query.pos += 1;\n+            while (query.pos < query.length && query.val[query.pos] !== \"\\\"\") {\n+                if (query.val[query.pos] === \"\\\\\") {\n+                    // We ignore the next coming character.\n+                    query.pos += 1;\n+                }\n+                query.pos += 1;\n+            }\n+            // To skip the quote at the end.\n+            query.pos += 1;\n+        }\n+        function skipWhitespaces(query) {\n+            var c;\n+            while (query.pos < query.length) {\n+                c = query.val[query.pos];\n+                if (!isWhitespace(c)) {\n+                    break;\n+                }\n+                query.pos += 1;\n+            }\n+\n+        }\n+        function skipStopCharacters(query) {\n+            var c;\n+            while (query.pos < query.length) {\n+                c = query.val[query.pos];\n+                if (!isStopCharacter(c)) {\n+                    break;\n+                }\n+                query.pos += 1;\n+            }\n+        }\n+        function isPathStart(query) {\n+            var pos = query.pos;\n+            return pos + 1 < query.length && query.val[pos] === ':' && query.val[pos + 1] === ':';\n+        }\n+        function isReturnArrow(query) {\n+            var pos = query.pos;\n+            return pos + 1 < query.length && query.val[pos] === '-' && query.val[pos + 1] === '>';\n+        }\n+        function removeEmptyStringsFromArray(x) {\n+            for (var i = 0, len = x.length; i < len; ++i) {\n+                if (x[i] === \"\") {\n+                    x.splice(i, 1);\n+                    i -= 1;\n+                }\n+            }\n+        }\n+        function createQueryElement(elems, val, generics, isExact) {\n+            removeEmptyStringsFromArray(generics);\n+            if (val === '*' || (val.length === 0 && generics.length === 0)) {\n+                return;\n+            }\n+            var paths = val.split(\"::\");\n+            removeEmptyStringsFromArray(paths);\n+            // In case we only have something like `<p>`, there is no name but it remains valid.\n+            if (paths.length === 0) {\n+                paths = [\"\"];\n+            }\n+            elems.push({\n+                isExact: isExact,\n+                name: val,\n+                fullPath: paths,\n+                pathWithoutLast: paths.slice(0, paths.length - 1),\n+                pathLast: paths[paths.length - 1],\n+                generics: generics,\n+            });\n+        }\n+        function getNextElem(query, elems) {\n+            var isExact = false;\n+            var generics = [];\n+\n+            skipStopCharacters(query);\n+            var start = query.pos;\n+            var end = start;\n+            // We handle the strings on their own mostly to make code easier to follow.\n+            if (query.val[query.pos] === \"\\\"\") {\n+                isExact = true;\n+                start += 1;\n+                getStringElem(query);\n+                end = query.pos - 1;\n+                skipWhitespaces(query);\n+            } else {\n+                while (query.pos < query.length) {\n+                    var c = query.val[query.pos];\n+                    if (isStopCharacter(c) || isSpecialStartCharacter(c)) {\n+                        break;\n+                    }\n+                    // If we allow paths (\"str::string\" for example).\n+                    else if (c === \":\") {\n+                        if (!isPathStart(query)) {\n+                            break;\n+                        }\n+                        // Skip current \":\".\n+                        query.pos += 1;\n+                    }\n+                    query.pos += 1;\n+                    end = query.pos;\n+                    skipWhitespaces(query);\n+                }\n+            }\n+            if (query.pos < query.length && query.val[query.pos] === \"<\") {\n+                getItemsBefore(query, generics, \">\");\n+            }\n+            if (start >= end && generics.length === 0) {\n+                return;\n+            }\n+            createQueryElement(elems, query.val.slice(start, end), generics, isExact);\n+        }\n+        function getItemsBefore(query, elems, limit) {\n+            var c;\n+\n+            while (query.pos < query.length) {\n+                c = query.val[query.pos];\n+                if (c === limit) {\n+                    break;\n+                } else if (isSpecialStartCharacter(c) || c === \":\") {\n+                    // Something weird is going on in here. Ignoring it!\n+                    query.pos += 1;\n+                }\n+                getNextElem(query, elems);\n+            }\n+            // We skip the \"limit\".\n+            query.pos += 1;\n+        }\n+        function parseInput(query) {\n+            var c, before;\n+\n+            while (query.pos < query.length) {\n+                c = query.val[query.pos];\n+                if (isStopCharacter(c)) {\n+                    if (c === \",\") {\n+                        query.pos += 1;\n+                        continue;\n+                    } else if (c === \"-\" && isReturnArrow(query)) {\n+                        break;\n+                    }\n+                } else if (c == \"(\") {\n+                    break;\n+                } else if (c === \":\" && query.typeFilter === null && !isPathStart(query) &&\n+                           query.elems.length === 1)\n+                {\n+                    // The type filter doesn't count as an element since it's a modifier.\n+                    query.typeFilter = query.elems.pop().name;\n+                    query.pos += 1;\n+                    continue;\n+                }\n+                before = query.elems.length;\n+                getNextElem(query, query.elems);\n+                if (query.elems.length === before) {\n+                    // Nothing was added, let's check it's not because of a solo \":\"!\n+                    if (query.pos >= query.length || query.val[query.pos] !== \":\") {\n+                        break;\n+                    }\n+                    query.pos += 1;\n+                }\n+            }\n+            while (query.pos < query.length) {\n+                c = query.val[query.pos];\n+                if (query.args.length === 0 && c === \"(\") {\n+                    if (query.elemName === null && query.elems.length === 1) {\n+                        query.elemName = query.elems.pop();\n+                    }\n+                    // Check for function/method arguments.\n+                    getItemsBefore(query, query.args, \")\");\n+                } else if (isReturnArrow(query)) {\n+                    // Get returned elements.\n+                    getItemsBefore(query, query.returned, \"\");\n+                    // Nothing can come afterward!\n+                    break;\n+                } else {\n+                    query.pos += 1;\n+                }\n+            }\n+        }\n         function itemTypeFromName(typename) {\n             for (var i = 0, len = itemTypes.length; i < len; ++i) {\n                 if (itemTypes[i] === typename) {\n@@ -187,13 +358,62 @@ window.initSearch = function(rawSearchIndex) {\n             return NO_TYPE_FILTER;\n         }\n \n-        var valLower = query.query.toLowerCase(),\n-            val = valLower,\n-            typeFilter = itemTypeFromName(query.type),\n-            results = {}, results_in_args = {}, results_returned = {},\n-            split = valLower.split(\"::\");\n+        val = val.trim();\n+        var query = {\n+            original: val,\n+            val: val.toLowerCase(),\n+            length: val.length,\n+            pos: 0,\n+            typeFilter: null,\n+            elems: [],\n+            elemName: null,\n+            args: [],\n+            returned: [],\n+            foundElems: 0,\n+            // This field is used to check if it's needed to re-run a search or not.\n+            id: \"\",\n+            // This field is used in `sortResults`.\n+            nameSplit: null,\n+        };\n+        parseInput(query);\n+        query.foundElems = query.elems.length + query.args.length + query.returned.length;\n+        if (query.elemName !== null) {\n+            query.foundElems += 1;\n+        }\n+        if (query.foundElems === 0 && val.length !== 0) {\n+            // In this case, we'll simply keep whatever was entered by the user...\n+            createQueryElement(query.elems, val, [], false);\n+            query.foundElems += 1;\n+        }\n+        if (query.typeFilter !== null) {\n+            query.typeFilter = query.typeFilter.replace(/^const$/, \"constant\");\n+            query.typeFilter = itemTypeFromName(query.typeFilter);\n+        } else {\n+            query.typeFilter = NO_TYPE_FILTER;\n+        }\n+        query.id = val;\n+        // In case we only have one argument, we move it back to `elems` to keep things simple.\n+        if (query.foundElems === 1 && query.elemName !== null) {\n+            query.elems.push(query.elemName);\n+            query.elemName = null;\n+        }\n+        if (query.elemName !== null || query.elems.length === 1) {\n+            val = query.elemName || query.elems[0];\n+            query.nameSplit = typeof val.path === \"undefined\" ? null : val.path;\n+        }\n+        return query;\n+    }\n \n-        removeEmptyStringsFromArray(split);\n+    /**\n+     * Executes the query and builds an index of results\n+     * @param  {[Object]} query      [The user query]\n+     * @param  {[type]} searchWords  [The list of search words to query\n+     *                                against]\n+     * @param  {[type]} filterCrates [Crate to search in if defined]\n+     * @return {[type]}              [A search index of results]\n+     */\n+    function execQuery(queryInfo, searchWords, filterCrates) {\n+        var results_others = {}, results_in_args = {}, results_returned = {};\n \n         function transformResults(results) {\n             var duplicates = {};\n@@ -227,6 +447,8 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function sortResults(results, isType) {\n+            var nameSplit = queryInfo.nameSplit;\n+            var query = queryInfo.val;\n             var ar = [];\n             for (var entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n@@ -246,8 +468,8 @@ window.initSearch = function(rawSearchIndex) {\n                 var a, b;\n \n                 // sort by exact match with regard to the last word (mismatch goes later)\n-                a = (aaa.word !== val);\n-                b = (bbb.word !== val);\n+                a = (aaa.word !== query);\n+                b = (bbb.word !== query);\n                 if (a !== b) { return a - b; }\n \n                 // Sort by non levenshtein results and then levenshtein results by the distance\n@@ -320,77 +542,65 @@ window.initSearch = function(rawSearchIndex) {\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n-                if (!isType && !validateResult(name, path, split, parent)) {\n+                if (!isType && !validateResult(name, path, nameSplit, parent)) {\n                     result.id = -1;\n                 }\n             }\n             return transformResults(results);\n         }\n \n-        function extractGenerics(val) {\n-            val = val.toLowerCase();\n-            if (val.indexOf(\"<\") !== -1) {\n-                var values = val.substring(val.indexOf(\"<\") + 1, val.lastIndexOf(\">\"));\n-                return {\n-                    name: val.substring(0, val.indexOf(\"<\")),\n-                    generics: values.split(/\\s*,\\s*/),\n-                };\n+        /**\n+         * This function checks if the object (`obj`) generics match the given type (`val`)\n+         * generics. If there are no generics on `obj`, `defaultLev` is returned.\n+         *\n+         * @param {Object} obj         - The object to check.\n+         * @param {integer} defaultLev - This is the value to return in case there are no generics.\n+         *\n+         * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n+         */\n+        function checkGenerics(obj, val, defaultLev) {\n+            if (obj.length <= GENERICS_DATA || obj[GENERICS_DATA].length === 0) {\n+                return val.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n             }\n-            return {\n-                name: val,\n-                generics: [],\n-            };\n-        }\n-\n-        function checkGenerics(obj, val) {\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n-            var tmp_lev, elem_name;\n-            if (val.generics.length > 0) {\n-                if (obj.length > GENERICS_DATA &&\n-                      obj[GENERICS_DATA].length >= val.generics.length) {\n-                    var elems = Object.create(null);\n-                    var elength = obj[GENERICS_DATA].length;\n-                    for (var x = 0; x < elength; ++x) {\n-                        if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n-                            elems[obj[GENERICS_DATA][x][NAME]] = 0;\n-                        }\n-                        elems[obj[GENERICS_DATA][x][NAME]] += 1;\n+            var elem_name;\n+            if (val.generics.length > 0 && obj[GENERICS_DATA].length >= val.generics.length) {\n+                var elems = {};\n+                for (var x = 0, length = obj[GENERICS_DATA].length; x < length; ++x) {\n+                    elem_name = obj[GENERICS_DATA][x][NAME];\n+                    if (!elems[elem_name]) {\n+                        elems[elem_name] = 0;\n                     }\n-                    var total = 0;\n-                    var done = 0;\n-                    // We need to find the type that matches the most to remove it in order\n-                    // to move forward.\n-                    var vlength = val.generics.length;\n-                    for (x = 0; x < vlength; ++x) {\n-                        var lev = MAX_LEV_DISTANCE + 1;\n-                        var firstGeneric = val.generics[x];\n-                        var match = null;\n-                        if (elems[firstGeneric]) {\n-                            match = firstGeneric;\n-                            lev = 0;\n-                        } else {\n-                            for (elem_name in elems) {\n-                                tmp_lev = levenshtein(elem_name, firstGeneric);\n-                                if (tmp_lev < lev) {\n-                                    lev = tmp_lev;\n-                                    match = elem_name;\n-                                }\n+                    elems[elem_name] += 1;\n+                }\n+                // We need to find the type that matches the most to remove it in order\n+                // to move forward.\n+                for (x = 0, length = val.generics.length; x < length; ++x) {\n+                    var generic = val.generics[x];\n+                    var match = null;\n+                    if (elems[generic.name]) {\n+                        match = generic.name;\n+                    } else {\n+                        for (elem_name in elems) {\n+                            if (!hasOwnPropertyRustdoc(elems, elem_name)) {\n+                                continue;\n                             }\n-                        }\n-                        if (match !== null) {\n-                            elems[match] -= 1;\n-                            if (elems[match] == 0) {\n-                                delete elems[match];\n+                            if (elem_name === generic) {\n+                                match = elem_name;\n+                                break;\n                             }\n-                            total += lev;\n-                            done += 1;\n-                        } else {\n-                            return MAX_LEV_DISTANCE + 1;\n                         }\n                     }\n-                    return Math.ceil(total / done);\n+                    if (match === null) {\n+                        return MAX_LEV_DISTANCE + 1;\n+                    }\n+                    elems[match] -= 1;\n+                    if (elems[match] === 0) {\n+                        delete elems[match];\n+                    }\n                 }\n+                return 0;\n             }\n             return MAX_LEV_DISTANCE + 1;\n         }\n@@ -400,153 +610,154 @@ window.initSearch = function(rawSearchIndex) {\n           * generics (if any).\n           *\n           * @param {Object} obj\n-          * @param {string} val\n-          * @param {boolean} literalSearch\n+          * @param {Object} val\n+          *\n+          * @return {integer} - Returns a Levenshtein distance to the best match.\n+          */\n+        function checkIfInGenerics(obj, val) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n+            for (var x = 0, length = obj[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n+                lev = Math.min(\n+                    checkType(obj[GENERICS_DATA][x], val),\n+                    lev\n+                );\n+            }\n+            return lev;\n+        }\n+\n+        /**\n+          * This function checks if the object (`obj`) matches the given type (`val`) and its\n+          * generics (if any).\n+          *\n+          * @param {Object} obj\n+          * @param {Object} val\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n           *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n           */\n-        function checkType(obj, val, literalSearch) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n-            var tmp_lev = MAX_LEV_DISTANCE + 1;\n-            var len, x, firstGeneric;\n-            if (obj[NAME] === val.name) {\n-                if (literalSearch) {\n-                    if (val.generics && val.generics.length !== 0) {\n-                        if (obj.length > GENERICS_DATA &&\n-                             obj[GENERICS_DATA].length > 0) {\n-                            var elems = Object.create(null);\n-                            len = obj[GENERICS_DATA].length;\n-                            for (x = 0; x < len; ++x) {\n-                                if (!elems[obj[GENERICS_DATA][x][NAME]]) {\n-                                    elems[obj[GENERICS_DATA][x][NAME]] = 0;\n-                                }\n-                                elems[obj[GENERICS_DATA][x][NAME]] += 1;\n-                            }\n+        function checkType(obj, val) {\n+            if (val.name.length === 0 || obj[NAME].length === 0) {\n+                // This is a pure \"generic\" search, no need to run other checks.\n+                if (obj.length > GENERICS_DATA) {\n+                    return checkIfInGenerics(obj, val);\n+                }\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n \n-                            len = val.generics.length;\n-                            for (x = 0; x < len; ++x) {\n-                                firstGeneric = val.generics[x];\n-                                if (elems[firstGeneric]) {\n-                                    elems[firstGeneric] -= 1;\n-                                } else {\n-                                    // Something wasn't found and this is a literal search so\n-                                    // abort and return a \"failing\" distance.\n-                                    return MAX_LEV_DISTANCE + 1;\n-                                }\n-                            }\n-                            // Everything was found, success!\n+            var lev = levenshtein(obj[NAME], val.name);\n+            if (val.isExact) {\n+                if (lev !== 0) {\n+                    // The name didn't match, let's try to check if the generics do.\n+                    if (val.generics.length === 0) {\n+                        var checkGeneric = (obj.length > GENERICS_DATA &&\n+                            obj[GENERICS_DATA].length > 0);\n+                        if (checkGeneric && obj[GENERICS_DATA].findIndex(function(elem) {\n+                            return elem[NAME] === val.name;\n+                        }) !== -1) {\n                             return 0;\n                         }\n-                        return MAX_LEV_DISTANCE + 1;\n                     }\n-                    return 0;\n-                } else {\n-                    // If the type has generics but don't match, then it won't return at this point.\n-                    // Otherwise, `checkGenerics` will return 0 and it'll return.\n-                    if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length !== 0) {\n-                        tmp_lev = checkGenerics(obj, val);\n-                        if (tmp_lev <= MAX_LEV_DISTANCE) {\n-                            return tmp_lev;\n-                        }\n-                    }\n-                }\n-            } else if (literalSearch) {\n-                var found = false;\n-                if ((!val.generics || val.generics.length === 0) &&\n-                      obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                    found = obj[GENERICS_DATA].some(\n-                        function(gen) {\n-                            return gen[NAME] === val.name;\n-                        });\n+                    return MAX_LEV_DISTANCE + 1;\n+                } else if (val.generics.length > 0) {\n+                    return checkGenerics(obj, val, MAX_LEV_DISTANCE + 1);\n                 }\n-                return found ? 0 : MAX_LEV_DISTANCE + 1;\n-            }\n-            lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n-            if (lev_distance <= MAX_LEV_DISTANCE) {\n-                // The generics didn't match but the name kinda did so we give it\n-                // a levenshtein distance value that isn't *this* good so it goes\n-                // into the search results but not too high.\n-                lev_distance = Math.ceil((checkGenerics(obj, val) + lev_distance) / 2);\n-            }\n-            if (obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                // We can check if the type we're looking for is inside the generics!\n-                var olength = obj[GENERICS_DATA].length;\n-                for (x = 0; x < olength; ++x) {\n-                    tmp_lev = Math.min(levenshtein(obj[GENERICS_DATA][x][NAME], val.name), tmp_lev);\n-                }\n-                if (tmp_lev !== 0) {\n-                    // If we didn't find a good enough result, we go check inside the generics of\n-                    // the generics.\n-                    for (x = 0; x < olength && tmp_lev !== 0; ++x) {\n-                        tmp_lev = Math.min(\n-                            checkType(obj[GENERICS_DATA][x], val, literalSearch),\n-                            tmp_lev\n-                        );\n+                return 0;\n+            } else if (obj.length > GENERICS_DATA) {\n+                if (val.generics.length === 0) {\n+                    if (lev === 0) {\n+                        return 0;\n                     }\n+                    // The name didn't match so we now check if the type we're looking for is inside\n+                    // the generics!\n+                    lev = checkIfInGenerics(obj, val);\n+                    // Now whatever happens, the returned distance is \"less good\" so we should mark\n+                    // it as such, and so we add 0.5 to the distance to make it \"less good\".\n+                    return lev + 0.5;\n+                } else if (lev > MAX_LEV_DISTANCE) {\n+                    // So our item's name doesn't match at all and has generics.\n+                    //\n+                    // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n+                    // looking for \"B<C>\", we'll need to go down.\n+                    return checkIfInGenerics(obj, val);\n+                } else {\n+                    // At this point, the name kinda match and we have generics to check, so\n+                    // let's go!\n+                    var tmp_lev = checkGenerics(obj, val, lev);\n+                    if (tmp_lev > MAX_LEV_DISTANCE) {\n+                        return MAX_LEV_DISTANCE + 1;\n+                    }\n+                    // We compute the median value of both checks and return it.\n+                    return (tmp_lev + lev) / 2;\n                 }\n+            } else if (val.generics.length > 0) {\n+                // In this case, we were expecting generics but there isn't so we simply reject this\n+                // one.\n+                return MAX_LEV_DISTANCE + 1;\n             }\n-            // Now whatever happens, the returned distance is \"less good\" so we should mark it\n-            // as such, and so we add 1 to the distance to make it \"less good\".\n-            return Math.min(lev_distance, tmp_lev) + 1;\n+            // No generics on our query or on the target type so we can return without doing\n+            // anything else.\n+            return lev;\n         }\n \n         /**\n          * This function checks if the object (`obj`) has an argument with the given type (`val`).\n          *\n          * @param {Object} obj\n-         * @param {string} val\n-         * @param {boolean} literalSearch\n+         * @param {Object} val\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n-        function findArg(obj, val, literalSearch, typeFilter) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n+        function findArg(obj, val, typeFilter) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n+            var tmp;\n \n             if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n                 var length = obj.type[INPUTS_DATA].length;\n                 for (var i = 0; i < length; i++) {\n-                    var tmp = obj.type[INPUTS_DATA][i];\n+                    tmp = obj.type[INPUTS_DATA][i];\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    tmp = checkType(tmp, val, literalSearch);\n-                    if (tmp === 0) {\n+                    lev = Math.min(lev, checkType(tmp, val));\n+                    if (lev === 0) {\n                         return 0;\n-                    } else if (literalSearch) {\n-                        continue;\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n                 }\n             }\n-            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n+            return val.isExact ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n-        function checkReturned(obj, val, literalSearch, typeFilter) {\n-            var lev_distance = MAX_LEV_DISTANCE + 1;\n+        /**\n+         * @param {Object} obj\n+         * @param {Object} val\n+         * @param {integer} typeFilter\n+         *\n+         * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n+         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         */\n+        function checkReturned(obj, val, typeFilter) {\n+            var lev = MAX_LEV_DISTANCE + 1;\n+            var tmp;\n \n             if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n                 var ret = obj.type[OUTPUT_DATA];\n                 if (typeof ret[0] === \"string\") {\n                     ret = [ret];\n                 }\n                 for (var x = 0, len = ret.length; x < len; ++x) {\n-                    var tmp = ret[x];\n+                    tmp = ret[x];\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    tmp = checkType(tmp, val, literalSearch);\n-                    if (tmp === 0) {\n+                    lev = Math.min(lev, checkType(tmp, val));\n+                    if (lev === 0) {\n                         return 0;\n-                    } else if (literalSearch) {\n-                        continue;\n                     }\n-                    lev_distance = Math.min(tmp, lev_distance);\n                 }\n             }\n-            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n+            return val.isExact ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n         function checkPath(contains, lastElem, ty) {\n@@ -626,18 +837,18 @@ window.initSearch = function(rawSearchIndex) {\n             var aliases = [];\n             var crateAliases = [];\n             if (filterCrates !== null) {\n-                if (ALIASES[filterCrates] && ALIASES[filterCrates][query.search]) {\n-                    var query_aliases = ALIASES[filterCrates][query.search];\n+                if (ALIASES[filterCrates] && ALIASES[filterCrates][query]) {\n+                    var query_aliases = ALIASES[filterCrates][query];\n                     var len = query_aliases.length;\n                     for (var i = 0; i < len; ++i) {\n                         aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n                     }\n                 }\n             } else {\n                 Object.keys(ALIASES).forEach(function(crate) {\n-                    if (ALIASES[crate][query.search]) {\n+                    if (ALIASES[crate][query]) {\n                         var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                        var query_aliases = ALIASES[crate][query.search];\n+                        var query_aliases = ALIASES[crate][query];\n                         var len = query_aliases.length;\n                         for (var i = 0; i < len; ++i) {\n                             pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n@@ -658,7 +869,7 @@ window.initSearch = function(rawSearchIndex) {\n             aliases.sort(sortFunc);\n \n             var pushFunc = function(alias) {\n-                alias.alias = query.raw;\n+                alias.alias = query;\n                 var res = buildHrefAndPath(alias);\n                 alias.displayPath = pathSplitter(res[0]);\n                 alias.fullPath = alias.displayPath + alias.name;\n@@ -711,171 +922,187 @@ window.initSearch = function(rawSearchIndex) {\n             }\n         }\n \n-        // quoted values mean literal search\n-        var nSearchWords = searchWords.length;\n-        var i, it;\n-        var ty;\n-        var fullId;\n-        var returned;\n-        var in_args;\n-        var len;\n-        if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n-            val.charAt(val.length - 1) === val.charAt(0))\n-        {\n-            val = extractGenerics(val.substr(1, val.length - 2));\n-            for (i = 0; i < nSearchWords; ++i) {\n-                if (filterCrates !== null && searchIndex[i].crate !== filterCrates) {\n-                    continue;\n+        /**\n+         * This function is called in case the query is only one element (with or without generics).\n+         *\n+         * @param {Object} ty\n+         * @param {integer} pos     - Position in the `searchIndex`.\n+         * @param {Object} elem     - The element from the parsed query.\n+         */\n+        function handleSingleArg(ty, pos, elem) {\n+            if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n+                return;\n+            }\n+            var lev, lev_add = 0, index = -1;\n+            var fullId = ty.id;\n+\n+            var in_args = findArg(ty, elem, queryInfo.typeFilter);\n+            var returned = checkReturned(ty, elem, queryInfo.typeFilter);\n+\n+            addIntoResults(elem.isExact, results_in_args, fullId, pos, index, in_args);\n+            addIntoResults(elem.isExact, results_returned, fullId, pos, index, returned);\n+\n+            if (!typePassesFilter(queryInfo.typeFilter, ty.ty)) {\n+                return;\n+            }\n+            var searchWord = searchWords[pos];\n+\n+            if (elem.isExact) {\n+                if (searchWord === elem.name) {\n+                    addIntoResults(true, results_others, fullId, pos, -1, 0);\n                 }\n-                in_args = findArg(searchIndex[i], val, true, typeFilter);\n-                returned = checkReturned(searchIndex[i], val, true, typeFilter);\n-                ty = searchIndex[i];\n-                fullId = ty.id;\n-\n-                if (searchWords[i] === val.name\n-                    && typePassesFilter(typeFilter, searchIndex[i].ty)) {\n-                    addIntoResults(true, results, fullId, i, -1, 0);\n+                return;\n+            }\n+\n+            // No need to check anything else if it's a \"pure\" generics search.\n+            if (elem.name.length === 0) {\n+                if (ty.type !== null) {\n+                    lev = checkGenerics(ty.type, elem, MAX_LEV_DISTANCE + 1);\n+                    addIntoResults(false, results_others, fullId, pos, index, lev);\n                 }\n-                addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n-                addIntoResults(true, results_returned, fullId, i, -1, returned);\n-            }\n-            query.inputs = [val];\n-            query.output = val;\n-            query.search = val;\n-        // searching by type\n-        } else if (val.search(\"->\") > -1) {\n-            var trimmer = function(s) { return s.trim(); };\n-            var parts = val.split(\"->\").map(trimmer);\n-            var input = parts[0];\n-            // sort inputs so that order does not matter\n-            var inputs = input.split(\",\").map(trimmer).sort();\n-            for (i = 0, len = inputs.length; i < len; ++i) {\n-                inputs[i] = extractGenerics(inputs[i]);\n-            }\n-            var output = extractGenerics(parts[1]);\n-\n-            for (i = 0; i < nSearchWords; ++i) {\n-                if (filterCrates !== null && searchIndex[i].crate !== filterCrates) {\n-                    continue;\n+                return;\n+            }\n+\n+            if (elem.fullPath.length > 1) {\n+                lev = checkPath(elem.pathWithoutLast, elem.pathLast, ty);\n+                if (lev > MAX_LEV_DISTANCE || (elem.isExact && lev !== 0)) {\n+                    return;\n+                } else if (lev > 0) {\n+                    lev_add = lev / 10;\n                 }\n-                var type = searchIndex[i].type;\n-                ty = searchIndex[i];\n-                if (!type) {\n-                    continue;\n+            }\n+\n+            if (searchWord.indexOf(elem.pathLast) > -1 ||\n+                ty.normalizedName.indexOf(elem.pathLast) > -1)\n+            {\n+                // filter type: ... queries\n+                if (!results_others[fullId] !== undefined) {\n+                    index = ty.normalizedName.indexOf(elem.pathLast);\n+                }\n+            }\n+            lev = levenshtein(searchWord, elem.pathLast);\n+            lev += lev_add;\n+            if (lev > 0 && elem.pathLast.length > 3 && searchWord.indexOf(elem.pathLast) > -1)\n+            {\n+                if (elem.pathLast.length < 6) {\n+                    lev = 1;\n+                } else {\n+                    lev = 0;\n                 }\n-                fullId = ty.id;\n+            }\n+            if (lev > MAX_LEV_DISTANCE) {\n+                return;\n+            } else if (index !== -1 && elem.fullPath.length < 2) {\n+                lev -= 1;\n+            }\n+            if (lev < 0) {\n+                lev = 0;\n+            }\n+            addIntoResults(elem.isExact, results_others, fullId, pos, index, lev);\n+        }\n \n-                returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n-                if (output.name === \"*\" || returned === 0) {\n-                    in_args = false;\n-                    var is_module = false;\n+        /**\n+         * This function is called in case the query has more than one element.\n+         *\n+         * @param {Object} ty\n+         * @param {integer} pos     - Position in the `searchIndex`.\n+         * @param {Object} elem     - The element from the parsed query.\n+         */\n+        function handleArgs(ty, pos, results) {\n+            if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n+                return;\n+            }\n \n-                    if (input === \"*\") {\n-                        is_module = true;\n+            var totalLev = 0;\n+            var nbLev = 0;\n+            var lev;\n+            var i, len;\n+            var el;\n+\n+            // If the result is too \"bad\", we return false and it ends this search.\n+            function checkArgs(args, callback) {\n+                for (i = 0, len = args.length; i < len; ++i) {\n+                    el = args[i];\n+                    // There is more than one parameter to the query so all checks should be \"exact\"\n+                    el.isExact = true;\n+                    lev = callback(ty, el, NO_TYPE_FILTER);\n+                    if (lev <= 1) {\n+                        nbLev += 1;\n+                        totalLev += lev;\n                     } else {\n-                        var firstNonZeroDistance = 0;\n-                        for (it = 0, len = inputs.length; it < len; it++) {\n-                            var distance = checkType(type, inputs[it], true);\n-                            if (distance > 0) {\n-                                firstNonZeroDistance = distance;\n-                                break;\n-                            }\n-                        }\n-                        in_args = firstNonZeroDistance;\n-                    }\n-                    addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n-                    addIntoResults(true, results_returned, fullId, i, -1, returned);\n-                    if (is_module) {\n-                        addIntoResults(true, results, fullId, i, -1, 0);\n+                        return false;\n                     }\n                 }\n+                return true;\n+            }\n+            if (!checkArgs(queryInfo.elems, findArg)) {\n+                return;\n+            }\n+            if (!checkArgs(queryInfo.args, findArg)) {\n+                return;\n+            }\n+            if (!checkArgs(queryInfo.returned, checkReturned)) {\n+                return;\n             }\n-            query.inputs = inputs.map(function(input) {\n-                return input.name;\n-            });\n-            query.output = output.name;\n-        } else {\n-            query.inputs = [val];\n-            query.output = val;\n-            query.search = val;\n-            // gather matching search results up to a certain maximum\n-            val = val.replace(/_/g, \"\");\n \n-            var valGenerics = extractGenerics(val);\n+            if (nbLev === 0) {\n+                return;\n+            }\n+            lev = Math.round(totalLev / nbLev);\n+            addIntoResults(false, results, ty.id, pos, 0, lev);\n+        }\n \n-            var paths = valLower.split(\"::\");\n-            removeEmptyStringsFromArray(paths);\n-            val = paths[paths.length - 1];\n-            var contains = paths.slice(0, paths.length > 1 ? paths.length - 1 : 1);\n+        function innerRunQuery() {\n+            var elem, i, nSearchWords, in_args, in_returned, ty;\n \n-            var lev, j;\n-            for (j = 0; j < nSearchWords; ++j) {\n-                ty = searchIndex[j];\n-                if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n-                    continue;\n-                }\n-                var lev_add = 0;\n-                if (paths.length > 1) {\n-                    lev = checkPath(contains, paths[paths.length - 1], ty);\n-                    if (lev > MAX_LEV_DISTANCE) {\n-                        continue;\n-                    } else if (lev > 0) {\n-                        lev_add = lev / 10;\n+            if (queryInfo.foundElems === 1) {\n+                if (queryInfo.elems.length === 1) {\n+                    elem = queryInfo.elems[0];\n+                    for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                        // It means we want to check for this element everywhere (in names, args and\n+                        // returned).\n+                        handleSingleArg(searchIndex[i], i, elem);\n                     }\n-                }\n-\n-                returned = MAX_LEV_DISTANCE + 1;\n-                in_args = MAX_LEV_DISTANCE + 1;\n-                var index = -1;\n-                // we want lev results to go lower than others\n-                lev = MAX_LEV_DISTANCE + 1;\n-                fullId = ty.id;\n-\n-                if (searchWords[j].indexOf(split[i]) > -1 ||\n-                    searchWords[j].indexOf(val) > -1 ||\n-                    ty.normalizedName.indexOf(val) > -1)\n-                {\n-                    // filter type: ... queries\n-                    if (typePassesFilter(typeFilter, ty.ty) && results[fullId] === undefined) {\n-                        index = ty.normalizedName.indexOf(val);\n+                } else if (queryInfo.args.length === 1) {\n+                    // We received one argument to check, so looking into args.\n+                    elem = queryInfo.args[0];\n+                    for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                        ty = searchIndex[i];\n+                        in_args = findArg(ty, elem, queryInfo.typeFilter);\n+                        addIntoResults(elem.isExact, results_in_args, ty.id, i, -1, in_args);\n                     }\n-                }\n-                if ((lev = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                    if (typePassesFilter(typeFilter, ty.ty)) {\n-                        lev += 1;\n-                    } else {\n-                        lev = MAX_LEV_DISTANCE + 1;\n+                } else if (queryInfo.returned.length === 1) {\n+                    // We received one returned argument to check, so looking into returned values.\n+                    elem = queryInfo.returned[0];\n+                    for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                        ty = searchIndex[i];\n+                        in_returned = checkReturned(ty, elem, queryInfo.typeFilter);\n+                        addIntoResults(elem.isExact, results_returned, ty.id, i, -1, in_returned);\n                     }\n                 }\n-                in_args = findArg(ty, valGenerics, false, typeFilter);\n-                returned = checkReturned(ty, valGenerics, false, typeFilter);\n-\n-                lev += lev_add;\n-                if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {\n-                    if (val.length < 6) {\n-                        lev -= 1;\n-                    } else {\n-                        lev = 0;\n-                    }\n+            } else if (queryInfo.foundElems > 0) {\n+                var container = results_others;\n+                // In the special case where only a \"returned\" information is available, we want to\n+                // put the information into the \"results_returned\" dict.\n+                if (queryInfo.returned.length !== 0 && queryInfo.elemName === null &&\n+                        queryInfo.args.length === 0 && queryInfo.elems.length === 0)\n+                {\n+                    container = results_returned;\n                 }\n-                addIntoResults(false, results_in_args, fullId, j, index, in_args);\n-                addIntoResults(false, results_returned, fullId, j, index, returned);\n-                if (typePassesFilter(typeFilter, ty.ty) &&\n-                        (index !== -1 || lev <= MAX_LEV_DISTANCE)) {\n-                    if (index !== -1 && paths.length < 2) {\n-                        lev = 0;\n-                    }\n-                    addIntoResults(false, results, fullId, j, index, lev);\n+                for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n+                    handleArgs(searchIndex[i], i, container);\n                 }\n             }\n         }\n+        innerRunQuery();\n \n         var ret = {\n             \"in_args\": sortResults(results_in_args, true),\n             \"returned\": sortResults(results_returned, true),\n-            \"others\": sortResults(results, false),\n+            \"others\": sortResults(results_others, false),\n+            \"query\": queryInfo,\n         };\n-        handleAliases(ret, query, filterCrates);\n+        handleAliases(ret, queryInfo.original.replace(/\"/g, \"\").toLowerCase(), filterCrates);\n         return ret;\n     }\n \n@@ -895,6 +1122,9 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {boolean}       - Whether the result is valid or not\n      */\n     function validateResult(name, path, keys, parent) {\n+        if (!keys || !keys.length) {\n+            return true;\n+        }\n         for (var i = 0, len = keys.length; i < len; ++i) {\n             // each check is for validation so we negate the conditions and invalidate\n             if (!(\n@@ -913,30 +1143,6 @@ window.initSearch = function(rawSearchIndex) {\n         return true;\n     }\n \n-    /**\n-     * Parse a string into a query object.\n-     *\n-     * @param {string} raw - The text that the user typed.\n-     * @returns {ParsedQuery}\n-     */\n-    function getQuery(raw) {\n-        var matches, type = \"\", query;\n-        query = raw;\n-\n-        matches = query.match(/^(fn|mod|struct|enum|trait|type|const|macro)\\s*:\\s*/i);\n-        if (matches) {\n-            type = matches[1].replace(/^const$/, \"constant\");\n-            query = query.substring(matches[0].length);\n-        }\n-\n-        return {\n-            raw: raw,\n-            query: query,\n-            type: type,\n-            id: query + type\n-        };\n-    }\n-\n     function nextTab(direction) {\n         var next = (searchState.currentTab + direction + 3) % searchState.focusedByTab.length;\n         searchState.focusedByTab[searchState.currentTab] = document.activeElement;\n@@ -1092,7 +1298,7 @@ window.initSearch = function(rawSearchIndex) {\n             output.className = \"search-failed\" + extraClass;\n             output.innerHTML = \"No results :(<br/>\" +\n                 \"Try on <a href=\\\"https://duckduckgo.com/?q=\" +\n-                encodeURIComponent(\"rust \" + query.query) +\n+                encodeURIComponent(\"rust \" + query.val) +\n                 \"\\\">DuckDuckGo</a>?<br/><br/>\" +\n                 \"Or try looking in one of these:<ul><li>The <a \" +\n                 \"href=\\\"https://doc.rust-lang.org/reference/index.html\\\">Rust Reference</a> \" +\n@@ -1132,13 +1338,15 @@ window.initSearch = function(rawSearchIndex) {\n             elem.click();\n             return;\n         }\n-        var query = getQuery(searchState.input.value);\n+        if (results.query === undefined) {\n+            results.query = parseQuery(searchState.input.value);\n+        }\n \n-        currentResults = query.id;\n+        currentResults = results.query.id;\n \n-        var ret_others = addTab(results.others, query, true);\n-        var ret_in_args = addTab(results.in_args, query, false);\n-        var ret_returned = addTab(results.returned, query, false);\n+        var ret_others = addTab(results.others, results.query, true);\n+        var ret_in_args = addTab(results.in_args, results.query, false);\n+        var ret_returned = addTab(results.returned, results.query, false);\n \n         // Navigate to the relevant tab if the current tab is empty, like in case users search\n         // for \"-> String\". If they had selected another tab previously, they have to click on\n@@ -1164,11 +1372,15 @@ window.initSearch = function(rawSearchIndex) {\n             }\n             crates += `</select>`;\n         }\n-        var output = `<div id=\"search-settings\">\n-            <h1 class=\"search-results-title\">Results for ${escape(query.query)} ` +\n-            (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n-            crates +\n-            `</div><div id=\"titles\">` +\n+        var typeFilter = \"\";\n+        if (results.query.typeFilter !== NO_TYPE_FILTER) {\n+            typeFilter = \" (type: \" + escape(results.query.typeFilter) + \")\";\n+        }\n+\n+        var output = `<div id=\"search-settings\">` +\n+            `<h1 class=\"search-results-title\">Results for ${escape(results.query.val)}$` +\n+            `${typeFilter}</h1> in ${crates} </div>` +\n+            `<div id=\"titles\">` +\n             makeTabHeader(0, \"In Names\", ret_others[1]) +\n             makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n             makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n@@ -1196,28 +1408,6 @@ window.initSearch = function(rawSearchIndex) {\n         printTab(currentTab);\n     }\n \n-    function execSearch(query, searchWords, filterCrates) {\n-        query = query.raw.trim();\n-        var results = {\n-            \"in_args\": [],\n-            \"returned\": [],\n-            \"others\": [],\n-        };\n-\n-        if (query.length !== 0) {\n-            var tmp = execQuery(getQuery(query), searchWords, filterCrates);\n-\n-            results.in_args.push(tmp.in_args);\n-            results.returned.push(tmp.returned);\n-            results.others.push(tmp.others);\n-        }\n-        return {\n-            \"in_args\": results.in_args[0],\n-            \"returned\": results.returned[0],\n-            \"others\": results.others[0],\n-        };\n-    }\n-\n     /**\n      * Perform a search based on the current state of the search input element\n      * and display the results.\n@@ -1226,17 +1416,14 @@ window.initSearch = function(rawSearchIndex) {\n      */\n     function search(e, forced) {\n         var params = searchState.getQueryStringParams();\n-        var query = getQuery(searchState.input.value.trim());\n+        var query = parseQuery(searchState.input.value.trim());\n \n         if (e) {\n             e.preventDefault();\n         }\n \n-        if (query.query.length === 0) {\n-            return;\n-        }\n         if (!forced && query.id === currentResults) {\n-            if (query.query.length > 0) {\n+            if (query.val.length > 0) {\n                 putBackSearch();\n             }\n             return;\n@@ -1251,22 +1438,23 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         // Update document title to maintain a meaningful browser history\n-        searchState.title = \"Results for \" + query.query + \" - Rust\";\n+        searchState.title = \"Results for \" + query.original + \" - Rust\";\n \n         // Because searching is incremental by character, only the most\n         // recent search query is added to the browser history.\n         if (searchState.browserSupportsHistoryApi()) {\n-            var newURL = buildUrl(query.raw, filterCrates);\n-\n+            var newURL = buildUrl(query.original, filterCrates);\n             if (!history.state && !params.search) {\n                 history.pushState(null, \"\", newURL);\n             } else {\n                 history.replaceState(null, \"\", newURL);\n             }\n         }\n \n-        showResults(execSearch(query, searchWords, filterCrates),\n-            params[\"go_to_first\"], filterCrates);\n+        showResults(\n+            execQuery(query, searchWords, filterCrates),\n+            params.go_to_first,\n+            filterCrates);\n     }\n \n     function buildIndex(rawSearchIndex) {"}]}