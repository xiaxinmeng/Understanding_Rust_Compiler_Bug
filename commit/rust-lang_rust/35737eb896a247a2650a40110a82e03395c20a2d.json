{"sha": "35737eb896a247a2650a40110a82e03395c20a2d", "node_id": "C_kwDOAAsO6NoAKDM1NzM3ZWI4OTZhMjQ3YTI2NTBhNDAxMTBhODJlMDMzOTVjMjBhMmQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-02T21:24:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-02T21:24:07Z"}, "message": "Merge #11170\n\n11170: minor: Cleanup syntax highlighting r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e95c9aa2cf39608632d53286b8e0d4fd1dfffa80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95c9aa2cf39608632d53286b8e0d4fd1dfffa80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35737eb896a247a2650a40110a82e03395c20a2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh0hf3CRBK7hj4Ov3rIwAANe4IAHelsBzOqOBBzgREusLZ3vKA\n4Levq6G3vecs5ySaGF5jrv4nRHEZkfrkLKIcBItRmHv10kLTS1I4bytitWST5v47\ne6JpOgxqkGHTLynMVpUkRthSm2lw+jMMP+/IrUZx5bTwZJCEmH5rV2GukbqBHWds\n5752HNUBWKVxBdnhBuupyWo34um8dChovsZ/U2hjeOPdmNkIiDuNQ16rnAl2l8jo\nk5CQq/MhP6xp2M1JkJME5U2wsdENz9vQhC0ilVZj+FEHfwQ3Ux6Qu7yyWnJ/2x7W\nDaX6LSOKrYXlhFoO+QsBuayxGXWIsEU0sExqoZA72xOSBixfzaaEtVZrfY+0Pp0=\n=/vs4\n-----END PGP SIGNATURE-----\n", "payload": "tree e95c9aa2cf39608632d53286b8e0d4fd1dfffa80\nparent e1099aaa5749afe3d6dc8f196ef50ffc07fe3d68\nparent 19d894cdecbdc016213b887fc5b8d263ec821aeb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641158647 +0000\ncommitter GitHub <noreply@github.com> 1641158647 +0000\n\nMerge #11170\n\n11170: minor: Cleanup syntax highlighting r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35737eb896a247a2650a40110a82e03395c20a2d", "html_url": "https://github.com/rust-lang/rust/commit/35737eb896a247a2650a40110a82e03395c20a2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35737eb896a247a2650a40110a82e03395c20a2d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1099aaa5749afe3d6dc8f196ef50ffc07fe3d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1099aaa5749afe3d6dc8f196ef50ffc07fe3d68", "html_url": "https://github.com/rust-lang/rust/commit/e1099aaa5749afe3d6dc8f196ef50ffc07fe3d68"}, {"sha": "19d894cdecbdc016213b887fc5b8d263ec821aeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/19d894cdecbdc016213b887fc5b8d263ec821aeb", "html_url": "https://github.com/rust-lang/rust/commit/19d894cdecbdc016213b887fc5b8d263ec821aeb"}], "stats": {"total": 444, "additions": 209, "deletions": 235}, "files": [{"sha": "28c7c546fff7399a686cb7e27a669cc3296e6af5", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=35737eb896a247a2650a40110a82e03395c20a2d", "patch": "@@ -265,6 +265,7 @@ fn traverse(\n         }\n \n         let element = match event {\n+            WalkEvent::Enter(NodeOrToken::Token(tok)) if tok.kind() == WHITESPACE => continue,\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(NodeOrToken::Token(_)) => continue,\n             WalkEvent::Leave(NodeOrToken::Node(node)) => {\n@@ -347,13 +348,16 @@ fn traverse(\n         }\n \n         // do the normal highlighting\n-        let element = highlight::element(\n-            sema,\n-            krate,\n-            &mut bindings_shadow_count,\n-            syntactic_name_ref_highlighting,\n-            element_to_highlight,\n-        );\n+        let element = match element_to_highlight {\n+            NodeOrToken::Node(node) => highlight::node(\n+                sema,\n+                krate,\n+                &mut bindings_shadow_count,\n+                syntactic_name_ref_highlighting,\n+                node,\n+            ),\n+            NodeOrToken::Token(token) => highlight::token(sema, krate, token).zip(Some(None)),\n+        };\n         if let Some((mut highlight, binding_hash)) = element {\n             if inside_attribute {\n                 highlight |= HlMod::Attribute"}, {"sha": "4a09d341f709019cedf0f4bcd44dd21e8b4c7248", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 147, "deletions": 175, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=35737eb896a247a2650a40110a82e03395c20a2d", "patch": "@@ -8,7 +8,7 @@ use ide_db::{\n };\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast, match_ast, AstNode, AstToken, NodeOrToken, SyntaxElement,\n+    ast, match_ast, AstNode, AstToken, NodeOrToken,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n@@ -18,174 +18,46 @@ use crate::{\n     Highlight, HlMod, HlTag,\n };\n \n-pub(super) fn element(\n-    sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n-    bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n-    syntactic_name_ref_highlighting: bool,\n-    element: SyntaxElement,\n-) -> Option<(Highlight, Option<u64>)> {\n-    match element {\n-        NodeOrToken::Node(it) => {\n-            node(sema, krate, bindings_shadow_count, syntactic_name_ref_highlighting, it)\n-        }\n-        NodeOrToken::Token(it) => Some((token(sema, krate, it)?, None)),\n-    }\n-}\n-\n-fn token(\n+pub(super) fn token(\n     sema: &Semantics<RootDatabase>,\n     krate: Option<hir::Crate>,\n     token: SyntaxToken,\n ) -> Option<Highlight> {\n-    let highlight: Highlight = if let Some(comment) = ast::Comment::cast(token.clone()) {\n+    if let Some(comment) = ast::Comment::cast(token.clone()) {\n         let h = HlTag::Comment;\n-        match comment.kind().doc {\n+        return Some(match comment.kind().doc {\n             Some(_) => h | HlMod::Documentation,\n             None => h.into(),\n+        });\n+    }\n+\n+    let highlight: Highlight = match token.kind() {\n+        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n+        INT_NUMBER if token.ancestors().nth(1).map(|it| it.kind()) == Some(FIELD_EXPR) => {\n+            SymbolKind::Field.into()\n         }\n-    } else {\n-        match token.kind() {\n-            STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n-            INT_NUMBER if token.ancestors().nth(1).map_or(false, |it| it.kind() == FIELD_EXPR) => {\n-                SymbolKind::Field.into()\n-            }\n-            INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n-            BYTE => HlTag::ByteLiteral.into(),\n-            CHAR => HlTag::CharLiteral.into(),\n-            T![?] => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n-            IDENT if parent_matches::<ast::TokenTree>(&token) => {\n-                if let Some(attr) = token.ancestors().nth(2).and_then(ast::Attr::cast) {\n+        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n+        BYTE => HlTag::ByteLiteral.into(),\n+        CHAR => HlTag::CharLiteral.into(),\n+        IDENT if parent_matches::<ast::TokenTree>(&token) => {\n+            match token.ancestors().nth(2).and_then(ast::Attr::cast) {\n+                Some(attr) => {\n                     match try_resolve_derive_input(sema, &attr, &ast::Ident::cast(token).unwrap()) {\n                         Some(res) => highlight_def(sema, krate, Definition::from(res)),\n                         None => HlTag::None.into(),\n                     }\n-                } else {\n-                    HlTag::None.into()\n-                }\n-            }\n-            p if p.is_punct() => match p {\n-                T![&] if parent_matches::<ast::BinExpr>(&token) => HlOperator::Bitwise.into(),\n-                T![&] => {\n-                    let h = HlTag::Operator(HlOperator::Other).into();\n-                    let is_unsafe = token\n-                        .parent()\n-                        .and_then(ast::RefExpr::cast)\n-                        .map_or(false, |ref_expr| sema.is_unsafe_ref_expr(&ref_expr));\n-                    if is_unsafe {\n-                        h | HlMod::Unsafe\n-                    } else {\n-                        h\n-                    }\n-                }\n-                T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => {\n-                    HlOperator::Other.into()\n-                }\n-                T![!] if parent_matches::<ast::MacroCall>(&token) => HlPunct::MacroBang.into(),\n-                T![!] if parent_matches::<ast::NeverType>(&token) => HlTag::BuiltinType.into(),\n-                T![!] if parent_matches::<ast::PrefixExpr>(&token) => HlOperator::Logical.into(),\n-                T![*] if parent_matches::<ast::PtrType>(&token) => HlTag::Keyword.into(),\n-                T![*] if parent_matches::<ast::PrefixExpr>(&token) => {\n-                    let prefix_expr = token.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                    let expr = prefix_expr.expr()?;\n-                    let ty = sema.type_of_expr(&expr)?.original;\n-                    if ty.is_raw_ptr() {\n-                        HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n-                    } else if let Some(ast::UnaryOp::Deref) = prefix_expr.op_kind() {\n-                        HlOperator::Other.into()\n-                    } else {\n-                        HlPunct::Other.into()\n-                    }\n-                }\n-                T![-] if parent_matches::<ast::PrefixExpr>(&token) => {\n-                    let prefix_expr = token.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                    let expr = prefix_expr.expr()?;\n-                    match expr {\n-                        ast::Expr::Literal(_) => HlTag::NumericLiteral,\n-                        _ => HlTag::Operator(HlOperator::Other),\n-                    }\n-                    .into()\n-                }\n-                _ if parent_matches::<ast::PrefixExpr>(&token) => HlOperator::Other.into(),\n-                T![+] | T![-] | T![*] | T![/] if parent_matches::<ast::BinExpr>(&token) => {\n-                    HlOperator::Arithmetic.into()\n-                }\n-                T![+=] | T![-=] | T![*=] | T![/=] if parent_matches::<ast::BinExpr>(&token) => {\n-                    Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n-                }\n-                T![|] | T![&] | T![!] | T![^] if parent_matches::<ast::BinExpr>(&token) => {\n-                    HlOperator::Bitwise.into()\n-                }\n-                T![|=] | T![&=] | T![^=] if parent_matches::<ast::BinExpr>(&token) => {\n-                    Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n-                }\n-                T![&&] | T![||] if parent_matches::<ast::BinExpr>(&token) => {\n-                    HlOperator::Logical.into()\n-                }\n-                T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=]\n-                    if parent_matches::<ast::BinExpr>(&token) =>\n-                {\n-                    HlOperator::Comparison.into()\n-                }\n-                _ if parent_matches::<ast::BinExpr>(&token) => HlOperator::Other.into(),\n-                _ if parent_matches::<ast::RangeExpr>(&token) => HlOperator::Other.into(),\n-                _ if parent_matches::<ast::RangePat>(&token) => HlOperator::Other.into(),\n-                _ if parent_matches::<ast::RestPat>(&token) => HlOperator::Other.into(),\n-                _ if parent_matches::<ast::Attr>(&token) => HlTag::AttributeBracket.into(),\n-                kind => match kind {\n-                    T!['['] | T![']'] => HlPunct::Bracket,\n-                    T!['{'] | T!['}'] => HlPunct::Brace,\n-                    T!['('] | T![')'] => HlPunct::Parenthesis,\n-                    T![<] | T![>] => HlPunct::Angle,\n-                    T![,] => HlPunct::Comma,\n-                    T![:] => HlPunct::Colon,\n-                    T![;] => HlPunct::Semi,\n-                    T![.] => HlPunct::Dot,\n-                    _ => HlPunct::Other,\n-                }\n-                .into(),\n-            },\n-            k if k.is_keyword() => {\n-                let h = Highlight::new(HlTag::Keyword);\n-                match k {\n-                    T![await] => h | HlMod::Async | HlMod::ControlFlow,\n-                    T![break]\n-                    | T![continue]\n-                    | T![else]\n-                    | T![if]\n-                    | T![in]\n-                    | T![loop]\n-                    | T![match]\n-                    | T![return]\n-                    | T![while]\n-                    | T![yield] => h | HlMod::ControlFlow,\n-                    T![for] if !is_child_of_impl(&token) => h | HlMod::ControlFlow,\n-                    T![unsafe] => h | HlMod::Unsafe,\n-                    T![true] | T![false] => HlTag::BoolLiteral.into(),\n-                    // crate is handled just as a token if it's in an `extern crate`\n-                    T![crate] if parent_matches::<ast::ExternCrate>(&token) => h,\n-                    // self, crate and super are handled as either a Name or NameRef already\n-                    T![self] | T![crate] | T![super] => return None,\n-                    T![ref] => token\n-                        .parent()\n-                        .and_then(ast::IdentPat::cast)\n-                        .and_then(|ident_pat| {\n-                            (sema.is_unsafe_ident_pat(&ident_pat)).then(|| HlMod::Unsafe)\n-                        })\n-                        .map_or(h, |modifier| h | modifier),\n-                    T![async] => h | HlMod::Async,\n-                    _ => h,\n                 }\n+                None => HlTag::None.into(),\n             }\n-            _ => return None,\n         }\n+        p if p.is_punct() => punctuation(sema, token, p),\n+        k if k.is_keyword() => keyword(sema, token, k)?,\n+        _ => return None,\n     };\n     Some(highlight)\n }\n \n-fn node(\n+pub(super) fn node(\n     sema: &Semantics<RootDatabase>,\n     krate: Option<hir::Crate>,\n     bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n@@ -195,18 +67,6 @@ fn node(\n     let mut binding_hash = None;\n     let highlight = match_ast! {\n         match node {\n-            ast::Fn(__) => {\n-                bindings_shadow_count.clear();\n-                return None;\n-            },\n-            ast::Attr(__) => {\n-                HlTag::AttributeBracket.into()\n-            },\n-            // Highlight definitions depending on the \"type\" of the definition.\n-            ast::Name(name) => {\n-                highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n-            },\n-            // Highlight references like the definitions they resolve to\n             ast::NameRef(name_ref) => {\n                 highlight_name_ref(\n                     sema,\n@@ -217,6 +77,9 @@ fn node(\n                     name_ref,\n                 )\n             },\n+            ast::Name(name) => {\n+                highlight_name(sema, bindings_shadow_count, &mut binding_hash, krate, name)\n+            },\n             ast::Lifetime(lifetime) => {\n                 match NameClass::classify_lifetime(sema, &lifetime) {\n                     Some(NameClass::Definition(def)) => {\n@@ -229,12 +92,129 @@ fn node(\n                     _ => Highlight::from(SymbolKind::LifetimeParam) | HlMod::Definition,\n                 }\n             },\n-            _ => return None,\n+            ast::Fn(_) => {\n+                bindings_shadow_count.clear();\n+                return None;\n+            },\n+            _ => {\n+                if [FN, CONST, STATIC].contains(&node.kind()) {\n+                    bindings_shadow_count.clear();\n+                }\n+                return None\n+            },\n         }\n     };\n     Some((highlight, binding_hash))\n }\n \n+fn punctuation(sema: &Semantics<RootDatabase>, token: SyntaxToken, kind: SyntaxKind) -> Highlight {\n+    let parent = token.parent();\n+    let parent_kind = parent.as_ref().map_or(EOF, SyntaxNode::kind);\n+    match (kind, parent_kind) {\n+        (T![?], _) => HlTag::Operator(HlOperator::Other) | HlMod::ControlFlow,\n+        (T![&], BIN_EXPR) => HlOperator::Bitwise.into(),\n+        (T![&], _) => {\n+            let h = HlTag::Operator(HlOperator::Other).into();\n+            let is_unsafe = parent\n+                .and_then(ast::RefExpr::cast)\n+                .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr));\n+            if let Some(true) = is_unsafe {\n+                h | HlMod::Unsafe\n+            } else {\n+                h\n+            }\n+        }\n+        (T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.], _) => HlOperator::Other.into(),\n+        (T![!], MACRO_CALL) => HlPunct::MacroBang.into(),\n+        (T![!], NEVER_TYPE) => HlTag::BuiltinType.into(),\n+        (T![!], PREFIX_EXPR) => HlOperator::Logical.into(),\n+        (T![*], PTR_TYPE) => HlTag::Keyword.into(),\n+        (T![*], PREFIX_EXPR) => {\n+            let is_raw_ptr = (|| {\n+                let prefix_expr = parent.and_then(ast::PrefixExpr::cast)?;\n+                let expr = prefix_expr.expr()?;\n+                sema.type_of_expr(&expr)?.original.is_raw_ptr().then(|| ())\n+            })();\n+            if let Some(()) = is_raw_ptr {\n+                HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n+            } else {\n+                HlOperator::Other.into()\n+            }\n+        }\n+        (T![-], PREFIX_EXPR) => {\n+            let prefix_expr = parent.and_then(ast::PrefixExpr::cast).and_then(|e| e.expr());\n+            match prefix_expr {\n+                Some(ast::Expr::Literal(_)) => HlTag::NumericLiteral,\n+                _ => HlTag::Operator(HlOperator::Other),\n+            }\n+            .into()\n+        }\n+        (T![+] | T![-] | T![*] | T![/], BIN_EXPR) => HlOperator::Arithmetic.into(),\n+        (T![+=] | T![-=] | T![*=] | T![/=], BIN_EXPR) => {\n+            Highlight::from(HlOperator::Arithmetic) | HlMod::Mutable\n+        }\n+        (T![|] | T![&] | T![!] | T![^], BIN_EXPR) => HlOperator::Bitwise.into(),\n+        (T![|=] | T![&=] | T![^=], BIN_EXPR) => {\n+            Highlight::from(HlOperator::Bitwise) | HlMod::Mutable\n+        }\n+        (T![&&] | T![||], BIN_EXPR) => HlOperator::Logical.into(),\n+        (T![>] | T![<] | T![==] | T![>=] | T![<=] | T![!=], BIN_EXPR) => {\n+            HlOperator::Comparison.into()\n+        }\n+        (_, PREFIX_EXPR | BIN_EXPR | RANGE_EXPR | RANGE_PAT | REST_PAT) => HlOperator::Other.into(),\n+        (_, ATTR) => HlTag::AttributeBracket.into(),\n+        (kind, _) => match kind {\n+            T!['['] | T![']'] => HlPunct::Bracket,\n+            T!['{'] | T!['}'] => HlPunct::Brace,\n+            T!['('] | T![')'] => HlPunct::Parenthesis,\n+            T![<] | T![>] => HlPunct::Angle,\n+            T![,] => HlPunct::Comma,\n+            T![:] => HlPunct::Colon,\n+            T![;] => HlPunct::Semi,\n+            T![.] => HlPunct::Dot,\n+            _ => HlPunct::Other,\n+        }\n+        .into(),\n+    }\n+}\n+\n+fn keyword(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+    kind: SyntaxKind,\n+) -> Option<Highlight> {\n+    let h = Highlight::new(HlTag::Keyword);\n+    let h = match kind {\n+        T![await] => h | HlMod::Async | HlMod::ControlFlow,\n+        T![async] => h | HlMod::Async,\n+        T![break]\n+        | T![continue]\n+        | T![else]\n+        | T![if]\n+        | T![in]\n+        | T![loop]\n+        | T![match]\n+        | T![return]\n+        | T![while]\n+        | T![yield] => h | HlMod::ControlFlow,\n+        T![for] if parent_matches::<ast::ForExpr>(&token) => h | HlMod::ControlFlow,\n+        T![unsafe] => h | HlMod::Unsafe,\n+        T![true] | T![false] => HlTag::BoolLiteral.into(),\n+        // crate is handled just as a token if it's in an `extern crate`\n+        T![crate] if parent_matches::<ast::ExternCrate>(&token) => h,\n+        // self, crate and super are handled as either a Name or NameRef already, unless they\n+        // are inside unmapped token trees\n+        T![self] | T![crate] | T![super] if parent_matches::<ast::NameRef>(&token) => return None,\n+        T![self] if parent_matches::<ast::Name>(&token) => return None,\n+        T![ref] => match token.parent().and_then(ast::IdentPat::cast) {\n+            Some(ident) if sema.is_unsafe_ident_pat(&ident) => h | HlMod::Unsafe,\n+            _ => h,\n+        },\n+        _ => h,\n+    };\n+    Some(h)\n+}\n+\n fn highlight_name_ref(\n     sema: &Semantics<RootDatabase>,\n     krate: Option<hir::Crate>,\n@@ -325,10 +305,9 @@ fn highlight_name(\n     krate: Option<hir::Crate>,\n     name: ast::Name,\n ) -> Highlight {\n-    let db = sema.db;\n     let name_kind = NameClass::classify(sema, &name);\n     if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n-        if let Some(name) = local.name(db) {\n+        if let Some(name) = local.name(sema.db) {\n             let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n             *shadow_count += 1;\n             *binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n@@ -338,7 +317,7 @@ fn highlight_name(\n         Some(NameClass::Definition(def)) => {\n             let mut h = highlight_def(sema, krate, def) | HlMod::Definition;\n             if let Definition::Trait(trait_) = &def {\n-                if trait_.is_unsafe(db) {\n+                if trait_.is_unsafe(sema.db) {\n                     h |= HlMod::Unsafe;\n                 }\n             }\n@@ -347,7 +326,7 @@ fn highlight_name(\n         Some(NameClass::ConstReference(def)) => highlight_def(sema, krate, def),\n         Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n             let mut h = HlTag::Symbol(SymbolKind::Field).into();\n-            if let hir::VariantDef::Union(_) = field_ref.parent_def(db) {\n+            if let hir::VariantDef::Union(_) = field_ref.parent_def(sema.db) {\n                 h |= HlMod::Unsafe;\n             }\n             h\n@@ -729,21 +708,14 @@ fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[Sy\n     kinds.is_empty()\n }\n \n-#[inline]\n fn parent_matches<N: AstNode>(token: &SyntaxToken) -> bool {\n     token.parent().map_or(false, |it| N::can_cast(it.kind()))\n }\n \n-fn is_child_of_impl(token: &SyntaxToken) -> bool {\n-    match token.parent() {\n-        Some(e) => e.kind() == IMPL,\n-        _ => false,\n-    }\n-}\n-\n fn is_in_fn_with_self_param<N: AstNode>(node: &N) -> bool {\n     node.syntax()\n         .ancestors()\n+        .take_while(|node| ast::Expr::can_cast(node.kind()) || ast::Fn::can_cast(node.kind()))\n         .find_map(ast::Fn::cast)\n         .and_then(|s| s.param_list()?.self_param())\n         .is_some()"}, {"sha": "50013c06a756fe956df88b60adddd6c16eed4a66", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=35737eb896a247a2650a40110a82e03395c20a2d", "patch": "@@ -143,12 +143,12 @@\n <span class=\"comment documentation\">///</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">/// </span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span>\n-<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"false\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span><span class=\"attribute_bracket attribute\"> </span><span class=\"none attribute\">doc</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n-<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">doc</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"attribute_bracket attribute\">]</span>\n+<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"false\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n+<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"</span><span class=\"keyword control injected\">loop</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span><span class=\"brace injected\">}</span><span class=\"string_literal attribute\">\"</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">///</span>\n-<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"alloc\"</span><span class=\"comma attribute\">,</span><span class=\"attribute_bracket attribute\"> </span><span class=\"none attribute\">doc</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"```rust\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n-<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"alloc\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span><span class=\"attribute_bracket attribute\"> </span><span class=\"none attribute\">doc</span><span class=\"attribute_bracket attribute\"> </span><span class=\"operator attribute\">=</span><span class=\"attribute_bracket attribute\"> </span><span class=\"string_literal attribute\">\"```ignore\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n+<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"alloc\"</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"```rust\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n+<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"builtin_attr attribute library\">cfg_attr</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">not</span><span class=\"parenthesis attribute\">(</span><span class=\"none attribute\">feature</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"alloc\"</span><span class=\"parenthesis attribute\">)</span><span class=\"comma attribute\">,</span> <span class=\"none attribute\">doc</span> <span class=\"operator attribute\">=</span> <span class=\"string_literal attribute\">\"```ignore\"</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"function injected\">example</span><span class=\"parenthesis injected\">(</span><span class=\"operator injected\">&</span><span class=\"module injected\">alloc</span><span class=\"operator injected\">::</span><span class=\"macro injected\">vec</span><span class=\"macro_bang injected\">!</span><span class=\"bracket injected\">[</span><span class=\"numeric_literal injected\">1</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">2</span><span class=\"comma injected\">,</span><span class=\"none injected\"> </span><span class=\"numeric_literal injected\">3</span><span class=\"bracket injected\">]</span><span class=\"parenthesis injected\">)</span><span class=\"semicolon injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration public\">mix_and_match</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span><span class=\"brace\">}</span>"}, {"sha": "1ae07a125f7da9b190626f3a724b3b6d88f14819", "filename": "crates/ide/src/syntax_highlighting/test_data/highlighting.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlighting.html?ref=35737eb896a247a2650a40110a82e03395c20a2d", "patch": "@@ -262,7 +262,7 @@\n \n <span class=\"keyword\">impl</span> <span class=\"enum public\">Bool</span> <span class=\"brace\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function associated consuming declaration public\">to_primitive</span><span class=\"parenthesis\">(</span><span class=\"self_keyword declaration\">self</span><span class=\"parenthesis\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">bool</span> <span class=\"brace\">{</span>\n-        <span class=\"unresolved_reference\">matches</span><span class=\"macro_bang\">!</span><span class=\"parenthesis\">(</span>self<span class=\"comma\">,</span> Self<span class=\"colon\">:</span><span class=\"colon\">:</span>True<span class=\"parenthesis\">)</span>\n+        <span class=\"unresolved_reference\">matches</span><span class=\"macro_bang\">!</span><span class=\"parenthesis\">(</span><span class=\"keyword\">self</span><span class=\"comma\">,</span> Self<span class=\"colon\">:</span><span class=\"colon\">:</span>True<span class=\"parenthesis\">)</span>\n     <span class=\"brace\">}</span>\n <span class=\"brace\">}</span>\n <span class=\"keyword\">const</span> <span class=\"constant declaration\">USAGE_OF_BOOL</span><span class=\"colon\">:</span><span class=\"builtin_type\">bool</span> <span class=\"operator\">=</span> <span class=\"enum public\">Bool</span><span class=\"operator\">::</span><span class=\"enum_variant public\">True</span><span class=\"operator\">.</span><span class=\"function associated consuming public\">to_primitive</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>"}, {"sha": "c9b8c942051ae26e53376d418bfc2bf4d706f671", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35737eb896a247a2650a40110a82e03395c20a2d/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=35737eb896a247a2650a40110a82e03395c20a2d", "patch": "@@ -359,18 +359,6 @@ impl NameRefClass {\n \n         let parent = name_ref.syntax().parent()?;\n \n-        if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n-            if let Some(func) = sema.resolve_method_call(&method_call) {\n-                return Some(NameRefClass::Definition(Definition::Function(func)));\n-            }\n-        }\n-\n-        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-            if let Some(field) = sema.resolve_field(&field_expr) {\n-                return Some(NameRefClass::Definition(Definition::Field(field)));\n-            }\n-        }\n-\n         if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n             if let Some((field, local, _)) = sema.resolve_record_field(&record_field) {\n                 let res = match local {\n@@ -383,38 +371,6 @@ impl NameRefClass {\n             }\n         }\n \n-        if let Some(record_pat_field) = ast::RecordPatField::cast(parent.clone()) {\n-            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                let field = Definition::Field(field);\n-                return Some(NameRefClass::Definition(field));\n-            }\n-        }\n-\n-        if let Some(assoc_type_arg) = ast::AssocTypeArg::cast(parent.clone()) {\n-            if assoc_type_arg.name_ref().as_ref() == Some(name_ref) {\n-                // `Trait<Assoc = Ty>`\n-                //        ^^^^^\n-                let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-                let resolved = sema.resolve_path(&path)?;\n-                if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n-                    // FIXME: resolve in supertraits\n-                    if let Some(ty) = tr\n-                        .items(sema.db)\n-                        .iter()\n-                        .filter_map(|assoc| match assoc {\n-                            hir::AssocItem::TypeAlias(it) => Some(*it),\n-                            _ => None,\n-                        })\n-                        .find(|alias| alias.name(sema.db).to_smol_str() == name_ref.text().as_str())\n-                    {\n-                        return Some(NameRefClass::Definition(Definition::TypeAlias(ty)));\n-                    }\n-                }\n-\n-                return None;\n-            }\n-        }\n-\n         if let Some(path) = ast::PathSegment::cast(parent.clone()).map(|it| it.parent_path()) {\n             if path.parent_path().is_none() {\n                 if let Some(macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n@@ -428,10 +384,52 @@ impl NameRefClass {\n             return sema.resolve_path(&path).map(Into::into).map(NameRefClass::Definition);\n         }\n \n-        let extern_crate = ast::ExternCrate::cast(parent)?;\n-        let krate = sema.resolve_extern_crate(&extern_crate)?;\n-        let root_module = krate.root_module(sema.db);\n-        Some(NameRefClass::Definition(Definition::Module(root_module)))\n+        match_ast! {\n+            match parent {\n+                ast::MethodCallExpr(method_call) => {\n+                    sema.resolve_method_call(&method_call)\n+                        .map(Definition::Function)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::FieldExpr(field_expr) => {\n+                    sema.resolve_field(&field_expr)\n+                        .map(Definition::Field)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::RecordPatField(record_pat_field) => {\n+                    sema.resolve_record_pat_field(&record_pat_field)\n+                        .map(Definition::Field)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::AssocTypeArg(_) => {\n+                    // `Trait<Assoc = Ty>`\n+                    //        ^^^^^\n+                    let containing_path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+                    let resolved = sema.resolve_path(&containing_path)?;\n+                    if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n+                        // FIXME: resolve in supertraits\n+                        if let Some(ty) = tr\n+                            .items(sema.db)\n+                            .iter()\n+                            .filter_map(|&assoc| match assoc {\n+                                hir::AssocItem::TypeAlias(it) => Some(it),\n+                                _ => None,\n+                            })\n+                            .find(|alias| alias.name(sema.db).to_smol_str() == name_ref.text().as_str())\n+                        {\n+                            return Some(NameRefClass::Definition(Definition::TypeAlias(ty)));\n+                        }\n+                    }\n+                    None\n+                },\n+                ast::ExternCrate(extern_crate) => {\n+                    let krate = sema.resolve_extern_crate(&extern_crate)?;\n+                    let root_module = krate.root_module(sema.db);\n+                    Some(NameRefClass::Definition(Definition::Module(root_module)))\n+                },\n+                _ => None\n+            }\n+        }\n     }\n \n     pub fn classify_lifetime("}]}