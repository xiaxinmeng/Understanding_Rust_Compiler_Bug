{"sha": "af7ab3447079fddc51c6c7749b160d24769f7c16", "node_id": "C_kwDOAAsO6NoAKGFmN2FiMzQ0NzA3OWZkZGM1MWM2Yzc3NDliMTYwZDI0NzY5ZjdjMTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T17:02:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-21T17:02:31Z"}, "message": "Auto merge of #99567 - matthiaskrgr:rollup-08hh3r4, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #98707 (std: use futex-based locks on Fuchsia)\n - #99413 (Add `PhantomData` marker for dropck to `BTreeMap`)\n - #99454 (Add map_continue and continue_value combinators to ControlFlow)\n - #99523 (Fix the stable version of `AsFd for Arc<T>` and `Box<T>`)\n - #99526 (Normalize the arg spans to be within the call span)\n - #99528 (couple of clippy::perf fixes)\n - #99549 (Add regression test for #52304)\n - #99552 (Rewrite `orphan_check_trait_ref` to use a `TypeVisitor`)\n - #99557 (Edit `rustc_index::vec::IndexVec::pick3_mut` docs)\n - #99558 (Fix `remap_constness`)\n - #99559 (Remove unused field in ItemKind::KeywordItem)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c3313ceb71c87ffe157e6d68e967877761f7d836", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3313ceb71c87ffe157e6d68e967877761f7d836"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af7ab3447079fddc51c6c7749b160d24769f7c16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af7ab3447079fddc51c6c7749b160d24769f7c16", "html_url": "https://github.com/rust-lang/rust/commit/af7ab3447079fddc51c6c7749b160d24769f7c16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af7ab3447079fddc51c6c7749b160d24769f7c16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1673f1450eeaf4a5452e086db0fe2ae274a0144f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1673f1450eeaf4a5452e086db0fe2ae274a0144f", "html_url": "https://github.com/rust-lang/rust/commit/1673f1450eeaf4a5452e086db0fe2ae274a0144f"}, {"sha": "af64d93dbb8239dd8aa6e0fcaa89490467f1344f", "url": "https://api.github.com/repos/rust-lang/rust/commits/af64d93dbb8239dd8aa6e0fcaa89490467f1344f", "html_url": "https://github.com/rust-lang/rust/commit/af64d93dbb8239dd8aa6e0fcaa89490467f1344f"}], "stats": {"total": 921, "additions": 577, "deletions": 344}, "files": [{"sha": "2ac5c1960cd56acd6913ad5c95857304c29c6f8d", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -299,7 +299,7 @@ impl DiagnosticMessage {\n     /// - If `self` is non-translatable then return `self`'s message.\n     pub fn with_subdiagnostic_message(&self, sub: SubdiagnosticMessage) -> Self {\n         let attr = match sub {\n-            SubdiagnosticMessage::Str(s) => return DiagnosticMessage::Str(s.clone()),\n+            SubdiagnosticMessage::Str(s) => return DiagnosticMessage::Str(s),\n             SubdiagnosticMessage::FluentIdentifier(id) => {\n                 return DiagnosticMessage::FluentIdentifier(id, None);\n             }"}, {"sha": "30ff364210da8610fa0b73cbcf43eb83affe04a1", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -234,7 +234,9 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.get_mut(index.index())\n     }\n \n-    /// Returns mutable references to two distinct elements, a and b. Panics if a == b.\n+    /// Returns mutable references to two distinct elements, `a` and `b`.\n+    ///\n+    /// Panics if `a == b`.\n     #[inline]\n     pub fn pick2_mut(&mut self, a: I, b: I) -> (&mut T, &mut T) {\n         let (ai, bi) = (a.index(), b.index());\n@@ -249,7 +251,9 @@ impl<I: Idx, T> IndexVec<I, T> {\n         }\n     }\n \n-    /// Returns mutable references to three distinct elements or panics otherwise.\n+    /// Returns mutable references to three distinct elements.\n+    ///\n+    /// Panics if the elements are not distinct.\n     #[inline]\n     pub fn pick3_mut(&mut self, a: I, b: I, c: I) -> (&mut T, &mut T, &mut T) {\n         let (ai, bi, ci) = (a.index(), b.index(), c.index());"}, {"sha": "6c9561925fe8c5eb7586a517bc8051c7db0b613f", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -212,7 +212,7 @@ impl DiagnosticDeriveBuilder {\n                 }\n                 NestedMeta::Meta(meta @ Meta::NameValue(_))\n                     if !is_help_note_or_warn\n-                        && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n+                        && meta.path().segments.last().unwrap().ident == \"code\" =>\n                 {\n                     // don't error for valid follow-up attributes\n                 }"}, {"sha": "562d5e9f4d25e58138661ffdb79a810c33aaf478", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -194,8 +194,8 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                 let snake_name = Ident::new(\n                     // FIXME: should probably trim prefix, not replace all occurrences\n                     &name\n-                        .replace(&format!(\"{}-\", res.ident).replace(\"_\", \"-\"), \"\")\n-                        .replace(\"-\", \"_\"),\n+                        .replace(&format!(\"{}-\", res.ident).replace('_', \"-\"), \"\")\n+                        .replace('-', \"_\"),\n                     span,\n                 );\n                 constants.extend(quote! {\n@@ -207,7 +207,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                 });\n \n                 for Attribute { id: Identifier { name: attr_name }, .. } in attributes {\n-                    let snake_name = Ident::new(&attr_name.replace(\"-\", \"_\"), span);\n+                    let snake_name = Ident::new(&attr_name.replace('-', \"_\"), span);\n                     if !previous_attrs.insert(snake_name.clone()) {\n                         continue;\n                     }"}, {"sha": "c7653bdbe84a2f9cf841a11bee7ad84ce465997d", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -88,19 +88,17 @@ impl<'tcx> ValTree<'tcx> {\n                     let leafs = self\n                         .unwrap_branch()\n                         .into_iter()\n-                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n-                        .collect::<Vec<_>>();\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap());\n \n-                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                    return Some(tcx.arena.alloc_from_iter(leafs));\n                 }\n                 ty::Slice(slice_ty) if *slice_ty == tcx.types.u8 => {\n                     let leafs = self\n                         .unwrap_branch()\n                         .into_iter()\n-                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap())\n-                        .collect::<Vec<_>>();\n+                        .map(|v| v.unwrap_leaf().try_to_u8().unwrap());\n \n-                    return Some(tcx.arena.alloc_from_iter(leafs.into_iter()));\n+                    return Some(tcx.arena.alloc_from_iter(leafs));\n                 }\n                 _ => {}\n             },"}, {"sha": "4f39ec31a83807dc46c1d97eedf75ee75c3ea2f0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -790,22 +790,15 @@ pub struct TraitPredicate<'tcx> {\n pub type PolyTraitPredicate<'tcx> = ty::Binder<'tcx, TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n-    pub fn remap_constness(&mut self, tcx: TyCtxt<'tcx>, param_env: &mut ParamEnv<'tcx>) {\n-        if std::intrinsics::unlikely(Some(self.trait_ref.def_id) == tcx.lang_items().drop_trait()) {\n-            // remap without changing constness of this predicate.\n-            // this is because `T: ~const Drop` has a different meaning to `T: Drop`\n-            // FIXME(fee1-dead): remove this logic after beta bump\n-            param_env.remap_constness_with(self.constness)\n-        } else {\n-            *param_env = param_env.with_constness(self.constness.and(param_env.constness()))\n-        }\n+    pub fn remap_constness(&mut self, param_env: &mut ParamEnv<'tcx>) {\n+        *param_env = param_env.with_constness(self.constness.and(param_env.constness()))\n     }\n \n     /// Remap the constness of this predicate before emitting it for diagnostics.\n     pub fn remap_constness_diag(&mut self, param_env: ParamEnv<'tcx>) {\n         // this is different to `remap_constness` that callees want to print this predicate\n         // in case of selection errors. `T: ~const Drop` bounds cannot end up here when the\n-        // param_env is not const because we it is always satisfied in non-const contexts.\n+        // param_env is not const because it is always satisfied in non-const contexts.\n         if let hir::Constness::NotConst = param_env.constness() {\n             self.constness = ty::BoundConstness::NotConst;\n         }"}, {"sha": "390d6f5a856af29ce1f2f35374f8035a807a1677", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -1754,7 +1754,6 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                 || self.in_assoc_ty\n                 || self.tcx.resolutions(()).has_pub_restricted\n             {\n-                let descr = descr.to_string();\n                 let vis_span =\n                     self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n                 if kind == \"trait\" {"}, {"sha": "d74e26fc84498cf6c3bf997ccd68b558ad64a5ca", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -2608,7 +2608,7 @@ fn show_candidates(\n                 \"item\"\n             };\n             let plural_descr =\n-                if descr.ends_with(\"s\") { format!(\"{}es\", descr) } else { format!(\"{}s\", descr) };\n+                if descr.ends_with('s') { format!(\"{}es\", descr) } else { format!(\"{}s\", descr) };\n \n             let mut msg = format!(\"{}these {} exist but are inaccessible\", prefix, plural_descr);\n             let mut has_colon = false;"}, {"sha": "21b1b0b4ebf61638a54535e5abbce85bbad090b8", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -535,7 +535,7 @@ mod parse {\n     ) -> bool {\n         match v {\n             Some(s) => {\n-                for s in s.split(\",\") {\n+                for s in s.split(',') {\n                     let Some(pass_name) = s.strip_prefix(&['+', '-'][..]) else { return false };\n                     slot.push((pass_name.to_string(), &s[..1] == \"+\"));\n                 }"}, {"sha": "9983438233e1ef129275b506f53ab82d1f57a2e6", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 123, "deletions": 196, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -22,11 +22,12 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -578,220 +579,146 @@ fn orphan_check_trait_ref<'tcx>(\n         );\n     }\n \n-    // Given impl<P1..=Pn> Trait<T1..=Tn> for T0, an impl is valid only\n-    // if at least one of the following is true:\n-    //\n-    // - Trait is a local trait\n-    // (already checked in orphan_check prior to calling this function)\n-    // - All of\n-    //     - At least one of the types T0..=Tn must be a local type.\n-    //      Let Ti be the first such type.\n-    //     - No uncovered type parameters P1..=Pn may appear in T0..Ti (excluding Ti)\n-    //\n-    fn uncover_fundamental_ty<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        ty: Ty<'tcx>,\n-        in_crate: InCrate,\n-    ) -> Vec<Ty<'tcx>> {\n-        // FIXME: this is currently somewhat overly complicated,\n-        // but fixing this requires a more complicated refactor.\n-        if !contained_non_local_types(tcx, ty, in_crate).is_empty() {\n-            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n-                return inner_tys\n-                    .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                    .collect();\n+    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    match trait_ref.visit_with(&mut checker) {\n+        ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n+        ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n+            // Does there exist some local type after the `ParamTy`.\n+            checker.search_first_local_ty = true;\n+            if let Some(OrphanCheckEarlyExit::LocalTy(local_ty)) =\n+                trait_ref.visit_with(&mut checker).break_value()\n+            {\n+                Err(OrphanCheckErr::UncoveredTy(ty, Some(local_ty)))\n+            } else {\n+                Err(OrphanCheckErr::UncoveredTy(ty, None))\n             }\n         }\n-\n-        vec![ty]\n-    }\n-\n-    let mut non_local_spans = vec![];\n-    for (i, input_ty) in trait_ref\n-        .substs\n-        .types()\n-        .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-        .enumerate()\n-    {\n-        debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = contained_non_local_types(tcx, input_ty, in_crate);\n-        if non_local_tys.is_empty() {\n-            debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n-            return Ok(());\n-        } else if let ty::Param(_) = input_ty.kind() {\n-            debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n-            let local_type = trait_ref\n-                .substs\n-                .types()\n-                .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|&ty| ty_is_local_constructor(tcx, ty, in_crate));\n-\n-            debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n-\n-            return Err(OrphanCheckErr::UncoveredTy(input_ty, local_type));\n-        }\n-\n-        non_local_spans.extend(non_local_tys.into_iter().map(|input_ty| (input_ty, i == 0)));\n+        ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(_)) => Ok(()),\n     }\n-    // If we exit above loop, never found a local type.\n-    debug!(\"orphan_check_trait_ref: no local type\");\n-    Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-/// Returns a list of relevant non-local types for `ty`.\n-///\n-/// This is just `ty` itself unless `ty` is `#[fundamental]`,\n-/// in which case we recursively look into this type.\n-///\n-/// If `ty` is local itself, this method returns an empty `Vec`.\n-///\n-/// # Examples\n-///\n-/// - `u32` is not local, so this returns `[u32]`.\n-/// - for `Foo<u32>`, where `Foo` is a local type, this returns `[]`.\n-/// - `&mut u32` returns `[u32]`, as `&mut` is a fundamental type, similar to `Box`.\n-/// - `Box<Foo<u32>>` returns `[]`, as `Box` is a fundamental type and `Foo` is local.\n-fn contained_non_local_types<'tcx>(\n+struct OrphanChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n     in_crate: InCrate,\n-) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(tcx, ty, in_crate) {\n-        Vec::new()\n-    } else {\n-        match fundamental_ty_inner_tys(tcx, ty) {\n-            Some(inner_tys) => {\n-                inner_tys.flat_map(|ty| contained_non_local_types(tcx, ty, in_crate)).collect()\n-            }\n-            None => vec![ty],\n+    in_self_ty: bool,\n+    /// Ignore orphan check failures and exclusively search for the first\n+    /// local type.\n+    search_first_local_ty: bool,\n+    non_local_tys: Vec<(Ty<'tcx>, bool)>,\n+}\n+\n+impl<'tcx> OrphanChecker<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+        OrphanChecker {\n+            tcx,\n+            in_crate,\n+            in_self_ty: true,\n+            search_first_local_ty: false,\n+            non_local_tys: Vec::new(),\n         }\n     }\n-}\n \n-/// For `#[fundamental]` ADTs and `&T` / `&mut T`, returns `Some` with the\n-/// type parameters of the ADT, or `T`, respectively. For non-fundamental\n-/// types, returns `None`.\n-fn fundamental_ty_inner_tys<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n-    let (first_ty, rest_tys) = match *ty.kind() {\n-        ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n-        ty::Adt(def, substs) if def.is_fundamental() => {\n-            let mut types = substs.types();\n-\n-            // FIXME(eddyb) actually validate `#[fundamental]` up-front.\n-            match types.next() {\n-                None => {\n-                    tcx.sess.span_err(\n-                        tcx.def_span(def.did()),\n-                        \"`#[fundamental]` requires at least one type parameter\",\n-                    );\n-\n-                    return None;\n-                }\n+    fn found_non_local_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        self.non_local_tys.push((t, self.in_self_ty));\n+        ControlFlow::CONTINUE\n+    }\n \n-                Some(first_ty) => (first_ty, types),\n-            }\n+    fn found_param_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<OrphanCheckEarlyExit<'tcx>> {\n+        if self.search_first_local_ty {\n+            ControlFlow::CONTINUE\n+        } else {\n+            ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(t))\n         }\n-        _ => return None,\n-    };\n+    }\n \n-    Some(iter::once(first_ty).chain(rest_tys))\n+    fn def_id_is_local(&mut self, def_id: DefId) -> bool {\n+        match self.in_crate {\n+            InCrate::Local => def_id.is_local(),\n+            InCrate::Remote => false,\n+        }\n+    }\n }\n \n-fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n-    match in_crate {\n-        // The type is local to *this* crate - it will not be\n-        // local in any other crate.\n-        InCrate::Remote => false,\n-        InCrate::Local => def_id.is_local(),\n-    }\n+enum OrphanCheckEarlyExit<'tcx> {\n+    ParamTy(Ty<'tcx>),\n+    LocalTy(Ty<'tcx>),\n }\n \n-fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    debug!(\"ty_is_local_constructor({:?})\", ty);\n-\n-    match *ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::Str\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Array(..)\n-        | ty::Slice(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::Never\n-        | ty::Tuple(..)\n-        | ty::Param(..)\n-        | ty::Projection(..) => false,\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match in_crate {\n-            InCrate::Local => false,\n-            // The inference variable might be unified with a local\n-            // type in that remote crate.\n-            InCrate::Remote => true,\n-        },\n-\n-        ty::Adt(def, _) => def_id_is_local(def.did(), in_crate),\n-        ty::Foreign(did) => def_id_is_local(did, in_crate),\n-        ty::Opaque(..) => {\n-            // This merits some explanation.\n-            // Normally, opaque types are not involved when performing\n-            // coherence checking, since it is illegal to directly\n-            // implement a trait on an opaque type. However, we might\n-            // end up looking at an opaque type during coherence checking\n-            // if an opaque type gets used within another type (e.g. as\n-            // a type parameter). This requires us to decide whether or\n-            // not an opaque type should be considered 'local' or not.\n-            //\n-            // We choose to treat all opaque types as non-local, even\n-            // those that appear within the same crate. This seems\n-            // somewhat surprising at first, but makes sense when\n-            // you consider that opaque types are supposed to hide\n-            // the underlying type *within the same crate*. When an\n-            // opaque type is used from outside the module\n-            // where it is declared, it should be impossible to observe\n-            // anything about it other than the traits that it implements.\n-            //\n-            // The alternative would be to look at the underlying type\n-            // to determine whether or not the opaque type itself should\n-            // be considered local. However, this could make it a breaking change\n-            // to switch the underlying ('defining') type from a local type\n-            // to a remote type. This would violate the rule that opaque\n-            // types should be completely opaque apart from the traits\n-            // that they implement, so we don't use this behavior.\n-            false\n-        }\n+impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n+    type BreakTy = OrphanCheckEarlyExit<'tcx>;\n+    fn visit_region(&mut self, _r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n+    }\n \n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                def_id_is_local(principal.def_id(), in_crate)\n-            } else {\n-                false\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let result = match *ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Projection(..) => self.found_non_local_ty(ty),\n+\n+            ty::Param(..) => self.found_param_ty(ty),\n+\n+            ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) => match self.in_crate {\n+                InCrate::Local => self.found_non_local_ty(ty),\n+                // The inference variable might be unified with a local\n+                // type in that remote crate.\n+                InCrate::Remote => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            },\n+\n+            // For fundamental types, we just look inside of them.\n+            ty::Ref(_, ty, _) => ty.visit_with(self),\n+            ty::Adt(def, substs) => {\n+                if self.def_id_is_local(def.did()) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else if def.is_fundamental() {\n+                    substs.visit_with(self)\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n-        }\n+            ty::Foreign(def_id) => {\n+                if self.def_id_is_local(def_id) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Dynamic(tt, ..) => {\n+                let principal = tt.principal().map(|p| p.def_id());\n+                if principal.map_or(false, |p| self.def_id_is_local(p)) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n+            }\n+            ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n+            ty::Opaque(..) | ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                self.tcx.sess.delay_span_bug(\n+                    DUMMY_SP,\n+                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n+                );\n+                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            }\n+        };\n+        // A bit of a hack, the `OrphanChecker` is only used to visit a `TraitRef`, so\n+        // the first type we visit is always the self type.\n+        self.in_self_ty = false;\n+        result\n+    }\n \n-        ty::Error(_) => true,\n-\n-        // These variants should never appear during coherence checking because they\n-        // cannot be named directly.\n-        //\n-        // They could be indirectly used through an opaque type. While using opaque types\n-        // in impls causes an error, this path can still be hit afterwards.\n-        //\n-        // See `test/ui/coherence/coherence-with-closure.rs` for an example where this\n-        // could happens.\n-        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-            tcx.sess.delay_span_bug(\n-                DUMMY_SP,\n-                format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-            );\n-            true\n-        }\n+    // FIXME: Constants should participate in orphan checking.\n+    fn visit_const(&mut self, _c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::CONTINUE\n     }\n }"}, {"sha": "5636c74452ccf6626fad06f16dadb7a1cb10b16b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -607,10 +607,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 \"{}, {}={}>\",\n                                 &constraint[..constraint.len() - 1],\n                                 item.name,\n-                                term.to_string()\n+                                term\n                             );\n                         } else {\n-                            constraint.push_str(&format!(\"<{}={}>\", item.name, term.to_string()));\n+                            constraint.push_str(&format!(\"<{}={}>\", item.name, term));\n                         }\n                     }\n "}, {"sha": "17f34012d1dd3e2a2a2f23ad25b3ff4f09b6c8d5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -789,7 +789,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut param_env = obligation.param_env;\n \n         fresh_trait_pred = fresh_trait_pred.map_bound(|mut pred| {\n-            pred.remap_constness(self.tcx(), &mut param_env);\n+            pred.remap_constness(&mut param_env);\n             pred\n         });\n \n@@ -1321,7 +1321,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n         let tcx = self.tcx();\n         let mut pred = cache_fresh_trait_pred.skip_binder();\n-        pred.remap_constness(tcx, &mut param_env);\n+        pred.remap_constness(&mut param_env);\n \n         if self.can_use_global_caches(param_env) {\n             if let Some(res) = tcx.selection_cache.get(&(param_env, pred), tcx) {\n@@ -1375,7 +1375,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         let mut pred = cache_fresh_trait_pred.skip_binder();\n \n-        pred.remap_constness(tcx, &mut param_env);\n+        pred.remap_constness(&mut param_env);\n \n         if !self.can_cache_candidate(&candidate) {\n             debug!(?pred, ?candidate, \"insert_candidate_cache - candidate is not cacheable\");"}, {"sha": "8e4cd2392e03bf5edc9470e256c3960af4295db1", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -1803,7 +1803,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .source_map()\n                 .span_to_snippet(range_end.expr.span)\n                 .map(|s| format!(\" from `{s}`\"))\n-                .unwrap_or(String::new());\n+                .unwrap_or_default();\n             err.span_suggestion(\n                 range_start.span.shrink_to_hi(),\n                 &format!(\"to set the remaining fields{instead}, separate the last named field with a comma\"),\n@@ -2362,7 +2362,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 false\n             };\n         let expr_snippet =\n-            self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap_or(String::new());\n+            self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap_or_default();\n         let is_wrapped = expr_snippet.starts_with('(') && expr_snippet.ends_with(')');\n         let after_open = expr.span.lo() + rustc_span::BytePos(1);\n         let before_close = expr.span.hi() - rustc_span::BytePos(1);"}, {"sha": "1555f4f3fd6a6bc920440508a8d3289fb546a481", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -481,6 +481,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.set_tainted_by_errors();\n         let tcx = self.tcx;\n \n+        // Get the argument span in the context of the call span so that\n+        // suggestions and labels are (more) correct when an arg is a\n+        // macro invocation.\n+        let normalize_span = |span: Span| -> Span {\n+            let normalized_span = span.find_ancestor_inside(error_span).unwrap_or(span);\n+            // Sometimes macros mess up the spans, so do not normalize the\n+            // arg span to equal the error span, because that's less useful\n+            // than pointing out the arg expr in the wrong context.\n+            if normalized_span.source_equal(error_span) { span } else { normalized_span }\n+        };\n+\n         // Precompute the provided types and spans, since that's all we typically need for below\n         let provided_arg_tys: IndexVec<ProvidedIdx, (Ty<'tcx>, Span)> = provided_args\n             .iter()\n@@ -490,7 +501,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n                     .unwrap_or_else(|| tcx.ty_error());\n-                (self.resolve_vars_if_possible(ty), expr.span)\n+                (self.resolve_vars_if_possible(ty), normalize_span(expr.span))\n             })\n             .collect();\n         let callee_expr = match &call_expr.peel_blocks().kind {\n@@ -600,19 +611,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Take some care with spans, so we don't suggest wrapping a macro's\n                 // innards in parenthesis, for example.\n                 if satisfied\n-                    && let Some(lo) =\n-                        provided_args[mismatch_idx.into()].span.find_ancestor_inside(error_span)\n-                    && let Some(hi) = provided_args[(mismatch_idx + tys.len() - 1).into()]\n-                        .span\n-                        .find_ancestor_inside(error_span)\n+                    && let Some((_, lo)) =\n+                        provided_arg_tys.get(ProvidedIdx::from_usize(mismatch_idx))\n+                    && let Some((_, hi)) =\n+                        provided_arg_tys.get(ProvidedIdx::from_usize(mismatch_idx + tys.len() - 1))\n                 {\n                     let mut err;\n                     if tys.len() == 1 {\n                         // A tuple wrap suggestion actually occurs within,\n                         // so don't do anything special here.\n                         err = self.report_and_explain_type_error(\n                             TypeTrace::types(\n-                                &self.misc(lo),\n+                                &self.misc(*lo),\n                                 true,\n                                 formal_and_expected_inputs[mismatch_idx.into()].1,\n                                 provided_arg_tys[mismatch_idx.into()].0,\n@@ -1052,7 +1062,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let suggestion_text = if let Some(provided_idx) = provided_idx\n                     && let (_, provided_span) = provided_arg_tys[*provided_idx]\n                     && let Ok(arg_text) =\n-                        source_map.span_to_snippet(provided_span.source_callsite())\n+                        source_map.span_to_snippet(provided_span)\n                 {\n                     arg_text\n                 } else {"}, {"sha": "ded0888c33e15db96d8139245f4fed5553d395ac", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -72,9 +72,8 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n     }\n \n     fn mark_consumed(&mut self, consumer: HirId, target: TrackedValue) {\n-        if !self.places.consumed.contains_key(&consumer) {\n-            self.places.consumed.insert(consumer, <_>::default());\n-        }\n+        self.places.consumed.entry(consumer).or_insert_with(|| <_>::default());\n+\n         debug!(?consumer, ?target, \"mark_consumed\");\n         self.places.consumed.get_mut(&consumer).map(|places| places.insert(target));\n     }"}, {"sha": "cacbd54b6c246433ac8f93e7467a9e960c5b7769", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -178,6 +178,8 @@ pub struct BTreeMap<\n     length: usize,\n     /// `ManuallyDrop` to control drop order (needs to be dropped after all the nodes).\n     pub(super) alloc: ManuallyDrop<A>,\n+    // For dropck; the `Box` avoids making the `Unpin` impl more strict than before\n+    _marker: PhantomData<crate::boxed::Box<(K, V)>>,\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n@@ -187,6 +189,19 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V, A: Allocator + Clone> Drop for BTr\n     }\n }\n \n+// FIXME: This implementation is \"wrong\", but changing it would be a breaking change.\n+// (The bounds of the automatic `UnwindSafe` implementation have been like this since Rust 1.50.)\n+// Maybe we can fix it nonetheless with a crater run, or if the `UnwindSafe`\n+// traits are deprecated, or disarmed (no longer causing hard errors) in the future.\n+#[stable(feature = \"btree_unwindsafe\", since = \"1.64.0\")]\n+impl<K, V, A: Allocator + Clone> core::panic::UnwindSafe for BTreeMap<K, V, A>\n+where\n+    A: core::panic::UnwindSafe,\n+    K: core::panic::RefUnwindSafe,\n+    V: core::panic::RefUnwindSafe,\n+{\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone, A: Allocator + Clone> Clone for BTreeMap<K, V, A> {\n     fn clone(&self) -> BTreeMap<K, V, A> {\n@@ -204,6 +219,7 @@ impl<K: Clone, V: Clone, A: Allocator + Clone> Clone for BTreeMap<K, V, A> {\n                         root: Some(Root::new(alloc.clone())),\n                         length: 0,\n                         alloc: ManuallyDrop::new(alloc),\n+                        _marker: PhantomData,\n                     };\n \n                     {\n@@ -567,7 +583,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n     #[must_use]\n     pub const fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(Global) }\n+        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(Global), _marker: PhantomData }\n     }\n }\n \n@@ -593,6 +609,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n             root: mem::replace(&mut self.root, None),\n             length: mem::replace(&mut self.length, 0),\n             alloc: self.alloc.clone(),\n+            _marker: PhantomData,\n         });\n     }\n \n@@ -615,7 +632,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// ```\n     #[unstable(feature = \"btreemap_alloc\", issue = \"32838\")]\n     pub fn new_in(alloc: A) -> BTreeMap<K, V, A> {\n-        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(alloc) }\n+        BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(alloc), _marker: PhantomData }\n     }\n }\n \n@@ -1320,7 +1337,12 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n         let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n         self.length = new_left_len;\n \n-        BTreeMap { root: Some(right_root), length: right_len, alloc: self.alloc.clone() }\n+        BTreeMap {\n+            root: Some(right_root),\n+            length: right_len,\n+            alloc: self.alloc.clone(),\n+            _marker: PhantomData,\n+        }\n     }\n \n     /// Creates an iterator that visits all elements (key-value pairs) in\n@@ -1445,7 +1467,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n         let mut root = Root::new(alloc.clone());\n         let mut length = 0;\n         root.bulk_push(DedupSortedIter::new(iter.into_iter()), &mut length, alloc.clone());\n-        BTreeMap { root: Some(root), length, alloc: ManuallyDrop::new(alloc) }\n+        BTreeMap { root: Some(root), length, alloc: ManuallyDrop::new(alloc), _marker: PhantomData }\n     }\n }\n "}, {"sha": "b1f5559dcfc17e63161cacaa7b42c7426730536b", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -195,6 +195,41 @@ impl<B, C> ControlFlow<B, C> {\n             ControlFlow::Break(x) => ControlFlow::Break(f(x)),\n         }\n     }\n+\n+    /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n+    /// `ControlFlow` was `Continue` and `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// assert_eq!(ControlFlow::<i32, String>::Break(3).continue_value(), None);\n+    /// assert_eq!(ControlFlow::<String, i32>::Continue(3).continue_value(), Some(3));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn continue_value(self) -> Option<C> {\n+        match self {\n+            ControlFlow::Continue(x) => Some(x),\n+            ControlFlow::Break(..) => None,\n+        }\n+    }\n+\n+    /// Maps `ControlFlow<B, C>` to `ControlFlow<B, T>` by applying a function\n+    /// to the continue value in case it exists.\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn map_continue<T, F>(self, f: F) -> ControlFlow<B, T>\n+    where\n+        F: FnOnce(C) -> T,\n+    {\n+        match self {\n+            ControlFlow::Continue(x) => ControlFlow::Continue(f(x)),\n+            ControlFlow::Break(x) => ControlFlow::Break(x),\n+        }\n+    }\n }\n \n /// These are used only as part of implementing the iterator adapters."}, {"sha": "a463bc41db7aa4b384a96de149253e1a306d12b5", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -356,7 +356,7 @@ impl From<OwnedFd> for crate::net::UdpSocket {\n     }\n }\n \n-#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+#[stable(feature = \"asfd_ptrs\", since = \"1.64.0\")]\n /// This impl allows implementing traits that require `AsFd` on Arc.\n /// ```\n /// # #[cfg(any(unix, target_os = \"wasi\"))] mod group_cfg {\n@@ -379,7 +379,7 @@ impl<T: AsFd> AsFd for crate::sync::Arc<T> {\n     }\n }\n \n-#[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+#[stable(feature = \"asfd_ptrs\", since = \"1.64.0\")]\n impl<T: AsFd> AsFd for Box<T> {\n     #[inline]\n     fn as_fd(&self) -> BorrowedFd<'_> {"}, {"sha": "8d5b540212a17c9be272c66d14f6b84a96049c44", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -240,25 +240,34 @@ pub fn futex_wake_all(futex: &AtomicU32) {\n }\n \n #[cfg(target_os = \"fuchsia\")]\n-mod zircon {\n-    type zx_time_t = i64;\n-    type zx_futex_t = crate::sync::atomic::AtomicU32;\n-    type zx_handle_t = u32;\n-    type zx_status_t = i32;\n+pub mod zircon {\n+    pub type zx_futex_t = crate::sync::atomic::AtomicU32;\n+    pub type zx_handle_t = u32;\n+    pub type zx_status_t = i32;\n+    pub type zx_time_t = i64;\n \n     pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n-    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     pub const ZX_TIME_INFINITE: zx_time_t = zx_time_t::MAX;\n \n+    pub const ZX_OK: zx_status_t = 0;\n+    pub const ZX_ERR_INVALID_ARGS: zx_status_t = -10;\n+    pub const ZX_ERR_BAD_HANDLE: zx_status_t = -11;\n+    pub const ZX_ERR_WRONG_TYPE: zx_status_t = -12;\n+    pub const ZX_ERR_BAD_STATE: zx_status_t = -20;\n+    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     extern \"C\" {\n+        pub fn zx_clock_get_monotonic() -> zx_time_t;\n         pub fn zx_futex_wait(\n             value_ptr: *const zx_futex_t,\n             current_value: zx_futex_t,\n             new_futex_owner: zx_handle_t,\n             deadline: zx_time_t,\n         ) -> zx_status_t;\n         pub fn zx_futex_wake(value_ptr: *const zx_futex_t, wake_count: u32) -> zx_status_t;\n-        pub fn zx_clock_get_monotonic() -> zx_time_t;\n+        pub fn zx_futex_wake_single_owner(value_ptr: *const zx_futex_t) -> zx_status_t;\n+        pub fn zx_thread_self() -> zx_handle_t;\n     }\n }\n \n@@ -287,3 +296,8 @@ pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe { zircon::zx_futex_wake(futex, 1) };\n     false\n }\n+\n+#[cfg(target_os = \"fuchsia\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe { zircon::zx_futex_wake(futex, u32::MAX) };\n+}"}, {"sha": "ce427599c3bddc9ace0a1add4647dd8d51521a82", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -0,0 +1,165 @@\n+//! A priority inheriting mutex for Fuchsia.\n+//!\n+//! This is a port of the [mutex in Fuchsia's libsync]. Contrary to the original,\n+//! it does not abort the process when reentrant locking is detected, but deadlocks.\n+//!\n+//! Priority inheritance is achieved by storing the owning thread's handle in an\n+//! atomic variable. Fuchsia's futex operations support setting an owner thread\n+//! for a futex, which can boost that thread's priority while the futex is waited\n+//! upon.\n+//!\n+//! libsync is licenced under the following BSD-style licence:\n+//!\n+//! Copyright 2016 The Fuchsia Authors.\n+//!\n+//! Redistribution and use in source and binary forms, with or without\n+//! modification, are permitted provided that the following conditions are\n+//! met:\n+//!\n+//!    * Redistributions of source code must retain the above copyright\n+//!      notice, this list of conditions and the following disclaimer.\n+//!    * Redistributions in binary form must reproduce the above\n+//!      copyright notice, this list of conditions and the following\n+//!      disclaimer in the documentation and/or other materials provided\n+//!      with the distribution.\n+//!\n+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//! \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+//! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+//! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+//! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+//! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+//! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+//! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+//! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+//! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//!\n+//! [mutex in Fuchsia's libsync]: https://cs.opensource.google/fuchsia/fuchsia/+/main:zircon/system/ulib/sync/mutex.c\n+\n+use crate::sync::atomic::{\n+    AtomicU32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::zircon::{\n+    zx_futex_wait, zx_futex_wake_single_owner, zx_handle_t, zx_thread_self, ZX_ERR_BAD_HANDLE,\n+    ZX_ERR_BAD_STATE, ZX_ERR_INVALID_ARGS, ZX_ERR_TIMED_OUT, ZX_ERR_WRONG_TYPE, ZX_OK,\n+    ZX_TIME_INFINITE,\n+};\n+\n+// The lowest two bits of a `zx_handle_t` are always set, so the lowest bit is used to mark the\n+// mutex as contested by clearing it.\n+const CONTESTED_BIT: u32 = 1;\n+// This can never be a valid `zx_handle_t`.\n+const UNLOCKED: u32 = 0;\n+\n+pub type MovableMutex = Mutex;\n+\n+pub struct Mutex {\n+    futex: AtomicU32,\n+}\n+\n+#[inline]\n+fn to_state(owner: zx_handle_t) -> u32 {\n+    owner\n+}\n+\n+#[inline]\n+fn to_owner(state: u32) -> zx_handle_t {\n+    state | CONTESTED_BIT\n+}\n+\n+#[inline]\n+fn is_contested(state: u32) -> bool {\n+    state & CONTESTED_BIT == 0\n+}\n+\n+#[inline]\n+fn mark_contested(state: u32) -> u32 {\n+    state & !CONTESTED_BIT\n+}\n+\n+impl Mutex {\n+    #[inline]\n+    pub const fn new() -> Mutex {\n+        Mutex { futex: AtomicU32::new(UNLOCKED) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let thread_self = zx_thread_self();\n+        self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed).is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let thread_self = zx_thread_self();\n+        if let Err(state) =\n+            self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed)\n+        {\n+            self.lock_contested(state, thread_self);\n+        }\n+    }\n+\n+    #[cold]\n+    fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n+        let owned_state = mark_contested(to_state(thread_self));\n+        loop {\n+            // Mark the mutex as contested if it is not already.\n+            let contested = mark_contested(state);\n+            if is_contested(state)\n+                || self.futex.compare_exchange(state, contested, Relaxed, Relaxed).is_ok()\n+            {\n+                // The mutex has been marked as contested, wait for the state to change.\n+                unsafe {\n+                    match zx_futex_wait(\n+                        &self.futex,\n+                        AtomicU32::new(contested),\n+                        to_owner(state),\n+                        ZX_TIME_INFINITE,\n+                    ) {\n+                        ZX_OK | ZX_ERR_BAD_STATE | ZX_ERR_TIMED_OUT => (),\n+                        // Note that if a thread handle is reused after its associated thread\n+                        // exits without unlocking the mutex, an arbitrary thread's priority\n+                        // could be boosted by the wait, but there is currently no way to\n+                        // prevent that.\n+                        ZX_ERR_INVALID_ARGS | ZX_ERR_BAD_HANDLE | ZX_ERR_WRONG_TYPE => {\n+                            panic!(\n+                                \"either the current thread is trying to lock a mutex it has\n+                                already locked, or the previous owner did not unlock the mutex\n+                                before exiting\"\n+                            )\n+                        }\n+                        error => panic!(\"unexpected error in zx_futex_wait: {error}\"),\n+                    }\n+                }\n+            }\n+\n+            // The state has changed or a wakeup occured, try to lock the mutex.\n+            match self.futex.compare_exchange(UNLOCKED, owned_state, Acquire, Relaxed) {\n+                Ok(_) => return,\n+                Err(updated) => state = updated,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        if is_contested(self.futex.swap(UNLOCKED, Release)) {\n+            // The woken thread will mark the mutex as contested again,\n+            // and return here, waking until there are no waiters left,\n+            // in which case this is a noop.\n+            self.wake();\n+        }\n+    }\n+\n+    #[cold]\n+    fn wake(&self) {\n+        unsafe {\n+            zx_futex_wake_single_owner(&self.futex);\n+        }\n+    }\n+}"}, {"sha": "c0576c17880e1127f94add57997e2c9862c33b68", "filename": "library/std/src/sys/unix/locks/futex_condvar.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -0,0 +1,58 @@\n+use super::Mutex;\n+use crate::sync::atomic::{AtomicU32, Ordering::Relaxed};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+use crate::time::Duration;\n+\n+pub type MovableCondvar = Condvar;\n+\n+pub struct Condvar {\n+    // The value of this atomic is simply incremented on every notification.\n+    // This is used by `.wait()` to not miss any notifications after\n+    // unlocking the mutex and before waiting for notifications.\n+    futex: AtomicU32,\n+}\n+\n+impl Condvar {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { futex: AtomicU32::new(0) }\n+    }\n+\n+    // All the memory orderings here are `Relaxed`,\n+    // because synchronization is done by unlocking and locking the mutex.\n+\n+    pub unsafe fn notify_one(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake(&self.futex);\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake_all(&self.futex);\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        self.wait_optional_timeout(mutex, None);\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n+        self.wait_optional_timeout(mutex, Some(timeout))\n+    }\n+\n+    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n+        // Examine the notification counter _before_ we unlock the mutex.\n+        let futex_value = self.futex.load(Relaxed);\n+\n+        // Unlock the mutex before going to sleep.\n+        mutex.unlock();\n+\n+        // Wait, but only if there hasn't been any\n+        // notification since we unlocked the mutex.\n+        let r = futex_wait(&self.futex, futex_value, timeout);\n+\n+        // Lock the mutex again.\n+        mutex.lock();\n+\n+        r\n+    }\n+}"}, {"sha": "99ba86e5f996dce0bb445c5e12c99d494b441fcf", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "renamed", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -2,11 +2,9 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n-use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n-use crate::time::Duration;\n+use crate::sys::futex::{futex_wait, futex_wake};\n \n pub type MovableMutex = Mutex;\n-pub type MovableCondvar = Condvar;\n \n pub struct Mutex {\n     /// 0: unlocked\n@@ -101,55 +99,3 @@ impl Mutex {\n         futex_wake(&self.futex);\n     }\n }\n-\n-pub struct Condvar {\n-    // The value of this atomic is simply incremented on every notification.\n-    // This is used by `.wait()` to not miss any notifications after\n-    // unlocking the mutex and before waiting for notifications.\n-    futex: AtomicU32,\n-}\n-\n-impl Condvar {\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Self { futex: AtomicU32::new(0) }\n-    }\n-\n-    // All the memory orderings here are `Relaxed`,\n-    // because synchronization is done by unlocking and locking the mutex.\n-\n-    pub unsafe fn notify_one(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake(&self.futex);\n-    }\n-\n-    pub unsafe fn notify_all(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake_all(&self.futex);\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.wait_optional_timeout(mutex, None);\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n-        self.wait_optional_timeout(mutex, Some(timeout))\n-    }\n-\n-    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n-        // Examine the notification counter _before_ we unlock the mutex.\n-        let futex_value = self.futex.load(Relaxed);\n-\n-        // Unlock the mutex before going to sleep.\n-        mutex.unlock();\n-\n-        // Wait, but only if there hasn't been any\n-        // notification since we unlocked the mutex.\n-        let r = futex_wait(&self.futex, futex_value, timeout);\n-\n-        // Lock the mutex again.\n-        mutex.lock();\n-\n-        r\n-    }\n-}", "previous_filename": "library/std/src/sys/unix/locks/futex.rs"}, {"sha": "f5f92f693583003d2cc590fb802a73905b1b3b5f", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -7,10 +7,19 @@ cfg_if::cfg_if! {\n         target_os = \"openbsd\",\n         target_os = \"dragonfly\",\n     ))] {\n-        mod futex;\n+        mod futex_mutex;\n         mod futex_rwlock;\n-        pub(crate) use futex::{Mutex, MovableMutex, MovableCondvar};\n+        mod futex_condvar;\n+        pub(crate) use futex_mutex::{Mutex, MovableMutex};\n         pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n+    } else if #[cfg(target_os = \"fuchsia\")] {\n+        mod fuchsia_mutex;\n+        mod futex_rwlock;\n+        mod futex_condvar;\n+        pub(crate) use fuchsia_mutex::{Mutex, MovableMutex};\n+        pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n     } else {\n         mod pthread_mutex;\n         mod pthread_rwlock;"}, {"sha": "4dd79af56300f78292f26974d0e9a24c04e7692c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -496,8 +496,7 @@ impl Item {\n         // Primitives and Keywords are written in the source code as private modules.\n         // The modules need to be private so that nobody actually uses them, but the\n         // keywords and primitives that they are documenting are public.\n-        let visibility = if matches!(&kind, ItemKind::KeywordItem(..) | ItemKind::PrimitiveItem(..))\n-        {\n+        let visibility = if matches!(&kind, ItemKind::KeywordItem | ItemKind::PrimitiveItem(..)) {\n             Visibility::Public\n         } else {\n             cx.tcx.visibility(def_id).clean(cx)\n@@ -769,7 +768,7 @@ pub(crate) enum ItemKind {\n     AssocTypeItem(Typedef, Vec<GenericBound>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n-    KeywordItem(Symbol),\n+    KeywordItem,\n }\n \n impl ItemKind {\n@@ -808,7 +807,7 @@ impl ItemKind {\n             | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | StrippedItem(_)\n-            | KeywordItem(_) => [].iter(),\n+            | KeywordItem => [].iter(),\n         }\n     }\n }"}, {"sha": "fa449a21b0c93dd2c909d333fe4247c062e76b66", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n             )\n         }));\n         m.items.extend(keywords.into_iter().map(|(def_id, kw)| {\n-            Item::from_def_id_and_parts(def_id, Some(kw), ItemKind::KeywordItem(kw), cx)\n+            Item::from_def_id_and_parts(def_id, Some(kw), ItemKind::KeywordItem, cx)\n         }));\n     }\n "}, {"sha": "c93897236db691f0e326052ac75837d25d285b18", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -69,7 +69,7 @@ pub(crate) trait DocFolder: Sized {\n             | AssocConstItem(..)\n             | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n-            | KeywordItem(_) => kind,\n+            | KeywordItem => kind,\n         }\n     }\n "}, {"sha": "b9774eb70ea02e8fbcc131c12ce835d23bd78b77", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::TyAssocTypeItem(..)\n             | clean::AssocTypeItem(..)\n             | clean::StrippedItem(..)\n-            | clean::KeywordItem(..) => {\n+            | clean::KeywordItem => {\n                 // FIXME: Do these need handling?\n                 // The person writing this comment doesn't know.\n                 // So would rather leave them to an expert,"}, {"sha": "0a7ee2005915baa6cbb977aefd12b44361962fdf", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -91,7 +91,7 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::TyAssocConstItem(..) | clean::AssocConstItem(..) => ItemType::AssocConst,\n             clean::TyAssocTypeItem(..) | clean::AssocTypeItem(..) => ItemType::AssocType,\n             clean::ForeignTypeItem => ItemType::ForeignType,\n-            clean::KeywordItem(..) => ItemType::Keyword,\n+            clean::KeywordItem => ItemType::Keyword,\n             clean::TraitAliasItem(..) => ItemType::TraitAlias,\n             clean::ProcMacroItem(ref mac) => match mac.kind {\n                 MacroKind::Bang => ItemType::Macro,"}, {"sha": "0cee114b346b2aa4790a361daa3ebccf65069ad7", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -104,7 +104,7 @@ pub(super) fn print_item(\n         clean::StaticItem(..) | clean::ForeignStaticItem(..) => \"Static \",\n         clean::ConstantItem(..) => \"Constant \",\n         clean::ForeignTypeItem => \"Foreign Type \",\n-        clean::KeywordItem(..) => \"Keyword \",\n+        clean::KeywordItem => \"Keyword \",\n         clean::OpaqueTyItem(..) => \"Opaque Type \",\n         clean::TraitAliasItem(..) => \"Trait Alias \",\n         _ => {\n@@ -175,7 +175,7 @@ pub(super) fn print_item(\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n         clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n-        clean::KeywordItem(_) => item_keyword(buf, cx, item),\n+        clean::KeywordItem => item_keyword(buf, cx, item),\n         clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n         clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n         _ => {"}, {"sha": "418d7c8353513527fa24aa4e86ec9cf21064af87", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -43,7 +43,7 @@ impl JsonRenderer<'_> {\n         let span = item.span(self.tcx);\n         let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n         let inner = match *item.kind {\n-            clean::KeywordItem(_) => return None,\n+            clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n                 match &**inner {\n                     // We document non-empty stripped modules as with `Module::is_stripped` set to\n@@ -269,7 +269,7 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n             default: Some(t.item_type.unwrap_or(t.type_).into_tcx(tcx)),\n         },\n         // `convert_item` early returns `None` for stripped items and keywords.\n-        KeywordItem(_) => unreachable!(),\n+        KeywordItem => unreachable!(),\n         StrippedItem(inner) => {\n             match *inner {\n                 ModuleItem(m) => ItemEnum::Module(Module {"}, {"sha": "e80a94fe749de79e09bf62e92117d2943067905a", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n                 | clean::ExternCrateItem { .. }\n                 | clean::ImportItem(_)\n                 | clean::PrimitiveItem(_)\n-                | clean::KeywordItem(_)\n+                | clean::KeywordItem\n                 // check for trait impl\n                 | clean::ImplItem(clean::Impl { trait_: Some(_), .. })\n         )"}, {"sha": "0d419042a10a47508097a8bf2102445f2a4cab54", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -98,7 +98,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             clean::PrimitiveItem(..) => {}\n \n             // Keywords are never stripped\n-            clean::KeywordItem(..) => {}\n+            clean::KeywordItem => {}\n         }\n \n         let fastreturn = match *i.kind {"}, {"sha": "0bb41977c97cac4d2bab4b8f61c02ca82898a663", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -43,7 +43,7 @@ pub(crate) trait DocVisitor: Sized {\n             | AssocConstItem(..)\n             | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n-            | KeywordItem(_) => {}\n+            | KeywordItem => {}\n         }\n     }\n "}, {"sha": "c58727df30cae10d0c271932e32d77395fa247fa", "filename": "src/test/ui/btreemap/btreemap_dropck.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -0,0 +1,16 @@\n+struct PrintOnDrop<'a>(&'a str);\n+\n+impl Drop for PrintOnDrop<'_> {\n+    fn drop(&mut self) {\n+        println!(\"printint: {}\", self.0);\n+    }\n+}\n+\n+use std::collections::BTreeMap;\n+use std::iter::FromIterator;\n+\n+fn main() {\n+    let s = String::from(\"Hello World!\");\n+    let _map = BTreeMap::from_iter([((), PrintOnDrop(&s))]);\n+    drop(s); //~ ERROR cannot move out of `s` because it is borrowed\n+}"}, {"sha": "e953e7ae82bb8443f17b230b9d465d2d5315a633", "filename": "src/test/ui/btreemap/btreemap_dropck.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_dropck.stderr?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -0,0 +1,13 @@\n+error[E0505]: cannot move out of `s` because it is borrowed\n+  --> $DIR/btreemap_dropck.rs:15:10\n+   |\n+LL |     let _map = BTreeMap::from_iter([((), PrintOnDrop(&s))]);\n+   |                                                      -- borrow of `s` occurs here\n+LL |     drop(s);\n+   |          ^ move out of `s` occurs here\n+LL | }\n+   | - borrow might be used here, when `_map` is dropped and runs the `Drop` code for type `BTreeMap`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0505`."}, {"sha": "3e9de765b12b2a0def675108dbb572287b76f1e0", "filename": "src/test/ui/generator/issue-52304.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fgenerator%2Fissue-52304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fgenerator%2Fissue-52304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-52304.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+pub fn example() -> impl Generator {\n+    || yield &1\n+}\n+\n+fn main() {}"}, {"sha": "2eea726a19c5aa6622a2365b1271ee2a11a00bb7", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -7,7 +7,7 @@ LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+   = note: downstream crates may implement trait `std::fmt::Debug` for type `OpaqueType`\n \n error: cannot implement trait on type alias impl trait\n   --> $DIR/negative-reasoning.rs:19:25"}, {"sha": "0d8e7289dc8a243e976b786d74a0fc05d2cceaf7", "filename": "src/test/ui/inference/deref-suggestion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -1,5 +1,5 @@\n macro_rules! borrow {\n-    ($x:expr) => { &$x } //~ ERROR mismatched types\n+    ($x:expr) => { &$x }\n }\n \n fn foo(_: String) {}\n@@ -32,6 +32,7 @@ fn main() {\n     foo(&mut \"aaa\".to_owned());\n     //~^ ERROR mismatched types\n     foo3(borrow!(0));\n+    //~^ ERROR mismatched types\n     foo4(&0);\n     assert_eq!(3i32, &3i32);\n     //~^ ERROR mismatched types"}, {"sha": "d729f2d682a6144dfff38221cc278569bd5844ec", "filename": "src/test/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fderef-suggestion.stderr?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -70,13 +70,10 @@ LL +     foo(\"aaa\".to_owned());\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:2:20\n+  --> $DIR/deref-suggestion.rs:34:10\n    |\n-LL |     ($x:expr) => { &$x }\n-   |                    ^^^ expected `u32`, found `&{integer}`\n-...\n LL |     foo3(borrow!(0));\n-   |     ---- ---------- in this macro invocation\n+   |     ---- ^^^^^^^^^^ expected `u32`, found `&{integer}`\n    |     |\n    |     arguments to this function are incorrect\n    |\n@@ -85,18 +82,17 @@ note: function defined here\n    |\n LL | fn foo3(_: u32) {}\n    |    ^^^^ ------\n-   = note: this error originates in the macro `borrow` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:36:5\n+  --> $DIR/deref-suggestion.rs:37:5\n    |\n LL |     assert_eq!(3i32, &3i32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`\n    |\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:39:17\n+  --> $DIR/deref-suggestion.rs:40:17\n    |\n LL |     let s = S { u };\n    |                 ^\n@@ -105,7 +101,7 @@ LL |     let s = S { u };\n    |                 help: consider borrowing here: `u: &u`\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:41:20\n+  --> $DIR/deref-suggestion.rs:42:20\n    |\n LL |     let s = S { u: u };\n    |                    ^\n@@ -114,7 +110,7 @@ LL |     let s = S { u: u };\n    |                    help: consider borrowing here: `&u`\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:44:17\n+  --> $DIR/deref-suggestion.rs:45:17\n    |\n LL |     let r = R { i };\n    |                 ^ expected `u32`, found `&{integer}`\n@@ -125,7 +121,7 @@ LL |     let r = R { i: *i };\n    |                 ++++\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:46:20\n+  --> $DIR/deref-suggestion.rs:47:20\n    |\n LL |     let r = R { i: i };\n    |                    ^ expected `u32`, found `&{integer}`\n@@ -136,7 +132,7 @@ LL |     let r = R { i: *i };\n    |                    +\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:55:9\n+  --> $DIR/deref-suggestion.rs:56:9\n    |\n LL |         b\n    |         ^ expected `i32`, found `&{integer}`\n@@ -147,7 +143,7 @@ LL |         *b\n    |         +\n \n error[E0308]: mismatched types\n-  --> $DIR/deref-suggestion.rs:63:9\n+  --> $DIR/deref-suggestion.rs:64:9\n    |\n LL |         b\n    |         ^ expected `i32`, found `&{integer}`\n@@ -158,7 +154,7 @@ LL |         *b\n    |         +\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/deref-suggestion.rs:68:12\n+  --> $DIR/deref-suggestion.rs:69:12\n    |\n LL |        let val = if true {\n    |   _______________-"}, {"sha": "7287639c61dde128fc2f4d663859238c76af45c0", "filename": "src/test/ui/issues/issue-72554.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -1,10 +1,13 @@\n use std::collections::BTreeSet;\n \n #[derive(Hash)]\n-pub enum ElemDerived { //~ ERROR recursive type `ElemDerived` has infinite size\n+pub enum ElemDerived {\n+    //~^ ERROR recursive type `ElemDerived` has infinite size\n+    //~| ERROR cycle detected when computing drop-check constraints for `ElemDerived`\n     A(ElemDerived)\n }\n \n+\n pub enum Elem {\n     Derived(ElemDerived)\n }"}, {"sha": "3e5adcae133ca7a7c0e6bd613b6355028ab6cea7", "filename": "src/test/ui/issues/issue-72554.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af7ab3447079fddc51c6c7749b160d24769f7c16/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr?ref=af7ab3447079fddc51c6c7749b160d24769f7c16", "patch": "@@ -3,6 +3,7 @@ error[E0072]: recursive type `ElemDerived` has infinite size\n    |\n LL | pub enum ElemDerived {\n    | ^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size\n+...\n LL |     A(ElemDerived)\n    |       ----------- recursive without indirection\n    |\n@@ -11,6 +12,20 @@ help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ElemDerived\n LL |     A(Box<ElemDerived>)\n    |       ++++           +\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing drop-check constraints for `ElemDerived`\n+  --> $DIR/issue-72554.rs:4:1\n+   |\n+LL | pub enum ElemDerived {\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which immediately requires computing drop-check constraints for `ElemDerived` again\n+note: cycle used when computing drop-check constraints for `Elem`\n+  --> $DIR/issue-72554.rs:11:1\n+   |\n+LL | pub enum Elem {\n+   | ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0072`.\n+Some errors have detailed explanations: E0072, E0391.\n+For more information about an error, try `rustc --explain E0072`."}]}