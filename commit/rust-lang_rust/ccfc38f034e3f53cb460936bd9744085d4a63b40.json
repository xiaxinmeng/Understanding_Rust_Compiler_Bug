{"sha": "ccfc38f034e3f53cb460936bd9744085d4a63b40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjZmMzOGYwMzRlM2Y1M2NiNDYwOTM2YmQ5NzQ0MDg1ZDRhNjNiNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-04T14:20:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-04T14:20:44Z"}, "message": "Auto merge of #37167 - nikomatsakis:jroesch-issue-18937, r=pnkfelix\n\ndetect extra region requirements in impls\n\nThe current \"compare method\" check fails to check for the \"region obligations\" that accrue in the fulfillment context. This branch switches that code to create a `FnCtxt` so that it can invoke the regionck code. Previous crater runs (I haven't done one with the latest tip) have found some small number of affected crates, so I went ahead and introduced a warning cycle. I will kick off a crater run with this branch shortly.\n\nThis is a [breaking-change] because previously unsound code was accepted. The crater runs also revealed some cases where legitimate code was no longer type-checking, so the branch contains one additional (but orthogonal) change. It improves the elaborator so that we elaborate region requirements more thoroughly. In particular, if we know that `&'a T: 'b`, we now deduce that `T: 'b` and `'a: 'b`.\n\nI invested a certain amount of effort in getting a good error message. The error message looks like this:\n\n```\nerror[E0276]: impl has stricter requirements than trait\n  --> traits-elaborate-projection-region.rs:33:5\n   |\n21 |     fn foo() where T: 'a;\n   |     --------------------- definition of `foo` from trait\n...\n33 |     fn foo() where U: 'a { }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #18937 <https://github.com/rust-lang/rust/issues/18937>\nnote: lint level defined here\n  --> traits-elaborate-projection-region.rs:12:9\n   |\n12 | #![deny(extra_requirement_in_impl)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nObviously the warning only prints if this is a _new_ error (that resulted from the bugfix). But all existing errors that fit this description are updated to follow the general template. In order to get the lint to preserve the span-labels and the error code, I separate out the core `Diagnostic` type (which encapsulates the error code, message, span, and children) from the `DiagnosticBuilder` (which layers on a `Handler` that can be used to report errors). I also extended `add_lint` with an alternative `add_lint_diagnostic` that takes in a full diagnostic (cc @jonathandturner for those changes). This doesn't feel ideal but feels like it's moving in the right direction =).\n\nr? @pnkfelix\ncc @arielb1\n\nFixes #18937", "tree": {"sha": "2f7c7808ef2f74a2c40d4c296808be5e2b8edf03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f7c7808ef2f74a2c40d4c296808be5e2b8edf03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccfc38f034e3f53cb460936bd9744085d4a63b40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccfc38f034e3f53cb460936bd9744085d4a63b40", "html_url": "https://github.com/rust-lang/rust/commit/ccfc38f034e3f53cb460936bd9744085d4a63b40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccfc38f034e3f53cb460936bd9744085d4a63b40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2bc30b03fa4bf5425d080710f681f36f58f1706", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bc30b03fa4bf5425d080710f681f36f58f1706", "html_url": "https://github.com/rust-lang/rust/commit/d2bc30b03fa4bf5425d080710f681f36f58f1706"}, {"sha": "4501e5a52f6268a156e95a8fe72ae17c47bf6ee3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4501e5a52f6268a156e95a8fe72ae17c47bf6ee3", "html_url": "https://github.com/rust-lang/rust/commit/4501e5a52f6268a156e95a8fe72ae17c47bf6ee3"}], "stats": {"total": 2498, "additions": 1713, "deletions": 785}, "files": [{"sha": "47c0bc5fd60c56f8a9daabbf4f65111b9a475dcd", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 73, "deletions": 22, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -245,6 +245,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n         for error in errors {\n+            debug!(\"report_region_errors: error = {:?}\", error);\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup).emit();\n@@ -299,44 +300,64 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut bound_failures = Vec::new();\n \n         for error in errors {\n+            // Check whether we can process this error into some other\n+            // form; if not, fall through.\n             match *error {\n                 ConcreteFailure(ref origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n-                    match free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::ConcreteFailure(\n-                                    origin.clone(),\n-                                    sub,\n-                                    sup));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n-                        }\n-                        _ => {\n-                            other_errors.push(error.clone());\n-                        }\n+                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n+                        // When comparing an impl method against a\n+                        // trait method, it is not helpful to suggest\n+                        // changes to the impl method.  This is\n+                        // because the impl method signature is being\n+                        // checked using the trait's environment, so\n+                        // usually the changes we suggest would\n+                        // actually have to be applied to the *trait*\n+                        // method (and it's not clear that the trait\n+                        // method is even under the user's control).\n+                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                        origins.push(\n+                            ProcessedErrorOrigin::ConcreteFailure(\n+                                origin.clone(),\n+                                sub,\n+                                sup));\n+                        append_to_same_regions(&mut same_regions, &same_frs);\n+                        continue;\n                     }\n                 }\n-                SubSupConflict(ref var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n-                    match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::VariableFailure(\n-                                    var_origin.clone()));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n+                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n+                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n+                    match (sub_origin, sup_origin) {\n+                        (&SubregionOrigin::CompareImplMethodObligation { .. }, _) => {\n+                            // As above, when comparing an impl method\n+                            // against a trait method, it is not helpful\n+                            // to suggest changes to the impl method.\n                         }\n-                        None => {\n-                            other_errors.push(error.clone());\n+                        (_, &SubregionOrigin::CompareImplMethodObligation { .. }) => {\n+                            // See above.\n+                        }\n+                        _ => {\n+                            if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                                origins.push(\n+                                    ProcessedErrorOrigin::VariableFailure(\n+                                        var_origin.clone()));\n+                                append_to_same_regions(&mut same_regions, &same_frs);\n+                                continue;\n+                            }\n                         }\n                     }\n                 }\n                 GenericBoundFailure(ref origin, ref kind, region) => {\n                     bound_failures.push((origin.clone(), kind.clone(), region));\n+                    continue;\n                 }\n                 ProcessedErrors(..) => {\n                     bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n                 }\n             }\n+\n+            // No changes to this error.\n+            other_errors.push(error.clone());\n         }\n \n         // ok, let's pull together the errors, sorted in an order that\n@@ -630,6 +651,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n+        if let SubregionOrigin::CompareImplMethodObligation {\n+            span, item_name, impl_item_def_id, trait_item_def_id, lint_id\n+        } = origin {\n+            self.report_extra_impl_obligation(span,\n+                                              item_name,\n+                                              impl_item_def_id,\n+                                              trait_item_def_id,\n+                                              &format!(\"`{}: {}`\", bound_kind, sub),\n+                                              lint_id)\n+                .emit();\n+            return;\n+        }\n+\n         let mut err = match *sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n@@ -947,6 +981,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"\");\n                 err\n             }\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub),\n+                                                  lint_id)\n+            }\n         }\n     }\n \n@@ -1792,6 +1838,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"...so that references are valid when the destructor \\\n                      runs\");\n             }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(\n+                    span,\n+                    \"...so that the definition in impl matches the definition from the trait\");\n+            }\n         }\n     }\n }"}, {"sha": "35802aef5931f78fdc0492f8642fbac7e5674944", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -355,6 +355,19 @@ pub enum SubregionOrigin<'tcx> {\n \n     // Region constraint arriving from destructor safety\n     SafeDestructor(Span),\n+\n+    // Comparing the signature and requirements of an impl method against\n+    // the containing trait.\n+    CompareImplMethodObligation {\n+        span: Span,\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+\n+        // this is `Some(_)` if this error arises from the bug fix for\n+        // #18937. This is a temporary measure.\n+        lint_id: Option<ast::NodeId>,\n+    },\n }\n \n /// Places that type/region parameters can appear.\n@@ -1147,16 +1160,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn region_outlives_predicate(&self,\n-                                     span: Span,\n+                                     cause: &traits::ObligationCause<'tcx>,\n                                      predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n         -> UnitResult<'tcx>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = RelateRegionParamBound(span);\n+            let origin =\n+                SubregionOrigin::from_obligation_cause(cause,\n+                                                       || RelateRegionParamBound(cause.span));\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, span, &skol_map, snapshot)?;\n+            self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n         })\n     }\n@@ -1786,6 +1801,32 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n+            CompareImplMethodObligation { span, .. } => span,\n+        }\n+    }\n+\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n+                                    default: F)\n+                                    -> Self\n+        where F: FnOnce() -> Self\n+    {\n+        match cause.code {\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n+                                                                       impl_item_def_id,\n+                                                                       trait_item_def_id,\n+                                                                       lint_id } =>\n+                SubregionOrigin::CompareImplMethodObligation {\n+                    span: cause.span,\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                    lint_id: lint_id,\n+                },\n+\n+            _ => default(),\n         }\n     }\n }"}, {"sha": "82a46f76401d52a2a559bc6edd0fce550069009a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -198,6 +198,12 @@ declare_lint! {\n     \"patterns in functions without body were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub EXTRA_REQUIREMENT_IN_IMPL,\n+    Warn,\n+    \"detects extra requirements in impls that were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -235,7 +241,8 @@ impl LintPass for HardwiredLints {\n             HR_LIFETIME_IN_ASSOC_TYPE,\n             LIFETIME_UNDERSCORE,\n             SAFE_EXTERN_STATICS,\n-            PATTERNS_IN_FNS_WITHOUT_BODY\n+            PATTERNS_IN_FNS_WITHOUT_BODY,\n+            EXTRA_REQUIREMENT_IN_IMPL\n         )\n     }\n }"}, {"sha": "f08aa2eb49f72bd0b8a5701ad7450a7249faf5ea", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 87, "deletions": 35, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -38,11 +38,12 @@ use util::nodemap::FnvHashMap;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n+use std::fmt;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n-use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use syntax_pos::{MultiSpan, Span};\n+use errors::{self, Diagnostic, DiagnosticBuilder};\n use hir;\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n@@ -80,6 +81,46 @@ pub struct LintStore {\n     lint_cap: Option<Level>,\n }\n \n+/// When you call `add_lint` on the session, you wind up storing one\n+/// of these, which records a \"potential lint\" at a particular point.\n+#[derive(PartialEq)]\n+pub struct EarlyLint {\n+    /// what lint is this? (e.g., `dead_code`)\n+    pub id: LintId,\n+\n+    /// the main message\n+    pub diagnostic: Diagnostic,\n+}\n+\n+impl fmt::Debug for EarlyLint {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"EarlyLint\")\n+            .field(\"id\", &self.id)\n+            .field(\"span\", &self.diagnostic.span)\n+            .field(\"diagnostic\", &self.diagnostic)\n+            .finish()\n+    }\n+}\n+\n+pub trait IntoEarlyLint {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint;\n+}\n+\n+impl<'a> IntoEarlyLint for (Span, &'a str) {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint {\n+        let (span, msg) = self;\n+        let mut diagnostic = Diagnostic::new(errors::Level::Warning, msg);\n+        diagnostic.set_span(span);\n+        EarlyLint { id: id, diagnostic: diagnostic }\n+    }\n+}\n+\n+impl IntoEarlyLint for Diagnostic {\n+    fn into_early_lint(self, id: LintId) -> EarlyLint {\n+        EarlyLint { id: id, diagnostic: self }\n+    }\n+}\n+\n /// Extra information for a future incompatibility lint. See the call\n /// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n /// guidelines.\n@@ -388,22 +429,24 @@ pub fn gather_attr(attr: &ast::Attribute)\n /// in trans that run after the main lint pass is finished. Most\n /// lints elsewhere in the compiler should call\n /// `Session::add_lint()` instead.\n-pub fn raw_emit_lint(sess: &Session,\n-                     lints: &LintStore,\n-                     lint: &'static Lint,\n-                     lvlsrc: LevelSource,\n-                     span: Option<Span>,\n-                     msg: &str) {\n+pub fn raw_emit_lint<S: Into<MultiSpan>>(sess: &Session,\n+                                         lints: &LintStore,\n+                                         lint: &'static Lint,\n+                                         lvlsrc: LevelSource,\n+                                         span: Option<S>,\n+                                         msg: &str) {\n     raw_struct_lint(sess, lints, lint, lvlsrc, span, msg).emit();\n }\n \n-pub fn raw_struct_lint<'a>(sess: &'a Session,\n-                           lints: &LintStore,\n-                           lint: &'static Lint,\n-                           lvlsrc: LevelSource,\n-                           span: Option<Span>,\n-                           msg: &str)\n-                           -> DiagnosticBuilder<'a> {\n+pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n+                              lints: &LintStore,\n+                              lint: &'static Lint,\n+                              lvlsrc: LevelSource,\n+                              span: Option<S>,\n+                              msg: &str)\n+                              -> DiagnosticBuilder<'a>\n+    where S: Into<MultiSpan>\n+{\n     let (mut level, source) = lvlsrc;\n     if level == Allow {\n         return sess.diagnostic().struct_dummy();\n@@ -496,11 +539,11 @@ pub trait LintContext: Sized {\n         raw_emit_lint(&self.sess(), self.lints(), lint, (level, src), span, msg);\n     }\n \n-    fn lookup(&self,\n-              lint: &'static Lint,\n-              span: Option<Span>,\n-              msg: &str)\n-              -> DiagnosticBuilder {\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n         let (level, src) = match self.level_src(lint) {\n             None => return self.sess().diagnostic().struct_dummy(),\n             Some(pair) => pair,\n@@ -514,11 +557,20 @@ pub trait LintContext: Sized {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    fn struct_span_lint(&self,\n-                        lint: &'static Lint,\n-                        span: Span,\n-                        msg: &str)\n-                        -> DiagnosticBuilder {\n+    fn early_lint(&self, early_lint: EarlyLint) {\n+        let span = early_lint.diagnostic.span.primary_span().expect(\"early lint w/o primary span\");\n+        let mut err = self.struct_span_lint(early_lint.id.lint,\n+                                            span,\n+                                            &early_lint.diagnostic.message);\n+        err.copy_details_not_message(&early_lint.diagnostic);\n+        err.emit();\n+    }\n+\n+    fn struct_span_lint<S: Into<MultiSpan>>(&self,\n+                                            lint: &'static Lint,\n+                                            span: S,\n+                                            msg: &str)\n+                                            -> DiagnosticBuilder {\n         self.lookup(lint, Some(span), msg)\n     }\n \n@@ -1065,8 +1117,8 @@ impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n-            for (lint_id, span, msg) in lints {\n-                self.cx.span_lint(lint_id.lint, span, &msg[..])\n+            for early_lint in lints {\n+                self.cx.early_lint(early_lint);\n             }\n         }\n     }\n@@ -1211,10 +1263,10 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v {\n-            span_bug!(span,\n-                      \"unprocessed lint {} at {}: {}\",\n-                      lint.to_string(), tcx.map.node_to_string(*id), *msg)\n+        for early_lint in v {\n+            span_bug!(early_lint.diagnostic.span.clone(),\n+                      \"unprocessed lint {:?} at {}\",\n+                      early_lint, tcx.map.node_to_string(*id));\n         }\n     }\n \n@@ -1229,8 +1281,8 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     cx.with_lint_attrs(&krate.attrs, |cx| {\n         // Lints may be assigned to the whole crate.\n         if let Some(lints) = cx.sess.lints.borrow_mut().remove(&ast::CRATE_NODE_ID) {\n-            for (lint_id, span, msg) in lints {\n-                cx.span_lint(lint_id.lint, span, &msg[..])\n+            for early_lint in lints {\n+                cx.early_lint(early_lint);\n             }\n         }\n \n@@ -1249,8 +1301,8 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n     for (_, v) in sess.lints.borrow().iter() {\n-        for &(lint, span, ref msg) in v {\n-            span_bug!(span, \"unprocessed lint {}: {}\", lint.to_string(), *msg)\n+        for early_lint in v {\n+            span_bug!(early_lint.diagnostic.span.clone(), \"unprocessed lint {:?}\", early_lint);\n         }\n     }\n }"}, {"sha": "34e0ce7da14613b1a87011c5a59892616cc0fa3b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -41,7 +41,7 @@ use hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, FutureIncompatibleInfo};\n+                        raw_struct_lint, FutureIncompatibleInfo, EarlyLint, IntoEarlyLint};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "b4dadbf7961fb46593dacd228cabef4a327d572e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -74,7 +74,7 @@ pub struct Session {\n     pub local_crate_source_file: Option<PathBuf>,\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<NodeMap<Vec<(lint::LintId, Span, String)>>>,\n+    pub lints: RefCell<NodeMap<Vec<lint::EarlyLint>>>,\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n     /// that have been set once, but should not be set again, in order to avoid\n     /// redundantly verbose output (Issue #24690).\n@@ -262,17 +262,26 @@ impl Session {\n                     lint: &'static lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n-                    msg: String) {\n+                    msg: String)\n+    {\n+        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n+    }\n+    pub fn add_lint_diagnostic<M>(&self,\n+                                  lint: &'static lint::Lint,\n+                                  id: ast::NodeId,\n+                                  msg: M)\n+        where M: lint::IntoEarlyLint,\n+    {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n+        let early_lint = msg.into_early_lint(lint_id);\n         if let Some(arr) = lints.get_mut(&id) {\n-            let tuple = (lint_id, sp, msg);\n-            if !arr.contains(&tuple) {\n-                arr.push(tuple);\n+            if !arr.contains(&early_lint) {\n+                arr.push(early_lint);\n             }\n             return;\n         }\n-        lints.insert(id, vec![(lint_id, sp, msg)]);\n+        lints.insert(id, vec![early_lint]);\n     }\n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();"}, {"sha": "89c8162456c427e7e80a7de27190bfa33e1ce4b8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -27,6 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt, TypeOrigin};\n+use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n@@ -36,6 +37,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n use std::fmt;\n+use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -417,19 +419,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_overflow_error(&cycle[0], false);\n     }\n \n+    pub fn report_extra_impl_obligation(&self,\n+                                        error_span: Span,\n+                                        item_name: ast::Name,\n+                                        _impl_item_def_id: DefId,\n+                                        trait_item_def_id: DefId,\n+                                        requirement: &fmt::Display,\n+                                        lint_id: Option<ast::NodeId>) // (*)\n+                                        -> DiagnosticBuilder<'tcx>\n+    {\n+        // (*) This parameter is temporary and used only for phasing\n+        // in the bug fix to #18937. If it is `Some`, it has a kind of\n+        // weird effect -- the diagnostic is reported as a lint, and\n+        // the builder which is returned is marked as canceled.\n+\n+        let mut err =\n+            struct_span_err!(self.tcx.sess,\n+                             error_span,\n+                             E0276,\n+                             \"impl has stricter requirements than trait\");\n+\n+        if let Some(trait_item_span) = self.tcx.map.span_if_local(trait_item_def_id) {\n+            err.span_label(trait_item_span,\n+                           &format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(\n+            error_span,\n+            &format!(\"impl has extra requirement {}\", requirement));\n+\n+        if let Some(node_id) = lint_id {\n+            self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n+                                              node_id,\n+                                              (*err).clone());\n+            err.cancel();\n+        }\n+\n+        err\n+    }\n+\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                    span_err!(\n-                        self.tcx.sess, span, E0276,\n-                        \"the requirement `{}` appears on the impl \\\n-                         method but not on the corresponding trait method\",\n-                        obligation.predicate);\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name, impl_item_def_id, trait_item_def_id, lint_id\n+                } = obligation.cause.code {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                        lint_id)\n+                        .emit();\n                     return;\n                 } else {\n                     match obligation.predicate {\n@@ -492,7 +538,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(span,\n+                            let err = self.region_outlives_predicate(&obligation.cause,\n                                                                      &predicate).err().unwrap();\n                             struct_span_err!(self.tcx.sess, span, E0279,\n                                 \"the requirement `{}` is not satisfied (`{}`)\",\n@@ -822,6 +868,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n                                   ref_ty));\n             }\n+            ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n+                err.note(&format!(\"required so that the lifetime bound of `{}` for `{}` \\\n+                                   is satisfied\",\n+                                  region, object_ty));\n+            }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 err.note(&format!(\"required by `{}`\", item_name));\n@@ -886,7 +937,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 &parent_predicate,\n                                                 &data.parent_code);\n             }\n-            ObligationCauseCode::CompareImplMethodObligation => {\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n                 err.note(\n                     &format!(\"the requirement `{}` appears on the impl method \\\n                               but not on the corresponding trait method\","}, {"sha": "906da4290361e75c0c507b0c2e10c1b096d8b049", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -526,7 +526,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n+            match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n                 Ok(()) => Ok(Some(Vec::new())),\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }"}, {"sha": "017b34d914f803b635965f03666d1f53cebcd167", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -111,6 +111,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// A type like `&'a T` is WF only if `T: 'a`.\n     ReferenceOutlivesReferent(Ty<'tcx>),\n \n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, &'tcx ty::Region),\n+\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n@@ -138,7 +141,13 @@ pub enum ObligationCauseCode<'tcx> {\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    CompareImplMethodObligation,\n+    // error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        lint_id: Option<ast::NodeId>,\n+    },\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "d33e8b5675f55a4e655e6a1b820c0b7558441f82", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -175,6 +175,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n+            super::ObjectTypeBound(ty, r) => {\n+                tcx.lift(&ty).and_then(|ty| {\n+                    tcx.lift(&r).and_then(|r| {\n+                        Some(super::ObjectTypeBound(ty, r))\n+                    })\n+                })\n+            }\n             super::ObjectCastObligation(ty) => {\n                 tcx.lift(&ty).map(super::ObjectCastObligation)\n             }\n@@ -195,8 +202,16 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ImplDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::ImplDerivedObligation)\n             }\n-            super::CompareImplMethodObligation => {\n-                Some(super::CompareImplMethodObligation)\n+            super::CompareImplMethodObligation { item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                Some(super::CompareImplMethodObligation {\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                    lint_id: lint_id,\n+                })\n             }\n         }\n     }\n@@ -459,12 +474,15 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => self.clone(),\n+            super::CompareImplMethodObligation { .. } => self.clone(),\n \n             super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n             super::ReferenceOutlivesReferent(ty) => {\n                 super::ReferenceOutlivesReferent(ty.fold_with(folder))\n             }\n+            super::ObjectTypeBound(ty, r) => {\n+                super::ObjectTypeBound(ty.fold_with(folder), r.fold_with(folder))\n+            }\n             super::ObjectCastObligation(ty) => {\n                 super::ObjectCastObligation(ty.fold_with(folder))\n             }\n@@ -492,10 +510,11 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => false,\n+            super::CompareImplMethodObligation { .. } => false,\n \n             super::ProjectionWf(proj) => proj.visit_with(visitor),\n             super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n+            super::ObjectTypeBound(ty, r) => ty.visit_with(visitor) || r.visit_with(visitor),\n             super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n             super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n             super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)"}, {"sha": "a3d974216b6e00d882ed6702d933df405da66960", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n+use ty::outlives::Component;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n@@ -166,27 +167,63 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n             ty::Predicate::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::Predicate::RegionOutlives(..) |\n-            ty::Predicate::TypeOutlives(..) => {\n-                // Currently, we do not \"elaborate\" predicates like\n-                // `'a : 'b` or `T : 'a`.  We could conceivably do\n-                // more here.  For example,\n-                //\n-                //     &'a int : 'b\n-                //\n-                // implies that\n-                //\n-                //     'a : 'b\n-                //\n-                // and we could get even more if we took WF\n-                // constraints into account. For example,\n-                //\n-                //     &'a &'b int : 'c\n-                //\n-                // implies that\n+\n+            ty::Predicate::RegionOutlives(..) => {\n+                // Nothing to elaborate from `'a: 'b`.\n+            }\n+\n+            ty::Predicate::TypeOutlives(ref data) => {\n+                // We know that `T: 'a` for some type `T`. We can\n+                // often elaborate this. For example, if we know that\n+                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n+                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n+                // `U: 'b`.\n                 //\n-                //     'b : 'a\n-                //     'a : 'c\n+                // We can basically ignore bound regions here. So for\n+                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n+                // `'a: 'b`.\n+\n+                // Ignore `for<'a> T: 'a` -- we might in the future\n+                // consider this as evidence that `T: 'static`, but\n+                // I'm a bit wary of such constructions and so for now\n+                // I want to be conservative. --nmatsakis\n+                let ty_max = data.skip_binder().0;\n+                let r_min = data.skip_binder().1;\n+                if r_min.is_bound() {\n+                    return;\n+                }\n+\n+                let visited = &mut self.visited;\n+                self.stack.extend(\n+                    tcx.outlives_components(ty_max)\n+                       .into_iter()\n+                       .filter_map(|component| match component {\n+                           Component::Region(r) => if r.is_bound() {\n+                               None\n+                           } else {\n+                               Some(ty::Predicate::RegionOutlives(\n+                                   ty::Binder(ty::OutlivesPredicate(r, r_min))))\n+                           },\n+\n+                           Component::Param(p) => {\n+                               let ty = tcx.mk_param(p.idx, p.name);\n+                               Some(ty::Predicate::TypeOutlives(\n+                                   ty::Binder(ty::OutlivesPredicate(ty, r_min))))\n+                           },\n+\n+                           Component::UnresolvedInferenceVariable(_) => {\n+                               None\n+                           },\n+\n+                           Component::Projection(_) |\n+                           Component::EscapingProjection(_) => {\n+                               // We can probably do more here. This\n+                               // corresponds to a case like `<T as\n+                               // Foo<'a>>::U: 'b`.\n+                               None\n+                           },\n+                       })\n+                       .filter(|p| visited.insert(p)));\n             }\n         }\n     }"}, {"sha": "51feab9d40c9a72d0d02bea8b7e3b2969ff1bc0b", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -12,8 +12,7 @@\n // refers to rules defined in RFC 1214 (`OutlivesFooBar`), so see that\n // RFC for reference.\n \n-use infer::InferCtxt;\n-use ty::{self, Ty, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n@@ -55,9 +54,9 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns all the things that must outlive `'a` for the condition\n-    /// `ty0: 'a` to hold.\n+    /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn outlives_components(&self, ty0: Ty<'tcx>)\n                                -> Vec<Component<'tcx>> {\n         let mut components = vec![];\n@@ -148,16 +147,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            // If we encounter an inference variable, try to resolve it\n-            // and proceed with resolved version. If we cannot resolve it,\n-            // then record the unresolved variable as a component.\n-            ty::TyInfer(_) => {\n-                let ty = self.resolve_type_vars_if_possible(&ty);\n-                if let ty::TyInfer(infer_ty) = ty.sty {\n-                    out.push(Component::UnresolvedInferenceVariable(infer_ty));\n-                } else {\n-                    self.compute_components(ty, out);\n-                }\n+            // We assume that inference variables are fully resolved.\n+            // So, if we encounter an inference variable, just record\n+            // the unresolved variable as a component.\n+            ty::TyInfer(infer_ty) => {\n+                out.push(Component::UnresolvedInferenceVariable(infer_ty));\n             }\n \n             // Most types do not introduce any region binders, nor"}, {"sha": "155fa4989ea3cb716452b7b5bda64d89ae7e6207", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -178,7 +178,8 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n                         match infcx.tcx.no_late_bound_regions(data) {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let components = infcx.outlives_components(ty_a);\n+                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                                let components = infcx.tcx.outlives_components(ty_a);\n                                 implied_bounds_from_components(r_b, components)\n                             }\n                         },\n@@ -497,7 +498,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             let explicit_bound = data.region_bound;\n \n             for implicit_bound in implicit_bounds {\n-                let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n+                let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n             }"}, {"sha": "730ca8f9e2e4474e97735ffd13ad6a553f51183c", "filename": "src/librustc_errors/diagnostic.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use CodeSuggestion;\n+use Level;\n+use RenderSpan;\n+use RenderSpan::Suggestion;\n+use std::fmt;\n+use syntax_pos::{MultiSpan, Span};\n+\n+#[must_use]\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Diagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub code: Option<String>,\n+    pub span: MultiSpan,\n+    pub children: Vec<SubDiagnostic>,\n+}\n+\n+/// For example a note attached to an error.\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct SubDiagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub span: MultiSpan,\n+    pub render_span: Option<RenderSpan>,\n+}\n+\n+impl Diagnostic {\n+    pub fn new(level: Level, message: &str) -> Self {\n+        Diagnostic::new_with_code(level, None, message)\n+    }\n+\n+    pub fn new_with_code(level: Level, code: Option<String>, message: &str) -> Self {\n+        Diagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            code: code,\n+            span: MultiSpan::new(),\n+            children: vec![],\n+        }\n+    }\n+\n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n+    /// bump the error count on the Handler and cancelling it won't undo that.\n+    /// If you want to decrement the error count you should use `Handler::cancel`.\n+    pub fn cancel(&mut self) {\n+        self.level = Level::Cancelled;\n+    }\n+\n+    pub fn cancelled(&self) -> bool {\n+        self.level == Level::Cancelled\n+    }\n+\n+    pub fn is_fatal(&self) -> bool {\n+        self.level == Level::Fatal\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                      -> &mut Self {\n+        self.span.push_span_label(span, format!(\"{}\", label));\n+        self\n+    }\n+\n+    pub fn note_expected_found(&mut self,\n+                               label: &fmt::Display,\n+                               expected: &fmt::Display,\n+                               found: &fmt::Display)\n+                               -> &mut Self\n+    {\n+        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n+    }\n+\n+    pub fn note_expected_found_extra(&mut self,\n+                                     label: &fmt::Display,\n+                                     expected: &fmt::Display,\n+                                     found: &fmt::Display,\n+                                     expected_extra: &fmt::Display,\n+                                     found_extra: &fmt::Display)\n+                                     -> &mut Self\n+    {\n+        // For now, just attach these as notes\n+        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n+        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n+        self\n+    }\n+\n+    pub fn note(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Note, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Note, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Warning, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn help(&mut self , msg: &str) -> &mut Self {\n+        self.sub(Level::Help, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Help, msg, sp.into(), None);\n+        self\n+    }\n+\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                               sp: S,\n+                                               msg: &str,\n+                                               suggestion: String)\n+                                               -> &mut Self {\n+        self.sub(Level::Help,\n+                 msg,\n+                 MultiSpan::new(),\n+                 Some(Suggestion(CodeSuggestion {\n+                     msp: sp.into(),\n+                     substitutes: vec![suggestion],\n+                 })));\n+        self\n+    }\n+\n+    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = sp.into();\n+        self\n+    }\n+\n+    pub fn code(&mut self, s: String) -> &mut Self {\n+        self.code = Some(s);\n+        self\n+    }\n+\n+    pub fn message(&self) -> &str {\n+        &self.message\n+    }\n+\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Used by a lint. Copies over all details *but* the \"main\n+    /// message\".\n+    pub fn copy_details_not_message(&mut self, from: &Diagnostic) {\n+        self.span = from.span.clone();\n+        self.code = from.code.clone();\n+        self.children.extend(from.children.iter().cloned())\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// public methods above.\n+    fn sub(&mut self,\n+           level: Level,\n+           message: &str,\n+           span: MultiSpan,\n+           render_span: Option<RenderSpan>) {\n+        let sub = SubDiagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            span: span,\n+            render_span: render_span,\n+        };\n+        self.children.push(sub);\n+    }\n+}"}, {"sha": "7dfea6b8951b05f2aebd649e338124e57af9fbf6", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Diagnostic;\n+use Level;\n+use Handler;\n+use std::fmt::{self, Debug};\n+use std::ops::{Deref, DerefMut};\n+use std::thread::panicking;\n+use syntax_pos::{MultiSpan, Span};\n+\n+/// Used for emitting structured error messages and other diagnostic information.\n+#[must_use]\n+#[derive(Clone)]\n+pub struct DiagnosticBuilder<'a> {\n+    handler: &'a Handler,\n+    diagnostic: Diagnostic,\n+}\n+\n+/// In general, the `DiagnosticBuilder` uses deref to allow access to\n+/// the fields and methods of the embedded `diagnostic` in a\n+/// transparent way.  *However,* many of the methods are intended to\n+/// be used in a chained way, and hence ought to return `self`. In\n+/// that case, we can't just naively forward to the method on the\n+/// `diagnostic`, because the return type would be a `&Diagnostic`\n+/// instead of a `&DiagnosticBuilder<'a>`. This `forward!` macro makes\n+/// it easy to declare such methods on the builder.\n+macro_rules! forward {\n+    // Forward pattern for &self -> &Self\n+    (pub fn $n:ident(&self, $($name:ident: $ty:ty),*) -> &Self) => {\n+        pub fn $n(&self, $($name: $ty),*) -> &Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self\n+    (pub fn $n:ident(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n+    // type parameter. No obvious way to make this more generic.\n+    (pub fn $n:ident<S: Into<MultiSpan>>(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+}\n+\n+impl<'a> Deref for DiagnosticBuilder<'a> {\n+    type Target = Diagnostic;\n+\n+    fn deref(&self) -> &Diagnostic {\n+        &self.diagnostic\n+    }\n+}\n+\n+impl<'a> DerefMut for DiagnosticBuilder<'a> {\n+    fn deref_mut(&mut self) -> &mut Diagnostic {\n+        &mut self.diagnostic\n+    }\n+}\n+\n+impl<'a> DiagnosticBuilder<'a> {\n+    /// Emit the diagnostic.\n+    pub fn emit(&mut self) {\n+        if self.cancelled() {\n+            return;\n+        }\n+\n+        match self.level {\n+            Level::Bug |\n+            Level::Fatal |\n+            Level::PhaseFatal |\n+            Level::Error => {\n+                self.handler.bump_err_count();\n+            }\n+\n+            Level::Warning |\n+            Level::Note |\n+            Level::Help |\n+            Level::Cancelled => {\n+            }\n+        }\n+\n+        self.handler.emitter.borrow_mut().emit(&self);\n+        self.cancel();\n+        self.handler.panic_if_treat_err_as_bug();\n+\n+        // if self.is_fatal() {\n+        //     panic!(FatalError);\n+        // }\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    forward!(pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                               -> &mut Self);\n+\n+    forward!(pub fn note_expected_found(&mut self,\n+                                        label: &fmt::Display,\n+                                        expected: &fmt::Display,\n+                                        found: &fmt::Display)\n+                                        -> &mut Self);\n+\n+    forward!(pub fn note_expected_found_extra(&mut self,\n+                                              label: &fmt::Display,\n+                                              expected: &fmt::Display,\n+                                              found: &fmt::Display,\n+                                              expected_extra: &fmt::Display,\n+                                              found_extra: &fmt::Display)\n+                                              -> &mut Self);\n+\n+    forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self , msg: &str) -> &mut Self);\n+    forward!(pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                                        sp: S,\n+                                                        msg: &str,\n+                                                        suggestion: String)\n+                                                        -> &mut Self);\n+    forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n+    forward!(pub fn code(&mut self, s: String) -> &mut Self);\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new_with_code(handler, level, None, message)\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new_with_code(handler: &'a Handler,\n+                         level: Level,\n+                         code: Option<String>,\n+                         message: &str)\n+                         -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder {\n+            handler: handler,\n+            diagnostic: Diagnostic::new_with_code(level, code, message)\n+        }\n+    }\n+\n+    pub fn into_diagnostic(mut self) -> Diagnostic {\n+        // annoyingly, the Drop impl means we can't actually move\n+        let result = self.diagnostic.clone();\n+        self.cancel();\n+        result\n+    }\n+}\n+\n+impl<'a> Debug for DiagnosticBuilder<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.diagnostic.fmt(f)\n+    }\n+}\n+\n+/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n+/// we emit a bug.\n+impl<'a> Drop for DiagnosticBuilder<'a> {\n+    fn drop(&mut self) {\n+        if !panicking() && !self.cancelled() {\n+            let mut db = DiagnosticBuilder::new(self.handler,\n+                                                Level::Bug,\n+                                                \"Error constructed but not emitted\");\n+            db.emit();\n+            panic!();\n+        }\n+    }\n+}\n+"}, {"sha": "badee66b83dea3de14e591632a5dfd59b121d652", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 6, "deletions": 237, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -39,15 +39,15 @@ extern crate syntax_pos;\n pub use emitter::ColorConfig;\n \n use self::Level::*;\n-use self::RenderSpan::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n-use std::thread::panicking;\n \n+pub mod diagnostic;\n+pub mod diagnostic_builder;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n@@ -57,7 +57,7 @@ mod lock;\n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n use syntax_pos::MacroBacktrace;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum RenderSpan {\n     /// A FullSpan renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary of\n@@ -71,7 +71,7 @@ pub enum RenderSpan {\n     Suggestion(CodeSuggestion),\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq)]\n pub struct CodeSuggestion {\n     pub msp: MultiSpan,\n     pub substitutes: Vec<String>,\n@@ -211,219 +211,8 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-/// Used for emitting structured error messages and other diagnostic information.\n-#[must_use]\n-#[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    handler: &'a Handler,\n-    pub level: Level,\n-    pub message: String,\n-    pub code: Option<String>,\n-    pub span: MultiSpan,\n-    pub children: Vec<SubDiagnostic>,\n-}\n-\n-/// For example a note attached to an error.\n-#[derive(Clone)]\n-pub struct SubDiagnostic {\n-    pub level: Level,\n-    pub message: String,\n-    pub span: MultiSpan,\n-    pub render_span: Option<RenderSpan>,\n-}\n-\n-impl<'a> DiagnosticBuilder<'a> {\n-    /// Emit the diagnostic.\n-    pub fn emit(&mut self) {\n-        if self.cancelled() {\n-            return;\n-        }\n-\n-        self.handler.emitter.borrow_mut().emit(&self);\n-        self.cancel();\n-        self.handler.panic_if_treat_err_as_bug();\n-\n-        // if self.is_fatal() {\n-        //     panic!(FatalError);\n-        // }\n-    }\n-\n-    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// cancelled or it will panic when dropped).\n-    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n-    /// bump the error count on the Handler and cancelling it won't undo that.\n-    /// If you want to decrement the error count you should use `Handler::cancel`.\n-    pub fn cancel(&mut self) {\n-        self.level = Level::Cancelled;\n-    }\n-\n-    pub fn cancelled(&self) -> bool {\n-        self.level == Level::Cancelled\n-    }\n-\n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n-    /// Add a span/label to be included in the resulting snippet.\n-    /// This is pushed onto the `MultiSpan` that was created when the\n-    /// diagnostic was first built. If you don't call this function at\n-    /// all, and you just supplied a `Span` to create the diagnostic,\n-    /// then the snippet will just include that `Span`, which is\n-    /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display) -> &mut DiagnosticBuilder<'a> {\n-        self.span.push_span_label(span, format!(\"{}\", label));\n-        self\n-    }\n-\n-    pub fn note_expected_found(&mut self,\n-                               label: &fmt::Display,\n-                               expected: &fmt::Display,\n-                               found: &fmt::Display)\n-                               -> &mut DiagnosticBuilder<'a> {\n-        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n-    }\n-\n-    pub fn note_expected_found_extra(&mut self,\n-                                     label: &fmt::Display,\n-                                     expected: &fmt::Display,\n-                                     found: &fmt::Display,\n-                                     expected_extra: &fmt::Display,\n-                                     found_extra: &fmt::Display)\n-                                     -> &mut DiagnosticBuilder<'a> {\n-        // For now, just attach these as notes\n-        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n-        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n-        self\n-    }\n-\n-    pub fn note(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn help(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, sp.into(), None);\n-        self\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n-                                               sp: S,\n-                                               msg: &str,\n-                                               suggestion: String)\n-                                               -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help,\n-                 msg,\n-                 MultiSpan::new(),\n-                 Some(Suggestion(CodeSuggestion {\n-                     msp: sp.into(),\n-                     substitutes: vec![suggestion],\n-                 })));\n-        self\n-    }\n-\n-    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n-        self.span = sp.into();\n-        self\n-    }\n-\n-    pub fn code(&mut self, s: String) -> &mut Self {\n-        self.code = Some(s);\n-        self\n-    }\n-\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder::new_with_code(handler, level, None, message)\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new_with_code(handler: &'a Handler,\n-                     level: Level,\n-                     code: Option<String>,\n-                     message: &str)\n-                     -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n-            handler: handler,\n-            level: level,\n-            message: message.to_owned(),\n-            code: code,\n-            span: MultiSpan::new(),\n-            children: vec![],\n-        }\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// public methods above.\n-    fn sub(&mut self,\n-           level: Level,\n-           message: &str,\n-           span: MultiSpan,\n-           render_span: Option<RenderSpan>) {\n-        let sub = SubDiagnostic {\n-            level: level,\n-            message: message.to_owned(),\n-            span: span,\n-            render_span: render_span,\n-        };\n-        self.children.push(sub);\n-    }\n-}\n-\n-impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.message.fmt(f)\n-    }\n-}\n-\n-/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n-/// we emit a bug.\n-impl<'a> Drop for DiagnosticBuilder<'a> {\n-    fn drop(&mut self) {\n-        if !panicking() && !self.cancelled() {\n-            let mut db =\n-                DiagnosticBuilder::new(self.handler, Bug, \"Error constructed but not emitted\");\n-            db.emit();\n-            panic!();\n-        }\n-    }\n-}\n+pub use diagnostic::{Diagnostic, SubDiagnostic};\n+pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n /// (fatal, bug, unimpl) may cause immediate exit,\n@@ -504,7 +293,6 @@ impl Handler {\n                                                    sp: S,\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result\n@@ -514,21 +302,18 @@ impl Handler {\n                                                              msg: &str,\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n     pub fn struct_span_fatal<'a, S: Into<MultiSpan>>(&'a self,\n                                                      sp: S,\n                                                      msg: &str)\n                                                      -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result\n@@ -538,24 +323,16 @@ impl Handler {\n                                                                msg: &str,\n                                                                code: &str)\n                                                                -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n         result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n     pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.bump_err_count();\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n     pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n-        if err.level == Level::Error || err.level == Level::Fatal {\n-            self.err_count.set(self.err_count\n-                .get()\n-                .checked_sub(1)\n-                .expect(\"cancelled an error but err_count is 0\"));\n-        }\n         err.cancel();\n     }\n \n@@ -567,7 +344,6 @@ impl Handler {\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n@@ -577,13 +353,11 @@ impl Handler {\n                                                     code: &str)\n                                                     -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n         return FatalError;\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Error);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n     }\n     pub fn mut_span_err<'a, S: Into<MultiSpan>>(&'a self,\n@@ -592,12 +366,10 @@ impl Handler {\n                                                 -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n         result.set_span(sp);\n-        self.bump_err_count();\n         result\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         self.emit_with_code(&sp.into(), msg, code, Error);\n-        self.bump_err_count();\n         self.panic_if_treat_err_as_bug();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n@@ -616,7 +388,6 @@ impl Handler {\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Bug);\n-        self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Note);\n@@ -630,7 +401,6 @@ impl Handler {\n         }\n         let mut db = DiagnosticBuilder::new(self, Fatal, msg);\n         db.emit();\n-        self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n@@ -639,7 +409,6 @@ impl Handler {\n         }\n         let mut db = DiagnosticBuilder::new(self, Error, msg);\n         db.emit();\n-        self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);"}, {"sha": "c4b631c79b084b549ed38eb888e904bb2bb947cf", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -229,6 +229,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n             reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(EXTRA_REQUIREMENT_IN_IMPL),\n+            reference: \"issue #37166 <https://github.com/rust-lang/rust/issues/37166>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "6f450f57275c55034770a5aea0a5712697a9a767", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 459, "deletions": 374, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,19 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::middle::free_region::FreeRegionMap;\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n+use rustc::util::common::ErrorReported;\n \n use syntax::ast;\n use syntax_pos::Span;\n \n use CrateCtxt;\n use super::assoc;\n+use super::{Inherited, FnCtxt};\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -39,188 +41,56 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      impl_m_body_id: ast::NodeId,\n                                      trait_m: &ty::Method<'tcx>,\n                                      impl_trait_ref: &ty::TraitRef<'tcx>,\n-                                     trait_item_span: Option<Span>) {\n-    debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n-\n-    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n+                                     trait_item_span: Option<Span>,\n+                                     old_broken_mode: bool) {\n+    debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let tcx = ccx.tcx;\n-\n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n-\n-    // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n-    // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n-    // that the error messages you get out of this code are a bit more\n-    // inscrutable, particularly for cases where one method has no\n-    // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n-        (&ty::ExplicitSelfCategory::Static, _) => {\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           impl_m_span,\n-                                           E0185,\n-                                           \"method `{}` has a `{}` declaration in the impl, but \\\n-                                            not in the trait\",\n-                                           trait_m.name,\n-                                           impl_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span,\n-                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n-            }\n-            err.emit();\n-            return;\n-        }\n-        (_, &ty::ExplicitSelfCategory::Static) => {\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           impl_m_span,\n-                                           E0186,\n-                                           \"method `{}` has a `{}` declaration in the trait, but \\\n-                                            not in the impl\",\n-                                           trait_m.name,\n-                                           trait_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n-            }\n-            err.emit();\n-            return;\n-        }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n+    if let Err(ErrorReported) = compare_self_type(ccx,\n+                                                  impl_m,\n+                                                  impl_m_span,\n+                                                  trait_m) {\n+        return;\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.types.len();\n-    let num_trait_m_type_params = trait_m.generics.types.len();\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-            ImplItemKind::Method(ref impl_m_sig, _) => {\n-                if impl_m_sig.generics.is_parameterized() {\n-                    impl_m_sig.generics.span\n-                } else {\n-                    impl_m_span\n-                }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n-\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       span,\n-                                       E0049,\n-                                       \"method `{}` has {} type parameter{} but its trait \\\n-                                        declaration has {} type parameter{}\",\n-                                       trait_m.name,\n-                                       num_impl_m_type_params,\n-                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n-                                       num_trait_m_type_params,\n-                                       if num_trait_m_type_params == 1 {\n-                                           \"\"\n-                                       } else {\n-                                           \"s\"\n-                                       });\n-\n-        let mut suffix = None;\n-\n-        if let Some(span) = trait_item_span {\n-            err.span_label(span,\n-                           &format!(\"expected {}\",\n-                                    &if num_trait_m_type_params != 1 {\n-                                        format!(\"{} type parameters\", num_trait_m_type_params)\n-                                    } else {\n-                                        format!(\"{} type parameter\", num_trait_m_type_params)\n-                                    }));\n-        } else {\n-            suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n-        }\n-\n-        err.span_label(span,\n-                       &format!(\"found {}{}\",\n-                                &if num_impl_m_type_params != 1 {\n-                                    format!(\"{} type parameters\", num_impl_m_type_params)\n-                                } else {\n-                                    format!(\"1 type parameter\")\n-                                },\n-                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n-\n-        err.emit();\n+    if let Err(ErrorReported) = compare_number_of_generics(ccx,\n+                                                           impl_m,\n+                                                           impl_m_span,\n+                                                           trait_m,\n+                                                           trait_item_span) {\n+        return;\n+    }\n \n+    if let Err(ErrorReported) = compare_number_of_method_arguments(ccx,\n+                                                                   impl_m,\n+                                                                   impl_m_span,\n+                                                                   trait_m,\n+                                                                   trait_item_span) {\n         return;\n     }\n \n-    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n-        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n-        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n-        let trait_span = if let Some(trait_id) = trait_m_node_id {\n-            match tcx.map.expect_trait_item(trait_id).node {\n-                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n-                        trait_number_args - 1\n-                    } else {\n-                        0\n-                    }) {\n-                        Some(arg.pat.span)\n-                    } else {\n-                        trait_item_span\n-                    }\n-                }\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            }\n-        } else {\n-            trait_item_span\n-        };\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-            ImplItemKind::Method(ref impl_m_sig, _) => {\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n-                    impl_number_args - 1\n-                } else {\n-                    0\n-                }) {\n-                    arg.pat.span\n-                } else {\n-                    impl_m_span\n-                }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       impl_span,\n-                                       E0050,\n-                                       \"method `{}` has {} parameter{} but the declaration in \\\n-                                        trait `{}` has {}\",\n-                                       trait_m.name,\n-                                       impl_number_args,\n-                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n-                                       tcx.item_path_str(trait_m.def_id),\n-                                       trait_number_args);\n-        if let Some(trait_span) = trait_span {\n-            err.span_label(trait_span,\n-                           &format!(\"trait requires {}\",\n-                                    &if trait_number_args != 1 {\n-                                        format!(\"{} parameters\", trait_number_args)\n-                                    } else {\n-                                        format!(\"{} parameter\", trait_number_args)\n-                                    }));\n-        }\n-        err.span_label(impl_span,\n-                       &format!(\"expected {}, found {}\",\n-                                &if trait_number_args != 1 {\n-                                    format!(\"{} parameters\", trait_number_args)\n-                                } else {\n-                                    format!(\"{} parameter\", trait_number_args)\n-                                },\n-                                impl_number_args));\n-        err.emit();\n+    if let Err(ErrorReported) = compare_predicate_entailment(ccx,\n+                                                             impl_m,\n+                                                             impl_m_span,\n+                                                             impl_m_body_id,\n+                                                             trait_m,\n+                                                             impl_trait_ref,\n+                                                             old_broken_mode) {\n         return;\n     }\n+}\n+\n+fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                          impl_m: &ty::Method<'tcx>,\n+                                          impl_m_span: Span,\n+                                          impl_m_body_id: ast::NodeId,\n+                                          trait_m: &ty::Method<'tcx>,\n+                                          impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                          old_broken_mode: bool)\n+                                          -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n \n     // This code is best explained by example. Consider a trait:\n     //\n@@ -301,50 +171,48 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    // Check region bounds. FIXME(@jroesch) refactor this away when removing\n-    // ParamBounds.\n-    if !check_region_bounds_on_impl_method(ccx,\n-                                           impl_m_span,\n-                                           impl_m,\n-                                           &trait_m.generics,\n-                                           &impl_m.generics,\n-                                           trait_to_skol_substs,\n-                                           impl_to_skol_substs) {\n-        return;\n-    }\n-\n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-\n-        // Create obligations for each predicate declared by the impl\n-        // definition in the context of the trait's parameter\n-        // environment. We can't just use `impl_env.caller_bounds`,\n-        // however, because we want to replace all late-bound regions with\n-        // region variables.\n-        let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n-        let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n-\n-        debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n-\n-        // This is the only tricky bit of the new way we check implementation methods\n-        // We need to build a set of predicates where only the method-level bounds\n-        // are from the trait and we assume all other bounds from the implementation\n-        // to be previously satisfied.\n-        //\n-        // We then register the obligations from the impl_m and check to see\n-        // if all constraints hold.\n-        hybrid_preds.predicates\n-            .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n-\n-        // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-        // The key step here is to update the caller_bounds's predicates to be\n-        // the new hybrid bounds we computed.\n-        let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n-        let trait_param_env =\n-            traits::normalize_param_env_or_error(tcx, trait_param_env, normalize_cause.clone());\n-        // FIXME(@jroesch) this seems ugly, but is a temporary change\n-        infcx.parameter_environment = trait_param_env;\n+    // Check region bounds.\n+    check_region_bounds_on_impl_method(ccx,\n+                                       impl_m_span,\n+                                       impl_m,\n+                                       &trait_m.generics,\n+                                       &impl_m.generics,\n+                                       trait_to_skol_substs,\n+                                       impl_to_skol_substs)?;\n+\n+    // Create obligations for each predicate declared by the impl\n+    // definition in the context of the trait's parameter\n+    // environment. We can't just use `impl_env.caller_bounds`,\n+    // however, because we want to replace all late-bound regions with\n+    // region variables.\n+    let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+    let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n+\n+    debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n+\n+    // This is the only tricky bit of the new way we check implementation methods\n+    // We need to build a set of predicates where only the method-level bounds\n+    // are from the trait and we assume all other bounds from the implementation\n+    // to be previously satisfied.\n+    //\n+    // We then register the obligations from the impl_m and check to see\n+    // if all constraints hold.\n+    hybrid_preds.predicates\n+                .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+\n+    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+    // The key step here is to update the caller_bounds's predicates to be\n+    // the new hybrid bounds we computed.\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n+    let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                               trait_param_env,\n+                                                               normalize_cause.clone());\n+\n+    tcx.infer_ctxt(None, Some(trait_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+        let inh = Inherited::new(ccx, infcx);\n+        let infcx = &inh.infcx;\n+        let fulfillment_cx = &inh.fulfillment_cx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n                infcx.parameter_environment.caller_bounds);\n@@ -362,10 +230,15 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let cause = traits::ObligationCause {\n                 span: impl_m_span,\n                 body_id: impl_m_body_id,\n-                code: traits::ObligationCauseCode::CompareImplMethodObligation,\n+                code: traits::ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name: impl_m.name,\n+                    impl_item_def_id: impl_m.def_id,\n+                    trait_item_def_id: trait_m.def_id,\n+                    lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n+                },\n             };\n \n-            fulfillment_cx.register_predicate_obligation(\n+            fulfillment_cx.borrow_mut().register_predicate_obligation(\n                 &infcx,\n                 traits::Obligation::new(cause, predicate));\n         }\n@@ -387,30 +260,36 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let tcx = infcx.tcx;\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n-        let (impl_sig, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                       infer::HigherRankedType,\n-                                                       &impl_m.fty.sig);\n-        let impl_sig = impl_sig.subst(tcx, impl_to_skol_substs);\n-        let impl_sig = assoc::normalize_associated_types_in(&infcx,\n-                                                            &mut fulfillment_cx,\n-                                                            impl_m_span,\n-                                                            impl_m_body_id,\n-                                                            &impl_sig);\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx.borrow_mut(),\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n             sig: ty::Binder(impl_sig.clone()),\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = tcx.liberate_late_bound_regions(infcx.parameter_environment.free_id_outlive,\n-                                         &trait_m.fty.sig);\n-        let trait_sig = trait_sig.subst(tcx, trait_to_skol_substs);\n-        let trait_sig = assoc::normalize_associated_types_in(&infcx,\n-                                                             &mut fulfillment_cx,\n-                                                             impl_m_span,\n-                                                             impl_m_body_id,\n-                                                             &trait_sig);\n+        let trait_sig = tcx.liberate_late_bound_regions(\n+            infcx.parameter_environment.free_id_outlive,\n+            &trait_m.fty.sig);\n+        let trait_sig =\n+            trait_sig.subst(tcx, trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx.borrow_mut(),\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n@@ -449,171 +328,377 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 })),\n                                 &terr);\n             diag.emit();\n-            return;\n+            return Err(ErrorReported);\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+        if let Err(ref errors) = fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n-            return;\n+            return Err(ErrorReported);\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of\n-        // lifetime parameters. We have to build up a plausible lifetime\n-        // environment based on what we find in the trait. We could also\n-        // include the obligations derived from the method argument types,\n-        // but I don't think it's necessary -- after all, those are still\n-        // in effect when type-checking the body, and all the\n-        // where-clauses in the header etc should be implied by the trait\n-        // anyway, so it shouldn't be needed there either. Anyway, we can\n-        // always add more relations later (it's backwards compat).\n-        let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(\n-            &infcx.parameter_environment.caller_bounds);\n-\n-        infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n-    });\n+        // lifetime parameters.\n+        if old_broken_mode {\n+            // FIXME(#18937) -- this is how the code used to\n+            // work. This is buggy because the fulfillment cx creates\n+            // region obligations that get overlooked.  The right\n+            // thing to do is the code below. But we keep this old\n+            // pass around temporarily.\n+            let mut free_regions = FreeRegionMap::new();\n+            free_regions.relate_free_regions_from_predicates(\n+                &infcx.parameter_environment.caller_bounds);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+        } else {\n+            let fcx = FnCtxt::new(&inh, tcx.types.err, impl_m_body_id);\n+            fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n+        }\n+\n+        Ok(())\n+    })\n+}\n \n-    fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                    span: Span,\n-                                                    impl_m: &ty::Method<'tcx>,\n-                                                    trait_generics: &ty::Generics<'tcx>,\n-                                                    impl_generics: &ty::Generics<'tcx>,\n-                                                    trait_to_skol_substs: &Substs<'tcx>,\n-                                                    impl_to_skol_substs: &Substs<'tcx>)\n-                                                    -> bool {\n-\n-        let trait_params = &trait_generics.regions[..];\n-        let impl_params = &impl_generics.regions[..];\n-\n-        debug!(\"check_region_bounds_on_impl_method: \\\n-               trait_generics={:?} \\\n-               impl_generics={:?} \\\n-               trait_to_skol_substs={:?} \\\n-               impl_to_skol_substs={:?}\",\n-               trait_generics,\n-               impl_generics,\n-               trait_to_skol_substs,\n-               impl_to_skol_substs);\n-\n-        // Must have same number of early-bound lifetime parameters.\n-        // Unfortunately, if the user screws up the bounds, then this\n-        // will change classification between early and late.  E.g.,\n-        // if in trait we have `<'a,'b:'a>`, and in impl we just have\n-        // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n-        // in trait but 0 in the impl. But if we report \"expected 2\n-        // but found 0\" it's confusing, because it looks like there\n-        // are zero. Since I don't quite know how to phrase things at\n-        // the moment, give a kind of vague error message.\n-        if trait_params.len() != impl_params.len() {\n-            struct_span_err!(ccx.tcx.sess,\n-                             span,\n-                             E0195,\n-                             \"lifetime parameters or bounds on method `{}` do not match the \\\n-                              trait declaration\",\n-                             impl_m.name)\n-                .span_label(span, &format!(\"lifetimes do not match trait\"))\n-                .emit();\n-            return false;\n+fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                span: Span,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                trait_generics: &ty::Generics<'tcx>,\n+                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_to_skol_substs: &Substs<'tcx>,\n+                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                -> Result<(), ErrorReported> {\n+    let trait_params = &trait_generics.regions[..];\n+    let impl_params = &impl_generics.regions[..];\n+\n+    debug!(\"check_region_bounds_on_impl_method: \\\n+            trait_generics={:?} \\\n+            impl_generics={:?} \\\n+            trait_to_skol_substs={:?} \\\n+            impl_to_skol_substs={:?}\",\n+           trait_generics,\n+           impl_generics,\n+           trait_to_skol_substs,\n+           impl_to_skol_substs);\n+\n+    // Must have same number of early-bound lifetime parameters.\n+    // Unfortunately, if the user screws up the bounds, then this\n+    // will change classification between early and late.  E.g.,\n+    // if in trait we have `<'a,'b:'a>`, and in impl we just have\n+    // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n+    // in trait but 0 in the impl. But if we report \"expected 2\n+    // but found 0\" it's confusing, because it looks like there\n+    // are zero. Since I don't quite know how to phrase things at\n+    // the moment, give a kind of vague error message.\n+    if trait_params.len() != impl_params.len() {\n+        struct_span_err!(ccx.tcx.sess,\n+                         span,\n+                         E0195,\n+                         \"lifetime parameters or bounds on method `{}` do not match the \\\n+                          trait declaration\",\n+                         impl_m.name)\n+            .span_label(span, &format!(\"lifetimes do not match trait\"))\n+            .emit();\n+        return Err(ErrorReported);\n+    }\n+\n+    return Ok(());\n+}\n+\n+fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                                     terr: &TypeError,\n+                                                     origin: TypeOrigin,\n+                                                     impl_m: &ty::Method,\n+                                                     impl_sig: ty::FnSig<'tcx>,\n+                                                     trait_m: &ty::Method,\n+                                                     trait_sig: ty::FnSig<'tcx>)\n+                                                     -> (Span, Option<Span>) {\n+    let tcx = infcx.tcx;\n+    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+    let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        ImplItemKind::Method(ref impl_m_sig, _) => {\n+            (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+        }\n+        _ => bug!(\"{:?} is not a method\", impl_m),\n+    };\n+\n+    match *terr {\n+        TypeError::Mutability => {\n+            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                    TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                        trait_m_sig.decl.inputs.iter()\n+                    }\n+                    _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                };\n+\n+                impl_m_iter.zip(trait_m_iter)\n+                           .find(|&(ref impl_arg, ref trait_arg)| {\n+                               match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                                   (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n+                                   (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n+                                       impl_mt.mutbl != trait_mt.mutbl\n+                                   }\n+                                   _ => false,\n+                               }\n+                           })\n+                           .map(|(ref impl_arg, ref trait_arg)| {\n+                               match (impl_arg.to_self(), trait_arg.to_self()) {\n+                                   (Some(impl_self), Some(trait_self)) => {\n+                                       (impl_self.span, Some(trait_self.span))\n+                                   }\n+                                   (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n+                                   _ => {\n+                                       bug!(\"impl and trait fns have different first args, impl: \\\n+                                             {:?}, trait: {:?}\",\n+                                            impl_arg,\n+                                            trait_arg)\n+                                   }\n+                               }\n+                           })\n+                           .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+            } else {\n+                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            }\n         }\n+        TypeError::Sorts(ExpectedFound { .. }) => {\n+            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                let (trait_m_output, trait_m_iter) =\n+                    match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                            (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n+                        }\n+                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                    };\n \n-        return true;\n+                let impl_iter = impl_sig.inputs.iter();\n+                let trait_iter = trait_sig.inputs.iter();\n+                impl_iter.zip(trait_iter)\n+                         .zip(impl_m_iter)\n+                         .zip(trait_m_iter)\n+                         .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n+                             match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n+                                 Ok(_) => None,\n+                                 Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n+                             }\n+                         })\n+                         .next()\n+                         .unwrap_or_else(|| {\n+                             if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n+                                     .is_err() {\n+                                         (impl_m_output.span(), Some(trait_m_output.span()))\n+                                     } else {\n+                                         (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                                     }\n+                         })\n+            } else {\n+                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            }\n+        }\n+        _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n     }\n+}\n \n-    fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                                         terr: &TypeError,\n-                                                         origin: TypeOrigin,\n-                                                         impl_m: &ty::Method,\n-                                                         impl_sig: ty::FnSig<'tcx>,\n-                                                         trait_m: &ty::Method,\n-                                                         trait_sig: ty::FnSig<'tcx>)\n-                                                         -> (Span, Option<Span>) {\n-        let tcx = infcx.tcx;\n+fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               impl_m: &ty::Method<'tcx>,\n+                               impl_m_span: Span,\n+                               trait_m: &ty::Method<'tcx>)\n+                               -> Result<(), ErrorReported>\n+{\n+    let tcx = ccx.tcx;\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n+        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n+        (&ty::ExplicitSelfCategory::Static, _) => {\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0185,\n+                                           \"method `{}` has a `{}` declaration in the impl, but \\\n+                                            not in the trait\",\n+                                           trait_m.name,\n+                                           impl_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n+            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+                err.span_label(span,\n+                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n+            }\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+        (_, &ty::ExplicitSelfCategory::Static) => {\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0186,\n+                                           \"method `{}` has a `{}` declaration in the trait, but \\\n+                                            not in the impl\",\n+                                           trait_m.name,\n+                                           trait_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n+            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n+            }\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        impl_m: &ty::Method<'tcx>,\n+                                        impl_m_span: Span,\n+                                        trait_m: &ty::Method<'tcx>,\n+                                        trait_item_span: Option<Span>)\n+                                        -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+    let num_impl_m_type_params = impl_m.generics.types.len();\n+    let num_trait_m_type_params = trait_m.generics.types.len();\n+    if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n-                (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+                if impl_m_sig.generics.is_parameterized() {\n+                    impl_m_sig.generics.span\n+                } else {\n+                    impl_m_span\n+                }\n             }\n             _ => bug!(\"{:?} is not a method\", impl_m),\n         };\n \n-        match *terr {\n-            TypeError::Mutability => {\n-                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                    let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                            trait_m_sig.decl.inputs.iter()\n-                        }\n-                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n-                    };\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       span,\n+                                       E0049,\n+                                       \"method `{}` has {} type parameter{} but its trait \\\n+                                        declaration has {} type parameter{}\",\n+                                       trait_m.name,\n+                                       num_impl_m_type_params,\n+                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n+                                       num_trait_m_type_params,\n+                                       if num_trait_m_type_params == 1 {\n+                                           \"\"\n+                                       } else {\n+                                           \"s\"\n+                                       });\n \n-                    impl_m_iter.zip(trait_m_iter)\n-                        .find(|&(ref impl_arg, ref trait_arg)| {\n-                            match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                                (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                                (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n-                                    impl_mt.mutbl != trait_mt.mutbl\n-                                }\n-                                _ => false,\n-                            }\n-                        })\n-                        .map(|(ref impl_arg, ref trait_arg)| {\n-                            match (impl_arg.to_self(), trait_arg.to_self()) {\n-                                (Some(impl_self), Some(trait_self)) => {\n-                                    (impl_self.span, Some(trait_self.span))\n-                                }\n-                                (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                                _ => {\n-                                    bug!(\"impl and trait fns have different first args, impl: \\\n-                                          {:?}, trait: {:?}\",\n-                                         impl_arg,\n-                                         trait_arg)\n-                                }\n-                            }\n-                        })\n-                        .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n-                } else {\n-                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+        let mut suffix = None;\n+\n+        if let Some(span) = trait_item_span {\n+            err.span_label(span,\n+                           &format!(\"expected {}\",\n+                                    &if num_trait_m_type_params != 1 {\n+                                        format!(\"{} type parameters\", num_trait_m_type_params)\n+                                    } else {\n+                                        format!(\"{} type parameter\", num_trait_m_type_params)\n+                                    }));\n+        } else {\n+            suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n+        }\n+\n+        err.span_label(span,\n+                       &format!(\"found {}{}\",\n+                                &if num_impl_m_type_params != 1 {\n+                                    format!(\"{} type parameters\", num_impl_m_type_params)\n+                                } else {\n+                                    format!(\"1 type parameter\")\n+                                },\n+                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n+\n+        err.emit();\n+\n+        return Err(ErrorReported);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m_span: Span,\n+                                                trait_m: &ty::Method<'tcx>,\n+                                                trait_item_span: Option<Span>)\n+                                                -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n+        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n+        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n+        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n+        let trait_span = if let Some(trait_id) = trait_m_node_id {\n+            match tcx.map.expect_trait_item(trait_id).node {\n+                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                    if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n+                        trait_number_args - 1\n+                    } else {\n+                        0\n+                    }) {\n+                        Some(arg.pat.span)\n+                    } else {\n+                        trait_item_span\n+                    }\n                 }\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n             }\n-            TypeError::Sorts(ExpectedFound { .. }) => {\n-                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                    let (trait_m_output, trait_m_iter) =\n-                        match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                                (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n-                            }\n-                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n-                        };\n-\n-                    let impl_iter = impl_sig.inputs.iter();\n-                    let trait_iter = trait_sig.inputs.iter();\n-                    impl_iter.zip(trait_iter)\n-                        .zip(impl_m_iter)\n-                        .zip(trait_m_iter)\n-                        .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                            match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n-                                Ok(_) => None,\n-                                Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n-                            }\n-                        })\n-                        .next()\n-                        .unwrap_or_else(|| {\n-                            if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n-                                .is_err() {\n-                                (impl_m_output.span(), Some(trait_m_output.span()))\n-                            } else {\n-                                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n-                            }\n-                        })\n+        } else {\n+            trait_item_span\n+        };\n+        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+            ImplItemKind::Method(ref impl_m_sig, _) => {\n+                if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n+                    impl_number_args - 1\n                 } else {\n-                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                    0\n+                }) {\n+                    arg.pat.span\n+                } else {\n+                    impl_m_span\n                 }\n             }\n-            _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n+            _ => bug!(\"{:?} is not a method\", impl_m),\n+        };\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       impl_span,\n+                                       E0050,\n+                                       \"method `{}` has {} parameter{} but the declaration in \\\n+                                        trait `{}` has {}\",\n+                                       trait_m.name,\n+                                       impl_number_args,\n+                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n+                                       tcx.item_path_str(trait_m.def_id),\n+                                       trait_number_args);\n+        if let Some(trait_span) = trait_span {\n+            err.span_label(trait_span,\n+                           &format!(\"trait requires {}\",\n+                                    &if trait_number_args != 1 {\n+                                        format!(\"{} parameters\", trait_number_args)\n+                                    } else {\n+                                        format!(\"{} parameter\", trait_number_args)\n+                                    }));\n         }\n+        err.span_label(impl_span,\n+                       &format!(\"expected {}, found {}\",\n+                                &if trait_number_args != 1 {\n+                                    format!(\"{} parameters\", trait_number_args)\n+                                } else {\n+                                    format!(\"{} parameter\", trait_number_args)\n+                                },\n+                                impl_number_args));\n+        err.emit();\n+        return Err(ErrorReported);\n     }\n+\n+    Ok(())\n }\n \n pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "4e0f455e362389b4b049c87870fad1ebea19eeab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -407,22 +407,26 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n         let ccx = self.ccx;\n-        self.infcx.enter(|infcx| {\n-            f(Inherited {\n-                ccx: ccx,\n-                infcx: infcx,\n-                fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n-                locals: RefCell::new(NodeMap()),\n-                deferred_call_resolutions: RefCell::new(DefIdMap()),\n-                deferred_cast_checks: RefCell::new(Vec::new()),\n-                anon_types: RefCell::new(DefIdMap()),\n-                deferred_obligations: RefCell::new(Vec::new()),\n-            })\n-        })\n+        self.infcx.enter(|infcx| f(Inherited::new(ccx, infcx)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+    pub fn new(ccx: &'a CrateCtxt<'a, 'gcx>,\n+               infcx: InferCtxt<'a, 'gcx, 'tcx>)\n+               -> Self {\n+        Inherited {\n+            ccx: ccx,\n+            infcx: infcx,\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            locals: RefCell::new(NodeMap()),\n+            deferred_call_resolutions: RefCell::new(DefIdMap()),\n+            deferred_cast_checks: RefCell::new(Vec::new()),\n+            anon_types: RefCell::new(DefIdMap()),\n+            deferred_obligations: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n@@ -1024,13 +1028,26 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n                     let trait_span = tcx.map.span_if_local(ty_trait_item.def_id());\n                     if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n+                        let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n                                             &impl_method,\n                                             impl_item.span,\n                                             body.id,\n                                             &trait_method,\n                                             &impl_trait_ref,\n-                                            trait_span);\n+                                            trait_span,\n+                                            true); // start with old-broken-mode\n+                        if err_count == tcx.sess.err_count() {\n+                            // old broken mode did not report an error. Try with the new mode.\n+                            compare_impl_method(ccx,\n+                                                &impl_method,\n+                                                impl_item.span,\n+                                                body.id,\n+                                                &trait_method,\n+                                                &impl_trait_ref,\n+                                                trait_span,\n+                                                false); // use the new mode\n+                        }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\"}, {"sha": "9bfe80dba9db15d6b9f5a3a34d74f304f89937ff", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n                    r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n+            let origin = self.code_to_origin(&r_o.cause, sup_type);\n             self.type_must_outlive(origin, sup_type, r_o.sub_region);\n         }\n \n@@ -366,16 +366,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn code_to_origin(&self,\n-                      span: Span,\n-                      sup_type: Ty<'tcx>,\n-                      code: &traits::ObligationCauseCode<'tcx>)\n+                      cause: &traits::ObligationCause<'tcx>,\n+                      sup_type: Ty<'tcx>)\n                       -> SubregionOrigin<'tcx> {\n-        match *code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n-                infer::ReferenceOutlivesReferent(ref_type, span),\n-            _ =>\n-                infer::RelateParamBound(span, sup_type),\n-        }\n+        SubregionOrigin::from_obligation_cause(cause,\n+                                               || infer::RelateParamBound(cause.span, sup_type))\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -1474,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         assert!(!ty.has_escaping_regions());\n \n-        let components = self.outlives_components(ty);\n+        let components = self.tcx.outlives_components(ty);\n         self.components_must_outlive(origin, components, region);\n     }\n "}, {"sha": "be012d8976f6c1ab9836e131845a92bf48359067", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -458,7 +458,7 @@ Rust only supports variadic parameters for interoperability with C code in its\n FFI. As such, variadic parameters can only be used with functions which are\n using the C ABI. Examples of erroneous code:\n \n-```compile_fail,E0045\n+```compile_fail\n #![feature(unboxed_closures)]\n \n extern \"rust-call\" { fn foo(x: u8, ...); }"}, {"sha": "d99850332c36e8321addd6de76fccf67a8ae1835", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -67,7 +67,7 @@ pub struct Span {\n ///   the error, and would be rendered with `^^^`.\n /// - they can have a *label*. In this case, the label is written next\n ///   to the mark in the snippet when we render.\n-#[derive(Clone)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MultiSpan {\n     primary_spans: Vec<Span>,\n     span_labels: Vec<(Span, String)>,"}, {"sha": "e4da3e4fa43e67c91b4db0b27bbe8d0088e0b944", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -20,7 +20,7 @@ struct X { data: u32 }\n \n impl Something for X {\n     fn yay<T: Str>(_:Option<X>, thing: &[T]) {\n-    //~^ ERROR the requirement `T: Str` appears on the impl method\n+    //~^ ERROR E0276\n     }\n }\n "}, {"sha": "8ac66bb44d20a5b3d703396b073f9b4a8d6b8bcf", "filename": "src/test/compile-fail/issue-18937.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #18937.\n+\n+#![deny(extra_requirement_in_impl)]\n+\n+use std::fmt;\n+\n+#[derive(Debug)]\n+struct MyString<'a>(&'a String);\n+\n+struct B {\n+    list: Vec<Box<fmt::Debug>>,\n+}\n+\n+trait A<'a> {\n+    fn foo<F>(&mut self, f: F)\n+        where F: fmt::Debug + 'a,\n+              Self: Sized;\n+}\n+\n+impl<'a> A<'a> for B {\n+    fn foo<F>(&mut self, f: F) //~ ERROR E0276\n+        //~^ WARNING future release\n+        where F: fmt::Debug + 'static,\n+    {\n+        self.list.push(Box::new(f));\n+    }\n+}\n+\n+fn main() {\n+    let mut b = B { list: Vec::new() };\n+\n+    // Create a borrowed pointer, put it in `b`, then drop what's borrowing it\n+    let a = \"hello\".to_string();\n+    b.foo(MyString(&a));\n+\n+    // Drop the data which `b` has a reference to\n+    drop(a);\n+\n+    // Use the data, probably segfaulting\n+    for b in b.list.iter() {\n+        println!(\"{:?}\", b);\n+    }\n+}"}, {"sha": "1d4ffe0690d2f0d0cc0b31549871ecf2f0952b57", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -52,7 +52,7 @@ impl<'a, 't> Foo<'a, 't> for &'a isize {\n     }\n \n     fn another_bound<'x: 't>(self, x: Inv<'x>, y: Inv<'t>) {\n-        //~^ ERROR lifetime bound not satisfied\n+        //~^ ERROR E0276\n     }\n }\n "}, {"sha": "70055a101815fce2188e67eee0d49fc4b6f1fe45", "filename": "src/test/parse-fail/associated-types-project-from-hrtb-explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fassociated-types-project-from-hrtb-explicit.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n // Test you can't use a higher-ranked trait bound inside of a qualified\n // path (just won't parse)."}, {"sha": "2bb593258ae4b82248f09efd6817d7cb505920c5", "filename": "src/test/parse-fail/generic-non-trailing-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fgeneric-non-trailing-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fgeneric-non-trailing-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fgeneric-non-trailing-defaults.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n struct Heap;\n "}, {"sha": "de5aeb02ab788d91612f76a97de202d86e91d76d", "filename": "src/test/parse-fail/issue-17904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-17904.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n struct Baz<U> where U: Eq(U); //This is parsed as the new Fn* style parenthesis syntax.\n struct Baz<U> where U: Eq(U) -> R; // Notice this parses as well."}, {"sha": "c8406af52ae0c475bb94cbd88fe59705c83695c2", "filename": "src/test/parse-fail/lex-bad-octal-literal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n fn main() {\n     0o18; //~ ERROR invalid digit for a base 8 literal\n     0o1234_9_5670;  //~ ERROR invalid digit for a base 8 literal"}, {"sha": "a8771ae93af524fe84dfabb9958b950612a60062", "filename": "src/test/parse-fail/lifetime-no-keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flifetime-no-keyword.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n fn foo<'a>(a: &'a isize) { }\n fn bar(a: &'static isize) { }"}, {"sha": "2e33f98add6b4460e53b861a1a11e3637a15fe8a", "filename": "src/test/parse-fail/raw-byte-string-literals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fraw-byte-string-literals.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n \n pub fn main() {\n-    br\"\u00e9\";  //~ raw byte string must be ASCII\n-    br##~\"a\"~##;  //~ only `#` is allowed in raw string delimitation\n+    br\"\u00e9\";  //~ ERROR raw byte string must be ASCII\n+    br##~\"a\"~##;  //~ ERROR only `#` is allowed in raw string delimitation\n }"}, {"sha": "6deb3bb2e95185c299a6f916bb7d3a8c170d75b4", "filename": "src/test/parse-fail/removed-syntax-field-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fremoved-syntax-field-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fremoved-syntax-field-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-field-let.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n struct s {\n     let foo: (),"}, {"sha": "1971ffeaf2648708ec05a2ab4f2e48916aa639e4", "filename": "src/test/parse-fail/syntax-trait-polarity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fsyntax-trait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fsyntax-trait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fsyntax-trait-polarity.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n #![feature(optin_builtin_traits)]\n "}, {"sha": "44bb1f930c7bdcb945ae5d6cbd348d20917f7e5e", "filename": "src/test/parse-fail/trailing-plus-in-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n use std::fmt::Debug;\n "}, {"sha": "b7dcc8a8b3bc1a5774ebd4ce41e22dcf37bb254c", "filename": "src/test/parse-fail/trait-bounds-not-on-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n trait Foo {\n }"}, {"sha": "9e16e29ba50b3f8d5662d8e8c8edea4f7e4e2cc4", "filename": "src/test/parse-fail/use-as-where-use-ends-with-mod-sep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fuse-as-where-use-ends-with-mod-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fuse-as-where-use-ends-with-mod-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fuse-as-where-use-ends-with-mod-sep.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n use std::any:: as foo; //~ ERROR expected identifier, found keyword `as`\n //~^ ERROR: expected one of `::`, `;`, or `as`, found `foo`"}, {"sha": "45165b76c4af0acd64e340d0372f7a94518a5ebd", "filename": "src/test/parse-fail/where-clauses-no-bounds-or-predicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fwhere-clauses-no-bounds-or-predicates.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n fn equal1<T>(_: &T, _: &T) -> bool where {\n //~^ ERROR a `where` clause must have at least one predicate in it"}, {"sha": "7a24d087b44e2b8c29b277ef173702ee76ba8f4f", "filename": "src/test/run-pass/issue-18937-1.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Frun-pass%2Fissue-18937-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Frun-pass%2Fissue-18937-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18937-1.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to type-check this example. In particular,\n+// knowing that `T: 'a` allows us to deduce that `[U]: 'a` (because\n+// when `T=[U]` it implies that `U: 'a`).\n+//\n+// Regr. test for live code we found in the wild when fixing #18937.\n+\n+pub trait Leak<T : ?Sized> {\n+    fn leak<'a>(self) -> &'a T where T: 'a;\n+}\n+\n+impl<U> Leak<[U]> for Vec<U> {\n+    fn leak<'a>(mut self) -> &'a [U] where [U]: 'a {\n+        let r: *mut [U] = &mut self[..];\n+        std::mem::forget(self);\n+        unsafe { &mut *r }\n+    }\n+}\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "4621c2ca4be28ee98a466d2d16fd672cd171e3ff", "filename": "src/test/run-pass/traits-elaborate-type-region.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Frun-pass%2Ftraits-elaborate-type-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Frun-pass%2Ftraits-elaborate-type-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-elaborate-type-region.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// Test that we elaborate `Type: 'region` constraints and infer various important things.\n+\n+trait Master<'a, T: ?Sized> {\n+    fn foo() where T: 'a;\n+}\n+\n+// [U]: 'a => U: 'a\n+impl<'a, U> Master<'a, [U]> for () {\n+    fn foo() where U: 'a { }\n+}\n+\n+// &'b U: 'a => 'b: 'a, U: 'a\n+impl<'a, 'b, U> Master<'a, &'b U> for () {\n+    fn foo() where 'b: 'a, U: 'a { }\n+}\n+\n+// &'b [U]: 'a => 'b: 'a, U: 'a\n+impl<'a, 'b, U> Master<'a, &'b [U]> for () {\n+    fn foo() where 'b: 'a, U: 'a { }\n+}\n+\n+// Foo<'b>: 'a => 'b: 'a\n+struct Foo<'a> { x: &'a () }\n+impl<'a, 'b> Master<'a, Foo<'b>> for () {\n+    fn foo() where 'b: 'a { }\n+}\n+\n+// Bar<'b, T>: 'a => 'b: 'a, T: 'a\n+struct Bar<'a, T: 'a> { x: &'a T }\n+impl<'a, 'b, T> Master<'a, Bar<'b, T>> for () {\n+    fn foo() where 'b: 'a, T: 'a { }\n+}\n+\n+// fn(T): 'a => T: 'a\n+impl<'a, T> Master<'a, fn(T)> for () {\n+    fn foo() where T: 'a { }\n+}\n+\n+// fn() -> T: 'a => T: 'a\n+impl<'a, T> Master<'a, fn() -> T> for () {\n+    fn foo() where T: 'a { }\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "54cfe4be9c10143dbb9bedb3bf533487cf86c859", "filename": "src/test/ui/compare-method/proj-outlives-region.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(extra_requirement_in_impl)]\n+\n+// Test that we elaborate `Type: 'region` constraints and infer various important things.\n+\n+trait Master<'a, T: ?Sized, U> {\n+    fn foo() where T: 'a;\n+}\n+\n+// `U::Item: 'a` does not imply that `U: 'a`\n+impl<'a, U: Iterator> Master<'a, U::Item, U> for () {\n+    fn foo() where U: 'a { } //~ ERROR E0276\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "79293e0deed604bf895d6e8e1419ed496f2e6268", "filename": "src/test/ui/compare-method/proj-outlives-region.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,19 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/proj-outlives-region.rs:22:5\n+   |\n+17 |     fn foo() where T: 'a;\n+   |     --------------------- definition of `foo` from trait\n+...\n+22 |     fn foo() where U: 'a { } //~ ERROR E0276\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #37166 <https://github.com/rust-lang/rust/issues/37166>\n+note: lint level defined here\n+  --> $DIR/proj-outlives-region.rs:12:9\n+   |\n+12 | #![deny(extra_requirement_in_impl)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/proj-outlives-region.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40"}, {"sha": "b0cd3b8fdd29d08b629619ba22c7baa6df5a1fac", "filename": "src/test/ui/compare-method/region-extra-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -17,7 +17,7 @@ trait Tr<'a, T> {\n \n impl<'a, T> Tr<'a, T> for &'a mut [T] {\n     fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n-        //~^ ERROR lifetime bound not satisfied\n+        //~^ ERROR E0276\n         &mut self[..]\n     }\n }", "previous_filename": "src/test/compile-fail/region-bound-extra-bound-in-impl.rs"}, {"sha": "54a551bcfed5d6d794aa45d8670ab9a610d2186b", "filename": "src/test/ui/compare-method/region-extra-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/region-extra-2.rs:19:5\n+   |\n+15 |     fn renew<'b: 'a>(self) -> &'b mut [T];\n+   |     -------------------------------------- definition of `renew` from trait\n+...\n+19 |     fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n+   |     ^ impl has extra requirement `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d61d0250211dc86e9f81a756401ff88f54516d69", "filename": "src/test/ui/compare-method/region-extra.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(extra_requirement_in_impl)]\n+\n+// Test that you cannot add an extra where clause in the impl relating\n+// two regions.\n+\n+trait Master<'a, 'b> {\n+    fn foo();\n+}\n+\n+impl<'a, 'b> Master<'a, 'b> for () {\n+    fn foo() where 'a: 'b { }\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "e657813221a1265e9854a8728e4055a91be39df2", "filename": "src/test/ui/compare-method/region-extra.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/region-extra.rs:22:5\n+   |\n+18 |     fn foo();\n+   |     --------- definition of `foo` from trait\n+...\n+22 |     fn foo() where 'a: 'b { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/region-extra.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40"}, {"sha": "8f79b30bd5f31d8e2fe34bb936cb7457de40fe69", "filename": "src/test/ui/compare-method/region-unrelated.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(extra_requirement_in_impl)]\n+\n+// Test that we elaborate `Type: 'region` constraints and infer various important things.\n+\n+trait Master<'a, T: ?Sized, U> {\n+    fn foo() where T: 'a;\n+}\n+\n+// `U: 'a` does not imply `V: 'a`\n+impl<'a, U, V> Master<'a, U, V> for () {\n+    fn foo() where V: 'a { }\n+    //~^ ERROR parameter type `V` may not live long enough\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "b7cfdf799bc9d1ac4c47db0e20d05348d7d6da0d", "filename": "src/test/ui/compare-method/region-unrelated.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,19 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/region-unrelated.rs:22:5\n+   |\n+17 |     fn foo() where T: 'a;\n+   |     --------------------- definition of `foo` from trait\n+...\n+22 |     fn foo() where V: 'a { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `V: 'a`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #37166 <https://github.com/rust-lang/rust/issues/37166>\n+note: lint level defined here\n+  --> $DIR/region-unrelated.rs:12:9\n+   |\n+12 | #![deny(extra_requirement_in_impl)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/region-unrelated.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40"}, {"sha": "0b844d4521d784867ec3818a3ba736571f12106d", "filename": "src/test/ui/compare-method/reordered-type-param.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -10,6 +10,8 @@\n \n // Tests that ty params get matched correctly when comparing\n // an impl against a trait\n+//\n+// cc #26111\n \n trait A {\n   fn b<C:Clone,D>(&self, x: C) -> C;", "previous_filename": "src/test/compile-fail/issue-2611-5.rs"}, {"sha": "985b85cc4ec4082206eba6f7c9dfb8be4470e12e", "filename": "src/test/ui/compare-method/reordered-type-param.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,14 @@\n+error[E0053]: method `b` has an incompatible type for trait\n+  --> $DIR/reordered-type-param.rs:26:30\n+   |\n+17 |   fn b<C:Clone,D>(&self, x: C) -> C;\n+   |                             - type in trait\n+...\n+26 |   fn b<F:Clone,G>(&self, _x: G) -> G { panic!() } //~ ERROR method `b` has an incompatible type\n+   |                              ^ expected type parameter, found a different type parameter\n+   |\n+   = note: expected type `fn(&E, F) -> F`\n+   = note:    found type `fn(&E, G) -> G`\n+\n+error: aborting due to previous error\n+"}, {"sha": "09e9fb4ca2b62ce02eade07a022a6567bd4203b7", "filename": "src/test/ui/compare-method/trait-bound-on-type-parameter.rs", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that an impl method's bounds aren't *more* restrictive\n-// than the trait method it's implementing\n+// Tests that impl can't add extra `F: Sync` bound aren't *more* restrictive\n+// than the trait method it's implementing.\n+//\n+// Regr test for #26111.\n \n trait A {\n   fn b<C,D>(&self, x: C) -> C;\n@@ -20,8 +22,7 @@ struct E {\n }\n \n impl A for E {\n-    fn b<F: Sync, G>(&self, _x: F) -> F { panic!() }\n-    //~^ ERROR `F: std::marker::Sync` appears on the impl method\n+    fn b<F: Sync, G>(&self, _x: F) -> F { panic!() } //~ ERROR E0276\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-2611-4.rs"}, {"sha": "7112a00c7b7900fd7f305fbc1b79f71a044d21e4", "filename": "src/test/ui/compare-method/trait-bound-on-type-parameter.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftrait-bound-on-type-parameter.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/trait-bound-on-type-parameter.rs:25:5\n+   |\n+17 |   fn b<C,D>(&self, x: C) -> C;\n+   |   ---------------------------- definition of `b` from trait\n+...\n+25 |     fn b<F: Sync, G>(&self, _x: F) -> F { panic!() } //~ ERROR E0276\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `F: std::marker::Sync`\n+\n+error: aborting due to previous error\n+"}, {"sha": "cca282a1d195b679452429fd5e11fbf486c14e42", "filename": "src/test/ui/compare-method/traits-misc-mismatch-1.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -34,15 +34,15 @@ trait Foo {\n impl Foo for isize {\n     // invalid bound for T, was defined as Eq in trait\n     fn test_error1_fn<T: Ord>(&self) {}\n-    //~^ ERROR the requirement `T: std::cmp::Ord` appears on the impl\n+    //~^ ERROR E0276\n \n     // invalid bound for T, was defined as Eq + Ord in trait\n     fn test_error2_fn<T: Eq + B>(&self) {}\n-    //~^ ERROR the requirement `T: B` appears on the impl\n+    //~^ ERROR E0276\n \n     // invalid bound for T, was defined as Eq + Ord in trait\n     fn test_error3_fn<T: B + Eq>(&self) {}\n-    //~^ ERROR the requirement `T: B` appears on the impl\n+    //~^ ERROR E0276\n \n     // multiple bounds, same order as in trait\n     fn test3_fn<T: Ord + Eq>(&self) {}\n@@ -52,16 +52,16 @@ impl Foo for isize {\n \n     // parameters in impls must be equal or more general than in the defining trait\n     fn test_error5_fn<T: B>(&self) {}\n-    //~^ ERROR the requirement `T: B` appears on the impl\n+    //~^ ERROR E0276\n \n     // bound `std::cmp::Eq` not enforced by this implementation, but this is OK\n     fn test6_fn<T: A>(&self) {}\n \n     fn test_error7_fn<T: A + Eq>(&self) {}\n-    //~^ ERROR the requirement `T: std::cmp::Eq` appears on the impl\n+    //~^ ERROR E0276\n \n     fn test_error8_fn<T: C>(&self) {}\n-    //~^ ERROR the requirement `T: C` appears on the impl\n+    //~^ ERROR E0276\n }\n \n trait Getter<T> {\n@@ -74,7 +74,7 @@ trait Trait {\n \n impl Trait for usize {\n     fn method<G: Getter<usize>>(&self) {}\n-    //~^ ERROR `G: Getter<usize>` appears on the impl method\n+    //~^ ERROR E0276\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs"}, {"sha": "f221ebe3302c019dadf23280d4904b519a7955a6", "filename": "src/test/ui/compare-method/traits-misc-mismatch-1.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-1.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,65 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:36:5\n+   |\n+23 |     fn test_error1_fn<T: Eq>(&self);\n+   |     -------------------------------- definition of `test_error1_fn` from trait\n+...\n+36 |     fn test_error1_fn<T: Ord>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: std::cmp::Ord`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:40:5\n+   |\n+24 |     fn test_error2_fn<T: Eq + Ord>(&self);\n+   |     -------------------------------------- definition of `test_error2_fn` from trait\n+...\n+40 |     fn test_error2_fn<T: Eq + B>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: B`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:44:5\n+   |\n+25 |     fn test_error3_fn<T: Eq + Ord>(&self);\n+   |     -------------------------------------- definition of `test_error3_fn` from trait\n+...\n+44 |     fn test_error3_fn<T: B + Eq>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: B`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:54:5\n+   |\n+28 |     fn test_error5_fn<T: A>(&self);\n+   |     ------------------------------- definition of `test_error5_fn` from trait\n+...\n+54 |     fn test_error5_fn<T: B>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: B`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:60:5\n+   |\n+30 |     fn test_error7_fn<T: A>(&self);\n+   |     ------------------------------- definition of `test_error7_fn` from trait\n+...\n+60 |     fn test_error7_fn<T: A + Eq>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: std::cmp::Eq`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:63:5\n+   |\n+31 |     fn test_error8_fn<T: B>(&self);\n+   |     ------------------------------- definition of `test_error8_fn` from trait\n+...\n+63 |     fn test_error8_fn<T: C>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: C`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-1.rs:76:5\n+   |\n+72 |     fn method<G:Getter<isize>>(&self);\n+   |     ---------------------------------- definition of `method` from trait\n+...\n+76 |     fn method<G: Getter<usize>>(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `G: Getter<usize>`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "e82cf256df131fa0a8501fdf6cf10bd87799f999", "filename": "src/test/ui/compare-method/traits-misc-mismatch-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.rs?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -21,7 +21,7 @@ trait IteratorUtil<A>: Sized\n \n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n-    //~^ ERROR the requirement `U: Iterator<B>` appears on the impl method\n+    //~^ ERROR E0276\n         ZipIterator{a: self, b: other}\n     }\n }", "previous_filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs"}, {"sha": "5003550fd1ee3f0b0cb618cdcb70d3f19c11fbb7", "filename": "src/test/ui/compare-method/traits-misc-mismatch-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/traits-misc-mismatch-2.rs:23:5\n+   |\n+19 |     fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n+   |     ------------------------------------------------------------------ definition of `zip` from trait\n+...\n+23 |     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n+   |     ^ impl has extra requirement `U: Iterator<B>`\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa99d35f7aa779924dd17c96675ee50449f3343f", "filename": "src/test/ui/update-references.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ccfc38f034e3f53cb460936bd9744085d4a63b40/src%2Ftest%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fupdate-references.sh?ref=ccfc38f034e3f53cb460936bd9744085d4a63b40", "patch": "@@ -36,12 +36,12 @@ while [[ \"$1\" != \"\" ]]; do\n     STDOUT_NAME=\"${1/%.rs/.stdout}\"\n     shift\n     if [ -f $BUILD_DIR/$STDOUT_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME > /dev/null); then\n+           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME >& /dev/null); then\n         echo updating $MYDIR/$STDOUT_NAME\n         cp $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME\n     fi\n     if [ -f $BUILD_DIR/$STDERR_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME > /dev/null); then\n+           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME >& /dev/null); then\n         echo updating $MYDIR/$STDERR_NAME\n         cp $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME\n     fi"}]}