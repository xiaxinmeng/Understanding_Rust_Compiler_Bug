{"sha": "3e92f90952a2f9afc64079dc0f2dd02dd6484388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOTJmOTA5NTJhMmY5YWZjNjQwNzlkYzBmMmRkMDJkZDY0ODQzODg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-13T10:14:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-13T10:23:36Z"}, "message": "Apply implicit copying for unsafe references to alt patterns", "tree": {"sha": "0c32c8acb969765c0fa5d56d92f17aad4f436019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c32c8acb969765c0fa5d56d92f17aad4f436019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e92f90952a2f9afc64079dc0f2dd02dd6484388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e92f90952a2f9afc64079dc0f2dd02dd6484388", "html_url": "https://github.com/rust-lang/rust/commit/3e92f90952a2f9afc64079dc0f2dd02dd6484388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e92f90952a2f9afc64079dc0f2dd02dd6484388/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f949577218d8c3311406077c31840304719496a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f949577218d8c3311406077c31840304719496a", "html_url": "https://github.com/rust-lang/rust/commit/7f949577218d8c3311406077c31840304719496a"}], "stats": {"total": 193, "additions": 135, "deletions": 58}, "files": [{"sha": "23da42291aa6e69ed2a6e05d2134af2e8596fadb", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 95, "deletions": 45, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -1,7 +1,7 @@\n \n import syntax::{ast, ast_util};\n import ast::{ident, fn_ident, node_id, def_id};\n-import mut::{expr_root, mut_field, inner_mut};\n+import mut::{expr_root, mut_field, deref, field, index, unbox};\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n@@ -21,7 +21,7 @@ type restrict =\n       span: span,\n       local_id: uint,\n       bindings: [node_id],\n-      unsafe_ty: option::t<ty::t>,\n+      unsafe_tys: [ty::t],\n       depends_on: [uint],\n       mutable ok: valid,\n       mutable given_up: bool};\n@@ -192,21 +192,17 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n             }\n         }\n         let root_var = path_def_id(cx, root.ex);\n-        let unsafe_t =\n-            alt inner_mut(root.ds) { some(t) { some(t) } _ { none } };\n-        restricts +=\n-            [\n-             // FIXME kludge\n-             @{root_var: root_var,\n-               node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n-               ty: arg_t.ty,\n-               span: arg.span,\n-               local_id: cx.next_local,\n-               bindings: [arg.id],\n-               unsafe_ty: unsafe_t,\n-               depends_on: deps(sc, root_var),\n-               mutable ok: valid,\n-               mutable given_up: arg_t.mode == ast::by_move}];\n+        restricts += [@{root_var: root_var,\n+                        // FIXME kludge\n+                        node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n+                        ty: arg_t.ty,\n+                        span: arg.span,\n+                        local_id: cx.next_local,\n+                        bindings: [arg.id],\n+                        unsafe_tys: inner_mut(root.ds),\n+                        depends_on: deps(sc, root_var),\n+                        mutable ok: valid,\n+                        mutable given_up: arg_t.mode == ast::by_move}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -217,7 +213,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n     if f_may_close {\n         let i = 0u;\n         for r in restricts {\n-            if !option::is_none(r.unsafe_ty) && cant_copy(cx, r) {\n+            if vec::len(r.unsafe_tys) > 0u && cant_copy(cx, r) {\n                 cx.tcx.sess.span_err(f.span,\n                                      #fmt[\"function may alias with argument \\\n                                            %u, which is not immutably rooted\",\n@@ -228,8 +224,7 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n     }\n     let j = 0u;\n     for r in restricts {\n-        alt r.unsafe_ty {\n-          some(ty) {\n+        for ty in r.unsafe_tys {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ast::by_mut_ref;\n@@ -244,8 +239,6 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n                 }\n                 i += 1u;\n             }\n-          }\n-          _ { }\n         }\n         j += 1u;\n     }\n@@ -279,24 +272,42 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n     v.visit_expr(input, sc, v);\n     let root = expr_root(cx.tcx, input, true);\n     for a: ast::arm in arms {\n-        let dnums = ast_util::pat_binding_ids(a.pats[0]);\n-        let new_sc = sc;\n-        if vec::len(dnums) > 0u {\n-            let root_var = path_def_id(cx, root.ex);\n-            // FIXME need to use separate restrict for each binding\n-            new_sc = @(*sc + [@{root_var: root_var,\n-                                node_id: 0,\n-                                ty: ty::mk_int(cx.tcx),\n-                                span: a.pats[0].span,\n-                                local_id: cx.next_local,\n-                                bindings: dnums,\n-                                unsafe_ty: inner_mut(root.ds),\n-                                depends_on: deps(sc, root_var),\n-                                mutable ok: valid,\n-                                mutable given_up: false}]);\n+        // FIXME handle other | patterns\n+        let new_sc = *sc;\n+        let root_var = path_def_id(cx, root.ex);\n+        let pat_id_map = ast_util::pat_id_map(a.pats[0]);\n+        type info = {id: node_id, mutable unsafe: [ty::t], span: span};\n+        let binding_info: [info] = [];\n+        for pat in a.pats {\n+            for proot in *pattern_roots(cx.tcx, root.ds, pat) {\n+                let canon_id = pat_id_map.get(proot.name);\n+                // FIXME I wanted to use a block, but that hit a\n+                // typestate bug.\n+                fn match(x: info, canon: node_id) -> bool { x.id == canon }\n+                alt vec::find(bind match(_, canon_id), binding_info) {\n+                  some(s) { s.unsafe += inner_mut(proot.ds); }\n+                  none. {\n+                      binding_info += [{id: canon_id,\n+                                        mutable unsafe: inner_mut(proot.ds),\n+                                        span: proot.span}];\n+                  }\n+                }\n+            }\n+        }\n+        for info in binding_info {\n+            new_sc += [@{root_var: root_var,\n+                         node_id: info.id,\n+                         ty: ty::node_id_to_type(cx.tcx, info.id),\n+                         span: info.span,\n+                         local_id: cx.next_local,\n+                         bindings: [info.id],\n+                         unsafe_tys: info.unsafe,\n+                         depends_on: deps(sc, root_var),\n+                         mutable ok: valid,\n+                         mutable given_up: false}];\n         }\n         register_locals(cx, a.pats[0]);\n-        visit::visit_arm(a, new_sc, v);\n+        visit::visit_arm(a, @new_sc, v);\n     }\n }\n \n@@ -323,7 +334,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     let elt_t;\n     alt ty::struct(cx.tcx, seq_t) {\n       ty::ty_vec(mt) {\n-        if mt.mut != ast::imm { unsafe = some(seq_t); }\n+        if mt.mut != ast::imm { unsafe = [seq_t]; }\n         elt_t = mt.ty;\n       }\n       ty::ty_str. { elt_t = ty::mk_mach(cx.tcx, ast::ty_u8); }\n@@ -337,7 +348,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n           span: local.node.pat.span,\n           local_id: cx.next_local,\n           bindings: ast_util::pat_binding_ids(local.node.pat),\n-          unsafe_ty: unsafe,\n+          unsafe_tys: unsafe,\n           depends_on: deps(sc, root_var),\n           mutable ok: valid,\n           mutable given_up: false};\n@@ -354,16 +365,12 @@ fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n         alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n-\n         // excludes variables introduced since the alias was made\n         if my_local_id < r.local_id {\n-            alt r.unsafe_ty {\n-              some(ty) {\n+            for ty in r.unsafe_tys {\n                 if ty_can_unsafely_include(cx, ty, var_t, assign) {\n                     r.ok = val_taken(ex.span, p);\n                 }\n-              }\n-              _ { }\n             }\n         } else if vec::member(my_defnum, r.bindings) {\n             test_scope(cx, sc, r, p);\n@@ -546,6 +553,49 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n     ret score_ty(tcx, ty) > 8u;\n }\n \n+type pattern_root = {id: node_id, name: ident, ds: @[deref], span: span};\n+\n+fn pattern_roots(tcx: ty::ctxt, base: @[deref], pat: @ast::pat)\n+    -> @[pattern_root] {\n+    fn walk(tcx: ty::ctxt, base: [deref], pat: @ast::pat,\n+            &set: [pattern_root]) {\n+        alt pat.node {\n+          ast::pat_wild. | ast::pat_lit(_) {}\n+          ast::pat_bind(nm) {\n+            set += [{id: pat.id, name: nm, ds: @base, span: pat.span}];\n+          }\n+          ast::pat_tag(_, ps) | ast::pat_tup(ps) {\n+            let base = base + [@{mut: false, kind: field,\n+                                 outer_t: ty::node_id_to_type(tcx, pat.id)}];\n+            for p in ps { walk(tcx, base, p, set); }\n+          }\n+          ast::pat_rec(fs, _) {\n+            let ty = ty::node_id_to_type(tcx, pat.id);\n+            for f in fs {\n+                let mut = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm;\n+                let base = base + [@{mut: mut, kind: field, outer_t: ty}];\n+                walk(tcx, base, f.pat, set);\n+            }\n+          }\n+          ast::pat_box(p) {\n+            let ty = ty::node_id_to_type(tcx, pat.id);\n+            let mut = alt ty::struct(tcx, ty) {\n+              ty::ty_box(mt) { mt.mut != ast::imm }\n+            };\n+            walk(tcx, base + [@{mut: mut, kind: unbox, outer_t: ty}], p, set);\n+          }\n+        }\n+    }\n+    let set = [];\n+    walk(tcx, *base, pat, set);\n+    ret @set;\n+}\n+\n+fn inner_mut(ds: @[deref]) -> [ty::t] {\n+    for d: deref in *ds { if d.mut { ret [d.outer_t]; } }\n+    ret [];\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "253b402fb0465764052a88327d27d471612c4622", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -110,11 +110,6 @@ fn mut_field(ds: @[deref]) -> bool {\n     ret false;\n }\n \n-fn inner_mut(ds: @[deref]) -> option::t<ty::t> {\n-    for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n-    ret none;\n-}\n-\n // Actual mut-checking pass\n \n type mut_map = std::map::hashmap<node_id, ()>;"}, {"sha": "0b84f85054a4517f56e1b0f6734e2734582f6ed1", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -471,22 +471,37 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                      ids: ast_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true;\n-    for each item: @{key: ast::ident, val: ast::node_id} in ids.items() {\n+    for each @{key: name, val: node_id} in ids.items() {\n         let llbbs = [];\n         let vals = [];\n         for ex: exit_node in map {\n             if ex.to as uint == our_block {\n-                alt assoc(item.key, ex.bound) {\n+                alt assoc(name, ex.bound) {\n                   some(val) { llbbs += [ex.from]; vals += [val]; }\n                   none. { }\n                 }\n             }\n         }\n         if vec::len(vals) > 0u {\n-            let phi = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n-            bcx.fcx.lllocals.insert(item.val, phi);\n+            let local = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n+            bcx.fcx.lllocals.insert(node_id, local);\n         } else { success = false; }\n     }\n+    if success {\n+        // Copy references that the alias analysis considered unsafe\n+        for each @{val: node_id, _} in ids.items() {\n+            if bcx_ccx(bcx).copy_map.contains_key(node_id) {\n+                let local = bcx.fcx.lllocals.get(node_id);\n+                let e_ty = ty::node_id_to_type(bcx_tcx(bcx), node_id);\n+                let {bcx: abcx, val: alloc} = trans::alloc_ty(bcx, e_ty);\n+                bcx = trans::copy_val(abcx, trans::INIT, alloc,\n+                                      load_if_immediate(abcx, local, e_ty),\n+                                      e_ty);\n+                add_clean(bcx, alloc, e_ty);\n+                bcx.fcx.lllocals.insert(node_id, alloc);\n+            }\n+        }\n+    }\n     ret success;\n }\n "}, {"sha": "082644dbd726cf6a7af41fc95f6c0825c1bc21cd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -45,6 +45,7 @@ export expr_ty_params_and_ty;\n export fold_ty;\n export field;\n export field_idx;\n+export get_field;\n export fm_general;\n export get_element_type;\n export hash_ty;\n@@ -1680,6 +1681,16 @@ fn field_idx(sess: session::session, sp: span, id: ast::ident,\n     sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n+fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n+    alt struct(tcx, rec_ty) {\n+      ty_rec(fields) {\n+        alt vec::find({|f| str::eq(f.ident, id) }, fields) {\n+            some(f) { ret f; }\n+        }\n+      }\n+    }\n+}\n+\n fn method_idx(sess: session::session, sp: span, id: ast::ident,\n               meths: [method]) -> uint {\n     let i: uint = 0u;"}, {"sha": "23daa8bba163d82315d50045f70ca686177b4324", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:invalidate reference x\n \n-fn whoknows(x: @mutable int) { *x = 10; }\n+fn whoknows(x: @mutable {mutable x: int}) { x.x = 10; }\n \n fn main() {\n-    let box = @mutable 1;\n+    let box = @mutable {mutable x: 1};\n     alt *box { x { whoknows(box); log_err x; } }\n }"}, {"sha": "864ba50298b75c358843909c93aca1f5d61f0cc1", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -1,8 +1,8 @@\n // error-pattern:invalidate reference i\n \n-tag foo { left(int); right(bool); }\n+tag foo { left({mutable x: int}); right(bool); }\n \n fn main() {\n-    let x = left(10);\n+    let x = left({mutable x: 10});\n     alt x { left(i) { x = right(false); log i; } _ { } }\n }"}, {"sha": "7bb148b1b9118ee7f9a3fb0c8fdae9efd193528b", "filename": "src/test/run-pass/alt-implicit-copy.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e92f90952a2f9afc64079dc0f2dd02dd6484388/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy.rs?ref=3e92f90952a2f9afc64079dc0f2dd02dd6484388", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = @{mutable a: @10, b: @20};\n+    alt x {\n+      @{a, b} { assert *a == 10; (*x).a = @30; assert *a == 10; }\n+    }\n+}"}]}