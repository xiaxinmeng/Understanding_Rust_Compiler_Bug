{"sha": "9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYTQ5NTNhYTQ0MGNiODVkMTNkNmNjMmE4YTUzMmE3ZDY3NGNmYTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-26T02:21:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-26T02:21:27Z"}, "message": "Rollup merge of #69878 - estebank:chained-ops, r=Centril\n\nTweak chained operators diagnostic\n\nUse more selective spans\nImprove suggestion output\nBe more selective when displaying suggestions\nSilence some knock-down type errors\n\nr? @Centril", "tree": {"sha": "0728045998cae94546f4f6b3164b73dbbcdec9d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0728045998cae94546f4f6b3164b73dbbcdec9d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJefBGnCRBK7hj4Ov3rIwAAdHIIAGN5/z+AqE1uzwKvs9k7TcWC\nN/PN/K48nUoxqYcOHn+5YrRFrMfqtrtNhjoLxy5WDwbxx/SDrZHF3v6IKjIOGK9m\nvA3rkj4bByb0bsAx8+PyEK6hgD4ZM/ZNFUWP3WsClI7OP+q8W/JGCAyMeXCENIRA\nnhUgPAyxgsKTnQdysC2EGiSuca9m+5rs+L10BEYaRcpNzmjVOaiRj4Z+3CmTDFD6\nGTTGWz427/5CjiMjVQahLNVPxNp7fEdfrEyXEnNXlSaEEz+/q/mf6LVFzfjy6DzS\nhnj7A0s0bRsTuXbCQxHk5++0SOo08+tch7/QYdNugVEBU0Fu7HKcYy9XNUGwHFE=\n=DWP7\n-----END PGP SIGNATURE-----\n", "payload": "tree 0728045998cae94546f4f6b3164b73dbbcdec9d3\nparent b105ac40188131b76ef02667847973caf54fd532\nparent 4832f3fd5d471ec7a4bfe4a599d8a4378b6d248d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585189287 +0100\ncommitter GitHub <noreply@github.com> 1585189287 +0100\n\nRollup merge of #69878 - estebank:chained-ops, r=Centril\n\nTweak chained operators diagnostic\n\nUse more selective spans\nImprove suggestion output\nBe more selective when displaying suggestions\nSilence some knock-down type errors\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "html_url": "https://github.com/rust-lang/rust/commit/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b105ac40188131b76ef02667847973caf54fd532", "url": "https://api.github.com/repos/rust-lang/rust/commits/b105ac40188131b76ef02667847973caf54fd532", "html_url": "https://github.com/rust-lang/rust/commit/b105ac40188131b76ef02667847973caf54fd532"}, {"sha": "4832f3fd5d471ec7a4bfe4a599d8a4378b6d248d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4832f3fd5d471ec7a4bfe4a599d8a4378b6d248d", "html_url": "https://github.com/rust-lang/rust/commit/4832f3fd5d471ec7a4bfe4a599d8a4378b6d248d"}], "stats": {"total": 368, "additions": 202, "deletions": 166}, "files": [{"sha": "c4546dedfcdd48db5d90770ad7271bc9b8687e34", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 103, "deletions": 52, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -17,7 +17,6 @@ use rustc_span::symbol::kw;\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};\n-use std::mem;\n \n const TURBOFISH: &str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n \n@@ -459,9 +458,28 @@ impl<'a> Parser<'a> {\n         err: &mut DiagnosticBuilder<'_>,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n-    ) {\n+    ) -> bool /* advanced the cursor */ {\n         if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n-            match (op.node, &outer_op.node) {\n+            if let ExprKind::Field(_, ident) = l1.kind {\n+                if ident.as_str().parse::<i32>().is_err() && !matches!(r1.kind, ExprKind::Lit(_)) {\n+                    // The parser has encountered `foo.bar<baz`, the likelihood of the turbofish\n+                    // suggestion being the only one to apply is high.\n+                    return false;\n+                }\n+            }\n+            let mut enclose = |left: Span, right: Span| {\n+                err.multipart_suggestion(\n+                    \"parenthesize the comparison\",\n+                    vec![\n+                        (left.shrink_to_lo(), \"(\".to_string()),\n+                        (right.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MaybeIncorrect,\n+                );\n+            };\n+            return match (op.node, &outer_op.node) {\n+                // `x == y == z`\n+                (BinOpKind::Eq, AssocOp::Equal) |\n                 // `x < y < z` and friends.\n                 (BinOpKind::Lt, AssocOp::Less) | (BinOpKind::Lt, AssocOp::LessEqual) |\n                 (BinOpKind::Le, AssocOp::LessEqual) | (BinOpKind::Le, AssocOp::Less) |\n@@ -472,35 +490,55 @@ impl<'a> Parser<'a> {\n                         self.span_to_snippet(e.span)\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"split the comparison into two...\",\n-                        format!(\n-                            \"{} {} {} && {} {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"...or parenthesize one of the comparisons\",\n-                        format!(\n-                            \"({} {} {}) {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n+                    err.span_suggestion_verbose(\n+                            inner_op.span.shrink_to_hi(),\n+                        \"split the comparison into two\",\n+                        format!(\" && {}\", expr_to_str(&r1)),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    false // Keep the current parse behavior, where the AST is `(x < y) < z`.\n                 }\n-                _ => {}\n-            }\n+                // `x == y < z`\n+                (BinOpKind::Eq, AssocOp::Less) | (BinOpKind::Eq, AssocOp::LessEqual) |\n+                (BinOpKind::Eq, AssocOp::Greater) | (BinOpKind::Eq, AssocOp::GreaterEqual) => {\n+                    // Consume `z`/outer-op-rhs.\n+                    let snapshot = self.clone();\n+                    match self.parse_expr() {\n+                        Ok(r2) => {\n+                            // We are sure that outer-op-rhs could be consumed, the suggestion is\n+                            // likely correct.\n+                            enclose(r1.span, r2.span);\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            *self = snapshot;\n+                            false\n+                        }\n+                    }\n+                }\n+                // `x > y == z`\n+                (BinOpKind::Lt, AssocOp::Equal) | (BinOpKind::Le, AssocOp::Equal) |\n+                (BinOpKind::Gt, AssocOp::Equal) | (BinOpKind::Ge, AssocOp::Equal) => {\n+                    let snapshot = self.clone();\n+                    // At this point it is always valid to enclose the lhs in parentheses, no\n+                    // further checks are necessary.\n+                    match self.parse_expr() {\n+                        Ok(_) => {\n+                            enclose(l1.span, r1.span);\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            *self = snapshot;\n+                            false\n+                        }\n+                    }\n+                }\n+                _ => false,\n+            };\n         }\n+        false\n     }\n \n     /// Produces an error if comparison operators are chained (RFC #558).\n@@ -534,31 +572,26 @@ impl<'a> Parser<'a> {\n             |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n \n         match inner_op.kind {\n-            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-                // Respan to include both operators.\n-                let op_span = op.span.to(self.prev_token.span);\n-                let mut err =\n-                    self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n-\n-                // If it looks like a genuine attempt to chain operators (as opposed to a\n-                // misformatted turbofish, for instance), suggest a correct form.\n-                self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n+            ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n+                let mut err = self.struct_span_err(\n+                    vec![op.span, self.prev_token.span],\n+                    \"comparison operators cannot be chained\",\n+                );\n \n                 let suggest = |err: &mut DiagnosticBuilder<'_>| {\n                     err.span_suggestion_verbose(\n-                        op_span.shrink_to_lo(),\n+                        op.span.shrink_to_lo(),\n                         TURBOFISH,\n                         \"::\".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n                 };\n \n-                if op.node == BinOpKind::Lt &&\n-                    outer_op.node == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    outer_op.node == AssocOp::Greater\n-                // even in a case like the following:\n+                // Include `<` to provide this recommendation even in a case like\n+                // `Foo<Bar<Baz<Qux, ()>>>`\n+                if op.node == BinOpKind::Lt && outer_op.node == AssocOp::Less\n+                    || outer_op.node == AssocOp::Greater\n                 {\n-                    //     Foo<Bar<Baz<Qux, ()>>>\n                     if outer_op.node == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n@@ -572,7 +605,7 @@ impl<'a> Parser<'a> {\n                         {\n                             // We don't have `foo< bar >(` or `foo< bar >::`, so we rewind the\n                             // parser and bail out.\n-                            mem::replace(self, snapshot.clone());\n+                            *self = snapshot.clone();\n                         }\n                     }\n                     return if token::ModSep == self.token.kind {\n@@ -597,7 +630,7 @@ impl<'a> Parser<'a> {\n                                 expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n-                                mem::replace(self, snapshot);\n+                                *self = snapshot;\n                                 Err(err)\n                             }\n                         }\n@@ -617,15 +650,33 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                     } else {\n-                        // All we know is that this is `foo < bar >` and *nothing* else. Try to\n-                        // be helpful, but don't attempt to recover.\n-                        err.help(TURBOFISH);\n-                        err.help(\"or use `(...)` if you meant to specify fn arguments\");\n-                        // These cases cause too many knock-down errors, bail out (#61329).\n-                        Err(err)\n+                        if !matches!(l1.kind, ExprKind::Lit(_))\n+                            && !matches!(r1.kind, ExprKind::Lit(_))\n+                        {\n+                            // All we know is that this is `foo < bar >` and *nothing* else. Try to\n+                            // be helpful, but don't attempt to recover.\n+                            err.help(TURBOFISH);\n+                            err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                        }\n+\n+                        // If it looks like a genuine attempt to chain operators (as opposed to a\n+                        // misformatted turbofish, for instance), suggest a correct form.\n+                        if self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op)\n+                        {\n+                            err.emit();\n+                            mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n+                        } else {\n+                            // These cases cause too many knock-down errors, bail out (#61329).\n+                            Err(err)\n+                        }\n                     };\n                 }\n+                let recover =\n+                    self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n                 err.emit();\n+                if recover {\n+                    return mk_err_expr(self, inner_op.span.to(self.prev_token.span));\n+                }\n             }\n             _ => {}\n         }\n@@ -643,7 +694,7 @@ impl<'a> Parser<'a> {\n \n         if self.token.kind == token::Eof {\n             // Not entirely sure that what we consumed were fn arguments, rollback.\n-            mem::replace(self, snapshot);\n+            *self = snapshot;\n             Err(())\n         } else {\n             // 99% certain that the suggestion is correct, continue parsing."}, {"sha": "10972697f9fcdc7af0373f94d1493e80b785329e", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -2,16 +2,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:2:20\n    |\n LL |     (0..13).collect<Vec<i32>>();\n-   |                    ^^^^^\n+   |                    ^   ^\n    |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     ((0..13).collect < Vec) <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n@@ -21,7 +13,7 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:4:8\n    |\n LL |     Vec<i32>::new();\n-   |        ^^^^^\n+   |        ^   ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -32,16 +24,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:6:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n-   |                    ^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |                    ^   ^\n    |\n-LL |     ((0..13).collect < Vec) <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();"}, {"sha": "bbd46082c9f901bcc6c22f8de14f1759029bb188", "filename": "src/test/ui/parser/chained-comparison-suggestion.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -37,4 +37,17 @@ fn comp8() {\n     //~^ ERROR mismatched types\n }\n \n+fn comp9() {\n+    1 == 2 < 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp10() {\n+    1 > 2 == false; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp11() {\n+    1 == 2 == 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "067920d12f486c6595229d8eef6c896ba9a055b6", "filename": "src/test/ui/parser/chained-comparison-suggestion.stderr", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -2,127 +2,122 @@ error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:4:7\n    |\n LL |     1 < 2 <= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) <= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:9:7\n    |\n LL |     1 < 2 < 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) < 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:13:7\n    |\n LL |     1 <= 2 < 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) < 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:18:7\n    |\n LL |     1 <= 2 <= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) <= 3;\n-   |     ^^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:23:7\n    |\n LL |     1 > 2 >= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) >= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:28:7\n    |\n LL |     1 > 2 > 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) > 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:32:7\n    |\n LL |     1 >= 2 > 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 >= 2) > 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:36:7\n    |\n LL |     1 >= 2 >= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |            ^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:41:7\n+   |\n+LL |     1 == 2 < 3;\n+   |       ^^   ^\n    |\n-LL |     (1 >= 2) >= 3;\n-   |     ^^^^^^^^^^^\n+help: parenthesize the comparison\n+   |\n+LL |     1 == (2 < 3);\n+   |          ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:45:7\n+   |\n+LL |     1 > 2 == false;\n+   |       ^   ^^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     (1 > 2) == false;\n+   |     ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:49:7\n+   |\n+LL |     1 == 2 == 3;\n+   |       ^^   ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     1 == 2 && 2 == 3;\n+   |            ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/chained-comparison-suggestion.rs:4:14\n@@ -154,6 +149,12 @@ error[E0308]: mismatched types\n LL |     1 >= 2 >= 3;\n    |               ^ expected `bool`, found integer\n \n-error: aborting due to 13 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:49:15\n+   |\n+LL |     1 == 2 == 3;\n+   |               ^ expected `bool`, found integer\n+\n+error: aborting due to 17 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "4e97904ed6d5f9f178aa6954b3673368724c1239", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -4,20 +4,18 @@ struct X;\n fn main() {\n     false == false == false;\n     //~^ ERROR comparison operators cannot be chained\n+    //~| HELP split the comparison into two\n \n     false == 0 < 2;\n     //~^ ERROR comparison operators cannot be chained\n-    //~| ERROR mismatched types\n-    //~| ERROR mismatched types\n+    //~| HELP parenthesize the comparison\n \n     f<X>();\n     //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n     //~^ ERROR comparison operators cannot be chained\n-    //~| HELP split the comparison into two...\n-    //~| ...or parenthesize one of the comparisons\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     use std::convert::identity;"}, {"sha": "7001aa8e8a1d8c279707db8c396f5637ddb2fb71", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=9fa4953aa440cb85d13d6cc2a8a532a7d674cfa3", "patch": "@@ -2,19 +2,29 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:5:11\n    |\n LL |     false == false == false;\n-   |           ^^^^^^^^^^^\n+   |           ^^       ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     false == false && false == false;\n+   |                    ^^^^^^^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:11\n+  --> $DIR/require-parens-for-chained-comparison.rs:9:11\n    |\n LL |     false == 0 < 2;\n-   |           ^^^^^^\n+   |           ^^   ^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     false == (0 < 2);\n+   |              ^     ^\n \n error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:13:6\n    |\n LL |     f<X>();\n-   |      ^^^\n+   |      ^ ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -25,42 +35,21 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:17:6\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n-   |      ^^^^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     f < Result && Result <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |      ^      ^\n    |\n-LL |     (f < Result) <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:24:21\n+  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n    |\n LL |     let _ = identity<u8>;\n-   |                     ^^^^\n+   |                     ^  ^\n    |\n    = help: use `::<...>` instead of `<...>` to specify type arguments\n    = help: or use `(...)` if you meant to specify fn arguments\n \n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:14\n-   |\n-LL |     false == 0 < 2;\n-   |              ^ expected `bool`, found integer\n-\n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:18\n-   |\n-LL |     false == 0 < 2;\n-   |                  ^ expected `bool`, found integer\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}]}