{"sha": "19c53768af6e48514238e4224b5bf5ecd51bc7b1", "node_id": "C_kwDOAAsO6NoAKDE5YzUzNzY4YWY2ZTQ4NTE0MjM4ZTQyMjRiNWJmNWVjZDUxYmM3YjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T04:17:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T04:17:59Z"}, "message": "Auto merge of #108998 - matthiaskrgr:rollup-sxbdulg, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #106921 (Add documentation about the memory layout of `Cell`)\n - #108828 (Emit alias-eq when equating numeric var and projection)\n - #108834 (Do not ICE when we have fn pointer `Fn` obligations with bound vars in the self type)\n - #108900 (fix(lexer): print whitespace warning for \\x0c)\n - #108930 (feat: implement better error for manual impl of `Fn*` traits)\n - #108937 (improve readability of winnowing)\n - #108947 (Don't even try to combine consts with incompatible types)\n - #108976 (Update triagebot rust-analyzer team mention)\n - #108983 (Forbid `#[target_feature]` on safe default implementations)\n\nFailed merges:\n\n - #108950 (Directly construct Inherited in typeck.)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "dcad99f978c904d3aa291e228060729425904476", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcad99f978c904d3aa291e228060729425904476"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c53768af6e48514238e4224b5bf5ecd51bc7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c53768af6e48514238e4224b5bf5ecd51bc7b1", "html_url": "https://github.com/rust-lang/rust/commit/19c53768af6e48514238e4224b5bf5ecd51bc7b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c53768af6e48514238e4224b5bf5ecd51bc7b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dfaa143662ddfd6ed2fecadef20eae0ec5d267d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d", "html_url": "https://github.com/rust-lang/rust/commit/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d"}, {"sha": "f74bb35dad1474cdc8bef411ab95cb04fb6a7bdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74bb35dad1474cdc8bef411ab95cb04fb6a7bdd", "html_url": "https://github.com/rust-lang/rust/commit/f74bb35dad1474cdc8bef411ab95cb04fb6a7bdd"}], "stats": {"total": 715, "additions": 534, "deletions": 181}, "files": [{"sha": "679dc0866f23588fe134af0608b0055271aea86d", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -442,7 +442,7 @@ fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxIndexSet<Symbol> {\n pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n     if let DefKind::AssocFn = tcx.def_kind(id) {\n         let parent_id = tcx.local_parent(id);\n-        if let DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n+        if let DefKind::Trait | DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n             tcx.sess\n                 .struct_span_err(\n                     attr_span,"}, {"sha": "dbe15ed5e9b99f5c3330fcbc9f593fa1a2bd4aab", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -42,6 +42,9 @@ hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n+hir_analysis_parenthesized_fn_trait_expansion =\n+    parenthesized trait syntax expands to `{$expanded_type}`\n+\n hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type"}, {"sha": "156334fe785b9aac901ce8b3487c0b9e22dd0781", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,10 +1,14 @@\n use crate::astconv::AstConv;\n-use crate::errors::{ManualImplementation, MissingTypeParams};\n+use crate::errors::{\n+    AssocTypeBindingNotAllowed, ManualImplementation, MissingTypeParams,\n+    ParenthesizedFnTraitExpansion,\n+};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::FulfillmentError;\n+use rustc_middle::ty::TyCtxt;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n use rustc_span::edit_distance::find_best_match_for_name;\n@@ -78,43 +82,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Do not suggest the other syntax if we are in trait impl:\n             // the desugaring would contain an associated type constraint.\n             if !is_impl {\n-                let args = trait_segment\n-                    .args\n-                    .as_ref()\n-                    .and_then(|args| args.args.get(0))\n-                    .and_then(|arg| match arg {\n-                        hir::GenericArg::Type(ty) => match ty.kind {\n-                            hir::TyKind::Tup(t) => t\n-                                .iter()\n-                                .map(|e| sess.source_map().span_to_snippet(e.span))\n-                                .collect::<Result<Vec<_>, _>>()\n-                                .map(|a| a.join(\", \")),\n-                            _ => sess.source_map().span_to_snippet(ty.span),\n-                        }\n-                        .map(|s| format!(\"({})\", s))\n-                        .ok(),\n-                        _ => None,\n-                    })\n-                    .unwrap_or_else(|| \"()\".to_string());\n-                let ret = trait_segment\n-                    .args()\n-                    .bindings\n-                    .iter()\n-                    .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                        (true, hir::TypeBindingKind::Equality { term }) => {\n-                            let span = match term {\n-                                hir::Term::Ty(ty) => ty.span,\n-                                hir::Term::Const(c) => self.tcx().hir().span(c.hir_id),\n-                            };\n-                            sess.source_map().span_to_snippet(span).ok()\n-                        }\n-                        _ => None,\n-                    })\n-                    .unwrap_or_else(|| \"()\".to_string());\n                 err.span_suggestion(\n                     span,\n                     \"use parenthetical notation instead\",\n-                    format!(\"{}{} -> {}\", trait_segment.ident, args, ret),\n+                    fn_trait_to_string(self.tcx(), trait_segment, true),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -629,3 +600,69 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit();\n     }\n }\n+\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    segment: Option<(&hir::PathSegment<'_>, Span)>,\n+) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span, fn_trait_expansion: if let Some((segment, span)) = segment && segment.args().parenthesized {\n+        Some(ParenthesizedFnTraitExpansion { span, expanded_type: fn_trait_to_string(tcx, segment, false) })\n+    } else {\n+        None\n+    }});\n+}\n+\n+pub(crate) fn fn_trait_to_string(\n+    tcx: TyCtxt<'_>,\n+    trait_segment: &hir::PathSegment<'_>,\n+    parenthesized: bool,\n+) -> String {\n+    let args = trait_segment\n+        .args\n+        .as_ref()\n+        .and_then(|args| args.args.get(0))\n+        .and_then(|arg| match arg {\n+            hir::GenericArg::Type(ty) => match ty.kind {\n+                hir::TyKind::Tup(t) => t\n+                    .iter()\n+                    .map(|e| tcx.sess.source_map().span_to_snippet(e.span))\n+                    .collect::<Result<Vec<_>, _>>()\n+                    .map(|a| a.join(\", \")),\n+                _ => tcx.sess.source_map().span_to_snippet(ty.span),\n+            }\n+            .map(|s| {\n+                // `s.empty()` checks to see if the type is the unit tuple, if so we don't want a comma\n+                if parenthesized || s.is_empty() { format!(\"({})\", s) } else { format!(\"({},)\", s) }\n+            })\n+            .ok(),\n+            _ => None,\n+        })\n+        .unwrap_or_else(|| \"()\".to_string());\n+\n+    let ret = trait_segment\n+        .args()\n+        .bindings\n+        .iter()\n+        .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n+            (true, hir::TypeBindingKind::Equality { term }) => {\n+                let span = match term {\n+                    hir::Term::Ty(ty) => ty.span,\n+                    hir::Term::Const(c) => tcx.hir().span(c.hir_id),\n+                };\n+\n+                (span != tcx.hir().span(trait_segment.hir_id))\n+                    .then_some(tcx.sess.source_map().span_to_snippet(span).ok())\n+                    .flatten()\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or_else(|| \"()\".to_string());\n+\n+    if parenthesized {\n+        format!(\"{}{} -> {}\", trait_segment.ident, args, ret)\n+    } else {\n+        format!(\"{}<{}, Output={}>\", trait_segment.ident, args, ret)\n+    }\n+}"}, {"sha": "2f4963f6bc311aaf3a3ea2b2bab66cd538b1fcdf", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,9 +1,8 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n-    GenericArgCountResult, GenericArgPosition,\n+    errors::prohibit_assoc_ty_binding, CreateSubstsForGenericArgsCtxt, ExplicitLateBound,\n+    GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n };\n-use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -433,7 +432,7 @@ pub(crate) fn check_generic_arg_count(\n         (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n \n     if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            prohibit_assoc_ty_binding(tcx, b.span);\n+             prohibit_assoc_ty_binding(tcx, b.span, None);\n         }\n \n     let explicit_late_bound =\n@@ -589,11 +588,6 @@ pub(crate) fn check_generic_arg_count(\n     }\n }\n \n-/// Emits an error regarding forbidden type binding associations\n-pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-}\n-\n /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n /// are present. This is used both for datatypes and function calls.\n pub(crate) fn prohibit_explicit_late_bound_lifetimes("}, {"sha": "5db404608b36f217fed7dc4f53520fb9237d5d3f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -5,9 +5,8 @@\n mod errors;\n pub mod generics;\n \n-use crate::astconv::generics::{\n-    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n-};\n+use crate::astconv::errors::prohibit_assoc_ty_binding;\n+use crate::astconv::generics::{check_generic_arg_count, create_substs_for_generic_args};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -295,7 +294,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((item_segment, span)));\n         }\n \n         substs\n@@ -631,7 +630,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((item_segment, span)));\n         }\n \n         args\n@@ -825,7 +824,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span, Some((trait_segment, span)));\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -2596,7 +2595,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span, None);\n                 return true;\n             }\n         }"}, {"sha": "8a697b4c514881e56ae21e22cad60f0674a8e2be", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -129,6 +129,18 @@ pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n+\n+    #[subdiagnostic]\n+    pub fn_trait_expansion: Option<ParenthesizedFnTraitExpansion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(hir_analysis_parenthesized_fn_trait_expansion)]\n+pub struct ParenthesizedFnTraitExpansion {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub expanded_type: String,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "37783bc91bb8c821420e7a73909b2141bb7c858f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -148,10 +148,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_ty,\n                         op,\n                     );\n-                    self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n+                    self.demand_eqtype(expr.span, builtin_return_ty, return_ty);\n+                    builtin_return_ty\n+                } else {\n+                    return_ty\n                 }\n-\n-                return_ty\n             }\n         }\n     }"}, {"sha": "8ac82653c0ee80294cfe7c757793eb6e1ba0b36a", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -411,15 +411,28 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n-                t,\n-            ),\n-\n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n-                t,\n-            ),\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n+                        t,\n+                    )\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n+                        t,\n+                    )\n+                }\n+            }\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")"}, {"sha": "a2332797e8680d6c810ce960c4e5ef78809cd218", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -34,7 +34,6 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -119,20 +118,30 @@ impl<'tcx> InferCtxt<'tcx> {\n                 self.unify_float_variable(!a_is_expected, v_id, v)\n             }\n \n-            // All other cases of inference are errors\n-            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            // We don't expect `TyVar` or `Fresh*` vars at this point with lazy norm.\n+            (\n+                ty::Alias(AliasKind::Projection, _),\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+            )\n+            | (\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+                ty::Alias(AliasKind::Projection, _),\n+            ) if self.tcx.trait_solver_next() => {\n+                bug!()\n             }\n \n-            (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n+            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+                if self.tcx.trait_solver_next() =>\n+            {\n                 relation.register_type_equate_obligation(a, b);\n-                Ok(b)\n-            }\n-            (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(b, a);\n                 Ok(a)\n             }\n \n+            // All other cases of inference are errors\n+            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            }\n+\n             _ => ty::relate::super_relate_tys(relation, a, b),\n         }\n     }\n@@ -161,9 +170,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         //\n         // This probe is probably not strictly necessary but it seems better to be safe and not accidentally find\n         // ourselves with a check to find bugs being required for code to compile because it made inference progress.\n-        self.probe(|_| {\n+        let compatible_types = self.probe(|_| {\n             if a.ty() == b.ty() {\n-                return;\n+                return Ok(());\n             }\n \n             // We don't have access to trait solving machinery in `rustc_infer` so the logic for determining if the\n@@ -173,15 +182,24 @@ impl<'tcx> InferCtxt<'tcx> {\n                 (relation.param_env(), a.ty(), b.ty()),\n                 &mut OriginalQueryValues::default(),\n             );\n-\n-            if let Err(NoSolution) = self.tcx.check_tys_might_be_eq(canonical) {\n+            self.tcx.check_tys_might_be_eq(canonical).map_err(|_| {\n                 self.tcx.sess.delay_span_bug(\n                     DUMMY_SP,\n                     &format!(\"cannot relate consts of different types (a={:?}, b={:?})\", a, b,),\n-                );\n-            }\n+                )\n+            })\n         });\n \n+        // If the consts have differing types, just bail with a const error with\n+        // the expected const's type. Specifically, we don't want const infer vars\n+        // to do any type shapeshifting before and after resolution.\n+        if let Err(guar) = compatible_types {\n+            return Ok(self.tcx.const_error_with_guaranteed(\n+                if relation.a_is_expected() { a.ty() } else { b.ty() },\n+                guar,\n+            ));\n+        }\n+\n         match (a.kind(), b.kind()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),"}, {"sha": "4a834957959dbef27b8df1247ed235c198fd1d9f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1363,6 +1363,28 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().const_unification_table().find(var)\n     }\n \n+    /// Resolves an int var to a rigid int type, if it was constrained to one,\n+    /// or else the root int var in the unification table.\n+    pub fn opportunistic_resolve_int_var(&self, vid: ty::IntVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.int_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_int_var(inner.int_unification_table().find(vid))\n+        }\n+    }\n+\n+    /// Resolves a float var to a rigid int type, if it was constrained to one,\n+    /// or else the root float var in the unification table.\n+    pub fn opportunistic_resolve_float_var(&self, vid: ty::FloatVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.float_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_float_var(inner.float_unification_table().find(vid))\n+        }\n+    }\n+\n     /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n     /// are unaffected. If a type/const variable has not been unified, it"}, {"sha": "bb4d91247b81d04eefa2c80523d8fa6d8f1b6857", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -298,10 +298,10 @@ where\n         }\n         let tail = &tail[first_non_space..];\n         if let Some(c) = tail.chars().nth(0) {\n-            // For error reporting, we would like the span to contain the character that was not\n-            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-            let end = start + first_non_space + c.len_utf8() + 1;\n             if c.is_whitespace() {\n+                // For error reporting, we would like the span to contain the character that was not\n+                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+                let end = start + first_non_space + c.len_utf8() + 1;\n                 callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n             }\n         }"}, {"sha": "42101f6b93152a446030f803285b5c29f101f38d", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -135,6 +135,9 @@ impl<'tcx> Const<'tcx> {\n                 _,\n                 &hir::Path { res: Res::Def(DefKind::ConstParam, def_id), .. },\n             )) => {\n+                // Use the type from the param's definition, since we can resolve it,\n+                // not the expected parameter type from WithOptConstParam.\n+                let param_ty = tcx.type_of(def_id).subst_identity();\n                 match tcx.named_bound_var(expr.hir_id) {\n                     Some(rbv::ResolvedArg::EarlyBound(_)) => {\n                         // Find the name and index of the const parameter by indexing the generics of\n@@ -143,14 +146,14 @@ impl<'tcx> Const<'tcx> {\n                         let generics = tcx.generics_of(item_def_id);\n                         let index = generics.param_def_id_to_index[&def_id];\n                         let name = tcx.item_name(def_id);\n-                        Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+                        Some(tcx.mk_const(ty::ParamConst::new(index, name), param_ty))\n                     }\n                     Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => Some(tcx.mk_const(\n                         ty::ConstKind::Bound(debruijn, ty::BoundVar::from_u32(index)),\n-                        ty,\n+                        param_ty,\n                     )),\n                     Some(rbv::ResolvedArg::Error(guar)) => {\n-                        Some(tcx.const_error_with_guaranteed(ty, guar))\n+                        Some(tcx.const_error_with_guaranteed(param_ty, guar))\n                     }\n                     arg => bug!(\"unexpected bound var resolution for {:?}: {arg:?}\", expr.hir_id),\n                 }"}, {"sha": "d9bfacd6e3cf35cf11945661f77d14ab139041f2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> Term<'tcx> {\n \n     pub fn is_infer(&self) -> bool {\n         match self.unpack() {\n-            TermKind::Ty(ty) => ty.is_ty_or_numeric_infer(),\n+            TermKind::Ty(ty) => ty.is_ty_var(),\n             TermKind::Const(ct) => ct.is_ct_infer(),\n         }\n     }"}, {"sha": "ab7931d74d766b69e6de4877909dbae73db3f8dc", "filename": "compiler/rustc_parse/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Flocales%2Fen-US.ftl?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -709,7 +709,7 @@ parse_zero_chars = empty character literal\n parse_lone_slash = invalid trailing slash in literal\n     .label = {parse_lone_slash}\n \n-parse_unskipped_whitespace = non-ASCII whitespace symbol '{$ch}' is not skipped\n+parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n     .label = {parse_unskipped_whitespace}\n \n parse_multiple_skipped_lines = multiple lines skipped by escaped newline"}, {"sha": "7ee4f33230630d0a55a93f0000985a8301708aa9", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -278,16 +278,16 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                     Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                 }\n             }\n-            ty::Infer(ty::IntVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {\n                     CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n                 }\n             }\n-            ty::Infer(ty::FloatVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {"}, {"sha": "ee41d840bae926e17bf4860c91352508870fbabe", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -601,10 +601,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n         let tcx = self.tcx();\n-        let self_ty = self\n+\n+        let Some(self_ty) = self\n             .infcx\n-            .shallow_resolve(obligation.self_ty().no_bound_vars())\n-            .expect(\"fn pointer should not capture bound vars from predicate\");\n+            .shallow_resolve(obligation.self_ty().no_bound_vars()) else\n+        {\n+            // FIXME: Ideally we'd support `for<'a> fn(&'a ()): Fn(&'a ())`,\n+            // but we do not currently. Luckily, such a bound is not\n+            // particularly useful, so we don't expect users to write\n+            // them often.\n+            return Err(SelectionError::Unimplemented);\n+        };\n+\n         let sig = self_ty.fn_sig(tcx);\n         let trait_ref = closure_trait_ref_and_return_type(\n             tcx,"}, {"sha": "ba4df2b3720efbbb041f89f63e8a39ab9adea0b5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 67, "deletions": 40, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -465,14 +465,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                let should_drop_i = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n                     self.candidate_should_be_dropped_in_favor_of(\n                         &candidates[i],\n                         &candidates[j],\n                         needs_infer,\n-                    )\n+                    ) == DropVictim::Yes\n                 });\n-                if is_dup {\n+                if should_drop_i {\n                     debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                     candidates.swap_remove(i);\n                 } else {\n@@ -1842,16 +1842,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ProjectionMatchesProjection::No\n         }\n     }\n+}\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // WINNOW\n-    //\n-    // Winnowing is the process of attempting to resolve ambiguity by\n-    // probing further. During the winnowing process, we unify all\n-    // type variables and then we also attempt to evaluate recursive\n-    // bounds to see if they are satisfied.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum DropVictim {\n+    Yes,\n+    No,\n+}\n \n-    /// Returns `true` if `victim` should be dropped in favor of\n+/// ## Winnowing\n+///\n+/// Winnowing is the process of attempting to resolve ambiguity by\n+/// probing further. During the winnowing process, we unify all\n+/// type variables and then we also attempt to evaluate recursive\n+/// bounds to see if they are satisfied.\n+impl<'tcx> SelectionContext<'_, 'tcx> {\n+    /// Returns `DropVictim::Yes` if `victim` should be dropped in favor of\n     /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n     ///\n@@ -1861,9 +1867,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n         needs_infer: bool,\n-    ) -> bool {\n+    ) -> DropVictim {\n         if victim.candidate == other.candidate {\n-            return true;\n+            return DropVictim::Yes;\n         }\n \n         // Check if a bound would previously have been removed when normalizing\n@@ -1887,11 +1893,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // FIXME(@jswrenn): this should probably be more sophisticated\n-            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => false,\n+            (TransmutabilityCandidate, _) | (_, TransmutabilityCandidate) => DropVictim::No,\n \n             // (*)\n-            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => true,\n-            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => false,\n+            (BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_), _) => {\n+                DropVictim::Yes\n+            }\n+            (_, BuiltinCandidate { has_nested: false } | ConstDestructCandidate(_)) => {\n+                DropVictim::No\n+            }\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 let same_except_bound_vars = other.skip_binder().trait_ref\n@@ -1905,28 +1915,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // or the current one if tied (they should both evaluate to the same answer). This is\n                     // probably best characterized as a \"hack\", since we might prefer to just do our\n                     // best to *not* create essentially duplicate candidates in the first place.\n-                    other.bound_vars().len() <= victim.bound_vars().len()\n+                    if other.bound_vars().len() <= victim.bound_vars().len() {\n+                        DropVictim::Yes\n+                    } else {\n+                        DropVictim::No\n+                    }\n                 } else if other.skip_binder().trait_ref == victim.skip_binder().trait_ref\n                     && victim.skip_binder().constness == ty::BoundConstness::NotConst\n                     && other.skip_binder().polarity == victim.skip_binder().polarity\n                 {\n                     // Drop otherwise equivalent non-const candidates in favor of const candidates.\n-                    true\n+                    DropVictim::Yes\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n             // Drop otherwise equivalent non-const fn pointer candidates\n-            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => true,\n+            (FnPointerCandidate { .. }, FnPointerCandidate { is_const: false }) => DropVictim::Yes,\n \n-            // Global bounds from the where clause should be ignored\n-            // here (see issue #50825). Otherwise, we have a where\n-            // clause so don't go around looking for impls.\n-            // Arbitrarily give param candidates priority\n-            // over projection and object candidates.\n             (\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref other_cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate { .. }\n                 | GeneratorCandidate\n@@ -1939,11 +1948,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitAliasCandidate\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(..),\n-            ) => !is_global(cand),\n-            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref cand)) => {\n+            ) => {\n+                if is_global(other_cand) {\n+                    DropVictim::No\n+                } else {\n+                    // We have a where clause so don't go around looking\n+                    // for impls. Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    //\n+                    // Global bounds from the where clause should be ignored\n+                    // here (see issue #50825).\n+                    DropVictim::Yes\n+                }\n+            }\n+            (ObjectCandidate(_) | ProjectionCandidate(..), ParamCandidate(ref victim_cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand)\n+                if is_global(victim_cand) { DropVictim::Yes } else { DropVictim::No }\n             }\n             (\n                 ImplCandidate(_)\n@@ -1956,18 +1977,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-                ParamCandidate(ref cand),\n+                ParamCandidate(ref victim_cand),\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+                if is_global(victim_cand) && other.evaluation.must_apply_modulo_regions() {\n+                    DropVictim::Yes\n+                } else {\n+                    DropVictim::No\n+                }\n             }\n \n             (ProjectionCandidate(i, _), ProjectionCandidate(j, _))\n             | (ObjectCandidate(i), ObjectCandidate(j)) => {\n                 // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i < j && !needs_infer\n+                if i < j && !needs_infer { DropVictim::Yes } else { DropVictim::No }\n             }\n             (ObjectCandidate(_), ProjectionCandidate(..))\n             | (ProjectionCandidate(..), ObjectCandidate(_)) => {\n@@ -1987,7 +2012,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n-            ) => true,\n+            ) => DropVictim::Yes,\n \n             (\n                 ImplCandidate(..)\n@@ -2001,7 +2026,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate,\n                 ObjectCandidate(_) | ProjectionCandidate(..),\n-            ) => false,\n+            ) => DropVictim::No,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n@@ -2014,7 +2039,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let tcx = self.tcx();\n                 if other.evaluation.must_apply_modulo_regions() {\n                     if tcx.specializes((other_def, victim_def)) {\n-                        return true;\n+                        return DropVictim::Yes;\n                     }\n                 }\n \n@@ -2060,13 +2085,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // will then correctly report an inference error, since the\n                             // existence of multiple marker trait impls tells us nothing\n                             // about which one should actually apply.\n-                            !needs_infer\n+                            if needs_infer { DropVictim::No } else { DropVictim::Yes }\n                         }\n-                        Some(_) => true,\n-                        None => false,\n+                        Some(_) => DropVictim::Yes,\n+                        None => DropVictim::No,\n                     }\n                 } else {\n-                    false\n+                    DropVictim::No\n                 }\n             }\n \n@@ -2092,10 +2117,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitUpcastingUnsizeCandidate(_)\n                 | BuiltinCandidate { has_nested: true }\n                 | TraitAliasCandidate,\n-            ) => false,\n+            ) => DropVictim::No,\n         }\n     }\n+}\n \n+impl<'tcx> SelectionContext<'_, 'tcx> {\n     fn sized_conditions(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}, {"sha": "fcfb60b26030f4d5696d8bce23aa16d543577d3e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -99,10 +99,10 @@ pub fn translate_substs<'tcx>(\n             }\n \n             fulfill_implication(infcx, param_env, source_trait_ref, target_impl).unwrap_or_else(\n-                |_| {\n+                |()| {\n                     bug!(\n-                        \"When translating substitutions for specialization, the expected \\\n-                         specialization failed to hold\"\n+                        \"When translating substitutions from {source_impl:?} to {target_impl:?}, \\\n+                        the expected specialization failed to hold\"\n                     )\n                 },\n             )"}, {"sha": "9d1720acf36637f2651ff55d86a0e6b7db22a8be", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -209,6 +209,12 @@ pub use once::OnceCell;\n \n /// A mutable memory location.\n ///\n+/// # Memory layout\n+///\n+/// `Cell<T>` has the same [memory layout and caveats as\n+/// `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n+/// `Cell<T>` has the same in-memory representation as its inner type `T`.\n+///\n /// # Examples\n ///\n /// In this example, you can see that `Cell<T>` enables mutation inside an"}, {"sha": "daa13277be0a08a32d3237ad781733a36a10f197", "filename": "tests/ui/const-generics/type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftype_mismatch.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,5 +1,6 @@\n fn foo<const N: usize>() -> [u8; N] {\n     bar::<N>() //~ ERROR mismatched types\n+    //~^ ERROR the constant `N` is not of type `u8`\n }\n \n fn bar<const N: u8>() -> [u8; N] {}"}, {"sha": "6d8955e411ec39eaf29df0ca33d8c0b8355baf82", "filename": "tests/ui/const-generics/type_mismatch.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftype_mismatch.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,23 +1,35 @@\n+error: the constant `N` is not of type `u8`\n+  --> $DIR/type_mismatch.rs:2:5\n+   |\n+LL |     bar::<N>()\n+   |     ^^^^^^^^\n+   |\n+note: required by a bound in `bar`\n+  --> $DIR/type_mismatch.rs:6:8\n+   |\n+LL | fn bar<const N: u8>() -> [u8; N] {}\n+   |        ^^^^^^^^^^^ required by this bound in `bar`\n+\n error[E0308]: mismatched types\n   --> $DIR/type_mismatch.rs:2:11\n    |\n LL |     bar::<N>()\n    |           ^ expected `u8`, found `usize`\n \n error[E0308]: mismatched types\n-  --> $DIR/type_mismatch.rs:5:26\n+  --> $DIR/type_mismatch.rs:6:26\n    |\n LL | fn bar<const N: u8>() -> [u8; N] {}\n    |    ---                   ^^^^^^^ expected `[u8; N]`, found `()`\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n error[E0308]: mismatched types\n-  --> $DIR/type_mismatch.rs:5:31\n+  --> $DIR/type_mismatch.rs:6:31\n    |\n LL | fn bar<const N: u8>() -> [u8; N] {}\n    |                               ^ expected `usize`, found `u8`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "917abaed15e06e741caa2ec38b389eda67cfa18c", "filename": "tests/ui/const-generics/type_not_in_scope.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -6,6 +6,5 @@ impl X {\n }\n fn getn<const N: cfg_attr>() -> [u8; N] {}\n //~^ ERROR expected type, found built-in attribute `cfg_attr`\n-//~| ERROR mismatched types\n \n fn main() {}"}, {"sha": "5eb81ca0522412278bad70464974644eab16782b", "filename": "tests/ui/const-generics/type_not_in_scope.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Ftype_not_in_scope.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -10,15 +10,7 @@ error[E0573]: expected type, found built-in attribute `cfg_attr`\n LL | fn getn<const N: cfg_attr>() -> [u8; N] {}\n    |                  ^^^^^^^^ not a type\n \n-error[E0308]: mismatched types\n-  --> $DIR/type_not_in_scope.rs:7:33\n-   |\n-LL | fn getn<const N: cfg_attr>() -> [u8; N] {}\n-   |    ----                         ^^^^^^^ expected `[u8; N]`, found `()`\n-   |    |\n-   |    implicitly returns `()` as its body has no tail or `return` expression\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0308, E0412, E0573.\n-For more information about an error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0412, E0573.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "b1613f638d301796f89f3b8faa7defbfb704660a", "filename": "tests/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -64,6 +64,12 @@ error[E0229]: associated type bindings are not allowed here\n    |\n LL | impl FnOnce() for Foo1 {\n    |      ^^^^^^^^ associated type not allowed here\n+   |\n+help: parenthesized trait syntax expands to `FnOnce<(), Output=()>`\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:6\n+   |\n+LL | impl FnOnce() for Foo1 {\n+   |      ^^^^^^^^\n \n error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:6"}, {"sha": "5872f1007b015374cfde0c3ec2cd04060ea1fe91", "filename": "tests/ui/fn/issue-39259.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffn%2Fissue-39259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffn%2Fissue-39259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Fissue-39259.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,13 @@\n+#![feature(fn_traits)]\n+#![feature(unboxed_closures)]\n+\n+struct S;\n+\n+impl Fn(u32) -> u32 for S {\n+//~^ ERROR associated type bindings are not allowed here [E0229]\n+    fn call(&self) -> u32 {\n+        5\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b656b76bfe4eb4725a5f2797e20ad0fea7b69d61", "filename": "tests/ui/fn/issue-39259.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffn%2Fissue-39259.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ffn%2Fissue-39259.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Fissue-39259.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,15 @@\n+error[E0229]: associated type bindings are not allowed here\n+  --> $DIR/issue-39259.rs:6:17\n+   |\n+LL | impl Fn(u32) -> u32 for S {\n+   |                 ^^^ associated type not allowed here\n+   |\n+help: parenthesized trait syntax expands to `Fn<(u32,), Output=u32>`\n+  --> $DIR/issue-39259.rs:6:6\n+   |\n+LL | impl Fn(u32) -> u32 for S {\n+   |      ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0229`."}, {"sha": "9af6bc45c7a060c14ff3f875983ce0bdaf2ef3a8", "filename": "tests/ui/higher-rank-trait-bounds/fn-ptr.classic.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.classic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.classic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.classic.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: expected a `Fn<(&'w (),)>` closure, found `fn(&'w ())`\n+  --> $DIR/fn-ptr.rs:12:5\n+   |\n+LL |     ice();\n+   |     ^^^ expected an `Fn<(&'w (),)>` closure, found `fn(&'w ())`\n+   |\n+   = help: the trait `for<'w> Fn<(&'w (),)>` is not implemented for `fn(&'w ())`\n+note: required by a bound in `ice`\n+  --> $DIR/fn-ptr.rs:7:25\n+   |\n+LL | fn ice()\n+   |    --- required by a bound in this function\n+LL | where\n+LL |     for<'w> fn(&'w ()): Fn(&'w ()),\n+   |                         ^^^^^^^^^^ required by this bound in `ice`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "853160f961245ce3388972fd4c4e68f27fb0c767", "filename": "tests/ui/higher-rank-trait-bounds/fn-ptr.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Ffn-ptr.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,14 @@\n+// revisions: classic next\n+//[next] compile-flags: -Ztrait-solver=next\n+//[next] check-pass\n+\n+fn ice()\n+where\n+    for<'w> fn(&'w ()): Fn(&'w ()),\n+{\n+}\n+\n+fn main() {\n+    ice();\n+    //[classic]~^ ERROR expected a `Fn<(&'w (),)>` closure, found `fn(&'w ())`\n+}"}, {"sha": "b4f09fbbb04d03806cbc890c692cdb00d1690f3c", "filename": "tests/ui/issues/issue-66667-function-cmp-cycle.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,16 +1,19 @@\n fn first() {\n     second == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn second() {\n     first == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn bar() {\n     bar == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "d9a960ce197305ff313fa7b4dc309b1a7675bbc0", "filename": "tests/ui/issues/issue-66667-function-cmp-cycle.stderr", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -15,41 +15,65 @@ LL |     second == 1\n    = note: expected fn item `fn() {second}`\n                  found type `{integer}`\n \n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:2:5\n+   |\n+LL | fn first() {\n+   |            - help: try adding a return type: `-> bool`\n+LL |     second == 1\n+   |     ^^^^^^^^^^^ expected `()`, found `bool`\n+\n error[E0369]: binary operation `==` cannot be applied to type `fn() {first}`\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:7:11\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:11\n    |\n LL |     first == 1\n    |     ----- ^^ - {integer}\n    |     |\n    |     fn() {first}\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:7:14\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:14\n    |\n LL |     first == 1\n    |              ^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() {first}`\n                  found type `{integer}`\n \n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:5\n+   |\n+LL | fn second() {\n+   |             - help: try adding a return type: `-> bool`\n+LL |     first == 1\n+   |     ^^^^^^^^^^ expected `()`, found `bool`\n+\n error[E0369]: binary operation `==` cannot be applied to type `fn() {bar}`\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:12:9\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:9\n    |\n LL |     bar == 1\n    |     --- ^^ - {integer}\n    |     |\n    |     fn() {bar}\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:12:12\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:12\n    |\n LL |     bar == 1\n    |            ^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() {bar}`\n                  found type `{integer}`\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:5\n+   |\n+LL | fn bar() {\n+   |          - help: try adding a return type: `-> bool`\n+LL |     bar == 1\n+   |     ^^^^^^^^ expected `()`, found `bool`\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0369.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "5b93eff86142d7d2a6f9ab2d62536e1375177c3b", "filename": "tests/ui/lifetimes/issue-95023.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Flifetimes%2Fissue-95023.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Flifetimes%2Fissue-95023.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-95023.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -25,6 +25,12 @@ error[E0229]: associated type bindings are not allowed here\n    |\n LL | impl Fn(&isize) for Error {\n    |      ^^^^^^^^^^ associated type not allowed here\n+   |\n+help: parenthesized trait syntax expands to `Fn<(&isize,), Output=()>`\n+  --> $DIR/issue-95023.rs:3:6\n+   |\n+LL | impl Fn(&isize) for Error {\n+   |      ^^^^^^^^^^\n \n error[E0220]: associated type `B` not found for `Self`\n   --> $DIR/issue-95023.rs:6:44"}, {"sha": "9108f27b5f7f8297d687f2dfc056d12e25b89ca0", "filename": "tests/ui/rfcs/rfc-2396-target_feature-11/trait-impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -18,4 +18,10 @@ impl Foo for Bar {\n     unsafe fn unsf_foo(&self) {}\n }\n \n+trait Qux {\n+    #[target_feature(enable = \"sse2\")]\n+    //~^ ERROR cannot be applied to safe trait method\n+    fn foo(&self) {}\n+}\n+\n fn main() {}"}, {"sha": "eb0f18edd34011d2089175b2eb8fe2c9b0dfa0c2", "filename": "tests/ui/rfcs/rfc-2396-target_feature-11/trait-impl.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ftrait-impl.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,3 +1,12 @@\n+error: `#[target_feature(..)]` cannot be applied to safe trait method\n+  --> $DIR/trait-impl.rs:22:5\n+   |\n+LL |     #[target_feature(enable = \"sse2\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot be applied to safe trait method\n+LL |\n+LL |     fn foo(&self) {}\n+   |     ------------- not an `unsafe` function\n+\n error: `#[target_feature(..)]` cannot be applied to safe trait method\n   --> $DIR/trait-impl.rs:13:5\n    |\n@@ -7,5 +16,5 @@ LL |\n LL |     fn foo(&self) {}\n    |     ------------- not an `unsafe` function\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "582b480aa25be35832fb29bc8f1a0c43efc5dfbd", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,12 @@\n+#![feature(min_specialization)]\n+\n+// An impl that has an erroneous const substitution should not specialize one\n+// that is well-formed.\n+\n+struct S<const L: usize>;\n+\n+impl<const N: i32> Copy for S<N> {}\n+impl<const M: usize> Copy for S<M> {}\n+//~^ ERROR conflicting implementations of trait `Copy` for type `S<_>`\n+\n+fn main() {}"}, {"sha": "a3906a9a22fecee28315ba2a9aa6c11855764fff", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `Copy` for type `S<_>`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:9:1\n+   |\n+LL | impl<const N: i32> Copy for S<N> {}\n+   | -------------------------------- first implementation here\n+LL | impl<const M: usize> Copy for S<M> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `S<_>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "10a72421f24a7da7f9e610b809604666e081866a", "filename": "tests/ui/str/str-escape.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fstr%2Fstr-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fstr%2Fstr-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstr%2Fstr-escape.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,11 +1,31 @@\n // check-pass\n+// ignore-tidy-tab\n+\n fn main() {\n     let s = \"\\\n \n              \";\n     //~^^^ WARNING multiple lines skipped by escaped newline\n+    assert_eq!(s, \"\");\n+\n     let s = \"foo\\\n   \u00a0          bar\n              \";\n-    //~^^^ WARNING non-ASCII whitespace symbol '\\u{a0}' is not skipped\n+    //~^^^ WARNING whitespace symbol '\\u{a0}' is not skipped\n+    assert_eq!(s, \"foo\u00a0          bar\\n             \");\n+\n+    let s = \"a\\\n+ b\";\n+    assert_eq!(s, \"ab\");\n+\n+    let s = \"a\\\n+\tb\";\n+    assert_eq!(s, \"ab\");\n+\n+    let s = \"a\\\n+    \fb\";\n+    //~^^ WARNING whitespace symbol '\\u{c}' is not skipped\n+    // '\\x0c' is ASCII whitespace, but it may not need skipped\n+    // discussion: https://github.com/rust-lang/rust/pull/108403\n+    assert_eq!(s, \"a\\x0cb\");\n }"}, {"sha": "43b4f7e36f6abc1b72ca43fc3b76b6505ee93381", "filename": "tests/ui/str/str-escape.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fstr%2Fstr-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Fstr%2Fstr-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstr%2Fstr-escape.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,21 +1,31 @@\n warning: multiple lines skipped by escaped newline\n-  --> $DIR/str-escape.rs:3:14\n+  --> $DIR/str-escape.rs:5:14\n    |\n LL |       let s = \"\\\n    |  ______________^\n LL | |\n LL | |              \";\n    | |_____________^ skipping everything up to and including this point\n \n-warning: non-ASCII whitespace symbol '\\u{a0}' is not skipped\n-  --> $DIR/str-escape.rs:7:17\n+warning: whitespace symbol '\\u{a0}' is not skipped\n+  --> $DIR/str-escape.rs:11:17\n    |\n LL |       let s = \"foo\\\n    |  _________________^\n LL | |   \u00a0          bar\n-   | |   ^ non-ASCII whitespace symbol '\\u{a0}' is not skipped\n+   | |   ^ whitespace symbol '\\u{a0}' is not skipped\n    | |___|\n    | \n \n-warning: 2 warnings emitted\n+warning: whitespace symbol '\\u{c}' is not skipped\n+  --> $DIR/str-escape.rs:25:15\n+   |\n+LL |       let s = \"a\\\n+   |  _______________^\n+LL | |     \fb\";\n+   | |    ^- whitespace symbol '\\u{c}' is not skipped\n+   | |____|\n+   | \n+\n+warning: 3 warnings emitted\n "}, {"sha": "b647f9794bd9518158ce74072f4582df45b4f5c0", "filename": "tests/ui/traits/issue-87558.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fissue-87558.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fissue-87558.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-87558.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -17,6 +17,12 @@ error[E0229]: associated type bindings are not allowed here\n    |\n LL | impl Fn(&isize) for Error {\n    |      ^^^^^^^^^^ associated type not allowed here\n+   |\n+help: parenthesized trait syntax expands to `Fn<(&isize,), Output=()>`\n+  --> $DIR/issue-87558.rs:3:6\n+   |\n+LL | impl Fn(&isize) for Error {\n+   |      ^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3f7316a2279d3e8ab2cf66b3c8625cef0b34c67b", "filename": "tests/ui/traits/new-solver/canonical-int-var-eq-in-response.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+trait Mirror {\n+    type Assoc;\n+}\n+\n+impl<T> Mirror for T {\n+    type Assoc = T;\n+}\n+\n+trait Test {}\n+impl Test for i64 {}\n+impl Test for u64 {}\n+\n+fn mirror_me<T: Mirror>(t: T, s: <T as Mirror>::Assoc) where <T as Mirror>::Assoc: Test {}\n+\n+fn main() {\n+    let mut x = 0;\n+    mirror_me(x, 1);\n+    x = 1i64;\n+}"}, {"sha": "2da387db4a99f9171a120045994bdf4b21ad805c", "filename": "tests/ui/traits/new-solver/int-var-alias-eq.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+// HIR typeck ends up equating `<_#0i as Add>::Output == _#0i`.\n+// Want to make sure that we emit an alias-eq goal for this,\n+// instead of treating it as a type error and bailing.\n+\n+fn test() {\n+    // fallback\n+    let x = 1 + 2;\n+}\n+\n+fn test2() -> u32 {\n+    // expectation from return ty\n+    1 + 2\n+}\n+\n+fn main() {}"}, {"sha": "2b966609108bf97bea60e3ed87d551c150641cf8", "filename": "tests/ui/transmutability/issue-101739-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftransmutability%2Fissue-101739-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftransmutability%2Fissue-101739-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fissue-101739-1.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -6,7 +6,7 @@ mod assert {\n     pub fn is_transmutable<Src, Context, const ASSUME_ALIGNMENT: bool>()\n     where\n         Dst: BikeshedIntrinsicFrom<Src, Context, ASSUME_ALIGNMENT>, //~ ERROR cannot find type `Dst` in this scope\n-        //~^ ERROR mismatched types\n+        //~^ the constant `ASSUME_ALIGNMENT` is not of type `Assume`\n     {\n     }\n }"}, {"sha": "f0fa93722b89bf48960026be3df02a186bcdf4f6", "filename": "tests/ui/transmutability/issue-101739-1.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fissue-101739-1.stderr?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -4,13 +4,15 @@ error[E0412]: cannot find type `Dst` in this scope\n LL |         Dst: BikeshedIntrinsicFrom<Src, Context, ASSUME_ALIGNMENT>,\n    |         ^^^ not found in this scope\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-101739-1.rs:8:50\n+error: the constant `ASSUME_ALIGNMENT` is not of type `Assume`\n+  --> $DIR/issue-101739-1.rs:8:14\n    |\n LL |         Dst: BikeshedIntrinsicFrom<Src, Context, ASSUME_ALIGNMENT>,\n-   |                                                  ^^^^^^^^^^^^^^^^ expected `Assume`, found `bool`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: required by a bound in `BikeshedIntrinsicFrom`\n+  --> $SRC_DIR/core/src/mem/transmutability.rs:LL:COL\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0308, E0412.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "3b261062f782e6c1d227379a4fbb14d6a566d0b4", "filename": "tests/ui/typeck/lazy-norm/cast-checks-handling-projections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -1,5 +1,5 @@\n // compile-flags: -Ztrait-solver=next\n-// known-bug: unknown\n+// check-pass\n \n fn main() {\n     (0u8 + 0u8) as char;"}, {"sha": "6b09ccd52140def0329639a2f6ad5889d8193cbf", "filename": "tests/ui/typeck/lazy-norm/cast-checks-handling-projections.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6dfaa143662ddfd6ed2fecadef20eae0ec5d267d/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr?ref=6dfaa143662ddfd6ed2fecadef20eae0ec5d267d", "patch": "@@ -1,9 +0,0 @@\n-error[E0271]: type mismatch resolving `char == <u8 as Add>::Output`\n-  --> $DIR/cast-checks-handling-projections.rs:5:5\n-   |\n-LL |     (0u8 + 0u8) as char;\n-   |     ^^^^^^^^^^^ types differ\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "0388ce9fc98526080cd20844f538b76196a6710e", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19c53768af6e48514238e4224b5bf5ecd51bc7b1/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/19c53768af6e48514238e4224b5bf5ecd51bc7b1/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=19c53768af6e48514238e4224b5bf5ecd51bc7b1", "patch": "@@ -430,7 +430,7 @@ message = \"The Miri subtree was changed\"\n cc = [\"@rust-lang/miri\"]\n \n [mentions.\"src/tools/rust-analyzer\"]\n-cc = [\"@rust-lang/wg-rls-2\"]\n+cc = [\"@rust-lang/rust-analyzer\"]\n \n [mentions.\"src/tools/rustfmt\"]\n cc = [\"@rust-lang/rustfmt\"]"}]}