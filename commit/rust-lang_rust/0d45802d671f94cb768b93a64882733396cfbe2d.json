{"sha": "0d45802d671f94cb768b93a64882733396cfbe2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNDU4MDJkNjcxZjk0Y2I3NjhiOTNhNjQ4ODI3MzMzOTZjZmJlMmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-15T18:02:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-15T18:02:27Z"}, "message": "Merge #6220\n\n6220: implement binary operator overloading type inference r=flodiebold a=ruabmbua\n\nExtend type inference of *binary operator expression*, by adding support for operator overloads.\r\n\r\nBefore this merge request, the type inference of binary expressions could only resolve operations done on built-in primitive types. This merge requests adds a code path, which is executed in case the built-in inference could not get any results. It resolves the proper operator overload trait in *core::ops* via lang items, and then resolves the associated *Output* type.\r\n\r\n```rust\r\nstruct V2([f32; 2]);\r\n\r\n#[lang = \"add\"]\r\npub trait Add<Rhs = Self> {\r\n    /// The resulting type after applying the `+` operator.\r\n    type Output;\r\n\r\n    /// Performs the `+` operation.\r\n    #[must_use]\r\n    fn add(self, rhs: Rhs) -> Self::Output;\r\n}\r\n\r\nimpl Add<V2> for V2 {\r\n    type Output = V2;\r\n\r\n    fn add(self, rhs: V2) -> V2 {\r\n        let x = self.0[0] + rhs.0[0];\r\n        let y = self.0[1] + rhs.0[1];\r\n        V2([x, y])\r\n    }\r\n}\r\n\r\nfn test() {\r\n    let va = V2([0.0, 1.0]);\r\n    let vb = V2([0.0, 1.0]);\r\n\r\n    let r = va + vb; // This infers to V2 now\r\n}\r\n```\r\n\r\nThere is a problem with operator overloads, which do not explicitly set the *Rhs* type parameter in the respective impl block. \r\n\r\n**Example:**\r\n\r\n```rust\r\nimpl Add for V2 {\r\n    type Output = V2;\r\n\r\n    fn add(self, rhs: V2) -> V2 {\r\n        let x = self.0[0] + rhs.0[0];\r\n        let y = self.0[1] + rhs.0[1];\r\n        V2([x, y])\r\n    }\r\n}\r\n```\r\n\r\nIn this case, the trait solver does not realize, that the *Rhs* type parameter is actually self in the context of the impl block. This stops type inference in its tracks, and it can not resolve the associated *Output* type.\r\n\r\nI guess we can still merge this back, because it increases the amount of resolved types, and does not regress anything (in the tests).\r\n\r\nSomewhat blocked by https://github.com/rust-analyzer/rust-analyzer/issues/5685\r\nResolves  https://github.com/rust-analyzer/rust-analyzer/issues/5544\n\nCo-authored-by: Roland Ruckerbauer <roland.rucky@gmail.com>", "tree": {"sha": "abb91645ee84216304065bf42a959223d040814c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abb91645ee84216304065bf42a959223d040814c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d45802d671f94cb768b93a64882733396cfbe2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfiI6zCRBK7hj4Ov3rIwAAdHIIABHKUIW4ZT2Z3hO9h8+f1Vcs\ny77wZcZjgZj7MIc5x7TXW9jhGTN1jKufgT5z/qBjyvkYQsJRxsrssudokksF0G44\nZviV0NLdi88sNREw0gYXYDQqEveGL7g+Ka3++4jbjt8mNJxShFW4pK+CqcbE1L26\nhR1FPDfIzFmUcepP7hMgpzEcec4wxA1Xbbpv6LQmpASYEUYZ+Yox1O2OrAwV5aN4\niP3qrkPS2JpH6kNcqkGw8NyEGHBrChItqhiUccNVOBOo0XI0dZ/oj703onTUK9vD\nUZktJZ5yEo3639K31osSfJzb/VdGLTNb3O3zEKjvl/wB0PCwZG8ru+olB4XuF3A=\n=CnE7\n-----END PGP SIGNATURE-----\n", "payload": "tree abb91645ee84216304065bf42a959223d040814c\nparent 1de202010948c94658235f7cfe9b25dda0c7ddf3\nparent 0e9d1e17d6e45b44ec1a8f1430109cfc75e41241\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602784947 +0000\ncommitter GitHub <noreply@github.com> 1602784947 +0000\n\nMerge #6220\n\n6220: implement binary operator overloading type inference r=flodiebold a=ruabmbua\n\nExtend type inference of *binary operator expression*, by adding support for operator overloads.\r\n\r\nBefore this merge request, the type inference of binary expressions could only resolve operations done on built-in primitive types. This merge requests adds a code path, which is executed in case the built-in inference could not get any results. It resolves the proper operator overload trait in *core::ops* via lang items, and then resolves the associated *Output* type.\r\n\r\n```rust\r\nstruct V2([f32; 2]);\r\n\r\n#[lang = \"add\"]\r\npub trait Add<Rhs = Self> {\r\n    /// The resulting type after applying the `+` operator.\r\n    type Output;\r\n\r\n    /// Performs the `+` operation.\r\n    #[must_use]\r\n    fn add(self, rhs: Rhs) -> Self::Output;\r\n}\r\n\r\nimpl Add<V2> for V2 {\r\n    type Output = V2;\r\n\r\n    fn add(self, rhs: V2) -> V2 {\r\n        let x = self.0[0] + rhs.0[0];\r\n        let y = self.0[1] + rhs.0[1];\r\n        V2([x, y])\r\n    }\r\n}\r\n\r\nfn test() {\r\n    let va = V2([0.0, 1.0]);\r\n    let vb = V2([0.0, 1.0]);\r\n\r\n    let r = va + vb; // This infers to V2 now\r\n}\r\n```\r\n\r\nThere is a problem with operator overloads, which do not explicitly set the *Rhs* type parameter in the respective impl block. \r\n\r\n**Example:**\r\n\r\n```rust\r\nimpl Add for V2 {\r\n    type Output = V2;\r\n\r\n    fn add(self, rhs: V2) -> V2 {\r\n        let x = self.0[0] + rhs.0[0];\r\n        let y = self.0[1] + rhs.0[1];\r\n        V2([x, y])\r\n    }\r\n}\r\n```\r\n\r\nIn this case, the trait solver does not realize, that the *Rhs* type parameter is actually self in the context of the impl block. This stops type inference in its tracks, and it can not resolve the associated *Output* type.\r\n\r\nI guess we can still merge this back, because it increases the amount of resolved types, and does not regress anything (in the tests).\r\n\r\nSomewhat blocked by https://github.com/rust-analyzer/rust-analyzer/issues/5685\r\nResolves  https://github.com/rust-analyzer/rust-analyzer/issues/5544\n\nCo-authored-by: Roland Ruckerbauer <roland.rucky@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d45802d671f94cb768b93a64882733396cfbe2d", "html_url": "https://github.com/rust-lang/rust/commit/0d45802d671f94cb768b93a64882733396cfbe2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d45802d671f94cb768b93a64882733396cfbe2d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1de202010948c94658235f7cfe9b25dda0c7ddf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de202010948c94658235f7cfe9b25dda0c7ddf3", "html_url": "https://github.com/rust-lang/rust/commit/1de202010948c94658235f7cfe9b25dda0c7ddf3"}, {"sha": "0e9d1e17d6e45b44ec1a8f1430109cfc75e41241", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9d1e17d6e45b44ec1a8f1430109cfc75e41241", "html_url": "https://github.com/rust-lang/rust/commit/0e9d1e17d6e45b44ec1a8f1430109cfc75e41241"}], "stats": {"total": 131, "additions": 126, "deletions": 5}, "files": [{"sha": "644ebd42d367ca2da82e40f05004ed17e19cb2b4", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=0d45802d671f94cb768b93a64882733396cfbe2d", "patch": "@@ -22,7 +22,7 @@ use arena::map::ArenaMap;\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n-    expr::{BindingAnnotation, ExprId, PatId},\n+    expr::{ArithOp, BinaryOp, BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n@@ -586,6 +586,28 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n+    fn resolve_binary_op_output(&self, bop: &BinaryOp) -> Option<TypeAliasId> {\n+        let lang_item = match bop {\n+            BinaryOp::ArithOp(aop) => match aop {\n+                ArithOp::Add => \"add\",\n+                ArithOp::Sub => \"sub\",\n+                ArithOp::Mul => \"mul\",\n+                ArithOp::Div => \"div\",\n+                ArithOp::Shl => \"shl\",\n+                ArithOp::Shr => \"shr\",\n+                ArithOp::Rem => \"rem\",\n+                ArithOp::BitXor => \"bitxor\",\n+                ArithOp::BitOr => \"bitor\",\n+                ArithOp::BitAnd => \"bitand\",\n+            },\n+            _ => return None,\n+        };\n+\n+        let trait_ = self.resolve_lang_item(lang_item)?.as_trait();\n+\n+        self.db.trait_data(trait_?).associated_type_by_name(&name![Output])\n+    }\n+\n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n         let struct_ = self.resolve_lang_item(\"owned_box\")?.as_struct()?;\n         Some(struct_.into())"}, {"sha": "8ac4cf89a0c3a17aaea93b0ba4afd212651f6f15", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0d45802d671f94cb768b93a64882733396cfbe2d", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n use syntax::ast::RangeOp;\n+use test_utils::mark;\n \n use crate::{\n     autoderef, method_resolution, op,\n@@ -531,13 +532,22 @@ impl<'a> InferenceContext<'a> {\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    // FIXME: find implementation of trait corresponding to operation\n-                    // symbol and resolve associated `Output` type\n                     let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty.clone());\n                     let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n \n-                    // FIXME: similar as above, return ty is often associated trait type\n-                    op::binary_op_return_ty(*op, lhs_ty, rhs_ty)\n+                    let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n+\n+                    if ret == Ty::Unknown {\n+                        mark::hit!(infer_expr_inner_binary_operator_overload);\n+\n+                        self.resolve_associated_type_with_params(\n+                            lhs_ty,\n+                            self.resolve_binary_op_output(op),\n+                            &[rhs_ty],\n+                        )\n+                    } else {\n+                        ret\n+                    }\n                 }\n                 _ => Ty::Unknown,\n             },"}, {"sha": "4f72582b6bdd8b55b55eb9f5f80132ead72d7434", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d45802d671f94cb768b93a64882733396cfbe2d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=0d45802d671f94cb768b93a64882733396cfbe2d", "patch": "@@ -1,4 +1,5 @@\n use expect_test::expect;\n+use test_utils::mark;\n \n use super::{check_infer, check_types};\n \n@@ -2225,3 +2226,91 @@ fn generic_default_depending_on_other_type_arg_forward() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn infer_operator_overload() {\n+    mark::check!(infer_expr_inner_binary_operator_overload);\n+\n+    check_infer(\n+        r#\"\n+        struct V2([f32; 2]);\n+\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            /// The resulting type after applying the `+` operator.\n+            type Output;\n+\n+            /// Performs the `+` operation.\n+            #[must_use]\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+\n+        impl Add<V2> for V2 {\n+            type Output = V2;\n+\n+            fn add(self, rhs: V2) -> V2 {\n+                let x = self.0[0] + rhs.0[0];\n+                let y = self.0[1] + rhs.0[1];\n+                V2([x, y])\n+            }\n+        }\n+\n+        fn test() {\n+            let va = V2([0.0, 1.0]);\n+            let vb = V2([0.0, 1.0]);\n+\n+            let r = va + vb;\n+        }\n+\n+        \"#,\n+        expect![[r#\"\n+            207..211 'self': Self\n+            213..216 'rhs': Rhs\n+            299..303 'self': V2\n+            305..308 'rhs': V2\n+            320..422 '{     ...     }': V2\n+            334..335 'x': f32\n+            338..342 'self': V2\n+            338..344 'self.0': [f32; _]\n+            338..347 'self.0[0]': {unknown}\n+            338..358 'self.0...s.0[0]': f32\n+            345..346 '0': i32\n+            350..353 'rhs': V2\n+            350..355 'rhs.0': [f32; _]\n+            350..358 'rhs.0[0]': {unknown}\n+            356..357 '0': i32\n+            372..373 'y': f32\n+            376..380 'self': V2\n+            376..382 'self.0': [f32; _]\n+            376..385 'self.0[1]': {unknown}\n+            376..396 'self.0...s.0[1]': f32\n+            383..384 '1': i32\n+            388..391 'rhs': V2\n+            388..393 'rhs.0': [f32; _]\n+            388..396 'rhs.0[1]': {unknown}\n+            394..395 '1': i32\n+            406..408 'V2': V2([f32; _]) -> V2\n+            406..416 'V2([x, y])': V2\n+            409..415 '[x, y]': [f32; _]\n+            410..411 'x': f32\n+            413..414 'y': f32\n+            436..519 '{     ... vb; }': ()\n+            446..448 'va': V2\n+            451..453 'V2': V2([f32; _]) -> V2\n+            451..465 'V2([0.0, 1.0])': V2\n+            454..464 '[0.0, 1.0]': [f32; _]\n+            455..458 '0.0': f32\n+            460..463 '1.0': f32\n+            475..477 'vb': V2\n+            480..482 'V2': V2([f32; _]) -> V2\n+            480..494 'V2([0.0, 1.0])': V2\n+            483..493 '[0.0, 1.0]': [f32; _]\n+            484..487 '0.0': f32\n+            489..492 '1.0': f32\n+            505..506 'r': V2\n+            509..511 'va': V2\n+            509..516 'va + vb': V2\n+            514..516 'vb': V2\n+        \"#]],\n+    );\n+}"}]}