{"sha": "335a2554f94946a483c409199bb69fb5862b6f94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNWEyNTU0Zjk0OTQ2YTQ4M2M0MDkxOTliYjY5ZmI1ODYyYjZmOTQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-15T02:02:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-15T02:02:46Z"}, "message": "Rollup merge of #78963 - richkadel:llvm-coverage-counters-2.0.4, r=tmandry\n\nAdded some unit tests as requested\n\nAs discussed in PR #78267, for example:\n\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515404722\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515405958\n\nr? ```````@tmandry```````\nFYI: ```````@wesleywiser```````\n\nThis is pretty much self contained, but depending on feedback and timing, I may have a chance to add a few more unit tests requested against `counters.rs`. I'm looking at those now.", "tree": {"sha": "faf7dd79c2fefdf52bbda6dab474c3633321de5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faf7dd79c2fefdf52bbda6dab474c3633321de5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/335a2554f94946a483c409199bb69fb5862b6f94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfsIxGCRBK7hj4Ov3rIwAAdHIIAGq46UStVFVD4GHWXtwQco4f\nnh2NwIEO61MSwXQOr9GlhJinpeaAvup8RGWmKXjcIkDIfm8U1vH3H1sEUxkkcdtO\nH7L6z0182T79xyI50GaElEIMYdWLs2xw1arbeuhqK7PpDmoMUwMX9KWbCtn3q6JS\n+Lrkpq0PzfOkdvcWAdDvNyVK7PzuO6D8hiBb/GoSUZB4/YY2bRHdgxDJfYd+hPoA\nIppqveiY/e5e6dg1dYvyv/NfLRdPFDMnpfOyPZ/7dNzBBBvIVgK6tDZ7aYGB+m9X\niD4ZyqDJWfw4lAf4/Wir1bRQFaI+P+BnTIwzbcD/BV6bpZlXYUru5Ne1wWPnItw=\n=lBCP\n-----END PGP SIGNATURE-----\n", "payload": "tree faf7dd79c2fefdf52bbda6dab474c3633321de5e\nparent 50603891dc473462ed78984db5f65994f12d5cdc\nparent b4b0ef3e4b6ebf1571b2c38b952c940c8b94e91e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605405766 +0100\ncommitter GitHub <noreply@github.com> 1605405766 +0100\n\nRollup merge of #78963 - richkadel:llvm-coverage-counters-2.0.4, r=tmandry\n\nAdded some unit tests as requested\n\nAs discussed in PR #78267, for example:\n\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515404722\n* https://github.com/rust-lang/rust/pull/78267#discussion_r515405958\n\nr? ```````@tmandry```````\nFYI: ```````@wesleywiser```````\n\nThis is pretty much self contained, but depending on feedback and timing, I may have a chance to add a few more unit tests requested against `counters.rs`. I'm looking at those now.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/335a2554f94946a483c409199bb69fb5862b6f94", "html_url": "https://github.com/rust-lang/rust/commit/335a2554f94946a483c409199bb69fb5862b6f94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/335a2554f94946a483c409199bb69fb5862b6f94/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50603891dc473462ed78984db5f65994f12d5cdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/50603891dc473462ed78984db5f65994f12d5cdc", "html_url": "https://github.com/rust-lang/rust/commit/50603891dc473462ed78984db5f65994f12d5cdc"}, {"sha": "b4b0ef3e4b6ebf1571b2c38b952c940c8b94e91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b0ef3e4b6ebf1571b2c38b952c940c8b94e91e", "html_url": "https://github.com/rust-lang/rust/commit/b4b0ef3e4b6ebf1571b2c38b952c940c8b94e91e"}], "stats": {"total": 813, "additions": 788, "deletions": 25}, "files": [{"sha": "f02ae7ef6cfa3ace4295d90979aa6e99b9c28dc8", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -721,6 +721,13 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n \n+[[package]]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n [[package]]\n name = \"cpuid-bool\"\n version = \"0.1.2\"\n@@ -3922,6 +3929,7 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"coverage_test_macros\",\n  \"either\",\n  \"itertools 0.9.0\",\n  \"polonius-engine\","}, {"sha": "db11746971d18b2ce79a1e09b43ab0b82242a8e8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -611,6 +611,18 @@ pub struct TyS<'tcx> {\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n+impl<'tcx> TyS<'tcx> {\n+    /// A constructor used only for internal testing.\n+    #[allow(rustc::usage_of_ty_tykind)]\n+    pub fn make_for_test(\n+        kind: TyKind<'tcx>,\n+        flags: TypeFlags,\n+        outer_exclusive_binder: ty::DebruijnIndex,\n+    ) -> TyS<'tcx> {\n+        TyS { kind, flags, outer_exclusive_binder }\n+    }\n+}\n+\n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(TyS<'_>, 32);"}, {"sha": "9bfd1da0391203c9b5461dcbf83690c3df4fefe3", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -31,3 +31,6 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+\n+[dev-dependencies]\n+coverage_test_macros = { path = \"src/transform/coverage/test_macros\" }"}, {"sha": "20f6a16e0f75712190548ed9aa573a4310f4f673", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::coverage::*;\n \n /// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n /// `Coverage` statements.\n-pub(crate) struct CoverageCounters {\n+pub(super) struct CoverageCounters {\n     function_source_hash: u64,\n     next_counter_id: u32,\n     num_expressions: u32,\n@@ -37,7 +37,7 @@ impl CoverageCounters {\n         self.debug_counters.enable();\n     }\n \n-    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlocks` directly or\n+    /// Makes `CoverageKind` `Counter`s and `Expressions` for the `BasicCoverageBlock`s directly or\n     /// indirectly associated with `CoverageSpans`, and returns additional `Expression`s\n     /// representing intermediate values.\n     pub fn make_bcb_counters(\n@@ -120,7 +120,6 @@ struct BcbCounters<'a> {\n     basic_coverage_blocks: &'a mut CoverageGraph,\n }\n \n-// FIXME(richkadel): Add unit tests for `BcbCounters` functions/algorithms.\n impl<'a> BcbCounters<'a> {\n     fn new(\n         coverage_counters: &'a mut CoverageCounters,"}, {"sha": "7f1dc3844b21dc2cc1481ba310a03a6f1e4e802c", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -127,7 +127,7 @@ pub const NESTED_INDENT: &str = \"    \";\n \n const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n \n-pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n+pub(super) fn debug_options<'a>() -> &'a DebugOptions {\n     static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n \n     &DEBUG_OPTIONS.get_or_init(|| DebugOptions::from_env())\n@@ -136,7 +136,7 @@ pub(crate) fn debug_options<'a>() -> &'a DebugOptions {\n /// Parses and maintains coverage-specific debug options captured from the environment variable\n /// \"RUSTC_COVERAGE_DEBUG_OPTIONS\", if set.\n #[derive(Debug, Clone)]\n-pub(crate) struct DebugOptions {\n+pub(super) struct DebugOptions {\n     pub allow_unused_expressions: bool,\n     counter_format: ExpressionFormat,\n }\n@@ -250,7 +250,7 @@ impl Default for ExpressionFormat {\n ///\n /// `DebugCounters` supports a recursive rendering of `Expression` counters, so they can be\n /// presented as nested expressions such as `(bcb3 - (bcb0 + bcb1))`.\n-pub(crate) struct DebugCounters {\n+pub(super) struct DebugCounters {\n     some_counters: Option<FxHashMap<ExpressionOperandId, DebugCounter>>,\n }\n \n@@ -386,7 +386,7 @@ impl DebugCounter {\n \n /// If enabled, this data structure captures additional debugging information used when generating\n /// a Graphviz (.dot file) representation of the `CoverageGraph`, for debugging purposes.\n-pub(crate) struct GraphvizData {\n+pub(super) struct GraphvizData {\n     some_bcb_to_coverage_spans_with_counters:\n         Option<FxHashMap<BasicCoverageBlock, Vec<(CoverageSpan, CoverageKind)>>>,\n     some_bcb_to_dependency_counters: Option<FxHashMap<BasicCoverageBlock, Vec<CoverageKind>>>,\n@@ -496,7 +496,7 @@ impl GraphvizData {\n /// directly or indirectly, to compute the coverage counts for all `CoverageSpan`s, and any that are\n /// _not_ used are retained in the `unused_expressions` Vec, to be included in debug output (logs\n /// and/or a `CoverageGraph` graphviz output).\n-pub(crate) struct UsedExpressions {\n+pub(super) struct UsedExpressions {\n     some_used_expression_operands:\n         Option<FxHashMap<ExpressionOperandId, Vec<InjectedExpressionId>>>,\n     some_unused_expressions:\n@@ -626,7 +626,7 @@ impl UsedExpressions {\n }\n \n /// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n-pub(crate) fn dump_coverage_spanview(\n+pub(super) fn dump_coverage_spanview(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     basic_coverage_blocks: &CoverageGraph,\n@@ -666,7 +666,7 @@ fn span_viewables(\n }\n \n /// Generates the MIR pass coverage-specific graphviz dump file.\n-pub(crate) fn dump_coverage_graphviz(\n+pub(super) fn dump_coverage_graphviz(\n     tcx: TyCtxt<'tcx>,\n     mir_body: &mir::Body<'tcx>,\n     pass_name: &str,\n@@ -815,7 +815,7 @@ fn bcb_to_string_sections(\n \n /// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n /// values it might hold.\n-pub(crate) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n+pub(super) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n     match kind {\n         TerminatorKind::Goto { .. } => \"Goto\",\n         TerminatorKind::SwitchInt { .. } => \"SwitchInt\","}, {"sha": "9d375633dcf5108ce083c10abeb5996efe3c5e17", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -17,7 +17,8 @@ const ID_SEPARATOR: &str = \",\";\n /// `CoverageKind` counter (to be added by `CoverageCounters::make_bcb_counters`), and an optional\n /// set of additional counters--if needed--to count incoming edges, if there are more than one.\n /// (These \"edge counters\" are eventually converted into new MIR `BasicBlock`s.)\n-pub(crate) struct CoverageGraph {\n+#[derive(Debug)]\n+pub(super) struct CoverageGraph {\n     bcbs: IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n     bb_to_bcb: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     pub successors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n@@ -275,7 +276,7 @@ impl graph::WithPredecessors for CoverageGraph {\n \n rustc_index::newtype_index! {\n     /// A node in the [control-flow graph][CFG] of CoverageGraph.\n-    pub(crate) struct BasicCoverageBlock {\n+    pub(super) struct BasicCoverageBlock {\n         DEBUG_FORMAT = \"bcb{}\",\n     }\n }\n@@ -305,7 +306,7 @@ rustc_index::newtype_index! {\n /// queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch (control flow)\n /// significance.\n #[derive(Debug, Clone)]\n-pub(crate) struct BasicCoverageBlockData {\n+pub(super) struct BasicCoverageBlockData {\n     pub basic_blocks: Vec<BasicBlock>,\n     pub counter_kind: Option<CoverageKind>,\n     edge_from_bcbs: Option<FxHashMap<BasicCoverageBlock, CoverageKind>>,\n@@ -431,7 +432,7 @@ impl BasicCoverageBlockData {\n /// the specific branching BCB, representing the edge between the two. The latter case\n /// distinguishes this incoming edge from other incoming edges to the same `target_bcb`.\n #[derive(Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct BcbBranch {\n+pub(super) struct BcbBranch {\n     pub edge_from_bcb: Option<BasicCoverageBlock>,\n     pub target_bcb: BasicCoverageBlock,\n }\n@@ -498,9 +499,8 @@ fn bcb_filtered_successors<'a, 'tcx>(\n /// Maintains separate worklists for each loop in the BasicCoverageBlock CFG, plus one for the\n /// CoverageGraph outside all loops. This supports traversing the BCB CFG in a way that\n /// ensures a loop is completely traversed before processing Blocks after the end of the loop.\n-// FIXME(richkadel): Add unit tests for TraversalContext.\n #[derive(Debug)]\n-pub(crate) struct TraversalContext {\n+pub(super) struct TraversalContext {\n     /// From one or more backedges returning to a loop header.\n     pub loop_backedges: Option<(Vec<BasicCoverageBlock>, BasicCoverageBlock)>,\n \n@@ -510,7 +510,7 @@ pub(crate) struct TraversalContext {\n     pub worklist: Vec<BasicCoverageBlock>,\n }\n \n-pub(crate) struct TraverseCoverageGraphWithLoops {\n+pub(super) struct TraverseCoverageGraphWithLoops {\n     pub backedges: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n     pub context_stack: Vec<TraversalContext>,\n     visited: BitSet<BasicCoverageBlock>,\n@@ -642,7 +642,7 @@ impl TraverseCoverageGraphWithLoops {\n     }\n }\n \n-fn find_loop_backedges(\n+pub(super) fn find_loop_backedges(\n     basic_coverage_blocks: &CoverageGraph,\n ) -> IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>> {\n     let num_bcbs = basic_coverage_blocks.num_nodes();"}, {"sha": "192bb6680e42014b643248944c8d79903639288a", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -5,6 +5,9 @@ mod debug;\n mod graph;\n mod spans;\n \n+#[cfg(test)]\n+mod tests;\n+\n use counters::CoverageCounters;\n use graph::{BasicCoverageBlock, BasicCoverageBlockData, CoverageGraph};\n use spans::{CoverageSpan, CoverageSpans};\n@@ -31,7 +34,7 @@ use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n \n /// A simple error message wrapper for `coverage::Error`s.\n #[derive(Debug)]\n-pub(crate) struct Error {\n+struct Error {\n     message: String,\n }\n "}, {"sha": "95c49922262f628fb82f726cac1b4cf0b8b58201", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -17,7 +17,7 @@ use rustc_span::{BytePos, Span, SyntaxContext};\n use std::cmp::Ordering;\n \n #[derive(Debug, Copy, Clone)]\n-pub(crate) enum CoverageStatement {\n+pub(super) enum CoverageStatement {\n     Statement(BasicBlock, Span, usize),\n     Terminator(BasicBlock, Span),\n }\n@@ -66,7 +66,7 @@ impl CoverageStatement {\n /// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n /// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n #[derive(Debug, Clone)]\n-pub(crate) struct CoverageSpan {\n+pub(super) struct CoverageSpan {\n     pub span: Span,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n@@ -214,7 +214,7 @@ pub struct CoverageSpans<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n-    pub(crate) fn generate_coverage_spans(\n+    pub(super) fn generate_coverage_spans(\n         mir_body: &'a mir::Body<'tcx>,\n         body_span: Span,\n         basic_coverage_blocks: &'a CoverageGraph,\n@@ -645,7 +645,10 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_statement_span(\n+    statement: &'a Statement<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -686,7 +689,10 @@ fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> O\n     }\n }\n \n-fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -> Option<Span> {\n+pub(super) fn filtered_terminator_span(\n+    terminator: &'a Terminator<'tcx>,\n+    body_span: Span,\n+) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from"}, {"sha": "a9d6f0c803d2e2de2ff3c822663dccbcd2416b55", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2FCargo.toml?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"coverage_test_macros\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+doctest = false\n+\n+[dependencies]\n+proc-macro2 = \"1\""}, {"sha": "3d6095d2738cb562deecb28361595667663d888b", "filename": "compiler/rustc_mir/src/transform/coverage/test_macros/src/lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftest_macros%2Fsrc%2Flib.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -0,0 +1,6 @@\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn let_bcb(item: TokenStream) -> TokenStream {\n+    format!(\"let bcb{} = graph::BasicCoverageBlock::from_usize({});\", item, item).parse().unwrap()\n+}"}, {"sha": "d36f1b8e5f6705e92e5c472c3fe1e6cc5bf82ba1", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/335a2554f94946a483c409199bb69fb5862b6f94/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=335a2554f94946a483c409199bb69fb5862b6f94", "patch": "@@ -0,0 +1,714 @@\n+//! This crate hosts a selection of \"unit tests\" for components of the `InstrumentCoverage` MIR\n+//! pass.\n+//!\n+//! The tests construct a few \"mock\" objects, as needed, to support the `InstrumentCoverage`\n+//! functions and algorithms. Mocked objects include instances of `mir::Body`; including\n+//! `Terminator`s of various `kind`s, and `Span` objects. Some functions used by or used on\n+//! real, runtime versions of these mocked-up objects have constraints (such as cross-thread\n+//! limitations) and deep dependencies on other elements of the full Rust compiler (which is\n+//! *not* constructed or mocked for these tests).\n+//!\n+//! Of particular note, attempting to simply print elements of the `mir::Body` with default\n+//! `Debug` formatting can fail because some `Debug` format implementations require the\n+//! `TyCtxt`, obtained via a static global variable that is *not* set for these tests.\n+//! Initializing the global type context is prohibitively complex for the scope and scale of these\n+//! tests (essentially requiring initializing the entire compiler).\n+//!\n+//! Also note, some basic features of `Span` also rely on the `Span`s own \"session globals\", which\n+//! are unrelated to the `TyCtxt` global. Without initializing the `Span` session globals, some\n+//! basic, coverage-specific features would be impossible to test, but thankfully initializing these\n+//! globals is comparitively simpler. The easiest way is to wrap the test in a closure argument\n+//! to: `rustc_span::with_default_session_globals(|| { test_here(); })`.\n+\n+use super::counters;\n+use super::debug;\n+use super::graph;\n+use super::spans;\n+\n+use coverage_test_macros::let_bcb;\n+\n+use rustc_data_structures::graph::WithNumNodes;\n+use rustc_data_structures::graph::WithSuccessors;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::mir::coverage::CoverageKind;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{self, DebruijnIndex, TyS, TypeFlags};\n+use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n+\n+// All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n+const TEMP_BLOCK: BasicBlock = BasicBlock::MAX;\n+\n+fn dummy_ty() -> &'static TyS<'static> {\n+    thread_local! {\n+        static DUMMY_TYS: &'static TyS<'static> = Box::leak(box TyS::make_for_test(\n+            ty::Bool,\n+            TypeFlags::empty(),\n+            DebruijnIndex::from_usize(0),\n+        ));\n+    }\n+\n+    &DUMMY_TYS.with(|tys| *tys)\n+}\n+\n+struct MockBlocks<'tcx> {\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    dummy_place: Place<'tcx>,\n+    next_local: usize,\n+}\n+\n+impl<'tcx> MockBlocks<'tcx> {\n+    fn new() -> Self {\n+        Self {\n+            blocks: IndexVec::new(),\n+            dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n+            next_local: 0,\n+        }\n+    }\n+\n+    fn new_temp(&mut self) -> Local {\n+        let index = self.next_local;\n+        self.next_local += 1;\n+        Local::new(index)\n+    }\n+\n+    fn push(&mut self, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+        let next_lo = if let Some(last) = self.blocks.last() {\n+            self.blocks[last].terminator().source_info.span.hi()\n+        } else {\n+            BytePos(1)\n+        };\n+        let next_hi = next_lo + BytePos(1);\n+        self.blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                source_info: SourceInfo::outermost(Span::with_root_ctxt(next_lo, next_hi)),\n+                kind,\n+            }),\n+            is_cleanup: false,\n+        })\n+    }\n+\n+    fn link(&mut self, from_block: BasicBlock, to_block: BasicBlock) {\n+        match self.blocks[from_block].terminator_mut().kind {\n+            TerminatorKind::Assert { ref mut target, .. }\n+            | TerminatorKind::Call { destination: Some((_, ref mut target)), .. }\n+            | TerminatorKind::Drop { ref mut target, .. }\n+            | TerminatorKind::DropAndReplace { ref mut target, .. }\n+            | TerminatorKind::FalseEdge { real_target: ref mut target, .. }\n+            | TerminatorKind::FalseUnwind { real_target: ref mut target, .. }\n+            | TerminatorKind::Goto { ref mut target }\n+            | TerminatorKind::InlineAsm { destination: Some(ref mut target), .. }\n+            | TerminatorKind::Yield { resume: ref mut target, .. } => *target = to_block,\n+            ref invalid => bug!(\"Invalid from_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn add_block_from(\n+        &mut self,\n+        some_from_block: Option<BasicBlock>,\n+        to_kind: TerminatorKind<'tcx>,\n+    ) -> BasicBlock {\n+        let new_block = self.push(to_kind);\n+        if let Some(from_block) = some_from_block {\n+            self.link(from_block, new_block);\n+        }\n+        new_block\n+    }\n+\n+    fn set_branch(&mut self, switchint: BasicBlock, branch_index: usize, to_block: BasicBlock) {\n+        match self.blocks[switchint].terminator_mut().kind {\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                let mut branches = targets.iter().collect::<Vec<_>>();\n+                let otherwise = if branch_index == branches.len() {\n+                    to_block\n+                } else {\n+                    let old_otherwise = targets.otherwise();\n+                    if branch_index > branches.len() {\n+                        branches.push((branches.len() as u128, old_otherwise));\n+                        while branches.len() < branch_index {\n+                            branches.push((branches.len() as u128, TEMP_BLOCK));\n+                        }\n+                        to_block\n+                    } else {\n+                        branches[branch_index] = (branch_index as u128, to_block);\n+                        old_otherwise\n+                    }\n+                };\n+                *targets = SwitchTargets::new(branches.into_iter(), otherwise);\n+            }\n+            ref invalid => bug!(\"Invalid BasicBlock kind or no to_block: {:?}\", invalid),\n+        }\n+    }\n+\n+    fn call(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(\n+            some_from_block,\n+            TerminatorKind::Call {\n+                func: Operand::Copy(self.dummy_place.clone()),\n+                args: vec![],\n+                destination: Some((self.dummy_place.clone(), TEMP_BLOCK)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: DUMMY_SP,\n+            },\n+        )\n+    }\n+\n+    fn goto(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Goto { target: TEMP_BLOCK })\n+    }\n+\n+    fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        let switchint_kind = TerminatorKind::SwitchInt {\n+            discr: Operand::Move(Place::from(self.new_temp())),\n+            switch_ty: dummy_ty(),\n+            targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n+        };\n+        self.add_block_from(some_from_block, switchint_kind)\n+    }\n+\n+    fn return_(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n+        self.add_block_from(some_from_block, TerminatorKind::Return)\n+    }\n+\n+    fn to_body(self) -> Body<'tcx> {\n+        Body::new_cfg_only(self.blocks)\n+    }\n+}\n+\n+fn debug_basic_blocks(mir_body: &Body<'tcx>) -> String {\n+    format!(\n+        \"{:?}\",\n+        mir_body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .map(|(bb, data)| {\n+                let term = &data.terminator();\n+                let kind = &term.kind;\n+                let span = term.source_info.span;\n+                let sp = format!(\"(span:{},{})\", span.lo().to_u32(), span.hi().to_u32());\n+                match kind {\n+                    TerminatorKind::Assert { target, .. }\n+                    | TerminatorKind::Call { destination: Some((_, target)), .. }\n+                    | TerminatorKind::Drop { target, .. }\n+                    | TerminatorKind::DropAndReplace { target, .. }\n+                    | TerminatorKind::FalseEdge { real_target: target, .. }\n+                    | TerminatorKind::FalseUnwind { real_target: target, .. }\n+                    | TerminatorKind::Goto { target }\n+                    | TerminatorKind::InlineAsm { destination: Some(target), .. }\n+                    | TerminatorKind::Yield { resume: target, .. } => {\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), target)\n+                    }\n+                    TerminatorKind::SwitchInt { targets, .. } => {\n+                        format!(\"{}{:?}:{} -> {:?}\", sp, bb, debug::term_type(kind), targets)\n+                    }\n+                    _ => format!(\"{}{:?}:{}\", sp, bb, debug::term_type(kind)),\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+    )\n+}\n+\n+static PRINT_GRAPHS: bool = false;\n+\n+fn print_mir_graphviz(name: &str, mir_body: &Body<'_>) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            mir_body\n+                .basic_blocks()\n+                .iter_enumerated()\n+                .map(|(bb, data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bb,\n+                        bb,\n+                        debug::term_type(&data.terminator().kind),\n+                        mir_body\n+                            .successors(bb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+fn print_coverage_graphviz(\n+    name: &str,\n+    mir_body: &Body<'_>,\n+    basic_coverage_blocks: &graph::CoverageGraph,\n+) {\n+    if PRINT_GRAPHS {\n+        println!(\n+            \"digraph {} {{\\n{}\\n}}\",\n+            name,\n+            basic_coverage_blocks\n+                .iter_enumerated()\n+                .map(|(bcb, bcb_data)| {\n+                    format!(\n+                        \"    {:?} [label=\\\"{:?}: {}\\\"];\\n{}\",\n+                        bcb,\n+                        bcb,\n+                        debug::term_type(&bcb_data.terminator(mir_body).kind),\n+                        basic_coverage_blocks\n+                            .successors(bcb)\n+                            .map(|successor| { format!(\"    {:?} -> {:?};\", bcb, successor) })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\")\n+                    )\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+        );\n+    }\n+}\n+\n+/// Create a mock `Body` with a simple flow.\n+fn goto_switchint() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let goto = blocks.goto(Some(start));\n+    let switchint = blocks.switchint(Some(goto));\n+    let then_call = blocks.call(None);\n+    let else_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    blocks.set_branch(switchint, 1, else_call);\n+    blocks.return_(Some(then_call));\n+    blocks.return_(Some(else_call));\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_goto_switchint\", &mir_body);\n+    /* Graphviz character plots created using: `graph-easy --as=boxart`:\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb1: Goto    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502  bb4: Call  \u2502 \u25c0\u2500\u2500 \u2502 bb2: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      \u2502                   \u2502\n+      \u2502                   \u2502\n+      \u25bc                   \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb6: Return \u2502     \u2502   bb3: Call    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502  bb5: Return   \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+macro_rules! assert_successors {\n+    ($basic_coverage_blocks:ident, $i:ident, [$($successor:ident),*]) => {\n+        let mut successors = $basic_coverage_blocks.successors[$i].clone();\n+        successors.sort_unstable();\n+        assert_eq!(successors, vec![$($successor),*]);\n+    }\n+}\n+\n+#[test]\n+fn test_covgraph_goto_switchint() {\n+    let mir_body = goto_switchint();\n+    if false {\n+        println!(\"basic_blocks = {}\", debug_basic_blocks(&mir_body));\n+    }\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\"covgraph_goto_switchint \", &mir_body, &basic_coverage_blocks);\n+    /*\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb0: SwitchInt \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502  bcb1: Return   \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        3,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1, bcb2]);\n+    assert_successors!(basic_coverage_blocks, bcb1, []);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+}\n+\n+/// Create a mock `Body` with a loop.\n+fn switchint_then_loop_else_return() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let backedge_goto = blocks.goto(Some(then_call));\n+    blocks.link(backedge_goto, switchint);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_then_loop_else_return\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb4: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb2: Call    \u2502  \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                          \u2502                 \u2502\n+                          \u2502                 \u2502\n+                          \u25bc                 \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                        \u2502   bb3: Goto    \u2502 \u2500\u2518\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_then_loop_else_return() {\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_then_loop_else_return\",\n+        &mir_body,\n+        &basic_coverage_blocks,\n+    );\n+    /*\n+                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                       \u2502   bcb0: Call    \u2502\n+                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                         \u2502\n+                         \u2502\n+                         \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb3: Goto \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u2502                  \u2502\n+      \u2502                  \u25bc                  \u2502\n+      \u2502                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+      \u2502                \u2502  bcb2: Return   \u2502  \u2502\n+      \u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+      \u2502                                     \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        4,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb1]);\n+}\n+\n+/// Create a mock `Body` with nested loops.\n+fn switchint_loop_then_inner_loop_else_break() -> Body<'a> {\n+    let mut blocks = MockBlocks::new();\n+    let start = blocks.call(None);\n+    let switchint = blocks.switchint(Some(start));\n+    let then_call = blocks.call(None);\n+    blocks.set_branch(switchint, 0, then_call);\n+    let else_return = blocks.return_(None);\n+    blocks.set_branch(switchint, 1, else_return);\n+\n+    let inner_start = blocks.call(Some(then_call));\n+    let inner_switchint = blocks.switchint(Some(inner_start));\n+    let inner_then_call = blocks.call(None);\n+    blocks.set_branch(inner_switchint, 0, inner_then_call);\n+    let inner_backedge_goto = blocks.goto(Some(inner_then_call));\n+    blocks.link(inner_backedge_goto, inner_switchint);\n+    let inner_else_break_goto = blocks.goto(None);\n+    blocks.set_branch(inner_switchint, 1, inner_else_break_goto);\n+\n+    let backedge_goto = blocks.goto(Some(inner_else_break_goto));\n+    blocks.link(backedge_goto, switchint);\n+\n+    let mir_body = blocks.to_body();\n+    print_mir_graphviz(\"mir_switchint_loop_then_inner_loop_else_break\", &mir_body);\n+    /*\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                        \u2502   bb0: Call    \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                          \u2502\n+                          \u2502\n+                          \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bb3: Return \u2502 \u25c0\u2500\u2500 \u2502 bb1: SwitchInt \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb2: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+                        \u2502   bb4: Call    \u2502       \u2502\n+                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                          \u2502                      \u2502\n+                          \u2502                      \u2502\n+                          \u25bc                      \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n+    \u2502  bb8: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bb5: SwitchInt \u2502 \u25c0\u2510    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u2502                   \u2502                 \u2502    \u2502\n+      \u25bc                   \u25bc                 \u2502    \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+    \u2502  bb9: Goto  \u2502 \u2500\u2510  \u2502   bb6: Call    \u2502  \u2502    \u2502\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u2502                 \u2502    \u2502\n+                     \u2502    \u25bc                 \u2502    \u2502\n+                     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+                     \u2502  \u2502   bb7: Goto    \u2502 \u2500\u2518    \u2502\n+                     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+                     \u2502                           \u2502\n+                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    mir_body\n+}\n+\n+#[test]\n+fn test_covgraph_switchint_loop_then_inner_loop_else_break() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    print_coverage_graphviz(\n+        \"covgraph_switchint_loop_then_inner_loop_else_break\",\n+        &mir_body,\n+        &basic_coverage_blocks,\n+    );\n+    /*\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+                         \u2502   bcb0: Call    \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                           \u2502\n+                           \u2502\n+                           \u25bc\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+    \u2502 bcb2: Return \u2502 \u25c0\u2500\u2500 \u2502 bcb1: SwitchInt \u2502 \u25c0\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+                         \u2502   bcb3: Call    \u2502  \u2502\n+                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n+                           \u2502                  \u2502\n+                           \u2502                  \u2502\n+                           \u25bc                  \u2502\n+    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n+    \u2502  bcb6: Goto  \u2502 \u25c0\u2500\u2500 \u2502 bcb4: SwitchInt \u2502 \u25c0\u253c\u2500\u2500\u2500\u2500\u2510\n+    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u2502                  \u2502    \u2502\n+      \u2502                    \u25bc                  \u2502    \u2502\n+      \u2502                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502    \u2502\n+      \u2502                  \u2502   bcb5: Goto    \u2502 \u2500\u2518    \u2502\n+      \u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n+      \u2502                                            \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+    */\n+    assert_eq!(\n+        basic_coverage_blocks.num_nodes(),\n+        7,\n+        \"basic_coverage_blocks: {:?}\",\n+        basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+    );\n+\n+    let_bcb!(0);\n+    let_bcb!(1);\n+    let_bcb!(2);\n+    let_bcb!(3);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_successors!(basic_coverage_blocks, bcb0, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb1, [bcb2, bcb3]);\n+    assert_successors!(basic_coverage_blocks, bcb2, []);\n+    assert_successors!(basic_coverage_blocks, bcb3, [bcb4]);\n+    assert_successors!(basic_coverage_blocks, bcb4, [bcb5, bcb6]);\n+    assert_successors!(basic_coverage_blocks, bcb5, [bcb1]);\n+    assert_successors!(basic_coverage_blocks, bcb6, [bcb4]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_none() {\n+    let mir_body = goto_switchint();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    if false {\n+        println!(\n+            \"basic_coverage_blocks = {:?}\",\n+            basic_coverage_blocks.iter_enumerated().collect::<Vec<_>>()\n+        );\n+        println!(\"successors = {:?}\", basic_coverage_blocks.successors);\n+    }\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        0,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_one() {\n+    let mir_body = switchint_then_loop_else_return();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        1,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(3);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb3]);\n+}\n+\n+#[test]\n+fn test_find_loop_backedges_two() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let backedges = graph::find_loop_backedges(&basic_coverage_blocks);\n+    assert_eq!(\n+        backedges.iter_enumerated().map(|(_bcb, backedges)| backedges.len()).sum::<usize>(),\n+        2,\n+        \"backedges: {:?}\",\n+        backedges\n+    );\n+\n+    let_bcb!(1);\n+    let_bcb!(4);\n+    let_bcb!(5);\n+    let_bcb!(6);\n+\n+    assert_eq!(backedges[bcb1], vec![bcb5]);\n+    assert_eq!(backedges[bcb4], vec![bcb6]);\n+}\n+\n+#[test]\n+fn test_traverse_coverage_with_loops() {\n+    let mir_body = switchint_loop_then_inner_loop_else_break();\n+    let basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+    let mut traversed_in_order = Vec::new();\n+    let mut traversal = graph::TraverseCoverageGraphWithLoops::new(&basic_coverage_blocks);\n+    while let Some(bcb) = traversal.next(&basic_coverage_blocks) {\n+        traversed_in_order.push(bcb);\n+    }\n+\n+    let_bcb!(6);\n+\n+    // bcb0 is visited first. Then bcb1 starts the first loop, and all remaining nodes, *except*\n+    // bcb6 are inside the first loop.\n+    assert_eq!(\n+        *traversed_in_order.last().expect(\"should have elements\"),\n+        bcb6,\n+        \"bcb6 should not be visited until all nodes inside the first loop have been visited\"\n+    );\n+}\n+\n+fn synthesize_body_span_from_terminators(mir_body: &Body<'_>) -> Span {\n+    let mut some_span: Option<Span> = None;\n+    for (_, data) in mir_body.basic_blocks().iter_enumerated() {\n+        let term_span = data.terminator().source_info.span;\n+        if let Some(span) = some_span.as_mut() {\n+            *span = span.to(term_span);\n+        } else {\n+            some_span = Some(term_span)\n+        }\n+    }\n+    some_span.expect(\"body must have at least one BasicBlock\")\n+}\n+\n+#[test]\n+fn test_make_bcb_counters() {\n+    rustc_span::with_default_session_globals(|| {\n+        let mir_body = goto_switchint();\n+        let body_span = synthesize_body_span_from_terminators(&mir_body);\n+        let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n+        let mut coverage_spans = Vec::new();\n+        for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n+            if let Some(span) =\n+                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n+            {\n+                coverage_spans.push(spans::CoverageSpan::for_terminator(span, bcb, data.last_bb()));\n+            }\n+        }\n+        let mut coverage_counters = counters::CoverageCounters::new(0);\n+        let intermediate_expressions = coverage_counters\n+            .make_bcb_counters(&mut basic_coverage_blocks, &coverage_spans)\n+            .expect(\"should be Ok\");\n+        assert_eq!(intermediate_expressions.len(), 0);\n+\n+        let_bcb!(1);\n+        assert_eq!(\n+            1, // coincidentally, bcb1 has a `Counter` with id = 1\n+            match basic_coverage_blocks[bcb1].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+\n+        let_bcb!(2);\n+        assert_eq!(\n+            2, // coincidentally, bcb2 has a `Counter` with id = 2\n+            match basic_coverage_blocks[bcb2].counter().expect(\"should have a counter\") {\n+                CoverageKind::Counter { id, .. } => id,\n+                _ => panic!(\"expected a Counter\"),\n+            }\n+            .as_u32()\n+        );\n+    });\n+}"}]}