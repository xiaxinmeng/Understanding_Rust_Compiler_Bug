{"sha": "3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjN2FlYTNhNmE1ZmNmMDQwNjZkMDM2OGJmZDY2MThlOTQ5NDE3NmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-17T16:15:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-20T03:21:52Z"}, "message": "syntax: de-mode and prepare for de-modeing rustc", "tree": {"sha": "f80b0e952362e9f2496282be2ecc3a16fc39a364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80b0e952362e9f2496282be2ecc3a16fc39a364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "html_url": "https://github.com/rust-lang/rust/commit/3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9f4ef65f5a2fa0d3ba610daaf328309130f7fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9f4ef65f5a2fa0d3ba610daaf328309130f7fb", "html_url": "https://github.com/rust-lang/rust/commit/be9f4ef65f5a2fa0d3ba610daaf328309130f7fb"}], "stats": {"total": 727, "additions": 363, "deletions": 364}, "files": [{"sha": "b6580b4c5a1b2bde74311c9dc994c0c74c119104", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -255,13 +255,13 @@ pub impl AbiSet {\n }\n \n impl to_bytes::IterBytes for Abi {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.index().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for AbiSet {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.bits.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "b0b3e45abe501203965eb5c53e6eac5e4d2b2aad", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -97,7 +97,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -284,7 +284,7 @@ pub enum binding_mode {\n }\n \n impl to_bytes::IterBytes for binding_mode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n@@ -330,7 +330,7 @@ pub enum pat_ {\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n impl to_bytes::IterBytes for mutability {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -345,7 +345,7 @@ pub enum Sigil {\n }\n \n impl to_bytes::IterBytes for Sigil {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n@@ -428,7 +428,7 @@ pub enum inferable<T> {\n }\n \n impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n           to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n@@ -446,7 +446,7 @@ impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n pub enum rmode { by_ref, by_copy }\n \n impl to_bytes::IterBytes for rmode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -781,7 +781,7 @@ impl ToStr for int_ty {\n }\n \n impl to_bytes::IterBytes for int_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -798,7 +798,7 @@ impl ToStr for uint_ty {\n }\n \n impl to_bytes::IterBytes for uint_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -815,7 +815,7 @@ impl ToStr for float_ty {\n }\n \n impl to_bytes::IterBytes for float_ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -860,7 +860,7 @@ impl ToStr for Onceness {\n }\n \n impl to_bytes::IterBytes for Onceness {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n@@ -911,7 +911,7 @@ pub enum ty_ {\n }\n \n impl to_bytes::IterBytes for Ty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n@@ -979,7 +979,7 @@ impl ToStr for purity {\n }\n \n impl to_bytes::IterBytes for purity {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -994,7 +994,7 @@ pub enum ret_style {\n }\n \n impl to_bytes::IterBytes for ret_style {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1268,7 +1268,7 @@ pub enum item_ {\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n impl to_bytes::IterBytes for struct_mutability {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "05e67196b4c15d3b9de063ff4e7c72f8132ac522", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -115,7 +115,7 @@ pub struct Ctx {\n \n pub type vt = visit::vt<@mut Ctx>;\n \n-pub fn extend(cx: @mut Ctx, +elt: ident) -> @path {\n+pub fn extend(cx: @mut Ctx, elt: ident) -> @path {\n     @(vec::append(copy cx.path, ~[path_name(elt)]))\n }\n \n@@ -132,7 +132,7 @@ pub fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-pub fn map_crate(diag: @span_handler, c: crate) -> map {\n+pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n@@ -148,8 +148,8 @@ pub fn map_crate(diag: @span_handler, c: crate) -> map {\n // the item itself.\n pub fn map_decoded_item(diag: @span_handler,\n                         map: map,\n-                        +path: path,\n-                        ii: inlined_item) {\n+                        path: path,\n+                        ii: &inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -167,7 +167,7 @@ pub fn map_decoded_item(diag: @span_handler,\n     // methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n-    match ii {\n+    match *ii {\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i,\n@@ -190,7 +190,7 @@ pub fn map_fn(\n     body: &blk,\n     sp: codemap::span,\n     id: node_id,\n-    &&cx: @mut Ctx,\n+    cx: @mut Ctx,\n     v: visit::vt<@mut Ctx>\n ) {\n     for decl.inputs.each |a| {\n@@ -222,7 +222,7 @@ pub fn map_fn(\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: &blk, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_block(b: &blk, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy *b));\n     visit::visit_block(b, cx, v);\n }\n@@ -239,24 +239,24 @@ pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n     };\n }\n \n-pub fn map_local(loc: @local, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_local(loc: @local, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: &arm, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_arm(arm: &arm, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n-                  m: @method, &&cx: @mut Ctx) {\n+                  m: @method, cx: @mut Ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n     cx.map.insert(m.self_id, node_local(cx.local_id));\n     cx.local_id += 1u;\n }\n \n-pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_item(i: @item, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n@@ -355,13 +355,13 @@ pub fn map_struct_def(\n     }\n }\n \n-pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n-    cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n+pub fn map_stmt(stmt: @stmt, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n+    cx.map.insert(stmt_id(stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }\n \n@@ -408,7 +408,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_stmt(stmt)) => {\n         fmt!(\"stmt %s (id=%?)\",\n-             pprust::stmt_to_str(*stmt, itr), id)\n+             pprust::stmt_to_str(stmt, itr), id)\n       }\n       Some(&node_arg(_, _)) => { // add more info here\n         fmt!(\"arg (id=%?)\", id)\n@@ -430,7 +430,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n                                query: &fn(@item) -> Result,\n-                               +error_msg: ~str) -> Result {\n+                               error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(error_msg)"}, {"sha": "910c9857d2d635888efbff6a390b11cc5fc363db", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -39,7 +39,7 @@ pub fn local_def(id: node_id) -> def_id {\n \n pub fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-pub fn stmt_id(s: stmt) -> node_id {\n+pub fn stmt_id(s: &stmt) -> node_id {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -200,7 +200,7 @@ pub fn is_call_expr(e: @expr) -> bool {\n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n@@ -211,7 +211,7 @@ pub fn block_from_expr(e: @expr) -> blk {\n }\n \n pub fn default_block(\n-    +stmts1: ~[@stmt],\n+    stmts1: ~[@stmt],\n     expr1: Option<@expr>,\n     id1: node_id\n ) -> blk_ {\n@@ -224,15 +224,15 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, +i: ident) -> @Path {\n+pub fn ident_to_path(s: span, i: ident) -> @Path {\n     @ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n+pub fn ident_to_pat(id: node_id, s: span, i: ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_by_copy, ident_to_path(s, i), None),\n                 span: s }\n@@ -300,7 +300,7 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n pub trait inlined_item_utils {\n     fn ident(&self) -> ident;\n     fn id(&self) -> ast::node_id;\n-    fn accept<E>(&self, e: E, v: visit::vt<E>);\n+    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>);\n }\n \n impl inlined_item_utils for inlined_item {\n@@ -322,7 +322,7 @@ impl inlined_item_utils for inlined_item {\n         }\n     }\n \n-    fn accept<E>(&self, e: E, v: visit::vt<E>) {\n+    fn accept<E: Copy>(&self, e: E, v: visit::vt<E>) {\n         match *self {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n@@ -435,7 +435,7 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n \n         visit_local: |l| vfn(l.node.id),\n         visit_block: |b| vfn(b.node.id),\n-        visit_stmt: |s| vfn(ast_util::stmt_id(*s)),\n+        visit_stmt: |s| vfn(ast_util::stmt_id(s)),\n         visit_arm: |_| {},\n         visit_pat: |p| vfn(p.id),\n         visit_decl: |_| {},\n@@ -491,7 +491,7 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n     })\n }\n \n-pub fn visit_ids_for_inlined_item(item: inlined_item, vfn: @fn(node_id)) {\n+pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(node_id)) {\n     item.accept((), id_visitor(vfn));\n }\n \n@@ -505,7 +505,7 @@ pub fn compute_id_range(visit_ids_fn: &fn(@fn(node_id))) -> id_range {\n     id_range { min: *min, max: *max }\n }\n \n-pub fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n+pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n     compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n@@ -609,7 +609,7 @@ pub fn mk_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n pub fn mk_sctable() -> SCTable { ~[EmptyCtxt] }\n \n /// Add a value to the end of a vec, return its index\n-fn idx_push<T>(vec: &mut ~[T], +val: T) -> uint {\n+fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n     vec.push(val);\n     vec.len() - 1\n }"}, {"sha": "98cfdd33ef6b64ce25558ddd118feef3e041a85d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -31,12 +31,12 @@ pub fn mk_name_value_item_str(name: @~str, value: @~str)\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @~str, +value: ast::lit)\n+pub fn mk_name_value_item(name: @~str, value: ast::lit)\n         -> @ast::meta_item {\n     @dummy_spanned(ast::meta_name_value(name, value))\n }\n \n-pub fn mk_list_item(name: @~str, +items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: @~str, items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n     @dummy_spanned(ast::meta_list(name, items))\n }\n@@ -51,8 +51,8 @@ pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n                                     is_sugared_doc: false })\n }\n \n-pub fn mk_sugared_doc_attr(+text: ~str,\n-                           +lo: BytePos, +hi: BytePos) -> ast::attribute {\n+pub fn mk_sugared_doc_attr(text: ~str,\n+                           lo: BytePos, hi: BytePos) -> ast::attribute {\n     let style = doc_comment_style(text);\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = ast::attribute_ {"}, {"sha": "bd8aa7011b7b7f993f546f4ef469867cfebaa7ea", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -71,7 +71,7 @@ impl Sub<BytePos, BytePos> for BytePos {\n }\n \n impl to_bytes::IterBytes for BytePos {\n-    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -89,7 +89,7 @@ impl cmp::Ord for CharPos {\n }\n \n impl to_bytes::IterBytes for CharPos {\n-    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -141,20 +141,20 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-pub fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n \n-pub fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+pub fn respan<T>(sp: span, t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n-pub fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+pub fn dummy_spanned<T>(t: T) -> spanned<T> {\n     respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n-pub fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+pub fn mk_sp(lo: BytePos, hi: BytePos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n@@ -247,7 +247,7 @@ pub impl FileMap {\n     // UNCHECKED INVARIANT: these offsets must be added in the right\n     // order and must be in the right places; there is shared knowledge\n     // about what ends a line between this file and parse.rs\n-    fn next_line(&self, +pos: BytePos) {\n+    fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n         let lines = &mut *self.lines;\n         assert!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n@@ -287,14 +287,14 @@ pub impl CodeMap {\n     }\n \n     /// Add a new FileMap to the CodeMap and return it\n-    fn new_filemap(&self, +filename: FileName, src: @~str) -> @FileMap {\n+    fn new_filemap(&self, filename: FileName, src: @~str) -> @FileMap {\n         return self.new_filemap_w_substr(filename, FssNone, src);\n     }\n \n     fn new_filemap_w_substr(\n         &self,\n-        +filename: FileName,\n-        +substr: FileSubstr,\n+        filename: FileName,\n+        substr: FileSubstr,\n         src: @~str\n     ) -> @FileMap {\n         let files = &mut *self.files;\n@@ -325,11 +325,11 @@ pub impl CodeMap {\n     }\n \n     /// Lookup source information about a BytePos\n-    pub fn lookup_char_pos(&self, +pos: BytePos) -> Loc {\n+    pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         return self.lookup_pos(pos);\n     }\n \n-    pub fn lookup_char_pos_adj(&self, +pos: BytePos) -> LocWithOpt\n+    pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt\n     {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n@@ -405,7 +405,7 @@ pub impl CodeMap {\n \n priv impl CodeMap {\n \n-    fn lookup_filemap_idx(&self, +pos: BytePos) -> uint {\n+    fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = &*self.files;\n         let len = files.len();\n         let mut a = 0u;\n@@ -440,7 +440,7 @@ priv impl CodeMap {\n         return FileMapAndLine {fm: f, line: a};\n     }\n \n-    fn lookup_pos(&self, +pos: BytePos) -> Loc {\n+    fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n@@ -466,7 +466,7 @@ priv impl CodeMap {\n                     lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n-    fn lookup_byte_offset(&self, +bpos: BytePos)\n+    fn lookup_byte_offset(&self, bpos: BytePos)\n         -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = self.files[idx];\n@@ -476,7 +476,7 @@ priv impl CodeMap {\n \n     // Converts an absolute BytePos to a CharPos relative to the file it is\n     // located in\n-    fn bytepos_to_local_charpos(&self, +bpos: BytePos) -> CharPos {\n+    fn bytepos_to_local_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting %? to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let map = self.files[idx];"}, {"sha": "67c09c00733f8fa88dc2d4ad25e979d42a8f7484", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -239,7 +239,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn expr(&self, span: span, +node: ast::expr_) -> @ast::expr {\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -248,7 +248,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n         @ast::Path {\n             span: span,\n             global: false,\n@@ -258,7 +258,7 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path_global(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n         @ast::Path {\n             span: span,\n             global: true,\n@@ -271,8 +271,8 @@ priv impl @ext_ctxt {\n     fn path_tps(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Path {\n         @ast::Path {\n             span: span,\n@@ -286,8 +286,8 @@ priv impl @ext_ctxt {\n     fn path_tps_global(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Path {\n         @ast::Path {\n             span: span,\n@@ -301,8 +301,8 @@ priv impl @ext_ctxt {\n     fn ty_path(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident],\n-        +tps: ~[@ast::Ty]\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n     ) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n@@ -349,13 +349,13 @@ priv impl @ext_ctxt {\n                                 span: span}))\n     }\n \n-    fn lambda(&self, +blk: ast::blk) -> @ast::expr {\n+    fn lambda(&self, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n         quote_expr!( || $blk_e )\n     }\n \n-    fn blk(&self, span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n         codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n@@ -381,19 +381,19 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn expr_path(&self, span: span, +strs: ~[ast::ident]) -> @ast::expr {\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path(span, strs)))\n     }\n \n     fn expr_path_global(\n         &self,\n         span: span,\n-        +strs: ~[ast::ident]\n+        strs: ~[ast::ident]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_path(self.path_global(span, strs)))\n     }\n \n-    fn expr_var(&self, span: span, +var: ~str) -> @ast::expr {\n+    fn expr_var(&self, span: span, var: ~str) -> @ast::expr {\n         self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n@@ -410,7 +410,7 @@ priv impl @ext_ctxt {\n         &self,\n         span: span,\n         expr: @ast::expr,\n-        +args: ~[@ast::expr]\n+        args: ~[@ast::expr]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n@@ -420,7 +420,7 @@ priv impl @ext_ctxt {\n         span: span,\n         expr: @ast::expr,\n         ident: ast::ident,\n-        +args: ~[@ast::expr]\n+        args: ~[@ast::expr]\n     ) -> @ast::expr {\n         self.expr(span, ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n     }\n@@ -429,7 +429,7 @@ priv impl @ext_ctxt {\n         self.lambda(self.expr_blk(expr))\n     }\n \n-    fn lambda_stmts(&self, span: span, +stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda(self.blk(span, stmts))\n     }\n }\n@@ -597,7 +597,7 @@ fn mk_deser_impl(\n fn mk_ser_method(\n     cx: @ext_ctxt,\n     span: span,\n-    +ser_body: ast::blk\n+    ser_body: ast::blk\n ) -> @ast::method {\n     let ty_s = @ast::Ty {\n         id: cx.next_id(),\n@@ -660,7 +660,7 @@ fn mk_deser_method(\n     cx: @ext_ctxt,\n     span: span,\n     ty: @ast::Ty,\n-    +deser_body: ast::blk\n+    deser_body: ast::blk\n ) -> @ast::method {\n     let ty_d = @ast::Ty {\n         id: cx.next_id(),\n@@ -864,7 +864,7 @@ fn mk_enum_ser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    +enum_def: ast::enum_def,\n+    enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_ser_body(\n@@ -881,7 +881,7 @@ fn mk_enum_deser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    +enum_def: ast::enum_def,\n+    enum_def: ast::enum_def,\n     generics: &ast::Generics\n ) -> @ast::item {\n     let body = mk_enum_deser_body(\n@@ -974,7 +974,7 @@ fn mk_enum_ser_body(\n     cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n-    +variants: ~[ast::variant]\n+    variants: ~[ast::variant]\n ) -> @ast::expr {\n     let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n@@ -1219,37 +1219,37 @@ mod test {\n     impl Encoder for TestEncoder {\n         fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n \n-        fn emit_uint(&self, +v: uint) {self.add_to_log(CallToEmitUint(v)); }\n-        fn emit_u64(&self, +_v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&self, +_v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&self, +_v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&self, +_v: u8)   { self.add_unknown_to_log(); }\n+        fn emit_uint(&self, v: uint) {self.add_to_log(CallToEmitUint(v)); }\n+        fn emit_u64(&self, _v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&self, _v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&self, _v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&self, _v: u8)   { self.add_unknown_to_log(); }\n \n-        fn emit_int(&self, +_v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&self, +_v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&self, +_v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&self, +_v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&self, +_v: i8)   { self.add_unknown_to_log(); }\n+        fn emit_int(&self, _v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&self, _v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&self, _v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&self, _v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&self, _v: i8)   { self.add_unknown_to_log(); }\n \n-        fn emit_bool(&self, +_v: bool) { self.add_unknown_to_log(); }\n+        fn emit_bool(&self, _v: bool) { self.add_unknown_to_log(); }\n \n-        fn emit_f64(&self, +_v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&self, +_v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&self, +_v: float) { self.add_unknown_to_log(); }\n+        fn emit_f64(&self, _v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&self, _v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&self, _v: float) { self.add_unknown_to_log(); }\n \n-        fn emit_char(&self, +_v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n+        fn emit_char(&self, _v: char) { self.add_unknown_to_log(); }\n+        fn emit_str(&self, _v: &str) { self.add_unknown_to_log(); }\n \n         fn emit_enum(&self, name: &str, f: &fn()) {\n             self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n \n-        fn emit_enum_variant(&self, name: &str, +id: uint,\n-                             +cnt: uint, f: &fn()) {\n+        fn emit_enum_variant(&self, name: &str, id: uint,\n+                             cnt: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n             f();\n         }\n \n-        fn emit_enum_variant_arg(&self, +idx: uint, f: &fn()) {\n+        fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n@@ -1261,10 +1261,10 @@ mod test {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n+        fn emit_struct(&self, name: &str, len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_struct_field(&self, name: &str, +idx: uint, f: &fn()) {\n+        fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n@@ -1294,10 +1294,10 @@ mod test {\n             f();\n         }\n \n-        fn emit_seq(&self, +_len: uint, f: &fn()) {\n+        fn emit_seq(&self, _len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n+        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n "}, {"sha": "4eb48d12bfeab67c9f86f3886115ce4153bf60f0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -238,7 +238,7 @@ pub trait ext_ctxt {\n     fn ident_of(@mut self, st: ~str) -> ast::ident;\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, +cfg: ast::crate_cfg)\n+pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n             -> @ext_ctxt {\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n@@ -439,7 +439,7 @@ pub enum MapChain<K,V> {\n impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n \n     // Constructor. I don't think we need a zero-arg one.\n-    fn new(+init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n+    fn new(init: ~HashMap<K,@V>) -> @mut MapChain<K,V> {\n         @mut BaseMapChain(init)\n     }\n \n@@ -509,7 +509,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     }\n \n     // insert the binding into the top-level map\n-    fn insert (&mut self, +key: K, +ext: @V) -> bool {\n+    fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n         match *self {\n             BaseMapChain (~ref mut map) => map.insert(key, ext),"}, {"sha": "ff78ddb803cde0eab25f1e8f97168f64ccf6e8b5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -27,7 +27,7 @@ pub struct Field {\n \n pub fn mk_expr(cx: @ext_ctxt,\n                sp: codemap::span,\n-               +expr: ast::expr_)\n+               expr: ast::expr_)\n             -> @ast::expr {\n     @ast::expr {\n         id: cx.next_id(),\n@@ -63,44 +63,44 @@ pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n     mk_raw_path_(sp, idents, ~[])\n }\n pub fn mk_raw_path_(sp: span,\n-                    +idents: ~[ast::ident],\n-                    +types: ~[@ast::Ty])\n+                    idents: ~[ast::ident],\n+                    types: ~[@ast::Ty])\n                  -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::Path {\n     mk_raw_path_global_(sp, idents, ~[])\n }\n pub fn mk_raw_path_global_(sp: span,\n-                           +idents: ~[ast::ident],\n-                           +types: ~[@ast::Ty]) -> @ast::Path {\n+                           idents: ~[ast::ident],\n+                           types: ~[@ast::Ty]) -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_path(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n+pub fn mk_path(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n             -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-pub fn mk_path_global(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n+pub fn mk_path_global(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: @ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: @ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n@@ -115,25 +115,25 @@ pub fn mk_method_call(cx: @ext_ctxt,\n                       sp: span,\n                       rcvr_expr: @ast::expr,\n                       method_ident: ast::ident,\n-                      +args: ~[@ast::expr]) -> @ast::expr {\n+                      args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n }\n pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n-                +args: ~[@ast::expr]) -> @ast::expr {\n+                args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n-               +args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+               args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n-                      +args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_global(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n@@ -143,20 +143,20 @@ pub fn mk_vstore_e(cx: @ext_ctxt, sp: span, expr: @ast::expr,\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_base_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -170,8 +170,8 @@ pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n }\n pub fn mk_struct_e(cx: @ext_ctxt,\n                    sp: span,\n-                   +ctor_path: ~[ast::ident],\n-                   +fields: ~[Field])\n+                   ctor_path: ~[ast::ident],\n+                   fields: ~[Field])\n                 -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n@@ -180,8 +180,8 @@ pub fn mk_struct_e(cx: @ext_ctxt,\n }\n pub fn mk_global_struct_e(cx: @ext_ctxt,\n                           sp: span,\n-                          +ctor_path: ~[ast::ident],\n-                          +fields: ~[Field])\n+                          ctor_path: ~[ast::ident],\n+                          fields: ~[Field])\n                        -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n@@ -190,7 +190,7 @@ pub fn mk_global_struct_e(cx: @ext_ctxt,\n }\n pub fn mk_glob_use(cx: @ext_ctxt,\n                    sp: span,\n-                   +path: ~[ast::ident]) -> @ast::view_item {\n+                   path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n@@ -226,8 +226,8 @@ pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: @ext_ctxt, span: span,\n-                +view_items: ~[@ast::view_item],\n-                +stmts: ~[@ast::stmt],\n+                view_items: ~[@ast::view_item],\n+                stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n     let blk = codemap::spanned {\n         node: ast::blk_ {\n@@ -243,7 +243,7 @@ pub fn mk_block(cx: @ext_ctxt, span: span,\n }\n pub fn mk_block_(cx: @ext_ctxt,\n                  span: span,\n-                 +stmts: ~[@ast::stmt])\n+                 stmts: ~[@ast::stmt])\n               -> ast::blk {\n     codemap::spanned {\n         node: ast::blk_ {\n@@ -307,7 +307,7 @@ pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-pub fn mk_pat(cx: @ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n+pub fn mk_pat(cx: @ext_ctxt, span: span, pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n@@ -335,15 +335,15 @@ pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n pub fn mk_pat_enum(cx: @ext_ctxt,\n                    span: span,\n                    path: @ast::Path,\n-                   +subpats: ~[@ast::pat])\n+                   subpats: ~[@ast::pat])\n                 -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(subpats));\n     mk_pat(cx, span, pat)\n }\n pub fn mk_pat_struct(cx: @ext_ctxt,\n                      span: span,\n                      path: @ast::Path,\n-                     +field_pats: ~[ast::field_pat])\n+                     field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n     let pat = ast::pat_struct(path, field_pats, false);\n     mk_pat(cx, span, pat)\n@@ -360,7 +360,7 @@ pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n }\n pub fn mk_ty_path(cx: @ext_ctxt,\n                   span: span,\n-                  +idents: ~[ ast::ident ])\n+                  idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -369,7 +369,7 @@ pub fn mk_ty_path(cx: @ext_ctxt,\n }\n pub fn mk_ty_path_global(cx: @ext_ctxt,\n                          span: span,\n-                         +idents: ~[ ast::ident ])\n+                         idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n@@ -399,7 +399,7 @@ pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n }\n pub fn mk_trait_ref_global(cx: @ext_ctxt,\n                            span: span,\n-                           +idents: ~[ ast::ident ])\n+                           idents: ~[ ast::ident ])\n     -> @ast::trait_ref\n {\n     mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n@@ -430,12 +430,12 @@ pub fn mk_arg(cx: @ext_ctxt,\n         id: cx.next_id()\n     }\n }\n-pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+pub fn mk_fn_decl(inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n                                       span: span,\n-                                      +idents: ~[ast::ident])\n+                                      idents: ~[ast::ident])\n                                    -> ast::TyParamBound {\n     ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n }"}, {"sha": "6fd27c5f3d732ed5de61754f3d4593dcad2f395e", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -91,7 +91,7 @@ fn create_derived_encodable_impl(\n fn create_encode_method(\n     cx: @ext_ctxt,\n     span: span,\n-    +statements: ~[@stmt]\n+    statements: ~[@stmt]\n ) -> @method {\n     // Create the `e` parameter.\n     let e_arg_type = build::mk_ty_rptr("}, {"sha": "85592d142abcfbddd5c8068e339d31e3a9baa210", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -64,7 +64,7 @@ fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n // signature of the `iter_bytes` method.\n fn create_iter_bytes_method(cx: @ext_ctxt,\n                             span: span,\n-                            +statements: ~[@stmt])\n+                            statements: ~[@stmt])\n                          -> @method {\n     // Create the `lsb0` parameter.\n     let bool_ident = cx.ident_of(~\"bool\");"}, {"sha": "577cf4c01cfde167696cf4c5600de8f942d741df", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -142,7 +142,7 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n+fn create_impl_item(cx: @ext_ctxt, span: span, item: item_) -> @item {\n     let doc_attr = respan(span,\n                           ast::lit_str(@~\"Automatically derived.\"));\n     let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));"}, {"sha": "61032429c93a7b4e19e207c57e587515979ffffa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -237,8 +237,8 @@ macro_rules! without_macro_scoping(\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n-                       cx: @ext_ctxt, &&it: @ast::item,\n+pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n+                       cx: @ext_ctxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {"}, {"sha": "e0f6c90f5b378c424ab7faba2e7ecb950d1b3922", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -34,15 +34,15 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(+ids: ~[ident], span: span) -> @ast::Path {\n+pub fn path(ids: ~[ident], span: span) -> @ast::Path {\n     @ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(+ids: ~[ident], span: span) -> @ast::Path {\n+pub fn path_global(ids: ~[ident], span: span) -> @ast::Path {\n     @ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n@@ -52,7 +52,7 @@ pub fn path_global(+ids: ~[ident], span: span) -> @ast::Path {\n \n pub trait append_types {\n     fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path;\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path;\n }\n \n impl append_types for @ast::Path {\n@@ -63,7 +63,7 @@ impl append_types for @ast::Path {\n         }\n     }\n \n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path {\n+    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path {\n         @ast::Path {\n             types: vec::append(copy self.types, tys),\n             .. copy **self\n@@ -76,63 +76,63 @@ pub trait ext_ctxt_ast_builder {\n         -> ast::TyParam;\n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg;\n     fn expr_block(&self, e: @ast::expr) -> ast::blk;\n-    fn fn_decl(&self, +inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n-    fn item(&self, name: ident, span: span, +node: ast::item_) -> @ast::item;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn item(&self, name: ident, span: span, node: ast::item_) -> @ast::item;\n     fn item_fn_poly(&self,\n                     ame: ident,\n-                    +inputs: ~[ast::arg],\n+                    inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +generics: Generics,\n-                    +body: ast::blk) -> @ast::item;\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n                name: ident,\n-               +inputs: ~[ast::arg],\n+               inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk) -> @ast::item;\n+               body: ast::blk) -> @ast::item;\n     fn item_enum_poly(&self,\n                       name: ident,\n                       span: span,\n-                      +enum_definition: ast::enum_def,\n-                      +generics: Generics) -> @ast::item;\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item;\n     fn item_enum(&self,\n                  name: ident,\n                  span: span,\n-                 +enum_definition: ast::enum_def) -> @ast::item;\n+                 enum_definition: ast::enum_def) -> @ast::item;\n     fn item_struct_poly(&self,\n                         name: ident,\n                         span: span,\n-                        +struct_def: ast::struct_def,\n-                        +generics: Generics) -> @ast::item;\n+                        struct_def: ast::struct_def,\n+                        generics: Generics) -> @ast::item;\n     fn item_struct(&self,\n                    name: ident,\n                    span: span,\n-                   +struct_def: ast::struct_def) -> @ast::item;\n+                   struct_def: ast::struct_def) -> @ast::item;\n     fn struct_expr(&self,\n                    path: @ast::Path,\n-                   +fields: ~[ast::field]) -> @ast::expr;\n+                   fields: ~[ast::field]) -> @ast::expr;\n     fn variant(&self,\n                name: ident,\n                span: span,\n-               +tys: ~[@ast::Ty]) -> ast::variant;\n+               tys: ~[@ast::Ty]) -> ast::variant;\n     fn item_mod(&self,\n                 name: ident,\n                 span: span,\n-                +items: ~[@ast::item]) -> @ast::item;\n+                items: ~[@ast::item]) -> @ast::item;\n     fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty;\n     fn item_ty_poly(&self,\n                     name: ident,\n                     span: span,\n                     ty: @ast::Ty,\n-                    +generics: Generics) -> @ast::item;\n+                    generics: Generics) -> @ast::item;\n     fn item_ty(&self, name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n     fn ty_field_imm(&self, name: ident, ty: @ast::Ty) -> ast::ty_field;\n     fn field_imm(&self, name: ident, e: @ast::expr) -> ast::field;\n-    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n+    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n     fn stmt_let(&self, ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(&self, e: @ast::expr) -> @ast::stmt;\n-    fn block_expr(&self, +b: ast::blk) -> @ast::expr;\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr;\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer(&self) -> @ast::Ty;\n     fn ty_nil_ast_builder(&self) -> @ast::Ty;\n@@ -148,7 +148,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         ], dummy_sp()).add_ty(ty))\n     }\n \n-    fn block_expr(&self, +b: ast::blk) -> @ast::expr {\n+    fn block_expr(&self, b: ast::blk) -> @ast::expr {\n         @expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -215,7 +215,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         }\n     }\n \n-    fn block(&self, +stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n+    fn block(&self, stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n         let blk = ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -231,7 +231,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         self.block(~[], e)\n     }\n \n-    fn fn_decl(&self, +inputs: ~[ast::arg],\n+    fn fn_decl(&self, inputs: ~[ast::arg],\n                output: @ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n@@ -241,7 +241,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item(&self, name: ident, span: span,\n-            +node: ast::item_) -> @ast::item {\n+            node: ast::item_) -> @ast::item {\n \n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n@@ -265,10 +265,10 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_fn_poly(&self, name: ident,\n-                    +inputs: ~[ast::arg],\n+                    inputs: ~[ast::arg],\n                     output: @ast::Ty,\n-                    +generics: Generics,\n-                    +body: ast::blk) -> @ast::item {\n+                    generics: Generics,\n+                    body: ast::blk) -> @ast::item {\n         self.item(name,\n                   dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n@@ -280,9 +280,9 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n \n     fn item_fn(&self,\n                name: ident,\n-               +inputs: ~[ast::arg],\n+               inputs: ~[ast::arg],\n                output: @ast::Ty,\n-               +body: ast::blk\n+               body: ast::blk\n     ) -> @ast::item {\n         self.item_fn_poly(\n             name,\n@@ -294,21 +294,21 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_enum_poly(&self, name: ident, span: span,\n-                      +enum_definition: ast::enum_def,\n-                      +generics: Generics) -> @ast::item {\n+                      enum_definition: ast::enum_def,\n+                      generics: Generics) -> @ast::item {\n         self.item(name, span, ast::item_enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, name: ident, span: span,\n-                 +enum_definition: ast::enum_def) -> @ast::item {\n+                 enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(name, span, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n     fn item_struct(\n         &self, name: ident,\n         span: span,\n-        +struct_def: ast::struct_def\n+        struct_def: ast::struct_def\n     ) -> @ast::item {\n         self.item_struct_poly(\n             name,\n@@ -322,14 +322,14 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         &self,\n         name: ident,\n         span: span,\n-        +struct_def: ast::struct_def,\n-        +generics: Generics\n+        struct_def: ast::struct_def,\n+        generics: Generics\n     ) -> @ast::item {\n         self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n     fn struct_expr(&self, path: @ast::Path,\n-                   +fields: ~[ast::field]) -> @ast::expr {\n+                   fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n             callee_id: self.next_id(),\n@@ -339,7 +339,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn variant(&self, name: ident, span: span,\n-               +tys: ~[@ast::Ty]) -> ast::variant {\n+               tys: ~[@ast::Ty]) -> ast::variant {\n         let args = do tys.map |ty| {\n             ast::variant_arg { ty: *ty, id: self.next_id() }\n         };\n@@ -358,7 +358,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_mod(&self, name: ident, span: span,\n-                +items: ~[@ast::item]) -> @ast::item {\n+                items: ~[@ast::item]) -> @ast::item {\n \n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T:::kinds::Owned>` doesn't parse.\n@@ -425,7 +425,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n     }\n \n     fn item_ty_poly(&self, name: ident, span: span, ty: @ast::Ty,\n-                    +generics: Generics) -> @ast::item {\n+                    generics: Generics) -> @ast::item {\n         self.item(name, span, ast::item_ty(ty, generics))\n     }\n "}, {"sha": "7339ebdaa98fac349ba41f8518193fa3af6ec60c", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -19,13 +19,13 @@ use parse::token;\n use core::prelude::*;\n \n pub trait proto_parser {\n-    fn parse_proto(&self, +id: ~str) -> protocol;\n+    fn parse_proto(&self, id: ~str) -> protocol;\n     fn parse_state(&self, proto: protocol);\n     fn parse_message(&self, state: state);\n }\n \n impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, +id: ~str) -> protocol {\n+    fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n         self.parse_seq_to_before_end("}, {"sha": "6495750f93b75b18a11ad8c25922dbb803bede5f", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -81,8 +81,8 @@ pub struct state_ {\n }\n \n pub impl state_ {\n-    fn add_message(@self, +name: ~str, span: span,\n-                   +data: ~[@ast::Ty], +next: Option<next_state>) {\n+    fn add_message(@self, name: ~str, span: span,\n+                   data: ~[@ast::Ty], next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n@@ -119,11 +119,11 @@ pub impl state_ {\n \n pub type protocol = @mut protocol_;\n \n-pub fn protocol(+name: ~str, +span: span) -> protocol {\n+pub fn protocol(name: ~str, span: span) -> protocol {\n     @mut protocol_(name, span)\n }\n \n-pub fn protocol_(+name: ~str, span: span) -> protocol_ {\n+pub fn protocol_(name: ~str, span: span) -> protocol_ {\n     protocol_ {\n         name: name,\n         span: span,\n@@ -177,10 +177,10 @@ pub impl protocol_ {\n \n pub impl protocol_ {\n     fn add_state_poly(@mut self,\n-                      +name: ~str,\n+                      name: ~str,\n                       ident: ast::ident,\n                       dir: direction,\n-                      +generics: ast::Generics)\n+                      generics: ast::Generics)\n                    -> state {\n         let messages = @mut ~[];\n         let states = &*self.states;"}, {"sha": "f355d327d4fa02689809afc22fa175191a094896", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -419,7 +419,7 @@ fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n }\n \n-fn id_ext(cx: @ext_ctxt, +str: ~str) -> ast::ident {\n+fn id_ext(cx: @ext_ctxt, str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n@@ -734,8 +734,8 @@ fn expand_tts(cx: @ext_ctxt,\n \n fn expand_parse_call(cx: @ext_ctxt,\n                      sp: span,\n-                     +parse_method: ~str,\n-                     +arg_exprs: ~[@ast::expr],\n+                     parse_method: ~str,\n+                     arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n     let tts_expr = expand_tts(cx, sp, tts);\n "}, {"sha": "9df7a8e7e1db7b40842f22a09d31b5411beeb3e5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -98,9 +98,9 @@ pub enum matcher_pos_up { /* to break a circularity */\n     matcher_pos_up(Option<~MatcherPos>)\n }\n \n-pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n-    match &mpu {\n-      &matcher_pos_up(None) => false,\n+pub fn is_some(mpu: &matcher_pos_up) -> bool {\n+    match *mpu {\n+      matcher_pos_up(None) => false,\n       _ => true\n     }\n }\n@@ -115,9 +115,9 @@ pub struct MatcherPos {\n     sp_lo: BytePos,\n }\n \n-pub fn copy_up(&& mpu: matcher_pos_up) -> ~MatcherPos {\n-    match &mpu {\n-      &matcher_pos_up(Some(ref mp)) => copy (*mp),\n+pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n+    match *mpu {\n+      matcher_pos_up(Some(ref mp)) => copy (*mp),\n       _ => fail!()\n     }\n }\n@@ -132,7 +132,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn initial_matcher_pos(+ms: ~[matcher], +sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for ms.each |elt| {\n@@ -220,7 +220,7 @@ pub enum parse_result {\n \n pub fn parse_or_else(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     rdr: @reader,\n     ms: ~[matcher]\n ) -> HashMap<ident, @named_match> {\n@@ -257,7 +257,7 @@ pub fn parse(\n             /* at end of sequence */\n             if idx >= len {\n                 // can't move out of `match`es, so:\n-                if is_some(ei.up) {\n+                if is_some(&ei.up) {\n                     // hack: a matcher sequence is repeating iff it has a\n                     // parent (the top level is just a container)\n \n@@ -267,7 +267,7 @@ pub fn parse(\n                     if idx == len {\n                         // pop from the matcher position\n \n-                        let mut new_pos = copy_up(ei.up);\n+                        let mut new_pos = copy_up(&ei.up);\n \n                         // update matches (the MBE \"parse tree\") by appending\n                         // each tree as a subtree.\n@@ -394,7 +394,7 @@ pub fn parse(\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(rust_parser, *sess.interner.get(name))));\n+                        parse_nt(&rust_parser, *sess.interner.get(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -411,7 +411,7 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n+pub fn parse_nt(p: &Parser, name: ~str) -> nonterminal {\n     match name {\n       ~\"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),"}, {"sha": "482e7b80339becfa6836fcc6974edd0125b734b9", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -53,7 +53,7 @@ pub struct TtReader {\n pub fn new_tt_reader(sp_diag: @span_handler,\n                      itr: @ident_interner,\n                      interp: Option<HashMap<ident,@named_match>>,\n-                     +src: ~[ast::token_tree])\n+                     src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n@@ -109,7 +109,7 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n fn lookup_cur_matched_by_matched(r: &mut TtReader,\n                                       start: @named_match)\n                                    -> @named_match {\n-    fn red(+ad: @named_match, idx: &uint) -> @named_match {\n+    fn red(ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth"}, {"sha": "c7ca9eba5124ed4259e80caf1752dbc6d4e7c727", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -27,11 +27,11 @@ pub enum OptVec<T> {\n     Vec(~[T])\n }\n \n-pub fn with<T>(+t: T) -> OptVec<T> {\n+pub fn with<T>(t: T) -> OptVec<T> {\n     Vec(~[t])\n }\n \n-pub fn from<T>(+t: ~[T]) -> OptVec<T> {\n+pub fn from<T>(t: ~[T]) -> OptVec<T> {\n     if t.len() == 0 {\n         Empty\n     } else {\n@@ -40,7 +40,7 @@ pub fn from<T>(+t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n-    fn push(&mut self, +t: T) {\n+    fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {\n                 v.push(t);\n@@ -91,15 +91,15 @@ impl<T> OptVec<T> {\n     }\n }\n \n-pub fn take_vec<T>(+v: OptVec<T>) -> ~[T] {\n+pub fn take_vec<T>(v: OptVec<T>) -> ~[T] {\n     match v {\n         Empty => ~[],\n         Vec(v) => v\n     }\n }\n \n impl<T:Copy> OptVec<T> {\n-    fn prepend(&self, +t: T) -> OptVec<T> {\n+    fn prepend(&self, t: T) -> OptVec<T> {\n         let mut v0 = ~[t];\n         match *self {\n             Empty => {}\n@@ -157,7 +157,7 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n+    fn eachi(&self, blk: &fn(v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n@@ -169,7 +169,7 @@ impl<A> iter::ExtendedIter<A> for OptVec<A> {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]"}, {"sha": "840fb891bff2c5eee85efd17b276ea6fab0f6a81", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -40,7 +40,7 @@ pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     }\n }\n \n-pub fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n+pub fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n     return match stmt.node {\n         ast::stmt_decl(d, _) => {\n             match d.node {"}, {"sha": "2f6bfd4cfc53b23715e805546bbf33b6b94405c5", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -319,7 +319,7 @@ pub struct lit {\n \n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @diagnostic::span_handler,\n-                                    +path: ~str,\n+                                    path: ~str,\n                                     srdr: @io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());"}, {"sha": "2d4a6d47eaa58c3b340021ec3793b4229fb3a5f1", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -28,13 +28,13 @@ pub struct SeqSep {\n     trailing_sep_allowed: bool\n }\n \n-pub fn seq_sep_trailing_disallowed(+t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: false,\n     }\n }\n-pub fn seq_sep_trailing_allowed(+t: token::Token) -> SeqSep {\n+pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n     SeqSep {\n         sep: Some(t),\n         trailing_sep_allowed: true,"}, {"sha": "4d8fdcfe617cc8428e688dd0fed014785e411206", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -126,7 +126,7 @@ pub fn parse_crate_from_source_str(\n pub fn parse_expr_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::expr {\n     let p = new_parser_from_source_str(\n@@ -142,8 +142,8 @@ pub fn parse_expr_from_source_str(\n pub fn parse_item_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n-    +attrs: ~[ast::attribute],\n+    cfg: ast::crate_cfg,\n+    attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n     let p = new_parser_from_source_str(\n@@ -159,7 +159,7 @@ pub fn parse_item_from_source_str(\n pub fn parse_meta_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::meta_item {\n     let p = new_parser_from_source_str(\n@@ -175,8 +175,8 @@ pub fn parse_meta_from_source_str(\n pub fn parse_stmt_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n-    +attrs: ~[ast::attribute],\n+    cfg: ast::crate_cfg,\n+    attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> @ast::stmt {\n     let p = new_parser_from_source_str(\n@@ -192,7 +192,7 @@ pub fn parse_stmt_from_source_str(\n pub fn parse_tts_from_source_str(\n     name: ~str,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> ~[ast::token_tree] {\n     let p = new_parser_from_source_str(\n@@ -207,20 +207,20 @@ pub fn parse_tts_from_source_str(\n }\n \n pub fn parse_from_source_str<T>(\n-    f: &fn (Parser) -> T,\n+    f: &fn(&Parser) -> T,\n     name: ~str, ss: codemap::FileSubstr,\n     source: @~str,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> T {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n-        /*bad*/ copy ss,\n+        name,\n+        ss,\n         source\n     );\n-    let r = f(p);\n+    let r = f(&p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n@@ -236,9 +236,9 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n }\n \n pub fn new_parser_from_source_str(sess: @mut ParseSess,\n-                                  +cfg: ast::crate_cfg,\n-                                  +name: ~str,\n-                                  +ss: codemap::FileSubstr,\n+                                  cfg: ast::crate_cfg,\n+                                  name: ~str,\n+                                  ss: codemap::FileSubstr,\n                                   source: @~str)\n                                -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n@@ -254,7 +254,7 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess,\n /// that draws from that string\n pub fn new_parser_result_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path\n ) -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n@@ -274,7 +274,7 @@ pub fn new_parser_result_from_file(\n /// if the file doesn't exist\n pub fn new_parser_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path\n ) -> Parser {\n     match new_parser_result_from_file(sess, cfg, path) {\n@@ -289,7 +289,7 @@ pub fn new_parser_from_file(\n /// error messages correctly when the file does not exist.\n pub fn new_sub_parser_from_file(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n+    cfg: ast::crate_cfg,\n     path: &Path,\n     sp: span\n ) -> Parser {\n@@ -303,8 +303,8 @@ pub fn new_sub_parser_from_file(\n \n pub fn new_parser_from_tts(\n     sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n-    +tts: ~[ast::token_tree]\n+    cfg: ast::crate_cfg,\n+    tts: ~[ast::token_tree]\n ) -> Parser {\n     let trdr = lexer::new_tt_reader(\n         copy sess.span_diagnostic,\n@@ -316,7 +316,7 @@ pub fn new_parser_from_tts(\n }\n \n // abort if necessary\n-pub fn maybe_aborted<T>(+result : T, p: Parser) -> T {\n+pub fn maybe_aborted<T>(result : T, p: Parser) -> T {\n     p.abort_if_errors();\n     result\n }"}, {"sha": "423fc6dca6d809c78a28b750a04e89d876b67bda", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -66,7 +66,7 @@ pub enum ObsoleteSyntax {\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "e892f212b0577b3f9e2a9874659e1a9f7293059d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -201,7 +201,7 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n+fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n              -> ~[attribute] {\n     match rhs {\n         None => lhs,\n@@ -220,8 +220,8 @@ struct ParsedItemsAndViewItems {\n /* ident is handled by common.rs */\n \n pub fn Parser(sess: @mut ParseSess,\n-              +cfg: ast::crate_cfg,\n-              +rdr: @reader)\n+              cfg: ast::crate_cfg,\n+              rdr: @reader)\n            -> Parser {\n     let tok0 = copy rdr.next_token();\n     let interner = rdr.interner();\n@@ -299,7 +299,7 @@ pub impl Parser {\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n-    fn replace_token(&self, +next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    fn replace_token(&self, next: token::Token, lo: BytePos, hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n@@ -713,7 +713,7 @@ pub impl Parser {\n     fn parse_box_or_uniq_pointee(\n         &self,\n         sigil: ast::Sigil,\n-        ctor: &fn(+v: mt) -> ty_) -> ty_\n+        ctor: &fn(v: mt) -> ty_) -> ty_\n     {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n@@ -1112,7 +1112,7 @@ pub impl Parser {\n         spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n \n-    fn mk_expr(&self, +lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {\n+    fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1121,7 +1121,7 @@ pub impl Parser {\n         }\n     }\n \n-    fn mk_mac_expr(&self, +lo: BytePos, +hi: BytePos, +m: mac_) -> @expr {\n+    fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n@@ -1897,7 +1897,7 @@ pub impl Parser {\n \n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n-                              ctor: &fn(+v: @expr) -> expr_) -> @expr {\n+                              ctor: &fn(v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -2472,7 +2472,7 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_stmt(&self, +first_item_attrs: ~[attribute]) -> @stmt {\n+    fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n@@ -2612,7 +2612,7 @@ pub impl Parser {\n \n     // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n-                         +first_item_attrs: ~[attribute]) -> blk {\n+                         first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n@@ -2658,7 +2658,7 @@ pub impl Parser {\n                                     expr = Some(e);\n                                 }\n                                 copy t => {\n-                                    if classify::stmt_ends_with_semi(*stmt) {\n+                                    if classify::stmt_ends_with_semi(stmt) {\n                                         self.fatal(\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n@@ -2696,7 +2696,7 @@ pub impl Parser {\n                         _ => { // All other kinds of statements:\n                             stmts.push(stmt);\n \n-                            if classify::stmt_ends_with_semi(*stmt) {\n+                            if classify::stmt_ends_with_semi(stmt) {\n                                 self.expect(&token::SEMI);\n                             }\n                         }\n@@ -2891,7 +2891,7 @@ pub impl Parser {\n         &fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n         fn maybe_parse_self_ty(\n-            cnstr: &fn(+v: mutability) -> ast::self_ty_,\n+            cnstr: &fn(v: mutability) -> ast::self_ty_,\n             p: &Parser\n         ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n@@ -3064,9 +3064,9 @@ pub impl Parser {\n         (id, generics)\n     }\n \n-    fn mk_item(&self, +lo: BytePos, +hi: BytePos, +ident: ident,\n-               +node: item_, vis: visibility,\n-               +attrs: ~[attribute]) -> @item {\n+    fn mk_item(&self, lo: BytePos, hi: BytePos, ident: ident,\n+               node: item_, vis: visibility,\n+               attrs: ~[attribute]) -> @item {\n         @ast::item { ident: ident,\n                      attrs: attrs,\n                      id: self.get_id(),\n@@ -3305,7 +3305,7 @@ pub impl Parser {\n          None)\n     }\n \n-    fn token_is_pound_or_doc_comment(&self, ++tok: token::Token) -> bool {\n+    fn token_is_pound_or_doc_comment(&self, tok: token::Token) -> bool {\n         match tok {\n             token::POUND | token::DOC_COMMENT(_) => true,\n             _ => false\n@@ -3340,7 +3340,7 @@ pub impl Parser {\n         a_var\n     }\n \n-    fn parse_dtor(&self, +attrs: ~[attribute]) -> class_contents {\n+    fn parse_dtor(&self, attrs: ~[attribute]) -> class_contents {\n         let lo = self.last_span.lo;\n         let body = self.parse_block();\n         dtor_decl(body, attrs, mk_sp(lo, self.last_span.hi))\n@@ -3392,7 +3392,7 @@ pub impl Parser {\n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&self, term: token::Token,\n-                       +first_item_attrs: ~[attribute]) -> _mod {\n+                       first_item_attrs: ~[attribute]) -> _mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n         let ParsedItemsAndViewItems {\n@@ -3553,7 +3553,7 @@ pub impl Parser {\n                                     outer_attrs, id_sp)\n     }\n \n-    fn eval_src_mod_from_path(&self, prefix: Path, +path: Path,\n+    fn eval_src_mod_from_path(&self, prefix: Path, path: Path,\n                               outer_attrs: ~[ast::attribute],\n                               id_sp: span\n                              ) -> (ast::item_, ~[ast::attribute]) {\n@@ -3576,15 +3576,15 @@ pub impl Parser {\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n \n-        fn cdir_path_opt(+default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n             match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n                 Some(d) => copy *d,\n                 None => default\n             }\n         }\n     }\n \n-    fn parse_item_foreign_fn(&self,  +attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_item_foreign_fn(&self,  attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n@@ -3601,7 +3601,7 @@ pub impl Parser {\n     }\n \n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n-                                +attrs: ~[attribute]) -> @foreign_item {\n+                                attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n         // XXX: Obsolete; remove after snap.\n@@ -3638,7 +3638,7 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_foreign_item(&self, +attrs: ~[attribute]) -> @foreign_item {\n+    fn parse_foreign_item(&self, attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n         if self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\") {\n             self.parse_item_foreign_const(vis, attrs)\n@@ -3648,8 +3648,8 @@ pub impl Parser {\n     }\n \n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n-                               +abis: AbiSet,\n-                               +first_item_attrs: ~[attribute])\n+                               abis: AbiSet,\n+                               first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n         let ParsedItemsAndViewItems {\n@@ -3987,7 +3987,7 @@ pub impl Parser {\n     // flags; on failure, return iovi_none.\n     fn parse_item_or_view_item(\n         &self,\n-        +attrs: ~[attribute],\n+        attrs: ~[attribute],\n         items_allowed: bool,\n         foreign_items_allowed: bool,\n         macros_allowed: bool\n@@ -4198,7 +4198,7 @@ pub impl Parser {\n         return iovi_none;\n     }\n \n-    fn parse_item(&self, +attrs: ~[attribute]) -> Option<@ast::item> {\n+    fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true, false, true) {\n             iovi_none =>\n                 None,\n@@ -4337,7 +4337,7 @@ pub impl Parser {\n     // parse a view item.\n     fn parse_view_item(\n         &self,\n-        +attrs: ~[attribute],\n+        attrs: ~[attribute],\n         vis: visibility\n     ) -> @view_item {\n         let lo = self.span.lo;\n@@ -4363,7 +4363,7 @@ pub impl Parser {\n     // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n     // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n     // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n-    fn parse_items_and_view_items(&self, +first_item_attrs: ~[attribute],\n+    fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n                                 -> ParsedItemsAndViewItems {"}, {"sha": "eff7524e194ae7a83b2910c7d7e6226b0b36e460", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -104,7 +104,7 @@ pub impl token {\n     }\n }\n \n-pub fn tok_str(++t: token) -> ~str {\n+pub fn tok_str(t: token) -> ~str {\n     match t {\n         STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n         BREAK(_) => return ~\"BREAK\",\n@@ -398,7 +398,7 @@ pub impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    fn advance_left(&mut self, ++x: token, L: int) {\n+    fn advance_left(&mut self, x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {"}, {"sha": "8cf7359956283666a5625fe3eea76c50ac346ef9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -134,7 +134,7 @@ pub fn print_crate(cm: @CodeMap,\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: @ps, &&crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, crate: @ast::crate) {\n     print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n@@ -164,7 +164,7 @@ pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n     to_str(tts, print_tts, intr)\n }\n \n-pub fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n+pub fn stmt_to_str(s: &ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n@@ -177,7 +177,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(&&p: @ast::Path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -312,7 +312,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -323,8 +323,8 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n-                         get_span: &fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n+                               get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n@@ -343,7 +343,7 @@ pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n }\n \n pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n+    fn expr_span(expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n@@ -371,7 +371,7 @@ pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n     }\n }\n \n-pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n+pub fn print_type(s: @ps, ty: @ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -465,7 +465,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: @ps, &&item: @ast::item) {\n+pub fn print_item(s: @ps, item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -760,7 +760,7 @@ pub fn print_tt(s: @ps, tt: ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.eachi |i, tt| {\n         if i != 0 {\n@@ -872,7 +872,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n }\n \n \n-pub fn print_stmt(s: @ps, st: ast::stmt) {\n+pub fn print_stmt(s: @ps, st: &ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::stmt_decl(decl, _) => {\n@@ -950,7 +950,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     for blk.node.view_items.each |vi| { print_view_item(s, *vi); }\n     for blk.node.stmts.each |st| {\n-        print_stmt(s, **st);\n+        print_stmt(s, *st);\n     }\n     match blk.node.expr {\n       Some(expr) => {\n@@ -1089,7 +1089,7 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n+pub fn print_expr(s: @ps, expr: @ast::expr) {\n     fn print_field(s: @ps, field: ast::field) {\n         ibox(s, indent_unit);\n         if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n@@ -1454,7 +1454,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             word_nbsp(s, ~\"mut\");\n         }\n \n-        fn print_local(s: @ps, &&loc: @ast::local) {\n+        fn print_local(s: @ps, loc: @ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1485,7 +1485,7 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: @ps, &&path: @ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, ~\"::\"); }\n     let mut first = true;\n@@ -1513,15 +1513,15 @@ pub fn print_path(s: @ps, &&path: @ast::Path, colons_before_params: bool) {\n     }\n }\n \n-pub fn print_irrefutable_pat(s: @ps, &&pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: @ps, &&pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1758,12 +1758,12 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     }\n }\n \n-pub fn print_lifetime(s: @ps, &&lifetime: &ast::Lifetime) {\n+pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n     word(s.s, ~\"'\");\n     print_ident(s, lifetime.ident);\n }\n \n-pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n+pub fn print_generics(s: @ps, generics: &ast::Generics) {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n         word(s.s, ~\"<\");\n@@ -1790,7 +1790,7 @@ pub fn print_generics(s: @ps, &&generics: &ast::Generics) {\n     }\n }\n \n-pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, *name),\n@@ -1814,7 +1814,7 @@ pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, &&vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, namespace, _) => {\n         if namespace == ast::module_ns {\n@@ -2006,7 +2006,7 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, &&lit: @ast::lit) {\n+pub fn print_literal(s: @ps, lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2137,7 +2137,7 @@ pub fn print_string(s: @ps, st: &str) {\n     word(s.s, ~\"\\\"\");\n }\n \n-pub fn to_str<T>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         f(s, t);"}, {"sha": "6e70bd22b4fa321eba4db3ab6528417003189c1e", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -17,11 +17,10 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n+#[deny(deprecated_mode)];\n+#[deny(deprecated_pattern)];\n \n #[no_core];\n "}, {"sha": "0aaa08f2e78f6883067cdced4941966c1f1d715b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7aea3a6a5fcf04066d0368bfd6618e9494176c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "patch": "@@ -101,7 +101,7 @@ pub struct Visitor<E> {\n \n pub type visitor<E> = @Visitor<E>;\n \n-pub fn default_visitor<E>() -> visitor<E> {\n+pub fn default_visitor<E: Copy>() -> visitor<E> {\n     return @Visitor {\n         visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n         visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n@@ -127,18 +127,18 @@ pub fn default_visitor<E>() -> visitor<E> {\n     };\n }\n \n-pub fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n+pub fn visit_crate<E: Copy>(c: &crate, e: E, v: vt<E>) {\n     (v.visit_mod)(&c.node.module, c.span, crate_node_id, e, v);\n }\n \n-pub fn visit_mod<E>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n     for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n \n pub fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n \n-pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n+pub fn visit_local<E: Copy>(loc: @local, e: E, v: vt<E>) {\n     (v.visit_pat)(loc.node.pat, e, v);\n     (v.visit_ty)(loc.node.ty, e, v);\n     match loc.node.init {\n@@ -147,11 +147,11 @@ pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_trait_ref<E>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n+fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, e: E, v: vt<E>) {\n     visit_path(tref.path, e, v);\n }\n \n-pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n+pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n         item_const(t, ex) => {\n             (v.visit_ty)(t, e, v);\n@@ -216,10 +216,10 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n-                         tps: &Generics,\n-                         e: E,\n-                         v: vt<E>) {\n+pub fn visit_enum_def<E: Copy>(enum_definition: ast::enum_def,\n+                               tps: &Generics,\n+                               e: E,\n+                               v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n@@ -237,7 +237,7 @@ pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n \n pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n-pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n+pub fn visit_ty<E: Copy>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n         ty_box(mt) | ty_uniq(mt) |\n         ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n@@ -265,11 +265,11 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_path<E>(p: @Path, e: E, v: vt<E>) {\n+pub fn visit_path<E: Copy>(p: @Path, e: E, v: vt<E>) {\n     for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n }\n \n-pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n+pub fn visit_pat<E: Copy>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n         pat_enum(path, ref children) => {\n             visit_path(path, e, v);\n@@ -315,7 +315,7 @@ pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n+pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n             visit_fn_decl(fd, e, v);\n@@ -327,8 +327,8 @@ pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n-                                e: E, v: vt<E>) {\n+pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n+                                      e: E, v: vt<E>) {\n     for bounds.each |bound| {\n         match *bound {\n             TraitTyParamBound(ty) => visit_trait_ref(ty, e, v),\n@@ -337,13 +337,13 @@ pub fn visit_ty_param_bounds<E>(bounds: @OptVec<TyParamBound>,\n     }\n }\n \n-pub fn visit_generics<E>(generics: &Generics, e: E, v: vt<E>) {\n+pub fn visit_generics<E: Copy>(generics: &Generics, e: E, v: vt<E>) {\n     for generics.ty_params.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n }\n \n-pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n         (v.visit_pat)(a.pat, e, v);\n         (v.visit_ty)(a.ty, e, v);\n@@ -355,7 +355,7 @@ pub fn visit_fn_decl<E>(fd: &fn_decl, e: E, v: vt<E>) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn visit_method_helper<E>(m: &method, e: E, v: vt<E>) {\n+pub fn visit_method_helper<E: Copy>(m: &method, e: E, v: vt<E>) {\n     (v.visit_fn)(\n         &fk_method(\n             /* FIXME (#2543) */ copy m.ident,\n@@ -390,28 +390,28 @@ pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, generics: &Generics,\n \n }\n \n-pub fn visit_fn<E>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n-                   _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n+                         _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     let generics = generics_of_fn(fk);\n     (v.visit_generics)(&generics, e, v);\n     (v.visit_block)(body, e, v);\n }\n \n-pub fn visit_ty_method<E>(m: &ty_method, e: E, v: vt<E>) {\n+pub fn visit_ty_method<E: Copy>(m: &ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n     (v.visit_generics)(&m.generics, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n-pub fn visit_trait_method<E>(m: &trait_method, e: E, v: vt<E>) {\n+pub fn visit_trait_method<E: Copy>(m: &trait_method, e: E, v: vt<E>) {\n     match *m {\n       required(ref ty_m) => (v.visit_ty_method)(ty_m, e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n-pub fn visit_struct_def<E>(\n+pub fn visit_struct_def<E: Copy>(\n     sd: @struct_def,\n     _nm: ast::ident,\n     generics: &Generics,\n@@ -433,15 +433,15 @@ pub fn visit_struct_def<E>(\n     }\n }\n \n-pub fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n+pub fn visit_struct_field<E: Copy>(sf: @struct_field, e: E, v: vt<E>) {\n     (v.visit_ty)(sf.node.ty, e, v);\n }\n \n-pub fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n+pub fn visit_struct_method<E: Copy>(m: @method, e: E, v: vt<E>) {\n     visit_method_helper(m, e, v);\n }\n \n-pub fn visit_block<E>(b: &blk, e: E, v: vt<E>) {\n+pub fn visit_block<E: Copy>(b: &blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n         (v.visit_view_item)(*vi, e, v);\n     }\n@@ -460,7 +460,7 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n+pub fn visit_decl<E: Copy>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n         decl_local(ref locs) => {\n             for locs.each |loc| {\n@@ -475,15 +475,15 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n-pub fn visit_exprs<E>(exprs: &[@expr], e: E, v: vt<E>) {\n+pub fn visit_exprs<E: Copy>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n     /* no user-serviceable parts inside */\n }\n \n-pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n+pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n         expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n         expr_vec(ref es, _) => visit_exprs(*es, e, v),\n@@ -588,7 +588,7 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     (v.visit_expr_post)(ex, e, v);\n }\n \n-pub fn visit_arm<E>(a: &arm, e: E, v: vt<E>) {\n+pub fn visit_arm<E: Copy>(a: &arm, e: E, v: vt<E>) {\n     for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     (v.visit_block)(&a.body, e, v);\n@@ -655,67 +655,67 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         m: &_mod,\n         sp: span,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(m, sp, id);\n         visit_mod(m, sp, id, e, v);\n     }\n-    fn v_view_item(f: @fn(@view_item), vi: @view_item, &&e: (), v: vt<()>) {\n+    fn v_view_item(f: @fn(@view_item), vi: @view_item, e: (), v: vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n-    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, &&e: (),\n+    fn v_foreign_item(f: @fn(@foreign_item), ni: @foreign_item, e: (),\n                       v: vt<()>) {\n         f(ni);\n         visit_foreign_item(ni, e, v);\n     }\n-    fn v_item(f: @fn(@item), i: @item, &&e: (), v: vt<()>) {\n+    fn v_item(f: @fn(@item), i: @item, e: (), v: vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: @fn(@local), l: @local, &&e: (), v: vt<()>) {\n+    fn v_local(f: @fn(@local), l: @local, e: (), v: vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, &&e: (), v: vt<()>) {\n+    fn v_block(f: @fn(&ast::blk), bl: &ast::blk, e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: @fn(@stmt), st: @stmt, &&e: (), v: vt<()>) {\n+    fn v_stmt(f: @fn(@stmt), st: @stmt, e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: @fn(&arm), a: &arm, &&e: (), v: vt<()>) {\n+    fn v_arm(f: @fn(&arm), a: &arm, e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: @fn(@pat), p: @pat, &&e: (), v: vt<()>) {\n+    fn v_pat(f: @fn(@pat), p: @pat, e: (), v: vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: @fn(@decl), d: @decl, &&e: (), v: vt<()>) {\n+    fn v_decl(f: @fn(@decl), d: @decl, e: (), v: vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: @fn(@expr), ex: @expr, &&e: (), v: vt<()>) {\n+    fn v_expr(f: @fn(@expr), ex: @expr, e: (), v: vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_expr_post(f: @fn(@expr), ex: @expr, &&_e: (), _v: vt<()>) {\n+    fn v_expr_post(f: @fn(@expr), ex: @expr, _e: (), _v: vt<()>) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, &&e: (), v: vt<()>) {\n+    fn v_ty(f: @fn(@Ty), ty: @Ty, e: (), v: vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, &&e: (), v: vt<()>) {\n+    fn v_ty_method(f: @fn(&ty_method), ty: &ty_method, e: (), v: vt<()>) {\n         f(ty);\n         visit_ty_method(ty, e, v);\n     }\n     fn v_trait_method(f: @fn(&trait_method),\n                       m: &trait_method,\n-                      &&e: (),\n+                      e: (),\n                       v: vt<()>) {\n         f(m);\n         visit_trait_method(m, e, v);\n@@ -726,7 +726,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         nm: ident,\n         generics: &Generics,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(sd, nm, generics, id);\n@@ -735,7 +735,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_generics(\n         f: @fn(&Generics),\n         ps: &Generics,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(ps);\n@@ -748,20 +748,20 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         body: &blk,\n         sp: span,\n         id: node_id,\n-        &&e: (),\n+        e: (),\n         v: vt<()>\n     ) {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, e, v);\n     }\n-    let visit_ty: @fn(@Ty, &&x: (), vt<()>) =\n+    let visit_ty: @fn(@Ty, x: (), vt<()>) =\n         |a,b,c| v_ty(v.visit_ty, a, b, c);\n-    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, &&e: (),\n+    fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, e: (),\n                       v: vt<()>) {\n         f(sf);\n         visit_struct_field(sf, e, v);\n     }\n-    fn v_struct_method(f: @fn(@method), m: @method, &&e: (), v: vt<()>) {\n+    fn v_struct_method(f: @fn(@method), m: @method, e: (), v: vt<()>) {\n         f(m);\n         visit_struct_method(m, e, v);\n     }"}]}