{"sha": "055651d1af6a305785c76ca6f0708e89d2c70042", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NTY1MWQxYWY2YTMwNTc4NWM3NmNhNmYwNzA4ZTg5ZDJjNzAwNDI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-09-14T20:38:53Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-09-14T20:42:50Z"}, "message": "Remove concept of 'completion' from the projection cache\n\nFixes #88910\n\nWhen we initially store a `NormalizedTy` in the projection cache,\nwe discard all obligations that we can (while ensuring that we\ndon't cause any issues with incremental compilation).\n\nMarking a projection cache entry as 'completed' discards all\nobligations associated with it. This can only cause problems,\nsince any obligations stored in the cache are there for a reason\n(e.g. they evaluate to `EvaluatedToOkModuloRegions`).\n\nThis commit removes `complete` and `complete_normalized` entirely.", "tree": {"sha": "8e41ea135c9b473927dc57bbd3c04a5e46543f49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e41ea135c9b473927dc57bbd3c04a5e46543f49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/055651d1af6a305785c76ca6f0708e89d2c70042", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmFBCUsACgkQtAh+UQ6Y\nsWQIHRAAkhOkQeqdK9BFJvqOL0hg3JqVDurjMLpKfnLMhTPZUasPYvpHCCKR3Egn\nuf6KJKGqIyitJ3ygdX8KaOSMGPdfl1WnFnoLR5HpC+j3y6Z8JFfGZqKzGITwMwyk\nXIXqHQvPkdOXfYXuLpysuTO8qPd4R5nXuOPTXAqnICs/89qzgIA/YDamrfq82eYY\nnDrkx9uVyYVWUG90vrlBtS5f4LoKh/6gjEZh6ORXK+f130OsWP24fIybzrPPgaTF\nvIKv7TUoAzqNUsXIaPttBPlJZbP2tkGitvLFOk/ytYCoTsAwExNvBQYYursAfZnc\nWTzvD2UoiCS0++RLD74tzOyyKRgXnbGyizd2VqJXJbrbt7reClpR8IZ8eGOjMTm9\n5wvnjB2X6FNWb59iap7GgyJEE5NEjQUViOby75WLZqirTRevGLDLoPI1279H0DPl\nfgHOS4DXfKMHBax47zTbspePwQUlweP2V55sUvat15DoA799cqdnm4JPkoJD6G9E\n8d5XRJs5vF/lSiChHAoVz6KtiyXl45AM/bFL1sqj2QWu565kh59O/tyoi4HOWjLr\nVjltO18hlU9vyk1nySj0CQok4JvgfXi64gLfYeD05IgEFMl0UNuAZgOyVnMgyAav\nHue8W0JXsf7A9yt/XbzO2O7d6Ic95y8m6n43+CpfbFcMaJ+x6Ok=\n=zDPw\n-----END PGP SIGNATURE-----", "payload": "tree 8e41ea135c9b473927dc57bbd3c04a5e46543f49\nparent ec9a1bdc4586eec99acbe34df3717b3fd1277b06\nauthor Aaron Hill <aa1ronham@gmail.com> 1631651933 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1631652170 -0500\n\nRemove concept of 'completion' from the projection cache\n\nFixes #88910\n\nWhen we initially store a `NormalizedTy` in the projection cache,\nwe discard all obligations that we can (while ensuring that we\ndon't cause any issues with incremental compilation).\n\nMarking a projection cache entry as 'completed' discards all\nobligations associated with it. This can only cause problems,\nsince any obligations stored in the cache are there for a reason\n(e.g. they evaluate to `EvaluatedToOkModuloRegions`).\n\nThis commit removes `complete` and `complete_normalized` entirely.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/055651d1af6a305785c76ca6f0708e89d2c70042", "html_url": "https://github.com/rust-lang/rust/commit/055651d1af6a305785c76ca6f0708e89d2c70042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/055651d1af6a305785c76ca6f0708e89d2c70042/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec9a1bdc4586eec99acbe34df3717b3fd1277b06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9a1bdc4586eec99acbe34df3717b3fd1277b06", "html_url": "https://github.com/rust-lang/rust/commit/ec9a1bdc4586eec99acbe34df3717b3fd1277b06"}], "stats": {"total": 53, "additions": 2, "deletions": 51}, "files": [{"sha": "e2c13d20a9a5b5a7c11d7a0ec4b22c5e1cef1c93", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/055651d1af6a305785c76ca6f0708e89d2c70042/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055651d1af6a305785c76ca6f0708e89d2c70042/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=055651d1af6a305785c76ca6f0708e89d2c70042", "patch": "@@ -153,47 +153,6 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n-    /// Mark the relevant projection cache key as having its derived obligations\n-    /// complete, so they won't have to be re-computed (this is OK to do in a\n-    /// snapshot - if the snapshot is rolled back, the obligations will be\n-    /// marked as incomplete again).\n-    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let mut map = self.map();\n-        let ty = match map.get(&key) {\n-            Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n-                debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n-                ty.value\n-            }\n-            ref value => {\n-                // Type inference could \"strand behind\" old cache entries. Leave\n-                // them alone for now.\n-                debug!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\", key, value);\n-                return;\n-            }\n-        };\n-\n-        map.insert(\n-            key,\n-            ProjectionCacheEntry::NormalizedTy(Normalized { value: ty, obligations: vec![] }),\n-        );\n-    }\n-\n-    /// A specialized version of `complete` for when the key's value is known\n-    /// to be a NormalizedTy.\n-    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n-        // We want to insert `ty` with no obligations. If the existing value\n-        // already has no obligations (as is common) we don't insert anything.\n-        if !ty.obligations.is_empty() {\n-            self.map().insert(\n-                key,\n-                ProjectionCacheEntry::NormalizedTy(Normalized {\n-                    value: ty.value,\n-                    obligations: vec![],\n-                }),\n-            );\n-        }\n-    }\n-\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "ccf1bc0a2c27266f15507a39a06e1190de8cdd43", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/055651d1af6a305785c76ca6f0708e89d2c70042/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055651d1af6a305785c76ca6f0708e89d2c70042/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=055651d1af6a305785c76ca6f0708e89d2c70042", "patch": "@@ -14,18 +14,17 @@ use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n use super::DerivedObligationCause;\n+use super::Normalized;\n use super::Obligation;\n use super::ObligationCauseCode;\n use super::Selection;\n use super::SelectionResult;\n use super::TraitQueryMode;\n-use super::{Normalized, ProjectionCacheKey};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{Overflow, SelectionError, Unimplemented};\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n-use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -574,14 +573,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n                             self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                            let result = self\n-                                .evaluate_predicates_recursively(previous_stack, subobligations);\n-                            if let Some(key) =\n-                                ProjectionCacheKey::from_poly_projection_predicate(self, data)\n-                            {\n-                                self.infcx.inner.borrow_mut().projection_cache().complete(key);\n-                            }\n-                            result\n+                            self.evaluate_predicates_recursively(previous_stack, subobligations)\n                         }\n                         Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n                         Ok(Err(project::InProgress)) => Ok(EvaluatedToRecur),"}]}