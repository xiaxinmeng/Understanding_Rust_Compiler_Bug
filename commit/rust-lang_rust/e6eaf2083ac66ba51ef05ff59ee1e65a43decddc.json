{"sha": "e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZWFmMjA4M2FjNjZiYTUxZWYwNWZmNTllZTFlNjVhNDNkZWNkZGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-01T00:41:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-01T00:41:33Z"}, "message": "interpret StorageLive & StorageDead, and check dead stack slots are not used", "tree": {"sha": "3a5b23547dee45276860cd13b23809f51ff7c38c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a5b23547dee45276860cd13b23809f51ff7c38c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "html_url": "https://github.com/rust-lang/rust/commit/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9463510837598256a067438ebb854e6fed4f707", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9463510837598256a067438ebb854e6fed4f707", "html_url": "https://github.com/rust-lang/rust/commit/b9463510837598256a067438ebb854e6fed4f707"}], "stats": {"total": 178, "additions": 128, "deletions": 50}, "files": [{"sha": "702c2c4940fac323fe253a56f1c5a821c0ac20ab", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "patch": "@@ -24,6 +24,7 @@ pub enum EvalError<'tcx> {\n     ReadPointerAsBytes,\n     InvalidPointerMath,\n     ReadUndefBytes,\n+    DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n     Unimplemented(String),\n     DerefFunctionPointer,\n@@ -83,6 +84,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"attempted to do math or a comparison on pointers into different allocations\",\n             EvalError::ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n+            EvalError::DeadLocal =>\n+                \"tried to access a dead local variable\",\n             EvalError::InvalidBoolOp(_) =>\n                 \"invalid boolean operation\",\n             EvalError::Unimplemented(ref msg) => msg,"}, {"sha": "c704ab230d58e4314a8b5ec05690713a9087ea87", "filename": "src/eval_context.rs", "status": "modified", "additions": 107, "deletions": 44, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n@@ -74,11 +74,12 @@ pub struct Frame<'tcx> {\n     pub return_lvalue: Lvalue<'tcx>,\n \n     /// The list of locals for this stack frame, stored in order as\n-    /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Value`s, which\n+    /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n+    /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n     ///\n-    /// Before being initialized, all locals are `Value::ByVal(PrimVal::Undef)`.\n-    pub locals: Vec<Value>,\n+    /// Before being initialized, arguments are `Value::ByVal(PrimVal::Undef)` and other locals are `None`.\n+    pub locals: Vec<Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -452,10 +453,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n+        /// Return the set of locals that have a stroage annotation anywhere\n+        fn collect_storage_annotations<'tcx>(mir: &'tcx mir::Mir<'tcx>) -> HashSet<mir::Local> {\n+            use rustc::mir::StatementKind::*;\n+\n+            let mut set = HashSet::new();\n+            for block in mir.basic_blocks() {\n+                for stmt in block.statements.iter() {\n+                    match stmt.kind {\n+                        StorageLive(mir::Lvalue::Local(local)) | StorageDead(mir::Lvalue::Local(local)) => {\n+                            set.insert(local);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            };\n+            set\n+        }\n+\n         // Subtract 1 because `local_decls` includes the ReturnPointer, but we don't store a local\n         // `Value` for that.\n+        let annotated_locals = collect_storage_annotations(mir);\n         let num_locals = mir.local_decls.len() - 1;\n-        let locals = vec![Value::ByVal(PrimVal::Undef); num_locals];\n+        let mut locals = Vec::with_capacity(num_locals);\n+        for i in 0..num_locals {\n+            let local = mir::Local::new(i+1);\n+            locals.push(if annotated_locals.contains(&local) { None } else { Some(Value::ByVal(PrimVal::Undef)) });\n+        }\n \n         self.stack.push(Frame {\n             mir,\n@@ -509,21 +533,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n-            if let Value::ByRef(ptr) = local {\n-                trace!(\"deallocating local\");\n-                self.memory.dump_alloc(ptr.alloc_id);\n-                match self.memory.deallocate(ptr) {\n-                    // We could alternatively check whether the alloc_id is static before calling\n-                    // deallocate, but this is much simpler and is probably the rare case.\n-                    Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n-                    other => return other,\n-                }\n-            }\n+            self.deallocate_local(local)?;\n         }\n \n         Ok(())\n     }\n \n+    pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n+        if let Some(Value::ByRef(ptr)) = local {\n+            trace!(\"deallocating local\");\n+            self.memory.dump_alloc(ptr.alloc_id);\n+            match self.memory.deallocate(ptr) {\n+                // We could alternatively check whether the alloc_id is static before calling\n+                // deallocate, but this is much simpler and is probably the rare case.\n+                Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n+                other => return other,\n+            }\n+        };\n+        Ok(())\n+    }\n+\n     pub fn assign_discr_and_fields<\n         V: IntoValTyPair<'tcx>,\n         J: IntoIterator<Item = V>,\n@@ -1047,16 +1076,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Local { frame, local, field } => {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n-                    Value::ByRef(ptr) => {\n+                    None => return Err(EvalError::DeadLocal),\n+                    Some(Value::ByRef(ptr)) => {\n                         assert!(field.is_none());\n                         Lvalue::from_ptr(ptr)\n                     },\n-                    val => {\n+                    Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Value::ByRef(ptr);\n+                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr)); // it stays live\n                         self.write_value_to_ptr(val, ptr, ty)?;\n                         let lval = Lvalue::from_ptr(ptr);\n                         if let Some((field, field_ty)) = field {\n@@ -1139,7 +1169,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     *this.globals.get_mut(&cid).expect(\"already checked\") = Global {\n                         value: val,\n                         ..dest\n-                    }\n+                    };\n+                    Ok(())\n                 };\n                 self.write_value_possibly_by_val(src_val, write_dest, dest.value, dest_ty)\n             },\n@@ -1150,7 +1181,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Lvalue::Local { frame, local, field } => {\n-                let dest = self.stack[frame].get_local(local, field.map(|(i, _)| i));\n+                let dest = self.stack[frame].get_local(local, field.map(|(i, _)| i))?;\n                 self.write_value_possibly_by_val(\n                     src_val,\n                     |this, val| this.stack[frame].set_local(local, field.map(|(i, _)| i), val),\n@@ -1162,7 +1193,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     // The cases here can be a bit subtle. Read carefully!\n-    fn write_value_possibly_by_val<F: FnOnce(&mut Self, Value)>(\n+    fn write_value_possibly_by_val<F: FnOnce(&mut Self, Value) -> EvalResult<'tcx>>(\n         &mut self,\n         src_val: Value,\n         write_dest: F,\n@@ -1192,17 +1223,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n             if let Ok(Some(src_val)) = self.try_read_value(src_ptr, dest_ty) {\n-                write_dest(self, src_val);\n+                write_dest(self, src_val)?;\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?;\n                 self.copy(src_ptr, dest_ptr, dest_ty)?;\n-                write_dest(self, Value::ByRef(dest_ptr));\n+                write_dest(self, Value::ByRef(dest_ptr))?;\n             }\n \n         } else {\n             // Finally, we have the simple case where neither source nor destination are\n             // `ByRef`. We may simply copy the source value over the the destintion.\n-            write_dest(self, src_val);\n+            write_dest(self, src_val)?;\n         }\n         Ok(())\n     }\n@@ -1572,14 +1603,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             write!(msg, \":\").unwrap();\n \n             match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n-                Value::ByRef(ptr) => {\n+                Err(EvalError::DeadLocal) => {\n+                    write!(msg, \" is dead\").unwrap();\n+                }\n+                Err(err) => {\n+                    panic!(\"Failed to access local: {:?}\", err);\n+                }\n+                Ok(Value::ByRef(ptr)) => {\n                     allocs.push(ptr.alloc_id);\n                 }\n-                Value::ByVal(val) => {\n+                Ok(Value::ByVal(val)) => {\n                     write!(msg, \" {:?}\", val).unwrap();\n                     if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }\n                 }\n-                Value::ByValPair(val1, val2) => {\n+                Ok(Value::ByValPair(val1, val2)) => {\n                     write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                     if let PrimVal::Ptr(ptr) = val1 { allocs.push(ptr.alloc_id); }\n                     if let PrimVal::Ptr(ptr) = val2 { allocs.push(ptr.alloc_id); }\n@@ -1614,9 +1651,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack[frame].get_local(local, field);\n+        let val = self.stack[frame].get_local(local, field)?;\n         let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, field, new_val);\n+        self.stack[frame].set_local(local, field, new_val)?;\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n         // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n         //     self.memory.deallocate(ptr)?;\n@@ -1626,53 +1663,79 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl<'tcx> Frame<'tcx> {\n-    pub fn get_local(&self, local: mir::Local, field: Option<usize>) -> Value {\n+    pub fn get_local(&self, local: mir::Local, field: Option<usize>) -> EvalResult<'tcx, Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         if let Some(field) = field {\n-            match self.locals[local.index() - 1] {\n-                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n-                val @ Value::ByVal(_) => {\n+            Ok(match self.locals[local.index() - 1] {\n+                None => return Err(EvalError::DeadLocal),\n+                Some(Value::ByRef(_)) => bug!(\"can't have lvalue fields for ByRef\"),\n+                Some(val @ Value::ByVal(_)) => {\n                     assert_eq!(field, 0);\n                     val\n                 },\n-                Value::ByValPair(a, b) => {\n+                Some(Value::ByValPair(a, b)) => {\n                     match field {\n                         0 => Value::ByVal(a),\n                         1 => Value::ByVal(b),\n                         _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n                     }\n                 },\n-            }\n+            })\n         } else {\n-            self.locals[local.index() - 1]\n+            self.locals[local.index() - 1].ok_or(EvalError::DeadLocal)\n         }\n     }\n \n-    fn set_local(&mut self, local: mir::Local, field: Option<usize>, value: Value) {\n+    fn set_local(&mut self, local: mir::Local, field: Option<usize>, value: Value) -> EvalResult<'tcx> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         if let Some(field) = field {\n             match self.locals[local.index() - 1] {\n-                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n-                Value::ByVal(_) => {\n+                None => return Err(EvalError::DeadLocal),\n+                Some(Value::ByRef(_)) => bug!(\"can't have lvalue fields for ByRef\"),\n+                Some(Value::ByVal(_)) => {\n                     assert_eq!(field, 0);\n-                    self.set_local(local, None, value);\n+                    self.set_local(local, None, value)?;\n                 },\n-                Value::ByValPair(a, b) => {\n+                Some(Value::ByValPair(a, b)) => {\n                     let prim = match value {\n                         Value::ByRef(_) => bug!(\"can't set ValPair field to ByRef\"),\n                         Value::ByVal(val) => val,\n                         Value::ByValPair(_, _) => bug!(\"can't set ValPair field to ValPair\"),\n                     };\n                     match field {\n-                        0 => self.set_local(local, None, Value::ByValPair(prim, b)),\n-                        1 => self.set_local(local, None, Value::ByValPair(a, prim)),\n+                        0 => self.set_local(local, None, Value::ByValPair(prim, b))?,\n+                        1 => self.set_local(local, None, Value::ByValPair(a, prim))?,\n                         _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n                     }\n                 },\n             }\n         } else {\n-            self.locals[local.index() - 1] = value;\n+            match self.locals[local.index() - 1] {\n+                None => return Err(EvalError::DeadLocal),\n+                Some(ref mut local) => { *local = value; }\n+            }\n+        }\n+        return Ok(());\n+    }\n+\n+    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx> {\n+        trace!(\"{:?} is now live\", local);\n+        if self.locals[local.index() - 1].is_some() {\n+            // The variables comes live now, but was already accessed previously, when it was still dead\n+            return Err(EvalError::DeadLocal);\n+        } else {\n+            self.locals[local.index() - 1] = Some(Value::ByVal(PrimVal::Undef));\n         }\n+        return Ok(());\n+    }\n+\n+    /// Returns the old value of the local\n+    pub fn storage_dead(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {\n+        trace!(\"{:?} is now dead\", local);\n+\n+        let old = self.locals[local.index() - 1];\n+        self.locals[local.index() - 1] = None;\n+        return Ok(old);\n     }\n }\n "}, {"sha": "a09f72134e9d8db3e8b2f03a71c33568271b2c30", "filename": "src/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(Value::ByRef(ptr))\n             }\n             Lvalue::Local { frame, local, field } => {\n-                Ok(self.stack[frame].get_local(local, field.map(|(i, _)| i)))\n+                Ok(self.stack[frame].get_local(local, field.map(|(i, _)| i))?)\n             }\n             Lvalue::Global(cid) => {\n                 Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let (base_ptr, base_extra) = match base {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-            Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n+            Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i))? {\n                 Value::ByRef(ptr) => {\n                     assert!(field.is_none(), \"local can't be ByRef and have a field offset\");\n                     (ptr, LvalueExtra::None)"}, {"sha": "1df55a8b620d549c86c5b6a82ba9028b9762171e", "filename": "src/step.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6eaf2083ac66ba51ef05ff59ee1e65a43decddc/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=e6eaf2083ac66ba51ef05ff59ee1e65a43decddc", "patch": "@@ -126,9 +126,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n-            // Miri can safely ignore these. Only translation needs it.\n-            StorageLive(_) |\n-            StorageDead(_) => {}\n+            // Mark locals as dead or alive.\n+            StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n+                let (frame, local) = match self.eval_lvalue(lvalue)? {\n+                    Lvalue::Local{ frame, local, field: None } if self.stack.len() == frame+1 => (frame, local),\n+                    _ => return Err(EvalError::Unimplemented(\"Stroage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n+                };\n+                match stmt.kind {\n+                    StorageLive(_) => self.stack[frame].storage_live(local)?,\n+                    _ =>  {\n+                        let old_val = self.stack[frame].storage_dead(local)?;\n+                        self.deallocate_local(old_val)?;\n+                    }\n+                };\n+            }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly.\n@@ -240,7 +251,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               constant.span,\n                                               mir,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::MarkStatic(false))\n+                                              StackPopCleanup::MarkStatic(false),\n+                    )\n                 });\n             }\n         }"}]}