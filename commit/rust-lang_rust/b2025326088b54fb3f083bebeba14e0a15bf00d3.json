{"sha": "b2025326088b54fb3f083bebeba14e0a15bf00d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMDI1MzI2MDg4YjU0ZmIzZjA4M2JlYmViYTE0ZTBhMTViZjAwZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-01T16:52:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-01T16:52:28Z"}, "message": "Auto merge of #75534 - Aaron1011:feature/new-future-breakage, r=pnkfelix\n\nImplement rustc side of report-future-incompat\n\ncc https://github.com/rust-lang/rust/issues/71249\n\nThis is an alternative to `@pnkfelix's` initial implementation in https://github.com/pnkfelix/rust/commits/prototype-rustc-side-of-report-future-incompat (mainly because I started working before seeing that branch :smile: ).\n\nMy approach outputs the entire original `Diagnostic`, in a way that is compatible with incremental compilation. This is not yet integrated with compiletest, but can be used manually by passing `-Z emit-future-incompat-report` to `rustc`.\n\nSeveral changes are made to support this feature:\n* The `librustc_session/lint` module is moved to a new crate `librustc_lint_defs` (name bikesheddable). This allows accessing lint definitions from `librustc_errors`.\n* The `Lint` struct is extended with an `Option<FutureBreakage>`. When present, it indicates that we should display a lint in the future-compat report. `FutureBreakage` contains additional information that we may want to display in the report (currently, a `date` field indicating when the crate will stop compiling).\n* A new variant `rustc_error::Level::Allow` is added. This is used when constructing a diagnostic for a future-breakage lint that is marked as allowed (via `#[allow]` or `--cap-lints`). This allows us to capture any future-breakage diagnostics in one place, while still discarding them before they are passed to the `Emitter`.\n* `DiagnosticId::Lint` is extended with a `has_future_breakage` field, indicating whether or not the `Lint` has future breakage information (and should therefore show up in the report).\n* `Session` is given access to the `LintStore` via a new `SessionLintStore` trait (since `librustc_session` cannot directly reference `LintStore` without a cyclic dependency). We use this to turn a string `DiagnosticId::Lint` back into a `Lint`, to retrieve the `FutureBreakage` data.\n\nCurrently, `FutureBreakage.date` is always set to `None`. However, this could potentially be interpreted by Cargo in the future.\n\nI've enabled the future-breakage report for the `ARRAY_INTO_ITER` lint, which can be used to test out this PR. The intent is to use the field to allow Cargo to determine the date of future breakage (as described in [RFC 2834](https://github.com/rust-lang/rfcs/blob/master/text/2834-cargo-report-future-incompat.md)) without needing to parse the diagnostic itself.\n\ncc `@pnkfelix`", "tree": {"sha": "5e95cc5b1e03cc071cb2ffeb90e37c7caf915ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e95cc5b1e03cc071cb2ffeb90e37c7caf915ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2025326088b54fb3f083bebeba14e0a15bf00d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2025326088b54fb3f083bebeba14e0a15bf00d3", "html_url": "https://github.com/rust-lang/rust/commit/b2025326088b54fb3f083bebeba14e0a15bf00d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2025326088b54fb3f083bebeba14e0a15bf00d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1899c489d4c30b2640d30b77ac04f0a548834d81", "url": "https://api.github.com/repos/rust-lang/rust/commits/1899c489d4c30b2640d30b77ac04f0a548834d81", "html_url": "https://github.com/rust-lang/rust/commit/1899c489d4c30b2640d30b77ac04f0a548834d81"}, {"sha": "6db00a213a6c8815aed7ae2d4e71d8a1b5b6338e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db00a213a6c8815aed7ae2d4e71d8a1b5b6338e", "html_url": "https://github.com/rust-lang/rust/commit/6db00a213a6c8815aed7ae2d4e71d8a1b5b6338e"}], "stats": {"total": 662, "additions": 539, "deletions": 123}, "files": [{"sha": "a8e4490aa1a455eeb3e972a25623f07efdb3ac4f", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -3638,6 +3638,7 @@ dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"rustc_data_structures\",\n+ \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n@@ -3830,6 +3831,18 @@ dependencies = [\n  \"unicode-security\",\n ]\n \n+[[package]]\n+name = \"rustc_lint_defs\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_macros\",\n+ \"rustc_serialize\",\n+ \"rustc_span\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_llvm\"\n version = \"0.0.0\"\n@@ -4112,6 +4125,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n+ \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\","}, {"sha": "6afed355dc33849f59c1bf244021029f2f0e06e9", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -308,8 +308,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             E0726,\n                             \"implicit elided lifetime not allowed here\"\n                         );\n-                        rustc_session::lint::add_elided_lifetime_in_path_suggestion(\n-                            &self.sess,\n+                        rustc_errors::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess.source_map(),\n                             &mut err,\n                             expected_lifetimes,\n                             path_span,"}, {"sha": "5d8ff601e799398a29000dcd4ac3e119bb98ef19", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -13,6 +13,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\""}, {"sha": "6f365c07f6d30a51196eda7165afc34ea5a9ea25", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -72,6 +72,7 @@ fn annotation_type_for_level(level: Level) -> AnnotationType {\n         Level::Help => AnnotationType::Help,\n         // FIXME(#59346): Not sure how to map these two levels\n         Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n+        Level::Allow => panic!(\"Should not call with Allow\"),\n     }\n }\n \n@@ -143,7 +144,8 @@ impl AnnotateSnippetEmitterWriter {\n                 title: Some(Annotation {\n                     label: Some(&message),\n                     id: code.as_ref().map(|c| match c {\n-                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val.as_str(),\n+                        DiagnosticId::Error(val)\n+                        | DiagnosticId::Lint { name: val, has_future_breakage: _ } => val.as_str(),\n                     }),\n                     annotation_type: annotation_type_for_level(*level),\n                 }),"}, {"sha": "decbf03b9de85e607cc1ad5a358aae09843d339e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -1,10 +1,10 @@\n use crate::snippet::Style;\n-use crate::Applicability;\n use crate::CodeSuggestion;\n use crate::Level;\n use crate::Substitution;\n use crate::SubstitutionPart;\n use crate::SuggestionStyle;\n+use rustc_lint_defs::Applicability;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n@@ -27,7 +27,7 @@ pub struct Diagnostic {\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticId {\n     Error(String),\n-    Lint(String),\n+    Lint { name: String, has_future_breakage: bool },\n }\n \n /// For example a note attached to an error.\n@@ -107,7 +107,14 @@ impl Diagnostic {\n         match self.level {\n             Level::Bug | Level::Fatal | Level::Error | Level::FailureNote => true,\n \n-            Level::Warning | Level::Note | Level::Help | Level::Cancelled => false,\n+            Level::Warning | Level::Note | Level::Help | Level::Cancelled | Level::Allow => false,\n+        }\n+    }\n+\n+    pub fn has_future_breakage(&self) -> bool {\n+        match self.code {\n+            Some(DiagnosticId::Lint { has_future_breakage, .. }) => has_future_breakage,\n+            _ => false,\n         }\n     }\n "}, {"sha": "56acdf699ef450ba08c3cf5d5473f7a0ad4a70ac", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -1,5 +1,6 @@\n-use crate::{Applicability, Handler, Level, StashKey};\n use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString};\n+use crate::{Handler, Level, StashKey};\n+use rustc_lint_defs::Applicability;\n \n use rustc_span::{MultiSpan, Span};\n use std::fmt::{self, Debug};"}, {"sha": "2dc7b7e2da3833f333d2ba956387b36c1a9e20c4", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -9,14 +9,15 @@\n \n use Destination::*;\n \n+use rustc_lint_defs::FutureBreakage;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{MultiSpan, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n-use crate::{\n-    pluralize, CodeSuggestion, Diagnostic, DiagnosticId, Level, SubDiagnostic, SuggestionStyle,\n-};\n+use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Level, SubDiagnostic, SuggestionStyle};\n+\n+use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -192,6 +193,8 @@ pub trait Emitter {\n     /// other formats can, and will, simply ignore it.\n     fn emit_artifact_notification(&mut self, _path: &Path, _artifact_type: &str) {}\n \n+    fn emit_future_breakage_report(&mut self, _diags: Vec<(FutureBreakage, Diagnostic)>) {}\n+\n     /// Checks if should show explanations about \"rustc --explain\"\n     fn should_show_explain(&self) -> bool {\n         true"}, {"sha": "d57beb1148a25849a1199bedae019d090c1cf9a5", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -13,8 +13,9 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n-use crate::{Applicability, DiagnosticId};\n+use crate::DiagnosticId;\n use crate::{CodeSuggestion, SubDiagnostic};\n+use rustc_lint_defs::{Applicability, FutureBreakage};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_span::hygiene::ExpnData;\n@@ -131,6 +132,31 @@ impl Emitter for JsonEmitter {\n         }\n     }\n \n+    fn emit_future_breakage_report(&mut self, diags: Vec<(FutureBreakage, crate::Diagnostic)>) {\n+        let data: Vec<FutureBreakageItem> = diags\n+            .into_iter()\n+            .map(|(breakage, mut diag)| {\n+                if diag.level == crate::Level::Allow {\n+                    diag.level = crate::Level::Warning;\n+                }\n+                FutureBreakageItem {\n+                    future_breakage_date: breakage.date,\n+                    diagnostic: Diagnostic::from_errors_diagnostic(&diag, self),\n+                }\n+            })\n+            .collect();\n+        let report = FutureIncompatReport { future_incompat_report: data };\n+        let result = if self.pretty {\n+            writeln!(&mut self.dst, \"{}\", as_pretty_json(&report))\n+        } else {\n+            writeln!(&mut self.dst, \"{}\", as_json(&report))\n+        }\n+        .and_then(|_| self.dst.flush());\n+        if let Err(e) = result {\n+            panic!(\"failed to print future breakage report: {:?}\", e);\n+        }\n+    }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         Some(&self.sm)\n     }\n@@ -223,6 +249,17 @@ struct ArtifactNotification<'a> {\n     emit: &'a str,\n }\n \n+#[derive(Encodable)]\n+struct FutureBreakageItem {\n+    future_breakage_date: Option<&'static str>,\n+    diagnostic: Diagnostic,\n+}\n+\n+#[derive(Encodable)]\n+struct FutureIncompatReport {\n+    future_incompat_report: Vec<FutureBreakageItem>,\n+}\n+\n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let sugg = diag.suggestions.iter().map(|sugg| Diagnostic {\n@@ -432,7 +469,7 @@ impl DiagnosticCode {\n         s.map(|s| {\n             let s = match s {\n                 DiagnosticId::Error(s) => s,\n-                DiagnosticId::Lint(s) => s,\n+                DiagnosticId::Lint { name, has_future_breakage: _ } => name,\n             };\n             let je_result =\n                 je.registry.as_ref().map(|registry| registry.try_find_description(&s)).unwrap();"}, {"sha": "593e0d92031ffca0f4a1d768c481577da0d7e135", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 82, "deletions": 29, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -21,6 +21,8 @@ use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n+use rustc_lint_defs::FutureBreakage;\n+pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Loc, MultiSpan, Span};\n \n@@ -49,30 +51,6 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n-/// Indicates the confidence in the correctness of a suggestion.\n-///\n-/// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n-/// to determine whether it should be automatically applied or if the user should be consulted\n-/// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n-pub enum Applicability {\n-    /// The suggestion is definitely what the user intended. This suggestion should be\n-    /// automatically applied.\n-    MachineApplicable,\n-\n-    /// The suggestion may be what the user intended, but it is uncertain. The suggestion should\n-    /// result in valid Rust code if it is applied.\n-    MaybeIncorrect,\n-\n-    /// The suggestion contains placeholders like `(...)` or `{ /* fields */ }`. The suggestion\n-    /// cannot be applied automatically because it will not result in valid Rust code. The user\n-    /// will need to fill in the placeholders.\n-    HasPlaceholders,\n-\n-    /// The applicability of the suggestion is unknown.\n-    Unspecified,\n-}\n-\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {\n     /// Hide the suggested code when displaying this suggestion inline.\n@@ -321,6 +299,8 @@ struct HandlerInner {\n \n     /// The warning count, used for a recap upon finishing\n     deduplicated_warn_count: usize,\n+\n+    future_breakage_diagnostics: Vec<Diagnostic>,\n }\n \n /// A key denoting where from a diagnostic was stashed.\n@@ -434,6 +414,7 @@ impl Handler {\n                 emitted_diagnostic_codes: Default::default(),\n                 emitted_diagnostics: Default::default(),\n                 stashed_diagnostics: Default::default(),\n+                future_breakage_diagnostics: Vec::new(),\n             }),\n         }\n     }\n@@ -503,6 +484,17 @@ impl Handler {\n         result\n     }\n \n+    /// Construct a builder at the `Allow` level at the given `span` and with the `msg`.\n+    pub fn struct_span_allow(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_allow(msg);\n+        result.set_span(span);\n+        result\n+    }\n+\n     /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n     /// Also include a code.\n     pub fn struct_span_warn_with_code(\n@@ -525,6 +517,11 @@ impl Handler {\n         result\n     }\n \n+    /// Construct a builder at the `Allow` level with the `msg`.\n+    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+        DiagnosticBuilder::new(self, Level::Allow, msg)\n+    }\n+\n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n     pub fn struct_span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut result = self.struct_err(msg);\n@@ -693,6 +690,10 @@ impl Handler {\n         self.inner.borrow_mut().print_error_count(registry)\n     }\n \n+    pub fn take_future_breakage_diagnostics(&self) -> Vec<Diagnostic> {\n+        std::mem::take(&mut self.inner.borrow_mut().future_breakage_diagnostics)\n+    }\n+\n     pub fn abort_if_errors(&self) {\n         self.inner.borrow_mut().abort_if_errors()\n     }\n@@ -723,6 +724,10 @@ impl Handler {\n         self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n     }\n \n+    pub fn emit_future_breakage_report(&self, diags: Vec<(FutureBreakage, Diagnostic)>) {\n+        self.inner.borrow_mut().emitter.emit_future_breakage_report(diags)\n+    }\n+\n     pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n         self.inner.borrow_mut().delay_as_bug(diagnostic)\n     }\n@@ -748,12 +753,23 @@ impl HandlerInner {\n             return;\n         }\n \n+        if diagnostic.has_future_breakage() {\n+            self.future_breakage_diagnostics.push(diagnostic.clone());\n+        }\n+\n         if diagnostic.level == Warning && !self.flags.can_emit_warnings {\n+            if diagnostic.has_future_breakage() {\n+                (*TRACK_DIAGNOSTICS)(diagnostic);\n+            }\n             return;\n         }\n \n         (*TRACK_DIAGNOSTICS)(diagnostic);\n \n+        if diagnostic.level == Allow {\n+            return;\n+        }\n+\n         if let Some(ref code) = diagnostic.code {\n             self.emitted_diagnostic_codes.insert(code.clone());\n         }\n@@ -992,6 +1008,7 @@ pub enum Level {\n     Help,\n     Cancelled,\n     FailureNote,\n+    Allow,\n }\n \n impl fmt::Display for Level {\n@@ -1017,7 +1034,7 @@ impl Level {\n                 spec.set_fg(Some(Color::Cyan)).set_intense(true);\n             }\n             FailureNote => {}\n-            Cancelled => unreachable!(),\n+            Allow | Cancelled => unreachable!(),\n         }\n         spec\n     }\n@@ -1031,6 +1048,7 @@ impl Level {\n             Help => \"help\",\n             FailureNote => \"failure-note\",\n             Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n+            Allow => panic!(\"Shouldn't call on allowed error\"),\n         }\n     }\n \n@@ -1039,11 +1057,46 @@ impl Level {\n     }\n }\n \n-#[macro_export]\n-macro_rules! pluralize {\n-    ($x:expr) => {\n-        if $x != 1 { \"s\" } else { \"\" }\n+pub fn add_elided_lifetime_in_path_suggestion(\n+    source_map: &SourceMap,\n+    db: &mut DiagnosticBuilder<'_>,\n+    n: usize,\n+    path_span: Span,\n+    incl_angl_brckt: bool,\n+    insertion_span: Span,\n+    anon_lts: String,\n+) {\n+    let (replace_span, suggestion) = if incl_angl_brckt {\n+        (insertion_span, anon_lts)\n+    } else {\n+        // When possible, prefer a suggestion that replaces the whole\n+        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n+        // at a point (which makes for an ugly/confusing label)\n+        if let Ok(snippet) = source_map.span_to_snippet(path_span) {\n+            // But our spans can get out of whack due to macros; if the place we think\n+            // we want to insert `'_` isn't even within the path expression's span, we\n+            // should bail out of making any suggestion rather than panicking on a\n+            // subtract-with-overflow or string-slice-out-out-bounds (!)\n+            // FIXME: can we do better?\n+            if insertion_span.lo().0 < path_span.lo().0 {\n+                return;\n+            }\n+            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n+            if insertion_index > snippet.len() {\n+                return;\n+            }\n+            let (before, after) = snippet.split_at(insertion_index);\n+            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n+        } else {\n+            (insertion_span, anon_lts)\n+        }\n     };\n+    db.span_suggestion(\n+        replace_span,\n+        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n+        suggestion,\n+        Applicability::MachineApplicable,\n+    );\n }\n \n // Useful type to use with `Result<>` indicate that an error has already"}, {"sha": "072194e332a5b763252320c70e2968a8b7706595", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -286,7 +286,10 @@ pub fn register_plugins<'a>(\n         }\n     });\n \n-    Ok((krate, Lrc::new(lint_store)))\n+    let lint_store = Lrc::new(lint_store);\n+    sess.init_lint_store(lint_store.clone());\n+\n+    Ok((krate, lint_store))\n }\n \n fn pre_expansion_lint(sess: &Session, lint_store: &LintStore, krate: &ast::Crate) {"}, {"sha": "9332554eede3391120afc1dbe68a679745696a8b", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -477,6 +477,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(dump_mir_dir, String::from(\"abc\"));\n     untracked!(dump_mir_exclude_pass_number, true);\n     untracked!(dump_mir_graphviz, true);\n+    untracked!(emit_future_incompat_report, true);\n     untracked!(emit_stack_sizes, true);\n     untracked!(hir_stats, true);\n     untracked!(identify_regions, true);"}, {"sha": "0b5bd39f7f984c25e37dc5bc20c0667d9ab0cae1", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n-use rustc_session::lint::FutureIncompatibleInfo;\n+use rustc_session::lint::FutureBreakage;\n use rustc_span::symbol::sym;\n \n declare_lint! {\n@@ -38,6 +38,9 @@ declare_lint! {\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #66145 <https://github.com/rust-lang/rust/issues/66145>\",\n         edition: None,\n+        future_breakage: Some(FutureBreakage {\n+            date: None\n+        })\n     };\n }\n "}, {"sha": "c65cf65b1c7774c9c398e16f5553d25499bbf958", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -44,7 +44,6 @@ use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, layout::LayoutError, Ty, TyCtxt};\n-use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;"}, {"sha": "4cfeb0d968b95f1ad29eb67218d9677b8e1960a3", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -22,7 +22,7 @@ use rustc_ast as ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{add_elided_lifetime_in_path_suggestion, struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n@@ -33,9 +33,10 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n-use rustc_session::lint::{add_elided_lifetime_in_path_suggestion, BuiltinLintDiagnostics};\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n+use rustc_session::SessionLintStore;\n use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n use rustc_target::abi::LayoutOf;\n \n@@ -69,6 +70,20 @@ pub struct LintStore {\n     lint_groups: FxHashMap<&'static str, LintGroup>,\n }\n \n+impl SessionLintStore for LintStore {\n+    fn name_to_lint(&self, lint_name: &str) -> LintId {\n+        let lints = self\n+            .find_lints(lint_name)\n+            .unwrap_or_else(|_| panic!(\"Failed to find lint with name `{}`\", lint_name));\n+\n+        if let &[lint] = lints.as_slice() {\n+            return lint;\n+        } else {\n+            panic!(\"Found mutliple lints with name `{}`: {:?}\", lint_name, lints);\n+        }\n+    }\n+}\n+\n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n enum TargetLint {\n     /// A direct lint target\n@@ -543,7 +558,7 @@ pub trait LintContext: Sized {\n                     anon_lts,\n                 ) => {\n                     add_elided_lifetime_in_path_suggestion(\n-                        sess,\n+                        sess.source_map(),\n                         &mut db,\n                         n,\n                         path_span,"}, {"sha": "7f908088cf5b02c8573cb78d3dc62e63cdc99f98", "filename": "compiler/rustc_lint_defs/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2FCargo.toml?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_lint_defs\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+log = { package = \"tracing\", version = \"0.1\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "048f096aabe13ad129b24a92a842c0c56a700c3c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -4,7 +4,6 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n-use crate::lint::FutureIncompatibleInfo;\n use crate::{declare_lint, declare_lint_pass, declare_tool_lint};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::sym;", "previous_filename": "compiler/rustc_session/src/lint/builtin.rs"}, {"sha": "25a7bfcabb7283eb96ccf7ac5a74a33ae8335dd2", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "renamed", "additions": 64, "deletions": 55, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -1,12 +1,45 @@\n+#[macro_use]\n+extern crate rustc_macros;\n+\n pub use self::Level::*;\n use rustc_ast::node_id::{NodeId, NodeMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n-use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n use rustc_span::edition::Edition;\n use rustc_span::{sym, symbol::Ident, MultiSpan, Span, Symbol};\n \n pub mod builtin;\n \n+#[macro_export]\n+macro_rules! pluralize {\n+    ($x:expr) => {\n+        if $x != 1 { \"s\" } else { \"\" }\n+    };\n+}\n+\n+/// Indicates the confidence in the correctness of a suggestion.\n+///\n+/// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n+/// to determine whether it should be automatically applied or if the user should be consulted\n+/// before applying the suggestion.\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n+pub enum Applicability {\n+    /// The suggestion is definitely what the user intended. This suggestion should be\n+    /// automatically applied.\n+    MachineApplicable,\n+\n+    /// The suggestion may be what the user intended, but it is uncertain. The suggestion should\n+    /// result in valid Rust code if it is applied.\n+    MaybeIncorrect,\n+\n+    /// The suggestion contains placeholders like `(...)` or `{ /* fields */ }`. The suggestion\n+    /// cannot be applied automatically because it will not result in valid Rust code. The user\n+    /// will need to fill in the placeholders.\n+    HasPlaceholders,\n+\n+    /// The applicability of the suggestion is unknown.\n+    Unspecified,\n+}\n+\n /// Setting for how to handle a lint.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n pub enum Level {\n@@ -106,6 +139,21 @@ pub struct FutureIncompatibleInfo {\n     /// If this is an edition fixing lint, the edition in which\n     /// this lint becomes obsolete\n     pub edition: Option<Edition>,\n+    /// Information about a future breakage, which will\n+    /// be emitted in JSON messages to be displayed by Cargo\n+    /// for upstream deps\n+    pub future_breakage: Option<FutureBreakage>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct FutureBreakage {\n+    pub date: Option<&'static str>,\n+}\n+\n+impl FutureIncompatibleInfo {\n+    pub const fn default_fields_for_macro() -> Self {\n+        FutureIncompatibleInfo { reference: \"\", edition: None, future_breakage: None }\n+    }\n }\n \n impl Lint {\n@@ -331,31 +379,34 @@ macro_rules! declare_lint {\n         );\n     );\n     ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,\n-     $(@future_incompatible = $fi:expr;)?\n      $(@feature_gate = $gate:expr;)?\n+     $(@future_incompatible = FutureIncompatibleInfo { $($field:ident : $val:expr),* $(,)*  }; )?\n      $($v:ident),*) => (\n         $(#[$attr])*\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+        $vis static $NAME: &$crate::Lint = &$crate::Lint {\n             name: stringify!($NAME),\n-            default_level: $crate::lint::$Level,\n+            default_level: $crate::$Level,\n             desc: $desc,\n             edition_lint_opts: None,\n             is_plugin: false,\n             $($v: true,)*\n-            $(future_incompatible: Some($fi),)*\n             $(feature_gate: Some($gate),)*\n-            ..$crate::lint::Lint::default_fields_for_macro()\n+            $(future_incompatible: Some($crate::FutureIncompatibleInfo {\n+                $($field: $val,)*\n+                ..$crate::FutureIncompatibleInfo::default_fields_for_macro()\n+            }),)*\n+            ..$crate::Lint::default_fields_for_macro()\n         };\n     );\n     ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,\n      $lint_edition: expr => $edition_level: ident\n     ) => (\n         $(#[$attr])*\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+        $vis static $NAME: &$crate::Lint = &$crate::Lint {\n             name: stringify!($NAME),\n-            default_level: $crate::lint::$Level,\n+            default_level: $crate::$Level,\n             desc: $desc,\n-            edition_lint_opts: Some(($lint_edition, $crate::lint::Level::$edition_level)),\n+            edition_lint_opts: Some(($lint_edition, $crate::Level::$edition_level)),\n             report_in_external_macro: false,\n             is_plugin: false,\n         };\n@@ -380,9 +431,9 @@ macro_rules! declare_tool_lint {\n         $external:expr\n     ) => (\n         $(#[$attr])*\n-        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+        $vis static $NAME: &$crate::Lint = &$crate::Lint {\n             name: &concat!(stringify!($tool), \"::\", stringify!($NAME)),\n-            default_level: $crate::lint::$Level,\n+            default_level: $crate::$Level,\n             desc: $desc,\n             edition_lint_opts: None,\n             report_in_external_macro: $external,\n@@ -413,11 +464,11 @@ pub trait LintPass {\n #[macro_export]\n macro_rules! impl_lint_pass {\n     ($ty:ty => [$($lint:expr),* $(,)?]) => {\n-        impl $crate::lint::LintPass for $ty {\n+        impl $crate::LintPass for $ty {\n             fn name(&self) -> &'static str { stringify!($ty) }\n         }\n         impl $ty {\n-            pub fn get_lints() -> $crate::lint::LintArray { $crate::lint_array!($($lint),*) }\n+            pub fn get_lints() -> $crate::LintArray { $crate::lint_array!($($lint),*) }\n         }\n     };\n }\n@@ -431,45 +482,3 @@ macro_rules! declare_lint_pass {\n         $crate::impl_lint_pass!($name => [$($lint),*]);\n     };\n }\n-\n-pub fn add_elided_lifetime_in_path_suggestion(\n-    sess: &crate::Session,\n-    db: &mut DiagnosticBuilder<'_>,\n-    n: usize,\n-    path_span: Span,\n-    incl_angl_brckt: bool,\n-    insertion_span: Span,\n-    anon_lts: String,\n-) {\n-    let (replace_span, suggestion) = if incl_angl_brckt {\n-        (insertion_span, anon_lts)\n-    } else {\n-        // When possible, prefer a suggestion that replaces the whole\n-        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n-        // at a point (which makes for an ugly/confusing label)\n-        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n-            // But our spans can get out of whack due to macros; if the place we think\n-            // we want to insert `'_` isn't even within the path expression's span, we\n-            // should bail out of making any suggestion rather than panicking on a\n-            // subtract-with-overflow or string-slice-out-out-bounds (!)\n-            // FIXME: can we do better?\n-            if insertion_span.lo().0 < path_span.lo().0 {\n-                return;\n-            }\n-            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n-            if insertion_index > snippet.len() {\n-                return;\n-            }\n-            let (before, after) = snippet.split_at(insertion_index);\n-            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n-        } else {\n-            (insertion_span, anon_lts)\n-        }\n-    };\n-    db.span_suggestion(\n-        replace_span,\n-        &format!(\"indicate the anonymous lifetime{}\", pluralize!(n)),\n-        suggestion,\n-        Applicability::MachineApplicable,\n-    );\n-}", "previous_filename": "compiler/rustc_session/src/lint.rs"}, {"sha": "6e67f0d828c05fd4c2e05a82c693dd820136dd84", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -225,20 +225,31 @@ pub fn struct_lint_level<'s, 'd>(\n         span: Option<MultiSpan>,\n         decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n     ) {\n+        // Check for future incompatibility lints and issue a stronger warning.\n+        let lint_id = LintId::of(lint);\n+        let future_incompatible = lint.future_incompatible;\n+\n+        let has_future_breakage =\n+            future_incompatible.map_or(false, |incompat| incompat.future_breakage.is_some());\n+\n         let mut err = match (level, span) {\n-            (Level::Allow, _) => {\n-                return;\n+            (Level::Allow, span) => {\n+                if has_future_breakage {\n+                    if let Some(span) = span {\n+                        sess.struct_span_allow(span, \"\")\n+                    } else {\n+                        sess.struct_allow(\"\")\n+                    }\n+                } else {\n+                    return;\n+                }\n             }\n             (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n             (Level::Warn, None) => sess.struct_warn(\"\"),\n             (Level::Deny | Level::Forbid, Some(span)) => sess.struct_span_err(span, \"\"),\n             (Level::Deny | Level::Forbid, None) => sess.struct_err(\"\"),\n         };\n \n-        // Check for future incompatibility lints and issue a stronger warning.\n-        let lint_id = LintId::of(lint);\n-        let future_incompatible = lint.future_incompatible;\n-\n         // If this code originates in a foreign macro, aka something that this crate\n         // did not itself author, then it's likely that there's nothing this crate\n         // can do about it. We probably want to skip the lint entirely.\n@@ -321,7 +332,7 @@ pub fn struct_lint_level<'s, 'd>(\n             }\n         }\n \n-        err.code(DiagnosticId::Lint(name));\n+        err.code(DiagnosticId::Lint { name, has_future_breakage });\n \n         if let Some(future_incompatible) = future_incompatible {\n             const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\"}, {"sha": "4c72920502f5fb223512b9bd9b18bea7563a69aa", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -18,3 +18,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n num_cpus = \"1.0\"\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_lint_defs = { path = \"../rustc_lint_defs\" }"}, {"sha": "d002f5973916618bc6e64d7d5678ac0125f8bc92", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -9,8 +9,8 @@ extern crate rustc_macros;\n \n pub mod cgu_reuse_tracker;\n pub mod utils;\n-#[macro_use]\n-pub mod lint;\n+pub use lint::{declare_lint, declare_lint_pass, declare_tool_lint, impl_lint_pass};\n+pub use rustc_lint_defs as lint;\n pub mod parse;\n \n mod code_stats;"}, {"sha": "578caf2192d5fe54c3c63354f80f71bc76d8750d", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -893,6 +893,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         all `statement`s (including terminators), only `terminator` spans, or \\\n         computed `block` spans (one span encompassing a block's terminator and \\\n         all statements).\"),\n+    emit_future_incompat_report: bool = (false, parse_bool, [UNTRACKED],\n+        \"emits a future-incompatibility report for lints (RFC 2834)\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n     fewer_names: bool = (false, parse_bool, [TRACKED],"}, {"sha": "0b7c35a8afd504c55d84fb5bb6f98ad93aa1d47b", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -3,7 +3,7 @@ use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use crate::config::{self, CrateType, OutputType, PrintRequest, SanitizerSet, SwitchWithOptPath};\n use crate::filesearch;\n-use crate::lint;\n+use crate::lint::{self, LintId};\n use crate::parse::ParseSess;\n use crate::search_paths::{PathKind, SearchPath};\n \n@@ -21,7 +21,8 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n+use rustc_lint_defs::FutureBreakage;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n@@ -40,6 +41,10 @@ use std::str::FromStr;\n use std::sync::Arc;\n use std::time::Duration;\n \n+pub trait SessionLintStore: sync::Send + sync::Sync {\n+    fn name_to_lint(&self, lint_name: &str) -> LintId;\n+}\n+\n pub struct OptimizationFuel {\n     /// If `-zfuel=crate=n` is specified, initially set to `n`, otherwise `0`.\n     remaining: u64,\n@@ -131,6 +136,8 @@ pub struct Session {\n \n     features: OnceCell<rustc_feature::Features>,\n \n+    lint_store: OnceCell<Lrc<dyn SessionLintStore>>,\n+\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: OnceCell<Limit>,\n@@ -297,6 +304,35 @@ impl Session {\n     pub fn finish_diagnostics(&self, registry: &Registry) {\n         self.check_miri_unleashed_features();\n         self.diagnostic().print_error_count(registry);\n+        self.emit_future_breakage();\n+    }\n+\n+    fn emit_future_breakage(&self) {\n+        if !self.opts.debugging_opts.emit_future_incompat_report {\n+            return;\n+        }\n+\n+        let diags = self.diagnostic().take_future_breakage_diagnostics();\n+        if diags.is_empty() {\n+            return;\n+        }\n+        // If any future-breakage lints were registered, this lint store\n+        // should be available\n+        let lint_store = self.lint_store.get().expect(\"`lint_store` not initialized!\");\n+        let diags_and_breakage: Vec<(FutureBreakage, Diagnostic)> = diags\n+            .into_iter()\n+            .map(|diag| {\n+                let lint_name = match &diag.code {\n+                    Some(DiagnosticId::Lint { name, has_future_breakage: true }) => name,\n+                    _ => panic!(\"Unexpected code in diagnostic {:?}\", diag),\n+                };\n+                let lint = lint_store.name_to_lint(&lint_name);\n+                let future_breakage =\n+                    lint.lint.future_incompatible.unwrap().future_breakage.unwrap();\n+                (future_breakage, diag)\n+            })\n+            .collect();\n+        self.parse_sess.span_diagnostic.emit_future_breakage_report(diags_and_breakage);\n     }\n \n     pub fn local_crate_disambiguator(&self) -> CrateDisambiguator {\n@@ -337,6 +373,12 @@ impl Session {\n     pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_warn(msg)\n     }\n+    pub fn struct_span_allow<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n+        self.diagnostic().struct_span_allow(sp, msg)\n+    }\n+    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_> {\n+        self.diagnostic().struct_allow(msg)\n+    }\n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n@@ -611,6 +653,13 @@ impl Session {\n         }\n     }\n \n+    pub fn init_lint_store(&self, lint_store: Lrc<dyn SessionLintStore>) {\n+        self.lint_store\n+            .set(lint_store)\n+            .map_err(|_| ())\n+            .expect(\"`lint_store` was initialized twice\");\n+    }\n+\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n@@ -1388,6 +1437,7 @@ pub fn build_session(\n         crate_types: OnceCell::new(),\n         crate_disambiguator: OnceCell::new(),\n         features: OnceCell::new(),\n+        lint_store: OnceCell::new(),\n         recursion_limit: OnceCell::new(),\n         type_length_limit: OnceCell::new(),\n         const_eval_limit: OnceCell::new(),"}, {"sha": "7f511bde3cbfcd97a9d019b5caf58583da74d6d9", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -55,4 +55,7 @@ fn main() {\n     (&small as &[_]).into_iter();\n     small[..].into_iter();\n     std::iter::IntoIterator::into_iter(&[1, 2]);\n+\n+    #[allow(array_into_iter)]\n+    [0, 1].into_iter();\n }"}, {"sha": "d5fe83a7834b6422d81c466b65793be8374c46a7", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -55,4 +55,7 @@ fn main() {\n     (&small as &[_]).into_iter();\n     small[..].into_iter();\n     std::iter::IntoIterator::into_iter(&[1, 2]);\n+\n+    #[allow(array_into_iter)]\n+    [0, 1].into_iter();\n }"}, {"sha": "211315c3fcf05d48281d70e90f48bf21c44e96a8", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.stderr", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -109,3 +109,139 @@ LL |     Box::new(Box::new([0u8; 33])).into_iter();\n \n warning: 12 warnings emitted\n \n+Future incompatibility report: Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:9:11\n+   |\n+LL |     small.into_iter();\n+   |           ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = note: `#[warn(array_into_iter)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:12:12\n+   |\n+LL |     [1, 2].into_iter();\n+   |            ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:15:9\n+   |\n+LL |     big.into_iter();\n+   |         ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:18:15\n+   |\n+LL |     [0u8; 33].into_iter();\n+   |               ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:22:21\n+   |\n+LL |     Box::new(small).into_iter();\n+   |                     ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:25:22\n+   |\n+LL |     Box::new([1, 2]).into_iter();\n+   |                      ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:28:19\n+   |\n+LL |     Box::new(big).into_iter();\n+   |                   ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:31:25\n+   |\n+LL |     Box::new([0u8; 33]).into_iter();\n+   |                         ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:35:31\n+   |\n+LL |     Box::new(Box::new(small)).into_iter();\n+   |                               ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:38:32\n+   |\n+LL |     Box::new(Box::new([1, 2])).into_iter();\n+   |                                ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:41:29\n+   |\n+LL |     Box::new(Box::new(big)).into_iter();\n+   |                             ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:44:35\n+   |\n+LL |     Box::new(Box::new([0u8; 33])).into_iter();\n+   |                                   ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+Future breakage date: None, diagnostic:\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:60:12\n+   |\n+LL |     [0, 1].into_iter();\n+   |            ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/into-iter-on-arrays-lint.rs:59:13\n+   |\n+LL |     #[allow(array_into_iter)]\n+   |             ^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+"}, {"sha": "736a531eda657d9856aeb2575d36bed3937ece95", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -59,7 +59,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\"];\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n-pub const LINT: [&str; 3] = [\"rustc_session\", \"lint\", \"Lint\"];\n+pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_MANUALLY_DROP: [&str; 4] = [\"core\", \"mem\", \"manually_drop\", \"ManuallyDrop\"];"}, {"sha": "19aec0ea598f9eb6b658d2ecaae0b0f30b1bb3ff", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -36,6 +36,17 @@ struct DiagnosticSpan {\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n+#[derive(Deserialize)]\n+struct FutureIncompatReport {\n+    future_incompat_report: Vec<FutureBreakageItem>,\n+}\n+\n+#[derive(Deserialize)]\n+struct FutureBreakageItem {\n+    future_breakage_date: Option<String>,\n+    diagnostic: Diagnostic,\n+}\n+\n impl DiagnosticSpan {\n     /// Returns the deepest source span in the macro call stack with a given file name.\n     /// This is either the supplied span, or the span for some macro callsite that expanded to it.\n@@ -68,13 +79,42 @@ struct DiagnosticCode {\n     explanation: Option<String>,\n }\n \n+pub fn rustfix_diagnostics_only(output: &str) -> String {\n+    output\n+        .lines()\n+        .filter(|line| line.starts_with('{') && serde_json::from_str::<Diagnostic>(line).is_ok())\n+        .collect()\n+}\n+\n pub fn extract_rendered(output: &str) -> String {\n     output\n         .lines()\n         .filter_map(|line| {\n             if line.starts_with('{') {\n                 if let Ok(diagnostic) = serde_json::from_str::<Diagnostic>(line) {\n                     diagnostic.rendered\n+                } else if let Ok(report) = serde_json::from_str::<FutureIncompatReport>(line) {\n+                    if report.future_incompat_report.is_empty() {\n+                        None\n+                    } else {\n+                        Some(format!(\n+                            \"Future incompatibility report: {}\",\n+                            report\n+                                .future_incompat_report\n+                                .into_iter()\n+                                .map(|item| {\n+                                    format!(\n+                                        \"Future breakage date: {}, diagnostic:\\n{}\",\n+                                        item.future_breakage_date\n+                                            .unwrap_or_else(|| \"None\".to_string()),\n+                                        item.diagnostic\n+                                            .rendered\n+                                            .unwrap_or_else(|| \"Not rendered\".to_string())\n+                                    )\n+                                })\n+                                .collect::<String>()\n+                        ))\n+                    }\n                 } else if serde_json::from_str::<ArtifactNotification>(line).is_ok() {\n                     // Ignore the notification.\n                     None\n@@ -108,11 +148,17 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 expected_errors\n             }\n             Err(error) => {\n-                proc_res.fatal(Some(&format!(\n-                    \"failed to decode compiler output as json: \\\n-                     `{}`\\nline: {}\\noutput: {}\",\n-                    error, line, output\n-                )));\n+                // Ignore the future compat report message - this is handled\n+                // by `extract_rendered`\n+                if serde_json::from_str::<FutureIncompatReport>(line).is_ok() {\n+                    vec![]\n+                } else {\n+                    proc_res.fatal(Some(&format!(\n+                        \"failed to decode compiler output as json: \\\n+                         `{}`\\nline: {}\\noutput: {}\",\n+                        error, line, output\n+                    )));\n+                }\n             }\n         }\n     } else {"}, {"sha": "19ddcf3a01091d5decb2d094b33e7b29c1054349", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2025326088b54fb3f083bebeba14e0a15bf00d3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b2025326088b54fb3f083bebeba14e0a15bf00d3", "patch": "@@ -1942,6 +1942,7 @@ impl<'test> TestCx<'test> {\n                 }\n                 rustc.arg(\"-Zui-testing\");\n                 rustc.arg(\"-Zdeduplicate-diagnostics=no\");\n+                rustc.arg(\"-Zemit-future-incompat-report\");\n             }\n             MirOpt => {\n                 rustc.args(&[\n@@ -2978,6 +2979,7 @@ impl<'test> TestCx<'test> {\n         self.prune_duplicate_outputs(&modes_to_prune);\n \n         let mut errors = self.load_compare_outputs(&proc_res, TestOutput::Compile, explicit);\n+        let rustfix_input = json::rustfix_diagnostics_only(&proc_res.stderr);\n \n         if self.config.compare_mode.is_some() {\n             // don't test rustfix with nll right now\n@@ -2988,7 +2990,7 @@ impl<'test> TestCx<'test> {\n             // This will return an empty `Vec` in case the executed test file has a\n             // `compile-flags: --error-format=xxxx` header with a value other than `json`.\n             let suggestions = get_suggestions_from_json(\n-                &proc_res.stderr,\n+                &rustfix_input,\n                 &HashSet::new(),\n                 Filter::MachineApplicableOnly,\n             )\n@@ -3015,7 +3017,7 @@ impl<'test> TestCx<'test> {\n             // Apply suggestions from rustc to the code itself\n             let unfixed_code = self.load_expected_output_from_path(&self.testpaths.file).unwrap();\n             let suggestions = get_suggestions_from_json(\n-                &proc_res.stderr,\n+                &rustfix_input,\n                 &HashSet::new(),\n                 if self.props.rustfix_only_machine_applicable {\n                     Filter::MachineApplicableOnly\n@@ -3121,7 +3123,9 @@ impl<'test> TestCx<'test> {\n                 self.fatal_proc_rec(\"failed to compile fixed code\", &res);\n             }\n             if !res.stderr.is_empty() && !self.props.rustfix_only_machine_applicable {\n-                self.fatal_proc_rec(\"fixed code is still producing diagnostics\", &res);\n+                if !json::rustfix_diagnostics_only(&res.stderr).is_empty() {\n+                    self.fatal_proc_rec(\"fixed code is still producing diagnostics\", &res);\n+                }\n             }\n         }\n     }"}]}