{"sha": "5518b6b686abf5d28def94fdf3ece5e83348be05", "node_id": "C_kwDOAAsO6NoAKDU1MThiNmI2ODZhYmY1ZDI4ZGVmOTRmZGYzZWNlNWU4MzM0OGJlMDU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-21T14:54:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-21T14:54:04Z"}, "message": "Rollup merge of #100775 - GuillaumeGomez:reduce-span-v2, r=notriddle\n\nrustdoc: Merge source code pages HTML elements together v2\n\nThis is the follow-up of https://github.com/rust-lang/rust/pull/100429.\n\nI strongly recommend to review it one commit at a time because otherwise it's a lot at once.\n\nFor these ones, on each page, I run this JS: `document.getElementsByTagName('*').length`. The goal is to count the number of DOM elements. I took some pages that seemed big, but don't hesitate to check some others. I also added the \"starting point\" because it's quite nice to see how much the page was reduced thanks to these two PRs.\n\n| file name | before #100429 | before this PR | with this PR | diff |\n|-|-|-|-|-|\n| std/lib.rs.html (source link on std crate page) | 3455 | 2332 | 1772 | 24% |\n| alloc/vec/mod.rs.html (source on Vec type page) | 11012 | 5982 | 5833 | 2.5% |\n| alloc/string.rs.html (source on String type page) | 10800 | 6010 | 5822 | 3.2% |\n| std/sync/mutex.rs.html (source on Mutex type page) | 2953 | 2041 | 2038 | 0.1% |\n\nSo unsurprisingly, the more attributes you have, the bigger the difference.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/reduce-span-v2/src/std/lib.rs.html).\n\ncc ``````@jsha``````\nr? ``````@notriddle``````", "tree": {"sha": "0c378ef316a28e2c74e2c100d633ab1e634a8b7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c378ef316a28e2c74e2c100d633ab1e634a8b7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5518b6b686abf5d28def94fdf3ece5e83348be05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAkcMCRBK7hj4Ov3rIwAAf+4IAJ5U4NsNbjLuBmplcL3uWgXU\nd0/i9k750+jjRvVQ0YudURyoscsAn1Bmo8h94mESUCB1/A7NgGZ6XckzqDLVkZIN\nRNLwSv3YQft4mfqdlzCkxTObzDUzF0HumYVMUmBstSUqKOJ5J1VvYtx9kLkUHdWj\n825FXC2kk1tLpt9DcseZsyfTmnrmmlhXJF15smEO0BsmIwyshTVEbqnPOYQiy9WH\nP0ELPWumR4/F6ZrwS0rgSteSdXemgzB75gouxi2Xqrdt+YCpLGxcTiJ13GTg01Lz\nKsQI6rXD+veEYhAFwOXz3JeJ5PohdlTWuExckqwe6E8xvX2V2x7JwYUpnLjIWZI=\n=CNSc\n-----END PGP SIGNATURE-----\n", "payload": "tree 0c378ef316a28e2c74e2c100d633ab1e634a8b7e\nparent 9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c\nparent 7ab8e0cbe4c6e7617fe43a44467c463fad3b010e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661093644 +0200\ncommitter GitHub <noreply@github.com> 1661093644 +0200\n\nRollup merge of #100775 - GuillaumeGomez:reduce-span-v2, r=notriddle\n\nrustdoc: Merge source code pages HTML elements together v2\n\nThis is the follow-up of https://github.com/rust-lang/rust/pull/100429.\n\nI strongly recommend to review it one commit at a time because otherwise it's a lot at once.\n\nFor these ones, on each page, I run this JS: `document.getElementsByTagName('*').length`. The goal is to count the number of DOM elements. I took some pages that seemed big, but don't hesitate to check some others. I also added the \"starting point\" because it's quite nice to see how much the page was reduced thanks to these two PRs.\n\n| file name | before #100429 | before this PR | with this PR | diff |\n|-|-|-|-|-|\n| std/lib.rs.html (source link on std crate page) | 3455 | 2332 | 1772 | 24% |\n| alloc/vec/mod.rs.html (source on Vec type page) | 11012 | 5982 | 5833 | 2.5% |\n| alloc/string.rs.html (source on String type page) | 10800 | 6010 | 5822 | 3.2% |\n| std/sync/mutex.rs.html (source on Mutex type page) | 2953 | 2041 | 2038 | 0.1% |\n\nSo unsurprisingly, the more attributes you have, the bigger the difference.\n\nYou can test it [here](https://rustdoc.crud.net/imperio/reduce-span-v2/src/std/lib.rs.html).\n\ncc ``````@jsha``````\nr? ``````@notriddle``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5518b6b686abf5d28def94fdf3ece5e83348be05", "html_url": "https://github.com/rust-lang/rust/commit/5518b6b686abf5d28def94fdf3ece5e83348be05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5518b6b686abf5d28def94fdf3ece5e83348be05/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c", "html_url": "https://github.com/rust-lang/rust/commit/9cf3bacfb26a396d8d3ceaa8f9b709f6da9e359c"}, {"sha": "7ab8e0cbe4c6e7617fe43a44467c463fad3b010e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab8e0cbe4c6e7617fe43a44467c463fad3b010e", "html_url": "https://github.com/rust-lang/rust/commit/7ab8e0cbe4c6e7617fe43a44467c463fad3b010e"}], "stats": {"total": 263, "additions": 157, "deletions": 106}, "files": [{"sha": "4a12d74ddef5a5844dd89255ed451eee1f43e7af", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 133, "deletions": 91, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -111,53 +111,6 @@ fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>) {\n     write!(out, \"<code>\");\n }\n \n-/// Write all the pending elements sharing a same (or at mergeable) `Class`.\n-///\n-/// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n-/// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n-/// close the tag.\n-///\n-/// Otherwise, if there is only one pending element, we let the `string` function handle both\n-/// opening and closing the tag, otherwise we do it into this function.\n-fn write_pending_elems(\n-    out: &mut Buffer,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n-    pending_elems: &mut Vec<(&str, Option<Class>)>,\n-    current_class: &mut Option<Class>,\n-    closing_tags: &[(&str, Class)],\n-) {\n-    if pending_elems.is_empty() {\n-        return;\n-    }\n-    let mut done = false;\n-    if let Some((_, parent_class)) = closing_tags.last() {\n-        if can_merge(*current_class, Some(*parent_class), \"\") {\n-            for (text, class) in pending_elems.iter() {\n-                string(out, Escape(text), *class, &href_context, false);\n-            }\n-            done = true;\n-        }\n-    }\n-    if !done {\n-        // We only want to \"open\" the tag ourselves if we have more than one pending and if the current\n-        // parent tag is not the same as our pending content.\n-        let open_tag_ourselves = pending_elems.len() > 1;\n-        let close_tag = if open_tag_ourselves {\n-            enter_span(out, current_class.unwrap(), &href_context)\n-        } else {\n-            \"\"\n-        };\n-        for (text, class) in pending_elems.iter() {\n-            string(out, Escape(text), *class, &href_context, !open_tag_ourselves);\n-        }\n-        if open_tag_ourselves {\n-            exit_span(out, close_tag);\n-        }\n-    }\n-    pending_elems.clear();\n-    *current_class = None;\n-}\n-\n /// Check if two `Class` can be merged together. In the following rules, \"unclassified\" means `None`\n /// basically (since it's `Option<Class>`). The following rules apply:\n ///\n@@ -171,7 +124,88 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n         (Some(c1), Some(c2)) => c1.is_equal_to(c2),\n         (Some(Class::Ident(_)), None) | (None, Some(Class::Ident(_))) => true,\n         (Some(_), None) | (None, Some(_)) => text.trim().is_empty(),\n-        _ => false,\n+        (None, None) => true,\n+    }\n+}\n+\n+/// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n+/// the various functions (which became its methods).\n+struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    out: &'a mut Buffer,\n+    /// It contains the closing tag and the associated `Class`.\n+    closing_tags: Vec<(&'static str, Class)>,\n+    /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n+    /// case an `EnterSpan` event with the same class follows.\n+    pending_exit_span: Option<Class>,\n+    /// `current_class` and `pending_elems` are used to group HTML elements with same `class`\n+    /// attributes to reduce the DOM size.\n+    current_class: Option<Class>,\n+    /// We need to keep the `Class` for each element because it could contain a `Span` which is\n+    /// used to generate links.\n+    pending_elems: Vec<(&'b str, Option<Class>)>,\n+    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    fn handle_exit_span(&mut self) {\n+        // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n+        // being used in `write_pending_elems`.\n+        let class = self.closing_tags.last().expect(\"ExitSpan without EnterSpan\").1;\n+        // We flush everything just in case...\n+        self.write_pending_elems(Some(class));\n+\n+        exit_span(self.out, self.closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0);\n+        self.pending_exit_span = None;\n+    }\n+\n+    /// Write all the pending elements sharing a same (or at mergeable) `Class`.\n+    ///\n+    /// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n+    /// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n+    /// close the tag.\n+    ///\n+    /// Otherwise, if there is only one pending element, we let the `string` function handle both\n+    /// opening and closing the tag, otherwise we do it into this function.\n+    ///\n+    /// It returns `true` if `current_class` must be set to `None` afterwards.\n+    fn write_pending_elems(&mut self, current_class: Option<Class>) -> bool {\n+        if self.pending_elems.is_empty() {\n+            return false;\n+        }\n+        if let Some((_, parent_class)) = self.closing_tags.last() &&\n+            can_merge(current_class, Some(*parent_class), \"\")\n+        {\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, false);\n+            }\n+        } else {\n+            // We only want to \"open\" the tag ourselves if we have more than one pending and if the\n+            // current parent tag is not the same as our pending content.\n+            let close_tag = if self.pending_elems.len() > 1 && current_class.is_some() {\n+                Some(enter_span(self.out, current_class.unwrap(), &self.href_context))\n+            } else {\n+                None\n+            };\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, close_tag.is_none());\n+            }\n+            if let Some(close_tag) = close_tag {\n+                exit_span(self.out, close_tag);\n+            }\n+        }\n+        self.pending_elems.clear();\n+        true\n+    }\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    /// When leaving, we need to flush all pending data to not have missing content.\n+    fn drop(&mut self) {\n+        if self.pending_exit_span.is_some() {\n+            self.handle_exit_span();\n+        } else {\n+            self.write_pending_elems(self.current_class);\n+        }\n     }\n }\n \n@@ -194,64 +228,72 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    // It contains the closing tag and the associated `Class`.\n-    let mut closing_tags: Vec<(&'static str, Class)> = Vec::new();\n-    // The following two variables are used to group HTML elements with same `class` attributes\n-    // to reduce the DOM size.\n-    let mut current_class: Option<Class> = None;\n-    // We need to keep the `Class` for each element because it could contain a `Span` which is\n-    // used to generate links.\n-    let mut pending_elems: Vec<(&str, Option<Class>)> = Vec::new();\n+    let mut token_handler = TokenHandler {\n+        out,\n+        closing_tags: Vec::new(),\n+        pending_exit_span: None,\n+        current_class: None,\n+        pending_elems: Vec::new(),\n+        href_context,\n+    };\n \n     Classifier::new(\n         &src,\n-        href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        token_handler.href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => {\n+                // If we received a `ExitSpan` event and then have a non-compatible `Class`, we\n+                // need to close the `<span>`.\n+                let need_current_class_update = if let Some(pending) = token_handler.pending_exit_span &&\n+                    !can_merge(Some(pending), class, text) {\n+                        token_handler.handle_exit_span();\n+                        true\n                 // If the two `Class` are different, time to flush the current content and start\n                 // a new one.\n-                if !can_merge(current_class, class, text) {\n-                    write_pending_elems(\n-                        out,\n-                        &href_context,\n-                        &mut pending_elems,\n-                        &mut current_class,\n-                        &closing_tags,\n-                    );\n-                    current_class = class.map(Class::dummy);\n-                } else if current_class.is_none() {\n-                    current_class = class.map(Class::dummy);\n+                } else if !can_merge(token_handler.current_class, class, text) {\n+                    token_handler.write_pending_elems(token_handler.current_class);\n+                    true\n+                } else {\n+                    token_handler.current_class.is_none()\n+                };\n+\n+                if need_current_class_update {\n+                    token_handler.current_class = class.map(Class::dummy);\n                 }\n-                pending_elems.push((text, class));\n+                token_handler.pending_elems.push((text, class));\n             }\n             Highlight::EnterSpan { class } => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                closing_tags.push((enter_span(out, class, &href_context), class))\n+                let mut should_add = true;\n+                if let Some(pending_exit_span) = token_handler.pending_exit_span {\n+                    if class.is_equal_to(pending_exit_span) {\n+                        should_add = false;\n+                    } else {\n+                        token_handler.handle_exit_span();\n+                    }\n+                } else {\n+                    // We flush everything just in case...\n+                    if token_handler.write_pending_elems(token_handler.current_class) {\n+                        token_handler.current_class = None;\n+                    }\n+                }\n+                if should_add {\n+                    let closing_tag = enter_span(token_handler.out, class, &token_handler.href_context);\n+                    token_handler.closing_tags.push((closing_tag, class));\n+                }\n+\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span = None;\n             }\n             Highlight::ExitSpan => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0)\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span =\n+                    Some(token_handler.closing_tags.last().as_ref().expect(\"ExitSpan without EnterSpan\").1);\n             }\n         };\n     });\n-    write_pending_elems(out, &href_context, &mut pending_elems, &mut current_class, &closing_tags);\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -291,8 +333,8 @@ impl Class {\n         match (self, other) {\n             (Self::Self_(_), Self::Self_(_))\n             | (Self::Macro(_), Self::Macro(_))\n-            | (Self::Ident(_), Self::Ident(_))\n-            | (Self::Decoration(_), Self::Decoration(_)) => true,\n+            | (Self::Ident(_), Self::Ident(_)) => true,\n+            (Self::Decoration(c1), Self::Decoration(c2)) => c1 == c2,\n             (x, y) => x == y,\n         }\n     }\n@@ -761,7 +803,7 @@ impl<'a> Classifier<'a> {\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: Some(Class::Attribute) });\n+                    sink(Highlight::Token { text: \"]\", class: None });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }"}, {"sha": "ebf29f9cb3a91616f151baa53722095c9e7b8f42", "filename": "src/librustdoc/html/highlight/fixtures/decorations.html", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -1,2 +1,4 @@\n-<span class=\"example\"><span class=\"kw\">let </span>x = <span class=\"number\">1</span>;</span>\n-<span class=\"kw\">let </span>y = <span class=\"number\">2</span>;\n\\ No newline at end of file\n+<span class=\"example\"><span class=\"kw\">let </span>x = <span class=\"number\">1</span>;\n+<span class=\"kw\">let </span>y = <span class=\"number\">2</span>;\n+</span><span class=\"example2\"><span class=\"kw\">let </span>z = <span class=\"number\">3</span>;\n+</span><span class=\"kw\">let </span>a = <span class=\"number\">4</span>;\n\\ No newline at end of file"}, {"sha": "4a5a3cf609cd405956270d3f6c8465e250d73750", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -8,12 +8,13 @@\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }\n </style>\n-<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]</span>\n+<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n \n-<span class=\"kw\">use </span>std::path::{Path, PathBuf};\n+</span><span class=\"kw\">use </span>std::path::{Path, PathBuf};\n \n-<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]</span>\n-<span class=\"kw\">fn </span>main() -&gt; () {\n+<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n+#[cfg(target_os = <span class=\"string\">&quot;windows&quot;</span>)]\n+</span><span class=\"kw\">fn </span>main() -&gt; () {\n     <span class=\"kw\">let </span>foo = <span class=\"bool-val\">true </span>&amp;&amp; <span class=\"bool-val\">false </span>|| <span class=\"bool-val\">true</span>;\n     <span class=\"kw\">let _</span>: <span class=\"kw-2\">*const </span>() = <span class=\"number\">0</span>;\n     <span class=\"kw\">let _ </span>= <span class=\"kw-2\">&amp;</span>foo;\n@@ -22,16 +23,16 @@\n     <span class=\"macro\">mac!</span>(foo, <span class=\"kw-2\">&amp;mut </span>bar);\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.length &lt; N &amp;&amp; index &lt;= <span class=\"self\">self</span>.length);\n     ::std::env::var(<span class=\"string\">&quot;gateau&quot;</span>).is_ok();\n-    <span class=\"attribute\">#[rustfmt::skip]</span>\n-    <span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n+    <span class=\"attribute\">#[rustfmt::skip]\n+    </span><span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n     <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n \n     <span class=\"kw\">match </span><span class=\"kw-2\">&amp;</span>s {\n         <span class=\"kw-2\">ref mut </span>x =&gt; {}\n     }\n }\n \n-<span class=\"macro\">macro_rules!</span> bar {\n+<span class=\"macro\">macro_rules! </span>bar {\n     (<span class=\"macro-nonterminal\">$foo</span>:tt) =&gt; {};\n }\n </code></pre>"}, {"sha": "ef85b566cb3c487bf756d212f4a8b5b9d68f6eb1", "filename": "src/librustdoc/html/highlight/fixtures/sample.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -3,6 +3,7 @@\n use std::path::{Path, PathBuf};\n \n #[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"windows\")]\n fn main() -> () {\n     let foo = true && false || true;\n     let _: *const () = 0;"}, {"sha": "a5e633df4344820f4b140d3f6d5714ad9df8e7a7", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -69,9 +69,12 @@ fn test_union_highlighting() {\n fn test_decorations() {\n     create_default_session_globals_then(|| {\n         let src = \"let x = 1;\n-let y = 2;\";\n+let y = 2;\n+let z = 3;\n+let a = 4;\";\n         let mut decorations = FxHashMap::default();\n-        decorations.insert(\"example\", vec![(0, 10)]);\n+        decorations.insert(\"example\", vec![(0, 10), (11, 21)]);\n+        decorations.insert(\"example2\", vec![(22, 32)]);\n \n         let mut html = Buffer::new();\n         write_code(&mut html, src, None, Some(DecorationInfo(decorations)));"}, {"sha": "89987491d1b46cbcc47fd36d1977d84202e65387", "filename": "src/test/rustdoc/issue-41783.codeblock.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -1,5 +1,5 @@\n <code># single\n ## double\n ### triple\n-<span class=\"attribute\">#[outer]</span>\n-<span class=\"attribute\">#![inner]</span></code>\n\\ No newline at end of file\n+<span class=\"attribute\">#[outer]\n+#![inner]</span></code>"}, {"sha": "87267a750c6151b1079e4d75948168b0a2cb1059", "filename": "src/test/rustdoc/issue-41783.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5518b6b686abf5d28def94fdf3ece5e83348be05/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.rs?ref=5518b6b686abf5d28def94fdf3ece5e83348be05", "patch": "@@ -1,8 +1,10 @@\n // @has issue_41783/struct.Foo.html\n // @!hasraw - 'space'\n // @!hasraw - 'comment'\n-// @hasraw - '<span class=\"attribute\">#[outer]</span>'\n-// @hasraw - '<span class=\"attribute\">#![inner]</span>'\n+// @hasraw - '<span class=\"attribute\">#[outer]'\n+// @!hasraw - '<span class=\"attribute\">#[outer]</span>'\n+// @hasraw - '#![inner]</span>'\n+// @!hasraw - '<span class=\"attribute\">#![inner]</span>'\n // @snapshot 'codeblock' - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]//pre/code'\n \n /// ```no_run"}]}