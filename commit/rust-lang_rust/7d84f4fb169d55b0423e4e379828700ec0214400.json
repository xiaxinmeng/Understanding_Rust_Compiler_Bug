{"sha": "7d84f4fb169d55b0423e4e379828700ec0214400", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODRmNGZiMTY5ZDU1YjA0MjNlNGUzNzk4Mjg3MDBlYzAyMTQ0MDA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-07T10:03:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-16T09:22:45Z"}, "message": "Offload try_collect_active_jobs.", "tree": {"sha": "31265fd46c98d57df5c112f62bb56fd29ee356f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31265fd46c98d57df5c112f62bb56fd29ee356f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d84f4fb169d55b0423e4e379828700ec0214400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d84f4fb169d55b0423e4e379828700ec0214400", "html_url": "https://github.com/rust-lang/rust/commit/7d84f4fb169d55b0423e4e379828700ec0214400", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d84f4fb169d55b0423e4e379828700ec0214400/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dc7c2ed1aab0c6b0bfb15b4fb5a4d079d3aaa36", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc7c2ed1aab0c6b0bfb15b4fb5a4d079d3aaa36", "html_url": "https://github.com/rust-lang/rust/commit/5dc7c2ed1aab0c6b0bfb15b4fb5a4d079d3aaa36"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "54e80b4dc0b154cbf241186b4fb75400ffe835e2", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d84f4fb169d55b0423e4e379828700ec0214400/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d84f4fb169d55b0423e4e379828700ec0214400/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=7d84f4fb169d55b0423e4e379828700ec0214400", "patch": "@@ -57,7 +57,6 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::ops::Deref;\n use std::sync::Arc;\n "}, {"sha": "406ca18b59105249c68e394a775cb5169d214745", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7d84f4fb169d55b0423e4e379828700ec0214400/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d84f4fb169d55b0423e4e379828700ec0214400/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=7d84f4fb169d55b0423e4e379828700ec0214400", "patch": "@@ -2,10 +2,10 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::{QueryAccessors, QueryConfig, QueryDescription};\n-use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n+use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n use crate::ty::{self, TyCtxt};\n@@ -20,6 +20,7 @@ use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, H\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n+use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::mem;\n@@ -110,6 +111,35 @@ impl<'tcx, K, V, C: QueryCache<K, V>> QueryStateImpl<'tcx, K, V, C> {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n+\n+    pub(super) fn try_collect_active_jobs(\n+        &self,\n+        kind: DepKind,\n+        make_query: fn(K) -> Query<'tcx>,\n+        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<'tcx>>,\n+    ) -> Option<()>\n+    where\n+        K: Clone,\n+    {\n+        // We use try_lock_shards here since we are called from the\n+        // deadlock handler, and this shouldn't be locked.\n+        let shards = self.shards.try_lock_shards()?;\n+        let shards = shards.iter().enumerate();\n+        jobs.extend(shards.flat_map(|(shard_id, shard)| {\n+            shard.active.iter().filter_map(move |(k, v)| {\n+                if let QueryResult::Started(ref job) = *v {\n+                    let id =\n+                        QueryJobId { job: job.id, shard: u16::try_from(shard_id).unwrap(), kind };\n+                    let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n+                    Some((id, QueryJobInfo { info, job: job.clone() }))\n+                } else {\n+                    None\n+                }\n+            })\n+        }));\n+\n+        Some(())\n+    }\n }\n \n impl<'tcx, K, V, C: QueryCache<K, V>> Default for QueryStateImpl<'tcx, K, V, C> {\n@@ -1135,29 +1165,11 @@ macro_rules! define_queries_struct {\n                 let mut jobs = FxHashMap::default();\n \n                 $(\n-                    // We use try_lock_shards here since we are called from the\n-                    // deadlock handler, and this shouldn't be locked.\n-                    let shards = self.$name.shards.try_lock_shards()?;\n-                    let shards = shards.iter().enumerate();\n-                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n-                        shard.active.iter().filter_map(move |(k, v)| {\n-                        if let QueryResult::Started(ref job) = *v {\n-                                let id = QueryJobId {\n-                                    job: job.id,\n-                                    shard:  u16::try_from(shard_id).unwrap(),\n-                                    kind:\n-                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n-                                };\n-                                let info = QueryInfo {\n-                                    span: job.span,\n-                                    query: Query::$name(k.clone())\n-                                };\n-                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n-                        } else {\n-                            None\n-                        }\n-                        })\n-                    }));\n+                    self.$name.try_collect_active_jobs(\n+                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n+                        Query::$name,\n+                        &mut jobs,\n+                    )?;\n                 )*\n \n                 Some(jobs)"}]}