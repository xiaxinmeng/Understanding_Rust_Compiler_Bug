{"sha": "8b04c2d6e87b62b88a488383d84268684148723c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDRjMmQ2ZTg3YjYyYjg4YTQ4ODM4M2Q4NDI2ODY4NDE0ODcyM2M=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-09-15T19:21:35Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-09-15T19:21:35Z"}, "message": "Merge branch 'master' into lint-5734", "tree": {"sha": "93f78518205ff533edad9a65223bb1c78f5c69fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93f78518205ff533edad9a65223bb1c78f5c69fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b04c2d6e87b62b88a488383d84268684148723c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b04c2d6e87b62b88a488383d84268684148723c", "html_url": "https://github.com/rust-lang/rust/commit/8b04c2d6e87b62b88a488383d84268684148723c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b04c2d6e87b62b88a488383d84268684148723c/comments", "author": null, "committer": null, "parents": [{"sha": "15244a88df5cfd475df010ad945474c658749192", "url": "https://api.github.com/repos/rust-lang/rust/commits/15244a88df5cfd475df010ad945474c658749192", "html_url": "https://github.com/rust-lang/rust/commit/15244a88df5cfd475df010ad945474c658749192"}, {"sha": "0695f219945e22d092aa1351a5862abcb4e1f3c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0695f219945e22d092aa1351a5862abcb4e1f3c3", "html_url": "https://github.com/rust-lang/rust/commit/0695f219945e22d092aa1351a5862abcb4e1f3c3"}], "stats": {"total": 532, "additions": 468, "deletions": 64}, "files": [{"sha": "5a84333d6db5915940b8e038d43bf278769a5ad6", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1677,6 +1677,7 @@ Released 2018-09-13\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n+[`map_err_ignore`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_err_ignore\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n [`map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_identity\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or"}, {"sha": "a6313127f6911171cf7950e8caa0fe5685efc4fb", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -232,6 +232,7 @@ mod manual_async_fn;\n mod manual_non_exhaustive;\n mod manual_strip;\n mod map_clone;\n+mod map_err_ignore;\n mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -629,6 +630,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &manual_strip::MANUAL_STRIP,\n         &map_clone::MAP_CLONE,\n+        &map_err_ignore::MAP_ERR_IGNORE,\n         &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -867,6 +869,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n         &utils::internal_lints::DEFAULT_LINT,\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+        &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         &utils::internal_lints::PRODUCE_ICE,\n         &vec::USELESS_VEC,\n@@ -922,6 +925,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n     store.register_late_pass(|| box methods::Methods);\n     store.register_late_pass(|| box map_clone::MapClone);\n+    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n     store.register_late_pass(|| box shadow::Shadow);\n     store.register_late_pass(|| box types::LetUnitValue);\n     store.register_late_pass(|| box types::UnitCmp);\n@@ -1112,6 +1116,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n     store.register_late_pass(|| box manual_strip::ManualStrip);\n+    store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1189,6 +1194,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_INTO_ITER_LOOP),\n         LintId::of(&loops::EXPLICIT_ITER_LOOP),\n         LintId::of(&macro_use::MACRO_USE_IMPORTS),\n+        LintId::of(&map_err_ignore::MAP_ERR_IGNORE),\n         LintId::of(&match_on_vec_items::MATCH_ON_VEC_ITEMS),\n         LintId::of(&matches::MATCH_BOOL),\n         LintId::of(&matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n@@ -1239,6 +1245,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n+        LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n     ]);"}, {"sha": "3410341a1e3c5056aacfc16bffd2344bcf98e23b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1114,7 +1114,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n             if let Some(self_expr) = args.get(0);\n             if let Some(pushed_item) = args.get(1);\n             // Check that the method being called is push() on a Vec\n-            if match_type(cx, cx.typeck_results().expr_ty(self_expr), &paths::VEC);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym!(vec_type));\n             if path.ident.name.as_str() == \"push\";\n             then {\n                 return Some((self_expr, pushed_item))"}, {"sha": "5298e16a04d9b7d3578edc82c111fb3984cfbf9b", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -0,0 +1,147 @@\n+use crate::utils::span_lint_and_help;\n+\n+use rustc_hir::{CaptureBy, Expr, ExprKind, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map_err(|_| Some::Enum)`\n+    ///\n+    /// **Why is this bad?** This map_err throws away the original error rather than allowing the enum to contain and report the cause of the error\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Before:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible,\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {}\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(|_| Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    ///  ```\n+    ///\n+    ///  After:\n+    ///  ```rust\n+    /// use std::{fmt, num::ParseIntError};\n+    ///\n+    /// #[derive(Debug)]\n+    /// enum Error {\n+    ///     Indivisible(ParseIntError),\n+    ///     Remainder(u8),\n+    /// }\n+    ///\n+    /// impl fmt::Display for Error {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         match self {\n+    ///             Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n+    ///             Error::Remainder(remainder) => write!(\n+    ///                 f,\n+    ///                 \"input is not divisible by three, remainder = {}\",\n+    ///                 remainder\n+    ///             ),\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for Error {\n+    ///     fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n+    ///         match self {\n+    ///             Error::Indivisible(source) => Some(source),\n+    ///             _ => None,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// fn divisible_by_3(input: &str) -> Result<(), Error> {\n+    ///     input\n+    ///         .parse::<i32>()\n+    ///         .map_err(Error::Indivisible)\n+    ///         .map(|v| v % 3)\n+    ///         .and_then(|remainder| {\n+    ///             if remainder == 0 {\n+    ///                 Ok(())\n+    ///             } else {\n+    ///                 Err(Error::Remainder(remainder as u8))\n+    ///             }\n+    ///         })\n+    /// }\n+    /// ```\n+    pub MAP_ERR_IGNORE,\n+    pedantic,\n+    \"`map_err` should not ignore the original error\"\n+}\n+\n+declare_lint_pass!(MapErrIgnore => [MAP_ERR_IGNORE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n+    // do not try to lint if this is from a macro or desugaring\n+    fn check_expr(&mut self, cx: &LateContext<'_>, e: &Expr<'_>) {\n+        if e.span.from_expansion() {\n+            return;\n+        }\n+\n+        // check if this is a method call (e.g. x.foo())\n+        if let ExprKind::MethodCall(ref method, _t_span, ref args, _) = e.kind {\n+            // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n+            // Enum::Variant[2]))\n+            if method.ident.as_str() == \"map_err\" && args.len() == 2 {\n+                // make sure the first argument is a closure, and grab the CaptureRef, body_id, and body_span fields\n+                if let ExprKind::Closure(capture, _, body_id, body_span, _) = args[1].kind {\n+                    // check if this is by Reference (meaning there's no move statement)\n+                    if capture == CaptureBy::Ref {\n+                        // Get the closure body to check the parameters and values\n+                        let closure_body = cx.tcx.hir().body(body_id);\n+                        // make sure there's only one parameter (`|_|`)\n+                        if closure_body.params.len() == 1 {\n+                            // make sure that parameter is the wild token (`_`)\n+                            if let PatKind::Wild = closure_body.params[0].pat.kind {\n+                                // span the area of the closure capture and warn that the\n+                                // original error will be thrown away\n+                                span_lint_and_help(\n+                                    cx,\n+                                    MAP_ERR_IGNORE,\n+                                    body_span,\n+                                    \"`map_err(|_|...` ignores the original error\",\n+                                    None,\n+                                    \"Consider wrapping the error in an enum variant\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "de966cccd111c3da615ce9dceb35f9a87e4a86ff", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1808,7 +1808,7 @@ fn lint_or_fun_call<'tcx>(\n                     _ => (),\n                 }\n \n-                if match_type(cx, ty, &paths::VEC) {\n+                if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n                     return;\n                 }\n             }"}, {"sha": "67a3685fd0dc3b07b96e3a45039e7305366afddd", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -99,11 +99,11 @@ declare_clippy_lint! {\n     /// if y != x {} // where both are floats\n     ///\n     /// // Good\n-    /// let error = f64::EPSILON; // Use an epsilon for comparison\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n     /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error = std::f64::EPSILON;\n-    /// if (y - 1.23f64).abs() < error { }\n-    /// if (y - x).abs() > error { }\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (y - 1.23f64).abs() < error_margin { }\n+    /// if (y - x).abs() > error_margin { }\n     /// ```\n     pub FLOAT_CMP,\n     correctness,\n@@ -242,10 +242,10 @@ declare_clippy_lint! {\n     /// if x == ONE { } // where both are floats\n     ///\n     /// // Good\n-    /// let error = f64::EPSILON; // Use an epsilon for comparison\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n     /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error = std::f64::EPSILON;\n-    /// if (x - ONE).abs() < error { }\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (x - ONE).abs() < error_margin { }\n     /// ```\n     pub FLOAT_CMP_CONST,\n     restriction,\n@@ -411,16 +411,16 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                         if !is_comparing_arrays {\n                             diag.span_suggestion(\n                                 expr.span,\n-                                \"consider comparing them within some error\",\n+                                \"consider comparing them within some margin of error\",\n                                 format!(\n-                                    \"({}).abs() {} error\",\n+                                    \"({}).abs() {} error_margin\",\n                                     lhs - rhs,\n                                     if op == BinOpKind::Eq { '<' } else { '>' }\n                                 ),\n                                 Applicability::HasPlaceholders, // snippet\n                             );\n                         }\n-                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error`\");\n+                        diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n                     });\n                 } else if op == BinOpKind::Rem && is_integer_const(cx, right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");"}, {"sha": "60e5e7bfed398e03ccd9226b3ce47d30b0edae41", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1,6 +1,6 @@\n use crate::utils;\n use crate::utils::sugg::Sugg;\n-use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use crate::utils::{is_type_diagnostic_item, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n \n use rustc_errors::Applicability;\n@@ -73,7 +73,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.to_ident_string() == \"ok\"\n-            && match_type(cx, &cx.typeck_results().expr_ty(&receiver), &paths::RESULT)\n+            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym!(result_type))\n     } else {\n         false\n     }"}, {"sha": "ef4a54735a4986aa9e4a43b29c0995afb6c5a75d", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -25,7 +25,6 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let x = 1;\n-    ///\n     /// // Bad\n     /// let x = &x;\n     ///"}, {"sha": "0a58231558ede21304bf1ecc9f4b7cd1e60d29b5", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -51,6 +51,8 @@ pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: impl Into<Mult\n ///\n /// The `help` message can be optionally attached to a `Span`.\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n /// # Example\n ///\n /// ```ignore\n@@ -87,6 +89,8 @@ pub fn span_lint_and_help<'a, T: LintContext>(\n /// The `note` message is presented separately from the main lint message\n /// and is attached to a specific span:\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n /// # Example\n ///\n /// ```ignore\n@@ -126,6 +130,7 @@ pub fn span_lint_and_note<'a, T: LintContext>(\n /// Like `span_lint` but allows to add notes, help and suggestions using a closure.\n ///\n /// If you need to customize your lint output a lot, use this function.\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n where\n     F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n@@ -168,6 +173,10 @@ pub fn span_lint_hir_and_then(\n /// In the example below, `help` is `\"try\"` and `sugg` is the suggested replacement `\".any(|x| x >\n /// 2)\"`.\n ///\n+/// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n+///\n+/// # Example\n+///\n /// ```ignore\n /// error: This `.fold` can be more succinctly expressed as `.any`\n /// --> $DIR/methods.rs:390:13"}, {"sha": "f201494a02466da46b50701bf851edc8082bfbd4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n+    is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n+    snippet, span_lint, span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -206,6 +206,29 @@ declare_clippy_lint! {\n     \"found collapsible `span_lint_and_then` calls\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `utils::match_type()` on a type diagnostic item\n+    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    ///\n+    /// **Why is this bad?** `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    /// ```\n+    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    internal,\n+    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -652,3 +675,89 @@ fn suggest_note(\n         Applicability::MachineApplicable,\n     );\n }\n+\n+declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if !run_lints(cx, &[MATCH_TYPE_ON_DIAGNOSTIC_ITEM], expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            // Check if this is a call to utils::match_type()\n+            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n+            if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n+            if match_qpath(&fn_qpath, &[\"utils\", \"match_type\"]);\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, ty_path);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(ty_did) = path_to_res(cx, &segments[..]).and_then(|res| res.opt_def_id());\n+            // Check if the matched type is a diagnostic item\n+            let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n+            if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n+            then {\n+                let cx_snippet = snippet(cx, context.span, \"_\");\n+                let ty_snippet = snippet(cx, ty.span, \"_\");\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    expr.span,\n+                    \"usage of `utils::match_type()` on a type diagnostic item\",\n+                    \"try\",\n+                    format!(\"utils::is_type_diagnostic_item({}, {}, sym!({}))\", cx_snippet, ty_snippet, item_name),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<SymbolStr>> {\n+    use rustc_hir::ItemKind;\n+\n+    match &expr.kind {\n+        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n+        ExprKind::Path(qpath) => match qpath_res(cx, qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n+                    if let Some(init) = local.init {\n+                        return path_to_matched_type(cx, init);\n+                    }\n+                }\n+            },\n+            Res::Def(DefKind::Const | DefKind::Static, def_id) => {\n+                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n+                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n+                        let body = cx.tcx.hir().body(body_id);\n+                        return path_to_matched_type(cx, &body.value);\n+                    }\n+                }\n+            },\n+            _ => {},\n+        },\n+        ExprKind::Array(exprs) => {\n+            let segments: Vec<SymbolStr> = exprs\n+                .iter()\n+                .filter_map(|expr| {\n+                    if let ExprKind::Lit(lit) = &expr.kind {\n+                        if let LitKind::Str(sym, _) = lit.node {\n+                            return Some(sym.as_str());\n+                        }\n+                    }\n+\n+                    None\n+                })\n+                .collect();\n+\n+            if segments.len() == exprs.len() {\n+                return Some(segments);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    None\n+}"}, {"sha": "8db7e693e62617eb55f65d32f576c27336bbaa2f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -130,6 +130,9 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n+///\n+/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n@@ -138,6 +141,8 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n }\n \n /// Checks if the type is equal to a diagnostic item\n+///\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),"}, {"sha": "8736121c3b439f03708b07a171bd767c2b762954", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -106,7 +106,7 @@ pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWrite\n pub const SERDE_DESERIALIZE: [&str; 2] = [\"_serde\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n-pub const SLICE_ITER: [&str; 3] = [\"core\", \"slice\", \"Iter\"];\n+pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const STD_CONVERT_IDENTITY: [&str; 3] = [\"std\", \"convert\", \"identity\"];"}, {"sha": "53c3d084dbc98624bbe114172cf5f44ff7e82441", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -60,7 +60,7 @@ impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method\n-            if let hir::ExprKind::MethodCall(path, _, _args) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(path, _, _args, _) = &expr.kind;\n             // Check the name of this method is `some_method`\n             if path.ident.name == sym!(some_method);\n             then {"}, {"sha": "1468bef02b8a5a5ca50354c81093f82847b7baa1", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1179,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"entry\",\n     },\n+    Lint {\n+        name: \"map_err_ignore\",\n+        group: \"pedantic\",\n+        desc: \"`map_err` should not ignore the original error\",\n+        deprecation: None,\n+        module: \"map_err_ignore\",\n+    },\n     Lint {\n         name: \"map_flatten\",\n         group: \"pedantic\","}, {"sha": "6b5bcdaa78e2762cd82fc68130cdb4405d217e03", "filename": "tests/ui/drop_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_ref.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1,5 +1,6 @@\n #![warn(clippy::drop_ref)]\n #![allow(clippy::toplevel_ref_arg)]\n+#![allow(clippy::map_err_ignore)]\n \n use std::mem::drop;\n "}, {"sha": "7974bf56d44cf582e1b80e98ecf4c31c4aeb226e", "filename": "tests/ui/drop_ref.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fdrop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fdrop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_ref.stderr?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -1,108 +1,108 @@\n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:9:5\n+  --> $DIR/drop_ref.rs:10:5\n    |\n LL |     drop(&SomeStruct);\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::drop-ref` implied by `-D warnings`\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:9:10\n+  --> $DIR/drop_ref.rs:10:10\n    |\n LL |     drop(&SomeStruct);\n    |          ^^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:12:5\n+  --> $DIR/drop_ref.rs:13:5\n    |\n LL |     drop(&owned1);\n    |     ^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:12:10\n+  --> $DIR/drop_ref.rs:13:10\n    |\n LL |     drop(&owned1);\n    |          ^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:13:5\n+  --> $DIR/drop_ref.rs:14:5\n    |\n LL |     drop(&&owned1);\n    |     ^^^^^^^^^^^^^^\n    |\n note: argument has type `&&SomeStruct`\n-  --> $DIR/drop_ref.rs:13:10\n+  --> $DIR/drop_ref.rs:14:10\n    |\n LL |     drop(&&owned1);\n    |          ^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:14:5\n+  --> $DIR/drop_ref.rs:15:5\n    |\n LL |     drop(&mut owned1);\n    |     ^^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&mut SomeStruct`\n-  --> $DIR/drop_ref.rs:14:10\n+  --> $DIR/drop_ref.rs:15:10\n    |\n LL |     drop(&mut owned1);\n    |          ^^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:18:5\n+  --> $DIR/drop_ref.rs:19:5\n    |\n LL |     drop(reference1);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:18:10\n+  --> $DIR/drop_ref.rs:19:10\n    |\n LL |     drop(reference1);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:21:5\n+  --> $DIR/drop_ref.rs:22:5\n    |\n LL |     drop(reference2);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&mut SomeStruct`\n-  --> $DIR/drop_ref.rs:21:10\n+  --> $DIR/drop_ref.rs:22:10\n    |\n LL |     drop(reference2);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:24:5\n+  --> $DIR/drop_ref.rs:25:5\n    |\n LL |     drop(reference3);\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:24:10\n+  --> $DIR/drop_ref.rs:25:10\n    |\n LL |     drop(reference3);\n    |          ^^^^^^^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:29:5\n+  --> $DIR/drop_ref.rs:30:5\n    |\n LL |     drop(&val);\n    |     ^^^^^^^^^^\n    |\n note: argument has type `&T`\n-  --> $DIR/drop_ref.rs:29:10\n+  --> $DIR/drop_ref.rs:30:10\n    |\n LL |     drop(&val);\n    |          ^^^^\n \n error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n-  --> $DIR/drop_ref.rs:37:5\n+  --> $DIR/drop_ref.rs:38:5\n    |\n LL |     std::mem::drop(&SomeStruct);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: argument has type `&SomeStruct`\n-  --> $DIR/drop_ref.rs:37:20\n+  --> $DIR/drop_ref.rs:38:20\n    |\n LL |     std::mem::drop(&SomeStruct);\n    |                    ^^^^^^^^^^^"}, {"sha": "f7c380fc915c06a14f595c6b3a9ce66c16382ce5", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -2,50 +2,50 @@ error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:65:5\n    |\n LL |     ONE as f64 != 2.0;\n-   |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE as f64 - 2.0).abs() > error`\n+   |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE as f64 - 2.0).abs() > error_margin`\n    |\n    = note: `-D clippy::float-cmp` implied by `-D warnings`\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:70:5\n    |\n LL |     x == 1.0;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(x - 1.0).abs() < error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(x - 1.0).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:73:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(twice(x) - twice(ONE as f64)).abs() > error`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(twice(x) - twice(ONE as f64)).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:93:5\n    |\n LL |     NON_ZERO_ARRAY[i] == NON_ZERO_ARRAY[j];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` arrays\n   --> $DIR/float_cmp.rs:98:5\n    |\n LL |     a1 == a2;\n    |     ^^^^^^^^\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n   --> $DIR/float_cmp.rs:99:5\n    |\n LL |     a1[0] == a2[0];\n-   |     ^^^^^^^^^^^^^^ help: consider comparing them within some error: `(a1[0] - a2[0]).abs() < error`\n+   |     ^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(a1[0] - a2[0]).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "5d0455363e8e02dc2167dfe6833902751267876f", "filename": "tests/ui/float_cmp_const.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Ffloat_cmp_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Ffloat_cmp_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp_const.stderr?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -2,66 +2,66 @@ error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:20:5\n    |\n LL |     1f32 == ONE;\n-   |     ^^^^^^^^^^^ help: consider comparing them within some error: `(1f32 - ONE).abs() < error`\n+   |     ^^^^^^^^^^^ help: consider comparing them within some margin of error: `(1f32 - ONE).abs() < error_margin`\n    |\n    = note: `-D clippy::float-cmp-const` implied by `-D warnings`\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:21:5\n    |\n LL |     TWO == ONE;\n-   |     ^^^^^^^^^^ help: consider comparing them within some error: `(TWO - ONE).abs() < error`\n+   |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:22:5\n    |\n LL |     TWO != ONE;\n-   |     ^^^^^^^^^^ help: consider comparing them within some error: `(TWO - ONE).abs() > error`\n+   |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:23:5\n    |\n LL |     ONE + ONE == TWO;\n-   |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE + ONE - TWO).abs() < error`\n+   |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE + ONE - TWO).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:25:5\n    |\n LL |     x as f32 == ONE;\n-   |     ^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(x as f32 - ONE).abs() < error`\n+   |     ^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(x as f32 - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:28:5\n    |\n LL |     v == ONE;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(v - ONE).abs() < error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() < error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n   --> $DIR/float_cmp_const.rs:29:5\n    |\n LL |     v != ONE;\n-   |     ^^^^^^^^ help: consider comparing them within some error: `(v - ONE).abs() > error`\n+   |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() > error_margin`\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant arrays\n   --> $DIR/float_cmp_const.rs:61:5\n    |\n LL |     NON_ZERO_ARRAY == NON_ZERO_ARRAY2;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error`\n+   = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "617b6422872645362a68e406fdf92490f78b94b5", "filename": "tests/ui/map_err.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmap_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmap_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -0,0 +1,25 @@\n+#![warn(clippy::map_err_ignore)]\n+use std::convert::TryFrom;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+enum Errors {\n+    Ignored,\n+}\n+\n+impl Error for Errors {}\n+\n+impl fmt::Display for Errors {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Error\")\n+    }\n+}\n+\n+fn main() -> Result<(), Errors> {\n+    let x = u32::try_from(-123_i32);\n+\n+    println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n+\n+    Ok(())\n+}"}, {"sha": "7273f4603807865c42ff29e87d7878c12bceaaaa", "filename": "tests/ui/map_err.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmap_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmap_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_err.stderr?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -0,0 +1,11 @@\n+error: `map_err(|_|...` ignores the original error\n+  --> $DIR/map_err.rs:22:32\n+   |\n+LL |     println!(\"{:?}\", x.map_err(|_| Errors::Ignored));\n+   |                                ^^^\n+   |\n+   = note: `-D clippy::map-err-ignore` implied by `-D warnings`\n+   = help: Consider wrapping the error in an enum variant\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe950b0aa7c7004c729c33cc7b6dab3392d1260a", "filename": "tests/ui/match_type_on_diag_item.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.rs?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -0,0 +1,50 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_session;\n+use rustc_hir::Expr;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+\n+mod paths {\n+    pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n+}\n+\n+mod utils {\n+    use super::*;\n+\n+    pub fn match_type(_cx: &LateContext<'_>, _ty: Ty<'_>, _path: &[&str]) -> bool {\n+        false\n+    }\n+}\n+\n+use utils::match_type;\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Warn,\n+    \"\"\n+}\n+\n+declare_lint_pass!(Pass => [TEST_LINT]);\n+\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        let _ = match_type(cx, ty, &paths::VEC);\n+        let _ = match_type(cx, ty, &OPTION);\n+        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+        let _ = utils::match_type(cx, ty, rc_path);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5e5fe9e3a3e73c494873f3c06cc126ae43989944", "filename": "tests/ui/match_type_on_diag_item.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b04c2d6e87b62b88a488383d84268684148723c/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.stderr?ref=8b04c2d6e87b62b88a488383d84268684148723c", "patch": "@@ -0,0 +1,33 @@\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:41:17\n+   |\n+LL |         let _ = match_type(cx, ty, &paths::VEC);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/match_type_on_diag_item.rs:1:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:42:17\n+   |\n+LL |         let _ = match_type(cx, ty, &OPTION);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(option_type))`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:43:17\n+   |\n+LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(result_type))`\n+\n+error: usage of `utils::match_type()` on a type diagnostic item\n+  --> $DIR/match_type_on_diag_item.rs:46:17\n+   |\n+LL |         let _ = utils::match_type(cx, ty, rc_path);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(Rc))`\n+\n+error: aborting due to 4 previous errors\n+"}]}