{"sha": "a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MWFkZTdiYzM3MzYwZGI0MGFiMzExMWNlOTVhY2RmZDlkMGJjYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T01:18:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-25T01:18:13Z"}, "message": "Auto merge of #57888 - Centril:rollup, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #56217 (Add grammar in docs for {f32,f64}::from_str, mention known bug.)\n - #57294 (When using value after move, point at span of local)\n - #57652 (Update/remove some old readmes)\n - #57802 (Print visible name for types as well as modules.)\n - #57865 (Don't ICE when logging unusual types)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ed703bb2e268afcba45781c78f06fce045a0c086", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed703bb2e268afcba45781c78f06fce045a0c086"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "html_url": "https://github.com/rust-lang/rust/commit/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "278067d34d1535a840cf9c99bcb8b538bf5b109a", "url": "https://api.github.com/repos/rust-lang/rust/commits/278067d34d1535a840cf9c99bcb8b538bf5b109a", "html_url": "https://github.com/rust-lang/rust/commit/278067d34d1535a840cf9c99bcb8b538bf5b109a"}, {"sha": "a6fa7de8e7e06b132ecda6945746a416a972c763", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fa7de8e7e06b132ecda6945746a416a972c763", "html_url": "https://github.com/rust-lang/rust/commit/a6fa7de8e7e06b132ecda6945746a416a972c763"}], "stats": {"total": 2002, "additions": 867, "deletions": 1135}, "files": [{"sha": "14e773286bc6a21ccf06c6d281f641f787675630", "filename": "src/README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -8,7 +8,6 @@ For more information on how various parts of the compiler work, see the [rustc g\n There is also useful content in the following READMEs, which are gradually being moved over to the guide:\n - https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n - https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n-- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n - https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n - https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n "}, {"sha": "14a912872be35bfefc46e8d3e398d73f7d1a864c", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -112,11 +112,35 @@ macro_rules! from_str_float_impl {\n             /// * '2.5E10', or equivalently, '2.5e10'\n             /// * '2.5E-10'\n             /// * '5.'\n-            /// * '.5', or, equivalently,  '0.5'\n+            /// * '.5', or, equivalently, '0.5'\n             /// * 'inf', '-inf', 'NaN'\n             ///\n             /// Leading and trailing whitespace represent an error.\n             ///\n+            /// # Grammar\n+            ///\n+            /// All strings that adhere to the following [EBNF] grammar\n+            /// will result in an [`Ok`] being returned:\n+            ///\n+            /// ```txt\n+            /// Float  ::= Sign? ( 'inf' | 'NaN' | Number )\n+            /// Number ::= ( Digit+ |\n+            ///              Digit+ '.' Digit* |\n+            ///              Digit* '.' Digit+ ) Exp?\n+            /// Exp    ::= [eE] Sign? Digit+\n+            /// Sign   ::= [+-]\n+            /// Digit  ::= [0-9]\n+            /// ```\n+            ///\n+            /// [EBNF]: https://www.w3.org/TR/REC-xml/#sec-notation\n+            ///\n+            /// # Known bugs\n+            ///\n+            /// In some situations, some strings that should create a valid float\n+            /// instead return an error. See [issue #31407] for details.\n+            ///\n+            /// [issue #31407]: https://github.com/rust-lang/rust/issues/31407\n+            ///\n             /// # Arguments\n             ///\n             /// * src - A string"}, {"sha": "e7afaa5beb0a75adcc35dca489ddbfe834cc0419", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 401, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,403 +1,8 @@\n-# Skolemization and functions\n+To learn more about how Higher-ranked trait bounds work in the _old_ trait\n+solver, see [this chapter][oldhrtb] of the rustc-guide.\n \n-One of the trickiest and most subtle aspects of regions is dealing\n-with higher-ranked things which include bound region variables, such\n-as function types. I strongly suggest that if you want to understand\n-the situation, you read this paper (which is, admittedly, very long,\n-but you don't have to read the whole thing):\n+To learn more about how they work in the _new_ trait solver, see [this\n+chapter][newhrtb].\n \n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it. Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters. Consider, for\n-example, whether the following relation holds:\n-\n-    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n-\n-The answer is that of course it does. These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n-lifetime parameter.\n-\n-Now let's consider two more function types. Here, we assume that the\n-`'b` lifetime is defined somewhere outside and hence is not a lifetime\n-parameter bound by the function type (it \"appears free\"):\n-\n-    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n-\n-This subtyping relation does in fact hold. To see why, you have to\n-consider what subtyping means. One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`. So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `'b`. After all, `'b` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship. This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no. In this case, the function accepts *only the lifetime `'b`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n-    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with placeholder\n-   equivalents. A \"placeholder\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no placeholder regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. for<'a> fn(&'a T) <: for<'b> fn(&'b T)?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: fn(&'x T)?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system. I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate placeholder region names. We can assume they don't appear\n-elsewhere. Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match. Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship. Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'a T)    <: for<'b> fn(&'b T)?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'a T) <: fn(&'x T)?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`'a` was not bound, and hence was left as-is and not replaced with\n-a variable. The next step is again to check that the parameter types\n-match. This will ultimately require (as before) that `'a` <= `&x`\n-must hold: but this does not hold. `self` and `x` are both distinct\n-free regions. So the subtype check fails.\n-\n-#### Checking for placeholder leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant. The purpose of that last step is to\n-catch something like *this*:\n-\n-    for<'a> fn() -> fn(&'a T) <: fn() -> for<'b> fn(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region. The supertype returns a function that expects a value in any\n-region. If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above). Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions). This gives us:\n-\n-    fn() -> fn(&'A T) <: fn() -> for<'b> fn(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: for<'b> fn(&'b T)?\n-\n-Here we replace the bound region in the supertype with a placeholder to yield:\n-\n-    fn(&'A T) <: fn(&'x T)?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    'A <= 'x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported. But in fact this will not happen. The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy. In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the placeholders were added. In\n-the first example, you had two functions:\n-\n-    for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n-\n-and hence `&A` and `&x` were created \"together\". In general, the\n-intention of the placeholder names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to placeholder names. Basically, consider a\n-non-directed version of the constraint graph. Let `Tainted(x)` be the\n-set of all things reachable from a placeholder variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the placeholders were created. So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell. It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation. We have to consider this. Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail. The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some function\n-pairs and their LUB/GLB (for conciseness, in this table, I'm just\n-including the lifetimes here, not the rest of the types, and I'm\n-writing `fn<>` instead of `for<> fn`):\n-\n-```\n-Type 1                Type 2                LUB                    GLB\n-fn<'a>('a)            fn('X)                fn('X)                 fn<'a>('a)\n-fn('a)                fn('X)                --                     fn<'a>('a)\n-fn<'a,'b>('a, 'b)     fn<'x>('x, 'x)        fn<'a>('a, 'a)         fn<'a,'b>('a, 'b)\n-fn<'a,'b>('a, 'b, 'a) fn<'x,'y>('x, 'y, 'y) fn<'a>('a, 'a, 'a)     fn<'a,'b,'c>('a,'b,'c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `for<'a> fn(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with\n-a bound region, the algorithms make use of two bits of\n-information.  First is a set `V` that contains all region\n-variables created as part of the LUB/GLB computation (roughly; see\n-`region_vars_confined_to_snapshot()` for full details). `V` will\n-contain the region variables created to replace the bound regions\n-in the input types, but it also contains 'intermediate' variables\n-created to represent the LUB/GLB of individual regions.\n-Basically, when asked to compute the LUB/GLB of a region variable\n-with another region, the inferencer cannot oblige immediately\n-since the values of that variables are not known.  Therefore, it\n-creates a new variable that is related to the two regions.  For\n-example, the LUB of two variables `$x` and `$y` is a fresh\n-variable `$z` that is constrained such that `$x <= $z` and `$y <=\n-$z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `for<'a> fn(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+[oldhrtb]: https://rust-lang.github.io/rustc-guide/traits/hrtb.html\n+[newhrtb]: https://rust-lang.github.io/rustc-guide/borrow_check/region_inference.html#placeholders-and-universes"}, {"sha": "56320636a67431a88e7616cfb7c9189936977ec3", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -2,8 +2,12 @@\n \n > WARNING: This README is obsolete and will be removed soon! For\n > more info on how the current borrowck works, see the [rustc guide].\n+>\n+> As of edition 2018, region inference is done using Non-lexical lifetimes,\n+> which is described in the guide and [this RFC].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n+[this RFC]: https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md\n \n ## Terminology\n "}, {"sha": "ea7fffe9dc1c6fdc25b673ff7b248cc1bcea9203", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,77 +1,3 @@\n-# Region constraint collection\n-\n-> WARNING: This README is obsolete and will be removed soon! For\n-> more info on how the current borrowck works, see the [rustc guide].\n+For info on how the current borrowck works, see the [rustc guide].\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n-\n-## Terminology\n-\n-Note that we use the terms region and lifetime interchangeably.\n-\n-## Introduction\n-\n-As described in the rustc guide [chapter on type inference][ti], and unlike\n-normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-[ti]: https://rust-lang.github.io/rustc-guide/type-inference.html\n-\n-The constraints are always of one of three possible forms:\n-\n-- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n-  a subregion of Rj\n-- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n-  must not be a variable) must be a subregion of the variable Ri\n-- `ConstrainVarSubReg(Ri, R)` states the variable Ri should be less\n-  than the concrete region R. This is kind of deprecated and ought to\n-  be replaced with a verify (they essentially play the same role).\n-\n-In addition to constraints, we also gather up a set of \"verifys\"\n-(what, you don't think Verify is a noun? Get used to it my\n-friend!). These represent relations that must hold but which don't\n-influence inference proper. These take the form of:\n-\n-- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n-  where Rj is not an inference variable (and Ri may or may not contain\n-  one). This doesn't influence inference because we will already have\n-  inferred Ri to be as small as possible, so then we just test whether\n-  that result was less than Rj or not.\n-- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n-  that the region R must satisfy the bound `Vb`. The bounds themselves\n-  may have structure like \"must outlive one of the following regions\"\n-  or \"must outlive ALL of the following regions. These bounds arise\n-  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n-  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n-  'a` *or* `'c: 'a`.\n-\n-## Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n-- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the smallest region that is greater than both Ri and Rj\n-- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n-  the greatest region that is smaller than both Ri and Rj\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n-## Skolemization\n-\n-For a discussion on skolemization and higher-ranked subtyping, please\n-see the module `middle::infer::higher_ranked::doc`."}, {"sha": "0ddc5ae87208dcf2a61a51e868837794f34b1e2e", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -210,12 +210,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let visible_parent = visible_parent_map.get(&cur_def).cloned();\n             let actual_parent = self.parent(cur_def);\n-            debug!(\n-                \"try_push_visible_item_path: visible_parent={:?} actual_parent={:?}\",\n-                visible_parent, actual_parent,\n-            );\n \n             let data = cur_def_key.disambiguated_data.data;\n+            debug!(\n+                \"try_push_visible_item_path: data={:?} visible_parent={:?} actual_parent={:?}\",\n+                data, visible_parent, actual_parent,\n+            );\n             let symbol = match data {\n                 // In order to output a path that could actually be imported (valid and visible),\n                 // we need to handle re-exports correctly.\n@@ -248,16 +248,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // the children of the visible parent (as was done when computing\n                 // `visible_parent_map`), looking for the specific child we currently have and then\n                 // have access to the re-exported name.\n-                DefPathData::Module(module_name) if visible_parent != actual_parent => {\n-                    let mut name: Option<ast::Ident> = None;\n-                    if let Some(visible_parent) = visible_parent {\n-                        for child in self.item_children(visible_parent).iter() {\n-                            if child.def.def_id() == cur_def {\n-                                name = Some(child.ident);\n-                            }\n-                        }\n-                    }\n-                    name.map(|n| n.as_str()).unwrap_or(module_name.as_str())\n+                DefPathData::Module(actual_name) |\n+                DefPathData::TypeNs(actual_name) if visible_parent != actual_parent => {\n+                    visible_parent\n+                        .and_then(|parent| {\n+                            self.item_children(parent)\n+                                .iter()\n+                                .find(|child| child.def.def_id() == cur_def)\n+                                .map(|child| child.ident.as_str())\n+                        })\n+                        .unwrap_or_else(|| actual_name.as_str())\n                 },\n                 _ => {\n                     data.get_opt_name().map(|n| n.as_str()).unwrap_or_else(|| {"}, {"sha": "4b5e08cecd99c0719783fd538fe5e8044c293b3f", "filename": "src/librustc/ty/query/README.md", "status": "modified", "additions": 2, "deletions": 301, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc%2Fty%2Fquery%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2FREADME.md?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,302 +1,3 @@\n-# The Rust Compiler Query System\n-\n-The Compiler Query System is the key to our new demand-driven\n-organization.  The idea is pretty simple. You have various queries\n-that compute things about the input -- for example, there is a query\n-called `type_of(def_id)` that, given the def-id of some item, will\n-compute the type of that item and return it to you.\n-\n-Query execution is **memoized** -- so the first time you invoke a\n-query, it will go do the computation, but the next time, the result is\n-returned from a hashtable. Moreover, query execution fits nicely into\n-**incremental computation**; the idea is roughly that, when you do a\n-query, the result **may** be returned to you by loading stored data\n-from disk (but that's a separate topic we won't discuss further here).\n-\n-The overall vision is that, eventually, the entire compiler\n-control-flow will be query driven. There will effectively be one\n-top-level query (\"compile\") that will run compilation on a crate; this\n-will in turn demand information about that crate, starting from the\n-*end*.  For example:\n-\n-- This \"compile\" query might demand to get a list of codegen-units\n-  (i.e., modules that need to be compiled by LLVM).\n-- But computing the list of codegen-units would invoke some subquery\n-  that returns the list of all modules defined in the Rust source.\n-- That query in turn would invoke something asking for the HIR.\n-- This keeps going further and further back until we wind up doing the\n-  actual parsing.\n-\n-However, that vision is not fully realized. Still, big chunks of the\n-compiler (for example, generating MIR) work exactly like this.\n-\n-### Invoking queries\n-\n-To invoke a query is simple. The tcx (\"type context\") offers a method\n-for each defined query. So, for example, to invoke the `type_of`\n-query, you would just do this:\n-\n-```rust\n-let ty = tcx.type_of(some_def_id);\n-```\n-\n-### Cycles between queries\n-\n-Currently, cycles during query execution should always result in a\n-compilation error. Typically, they arise because of illegal programs\n-that contain cyclic references they shouldn't (though sometimes they\n-arise because of compiler bugs, in which case we need to factor our\n-queries in a more fine-grained fashion to avoid them).\n-\n-However, it is nonetheless often useful to *recover* from a cycle\n-(after reporting an error, say) and try to soldier on, so as to give a\n-better user experience. In order to recover from a cycle, you don't\n-get to use the nice method-call-style syntax. Instead, you invoke\n-using the `try_get` method, which looks roughly like this:\n-\n-```rust\n-use ty::query::queries;\n-...\n-match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {\n-  Ok(result) => {\n-    // no cycle occurred! You can use `result`\n-  }\n-  Err(err) => {\n-    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,\n-    // meaning essentially an \"in-progress\", not-yet-reported error message.\n-    // See below for more details on what to do here.\n-  }\n-}\n-```\n-\n-So, if you get back an `Err` from `try_get`, then a cycle *did* occur. This means that\n-you must ensure that a compiler error message is reported. You can do that in two ways:\n-\n-The simplest is to invoke `err.emit()`. This will emit the cycle error to the user.\n-\n-However, often cycles happen because of an illegal program, and you\n-know at that point that an error either already has been reported or\n-will be reported due to this cycle by some other bit of code. In that\n-case, you can invoke `err.cancel()` to not emit any error. It is\n-traditional to then invoke:\n-\n-```\n-tcx.sess.delay_span_bug(some_span, \"some message\")\n-```\n-\n-`delay_span_bug()` is a helper that says: we expect a compilation\n-error to have happened or to happen in the future; so, if compilation\n-ultimately succeeds, make an ICE with the message `\"some\n-message\"`. This is basically just a precaution in case you are wrong.\n-\n-### How the compiler executes a query\n-\n-So you may be wondering what happens when you invoke a query\n-method. The answer is that, for each query, the compiler maintains a\n-cache -- if your query has already been executed, then, the answer is\n-simple: we clone the return value out of the cache and return it\n-(therefore, you should try to ensure that the return types of queries\n-are cheaply cloneable; insert a `Rc` if necessary).\n-\n-#### Providers\n-\n-If, however, the query is *not* in the cache, then the compiler will\n-try to find a suitable **provider**. A provider is a function that has\n-been defined and linked into the compiler somewhere that contains the\n-code to compute the result of the query.\n-\n-**Providers are defined per-crate.** The compiler maintains,\n-internally, a table of providers for every crate, at least\n-conceptually. Right now, there are really two sets: the providers for\n-queries about the **local crate** (that is, the one being compiled)\n-and providers for queries about **external crates** (that is,\n-dependencies of the local crate). Note that what determines the crate\n-that a query is targeting is not the *kind* of query, but the *key*.\n-For example, when you invoke `tcx.type_of(def_id)`, that could be a\n-local query or an external query, depending on what crate the `def_id`\n-is referring to (see the `self::keys::Key` trait for more information\n-on how that works).\n-\n-Providers always have the same signature:\n-\n-```rust\n-fn provider<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                       key: QUERY_KEY)\n-                       -> QUERY_RESULT\n-{\n-    ...\n-}\n-```\n-\n-Providers take two arguments: the `tcx` and the query key. Note also\n-that they take the *global* tcx (i.e., they use the `'tcx` lifetime\n-twice), rather than taking a tcx with some active inference context.\n-They return the result of the query.\n-\n-####  How providers are setup\n-\n-When the tcx is created, it is given the providers by its creator using\n-the `Providers` struct. This struct is generate by the macros here, but it\n-is basically a big list of function pointers:\n-\n-```rust\n-struct Providers {\n-    type_of: for<'cx, 'tcx> fn(TyCtxt<'cx, 'tcx, 'tcx>, DefId) -> Ty<'tcx>,\n-    ...\n-}\n-```\n-\n-At present, we have one copy of the struct for local crates, and one\n-for external crates, though the plan is that we may eventually have\n-one per crate.\n-\n-These `Provider` structs are ultimately created and populated by\n-`librustc_driver`, but it does this by distributing the work\n-throughout the other `rustc_*` crates. This is done by invoking\n-various `provide` functions. These functions tend to look something\n-like this:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        ..*providers\n-    };\n-}\n-```\n-\n-That is, they take an `&mut Providers` and mutate it in place. Usually\n-we use the formulation above just because it looks nice, but you could\n-as well do `providers.type_of = type_of`, which would be equivalent.\n-(Here, `type_of` would be a top-level function, defined as we saw\n-before.) So, if we want to add a provider for some other query,\n-let's call it `fubar`, into the crate above, we might modify the `provide()`\n-function like so:\n-\n-```rust\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        type_of,\n-        fubar,\n-        ..*providers\n-    };\n-}\n-\n-fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n-```\n-\n-NB. Most of the `rustc_*` crates only provide **local\n-providers**. Almost all **extern providers** wind up going through the\n-`rustc_metadata` crate, which loads the information from the crate\n-metadata.  But in some cases there are crates that provide queries for\n-*both* local and external crates, in which case they define both a\n-`provide` and a `provide_extern` function that `rustc_driver` can\n-invoke.\n-\n-### Adding a new kind of query\n-\n-So suppose you want to add a new kind of query, how do you do so?\n-Well, defining a query takes place in two steps:\n-\n-1. first, you have to specify the query name and arguments; and then,\n-2. you have to supply query providers where needed.\n-\n-To specify the query name and arguments, you simply add an entry\n-to the big macro invocation in `mod.rs`. This will probably have changed\n-by the time you read this README, but at present it looks something\n-like:\n-\n-```\n-define_queries! { <'tcx>\n-    /// Records the type of every item.\n-    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-\n-    ...\n-}\n-```\n-\n-Each line of the macro defines one query. The name is broken up like this:\n-\n-```\n-[] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^\n-|     |        |          |         |\n-|     |        |          |         result type of query\n-|     |        |          query key type\n-|     |        dep-node constructor\n-|     name of query\n-query flags\n-```\n-\n-Let's go over them one by one:\n-\n-- **Query flags:** these are largely unused right now, but the intention\n-  is that we'll be able to customize various aspects of how the query is\n-  processed.\n-- **Name of query:** the name of the query method\n-  (`tcx.type_of(..)`). Also used as the name of a struct\n-  (`ty::query::queries::type_of`) that will be generated to represent\n-  this query.\n-- **Dep-node constructor:** indicates the constructor function that\n-  connects this query to incremental compilation. Typically, this is a\n-  `DepNode` variant, which can be added by modifying the\n-  `define_dep_nodes!` macro invocation in\n-  `librustc/dep_graph/dep_node.rs`.\n-  - However, sometimes we use a custom function, in which case the\n-    name will be in snake case and the function will be defined at the\n-    bottom of the file. This is typically used when the query key is\n-    not a def-id, or just not the type that the dep-node expects.\n-- **Query key type:** the type of the argument to this query.\n-  This type must implement the `ty::query::keys::Key` trait, which\n-  defines (for example) how to map it to a crate, and so forth.\n-- **Result type of query:** the type produced by this query. This type\n-  should (a) not use `RefCell` or other interior mutability and (b) be\n-  cheaply cloneable. Interning or using `Rc` or `Arc` is recommended for\n-  non-trivial data types.\n-  - The one exception to those rules is the `ty::steal::Steal` type,\n-    which is used to cheaply modify MIR in place. See the definition\n-    of `Steal` for more details. New uses of `Steal` should **not** be\n-    added without alerting `@rust-lang/compiler`.\n-\n-So, to add a query:\n-\n-- Add an entry to `define_queries!` using the format above.\n-- Possibly add a corresponding entry to the dep-node macro.\n-- Link the provider by modifying the appropriate `provide` method;\n-  or add a new one if needed and ensure that `rustc_driver` is invoking it.\n-\n-#### Query structs and descriptions\n-\n-For each kind, the `define_queries` macro will generate a \"query struct\"\n-named after the query. This struct is a kind of a place-holder\n-describing the query. Each such struct implements the\n-`self::config::QueryConfig` trait, which has associated types for the\n-key/value of that particular query. Basically the code generated looks something\n-like this:\n-\n-```rust\n-// Dummy struct representing a particular kind of query:\n-pub struct type_of<'tcx> { phantom: PhantomData<&'tcx ()> }\n-\n-impl<'tcx> QueryConfig for type_of<'tcx> {\n-  type Key = DefId;\n-  type Value = Ty<'tcx>;\n-}\n-```\n-\n-There is an additional trait that you may wish to implement called\n-`self::config::QueryDescription`. This trait is used during cycle\n-errors to give a \"human readable\" name for the query, so that we can\n-summarize what was happening when the cycle occurred. Implementing\n-this trait is optional if the query key is `DefId`, but if you *don't*\n-implement it, you get a pretty generic error (\"processing `foo`...\").\n-You can put new impls into the `config` module. They look something like this:\n-\n-```rust\n-impl<'tcx> QueryDescription for queries::type_of<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: DefId) -> String {\n-        format!(\"computing the type of `{}`\", tcx.item_path_str(key))\n-    }\n-}\n-```\n+For more information about how the query system works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang.github.io/rustc-guide/query.html"}, {"sha": "afaeb352cd9926fbcf90f85cf403f64ec15e9e77", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -55,7 +55,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Str => {\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n-            printer.push_type_name(layout.ty, &mut name);\n+            printer.push_type_name(layout.ty, &mut name, false);\n             if let (&ty::Adt(def, _), &layout::Variants::Single { index })\n                  = (&layout.ty.sty, &layout.variants)\n             {"}, {"sha": "8488ab2ae862f7f8970aee4d73f0f05a8d502edf", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -13,7 +13,7 @@ pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     fn define<Bx: BuilderMethods<'a, 'tcx>>(&self, cx: &'a Bx::CodegenCx) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n+               self.to_string(cx.tcx(), true),\n                self.to_raw_string(),\n                cx.codegen_unit().name());\n \n@@ -45,7 +45,7 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n+               self.to_string(cx.tcx(), true),\n                self.to_raw_string(),\n                cx.codegen_unit().name());\n     }\n@@ -57,7 +57,7 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         visibility: Visibility\n     ) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n+               self.to_string(cx.tcx(), true),\n                self.to_raw_string(),\n                cx.codegen_unit().name());\n \n@@ -76,7 +76,7 @@ pub trait MonoItemExt<'a, 'tcx: 'a>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(cx.tcx()),\n+               self.to_string(cx.tcx(), true),\n                self.to_raw_string(),\n                cx.codegen_unit().name());\n     }"}, {"sha": "982a2bacce1648459cffea4dc3cde3e83d0fb5b2", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/278067d34d1535a840cf9c99bcb8b538bf5b109a/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=278067d34d1535a840cf9c99bcb8b538bf5b109a", "patch": "@@ -1,81 +0,0 @@\n-The `ObligationForest` is a utility data structure used in trait\n-matching to track the set of outstanding obligations (those not yet\n-resolved to success or error). It also tracks the \"backtrace\" of each\n-pending obligation (why we are trying to figure this out in the first\n-place).\n-\n-### External view\n-\n-`ObligationForest` supports two main public operations (there are a\n-few others not discussed here):\n-\n-1. Add a new root obligations (`push_tree`).\n-2. Process the pending obligations (`process_obligations`).\n-\n-When a new obligation `N` is added, it becomes the root of an\n-obligation tree. This tree can also carry some per-tree state `T`,\n-which is given at the same time. This tree is a singleton to start, so\n-`N` is both the root and the only leaf. Each time the\n-`process_obligations` method is called, it will invoke its callback\n-with every pending obligation (so that will include `N`, the first\n-time). The callback also receives a (mutable) reference to the\n-per-tree state `T`. The callback should process the obligation `O`\n-that it is given and return one of three results:\n-\n-- `Ok(None)` -> ambiguous result. Obligation was neither a success\n-  nor a failure. It is assumed that further attempts to process the\n-  obligation will yield the same result unless something in the\n-  surrounding environment changes.\n-- `Ok(Some(C))` - the obligation was *shallowly successful*. The\n-  vector `C` is a list of subobligations. The meaning of this is that\n-  `O` was successful on the assumption that all the obligations in `C`\n-  are also successful. Therefore, `O` is only considered a \"true\"\n-  success if `C` is empty. Otherwise, `O` is put into a suspended\n-  state and the obligations in `C` become the new pending\n-  obligations. They will be processed the next time you call\n-  `process_obligations`.\n-- `Err(E)` -> obligation failed with error `E`. We will collect this\n-  error and return it from `process_obligations`, along with the\n-  \"backtrace\" of obligations (that is, the list of obligations up to\n-  and including the root of the failed obligation). No further\n-  obligations from that same tree will be processed, since the tree is\n-  now considered to be in error.\n-\n-When the call to `process_obligations` completes, you get back an `Outcome`,\n-which includes three bits of information:\n-\n-- `completed`: a list of obligations where processing was fully\n-  completed without error (meaning that all transitive subobligations\n-  have also been completed). So, for example, if the callback from\n-  `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n-  then `O` will be considered completed right away if `C` is the\n-  empty vector. Otherwise it will only be considered completed once\n-  all the obligations in `C` have been found completed.\n-- `errors`: a list of errors that occurred and associated backtraces\n-  at the time of error, which can be used to give context to the user.\n-- `stalled`: if true, then none of the existing obligations were\n-  *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n-  This implies that all obligations were either errors or returned an\n-  ambiguous result, which means that any further calls to\n-  `process_obligations` would simply yield back further ambiguous\n-  results. This is used by the `FulfillmentContext` to decide when it\n-  has reached a steady state.\n-\n-#### Snapshots\n-\n-The `ObligationForest` supports a limited form of snapshots; see\n-`start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n-particular, you can use a snapshot to roll back new root\n-obligations. However, it is an error to attempt to\n-`process_obligations` during a snapshot.\n-\n-### Implementation details\n-\n-For the most part, comments specific to the implementation are in the\n-code.  This file only contains a very high-level overview. Basically,\n-the forest is stored in a vector. Each element of the vector is a node\n-in some tree. Each node in the vector has the index of an (optional)\n-parent and (for convenience) its root (which may be itself). It also\n-has a current state, described by `NodeState`. After each\n-processing step, we compress the vector to remove completed and error\n-nodes, which aren't needed anymore."}, {"sha": "9dd7d204f0373d5ccea71f87c629a3d33b5f6176", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,9 +1,84 @@\n //! The `ObligationForest` is a utility data structure used in trait\n-//! matching to track the set of outstanding obligations (those not\n-//! yet resolved to success or error). It also tracks the \"backtrace\"\n-//! of each pending obligation (why we are trying to figure this out\n-//! in the first place). See README.md for a general overview of how\n-//! to use this class.\n+//! matching to track the set of outstanding obligations (those not yet\n+//! resolved to success or error). It also tracks the \"backtrace\" of each\n+//! pending obligation (why we are trying to figure this out in the first\n+//! place).\n+//!\n+//! ### External view\n+//!\n+//! `ObligationForest` supports two main public operations (there are a\n+//! few others not discussed here):\n+//!\n+//! 1. Add a new root obligations (`push_tree`).\n+//! 2. Process the pending obligations (`process_obligations`).\n+//!\n+//! When a new obligation `N` is added, it becomes the root of an\n+//! obligation tree. This tree can also carry some per-tree state `T`,\n+//! which is given at the same time. This tree is a singleton to start, so\n+//! `N` is both the root and the only leaf. Each time the\n+//! `process_obligations` method is called, it will invoke its callback\n+//! with every pending obligation (so that will include `N`, the first\n+//! time). The callback also receives a (mutable) reference to the\n+//! per-tree state `T`. The callback should process the obligation `O`\n+//! that it is given and return one of three results:\n+//!\n+//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//!   nor a failure. It is assumed that further attempts to process the\n+//!   obligation will yield the same result unless something in the\n+//!   surrounding environment changes.\n+//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//!   vector `C` is a list of subobligations. The meaning of this is that\n+//!   `O` was successful on the assumption that all the obligations in `C`\n+//!   are also successful. Therefore, `O` is only considered a \"true\"\n+//!   success if `C` is empty. Otherwise, `O` is put into a suspended\n+//!   state and the obligations in `C` become the new pending\n+//!   obligations. They will be processed the next time you call\n+//!   `process_obligations`.\n+//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//!   error and return it from `process_obligations`, along with the\n+//!   \"backtrace\" of obligations (that is, the list of obligations up to\n+//!   and including the root of the failed obligation). No further\n+//!   obligations from that same tree will be processed, since the tree is\n+//!   now considered to be in error.\n+//!\n+//! When the call to `process_obligations` completes, you get back an `Outcome`,\n+//! which includes three bits of information:\n+//!\n+//! - `completed`: a list of obligations where processing was fully\n+//!   completed without error (meaning that all transitive subobligations\n+//!   have also been completed). So, for example, if the callback from\n+//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   then `O` will be considered completed right away if `C` is the\n+//!   empty vector. Otherwise it will only be considered completed once\n+//!   all the obligations in `C` have been found completed.\n+//! - `errors`: a list of errors that occurred and associated backtraces\n+//!   at the time of error, which can be used to give context to the user.\n+//! - `stalled`: if true, then none of the existing obligations were\n+//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   This implies that all obligations were either errors or returned an\n+//!   ambiguous result, which means that any further calls to\n+//!   `process_obligations` would simply yield back further ambiguous\n+//!   results. This is used by the `FulfillmentContext` to decide when it\n+//!   has reached a steady state.\n+//!\n+//! #### Snapshots\n+//!\n+//! The `ObligationForest` supports a limited form of snapshots; see\n+//! `start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+//! particular, you can use a snapshot to roll back new root\n+//! obligations. However, it is an error to attempt to\n+//! `process_obligations` during a snapshot.\n+//!\n+//! ### Implementation details\n+//!\n+//! For the most part, comments specific to the implementation are in the\n+//! code.  This file only contains a very high-level overview. Basically,\n+//! the forest is stored in a vector. Each element of the vector is a node\n+//! in some tree. Each node in the vector has the index of an (optional)\n+//! parent and (for convenience) its root (which may be itself). It also\n+//! has a current state, described by `NodeState`. After each\n+//! processing step, we compress the vector to remove completed and error\n+//! nodes, which aren't needed anymore.\n \n use fx::{FxHashMap, FxHashSet};\n "}, {"sha": "56b87feb82b2c34f2ce9bf93e14fe72489960f47", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -198,19 +198,38 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let place = &self.move_data.move_paths[mpi].place;\n \n                 let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n-                let note_msg = match self.describe_place_with_options(\n-                    place,\n-                    IncludingDowncast(true),\n-                ) {\n-                    Some(name) => format!(\"`{}`\", name),\n+                let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n+                let note_msg = match opt_name {\n+                    Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n-\n-                err.note(&format!(\n-                    \"move occurs because {} has type `{}`, \\\n-                     which does not implement the `Copy` trait\",\n-                    note_msg, ty\n-                ));\n+                if let ty::TyKind::Param(param_ty) = ty.sty {\n+                    let tcx = self.infcx.tcx;\n+                    let generics = tcx.generics_of(self.mir_def_id);\n+                    let def_id = generics.type_param(&param_ty, tcx).def_id;\n+                    if let Some(sp) = tcx.hir().span_if_local(def_id) {\n+                        err.span_label(\n+                            sp,\n+                            \"consider adding a `Copy` constraint to this type argument\",\n+                        );\n+                    }\n+                }\n+                if let Place::Local(local) = place {\n+                    let decl = &self.mir.local_decls[*local];\n+                    err.span_label(\n+                        decl.source_info.span,\n+                        format!(\n+                            \"move occurs because {} has type `{}`, \\\n+                                which does not implement the `Copy` trait\",\n+                            note_msg, ty,\n+                    ));\n+                } else {\n+                    err.note(&format!(\n+                        \"move occurs because {} has type `{}`, \\\n+                         which does not implement the `Copy` trait\",\n+                        note_msg, ty\n+                    ));\n+                }\n             }\n \n             if let Some((_, mut old_err)) = self.move_error_reported"}, {"sha": "bc63f8b6ac854a460261d99fd5e53061c4cdd86f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -355,7 +355,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(tcx, true));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n@@ -409,7 +409,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "431cc0d52b4c8b4d6aa629ae761c5ba1cce4c26b", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -159,14 +159,14 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n+                to_string_internal(tcx, \"fn \", instance, debug)\n             },\n             MonoItem::Static(def_id) => {\n                 let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n-                to_string_internal(tcx, \"static \", instance)\n+                to_string_internal(tcx, \"static \", instance, debug)\n             },\n             MonoItem::GlobalAsm(..) => {\n                 \"global_asm\".to_string()\n@@ -175,12 +175,13 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n \n         fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         prefix: &str,\n-                                        instance: Instance<'tcx>)\n+                                        instance: Instance<'tcx>,\n+                                        debug: bool)\n                                         -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             let printer = DefPathBasedNames::new(tcx, false, false);\n-            printer.push_instance_as_string(instance, &mut result);\n+            printer.push_instance_as_string(instance, &mut result, debug);\n             result\n         }\n     }\n@@ -238,7 +239,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n         }\n     }\n \n-    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String) {\n+    // Pushes the type name of the specified type to the provided string.\n+    // If 'debug' is true, printing normally unprintable types is allowed\n+    // (e.g. ty::GeneratorWitness). This parameter should only be set when\n+    // this method is being used for logging purposes (e.g. with debug! or info!)\n+    // When being used for codegen purposes, 'debug' should be set to 'false'\n+    // in order to catch unexpected types that should never end up in a type name\n+    pub fn push_type_name(&self, t: Ty<'tcx>, output: &mut String, debug: bool) {\n         match t.sty {\n             ty::Bool              => output.push_str(\"bool\"),\n             ty::Char              => output.push_str(\"char\"),\n@@ -260,12 +267,12 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n-                self.push_type_params(substs, iter::empty(), output);\n+                self.push_type_params(substs, iter::empty(), output, debug);\n             },\n             ty::Tuple(component_types) => {\n                 output.push('(');\n                 for &component_type in component_types {\n-                    self.push_type_name(component_type, output);\n+                    self.push_type_name(component_type, output, debug);\n                     output.push_str(\", \");\n                 }\n                 if !component_types.is_empty() {\n@@ -281,25 +288,25 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     hir::MutMutable => output.push_str(\"mut \"),\n                 }\n \n-                self.push_type_name(inner_type, output);\n+                self.push_type_name(inner_type, output, debug);\n             },\n             ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n                 if mutbl == hir::MutMutable {\n                     output.push_str(\"mut \");\n                 }\n \n-                self.push_type_name(inner_type, output);\n+                self.push_type_name(inner_type, output, debug);\n             },\n             ty::Array(inner_type, len) => {\n                 output.push('[');\n-                self.push_type_name(inner_type, output);\n+                self.push_type_name(inner_type, output, debug);\n                 write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n                 output.push(']');\n             },\n             ty::Slice(inner_type) => {\n                 output.push('[');\n-                self.push_type_name(inner_type, output);\n+                self.push_type_name(inner_type, output, debug);\n                 output.push(']');\n             },\n             ty::Dynamic(ref trait_data, ..) => {\n@@ -309,6 +316,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                         principal.skip_binder().substs,\n                         trait_data.projection_bounds(),\n                         output,\n+                        debug\n                     );\n                 } else {\n                     output.push_str(\"dyn '_\");\n@@ -338,7 +346,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 if !sig.inputs().is_empty() {\n                     for &parameter_type in sig.inputs() {\n-                        self.push_type_name(parameter_type, output);\n+                        self.push_type_name(parameter_type, output, debug);\n                         output.push_str(\", \");\n                     }\n                     output.pop();\n@@ -357,15 +365,15 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 if !sig.output().is_unit() {\n                     output.push_str(\" -> \");\n-                    self.push_type_name(sig.output(), output);\n+                    self.push_type_name(sig.output(), output, debug);\n                 }\n             },\n             ty::Generator(def_id, GeneratorSubsts { ref substs }, _) |\n             ty::Closure(def_id, ClosureSubsts { ref substs }) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));\n                 let substs = substs.truncate_to(self.tcx, generics);\n-                self.push_type_params(substs, iter::empty(), output);\n+                self.push_type_params(substs, iter::empty(), output, debug);\n             }\n             ty::Error |\n             ty::Bound(..) |\n@@ -376,8 +384,12 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::Param(_) |\n             ty::GeneratorWitness(_) |\n             ty::Opaque(..) => {\n-                bug!(\"DefPathBasedNames: Trying to create type name for \\\n+                if debug {\n+                    output.push_str(&format!(\"`{:?}`\", t));\n+                } else {\n+                    bug!(\"DefPathBasedNames: Trying to create type name for \\\n                                          unexpected type: {:?}\", t);\n+                }\n             }\n         }\n     }\n@@ -412,7 +424,8 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     fn push_type_params<I>(&self,\n                             substs: &Substs<'tcx>,\n                             projections: I,\n-                            output: &mut String)\n+                            output: &mut String,\n+                            debug: bool)\n         where I: Iterator<Item=ty::PolyExistentialProjection<'tcx>>\n     {\n         let mut projections = projections.peekable();\n@@ -423,7 +436,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n         output.push('<');\n \n         for type_parameter in substs.types() {\n-            self.push_type_name(type_parameter, output);\n+            self.push_type_name(type_parameter, output, debug);\n             output.push_str(\", \");\n         }\n \n@@ -432,7 +445,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             let name = &self.tcx.associated_item(projection.item_def_id).ident.as_str();\n             output.push_str(name);\n             output.push_str(\"=\");\n-            self.push_type_name(projection.ty, output);\n+            self.push_type_name(projection.ty, output, debug);\n             output.push_str(\", \");\n         }\n \n@@ -444,8 +457,9 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n     pub fn push_instance_as_string(&self,\n                                    instance: Instance<'tcx>,\n-                                   output: &mut String) {\n+                                   output: &mut String,\n+                                   debug: bool) {\n         self.push_def_path(instance.def_id(), output);\n-        self.push_type_params(instance.substs, iter::empty(), output);\n+        self.push_type_params(instance.substs, iter::empty(), output, debug);\n     }\n }"}, {"sha": "569e4c828f6014ef845b3a4fd1a3910a07805b0a", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -879,7 +879,7 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    .unwrap_or(\"<no hash>\");\n \n                 debug!(\" - {} [{:?}] [{}]\",\n-                       mono_item.to_string(tcx),\n+                       mono_item.to_string(tcx, true),\n                        linkage,\n                        symbol_hash);\n             }\n@@ -971,7 +971,7 @@ fn collect_and_partition_mono_items<'a, 'tcx>(\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(tcx);\n+                let mut output = i.to_string(tcx, false);\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);"}, {"sha": "59b5aba93cad4664d6554d1e27d364997f5eb38d", "filename": "src/test/ui/binop/binop-consume-args.nll.stderr", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,253 @@\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:7:10\n+   |\n+LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs + rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:8:10\n+   |\n+LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs + rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:13:10\n+   |\n+LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs - rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:14:10\n+   |\n+LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs - rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:19:10\n+   |\n+LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs * rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:20:10\n+   |\n+LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs * rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:25:10\n+   |\n+LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs / rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:26:10\n+   |\n+LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs / rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:31:10\n+   |\n+LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs % rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:32:10\n+   |\n+LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs % rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:37:10\n+   |\n+LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |           -                           --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |           |\n+   |           consider adding a `Copy` constraint to this type argument\n+LL |     lhs & rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:38:10\n+   |\n+LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                                    |\n+   |                                    consider adding a `Copy` constraint to this type argument\n+LL |     lhs & rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:43:10\n+   |\n+LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |          -                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |          |\n+   |          consider adding a `Copy` constraint to this type argument\n+LL |     lhs | rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:44:10\n+   |\n+LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                                  -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                                  |\n+   |                                  consider adding a `Copy` constraint to this type argument\n+LL |     lhs | rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:49:10\n+   |\n+LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |           -                           --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |           |\n+   |           consider adding a `Copy` constraint to this type argument\n+LL |     lhs ^ rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:50:10\n+   |\n+LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                                    |\n+   |                                    consider adding a `Copy` constraint to this type argument\n+LL |     lhs ^ rhs;\n+   |           --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:55:10\n+   |\n+LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs << rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:56:10\n+   |\n+LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs << rhs;\n+   |            --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `lhs`\n+  --> $DIR/binop-consume-args.rs:61:10\n+   |\n+LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |        -                        --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     lhs >> rhs;\n+   |     --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+   |          ^^^ value used here after move\n+\n+error[E0382]: use of moved value: `rhs`\n+  --> $DIR/binop-consume-args.rs:62:10\n+   |\n+LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n+   |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n+   |                              |\n+   |                              consider adding a `Copy` constraint to this type argument\n+LL |     lhs >> rhs;\n+   |            --- value moved here\n+LL |     drop(lhs);  //~ ERROR use of moved value: `lhs`\n+LL |     drop(rhs);  //~ ERROR use of moved value: `rhs`\n+   |          ^^^ value used here after move\n+\n+error: aborting due to 20 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "7c84e8833a9e6dfb860094e54cb2887762721c6d", "filename": "src/test/ui/binop/binop-move-semantics.nll.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,24 +1,28 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n+LL | fn double_move<T: Add<Output=()>>(x: T) {\n+   |                -                  - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                |\n+   |                consider adding a `Copy` constraint to this type argument\n LL |     x\n    |     - value moved here\n LL |     +\n LL |     x;  //~ ERROR: use of moved value\n    |     ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:14:5\n    |\n+LL | fn move_then_borrow<T: Add<Output=()> + Clone>(x: T) {\n+   |                     -                          - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                     |\n+   |                     consider adding a `Copy` constraint to this type argument\n LL |     x\n    |     - value moved here\n LL |     +\n LL |     x.clone();  //~ ERROR: use of moved value\n    |     ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait\n \n error[E0505]: cannot move out of `x` because it is borrowed\n   --> $DIR/binop-move-semantics.rs:21:5"}, {"sha": "86e4832b3873ce49ae1bc09a2247e1b3e5af6fde", "filename": "src/test/ui/borrowck/borrowck-asm.ast.nll.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.ast.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,14 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-asm.rs:27:17\n    |\n+LL |         let x = &mut 0isize;\n+   |             - move occurs because `x` has type `&mut isize`, which does not implement the `Copy` trait\n+LL |         unsafe {\n LL |             asm!(\"nop\" : : \"r\"(x));\n    |                                - value moved here\n LL |         }\n LL |         let z = x;  //[ast]~ ERROR use of moved value: `x`\n    |                 ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `&mut isize`, which does not implement the `Copy` trait\n \n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/borrowck-asm.rs:35:32\n@@ -66,12 +67,13 @@ LL |         let z = y;\n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-asm.rs:86:40\n    |\n+LL |         let x = &mut 2;\n+   |             - move occurs because `x` has type `&mut i32`, which does not implement the `Copy` trait\n+LL |         unsafe {\n LL |             asm!(\"nop\" : : \"r\"(x), \"r\"(x) );    //[ast]~ ERROR use of moved value\n    |                                -       ^ value used here after move\n    |                                |\n    |                                value moved here\n-   |\n-   = note: move occurs because `x` has type `&mut i32`, which does not implement the `Copy` trait\n \n error: aborting due to 7 previous errors\n "}, {"sha": "86e4832b3873ce49ae1bc09a2247e1b3e5af6fde", "filename": "src/test/ui/borrowck/borrowck-asm.mir.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-asm.mir.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,14 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-asm.rs:27:17\n    |\n+LL |         let x = &mut 0isize;\n+   |             - move occurs because `x` has type `&mut isize`, which does not implement the `Copy` trait\n+LL |         unsafe {\n LL |             asm!(\"nop\" : : \"r\"(x));\n    |                                - value moved here\n LL |         }\n LL |         let z = x;  //[ast]~ ERROR use of moved value: `x`\n    |                 ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `&mut isize`, which does not implement the `Copy` trait\n \n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/borrowck-asm.rs:35:32\n@@ -66,12 +67,13 @@ LL |         let z = y;\n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-asm.rs:86:40\n    |\n+LL |         let x = &mut 2;\n+   |             - move occurs because `x` has type `&mut i32`, which does not implement the `Copy` trait\n+LL |         unsafe {\n LL |             asm!(\"nop\" : : \"r\"(x), \"r\"(x) );    //[ast]~ ERROR use of moved value\n    |                                -       ^ value used here after move\n    |                                |\n    |                                value moved here\n-   |\n-   = note: move occurs because `x` has type `&mut i32`, which does not implement the `Copy` trait\n \n error: aborting due to 7 previous errors\n "}, {"sha": "ea7683a91adfe92d21d6bb8a2cd7e1cd79fcb954", "filename": "src/test/ui/borrowck/borrowck-consume-unsize-vec.nll.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-unsize-vec.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `b`\n+  --> $DIR/borrowck-consume-unsize-vec.rs:8:13\n+   |\n+LL | fn foo(b: Box<[i32;5]>) {\n+   |        - move occurs because `b` has type `std::boxed::Box<[i32; 5]>`, which does not implement the `Copy` trait\n+LL |     consume(b);\n+   |             - value moved here\n+LL |     consume(b); //~ ERROR use of moved value\n+   |             ^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "15cf359326be96aea02e028e6ea26ba6a6d351c2", "filename": "src/test/ui/borrowck/borrowck-consume-upcast-box.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-consume-upcast-box.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `b`\n   --> $DIR/borrowck-consume-upcast-box.rs:10:13\n    |\n+LL | fn foo(b: Box<Foo+Send>) {\n+   |        - move occurs because `b` has type `std::boxed::Box<dyn Foo + std::marker::Send>`, which does not implement the `Copy` trait\n LL |     consume(b);\n    |             - value moved here\n LL |     consume(b); //~ ERROR use of moved value\n    |             ^ value used here after move\n-   |\n-   = note: move occurs because `b` has type `std::boxed::Box<dyn Foo + std::marker::Send>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "07b597f480feba33d7c40c018b55c80a6b18de8f", "filename": "src/test/ui/borrowck/borrowck-drop-from-guard.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-drop-from-guard.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,14 @@\n error[E0382]: use of moved value: `my_str`\n   --> $DIR/borrowck-drop-from-guard.rs:11:23\n    |\n+LL |     let my_str = \"hello\".to_owned();\n+   |         ------ move occurs because `my_str` has type `std::string::String`, which does not implement the `Copy` trait\n+LL |     match Some(42) {\n LL |         Some(_) if { drop(my_str); false } => {}\n    |                           ------ value moved here\n LL |         Some(_) => {}\n LL |         None => { foo(my_str); } //~ ERROR [E0382]\n    |                       ^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `my_str` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "de4894d5b526b8e5baf7c6400836cbe765e3e502", "filename": "src/test/ui/borrowck/borrowck-issue-48962.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-48962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-48962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-issue-48962.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,22 +1,22 @@\n error[E0382]: use of moved value: `src`\n   --> $DIR/borrowck-issue-48962.rs:16:5\n    |\n+LL |     let mut src = &mut node;\n+   |         ------- move occurs because `src` has type `&mut Node`, which does not implement the `Copy` trait\n LL |     {src};\n    |      --- value moved here\n LL |     src.next = None; //~ ERROR use of moved value: `src` [E0382]\n    |     ^^^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `src` has type `&mut Node`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `src`\n   --> $DIR/borrowck-issue-48962.rs:22:5\n    |\n+LL |     let mut src = &mut (22, 44);\n+   |         ------- move occurs because `src` has type `&mut (i32, i32)`, which does not implement the `Copy` trait\n LL |     {src};\n    |      --- value moved here\n LL |     src.0 = 66; //~ ERROR use of moved value: `src` [E0382]\n    |     ^^^^^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `src` has type `&mut (i32, i32)`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "095ae7f56b22e5643219552e332d6538596c2a4c", "filename": "src/test/ui/borrowck/borrowck-loan-in-overloaded-op.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-loan-in-overloaded-op.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrowck-loan-in-overloaded-op.rs:21:20\n    |\n+LL |     let x = Foo(box 3);\n+   |         - move occurs because `x` has type `Foo`, which does not implement the `Copy` trait\n LL |     let _y = {x} + x.clone(); // the `{x}` forces a move to occur\n    |               -    ^ value borrowed here after move\n    |               |\n    |               value moved here\n-   |\n-   = note: move occurs because `x` has type `Foo`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "0789926563ce7fe6fdfcd07de377a7d2435cc185", "filename": "src/test/ui/borrowck/borrowck-move-moved-value-into-closure.ast.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.ast.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,6 +1,9 @@\n error[E0382]: use of moved value: `t`\n   --> $DIR/borrowck-move-moved-value-into-closure.rs:14:12\n    |\n+LL |     let t: Box<_> = box 3;\n+   |         - move occurs because `t` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+LL | \n LL |     call_f(move|| { *t + 1 });\n    |            ------    - variable moved due to use in closure\n    |            |\n@@ -9,8 +12,6 @@ LL |     call_f(move|| { *t + 1 }); //[ast]~ ERROR capture of moved value\n    |            ^^^^^^    - use occurs due to use in closure\n    |            |\n    |            value used here after move\n-   |\n-   = note: move occurs because `t` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "0789926563ce7fe6fdfcd07de377a7d2435cc185", "filename": "src/test/ui/borrowck/borrowck-move-moved-value-into-closure.mir.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-moved-value-into-closure.mir.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,6 +1,9 @@\n error[E0382]: use of moved value: `t`\n   --> $DIR/borrowck-move-moved-value-into-closure.rs:14:12\n    |\n+LL |     let t: Box<_> = box 3;\n+   |         - move occurs because `t` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+LL | \n LL |     call_f(move|| { *t + 1 });\n    |            ------    - variable moved due to use in closure\n    |            |\n@@ -9,8 +12,6 @@ LL |     call_f(move|| { *t + 1 }); //[ast]~ ERROR capture of moved value\n    |            ^^^^^^    - use occurs due to use in closure\n    |            |\n    |            value used here after move\n-   |\n-   = note: move occurs because `t` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "d0065a2e7dc3d817ee80f60761804a3b0403a91f", "filename": "src/test/ui/borrowck/borrowck-multiple-captures.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-multiple-captures.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -29,28 +29,28 @@ LL |     borrow(&*p2);\n error[E0382]: use of moved value: `x1`\n   --> $DIR/borrowck-multiple-captures.rs:25:19\n    |\n+LL |     let x1: Box<_> = box 1;\n+   |         -- move occurs because `x1` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n LL |     drop(x1);\n    |          -- value moved here\n ...\n LL |     thread::spawn(move|| {\n    |                   ^^^^^^ value used here after move\n LL |         drop(x1); //~ ERROR capture of moved value: `x1`\n    |              -- use occurs due to use in closure\n-   |\n-   = note: move occurs because `x1` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x2`\n   --> $DIR/borrowck-multiple-captures.rs:25:19\n    |\n+LL |     let x2: Box<_> = box 2;\n+   |         -- move occurs because `x2` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n LL |     drop(x2);\n    |          -- value moved here\n LL |     thread::spawn(move|| {\n    |                   ^^^^^^ value used here after move\n LL |         drop(x1); //~ ERROR capture of moved value: `x1`\n LL |         drop(x2); //~ ERROR capture of moved value: `x2`\n    |              -- use occurs due to use in closure\n-   |\n-   = note: move occurs because `x2` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-multiple-captures.rs:36:14\n@@ -88,14 +88,14 @@ LL |         drop(x); //~ ERROR use of moved value: `x`\n error[E0382]: use of moved value: `x`\n   --> $DIR/borrowck-multiple-captures.rs:44:19\n    |\n+LL |     let x: Box<_> = box 1;\n+   |         - move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n LL |     drop(x);\n    |          - value moved here\n LL |     thread::spawn(move|| {\n    |                   ^^^^^^ value used here after move\n LL |         drop(x); //~ ERROR capture of moved value: `x`\n    |              - use occurs due to use in closure\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error: aborting due to 8 previous errors\n "}, {"sha": "c5a4c4e005aa7d8177ee6e85b37b13ddd5766758", "filename": "src/test/ui/borrowck/borrowck-overloaded-call.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-call.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-call.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-call.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -20,12 +20,13 @@ LL |     s(3);   //~ ERROR cannot borrow immutable local variable `s` as mutable\n error[E0382]: use of moved value: `s`\n   --> $DIR/borrowck-overloaded-call.rs:75:5\n    |\n+LL |     let s = SFnOnce {\n+   |         - move occurs because `s` has type `SFnOnce`, which does not implement the `Copy` trait\n+...\n LL |     s(\" world\".to_string());\n    |     - value moved here\n LL |     s(\" world\".to_string());    //~ ERROR use of moved value: `s`\n    |     ^ value used here after move\n-   |\n-   = note: move occurs because `s` has type `SFnOnce`, which does not implement the `Copy` trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "de60067f1a613702080d4b60dccd47cbad3177bf", "filename": "src/test/ui/borrowck/borrowck-overloaded-index-move-index.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-overloaded-index-move-index.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -25,13 +25,14 @@ LL |     use_mut(rs);\n error[E0382]: use of moved value: `s`\n   --> $DIR/borrowck-overloaded-index-move-index.rs:53:7\n    |\n+LL |     let mut s = \"hello\".to_string();\n+   |         ----- move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |     println!(\"{}\", f[s]);\n    |                      - value moved here\n ...\n LL |     f[s] = 10;\n    |       ^ value used here after move\n-   |\n-   = note: move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "65f2bd6cfbda9c1b113e6f511051aa3f7f2dd0f0", "filename": "src/test/ui/borrowck/borrowck-partial-reinit-1.nll.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-1.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,22 +1,24 @@\n error[E0382]: assign of moved value: `t`\n   --> $DIR/borrowck-partial-reinit-1.rs:27:5\n    |\n+LL |     let mut t = Test2 { b: None };\n+   |         ----- move occurs because `t` has type `Test2`, which does not implement the `Copy` trait\n+LL |     let u = Test;\n LL |     drop(t);\n    |          - value moved here\n LL |     t.b = Some(u);\n    |     ^^^ value assigned here after move\n-   |\n-   = note: move occurs because `t` has type `Test2`, which does not implement the `Copy` trait\n \n error[E0382]: assign of moved value: `t`\n   --> $DIR/borrowck-partial-reinit-1.rs:33:5\n    |\n+LL |     let mut t = Test3(None);\n+   |         ----- move occurs because `t` has type `Test3`, which does not implement the `Copy` trait\n+LL |     let u = Test;\n LL |     drop(t);\n    |          - value moved here\n LL |     t.0 = Some(u);\n    |     ^^^ value assigned here after move\n-   |\n-   = note: move occurs because `t` has type `Test3`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "36a871fbb12a18d2bc2ef5e59f113be8b3a6bd01", "filename": "src/test/ui/borrowck/borrowck-partial-reinit-2.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-partial-reinit-2.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: assign of moved value: `t`\n   --> $DIR/borrowck-partial-reinit-2.rs:15:5\n    |\n+LL |     let mut t = Test { a: 1, b: None};\n+   |         ----- move occurs because `t` has type `Test`, which does not implement the `Copy` trait\n LL |     let mut u = Test { a: 2, b: Some(Box::new(t))};\n    |                                               - value moved here\n LL |     t.b = Some(Box::new(u));\n    |     ^^^ value assigned here after move\n-   |\n-   = note: move occurs because `t` has type `Test`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "96f3981ac2fe6b0c8eed50b25ebfa8b647df1a84", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -11,12 +11,13 @@ LL |     let _ = (1,x); //~ ERROR use of moved value: `x` (Ast)\n error[E0382]: use of moved value: `x` (Mir)\n   --> $DIR/borrowck-reinit.rs:8:16\n    |\n+LL |     let mut x = Box::new(0);\n+   |         ----- move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+...\n LL |     drop(x);\n    |          - value moved here\n LL |     let _ = (1,x); //~ ERROR use of moved value: `x` (Ast)\n    |                ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "363a5a69a07e394db6db4c63cf3706125b45473a", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -19,12 +19,14 @@ LL |     f(1, 2);    //~ ERROR cannot borrow immutable argument\n error[E0382]: use of moved value: `f`\n   --> $DIR/borrowck-unboxed-closures.rs:12:5\n    |\n+LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n+   |      -                                - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n+   |      |\n+   |      consider adding a `Copy` constraint to this type argument\n LL |     f(1, 2);\n    |     - value moved here\n LL |     f(1, 2);    //~ ERROR use of moved value\n    |     ^ value used here after move\n-   |\n-   = note: move occurs because `f` has type `F`, which does not implement the `Copy` trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e59fef2dc0d2f181305f5869861ac55931ab58b2", "filename": "src/test/ui/borrowck/borrowck-union-move-assign.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move-assign.rs:17:21\n    |\n+LL |             let mut u = U { a: A };\n+   |                 ----- move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |             let a = u.a;\n    |                     --- value moved here\n LL |             let a = u.a; //~ ERROR use of moved value: `u.a`\n    |                     ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "1392a7931c30a157bb0e3f5eaa4e384bebd484c2", "filename": "src/test/ui/borrowck/borrowck-union-move.nll.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,62 +1,62 @@\n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:26:21\n    |\n+LL |             let mut u = Unn { n1: NonCopy };\n+   |                 ----- move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n LL |             let a = u.n1;\n    |                     ---- value moved here\n LL |             let a = u.n1; //~ ERROR use of moved value: `u.n1`\n    |                     ^^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:31:21\n    |\n+LL |             let mut u = Unn { n1: NonCopy };\n+   |                 ----- move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n LL |             let a = u.n1;\n    |                     ---- value moved here\n LL |             let a = u; //~ ERROR use of partially moved value: `u`\n    |                     ^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:36:21\n    |\n+LL |             let mut u = Unn { n1: NonCopy };\n+   |                 ----- move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n LL |             let a = u.n1;\n    |                     ---- value moved here\n LL |             let a = u.n2; //~ ERROR use of moved value: `u.n2`\n    |                     ^^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:63:21\n    |\n+LL |             let mut u = Ucn { c: Copy };\n+   |                 ----- move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n LL |             let a = u.n;\n    |                     --- value moved here\n LL |             let a = u.n; //~ ERROR use of moved value: `u.n`\n    |                     ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:68:21\n    |\n+LL |             let mut u = Ucn { c: Copy };\n+   |                 ----- move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n LL |             let a = u.n;\n    |                     --- value moved here\n LL |             let a = u.c; //~ ERROR use of moved value: `u.c`\n    |                     ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:83:21\n    |\n+LL |             let mut u = Ucn { c: Copy };\n+   |                 ----- move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n LL |             let a = u.n;\n    |                     --- value moved here\n LL |             let a = u; //~ ERROR use of partially moved value: `u`\n    |                     ^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n \n error: aborting due to 6 previous errors\n "}, {"sha": "42aa03817023813b752a67cc69ba2a93ed5a21a5", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,32 +1,32 @@\n error[E0382]: assign to part of moved value: `t`\n   --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:23:9\n    |\n+LL |         let mut t: Tuple = (S(0), 0);\n+   |             ----- move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n LL |         drop(t);\n    |              - value moved here\n LL |         t.0 = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `u`\n   --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:34:9\n    |\n+LL |         let mut u: Tpair = Tpair(S(0), 0);\n+   |             ----- move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n LL |         drop(u);\n    |              - value moved here\n LL |         u.0 = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `v`\n   --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:45:9\n    |\n+LL |         let mut v: Spair = Spair { x: S(0), y: 0 };\n+   |             ----- move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n LL |         drop(v);\n    |              - value moved here\n LL |         v.x = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "1184907f307cb8e541568f794858646e61c2aee8", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -10,12 +10,12 @@ LL |         t.0 = S(1);\n error[E0382]: assign to part of moved value: `t`\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n    |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n LL |         drop(t);\n    |              - value moved here\n LL |         t.0 = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n \n error[E0594]: cannot assign to `t.1`, as `t` is not declared as mutable\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:27:9\n@@ -38,12 +38,12 @@ LL |         u.0 = S(1);\n error[E0382]: assign to part of moved value: `u`\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n    |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n LL |         drop(u);\n    |              - value moved here\n LL |         u.0 = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n \n error[E0594]: cannot assign to `u.1`, as `u` is not declared as mutable\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:42:9\n@@ -66,12 +66,12 @@ LL |         v.x = S(1);\n error[E0382]: assign to part of moved value: `v`\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n    |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n LL |         drop(v);\n    |              - value moved here\n LL |         v.x = S(1);\n    |         ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n \n error[E0594]: cannot assign to `v.y`, as `v` is not declared as mutable\n   --> $DIR/issue-54499-field-mutation-of-moved-out.rs:57:9"}, {"sha": "d026f81b7aad6f2ea7af7620f97c2f02dc0759f2", "filename": "src/test/ui/borrowck/two-phase-nonrecv-autoref.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.ast.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -10,6 +10,8 @@ LL |         f(f(10));\n error[E0382]: use of moved value: `*f`\n   --> $DIR/two-phase-nonrecv-autoref.rs:69:11\n    |\n+LL |     fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n+   |                     - consider adding a `Copy` constraint to this type argument\n LL |         f(f(10));\n    |         - ^ value used here after move\n    |         |"}, {"sha": "d026f81b7aad6f2ea7af7620f97c2f02dc0759f2", "filename": "src/test/ui/borrowck/two-phase-nonrecv-autoref.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-nonrecv-autoref.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -10,6 +10,8 @@ LL |         f(f(10));\n error[E0382]: use of moved value: `*f`\n   --> $DIR/two-phase-nonrecv-autoref.rs:69:11\n    |\n+LL |     fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n+   |                     - consider adding a `Copy` constraint to this type argument\n LL |         f(f(10));\n    |         - ^ value used here after move\n    |         |"}, {"sha": "3b8507a067ded31725ab9219b7ce445c9417ca9a", "filename": "src/test/ui/codemap_tests/tab_3.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,13 @@\n error[E0382]: borrow of moved value: `some_vec`\n   --> $DIR/tab_3.rs:7:20\n    |\n+LL |     let some_vec = vec![\"hi\"];\n+   |         -------- move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n LL |     some_vec.into_iter();\n    |     -------- value moved here\n LL |     {\n LL |         println!(\"{:?}\", some_vec); //~ ERROR use of moved\n    |                          ^^^^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "65b9beb91f90ca00cddda0ff6bf16cb6d8c1edc0", "filename": "src/test/ui/issues/auxiliary/issue-56943.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-56943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-56943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-56943.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,3 @@\n+pub struct S;\n+mod m { pub struct S; }\n+pub use crate::m::S as S2;"}, {"sha": "20198f19dd5f54286075b5d9d4631ef28fbe6313", "filename": "src/test/ui/issues/issue-17385.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,23 +1,23 @@\n error[E0382]: use of moved value: `foo`\n   --> $DIR/issue-17385.rs:19:11\n    |\n+LL |     let foo = X(1);\n+   |         --- move occurs because `foo` has type `X`, which does not implement the `Copy` trait\n LL |     drop(foo);\n    |          --- value moved here\n LL |     match foo { //~ ERROR use of moved value\n LL |         X(1) => (),\n    |           ^ value used here after move\n-   |\n-   = note: move occurs because `foo` has type `X`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `e`\n   --> $DIR/issue-17385.rs:25:11\n    |\n+LL |     let e = Enum::Variant2;\n+   |         - move occurs because `e` has type `Enum`, which does not implement the `Copy` trait\n LL |     drop(e);\n    |          - value moved here\n LL |     match e { //~ ERROR use of moved value\n    |           ^ value used here after move\n-   |\n-   = note: move occurs because `e` has type `Enum`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "310535434cd0807185a8e358cf98d7653b8fcba8", "filename": "src/test/ui/issues/issue-24357.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-24357.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-24357.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24357.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,15 +1,15 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/issue-24357.rs:6:12\n    |\n+LL |    let x = NoCopy;\n+   |        - move occurs because `x` has type `NoCopy`, which does not implement the `Copy` trait\n LL |    let f = move || { let y = x; };\n    |            -------           - variable moved due to use in closure\n    |            |\n    |            value moved into closure here\n LL |    //~^ NOTE value moved (into closure) here\n LL |    let z = x;\n    |            ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `NoCopy`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "ba5403cca4d067f70f3507090e58158578d196a3", "filename": "src/test/ui/issues/issue-25700.nll.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-25700.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-25700.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25700.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `t`\n+  --> $DIR/issue-25700.rs:13:10\n+   |\n+LL |     let t = S::<()>(None);\n+   |         - move occurs because `t` has type `S<()>`, which does not implement the `Copy` trait\n+LL |     drop(t);\n+   |          - value moved here\n+LL |     drop(t); //~ ERROR use of moved value\n+   |          ^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "6993419326c8e259323af3375cad48dba34e786c", "filename": "src/test/ui/issues/issue-27282-move-match-input-into-guard.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,15 +1,16 @@\n error[E0382]: use of moved value: `b`\n   --> $DIR/issue-27282-move-match-input-into-guard.rs:18:14\n    |\n+LL |     let b = &mut true;\n+   |         - move occurs because `b` has type `&mut bool`, which does not implement the `Copy` trait\n+...\n LL |         _ if { (|| { let bar = b; *bar = false; })();\n    |                 --             - variable moved due to use in closure\n    |                 |\n    |                 value moved into closure here\n LL |                      false } => { },\n LL |         &mut true => { println!(\"You might think we should get here\"); },\n    |              ^^^^ value used here after move\n-   |\n-   = note: move occurs because `b` has type `&mut bool`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "7928af5d5a5cd654df408173042b7b43be444fb4", "filename": "src/test/ui/issues/issue-29723.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29723.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,14 @@\n error[E0382]: use of moved value: `s`\n   --> $DIR/issue-29723.rs:12:13\n    |\n+LL |     let s = String::new();\n+   |         - move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n+LL |     let _s = match 0 {\n LL |         0 if { drop(s); false } => String::from(\"oops\"),\n    |                     - value moved here\n ...\n LL |             s\n    |             ^ value used here after move\n-   |\n-   = note: move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "226c21446b1ed5022795e7c8445e6cf09a4d2d75", "filename": "src/test/ui/issues/issue-34721.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,34 @@\n+#![feature(nll)]\n+\n+pub trait Foo {\n+    fn zero(self) -> Self;\n+}\n+\n+impl Foo for u32 {\n+    fn zero(self) -> u32 { 0u32 }\n+}\n+\n+pub mod bar {\n+    pub use Foo;\n+    pub fn bar<T: Foo>(x: T) -> T {\n+      x.zero()\n+    }\n+}\n+\n+mod baz {\n+    use bar;\n+    use Foo;\n+    pub fn baz<T: Foo>(x: T) -> T {\n+        if 0 == 1 {\n+            bar::bar(x.zero())\n+        } else {\n+            x.zero()\n+        };\n+        x.zero()\n+        //~^ ERROR use of moved value\n+    }\n+}\n+\n+fn main() {\n+    let _ = baz::baz(0u32);\n+}"}, {"sha": "2ed7b543e713c8b691e0e098b639793a995d9929", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,20 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/issue-34721.rs:27:9\n+   |\n+LL |     pub fn baz<T: Foo>(x: T) -> T {\n+   |                -       - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                |\n+   |                consider adding a `Copy` constraint to this type argument\n+LL |         if 0 == 1 {\n+LL |             bar::bar(x.zero())\n+   |                      - value moved here\n+LL |         } else {\n+LL |             x.zero()\n+   |             - value moved here\n+LL |         };\n+LL |         x.zero()\n+   |         ^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "23cc88bab52d54dd7e83d3d4828784cd48e72394", "filename": "src/test/ui/issues/issue-42796.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-42796.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-42796.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42796.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,13 @@\n error[E0382]: borrow of moved value: `s`\n   --> $DIR/issue-42796.rs:18:20\n    |\n+LL |     let s = \"Hello!\".to_owned();\n+   |         - move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let mut s_copy = s;\n    |                      - value moved here\n ...\n LL |     println!(\"{}\", s); //~ ERROR use of moved value\n    |                    ^ value borrowed here after move\n-   |\n-   = note: move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "8fc77abdbf58827101780bf20e448cd03d83ba1c", "filename": "src/test/ui/issues/issue-56943.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-56943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-56943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56943.rs?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:issue-56943.rs\n+\n+extern crate issue_56943;\n+\n+fn main() {\n+    let _: issue_56943::S = issue_56943::S2;\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "27202051524c9be592d84314ecbf49dee6a33007", "filename": "src/test/ui/issues/issue-56943.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56943.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-56943.rs:6:29\n+   |\n+LL |     let _: issue_56943::S = issue_56943::S2;\n+   |                             ^^^^^^^^^^^^^^^ expected struct `issue_56943::S`, found struct `issue_56943::S2`\n+   |\n+   = note: expected type `issue_56943::S`\n+              found type `issue_56943::S2`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "521304d560554850b7cfaa1498471c9c0a879774", "filename": "src/test/ui/liveness/liveness-move-call-arg.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-call-arg.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,10 +1,11 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/liveness-move-call-arg.rs:9:14\n    |\n+LL |     let x: Box<isize> = box 25;\n+   |         - move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+LL |     loop {\n LL |         take(x); //~ ERROR use of moved value: `x`\n    |              ^ value moved here, in previous iteration of loop\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "b7e973bc9140d3ef3ef9d788a41ad2948247eede", "filename": "src/test/ui/liveness/liveness-move-in-loop.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-loop.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,10 +1,11 @@\n error[E0382]: use of moved value: `y`\n   --> $DIR/liveness-move-in-loop.rs:11:25\n    |\n+LL |     let y: Box<isize> = box 42;\n+   |         - move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+...\n LL |                     x = y; //~ ERROR use of moved value\n    |                         ^ value moved here, in previous iteration of loop\n-   |\n-   = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "167dcc6b6437207a70fdecfdee6ead7e7eacfab0", "filename": "src/test/ui/liveness/liveness-move-in-while.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-move-in-while.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,13 @@\n error[E0382]: borrow of moved value: `y`\n   --> $DIR/liveness-move-in-while.rs:7:24\n    |\n+LL |     let y: Box<isize> = box 42;\n+   |         - move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n+...\n LL |         println!(\"{}\", y); //~ ERROR use of moved value: `y`\n    |                        ^ value borrowed here after move\n LL |         while true { while true { while true { x = y; x.clone(); } } }\n    |                                                    - value moved here, in previous iteration of loop\n-   |\n-   = note: move occurs because `y` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "36c25882ccd4f6ddfc75b36b44324f0cb957be57", "filename": "src/test/ui/liveness/liveness-use-after-move.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/liveness-use-after-move.rs:6:20\n    |\n+LL |     let x: Box<_> = box 5;\n+   |         - move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n LL |     let y = x;\n    |             - value moved here\n LL |     println!(\"{}\", *x); //~ ERROR use of moved value: `*x`\n    |                    ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "d9367c871165a72d93bbe3714436f74bee56884d", "filename": "src/test/ui/liveness/liveness-use-after-send.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-send.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `message`\n   --> $DIR/liveness-use-after-send.rs:16:20\n    |\n+LL | fn test00_start(ch: Chan<Box<isize>>, message: Box<isize>, _count: Box<isize>) {\n+   |                                       ------- move occurs because `message` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n LL |     send(ch, message);\n    |              ------- value moved here\n LL |     println!(\"{}\", message); //~ ERROR use of moved value: `message`\n    |                    ^^^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `message` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "43f99cabcae947cc5a9cc7af43ea3f4179fd0ccf", "filename": "src/test/ui/moves/move-guard-same-consts.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-guard-same-consts.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,14 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/move-guard-same-consts.rs:20:24\n+   |\n+LL |     let x: Box<_> = box 1;\n+   |         - move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+...\n+LL |         (1, 2) if take(x) => (),\n+   |                        - value moved here\n+LL |         (1, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+   |                        ^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "41abe6fa72a57abd163844617e1382191d636a8d", "filename": "src/test/ui/moves/move-in-guard-1.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-1.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,14 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/move-in-guard-1.rs:10:24\n+   |\n+LL |     let x: Box<_> = box 1;\n+   |         - move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+...\n+LL |         (1, _) if take(x) => (),\n+   |                        - value moved here\n+LL |         (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n+   |                        ^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "0b14c1620d3cf17e5865486d1c69a57f53553fdc", "filename": "src/test/ui/moves/move-in-guard-2.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-in-guard-2.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,10 +1,11 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/move-in-guard-2.rs:10:24\n    |\n+LL |     let x: Box<_> = box 1;\n+   |         - move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+...\n LL |         (_, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n    |                        ^ value moved here, in previous iteration of loop\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "20bfdc2bbac7202a5f0c2d118ea2ea32a48fa8a8", "filename": "src/test/ui/moves/move-into-dead-array-2.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-into-dead-array-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmove-into-dead-array-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-into-dead-array-2.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `a`\n   --> $DIR/move-into-dead-array-2.rs:14:5\n    |\n+LL | fn foo(mut a: [D; 4], i: usize) {\n+   |        ----- move occurs because `a` has type `[D; 4]`, which does not implement the `Copy` trait\n LL |     drop(a);\n    |          - value moved here\n LL |     a[i] = d(); //~ ERROR use of moved value: `a`\n    |     ^^^^ value used here after move\n-   |\n-   = note: move occurs because `a` has type `[D; 4]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "6ad9a2d414c77027be2c0ba75dd86ea0d066a3bd", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-access-to-field.rs:11:12\n    |\n+LL |     let x = vec![\"hi\".to_string()];\n+   |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     consume(x.into_iter().next().unwrap());\n    |             - value moved here\n LL |     touch(&x[0]); //~ ERROR use of moved value: `x`\n    |            ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "bed0ae7275cc525cd9d4960db3d77ee9f2775cf3", "filename": "src/test/ui/moves/moves-based-on-type-capture-clause-bad.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-capture-clause-bad.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-capture-clause-bad.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-capture-clause-bad.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,15 +1,15 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-capture-clause-bad.rs:8:20\n    |\n+LL |     let x = \"Hello world!\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     thread::spawn(move|| {\n    |                   ------ value moved into closure here\n LL |         println!(\"{}\", x);\n    |                        - variable moved due to use in closure\n LL |     });\n LL |     println!(\"{}\", x); //~ ERROR use of moved value\n    |                    ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "07f40274f9e310f129e823cb7ae4b1d478cc15de", "filename": "src/test/ui/moves/moves-based-on-type-distribute-copy-over-paren.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-distribute-copy-over-paren.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,24 +1,24 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-distribute-copy-over-paren.rs:11:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = Foo { f:x };\n    |                      - value moved here\n LL |     //~^ NOTE value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-distribute-copy-over-paren.rs:20:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = Foo { f:(((x))) };\n    |                      ------- value moved here\n LL |     //~^ NOTE value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "162aec45f5f5743453f616c7c965b00880c8d3ec", "filename": "src/test/ui/moves/moves-based-on-type-exprs.nll.stderr", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,117 +1,122 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:12:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = Foo { f:x };\n    |                      - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:18:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = (x, 3);\n    |               - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:35:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |         x\n    |         - value moved here\n ...\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `y`\n   --> $DIR/moves-based-on-type-exprs.rs:36:11\n    |\n+LL |     let y = \"ho\".to_string();\n+   |         - move occurs because `y` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |         y\n    |         - value moved here\n ...\n LL |     touch(&y); //~ ERROR use of moved value: `y`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `y` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:46:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |         true => x,\n    |                 - value moved here\n ...\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `y`\n   --> $DIR/moves-based-on-type-exprs.rs:47:11\n    |\n+LL |     let y = \"ho\".to_string();\n+   |         - move occurs because `y` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |         false => y\n    |                  - value moved here\n ...\n LL |     touch(&y); //~ ERROR use of moved value: `y`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `y` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:58:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |         _ if guard(x) => 10,\n    |                    - value moved here\n ...\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:65:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = [x];\n    |               - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:71:11\n    |\n+LL |     let x = \"hi\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = vec![x];\n    |                   - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:77:11\n    |\n+LL |     let x = vec![\"hi\".to_string()];\n+   |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = x.into_iter().next().unwrap();\n    |              - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n    |\n+LL |     let x = vec![\"hi\".to_string()];\n+   |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = [x.into_iter().next().unwrap(); 1];\n    |               - value moved here\n LL |     touch(&x); //~ ERROR use of moved value: `x`\n    |           ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n \n error: aborting due to 11 previous errors\n "}, {"sha": "391dd67dbf60aa469c7fad3a83c7afb5b57d74cf", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -10,12 +10,14 @@ LL |                     (f.c)(f, true);\n error[E0382]: borrow of moved value: `f`\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:32:5\n    |\n+LL | fn conspirator<F>(mut f: F) where F: FnMut(&mut R, bool) {\n+   |                -  ----- move occurs because `f` has type `F`, which does not implement the `Copy` trait\n+   |                |\n+   |                consider adding a `Copy` constraint to this type argument\n LL |     let mut r = R {c: Box::new(f)};\n    |                                - value moved here\n LL |     f(&mut r, false) //~ ERROR use of moved value\n    |     ^ value borrowed here after move\n-   |\n-   = note: move occurs because `f` has type `F`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c49dbdab402108d534b89a9f62d4be3bc522ebf8", "filename": "src/test/ui/moves/moves-based-on-type-tuple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -11,12 +11,12 @@ LL |     box (x, x)\n error[E0382]: use of moved value: `x` (Mir)\n   --> $DIR/moves-based-on-type-tuple.rs:6:13\n    |\n+LL | fn dup(x: Box<isize>) -> Box<(Box<isize>,Box<isize>)> {\n+   |        - move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n LL |     box (x, x)\n    |          -  ^ value used here after move\n    |          |\n    |          value moved here\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3ca0aefb592e0898ce1409b5a4924757d35ec897", "filename": "src/test/ui/nll/closure-access-spans.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -59,50 +59,50 @@ LL |     r.use_ref();\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-access-spans.rs:37:5\n    |\n+LL | fn closure_imm_capture_moved(mut x: String) {\n+   |                              ----- move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let r = x;\n    |             - value moved here\n LL |     || x.len(); //~ ERROR\n    |     ^^ - borrow occurs due to use in closure\n    |     |\n    |     value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-access-spans.rs:42:5\n    |\n+LL | fn closure_mut_capture_moved(mut x: String) {\n+   |                              ----- move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let r = x;\n    |             - value moved here\n LL |     || x = String::new(); //~ ERROR\n    |     ^^ - borrow occurs due to use in closure\n    |     |\n    |     value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-access-spans.rs:47:5\n    |\n+LL | fn closure_unique_capture_moved(x: &mut String) {\n+   |                                 - move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n LL |     let r = x;\n    |             - value moved here\n LL |     || *x = String::new(); //~ ERROR\n    |     ^^  - borrow occurs due to use in closure\n    |     |\n    |     value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/closure-access-spans.rs:52:5\n    |\n+LL | fn closure_move_capture_moved(x: &mut String) {\n+   |                               - move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n LL |     let r = x;\n    |             - value moved here\n LL |     || x; //~ ERROR\n    |     ^^ - use occurs due to use in closure\n    |     |\n    |     value used here after move\n-   |\n-   = note: move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to 9 previous errors\n "}, {"sha": "6750c4047601a4b4627c10e760db135cca52ee44", "filename": "src/test/ui/nll/closure-move-spans.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,38 +1,38 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/closure-move-spans.rs:7:13\n    |\n+LL | fn move_after_move(x: String) {\n+   |                    - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     || x;\n    |     -- - variable moved due to use in closure\n    |     |\n    |     value moved into closure here\n LL |     let y = x; //~ ERROR\n    |             ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-move-spans.rs:12:13\n    |\n+LL | fn borrow_after_move(x: String) {\n+   |                      - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     || x;\n    |     -- - variable moved due to use in closure\n    |     |\n    |     value moved into closure here\n LL |     let y = &x; //~ ERROR\n    |             ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/closure-move-spans.rs:17:13\n    |\n+LL | fn borrow_mut_after_move(mut x: String) {\n+   |                          ----- move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     || x;\n    |     -- - variable moved due to use in closure\n    |     |\n    |     value moved into closure here\n LL |     let y = &mut x; //~ ERROR\n    |             ^^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6c9e1639f88dd7f6c8066a9ee841dd8178a4bff3", "filename": "src/test/ui/nll/closures-in-loops.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,13 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/closures-in-loops.rs:8:9\n    |\n+LL | fn repreated_move(x: String) {\n+   |                   - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+LL |     for i in 0..10 {\n LL |         || x; //~ ERROR\n    |         ^^ - use occurs due to use in closure\n    |         |\n    |         value moved into closure here, in previous iteration of loop\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/closures-in-loops.rs:15:16"}, {"sha": "54c728e3d2783fdb1e6c53bdb672cf1f8353a58d", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -13,12 +13,12 @@ LL |     d.x = 10;\n error[E0382]: assign of moved value: `d`\n   --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:43:5\n    |\n+LL |     let mut d = D { x: 0, s: S{ y: 0, z: 0 } };\n+   |         ----- move occurs because `d` has type `D`, which does not implement the `Copy` trait\n LL |     drop(d);\n    |          - value moved here\n LL |     d.x = 10;\n    |     ^^^^^^^^ value assigned here after move\n-   |\n-   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n \n error[E0381]: assign to part of possibly uninitialized variable: `d`\n   --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:49:5\n@@ -35,12 +35,12 @@ LL |     d.s.y = 20;\n error[E0382]: assign to part of moved value: `d`\n   --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:62:5\n    |\n+LL |     let mut d = D { x: 0, s: S{ y: 0, z: 0} };\n+   |         ----- move occurs because `d` has type `D`, which does not implement the `Copy` trait\n LL |     drop(d);\n    |          - value moved here\n LL |     d.s.y = 20;\n    |     ^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n \n error: aborting due to 6 previous errors\n "}, {"sha": "23da533252cb9c6e64a4a7416410162c6f5c6f99", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.stderr", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -14,21 +14,21 @@ error[E0382]: assign to part of moved value: `s`\n   --> $DIR/issue-21232-partial-init-and-use.rs:113:5\n    |\n LL |     let mut s: S<B> = S::new(); drop(s);\n-   |                                      - value moved here\n+   |         -----                        - value moved here\n+   |         |\n+   |         move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n LL |     s.x = 10; s.y = Box::new(20);\n    |     ^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `t`\n   --> $DIR/issue-21232-partial-init-and-use.rs:120:5\n    |\n LL |     let mut t: T = (0, Box::new(0)); drop(t);\n-   |                                           - value moved here\n+   |         -----                             - value moved here\n+   |         |\n+   |         move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n LL |     t.0 = 10; t.1 = Box::new(20);\n    |     ^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n \n error[E0381]: assign to part of possibly uninitialized variable: `s`\n   --> $DIR/issue-21232-partial-init-and-use.rs:127:5\n@@ -46,21 +46,21 @@ error[E0382]: assign to part of moved value: `s`\n   --> $DIR/issue-21232-partial-init-and-use.rs:141:5\n    |\n LL |     let mut s: S<B> = S::new(); drop(s);\n-   |                                      - value moved here\n+   |         -----                        - value moved here\n+   |         |\n+   |         move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n LL |     s.x = 10;\n    |     ^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `t`\n   --> $DIR/issue-21232-partial-init-and-use.rs:148:5\n    |\n LL |     let mut t: T = (0, Box::new(0)); drop(t);\n-   |                                           - value moved here\n+   |         -----                             - value moved here\n+   |         |\n+   |         move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n LL |     t.0 = 10;\n    |     ^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n \n error[E0381]: assign to part of possibly uninitialized variable: `s`\n   --> $DIR/issue-21232-partial-init-and-use.rs:155:5\n@@ -153,22 +153,24 @@ LL |     q.r.f.0 = 10;\n error[E0382]: assign to part of moved value: `c`\n   --> $DIR/issue-21232-partial-init-and-use.rs:259:13\n    |\n+LL |     let mut c = (1, \"\".to_owned());\n+   |         ----- move occurs because `c` has type `(i32, std::string::String)`, which does not implement the `Copy` trait\n+LL |     match c {\n LL |         c2 => {\n    |         -- value moved here\n LL |             c.0 = 2; //~ ERROR assign to part of moved value\n    |             ^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `c` has type `(i32, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `c`\n   --> $DIR/issue-21232-partial-init-and-use.rs:269:13\n    |\n+LL |     let mut c = (1, (1, \"\".to_owned()));\n+   |         ----- move occurs because `c` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n+LL |     match c {\n LL |         c2 => {\n    |         -- value moved here\n LL |             (c.1).0 = 2; //~ ERROR assign to part of moved value\n    |             ^^^^^^^^^^^ value partially assigned here after move\n-   |\n-   = note: move occurs because `c` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n \n error[E0382]: assign to part of moved value: `c.1`\n   --> $DIR/issue-21232-partial-init-and-use.rs:277:13"}, {"sha": "a84a236ca77722995b7c5760985dc6f51d0d1236", "filename": "src/test/ui/nll/issue-51512.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `range`\n   --> $DIR/issue-51512.rs:7:13\n    |\n+LL |     let range = 0..1;\n+   |         ----- move occurs because `range` has type `std::ops::Range<i32>`, which does not implement the `Copy` trait\n LL |     let r = range;\n    |             ----- value moved here\n LL |     let x = range.start;\n    |             ^^^^^^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `range` has type `std::ops::Range<i32>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "f51768c3859e4f3244ed795bdb74e56f9153d309", "filename": "src/test/ui/nll/issue-52669.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-52669.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fnll%2Fissue-52669.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52669.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,13 @@\n error[E0382]: borrow of moved value: `a.b`\n   --> $DIR/issue-52669.rs:15:5\n    |\n+LL | fn bar(mut a: A) -> B {\n+   |        ----- move occurs because `a` has type `A`, which does not implement the `Copy` trait\n+LL |     a.b = B;\n LL |     foo(a);\n    |         - value moved here\n LL |     a.b.clone()\n    |     ^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `a` has type `A`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "476b6f75abb46b569595054dc363fae9dd51b168", "filename": "src/test/ui/no-capture-arc.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fno-capture-arc.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fno-capture-arc.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-capture-arc.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,15 +1,16 @@\n error[E0382]: borrow of moved value: `arc_v`\n   --> $DIR/no-capture-arc.rs:14:18\n    |\n+LL |     let arc_v = Arc::new(v);\n+   |         ----- move occurs because `arc_v` has type `std::sync::Arc<std::vec::Vec<i32>>`, which does not implement the `Copy` trait\n+LL | \n LL |     thread::spawn(move|| {\n    |                   ------ value moved into closure here\n LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3);\n    |                  ^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `arc_v` has type `std::sync::Arc<std::vec::Vec<i32>>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "0b14f65a770733b8894a9fcefbe21bfc0fca7876", "filename": "src/test/ui/no-reuse-move-arc.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fno-reuse-move-arc.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fno-reuse-move-arc.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-reuse-move-arc.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,15 +1,16 @@\n error[E0382]: borrow of moved value: `arc_v`\n   --> $DIR/no-reuse-move-arc.rs:12:18\n    |\n+LL |     let arc_v = Arc::new(v);\n+   |         ----- move occurs because `arc_v` has type `std::sync::Arc<std::vec::Vec<i32>>`, which does not implement the `Copy` trait\n+LL | \n LL |     thread::spawn(move|| {\n    |                   ------ value moved into closure here\n LL |         assert_eq!((*arc_v)[3], 4);\n    |                      ----- variable moved due to use in closure\n ...\n LL |     assert_eq!((*arc_v)[2], 3); //~ ERROR use of moved value: `arc_v`\n    |                  ^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `arc_v` has type `std::sync::Arc<std::vec::Vec<i32>>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "ea53abc1b0f2d05d1551b94781a37ca227dbbc94", "filename": "src/test/ui/once-cant-call-twice-on-heap.nll.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -0,0 +1,15 @@\n+error[E0382]: use of moved value: `blk`\n+  --> $DIR/once-cant-call-twice-on-heap.rs:9:5\n+   |\n+LL | fn foo<F:FnOnce()>(blk: F) {\n+   |        -           --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n+   |        |\n+   |        consider adding a `Copy` constraint to this type argument\n+LL |     blk();\n+   |     --- value moved here\n+LL |     blk(); //~ ERROR use of moved value\n+   |     ^^^ value used here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "bef8dcca921e61a2b20b9cfe3c62af8e46bde921", "filename": "src/test/ui/ref-suggestion.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fref-suggestion.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,22 +1,22 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/ref-suggestion.rs:4:5\n    |\n+LL |     let x = vec![1];\n+   |         - move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n LL |     let y = x;\n    |             - value moved here\n LL |     x; //~ ERROR use of moved value\n    |     ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/ref-suggestion.rs:8:5\n    |\n+LL |     let x = vec![1];\n+   |         - move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n LL |     let mut y = x;\n    |                 - value moved here\n LL |     x; //~ ERROR use of moved value\n    |     ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/ref-suggestion.rs:16:5"}, {"sha": "5a730ad2be42c67bd8d8994949990bd5f2686baf", "filename": "src/test/ui/rfc-2361-dbg-macro/dbg-macro-move-semantics.nll.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-move-semantics.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,13 @@\n error[E0382]: use of moved value: `a`\n   --> $DIR/dbg-macro-move-semantics.rs:9:18\n    |\n+LL |     let a = NoCopy(0);\n+   |         - move occurs because `a` has type `NoCopy`, which does not implement the `Copy` trait\n LL |     let _ = dbg!(a);\n    |             ------- value moved here\n LL |     let _ = dbg!(a); //~ ERROR use of moved value\n    |                  ^ value used here after move\n    |\n-   = note: move occurs because `a` has type `NoCopy`, which does not implement the `Copy` trait\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "b1b925d694ff9ba8e1acc6115425978cb989543f", "filename": "src/test/ui/try-block/try-block-bad-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -25,13 +25,14 @@ LL |         ::std::mem::drop(k); //~ ERROR use of moved value: `k`\n error[E0382]: use of moved value: `k`\n   --> $DIR/try-block-bad-lifetime.rs:31:26\n    |\n+LL |         let k = &mut i;\n+   |             - move occurs because `k` has type `&mut i32`, which does not implement the `Copy` trait\n+LL |         let mut j: Result<(), &mut i32> = try {\n LL |             Err(k) ?;\n    |                 - value moved here\n ...\n LL |         ::std::mem::drop(k); //~ ERROR use of moved value: `k`\n    |                          ^ value used here after move\n-   |\n-   = note: move occurs because `k` has type `&mut i32`, which does not implement the `Copy` trait\n \n error[E0506]: cannot assign to `i` because it is borrowed\n   --> $DIR/try-block-bad-lifetime.rs:32:9"}, {"sha": "dafbde6a5150bb461bcd861f1356e8acb958a802", "filename": "src/test/ui/try-block/try-block-maybe-bad-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-maybe-bad-lifetime.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -13,13 +13,14 @@ LL |         do_something_with(x);\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/try-block-maybe-bad-lifetime.rs:28:24\n    |\n+LL |         let x = String::new();\n+   |             - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+...\n LL |             ::std::mem::drop(x);\n    |                              - value moved here\n LL |         };\n LL |         println!(\"{}\", x); //~ ERROR borrow of moved value: `x`\n    |                        ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0506]: cannot assign to `i` because it is borrowed\n   --> $DIR/try-block-maybe-bad-lifetime.rs:40:9"}, {"sha": "29d161fe150e74b1fa856b6e8652161207327d53", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -13,12 +13,12 @@ LL |     use_borrow(a);\n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n    |\n+LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = u.x.0;\n    |             ----- value moved here\n LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |             ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n@@ -35,12 +35,12 @@ LL |     use_borrow(a);\n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n    |\n+LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = (u.x.0).0;\n    |             --------- value moved here\n LL |     let b = u.y; //~ ERROR use of moved value: `u.y`\n    |             ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n   --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n@@ -57,12 +57,12 @@ LL |     use_borrow(a);\n error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:48:13\n    |\n+LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = *u.y;\n    |             ---- value moved here\n LL |     let b = u.x; //~ ERROR use of moved value: `u.x`\n    |             ^^^ value used here after move\n-   |\n-   = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n error: aborting due to 6 previous errors\n "}, {"sha": "58953d55b1fbae40d7e1c903540c81f573843f4a", "filename": "src/test/ui/unop-move-semantics.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funop-move-semantics.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funop-move-semantics.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,13 +1,15 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/unop-move-semantics.rs:8:5\n    |\n+LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n+   |                     -                         - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+   |                     |\n+   |                     consider adding a `Copy` constraint to this type argument\n LL |     !x;\n    |      - value moved here\n LL | \n LL |     x.clone();  //~ ERROR: use of moved value\n    |     ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait\n \n error[E0505]: cannot move out of `x` because it is borrowed\n   --> $DIR/unop-move-semantics.rs:15:6"}, {"sha": "0e6a6f6369a15f091dd93b15a782bf0ceb4f4ab3", "filename": "src/test/ui/unsized-locals/borrow-after-move.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -12,13 +12,13 @@ LL |         println!(\"{}\", &x);\n error[E0382]: borrow of moved value: `y`\n   --> $DIR/borrow-after-move.rs:22:24\n    |\n+LL |         let y = *x;\n+   |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         drop_unsized(y);\n    |                      - value moved here\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `y` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:30:24\n@@ -34,13 +34,13 @@ LL |         println!(\"{}\", &x);\n error[E0382]: borrow of moved value: `y`\n   --> $DIR/borrow-after-move.rs:32:24\n    |\n+LL |         let y = *x;\n+   |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n    |         - value moved here\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n-   |\n-   = note: move occurs because `y` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24"}, {"sha": "e40289af5ad3d7487f5dc53f7105f4b6be83efdc", "filename": "src/test/ui/unsized-locals/double-move.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `y`\n   --> $DIR/double-move.rs:20:22\n    |\n+LL |         let y = *x;\n+   |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         drop_unsized(y);\n    |                      - value moved here\n LL |         drop_unsized(y); //~ERROR use of moved value\n    |                      ^ value used here after move\n-   |\n-   = note: move occurs because `y` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:26:22\n@@ -21,22 +21,22 @@ LL |         drop_unsized(x); //~ERROR use of moved value\n error[E0382]: use of moved value: `*x`\n   --> $DIR/double-move.rs:32:18\n    |\n+LL |         let x = \"hello\".to_owned().into_boxed_str();\n+   |             - move occurs because `x` has type `std::boxed::Box<str>`, which does not implement the `Copy` trait\n LL |         drop_unsized(x);\n    |                      - value moved here\n LL |         let _y = *x; //~ERROR use of moved value\n    |                  ^^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<str>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `y`\n   --> $DIR/double-move.rs:39:9\n    |\n+LL |         let y = *x;\n+   |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n    |         - value moved here\n LL |         y.foo(); //~ERROR use of moved value\n    |         ^ value used here after move\n-   |\n-   = note: move occurs because `y` has type `str`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `*x`\n   --> $DIR/double-move.rs:45:9"}, {"sha": "8160ada9d62ea41d54136cb95d83d97a1a72a122", "filename": "src/test/ui/use/use-after-move-based-on-type.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-based-on-type.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `x`\n   --> $DIR/use-after-move-based-on-type.rs:4:20\n    |\n+LL |     let x = \"Hello!\".to_string();\n+   |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n LL |     let _y = x;\n    |              - value moved here\n LL |     println!(\"{}\", x); //~ ERROR use of moved value\n    |                    ^ value borrowed here after move\n-   |\n-   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "e16bca380679f5e982b409844d063f86f766dec7", "filename": "src/test/ui/use/use-after-move-implicity-coerced-object.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-implicity-coerced-object.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,13 @@\n error[E0382]: borrow of moved value: `n`\n   --> $DIR/use-after-move-implicity-coerced-object.rs:28:13\n    |\n+LL |     let n: Box<_> = box Number { n: 42 };\n+   |         - move occurs because `n` has type `std::boxed::Box<Number>`, which does not implement the `Copy` trait\n+LL |     let mut l: Box<_> = box List { list: Vec::new() };\n LL |     l.push(n);\n    |            - value moved here\n LL |     let x = n.to_string();\n    |             ^ value borrowed here after move\n-   |\n-   = note: move occurs because `n` has type `std::boxed::Box<Number>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "4119741d805cd43b24f66975a099fdb8508ba6ee", "filename": "src/test/ui/use/use-after-move-self-based-on-type.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `self`\n   --> $DIR/use-after-move-self-based-on-type.rs:12:16\n    |\n+LL |     pub fn foo(self) -> isize {\n+   |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n    |         ---- value moved here\n LL |         return self.x;  //~ ERROR use of moved value: `self.x`\n    |                ^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `self` has type `S`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "e2ce3690cb9046c89b0898fdfff7f4bdb6eb7e35", "filename": "src/test/ui/use/use-after-move-self.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: use of moved value: `self`\n   --> $DIR/use-after-move-self.rs:10:16\n    |\n+LL |     pub fn foo(self) -> isize {\n+   |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n    |         ---- value moved here\n LL |         return *self.x;  //~ ERROR use of moved value: `*self.x`\n    |                ^^^^^^^ value used here after move\n-   |\n-   = note: move occurs because `self` has type `S`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "2263747607b9c94243df3279e3e056992e64d697", "filename": "src/test/ui/walk-struct-literal-with.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41ade7bc37360db40ab3111ce95acdfd9d0bcb3/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr?ref=a41ade7bc37360db40ab3111ce95acdfd9d0bcb3", "patch": "@@ -1,12 +1,12 @@\n error[E0382]: borrow of moved value: `start`\n   --> $DIR/walk-struct-literal-with.rs:16:20\n    |\n+LL |     let start = Mine{test:\"Foo\".to_string(), other_val:0};\n+   |         ----- move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};\n    |                                   ----- value moved here\n LL |     println!(\"{}\", start.test); //~ ERROR use of moved value: `start.test`\n    |                    ^^^^^^^^^^ value borrowed here after move\n-   |\n-   = note: move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}]}