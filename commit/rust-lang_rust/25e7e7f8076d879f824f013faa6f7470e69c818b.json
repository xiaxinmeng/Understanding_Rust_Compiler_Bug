{"sha": "25e7e7f8076d879f824f013faa6f7470e69c818b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZTdlN2Y4MDc2ZDg3OWY4MjRmMDEzZmFhNmY3NDcwZTY5YzgxOGI=", "commit": {"author": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-27T03:42:26Z"}, "committer": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-29T14:15:41Z"}, "message": "Removing do keyword from libstd and librustc", "tree": {"sha": "9acb92473ae0a0f1463901fe97e222e07da55b6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9acb92473ae0a0f1463901fe97e222e07da55b6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25e7e7f8076d879f824f013faa6f7470e69c818b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25e7e7f8076d879f824f013faa6f7470e69c818b", "html_url": "https://github.com/rust-lang/rust/commit/25e7e7f8076d879f824f013faa6f7470e69c818b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25e7e7f8076d879f824f013faa6f7470e69c818b/comments", "author": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af218d68e4b4916440ef2b4fc076a7bd8dead892", "url": "https://api.github.com/repos/rust-lang/rust/commits/af218d68e4b4916440ef2b4fc076a7bd8dead892", "html_url": "https://github.com/rust-lang/rust/commit/af218d68e4b4916440ef2b4fc076a7bd8dead892"}], "stats": {"total": 531, "additions": 265, "deletions": 266}, "files": [{"sha": "0582528b3e2c1eeb44b900c0971d67fef75d161c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -146,7 +146,7 @@ pub mod method;\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n-///         do bar() { ... }\n+///         bar(proc() { ... })\n ///     }\n ///\n /// Here, the function `foo()` and the closure passed to"}, {"sha": "8c56e65c22c667dbd19ebb4339015e320e25fe25", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -60,18 +60,18 @@\n //! ```rust,should_fail\n //! // Create a simple streaming channel\n //! let (port, chan) = Chan::new();\n-//! do spawn {\n+//! spawn(proc() {\n //!     chan.send(10);\n-//! }\n+//! })\n //! assert_eq!(port.recv(), 10);\n //!\n //! // Create a shared channel which can be sent along from many tasks\n //! let (port, chan) = SharedChan::new();\n //! for i in range(0, 10) {\n //!     let chan = chan.clone();\n-//!     do spawn {\n+//!     spawn(proc() {\n //!         chan.send(i);\n-//!     }\n+//!     })\n //! }\n //!\n //! for _ in range(0, 10) {\n@@ -264,7 +264,7 @@ macro_rules! test (\n             $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n-                do native::task::spawn { c.send(f()) }\n+                native::task::spawn(proc() { c.send(f()) });\n                 p.recv();\n             }\n         }\n@@ -962,9 +962,9 @@ mod test {\n \n     test!(fn smoke_threads() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             c.send(1);\n-        }\n+        });\n         assert_eq!(p.recv(), 1);\n     })\n \n@@ -990,18 +990,18 @@ mod test {\n \n     test!(fn port_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             p.recv();\n-        }\n+        });\n         loop { c.send(1) }\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent_shared() {\n         let (p, c) = SharedChan::new();\n         let c1 = c.clone();\n-        do spawn {\n+        spawn(proc() {\n             p.recv();\n-        }\n+        });\n         loop {\n             c.send(1);\n             c1.send(1);\n@@ -1024,18 +1024,18 @@ mod test {\n \n     test!(fn chan_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             c.send(1);\n             c.send(1);\n-        }\n+        });\n         loop { p.recv(); }\n     } #[should_fail])\n \n     test!(fn stress() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             for _ in range(0, 10000) { c.send(1); }\n-        }\n+        });\n         for _ in range(0, 10000) {\n             assert_eq!(p.recv(), 1);\n         }\n@@ -1047,7 +1047,7 @@ mod test {\n         let (p, c) = SharedChan::<int>::new();\n         let (p1, c1) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             for _ in range(0, AMT * NTHREADS) {\n                 assert_eq!(p.recv(), 1);\n             }\n@@ -1056,13 +1056,13 @@ mod test {\n                 _ => {}\n             }\n             c1.send(());\n-        }\n+        });\n \n         for _ in range(0, NTHREADS) {\n             let c = c.clone();\n-            do spawn {\n+            spawn(proc() {\n                 for _ in range(0, AMT) { c.send(1); }\n-            }\n+            });\n         }\n         p1.recv();\n     })\n@@ -1073,20 +1073,20 @@ mod test {\n         let (p1, c1) = Chan::new();\n         let (port, chan) = SharedChan::new();\n         let chan2 = chan.clone();\n-        do spawn {\n+        spawn(proc() {\n             c1.send(());\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n             chan2.send(());\n-        }\n+        });\n         p1.recv();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             for _ in range(0, 40) {\n                 c.send(1);\n             }\n             chan.send(());\n-        }\n+        });\n         port.recv();\n         port.recv();\n     }\n@@ -1095,12 +1095,12 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n         let (dp, dc) = Chan::new();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n             dc.send(());\n-        };\n+        });\n         for _ in range(0, 40) {\n             c.send(1);\n         }\n@@ -1113,16 +1113,16 @@ mod test {\n         let (p2, c2) = Chan::<int>::new();\n         let (port, chan) = SharedChan::new();\n         let chan2 = chan.clone();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             assert_eq!(p1.recv(), 1);\n             c2.send(2);\n             chan2.send(());\n-        }\n-        do native::task::spawn {\n+        });\n+        native::task::spawn(proc() {\n             c1.send(1);\n             assert_eq!(p2.recv(), 2);\n             chan.send(());\n-        }\n+        });\n         port.recv();\n         port.recv();\n     }\n@@ -1148,11 +1148,11 @@ mod test {\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will fail\n-        let res = do task::try {\n+        let res = task::try(proc() {\n             let (port, chan) = Chan::<~int>::new();\n             { let _c = chan; }\n             port.recv();\n-        };\n+        });\n         // What is our res?\n         assert!(res.is_err());\n     })\n@@ -1208,74 +1208,74 @@ mod test {\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (port, chan) = Chan::<~int>::new();\n-        do spawn {\n+        spawn(proc() {\n             assert!(port.recv() == ~10);\n-        }\n+        });\n \n         chan.send(~10);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n         let (port, chan) = Chan::<~int>::new();\n-        do spawn {\n+        spawn(proc() {\n             let _chan = chan;\n-        }\n-        let res = do task::try {\n+        });\n+        let res = task::try(proc() {\n             assert!(port.recv() == ~10);\n-        };\n+        });\n         assert!(res.is_err());\n     })\n \n     test!(fn oneshot_multi_thread_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let _p = port;\n-            }\n+            });\n             let _chan = chan;\n         })\n     })\n \n     test!(fn oneshot_multi_thread_send_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let _p = port;\n-            }\n-            do task::try {\n+            });\n+            task::try(proc() {\n                 chan.send(1);\n-            };\n+            });\n         })\n     })\n \n     test!(fn oneshot_multi_thread_recv_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let port = port;\n-                let res = do task::try {\n+                let res = task::try(proc() {\n                     port.recv();\n-                };\n+                });\n                 assert!(res.is_err());\n-            };\n-            do spawn {\n+            });\n+            spawn(proc() {\n                 let chan = chan;\n-                do spawn {\n+                spawn(proc() {\n                     let _chan = chan;\n-                }\n-            };\n+                });\n+            });\n         })\n     })\n \n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 chan.send(~10);\n-            }\n-            do spawn {\n+            });\n+            spawn(proc() {\n                 assert!(port.recv() == ~10);\n-            }\n+            });\n         })\n     })\n \n@@ -1289,19 +1289,19 @@ mod test {\n             fn send(chan: Chan<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawn {\n+                spawn(proc() {\n                     chan.send(~i);\n                     send(chan, i + 1);\n-                }\n+                });\n             }\n \n             fn recv(port: Port<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawn {\n+                spawn(proc() {\n                     assert!(port.recv() == ~i);\n                     recv(port, i + 1);\n-                };\n+                });\n             }\n         })\n     })\n@@ -1318,9 +1318,9 @@ mod test {\n         let total = stress_factor() + 100;\n         total.times(|| {\n             let chan_clone = chan.clone();\n-            do spawn {\n+            spawn(proc() {\n                 chan_clone.send(());\n-            }\n+            });\n         });\n \n         total.times(|| {\n@@ -1332,13 +1332,13 @@ mod test {\n         let (port, chan) = Chan::<int>::new();\n         let (total_port, total_chan) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acc = 0;\n             for x in port.iter() {\n                 acc += x;\n             }\n             total_chan.send(acc);\n-        }\n+        });\n \n         chan.send(3);\n         chan.send(1);\n@@ -1351,7 +1351,7 @@ mod test {\n         let (port, chan) = Chan::<int>::new();\n         let (count_port, count_chan) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut count = 0;\n             for x in port.iter() {\n                 if count >= 3 {\n@@ -1361,7 +1361,7 @@ mod test {\n                 }\n             }\n             count_chan.send(count);\n-        }\n+        });\n \n         chan.send(2);\n         chan.send(2);\n@@ -1375,14 +1375,14 @@ mod test {\n         let (p, c) = Chan::<int>::new();\n         let (p1, c1) = Chan::<()>::new();\n         let (p2, c2) = Chan::<()>::new();\n-        do spawn {\n+        spawn(proc() {\n             p1.recv();\n             c.send(1);\n             c2.send(());\n             p1.recv();\n             drop(c);\n             c2.send(());\n-        }\n+        });\n \n         assert_eq!(p.try_recv(), Empty);\n         c1.send(());"}, {"sha": "af435c3fc5f311bb206b84a8dcf36c4849f4769f", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -378,12 +378,12 @@ mod test {\n         let (mut p2, _c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             20.times(task::deschedule);\n             c1.send(1);\n             p3.recv();\n             20.times(task::deschedule);\n-        }\n+        });\n \n         select! (\n             a = p1.recv() => { assert_eq!(a, 1); },\n@@ -401,12 +401,12 @@ mod test {\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             20.times(task::deschedule);\n             c1.send(1);\n             c2.send(2);\n             p3.recv();\n-        }\n+        });\n \n         select! (\n             a = p1.recv() => { assert_eq!(a, 1); },\n@@ -427,7 +427,7 @@ mod test {\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n                     c1.send(i);\n@@ -436,7 +436,7 @@ mod test {\n                 }\n                 p3.recv();\n             }\n-        }\n+        });\n \n         for i in range(0, AMT) {\n             select! ("}, {"sha": "0acfa71e3151c9a5484195cfafe7934fdabb48a7", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -120,13 +120,13 @@ mod test {\n     #[test]\n     fn test_port_reader() {\n         let (port, chan) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n           chan.send(~[1u8, 2u8]);\n           chan.send(~[]);\n           chan.send(~[3u8, 4u8]);\n           chan.send(~[5u8, 6u8]);\n           chan.send(~[7u8, 8u8]);\n-        }\n+        });\n \n         let mut reader = PortReader::new(port);\n         let mut buf = ~[0u8, ..3];\n@@ -172,7 +172,7 @@ mod test {\n         writer.write_be_u32(42);\n \n         let wanted = ~[0u8, 0u8, 0u8, 42u8];\n-        let got = do task::try { port.recv() }.unwrap();\n+        let got = task::try(proc() { port.recv() }).unwrap();\n         assert_eq!(wanted, got);\n \n         let mut err = None;"}, {"sha": "2d074df49199b1df8f3929b16fb855be4a72c7a4", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -167,11 +167,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -185,11 +185,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -203,11 +203,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -221,11 +221,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -239,11 +239,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -267,11 +267,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -295,11 +295,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -326,11 +326,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -358,13 +358,13 @@ mod test {\n         let max = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -380,13 +380,13 @@ mod test {\n         let max = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -402,35 +402,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([i as u8]);\n-            }\n+            });\n         }\n     })\n \n@@ -439,35 +439,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([i as u8]);\n-            }\n+            });\n         }\n     })\n \n@@ -476,35 +476,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([99]);\n-            }\n+            });\n         }\n     })\n \n@@ -513,35 +513,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([99]);\n-            }\n+            });\n         }\n     })\n \n@@ -558,11 +558,11 @@ mod test {\n     pub fn peer_name(addr: SocketAddr) {\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             acceptor.accept();\n-        }\n+        });\n \n         port.recv();\n         let stream = TcpStream::connect(addr);\n@@ -592,15 +592,15 @@ mod test {\n     iotest!(fn partial_read() {\n         let addr = next_test_ip4();\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let mut srv = TcpListener::bind(addr).listen();\n             c.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]);\n             let mut b = [0];\n             cl.read(b);\n             c.send(());\n-        }\n+        });\n \n         p.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n@@ -630,12 +630,12 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let stream = TcpStream::connect(addr);\n             // Close\n             port.recv();\n-        }\n+        });\n \n         {\n             let mut acceptor = TcpListener::bind(addr).listen();"}, {"sha": "1cf30d469f7aa81d76982ea75a3a34bca0f6f4d8", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -119,7 +119,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -128,7 +128,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(ref mut server) => {\n@@ -153,15 +153,15 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (port, chan) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n                     client.sendto([99], server_ip)\n                 }\n                 None => fail!()\n             }\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(ref mut server) => {\n@@ -186,7 +186,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -197,7 +197,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(server) => {\n@@ -224,7 +224,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -235,7 +235,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(server) => {"}, {"sha": "dcf6d2ad2035894f2859505be2d52bdcb3656d16", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -147,10 +147,10 @@ mod tests {\n         let path2 = path1.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             client(UnixStream::connect(&path2).unwrap());\n-        }\n+        });\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n         chan.send(());\n@@ -232,13 +232,13 @@ mod tests {\n         let path2 = path1.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             times.times(|| {\n                 let mut stream = UnixStream::connect(&path2);\n                 stream.write([100]);\n             })\n-        }\n+        });\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n         chan.send(());"}, {"sha": "9919d333f41b4c80bda9726565c1d76ae53c7986", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -89,11 +89,11 @@ mod test {\n         let out = PipeStream::open(out);\n         let mut input = PipeStream::open(input);\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let mut out = out;\n             out.write([10]);\n             p.recv(); // don't close the pipe until the other read has finished\n-        }\n+        });\n \n         let mut buf = [0, ..10];\n         input.read(buf);"}, {"sha": "5575e289b59a7a096a4acfc66ca1aece6cb66cdc", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -65,14 +65,14 @@ pub enum Signum {\n /// let mut listener = Listener::new();\n /// listener.register(Interrupt);\n ///\n-/// do spawn {\n+/// spawn({\n ///     loop {\n ///         match listener.port.recv() {\n ///             Interrupt => println!(\"Got Interrupt'ed\"),\n ///             _ => (),\n ///         }\n ///     }\n-/// }\n+/// });\n ///\n /// ```\n pub struct Listener {"}, {"sha": "d9fa2a4fc336bc63b65d0e3cc55c19e68560e473", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -372,10 +372,10 @@ mod tests {\n \n         let (p, c) = Chan::new();\n         let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n-        do spawn {\n+        spawn(proc() {\n             set_stdout(~w as ~Writer);\n             println!(\"hello!\");\n-        }\n+        });\n         assert_eq!(r.read_to_str(), ~\"hello!\\n\");\n     })\n \n@@ -384,10 +384,10 @@ mod tests {\n \n         let (p, c) = Chan::new();\n         let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n-        do spawn {\n+        spawn(proc() {\n             set_stderr(~w as ~Writer);\n             fail!(\"my special message\");\n-        }\n+        });\n         let s = r.read_to_str();\n         assert!(s.contains(\"my special message\"));\n     })"}, {"sha": "6ac73e7f61e712c78a810bd16968562313786cd6", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -45,7 +45,7 @@ macro_rules! iotest (\n             $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n-                do native::task::spawn { c.send(f()) }\n+                native::task::spawn(proc() { c.send(f()) });\n                 p.recv();\n             }\n         }"}, {"sha": "24eaf6adf3f3ead681439b736b3dbf66c4be7fa6", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -204,9 +204,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end\n@@ -217,9 +217,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.oneshot(1);\n     })\n@@ -229,9 +229,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.sleep(1);\n     })"}, {"sha": "719cf2450c5054c964ff8ac4f79c7931f978302e", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -355,14 +355,14 @@ mod tests {\n     fn test_tls_multitask() {\n         static my_key: Key<~str> = &Key;\n         set(my_key, ~\"parent data\");\n-        do task::spawn {\n+        task::spawn(proc() {\n             // TLS shouldn't carry over.\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).is_none());\n             set(my_key, ~\"child data\");\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() ==\n                     ~\"child data\");\n             // should be cleaned up for us\n-        }\n+        });\n         // Must work multiple times\n         assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n         assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n@@ -414,21 +414,21 @@ mod tests {\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n         static my_key: Key<~str> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(my_key, ~\"hax\");\n-        }\n+        });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(str_key, ~\"string data\");\n             set(box_key, @());\n             set(int_key, 42);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -437,7 +437,7 @@ mod tests {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(str_key, ~\"string data\");\n             set(str_key, ~\"string data 2\");\n             set(box_key, @());\n@@ -447,7 +447,7 @@ mod tests {\n             // with the crazy polymorphic transmute rather than the provided\n             // finaliser.\n             set(int_key, 31337);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -458,13 +458,13 @@ mod tests {\n         static int_key: Key<int> = &Key;\n         set(str_key, ~\"parent data\");\n         set(box_key, @());\n-        do task::spawn {\n+        task::spawn(proc() {\n             // spawn_linked\n             set(str_key, ~\"string data\");\n             set(box_key, @());\n             set(int_key, 42);\n             fail!();\n-        }\n+        });\n         // Not quite nondeterministic.\n         set(int_key, 31337);\n         fail!();"}, {"sha": "8029ec696f82a7282600ec6addd5c0442d792407", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -569,11 +569,11 @@ mod tests {\n         use task;\n \n         macro_rules! t(\n-            ($name:expr => $code:block) => (\n+            ($name:expr => $code:expr) => (\n                 {\n                     let mut t = task::task();\n                     t.name($name);\n-                    let res = do t.try $code;\n+                    let res = t.try(proc() $code);\n                     assert!(res.is_err());\n                 }\n             )"}, {"sha": "a07471afc1a67f940fbebdb3ff8e05606c63bd9d", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -1290,11 +1290,11 @@ mod tests {\n         use task;\n \n         macro_rules! t(\n-            ($name:expr => $code:block) => (\n+            ($name:expr => $code:expr) => (\n                 {\n                     let mut t = task::task();\n                     t.name($name);\n-                    let res = do t.try $code;\n+                    let res = t.try(proc() $code);\n                     assert!(res.is_err());\n                 }\n             )"}, {"sha": "c359d79d27509e8204d4ce089d94432fadcd172a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -159,7 +159,7 @@ mod test {\n         for _ in range(0, 20) {\n             let (p, c) = Chan::new();\n             chans.push(c);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 // wait until all the tasks are ready to go.\n                 p.recv();\n \n@@ -177,7 +177,7 @@ mod test {\n                     r.fill_bytes(v);\n                     task::deschedule();\n                 }\n-            }\n+            })\n         }\n \n         // start all the tasks"}, {"sha": "76a672b79cada5638095031819a2ab940f5151ab", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -57,17 +57,17 @@ mod test {\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn thread_local_task_two_instances() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n@@ -76,13 +76,12 @@ mod test {\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n-\n+        });\n     }\n \n     #[test]\n     fn borrow_smoke_test() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -91,12 +90,12 @@ mod test {\n             }\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn borrow_with_return() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -106,12 +105,12 @@ mod test {\n \n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn try_take() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -120,7 +119,7 @@ mod test {\n             assert!(u.is_none());\n \n             cleanup_task(t);\n-        }\n+        });\n     }\n \n     fn cleanup_task(mut t: ~Task) {"}, {"sha": "83f5ca346a9369104c4e7b4455adcf44a11b5f6a", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -255,11 +255,11 @@ mod tests {\n     use super::Thread;\n \n     #[test]\n-    fn smoke() { do Thread::start {}.join(); }\n+    fn smoke() { Thread::start(proc (){}).join(); }\n \n     #[test]\n-    fn data() { assert_eq!(do Thread::start { 1 }.join(), 1); }\n+    fn data() { assert_eq!(Thread::start(proc () { 1 }).join(), 1); }\n \n     #[test]\n-    fn detached() { do Thread::spawn {} }\n+    fn detached() { Thread::spawn(proc () {}) }\n }"}, {"sha": "482477b2f0eb9ec27d488c427477f89807d5c6eb", "filename": "src/libstd/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -223,22 +223,22 @@ impl Process {\n         let (p, ch) = SharedChan::new();\n         let ch_clone = ch.clone();\n \n-        do spawn {\n+        spawn(proc() {\n             let _guard = io::ignore_io_error();\n             let mut error = error;\n             match error {\n                 Some(ref mut e) => ch.send((2, e.read_to_end())),\n                 None => ch.send((2, ~[]))\n             }\n-        }\n-        do spawn {\n+        });\n+        spawn(proc() {\n             let _guard = io::ignore_io_error();\n             let mut output = output;\n             match output {\n                 Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n                 None => ch_clone.send((1, ~[]))\n             }\n-        }\n+        });\n \n         let status = self.finish();\n \n@@ -414,9 +414,9 @@ mod tests {\n         os::close(pipe_out.out as int);\n         os::close(pipe_err.out as int);\n \n-        do spawn {\n+        spawn(proc() {\n             writeclose(pipe_in.out, \"test\");\n-        }\n+        });\n         let actual = readclose(pipe_out.input);\n         readclose(pipe_err.input);\n         process.finish();"}, {"sha": "7feff127d691a029511e7af37995d1b7b6bfc761", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -425,7 +425,7 @@ mod tests {\n         static AMT: int = 100000;\n         let mut pool = BufferPool::<int>::new();\n         let (mut w, s) = pool.deque();\n-        let t = do Thread::start {\n+        let t = Thread::start(proc() {\n             let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n@@ -437,7 +437,7 @@ mod tests {\n                     Abort | Empty => {}\n                 }\n             }\n-        };\n+        });\n \n         for _ in range(0, AMT) {\n             w.push(1);\n@@ -451,7 +451,7 @@ mod tests {\n         static AMT: int = 100000;\n         let mut pool = BufferPool::<(int, int)>::new();\n         let (mut w, s) = pool.deque();\n-        let t = do Thread::start {\n+        let t = Thread::start(proc() {\n             let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n@@ -461,7 +461,7 @@ mod tests {\n                     Abort | Empty => {}\n                 }\n             }\n-        };\n+        });\n \n         for _ in range(0, AMT) {\n             w.push((1, 10));\n@@ -480,7 +480,7 @@ mod tests {\n \n         let threads = range(0, nthreads).map(|_| {\n             let s = s.clone();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     while (*unsafe_remaining).load(SeqCst) > 0 {\n@@ -493,7 +493,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }\n+            })\n         }).to_owned_vec();\n \n         while remaining.load(SeqCst) > 0 {\n@@ -522,9 +522,9 @@ mod tests {\n         let mut pool = BufferPool::<~int>::new();\n         let threads = range(0, AMT).map(|_| {\n             let (w, s) = pool.deque();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 stampede(w, s, 4, 10000);\n-            }\n+            })\n         }).to_owned_vec();\n \n         for thread in threads.move_iter() {\n@@ -543,7 +543,7 @@ mod tests {\n \n         let threads = range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     loop {\n@@ -555,7 +555,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }\n+            })\n         }).to_owned_vec();\n \n         let mut rng = rand::task_rng();\n@@ -606,7 +606,7 @@ mod tests {\n             let thread_box = unsafe {\n                 *cast::transmute::<&~AtomicUint,**mut AtomicUint>(&unique_box)\n             };\n-            (do Thread::start {\n+            (Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     loop {\n@@ -620,7 +620,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }, unique_box)\n+            }), unique_box)\n         }));\n \n         let mut rng = rand::task_rng();"}, {"sha": "bb0e96f96de2b8417583d4f9e7119b3d2237a42b", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -177,21 +177,21 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = q.clone();\n             let chan = chan.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n                 chan.send(());\n-            }\n+            });\n         }\n \n         let mut completion_ports = ~[];\n         for _ in range(0, nthreads) {\n             let (completion_port, completion_chan) = Chan::new();\n             completion_ports.push(completion_port);\n             let q = q.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 let mut i = 0u;\n                 loop {\n@@ -204,7 +204,7 @@ mod tests {\n                     }\n                 }\n                 completion_chan.send(i);\n-            }\n+            });\n         }\n \n         for completion_port in completion_ports.mut_iter() {"}, {"sha": "1ec8ac5d83e055abe2ef14330c39585b5e8dd903", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -227,13 +227,13 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = p.clone();\n             let chan = chan.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n                 chan.send(());\n-            }\n+            });\n         }\n \n         let mut i = 0u;"}, {"sha": "35a5846f11aba287fc843ca4b16034d24b50dcbd", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -315,7 +315,7 @@ mod test {\n         fn stress_bound(bound: uint) {\n             let (c, mut p) = queue(bound, ());\n             let (port, chan) = Chan::new();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut c = c;\n                 for _ in range(0, 100000) {\n                     loop {\n@@ -327,7 +327,7 @@ mod test {\n                     }\n                 }\n                 chan.send(());\n-            }\n+            });\n             for _ in range(0, 100000) {\n                 p.push(1);\n             }"}, {"sha": "c8b690830866e9a763a9ce99bf53682298babc2a", "filename": "src/libstd/task.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -45,9 +45,9 @@\n  * # Example\n  *\n  * ```\n- * do spawn {\n+ * spawn(proc() {\n  *     log(error, \"Hello, World!\");\n- * }\n+ * })\n  * ```\n  */\n \n@@ -265,9 +265,9 @@ impl TaskBuilder {\n \n         let result = self.future_result();\n \n-        do self.spawn {\n+        self.spawn(proc() {\n             ch.send(f());\n-        }\n+        });\n \n         match result.recv() {\n             Ok(())     => Ok(po.recv()),\n@@ -365,83 +365,83 @@ pub fn failing() -> bool {\n \n #[test]\n fn test_unnamed_task() {\n-    do spawn {\n+    spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.is_none());\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_owned_named_task() {\n     let mut t = task();\n     t.name(~\"ada lovelace\");\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_static_named_task() {\n     let mut t = task();\n     t.name(\"ada lovelace\");\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_send_named_task() {\n     let mut t = task();\n     t.name(\"ada lovelace\".into_send_str());\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_run_basic() {\n     let (po, ch) = Chan::new();\n-    do task().spawn {\n+    task().spawn(proc() {\n         ch.send(());\n-    }\n+    });\n     po.recv();\n }\n \n #[test]\n fn test_add_wrapper() {\n     let (po, ch) = Chan::new();\n     let mut b0 = task();\n-    do b0.add_wrapper |body| {\n+    b0.add_wrapper(proc(body) {\n         let ch = ch;\n         let result: proc() = proc() {\n             body();\n             ch.send(());\n         };\n         result\n-    };\n-    do b0.spawn { }\n+    });\n+    b0.spawn(proc() { });\n     po.recv();\n }\n \n #[test]\n fn test_future_result() {\n     let mut builder = task();\n     let result = builder.future_result();\n-    do builder.spawn {}\n+    builder.spawn(proc() {});\n     assert!(result.recv().is_ok());\n \n     let mut builder = task();\n     let result = builder.future_result();\n-    do builder.spawn {\n+    builder.spawn(proc() {\n         fail!();\n-    }\n+    });\n     assert!(result.recv().is_err());\n }\n \n@@ -454,19 +454,19 @@ fn test_back_to_the_future_result() {\n \n #[test]\n fn test_try_success() {\n-    match do try {\n+    match try(proc() {\n         ~\"Success!\"\n-    } {\n+    }) {\n         result::Ok(~\"Success!\") => (),\n         _ => fail!()\n     }\n }\n \n #[test]\n fn test_try_fail() {\n-    match do try {\n+    match try(proc() {\n         fail!()\n-    } {\n+    }) {\n         result::Err(_) => (),\n         result::Ok(()) => fail!()\n     }\n@@ -480,13 +480,13 @@ fn test_spawn_sched() {\n \n     fn f(i: int, ch: SharedChan<()>) {\n         let ch = ch.clone();\n-        do spawn {\n+        spawn(proc() {\n             if i == 0 {\n                 ch.send(());\n             } else {\n                 f(i - 1, ch);\n             }\n-        };\n+        });\n \n     }\n     f(10, ch);\n@@ -497,12 +497,12 @@ fn test_spawn_sched() {\n fn test_spawn_sched_childs_on_default_sched() {\n     let (po, ch) = Chan::new();\n \n-    do spawn {\n+    spawn(proc() {\n         let ch = ch;\n-        do spawn {\n+        spawn(proc() {\n             ch.send(());\n-        };\n-    };\n+        });\n+    });\n \n     po.recv();\n }\n@@ -514,10 +514,10 @@ fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n-    do spawnfn {\n+    spawnfn(proc() {\n         let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n-    }\n+    });\n \n     let x_in_child = p.recv();\n     assert_eq!(x_in_parent, x_in_child);\n@@ -532,18 +532,18 @@ fn test_avoid_copying_the_body_spawn() {\n fn test_avoid_copying_the_body_task_spawn() {\n     avoid_copying_the_body(|f| {\n         let builder = task();\n-        do builder.spawn || {\n+        builder.spawn(proc() {\n             f();\n-        }\n+        });\n     })\n }\n \n #[test]\n fn test_avoid_copying_the_body_try() {\n     avoid_copying_the_body(|f| {\n-        do try || {\n+        try(proc() {\n             f()\n-        };\n+        });\n     })\n }\n \n@@ -575,9 +575,9 @@ fn test_simple_newsched_spawn() {\n \n #[test]\n fn test_try_fail_message_static_str() {\n-    match do try {\n+    match try(proc() {\n         fail!(\"static string\");\n-    } {\n+    }) {\n         Err(e) => {\n             type T = &'static str;\n             assert!(e.is::<T>());\n@@ -589,9 +589,9 @@ fn test_try_fail_message_static_str() {\n \n #[test]\n fn test_try_fail_message_owned_str() {\n-    match do try {\n+    match try(proc() {\n         fail!(~\"owned string\");\n-    } {\n+    }) {\n         Err(e) => {\n             type T = ~str;\n             assert!(e.is::<T>());\n@@ -603,9 +603,9 @@ fn test_try_fail_message_owned_str() {\n \n #[test]\n fn test_try_fail_message_any() {\n-    match do try {\n+    match try(proc() {\n         fail!(~413u16 as ~Any);\n-    } {\n+    }) {\n         Err(e) => {\n             type T = ~Any;\n             assert!(e.is::<T>());\n@@ -621,9 +621,9 @@ fn test_try_fail_message_any() {\n fn test_try_fail_message_unit_struct() {\n     struct Juju;\n \n-    match do try {\n+    match try(proc() {\n         fail!(Juju)\n-    } {\n+    }) {\n         Err(ref e) if e.is::<Juju>() => {}\n         Err(_) | Ok(()) => fail!()\n     }"}, {"sha": "87870ef033142c5b28998485babfaae2ab411907", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -41,18 +41,18 @@ pub fn run_in_bare_thread(f: proc()) {\n #[test]\n fn test_run_in_bare_thread() {\n     let i = 100;\n-    do run_in_bare_thread {\n+    run_in_bare_thread(proc() {\n         assert_eq!(i, 100);\n-    }\n+    });\n }\n \n #[test]\n fn test_run_in_bare_thread_exchange() {\n     // Does the exchange heap work without the runtime?\n     let i = ~100;\n-    do run_in_bare_thread {\n+    run_in_bare_thread(proc() {\n         assert!(i == ~100);\n-    }\n+    });\n }\n \n /// Dynamically inquire about whether we're running under V."}, {"sha": "39f0d7b5638bc366b5cef813ff2be6f8e9db9b6e", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -439,7 +439,7 @@ mod test {\n         let (p, c) = SharedChan::new();\n         for _ in range(0, 10) {\n             let c = c.clone();\n-            do spawn {\n+            spawn(proc() {\n                 for _ in range(0, 4) { task::deschedule() }\n                 unsafe {\n                     o.doit(|| {\n@@ -449,7 +449,7 @@ mod test {\n                     assert!(run);\n                 }\n                 c.send(());\n-            }\n+            });\n         }\n \n         unsafe {\n@@ -479,11 +479,11 @@ mod test {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n             lock.lock();\n-            let t = do Thread::start {\n+            let t = Thread::start(proc() {\n                 lock.lock();\n                 lock.signal();\n                 lock.unlock();\n-            };\n+            });\n             lock.wait();\n             lock.unlock();\n             t.join();"}, {"sha": "3b2c86c371217138a5cec130ebed2aeb007f8b28", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e7e7f8076d879f824f013faa6f7470e69c818b/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=25e7e7f8076d879f824f013faa6f7470e69c818b", "patch": "@@ -179,12 +179,12 @@ mod tests {\n                 let (port, chan) = Chan::new();\n                 futures.push(port);\n \n-                do task::spawn {\n+                task::spawn(proc() {\n                     for _ in range(0u, count) {\n                         total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n-                }\n+                });\n             };\n \n             for f in futures.mut_iter() { f.recv() }\n@@ -200,9 +200,9 @@ mod tests {\n             // accesses will also fail.\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n-            do task::try || {\n+            task::try(proc() {\n                 x2.with(|one| assert_eq!(*one, 2))\n-            };\n+            });\n             x.with(|one| assert_eq!(*one, 1));\n         }\n     }"}]}