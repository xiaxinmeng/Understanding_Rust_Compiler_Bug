{"sha": "9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNGU1YjNiNmNiZjliMzFhYzdiZDc0ZDc2MDIxNGUzNmU3OWJmZmY=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-05-10T00:16:10Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-05-10T00:16:12Z"}, "message": "Restore RawVec::reserve* documentation\n\nWhen the RawVec::try_reserve* methods were added, they took the place of\nthe ::reserve* methods in the source file, and new ::reserve* methods\nwrapping the new try_reserve* methods were created. But the\ndocumentation didn't move along, such that:\n - reserve_* methods are barely documented.\n - try_reserve_* methods have unmodified documentation from reserve_*,\n   such that their documentation indicate they are panicking/aborting.\n\nThis moves the documentation back to the right methods, with a\nplaceholder documentation for the try_reserve* methods.", "tree": {"sha": "19a92e41959342fd168c9edb52007ccc55459f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a92e41959342fd168c9edb52007ccc55459f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff", "html_url": "https://github.com/rust-lang/rust/commit/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f80f2a4f016bf724a1cfb580619d71c8fd39ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f80f2a4f016bf724a1cfb580619d71c8fd39ec", "html_url": "https://github.com/rust-lang/rust/commit/e5f80f2a4f016bf724a1cfb580619d71c8fd39ec"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "5c6f6b22aae068f23d8759c8043fc0da1e497d0a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9c4e5b3b6cbf9b31ac7bd74d760214e36e79bfff", "patch": "@@ -385,26 +385,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n-    ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n+    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n            -> Result<(), CollectionAllocErr> {\n \n@@ -441,6 +422,26 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// will reallocate the minimum possible amount of memory necessary.\n+    /// Generally this will be exactly the amount of memory necessary,\n+    /// but in principle the allocator is free to give back more than\n+    /// we asked for.\n+    ///\n+    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behavior of this function may break.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve_exact(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -463,6 +464,42 @@ impl<T, A: Alloc> RawVec<T, A> {\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n+    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+         unsafe {\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they give a bad `used_cap`\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+               return Ok(());\n+            }\n+\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+\n+             // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size())?;\n+\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+\n+            self.ptr = res?.cast().into();\n+            self.cap = new_cap;\n+\n+            Ok(())\n+        }\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -515,42 +552,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n-        -> Result<(), CollectionAllocErr> {\n-         unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-               return Ok(());\n-            }\n-\n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n-    }\n-\n-    /// The same as try_reserve, but errors are lowered to a call to oom().\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => capacity_overflow(),"}]}