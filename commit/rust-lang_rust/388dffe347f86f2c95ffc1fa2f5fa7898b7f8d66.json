{"sha": "388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OGRmZmUzNDdmODZmMmM5NWZmYzFmYTJmNWZhNzg5OGI3ZjhkNjY=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-04T19:56:41Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-04T19:56:41Z"}, "message": "Make conflicting borrow description more robust.\n\nThis commit improves the logic for place descriptions in conflicting\nborrow errors so that borrows of union fields have better messages even\nwhen the unions are embedded in other unions or structs.", "tree": {"sha": "438518312a0804db5be56440881b38a2cd696092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438518312a0804db5be56440881b38a2cd696092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlwvutgACgkQAXYLT59T\n8VQhdw/8DqyFD/lMpY185JJ/IBQ59v4tIY+0IeZCFMFcAqeAUv65AQaoo8v2Y0HN\nj5f4YcFx6CwrDtFSpIvvxtFu0mIQxkhk0WeCpAGhvKbXrgALTfsuoC9XdHxIU66y\nJs2gtseeVgyJmEpVx7shutnBeAeSTGehFQSStV0wy8iphNuWvDaMhpfFOYX19TV7\nsyyH2CAFPqda8HbYUcop1bigJjn701Grd4r9cFT1uHiJ/pjKQPgO2GgTb5lrYI/1\nhE1M+SMvn8tX69iqTAJt+X4LKSHdpSHbSWCgByJnqD/eJNLEryTTQ3jKaJRlDwds\nDtYwIR1q6JJO+dxRQdJoyHFDTWQcL0ZR07qrk0PPmeiD52mJ/QQhCzD+kHIm6N+J\nFZ11Zfaqt0QqGmsntwWJpM8OOKgxFak/93vgFF+PYok488sk4vtVO52onQyYEGLa\nGE6tKEuqB3PEdRSTDUxFE67g31vm2j9PtpZYDs50YXFJt3Hb742P8xpOQ3XNJ5ec\nOE8yzyOuglAx9OLJ01xoTDxv0P7BYVEhhh+Ok26bNWZXgtUcxJn1v4R6ADq0D2Qg\n5U0LWj3fKtv4LVeEs1tvmzmaixEChyW+upch7Dsv+llRoJaPFgEhnpmxaDTwV62f\njadbFuFQ/nuE3sMJp6mSf1EtTyglnGzRiojr2k1IB7q3rjV+vDw=\n=gnXz\n-----END PGP SIGNATURE-----", "payload": "tree 438518312a0804db5be56440881b38a2cd696092\nparent 69bded2493c964cb1d5cce4f708d221e242aff41\nauthor David Wood <david@davidtw.co> 1546631801 +0100\ncommitter David Wood <david@davidtw.co> 1546631801 +0100\n\nMake conflicting borrow description more robust.\n\nThis commit improves the logic for place descriptions in conflicting\nborrow errors so that borrows of union fields have better messages even\nwhen the unions are embedded in other unions or structs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "html_url": "https://github.com/rust-lang/rust/commit/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69bded2493c964cb1d5cce4f708d221e242aff41", "url": "https://api.github.com/repos/rust-lang/rust/commits/69bded2493c964cb1d5cce4f708d221e242aff41", "html_url": "https://github.com/rust-lang/rust/commit/69bded2493c964cb1d5cce4f708d221e242aff41"}], "stats": {"total": 218, "additions": 187, "deletions": 31}, "files": [{"sha": "aeba56cb7e26094849877e9c9b8f5ecc673ff986", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 91, "deletions": 31, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "patch": "@@ -329,16 +329,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"closure\"\n         };\n \n-        let (desc_place, msg_place, msg_borrow) = if issued_borrow.borrowed_place == *place {\n-            let desc_place = self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n-            (desc_place, \"\".to_string(), \"\".to_string())\n-        } else {\n-            let (desc_place, msg_place) = self.describe_place_for_conflicting_borrow(place);\n-            let (_, msg_borrow) = self.describe_place_for_conflicting_borrow(\n-                &issued_borrow.borrowed_place\n-            );\n-            (desc_place, msg_place, msg_borrow)\n-        };\n+        let (desc_place, msg_place, msg_borrow) = self.describe_place_for_conflicting_borrow(\n+            place, &issued_borrow.borrowed_place,\n+        );\n+        let via = |msg: String| if msg.is_empty() { msg } else { format!(\" (via `{}`)\", msg) };\n+        let msg_place = via(msg_place);\n+        let msg_borrow = via(msg_borrow);\n \n         let explanation = self.explain_why_borrow_contains_point(context, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() {\n@@ -526,33 +522,97 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n-    /// Returns a description of a place and an associated message for the purposes of conflicting\n-    /// borrow diagnostics.\n+    /// Returns the description of the root place for a conflicting borrow and the full\n+    /// descriptions of the places that caused the conflict.\n+    ///\n+    /// In the simplest case, where there are no unions involved, if a mutable borrow of `x` is\n+    /// attempted while a shared borrow is live, then this function will return:\n+    ///\n+    ///     (\"x\", \"\", \"\")\n     ///\n-    /// If the borrow is of the field `b` of a union `u`, then the return value will be\n-    /// `(\"u\", \" (via \\`u.b\\`)\")`. Otherwise, for some variable `a`, the return value will be\n-    /// `(\"a\", \"\")`.\n+    /// In the simple union case, if a mutable borrow of a union field `x.z` is attempted while\n+    /// a shared borrow of another field `x.y`, then this function will return:\n+    ///\n+    ///     (\"x\", \"x.z\", \"x.y\")\n+    ///\n+    /// In the more complex union case, where the union is a field of a struct, then if a mutable\n+    /// borrow of a union field in a struct `x.u.z` is attempted while a shared borrow of\n+    /// another field `x.u.y`, then this function will return:\n+    ///\n+    ///     (\"x.u\", \"x.u.z\", \"x.u.y\")\n+    ///\n+    /// This is used when creating error messages like below:\n+    ///\n+    /// >  cannot borrow `a.u` (via `a.u.z.c`) as immutable because it is also borrowed as\n+    /// >  mutable (via `a.u.s.b`) [E0502]\n     pub(super) fn describe_place_for_conflicting_borrow(\n         &self,\n-        place: &Place<'tcx>,\n-    ) -> (String, String) {\n-        place.base_local()\n-            .filter(|local| {\n-                // Filter out non-unions.\n-                self.mir.local_decls[*local].ty\n-                    .ty_adt_def()\n-                    .map(|adt| adt.is_union())\n-                    .unwrap_or(false)\n+        first_borrowed_place: &Place<'tcx>,\n+        second_borrowed_place: &Place<'tcx>,\n+    ) -> (String, String, String) {\n+        // Define a small closure that we can use to check if the type of a place\n+        // is a union.\n+        let is_union = |place: &Place<'tcx>| -> bool {\n+            place.ty(self.mir, self.infcx.tcx)\n+                .to_ty(self.infcx.tcx)\n+                .ty_adt_def()\n+                .map(|adt| adt.is_union())\n+                .unwrap_or(false)\n+        };\n+\n+        // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n+        // code duplication (particularly around returning an empty description in the failure\n+        // case).\n+        Some(())\n+            .filter(|_| {\n+                // If we have a conflicting borrow of the same place, then we don't want to add\n+                // an extraneous \"via x.y\" to our diagnostics, so filter out this case.\n+                first_borrowed_place != second_borrowed_place\n             })\n-            .and_then(|local| {\n-                let desc_base = self.describe_place(&Place::Local(local))\n-                    .unwrap_or_else(|| \"_\".to_owned());\n-                let desc_original = self.describe_place(place)\n-                    .unwrap_or_else(|| \"_\".to_owned());\n-                return Some((desc_base, format!(\" (via `{}`)\", desc_original)));\n+            .and_then(|_| {\n+                // We're going to want to traverse the first borrowed place to see if we can find\n+                // field access to a union. If we find that, then we will keep the place of the\n+                // union being accessed and the field that was being accessed so we can check the\n+                // second borrowed place for the same union and a access to a different field.\n+                let mut current = first_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                            return Some((base, field));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n+            })\n+            .and_then(|(target_base, target_field)| {\n+                // With the place of a union and a field access into it, we traverse the second\n+                // borrowed place and look for a access to a different field of the same union.\n+                let mut current = second_borrowed_place;\n+                while let Place::Projection(box PlaceProjection { base, elem }) = current {\n+                    match elem {\n+                        ProjectionElem::Field(field, _) if {\n+                            is_union(base) && field != target_field && base == target_base\n+                        } => {\n+                            let desc_base = self.describe_place(base)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_first = self.describe_place(first_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            let desc_second = self.describe_place(second_borrowed_place)\n+                                .unwrap_or_else(|| \"_\".to_owned());\n+                            return Some((desc_base, desc_first, desc_second));\n+                        },\n+                        _ => current = base,\n+                    }\n+                }\n+                None\n             })\n             .unwrap_or_else(|| {\n-                (self.describe_place(place).unwrap_or_else(|| \"_\".to_owned()), \"\".to_string())\n+                // If we didn't find a field access into a union, or both places match, then\n+                // only return the description of the first place.\n+                let desc_place = self.describe_place(first_borrowed_place)\n+                    .unwrap_or_else(|| \"_\".to_owned());\n+                (desc_place, \"\".to_string(), \"\".to_string())\n             })\n     }\n "}, {"sha": "f669fe00956ef5047bb2fcdc4f7b3f24a228b398", "filename": "src/test/ui/nll/issue-57100.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.rs?ref=388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "patch": "@@ -0,0 +1,69 @@\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+// ignore-tidy-linelength\n+\n+// This tests the error messages for borrows of union fields when the unions are embedded in other\n+// structs or unions.\n+\n+#[derive(Clone, Copy, Default)]\n+struct Leaf {\n+    l1_u8: u8,\n+    l2_u8: u8,\n+}\n+\n+#[derive(Clone, Copy)]\n+union First {\n+    f1_leaf: Leaf,\n+    f2_leaf: Leaf,\n+    f3_union: Second,\n+}\n+\n+#[derive(Clone, Copy)]\n+union Second {\n+    s1_leaf: Leaf,\n+    s2_leaf: Leaf,\n+}\n+\n+struct Root {\n+    r1_u8: u8,\n+    r2_union: First,\n+}\n+\n+// Borrow a different field of the nested union.\n+fn nested_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+        //                                  ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+        //                              ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+// Borrow a different field of the first union.\n+fn first_union() {\n+    unsafe {\n+        let mut r = Root {\n+            r1_u8: 3,\n+            r2_union: First { f3_union: Second { s2_leaf: Leaf { l1_u8: 8, l2_u8: 4 } } }\n+        };\n+\n+        let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+        //                         ^^^^^^^\n+        *mref = 22;\n+        let nref = &r.r2_union.f1_leaf.l1_u8;\n+        //                     ^^^^^^^\n+        //~^^ ERROR cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`) [E0502]\n+        println!(\"{} {}\", mref, nref)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "34dcdfc49478b935afebc1a7683174b92e0a5074", "filename": "src/test/ui/nll/issue-57100.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57100.stderr?ref=388dffe347f86f2c95ffc1fa2f5fa7898b7f8d66", "patch": "@@ -0,0 +1,27 @@\n+error[E0502]: cannot borrow `r.r2_union.f3_union` (via `r.r2_union.f3_union.s2_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:44:20\n+   |\n+LL |         let mref = &mut r.r2_union.f3_union.s1_leaf.l1_u8;\n+   |                    -------------------------------------- mutable borrow occurs here (via `r.r2_union.f3_union.s1_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f3_union.s2_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow occurs here (via `r.r2_union.f3_union.s2_leaf.l1_u8`)\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+\n+error[E0502]: cannot borrow `r.r2_union` (via `r.r2_union.f1_leaf.l1_u8`) as immutable because it is also borrowed as mutable (via `r.r2_union.f2_leaf.l1_u8`)\n+  --> $DIR/issue-57100.rs:62:20\n+   |\n+LL |         let mref = &mut r.r2_union.f2_leaf.l1_u8;\n+   |                    ----------------------------- mutable borrow occurs here (via `r.r2_union.f2_leaf.l1_u8`)\n+...\n+LL |         let nref = &r.r2_union.f1_leaf.l1_u8;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ immutable borrow occurs here (via `r.r2_union.f1_leaf.l1_u8`)\n+...\n+LL |         println!(\"{} {}\", mref, nref)\n+   |                           ---- mutable borrow later used here\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}]}