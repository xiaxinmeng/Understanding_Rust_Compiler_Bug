{"sha": "fdddf8f9e1d6738d42989a6d8a735dd58127e199", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZGRmOGY5ZTFkNjczOGQ0Mjk4OWE2ZDhhNzM1ZGQ1ODEyN2UxOTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-10T14:01:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-11T04:48:28Z"}, "message": "put serializer into the build and encode full item paths", "tree": {"sha": "9e324f85345957929daed40aedeaf52d0199b33d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e324f85345957929daed40aedeaf52d0199b33d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdddf8f9e1d6738d42989a6d8a735dd58127e199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdddf8f9e1d6738d42989a6d8a735dd58127e199", "html_url": "https://github.com/rust-lang/rust/commit/fdddf8f9e1d6738d42989a6d8a735dd58127e199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdddf8f9e1d6738d42989a6d8a735dd58127e199/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbcb54f4dc44957c9505958655a16e678ee4396b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcb54f4dc44957c9505958655a16e678ee4396b", "html_url": "https://github.com/rust-lang/rust/commit/dbcb54f4dc44957c9505958655a16e678ee4396b"}], "stats": {"total": 267, "additions": 238, "deletions": 29}, "files": [{"sha": "faee8e8d8636bd57ef032afb5e2deaec89b70381", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -410,6 +410,7 @@ TSREQS :=\t\t\t\t\t\t\t\t\t\t\t\\\n FUZZ := $(HBIN3_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n CARGO := $(HBIN3_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n RUSTDOC := $(HBIN3_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n+SERIALIZER := $(HBIN3_H_$(CFG_HOST_TRIPLE))/serializer$(X)\n \n all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC)\n "}, {"sha": "772de00f9c2ad6f8ed236833970f00637df8ddb0", "filename": "mk/tools.mk", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -16,6 +16,11 @@ CARGO_INPUTS := $(wildcard $(S)src/cargo/*rs)\n RUSTDOC_CRATE := $(S)src/rustdoc/rustdoc.rc\n RUSTDOC_INPUTS := $(wildcard $(S)src/rustdoc/*.rs)\n \n+# Serializer, generates serialization code\n+# (Should eventually move into a compiler ext)\n+SERIALIZER_CRATE := $(S)src/serializer/serializer.rc\n+SERIALIZER_INPUTS := $(wildcard $(S)src/serializer/*.rs)\n+\n # FIXME: These are only built for the host arch. Eventually we'll\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N\n@@ -83,6 +88,21 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n+$$(TBIN$(1)_T_$(4)_H_$(3))/serializer$$(X):\t\t\t\\\n+\t\t$$(SERIALIZER_CRATE) $$(SERIALIZER_INPUTS)\t\\\n+\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_CORELIB)\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_STDLIB)\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTC)\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$<\n+\n+$$(HBIN$(2)_H_$(4))/serializer$$(X):\t\t\t\t\\\n+\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/serializer$$(X)\t\\\n+\t\t$$(HSREQ$(2)_$(4))\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n endef\n \n $(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\t\\"}, {"sha": "32358794212d114e9b868a2b12119240417304ce", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -70,6 +70,13 @@ const tag_impl_iface: uint = 0x32u;\n // discriminator value for variants\n const tag_disr_val: uint = 0x34u;\n \n+// used to encode ast_map::path and ast_map::path_elt\n+const tag_path: uint = 0x40u;\n+const tag_path_len: uint = 0x41u;\n+const tag_path_elt_mod: uint = 0x42u;\n+const tag_path_elt_name: uint = 0x43u;\n+\n+\n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n "}, {"sha": "1ac86faed0d263d1ddb76931d2a5e748ae1cd814", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -2,7 +2,8 @@\n \n import syntax::ast;\n import syntax::ast_util;\n-import middle::ty;\n+import middle::{ty, ast_map};\n+import option::{some, none};\n import driver::session;\n \n export get_symbol;\n@@ -13,6 +14,7 @@ export get_impls_for_mod;\n export get_iface_methods;\n export get_type;\n export get_impl_iface;\n+export get_item_path;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n@@ -55,6 +57,12 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     ret result;\n }\n \n+fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n+    let cstore = tcx.sess.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    ret decoder::get_item_path(cdata, def.node);\n+}\n+\n fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "ccc0e3bfa2ac1e96669802588d19cff813217e34", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -6,6 +6,7 @@ import syntax::{ast, ast_util};\n import driver::session::session;\n import front::attr;\n import middle::ty;\n+import middle::ast_map;\n import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n import syntax::print::pprust;\n@@ -28,6 +29,7 @@ export get_crate_hash;\n export get_impls_for_mod;\n export get_iface_methods;\n export get_crate_module_paths;\n+export get_item_path;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -176,6 +178,30 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     ret result;\n }\n \n+fn item_path(item_doc: ebml::doc) -> ast_map::path {\n+    let path_doc = ebml::get_doc(item_doc, tag_path);\n+\n+    let len_doc = ebml::get_doc(path_doc, tag_path_len);\n+    let len = ebml::doc_as_uint(len_doc);\n+\n+    let result = [];\n+    vec::reserve(result, len);\n+\n+    ebml::docs(path_doc) {|tag, elt_doc|\n+        if tag == tag_path_elt_mod {\n+            let str = ebml::doc_str(elt_doc);\n+            result += [ast_map::path_mod(str)];\n+        } else if tag == tag_path_elt_name {\n+            let str = ebml::doc_str(elt_doc);\n+            result += [ast_map::path_name(str)];\n+        } else {\n+            // ignore tag_path_len element\n+        }\n+    }\n+\n+    ret result;\n+}\n+\n fn item_name(item: ebml::doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n     str::from_bytes(ebml::doc_data(name))\n@@ -234,6 +260,10 @@ fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n+fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n+    item_path(lookup_item(id, cdata.data))\n+}\n+\n fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> [ty::variant_info] {\n     let data = cdata.data;"}, {"sha": "89b188f92a4be111e3014008df946b8c2a6fb7c4", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -10,6 +10,7 @@ import common::*;\n import middle::trans::common::crate_ctxt;\n import middle::ty;\n import middle::ty::node_id_to_type;\n+import middle::ast_map;\n import front::attr;\n import driver::session::session;\n \n@@ -233,8 +234,9 @@ fn encode_enum_id(ebml_w: ebml::writer, id: def_id) {\n }\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                           id: node_id, variants: [variant],\n-                           &index: [entry<int>], ty_params: [ty_param]) {\n+                            id: node_id, variants: [variant],\n+                            path: ast_map::path, &index: [entry<int>],\n+                            ty_params: [ty_param]) {\n     let disr_val = 0;\n     let i = 0;\n     let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n@@ -256,14 +258,38 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             disr_val = vi[i].disr_val;\n         }\n         encode_type_param_bounds(ebml_w, ecx, ty_params);\n+        encode_path(ebml_w, path, ast_map::path_name(variant.node.name));\n         ebml::end_tag(ebml_w);\n         disr_val += 1;\n         i += 1;\n     }\n }\n \n+fn encode_path(ebml_w: ebml::writer,\n+               path: ast_map::path,\n+               name: ast_map::path_elt) {\n+    fn encode_path_elt(ebml_w: ebml::writer, elt: ast_map::path_elt) {\n+        let (tag, name) = alt elt {\n+          ast_map::path_mod(name) { (tag_path_elt_mod, name) }\n+          ast_map::path_name(name) { (tag_path_elt_name, name) }\n+        };\n+\n+        ebml_w.wr_tag(tag) {||\n+            ebml_w.wr_str(name)\n+        }\n+    }\n+\n+    ebml_w.wr_tag(tag_path) {||\n+        ebml_w.wr_tag(tag_path_len) {||\n+            ebml_w.wr_uint(vec::len(path) + 1u);\n+        }\n+        vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n+        encode_path_elt(ebml_w, name);\n+    }\n+}\n+\n fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n-                       id: node_id, name: ident) {\n+                       id: node_id, path: ast_map::path, name: ident) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm' as u8);\n@@ -281,11 +307,12 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n       _ { ecx.ccx.tcx.sess.bug(\"encode_info_for_mod: \\\n              undocumented invariant\"); }\n     }\n+    encode_path(ebml_w, path, ast_map::path_mod(name));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        &index: [entry<int>]) {\n+                        &index: [entry<int>], path: ast_map::path) {\n     let tcx = ecx.ccx.tcx;\n     alt item.node {\n       item_const(_, _) {\n@@ -294,6 +321,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'c' as u8);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_fn(decl, tps, _) {\n@@ -308,16 +336,18 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_mod(m) {\n-        encode_info_for_mod(ecx, ebml_w, m, item.id, item.ident);\n+        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n       }\n       item_native_mod(_) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n' as u8);\n         encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_ty(_, tps) {\n@@ -327,6 +357,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_enum(variants, tps) {\n@@ -339,8 +370,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n-        encode_enum_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n+        encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n+                                 path, index, tps);\n       }\n       item_class(_,_,_,_,_) {\n           fail \"encode: implement item_class\";\n@@ -355,6 +388,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n \n         index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n@@ -364,6 +398,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n       item_impl(tps, ifce, _, methods) {\n@@ -388,8 +423,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n           }\n           _ {}\n         }\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n \n+        let impl_path = path + [ast_map::path_name(item.ident)];\n         for m in methods {\n             index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -400,6 +437,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n+            encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n             ebml::end_tag(ebml_w);\n         }\n       }\n@@ -419,13 +457,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml::end_tag(ebml_w);\n             i += 1u;\n         }\n+        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml::end_tag(ebml_w);\n       }\n     }\n }\n \n fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                               nitem: @native_item) {\n+                               nitem: @native_item, path: ast_map::path) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt nitem.node {\n       native_item_fn(fn_decl, tps) {\n@@ -439,6 +478,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n+        encode_path(ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n     ebml::end_tag(ebml_w);\n@@ -449,16 +489,16 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n     index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n-    encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, \"\");\n+    encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, [], \"\");\n     ecx.ccx.ast_map.items {|key, val|\n         alt val {\n-          middle::ast_map::node_item(i, _) {\n+          middle::ast_map::node_item(i, path) {\n             index += [{val: key, pos: ebml_w.writer.tell()}];\n-            encode_info_for_item(ecx, ebml_w, i, index);\n+            encode_info_for_item(ecx, ebml_w, i, index, *path);\n           }\n-          middle::ast_map::node_native_item(i, _) {\n+          middle::ast_map::node_native_item(i, path) {\n             index += [{val: key, pos: ebml_w.writer.tell()}];\n-            encode_info_for_native_item(ecx, ebml_w, i);\n+            encode_info_for_native_item(ecx, ebml_w, i, *path);\n           }\n           _ { }\n         }"}, {"sha": "1504f5f738e08b42399e667bf8424a261d9c7293", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -6,6 +6,20 @@ import syntax::{visit, codemap};\n enum path_elt { path_mod(str), path_name(str) }\n type path = [path_elt];\n \n+fn path_to_str_with_sep(p: path, sep: str) -> str {\n+    let strs = vec::map(p) {|e|\n+        alt e {\n+          path_mod(s) { s }\n+          path_name(s) { s }\n+        }\n+    };\n+    str::connect(strs, sep)\n+}\n+\n+fn path_to_str(p: path) -> str {\n+    path_to_str_with_sep(p, \"::\")\n+}\n+\n enum ast_node {\n     node_item(@item, @path),\n     node_native_item(@native_item, @path),"}, {"sha": "019ba856e98aec579493c0bf952b4ce7e6cbdede", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -128,6 +128,7 @@ export ck_uniq;\n export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n+export item_path;\n \n // Data types\n \n@@ -2371,6 +2372,44 @@ fn substd_enum_variants(cx: ctxt, id: ast::def_id, tps: [ty::t])\n     }\n }\n \n+fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n+    if id.crate != ast::local_crate {\n+        csearch::get_item_path(cx, id)\n+    } else {\n+        let node = cx.items.get(id.node);\n+        alt node {\n+          ast_map::node_item(item, path) {\n+            let item_elt = alt item.node {\n+              item_mod(_) | item_native_mod(_) {\n+                ast_map::path_mod(item.ident)\n+              }\n+              _ {\n+                ast_map::path_name(item.ident)\n+              }\n+            };\n+            *path + [item_elt]\n+          }\n+\n+          ast_map::node_native_item(nitem, path) {\n+            *path + [ast_map::path_name(nitem.ident)]\n+          }\n+\n+          ast_map::node_method(method, path) {\n+            *path + [ast_map::path_name(method.ident)]\n+          }\n+\n+          ast_map::node_variant(variant, _, path) {\n+            vec::init(*path) + [ast_map::path_name(variant.node.name)]\n+          }\n+\n+          ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n+          ast_map::node_local(_) | ast_map::node_res_ctor(_) {\n+            cx.sess.bug(#fmt[\"cannot find item_path for node %?\", node]);\n+          }\n+        }\n+    }\n+}\n+\n fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     alt cx.enum_var_cache.find(id) {\n       some(variants) { ret variants; }"}, {"sha": "24337878a5c616646ee5abe28f7e9dda0cc59be6", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -110,6 +110,16 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n+      ty_enum(did, tps) {\n+        let path = ty::item_path(cx, did);\n+        let base = ast_map::path_to_str(path);\n+        if vec::is_empty(tps) {\n+            base\n+        } else {\n+            let tps_strs = vec::map(tps) {|t| ty_to_str(cx, t) };\n+            #fmt[\"%s<%s>\", base, str::connect(tps_strs, \",\")]\n+        }\n+      }\n       _ { ty_to_short_str(cx, typ) }\n     }\n }"}, {"sha": "5799211865fafc7eba2e812a3a5abf625c3f1118", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -20,6 +20,20 @@ This is 2^wordsize - 1\n */\n const max_value: uint = 0u - 1u;\n \n+/*\n+Function: max\n+*/\n+fn max(x: uint, y: uint) -> uint {\n+    if x > y { x } else { y }\n+}\n+\n+/*\n+Function: min\n+*/\n+fn min(x: uint, y: uint) -> uint {\n+    if x < y { x } else { y }\n+}\n+\n /* Function: add */\n pure fn add(x: uint, y: uint) -> uint { ret x + y; }\n \n@@ -252,6 +266,15 @@ Convert to a string\n */\n fn str(i: uint) -> str { ret to_str(i, 10u); }\n \n+/*\n+Function: compl\n+\n+Computes the bitwise complement.\n+*/\n+fn compl(i: uint) -> uint {\n+    uint::max_value ^ i\n+}\n+\n #[cfg(test)]\n mod tests {\n "}, {"sha": "bee738145805bd5371c1b02eafe30fa1e2455bfb", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -97,6 +97,8 @@ fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n \n fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n \n+fn doc_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n+\n fn be_uint_from_bytes(data: @[u8], start: uint, size: uint) -> uint {\n     let sz = size;\n     assert (sz <= 4u);\n@@ -136,11 +138,11 @@ fn write_sized_vint(w: io::writer, n: uint, size: uint) {\n     w.write(buf);\n }\n \n-fn write_vint(w: io::writer, n: uint) {\n-    if n < 0x7fu { write_sized_vint(w, n, 1u); ret; }\n-    if n < 0x4000u { write_sized_vint(w, n, 2u); ret; }\n-    if n < 0x200000u { write_sized_vint(w, n, 3u); ret; }\n-    if n < 0x10000000u { write_sized_vint(w, n, 4u); ret; }\n+fn write_vint(w: io::writer, n: u64) {\n+    if n < 0x7f_u64 { write_sized_vint(w, n, 1u); ret; }\n+    if n < 0x4000_u64 { write_sized_vint(w, n, 2u); ret; }\n+    if n < 0x200000_u64 { write_sized_vint(w, n, 3u); ret; }\n+    if n < 0x10000000_u64 { write_sized_vint(w, n, 4u); ret; }\n     #error(\"vint to write too big\");\n     fail;\n }\n@@ -177,7 +179,11 @@ impl writer_util for writer {\n         end_tag(self);\n     }\n \n-    fn wr_uint(id: uint) {\n+    fn wr_uint(id: u64) {\n+        write_vint(self.writer, id);\n+    }\n+\n+    fn wr_int(id: uint) {\n         write_vint(self.writer, id);\n     }\n "}, {"sha": "50ff84ee0bcfc2359b36d0a4471a0f3f9a955aa7", "filename": "src/serializer/serializer", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fserializer", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fserializer", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199"}, {"sha": "80b51ba78a7a55a1a1f5ebb5251cd71ef825404e", "filename": "src/serializer/serializer.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -106,12 +106,8 @@ impl serialize_ctx for serialize_ctx {\n         ret tps_map;\n     }\n \n-    fn path(mod_: [str], id: str) -> str {\n-        str::connect(mod_ + [id], \"::\")\n-    }\n-\n-    fn ident(mod_: [str], id: str) -> str {\n-        str::connect(mod_ + [id], \"_\")\n+    fn ident(base_path: ast_map::path, id: str) -> str {\n+        #fmt[\"%s_%s\", ast_map::path_to_str_with_sep(base_path, \"_\"), id]\n     }\n \n     fn instantiate(id: ast::def_id, args: [ty::t]) -> ty::t {\n@@ -134,7 +130,11 @@ impl serialize_ctx for serialize_ctx {\n     }\n \n     fn blk(stmts: [ast_stmt]) -> ast_blk {\n-        \"{\" + str::connect(stmts, \";\") + \"}\"\n+        if vec::is_empty(stmts) {\n+            \"\"\n+        } else {\n+            \"{\" + str::connect(stmts, \";\") + \"}\"\n+        }\n     }\n \n     fn blk_expr(stmts: [ast_stmt]) -> ast_expr {\n@@ -159,6 +159,7 @@ impl serialize_ctx for serialize_ctx {\n         // in case of recursive calls:\n         let id = self.tyfns.size();\n         let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n+        #debug[\"ty0_str = %s / ty0 = %?\", ty0_str, ty0];\n         let name = #fmt[\"serialize_%u /*%s*/\", id, ty0_str];\n         self.tyfns.insert(ty0, name);\n         let v = \"v\";\n@@ -221,11 +222,11 @@ impl serialize_ctx for serialize_ctx {\n     fn serialize_enum(v: ast_expr,\n                       id: ast::def_id,\n                       tps: [ty::t]) -> ast_expr {\n-        let path = [];\n         let variants = ty::substd_enum_variants(self.tcx, id, tps);\n \n         let arms = vec::map(variants) {|variant|\n-            let v_path = self.path(path, variant.name);\n+            let item_path = ty::item_path(self.tcx, variant.id);\n+            let v_path = ast_map::path_to_str(item_path);\n             let n_args = vec::len(variant.args);\n             let (v_pat, stmts) = {\n                 if n_args == 0u {\n@@ -235,7 +236,8 @@ impl serialize_ctx for serialize_ctx {\n                 }\n             };\n \n-            let v_const = #fmt[\"at_%s\", self.ident(path, variant.name)];\n+            let v_ident = ast_map::path_to_str_with_sep(item_path, \"_\");\n+            let v_const = #fmt[\"at_%s\", v_ident];\n \n             #fmt[\"%s { \\\n                     start_variant(cx, %s); \\"}, {"sha": "b1d255f49397d4027cc3c14db9f6a31e938e483b", "filename": "src/serializer/stest.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fstest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Fserializer%2Fstest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fstest.rs?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199", "patch": "@@ -28,4 +28,13 @@ type test5 = {\n \n type test6 = option<int>;\n \n+mod test7 {\n+    enum testa {\n+    }\n+\n+    enum testb {\n+        t4_a(@testa), t4_b(@testb)\n+    }\n+}\n+\n fn main() {}\n\\ No newline at end of file"}, {"sha": "0c4c440cafac9d4a86984b2b1e6a7fc3b1c6da76", "filename": "src/test/run-pass/qquote", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Ftest%2Frun-pass%2Fqquote", "raw_url": "https://github.com/rust-lang/rust/raw/fdddf8f9e1d6738d42989a6d8a735dd58127e199/src%2Ftest%2Frun-pass%2Fqquote", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fqquote?ref=fdddf8f9e1d6738d42989a6d8a735dd58127e199"}]}