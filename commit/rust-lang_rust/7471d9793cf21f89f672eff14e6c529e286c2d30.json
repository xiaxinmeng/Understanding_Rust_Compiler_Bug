{"sha": "7471d9793cf21f89f672eff14e6c529e286c2d30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NzFkOTc5M2NmMjFmODlmNjcyZWZmMTRlNmM1MjllMjg2YzJkMzA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-20T00:51:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-20T00:51:09Z"}, "message": "Rollup merge of #40532 - jseyfried:improve_tokenstream_quoter, r=nrc\n\nmacros: improve the `TokenStream` quoter\n\nThis PR\n - renames the `TokenStream` quoter from `qquote!` to `quote!`,\n - uses `$` instead of `unquote` (e.g. `let toks: TokenStream = ...; quote!([$toks])`),\n - allows unquoting `Token`s as well as `TokenTree`s and `TokenStream`s (fixes #39746), and\n - to preserve syntactic space, requires that `$` be followed by\n   - a single identifier to unquote, or\n   - another `$` to produce a literal `$`.\n\nr? @nrc", "tree": {"sha": "55ef7bc3a856def3bd1872fffa093acee516f61a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55ef7bc3a856def3bd1872fffa093acee516f61a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7471d9793cf21f89f672eff14e6c529e286c2d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7471d9793cf21f89f672eff14e6c529e286c2d30", "html_url": "https://github.com/rust-lang/rust/commit/7471d9793cf21f89f672eff14e6c529e286c2d30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7471d9793cf21f89f672eff14e6c529e286c2d30/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d1543d5667ef1dddf03aa1aeed77851b604f704", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1543d5667ef1dddf03aa1aeed77851b604f704", "html_url": "https://github.com/rust-lang/rust/commit/1d1543d5667ef1dddf03aa1aeed77851b604f704"}, {"sha": "ce616a7d6ad838aacd080b47566c15e82ad8dd6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce616a7d6ad838aacd080b47566c15e82ad8dd6d", "html_url": "https://github.com/rust-lang/rust/commit/ce616a7d6ad838aacd080b47566c15e82ad8dd6d"}], "stats": {"total": 136, "additions": 77, "deletions": 59}, "files": [{"sha": "a6dad64125331cc4c6ab5d903615fffbe8be4389", "filename": "src/libproc_macro_plugin/lib.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -13,62 +13,64 @@\n //! A library for procedural macro writers.\n //!\n //! ## Usage\n-//! This crate provides the `qquote!` macro for syntax creation.\n+//! This crate provides the `quote!` macro for syntax creation.\n //!\n-//! The `qquote!` macro uses the crate `syntax`, so users must declare `extern crate syntax;`\n+//! The `quote!` macro uses the crate `syntax`, so users must declare `extern crate syntax;`\n //! at the crate root. This is a temporary solution until we have better hygiene.\n //!\n //! ## Quasiquotation\n //!\n //! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n-//! input. For example, `qquote!(5 + 5)` will produce a program, that, when run, will\n+//! input. For example, `quote!(5 + 5)` will produce a program, that, when run, will\n //! construct the TokenStream `5 | + | 5`.\n //!\n //! ### Unquoting\n //!\n-//! Unquoting is currently done as `unquote`, and works by taking the single next\n-//! TokenTree in the TokenStream as the unquoted term. Ergonomically, `unquote(foo)` works\n-//! fine, but `unquote foo` is also supported.\n+//! Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n+//! To quote `$` itself, use `$$`.\n //!\n-//! A simple example might be:\n+//! A simple example is:\n //!\n //!```\n //!fn double(tmp: TokenStream) -> TokenStream {\n-//!    qquote!(unquote(tmp) * 2)\n+//!    quote!($tmp * 2)\n //!}\n //!```\n //!\n-//! ### Large Example: Implementing Scheme's `cond`\n+//! ### Large example: Scheme's `cond`\n //!\n-//! Below is the full implementation of Scheme's `cond` operator.\n+//! Below is an example implementation of Scheme's `cond`.\n //!\n //! ```\n-//! fn cond_rec(input: TokenStream) -> TokenStream {\n-//!   if input.is_empty() { return quote!(); }\n-//!\n-//!   let next = input.slice(0..1);\n-//!   let rest = input.slice_from(1..);\n-//!\n-//!   let clause : TokenStream = match next.maybe_delimited() {\n-//!     Some(ts) => ts,\n-//!     _ => panic!(\"Invalid input\"),\n-//!   };\n-//!\n-//!   // clause is ([test]) [rhs]\n-//!   if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n-//!\n-//!   let test: TokenStream = clause.slice(0..1);\n-//!   let rhs: TokenStream = clause.slice_from(1..);\n-//!\n-//!   if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n-//!     quote!({unquote(rhs)})\n-//!   } else {\n-//!     quote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n-//!   }\n+//! fn cond(input: TokenStream) -> TokenStream {\n+//!     let mut conds = Vec::new();\n+//!     let mut input = input.trees().peekable();\n+//!     while let Some(tree) = input.next() {\n+//!         let mut cond = match tree {\n+//!             TokenTree::Delimited(_, ref delimited) => delimited.stream(),\n+//!             _ => panic!(\"Invalid input\"),\n+//!         };\n+//!         let mut trees = cond.trees();\n+//!         let test = trees.next();\n+//!         let rhs = trees.collect::<TokenStream>();\n+//!         if rhs.is_empty() {\n+//!             panic!(\"Invalid macro usage in cond: {}\", cond);\n+//!         }\n+//!         let is_else = match test {\n+//!             Some(TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"else\" => true,\n+//!             _ => false,\n+//!         };\n+//!         conds.push(if is_else || input.peek().is_none() {\n+//!             quote!({ $rhs })\n+//!         } else {\n+//!             let test = test.unwrap();\n+//!             quote!(if $test { $rhs } else)\n+//!         });\n+//!     }\n+//!\n+//!     conds.into_iter().collect()\n //! }\n //! ```\n-//!\n-\n #![crate_name = \"proc_macro_plugin\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![feature(plugin_registrar)]\n@@ -87,8 +89,8 @@ extern crate rustc_plugin;\n extern crate syntax;\n extern crate syntax_pos;\n \n-mod qquote;\n-use qquote::qquote;\n+mod quote;\n+use quote::quote;\n \n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n@@ -99,6 +101,6 @@ use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(Symbol::intern(\"qquote\"),\n-                                  SyntaxExtension::ProcMacro(Box::new(qquote)));\n+    reg.register_syntax_extension(Symbol::intern(\"quote\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(quote)));\n }"}, {"sha": "ad71584b61a0fbf611965a1bc8af7758494f7073", "filename": "src/libproc_macro_plugin/quote.rs", "status": "renamed", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibproc_macro_plugin%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibproc_macro_plugin%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fquote.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::DUMMY_SP;\n \n use std::iter;\n \n-pub fn qquote<'cx>(stream: TokenStream) -> TokenStream {\n+pub fn quote<'cx>(stream: TokenStream) -> TokenStream {\n     stream.quote()\n }\n \n@@ -72,28 +72,32 @@ impl Quote for TokenStream {\n             return quote!(::syntax::tokenstream::TokenStream::empty());\n         }\n \n-        struct Quote(iter::Peekable<tokenstream::Cursor>);\n+        struct Quoter(iter::Peekable<tokenstream::Cursor>);\n \n-        impl Iterator for Quote {\n+        impl Iterator for Quoter {\n             type Item = TokenStream;\n \n             fn next(&mut self) -> Option<TokenStream> {\n-                let is_unquote = match self.0.peek() {\n-                    Some(&TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n-                        self.0.next();\n-                        true\n+                let quoted_tree = if let Some(&TokenTree::Token(_, Token::Dollar)) = self.0.peek() {\n+                    self.0.next();\n+                    match self.0.next() {\n+                        Some(tree @ TokenTree::Token(_, Token::Ident(..))) => Some(tree.into()),\n+                        Some(tree @ TokenTree::Token(_, Token::Dollar)) => Some(tree.quote()),\n+                        // FIXME(jseyfried): improve these diagnostics\n+                        Some(..) => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n+                        None => panic!(\"unexpected trailing `$` in `quote!`\"),\n                     }\n-                    _ => false,\n+                } else {\n+                    self.0.next().as_ref().map(Quote::quote)\n                 };\n \n-                self.0.next().map(|tree| {\n-                    let quoted_tree = if is_unquote { tree.into() } else { tree.quote() };\n+                quoted_tree.map(|quoted_tree| {\n                     quote!(::syntax::tokenstream::TokenStream::from((unquote quoted_tree)),)\n                 })\n             }\n         }\n \n-        let quoted = Quote(self.trees().peekable()).collect::<TokenStream>();\n+        let quoted = Quoter(self.trees().peekable()).collect::<TokenStream>();\n         quote!([(unquote quoted)].iter().cloned().collect::<::syntax::tokenstream::TokenStream>())\n     }\n }", "previous_filename": "src/libproc_macro_plugin/qquote.rs"}, {"sha": "b75b3efda36c8d8670dae90b0541797095cc0d74", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -162,6 +162,12 @@ impl From<TokenTree> for TokenStream {\n     }\n }\n \n+impl From<Token> for TokenStream {\n+    fn from(token: Token) -> TokenStream {\n+        TokenTree::Token(DUMMY_SP, token).into()\n+    }\n+}\n+\n impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n         TokenStream::concat(iter.into_iter().map(Into::into).collect::<Vec<_>>())"}, {"sha": "0433b95865ef8c4591479fb9a660d93fd8b38ce2", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -49,9 +49,10 @@ fn cond(input: TokenStream) -> TokenStream {\n             _ => false,\n         };\n         conds.push(if is_else || input.peek().is_none() {\n-            qquote!({ unquote rhs })\n+            quote!({ $rhs })\n         } else {\n-            qquote!(if unquote(test.unwrap()) { unquote rhs } else)\n+            let test = test.unwrap();\n+            quote!(if $test { $rhs } else)\n         });\n     }\n "}, {"sha": "9522592a5e9e6642d79c072bf873c78e78770682", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -29,6 +29,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n // This macro is not very interesting, but it does contain delimited tokens with\n // no content - `()` and `{}` - which has caused problems in the past.\n+// Also, it tests that we can escape `$` via `$$`.\n fn hello(_: TokenStream) -> TokenStream {\n-    qquote!({ fn hello() {} hello(); })\n+    quote!({\n+        fn hello() {}\n+        macro_rules! m { ($$($$t:tt)*) => { $$($$t)* } }\n+        m!(hello());\n+    })\n }"}, {"sha": "0e37a7a5dcce22f8daf5d603513812ac44c0689b", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -34,21 +34,21 @@ pub fn plugin_registrar(reg: &mut Registry) {\n }\n \n fn attr_tru(_attr: TokenStream, _item: TokenStream) -> TokenStream {\n-    qquote!(fn f1() -> bool { true })\n+    quote!(fn f1() -> bool { true })\n }\n \n fn attr_identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n-    qquote!(unquote item)\n+    quote!($item)\n }\n \n fn tru(_ts: TokenStream) -> TokenStream {\n-    qquote!(true)\n+    quote!(true)\n }\n \n fn ret_tru(_ts: TokenStream) -> TokenStream {\n-    qquote!(return true;)\n+    quote!(return true;)\n }\n \n fn identity(ts: TokenStream) -> TokenStream {\n-    qquote!(unquote ts)\n+    quote!($ts)\n }"}, {"sha": "01b0ed802354c74e19f15f217738caa7bf50a685", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "patch": "@@ -22,6 +22,6 @@ use syntax::parse::token;\n use syntax::tokenstream::TokenTree;\n \n fn main() {\n-    let true_tok = TokenTree::Token(syntax_pos::DUMMY_SP, token::Ident(Ident::from_str(\"true\")));\n-    assert!(qquote!(true).eq_unspanned(&true_tok.into()));\n+    let true_tok = token::Ident(Ident::from_str(\"true\"));\n+    assert!(quote!(true).eq_unspanned(&true_tok.into()));\n }"}, {"sha": "bdbea8a419416f7db089719dcb19587c913bc711", "filename": "src/test/run-pass-fulldeps/macro-quote-test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7471d9793cf21f89f672eff14e6c529e286c2d30/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs?ref=7471d9793cf21f89f672eff14e6c529e286c2d30", "previous_filename": "src/test/run-pass-fulldeps/macro-quote-empty-delims.rs"}]}