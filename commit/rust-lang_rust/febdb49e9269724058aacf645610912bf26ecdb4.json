{"sha": "febdb49e9269724058aacf645610912bf26ecdb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYmRiNDllOTI2OTcyNDA1OGFhY2Y2NDU2MTA5MTJiZjI2ZWNkYjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-28T00:28:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-28T21:03:49Z"}, "message": "Change bare functions so that they are represented by a single pointer.\n\nThe basic idea is that we add a new kind of adjustment, AutoAddEnv, that pads\nan extern fn into a closure by adding the extra NULL word. Then there are a few\nmisc changes in trans to get the LLVM types to match up.\n\nFixes #4808.", "tree": {"sha": "dce869ea86f1bba8ced97212497e4a6a309ad922", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce869ea86f1bba8ced97212497e4a6a309ad922"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/febdb49e9269724058aacf645610912bf26ecdb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/febdb49e9269724058aacf645610912bf26ecdb4", "html_url": "https://github.com/rust-lang/rust/commit/febdb49e9269724058aacf645610912bf26ecdb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/febdb49e9269724058aacf645610912bf26ecdb4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85aaf392914626441b3b681edb4d79552e078781", "url": "https://api.github.com/repos/rust-lang/rust/commits/85aaf392914626441b3b681edb4d79552e078781", "html_url": "https://github.com/rust-lang/rust/commit/85aaf392914626441b3b681edb4d79552e078781"}], "stats": {"total": 439, "additions": 311, "deletions": 128}, "files": [{"sha": "1b6452e977e4a78433ad9563658f613fb58c8efc", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -451,9 +451,17 @@ impl tr for ast::def {\n \n impl tr for ty::AutoAdjustment {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        ty::AutoAdjustment {\n-            autoderefs: self.autoderefs,\n-            autoref: self.autoref.map(|ar| ar.tr(xcx)),\n+        match self {\n+            &ty::AutoAddEnv(r, s) => {\n+                ty::AutoAddEnv(r.tr(xcx), s)\n+            }\n+\n+            &ty::AutoDerefRef(ref adr) => {\n+                ty::AutoDerefRef(ty::AutoDerefRef {\n+                    autoderefs: adr.autoderefs,\n+                    autoref: adr.autoref.map(|ar| ar.tr(xcx)),\n+                })\n+            }\n         }\n     }\n }"}, {"sha": "236592874cb1629ce2dde9728ea7ba9f861da922", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -299,17 +299,27 @@ impl GatherLoanCtxt {\n                expr_repr(self.tcx(), expr), adjustment);\n         let _i = indenter();\n \n-        match adjustment.autoref {\n-            None => {\n+        match *adjustment {\n+            ty::AutoAddEnv(*) => {\n+                debug!(\"autoaddenv -- no autoref\");\n+                return;\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: None, _ }) => {\n                 debug!(\"no autoref\");\n                 return;\n             }\n \n-            Some(ref autoref) => {\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: Some(ref autoref),\n+                    autoderefs: autoderefs}) => {\n                 let mcx = &mem_categorization_ctxt {\n                     tcx: self.tcx(),\n                     method_map: self.bccx.method_map};\n-                let mut cmt = mcx.cat_expr_autoderefd(expr, adjustment);\n+                let mut cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n                 debug!(\"after autoderef, cmt=%s\", self.bccx.cmt_to_repr(cmt));\n \n                 match autoref.kind {"}, {"sha": "87ff8554fd99e049c330631e1e0f18d543c9f104", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -478,9 +478,20 @@ pub impl BorrowckCtxt {\n     }\n \n     fn cat_expr_autoderefd(&self, expr: @ast::expr,\n-                           adj: @ty::AutoAdjustment)\n-                        -> cmt {\n-        cat_expr_autoderefd(self.tcx, self.method_map, expr, adj)\n+                           adj: @ty::AutoAdjustment) -> cmt {\n+        match *adj {\n+            ty::AutoAddEnv(*) => {\n+                // no autoderefs\n+                cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+            }\n+\n+            ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoderefs: autoderefs, _}) => {\n+                cat_expr_autoderefd(self.tcx, self.method_map, expr,\n+                                    autoderefs)\n+            }\n+        }\n     }\n \n     fn cat_def(&self,"}, {"sha": "e1a2079be25f0fac936aee3a7977c8fc7d44972e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -241,12 +241,12 @@ pub fn cat_expr_autoderefd(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n     expr: @ast::expr,\n-    adj: @ty::AutoAdjustment) -> cmt {\n-\n+    autoderefs: uint) -> cmt\n+{\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n     };\n-    return mcx.cat_expr_autoderefd(expr, adj);\n+    return mcx.cat_expr_autoderefd(expr, autoderefs);\n }\n \n pub fn cat_def(\n@@ -361,28 +361,38 @@ pub impl mem_categorization_ctxt {\n                 self.cat_expr_unadjusted(expr)\n             }\n \n-            Some(adjustment) => {\n-                match adjustment.autoref {\n-                    Some(_) => {\n-                        // Equivalent to &*expr or something similar.\n-                        // This is an rvalue, effectively.\n-                        let expr_ty = ty::expr_ty(self.tcx, expr);\n-                        self.cat_rvalue(expr, expr_ty)\n-                    }\n-                    None => {\n-                        // Equivalent to *expr or something similar.\n-                        self.cat_expr_autoderefd(expr, adjustment)\n-                    }\n-                }\n+            Some(@ty::AutoAddEnv(*)) => {\n+                // Convert a bare fn to a closure by adding NULL env.\n+                // Result is an rvalue.\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                self.cat_rvalue(expr, expr_ty)\n+            }\n+\n+            Some(\n+                @ty::AutoDerefRef(\n+                    ty::AutoDerefRef {\n+                        autoref: Some(_), _})) => {\n+                // Equivalent to &*expr or something similar.\n+                // Result is an rvalue.\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                self.cat_rvalue(expr, expr_ty)\n+            }\n+\n+            Some(\n+                @ty::AutoDerefRef(\n+                    ty::AutoDerefRef {\n+                        autoref: None, autoderefs: autoderefs})) => {\n+                // Equivalent to *expr or something similar.\n+                self.cat_expr_autoderefd(expr, autoderefs)\n             }\n         }\n     }\n \n     fn cat_expr_autoderefd(&self,\n                            expr: @ast::expr,\n-                           adjustment: &ty::AutoAdjustment) -> cmt {\n+                           autoderefs: uint) -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n-        for uint::range(1, adjustment.autoderefs+1) |deref| {\n+        for uint::range(1, autoderefs+1) |deref| {\n             cmt = self.cat_deref(expr, cmt, deref);\n         }\n         return cmt;"}, {"sha": "8e344c0afc7bd5be45c489caffa60406176e6428", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -410,7 +410,9 @@ impl VisitContext {\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n         let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n-            Some(adj) if adj.autoref.is_some() => Read,\n+            Some(@ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoref: Some(_), _})) => Read,\n             _ => expr_mode.component_mode(expr)\n         };\n "}, {"sha": "ff37e6d76c652b4b1fde7d9452ee88f7ce055702", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -82,10 +82,25 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n     }\n \n     // any other expressions are closures:\n-    return closure_callee(&expr::trans_to_datum(bcx, expr));\n-\n-    fn closure_callee(db: &DatumBlock) -> Callee {\n-        return Callee {bcx: db.bcx, data: Closure(db.datum)};\n+    return datum_callee(bcx, expr);\n+\n+    fn datum_callee(bcx: block, expr: @ast::expr) -> Callee {\n+        let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n+        match ty::get(datum.ty).sty {\n+            ty::ty_bare_fn(*) => {\n+                let llval = datum.to_appropriate_llval(bcx);\n+                return Callee {bcx: bcx, data: Fn(FnData {llfn: llval})};\n+            }\n+            ty::ty_closure(*) => {\n+                return Callee {bcx: bcx, data: Closure(datum)};\n+            }\n+            _ => {\n+                bcx.tcx().sess.span_bug(\n+                    expr.span,\n+                    fmt!(\"Type of callee is neither bare-fn nor closure: %s\",\n+                         bcx.ty_to_str(datum.ty)));\n+            }\n+        }\n     }\n \n     fn fn_callee(bcx: block, fd: FnData) -> Callee {\n@@ -117,7 +132,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             ast::def_binding(*) |\n             ast::def_upvar(*) |\n             ast::def_self(*) => {\n-                closure_callee(&expr::trans_to_datum(bcx, ref_expr))\n+                datum_callee(bcx, ref_expr)\n             }\n             ast::def_mod(*) | ast::def_foreign_mod(*) |\n             ast::def_const(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n@@ -380,7 +395,6 @@ pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n                                                     fty);\n                     let mut llfnty = type_of::type_of(callee.bcx.ccx(),\n                                                       substituted);\n-                    llfnty = lib::llvm::struct_tys(llfnty)[0];\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n                 _ => fail!()\n@@ -703,6 +717,8 @@ pub fn trans_arg_expr(bcx: block,\n                     }\n \n                     ast::by_copy => {\n+                        debug!(\"by copy arg with type %s, storing to scratch\",\n+                               ty_to_str(ccx.tcx, arg_datum.ty));\n                         let scratch = scratch_datum(bcx, arg_datum.ty, false);\n \n                         arg_datum.store_to_datum(bcx, arg_expr.id,"}, {"sha": "04fefd4fb334fc0808e6a2f032f8fb01a9417e39", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -1344,6 +1344,12 @@ pub fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n+pub fn expr_ty_adjusted(bcx: block, ex: @ast::expr) -> ty::t {\n+    let tcx = bcx.tcx();\n+    let t = ty::expr_ty_adjusted(tcx, ex);\n+    monomorphize_type(bcx, t)\n+}\n+\n pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);"}, {"sha": "8ceb539351e17074042a67011e2cc6cd96a3a797", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 94, "deletions": 43, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -136,7 +136,8 @@ use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::tvec;\n use middle::ty::struct_mutable_fields;\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n+use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n+                 AutoDerefRef, AutoAddEnv};\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n@@ -189,7 +190,14 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         None => {\n             trans_to_datum_unadjusted(bcx, expr)\n         }\n-        Some(adj) => {\n+        Some(@AutoAddEnv(*)) => {\n+            let mut bcx = bcx;\n+            let mut datum = unpack_datum!(bcx, {\n+                trans_to_datum_unadjusted(bcx, expr)\n+            });\n+            add_env(bcx, expr, datum)\n+        }\n+        Some(@AutoDerefRef(ref adj)) => {\n             let mut bcx = bcx;\n             let mut datum = unpack_datum!(bcx, {\n                 trans_to_datum_unadjusted(bcx, expr)\n@@ -258,6 +266,25 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n+    fn add_env(bcx: block, expr: @ast::expr, datum: Datum) -> DatumBlock {\n+        // This is not the most efficient thing possible; since closures\n+        // are two words it'd be better if this were compiled in\n+        // 'dest' mode, but I can't find a nice way to structure the\n+        // code and keep it DRY that accommodates that use case at the\n+        // moment.\n+\n+        let tcx = bcx.tcx();\n+        let closure_ty = expr_ty_adjusted(bcx, expr);\n+        debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n+        let scratch = scratch_datum(bcx, closure_ty, false);\n+        let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n+        assert datum.appropriate_mode() == ByValue;\n+        Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n+        let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n+        Store(bcx, base::null_env_ptr(bcx), llenv);\n+        DatumBlock {bcx: bcx, datum: scratch}\n+    }\n+\n     fn auto_slice_and_ref(bcx: block, datum: Datum) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, datum);\n         auto_ref(bcx, datum)\n@@ -412,6 +439,9 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n+        ast::expr_path(_) => {\n+            return trans_def_datum_unadjusted(bcx, expr, bcx.def(expr.id));\n+        }\n         ast::expr_vstore(contents, ast::expr_vstore_box) |\n         ast::expr_vstore(contents, ast::expr_vstore_mut_box) => {\n             return tvec::trans_uniq_or_managed_vstore(bcx, heap_managed,\n@@ -677,22 +707,13 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n     };\n \n     match def {\n-        ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n-            let fn_data = callee::trans_fn_ref(bcx, did, ref_expr.id);\n-            return fn_data_to_datum(bcx, did, fn_data, lldest);\n-        }\n-        ast::def_static_method(impl_did, Some(trait_did), _) => {\n-            let fn_data = meth::trans_static_method_callee(bcx, impl_did,\n-                                                           trait_did,\n-                                                           ref_expr.id);\n-            return fn_data_to_datum(bcx, impl_did, fn_data, lldest);\n-        }\n         ast::def_variant(tid, vid) => {\n             let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n                 let fn_data = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n-                return fn_data_to_datum(bcx, vid, fn_data, lldest);\n+                Store(bcx, fn_data.llfn, lldest);\n+                return bcx;\n             } else if !ty::enum_is_univariant(ccx.tcx, tid) {\n                 // Nullary variant.\n                 let lldiscrimptr = GEPi(bcx, lldest, [0u, 0u]);\n@@ -717,6 +738,66 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n     }\n }\n \n+fn trans_def_datum_unadjusted(bcx: block,\n+                              ref_expr: @ast::expr,\n+                              def: ast::def) -> DatumBlock\n+{\n+    let _icx = bcx.insn_ctxt(\"trans_def_datum_unadjusted\");\n+\n+    match def {\n+        ast::def_fn(did, _) | ast::def_static_method(did, None, _) => {\n+            let fn_data = callee::trans_fn_ref(bcx, did, ref_expr.id);\n+            return fn_data_to_datum(bcx, ref_expr, did, fn_data);\n+        }\n+        ast::def_static_method(impl_did, Some(trait_did), _) => {\n+            let fn_data = meth::trans_static_method_callee(bcx, impl_did,\n+                                                           trait_did,\n+                                                           ref_expr.id);\n+            return fn_data_to_datum(bcx, ref_expr, impl_did, fn_data);\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(ref_expr.span, fmt!(\n+                \"Non-DPS def %? referened by %s\",\n+                def, bcx.node_id_to_str(ref_expr.id)));\n+        }\n+    }\n+\n+    fn fn_data_to_datum(bcx: block,\n+                        ref_expr: @ast::expr,\n+                        def_id: ast::def_id,\n+                        fn_data: callee::FnData) -> DatumBlock {\n+        /*!\n+        *\n+        * Translates a reference to a top-level fn item into a rust\n+        * value.  This is just a fn pointer.\n+        */\n+\n+        let is_extern = {\n+            let fn_tpt = ty::lookup_item_type(bcx.tcx(), def_id);\n+            ty::ty_fn_purity(fn_tpt.ty) == ast::extern_fn\n+        };\n+        let (rust_ty, llval) = if is_extern {\n+            let rust_ty = ty::mk_ptr(\n+                bcx.tcx(),\n+                ty::mt {\n+                    ty: ty::mk_mach_uint(bcx.tcx(), ast::ty_u8),\n+                    mutbl: ast::m_imm\n+                }); // *u8\n+            (rust_ty, PointerCast(bcx, fn_data.llfn, T_ptr(T_i8())))\n+        } else {\n+            let fn_ty = expr_ty(bcx, ref_expr);\n+            (fn_ty, fn_data.llfn)\n+        };\n+        return DatumBlock {\n+            bcx: bcx,\n+            datum: Datum {val: llval,\n+                          ty: rust_ty,\n+                          mode: ByValue,\n+                          source: RevokeClean}\n+        };\n+    }\n+}\n+\n fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      *\n@@ -1004,36 +1085,6 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     }\n }\n \n-fn fn_data_to_datum(bcx: block,\n-                    def_id: ast::def_id,\n-                    fn_data: callee::FnData,\n-                    lldest: ValueRef) -> block {\n-    //!\n-    //\n-    // Translates a reference to a top-level fn item into a rust\n-    // value.  This is generally a Rust closure pair: (fn ptr, env)\n-    // where the environment is NULL.  However, extern functions for\n-    // interfacing with C are represted as just the fn ptr with type\n-    // *u8.\n-    //\n-    // Strictly speaking, references to extern fns ought to be\n-    // RvalueDatumExprs, but it's not worth the complexity to avoid the\n-    // extra stack slot that LLVM probably optimizes away anyhow.\n-\n-    let fn_tpt = ty::lookup_item_type(bcx.tcx(), def_id);\n-    if ty::ty_fn_purity(fn_tpt.ty) == ast::extern_fn {\n-        let val = PointerCast(bcx, fn_data.llfn, T_ptr(T_i8()));\n-        Store(bcx, val, lldest);\n-        return bcx;\n-    }\n-\n-    let llfn = GEPi(bcx, lldest, [0u, abi::fn_field_code]);\n-    Store(bcx, fn_data.llfn, llfn);\n-    let llenv = GEPi(bcx, lldest, [0u, abi::fn_field_box]);\n-    Store(bcx, base::null_env_ptr(bcx), llenv);\n-    return bcx;\n-}\n-\n // The optional node ID here is the node ID of the path identifying the enum\n // variant in use. If none, this cannot possibly an enum variant (so, if it\n // is and `node_id_opt` is none, this function fails)."}, {"sha": "7af33eb2b9d3396599cf41ba0b566217e5bb8523", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -130,8 +130,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n             T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())])\n         }\n \n-        // FIXME(#4804) Bare fn repr\n-        ty::ty_bare_fn(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())]),\n+        ty::ty_bare_fn(*) => T_ptr(T_i8()),\n         ty::ty_closure(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())]),\n         ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n \n@@ -169,7 +168,9 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         ty::ty_enum(def_id, _) => T_struct(enum_body_types(cx, def_id, t)),\n \n         ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n-            cx.tcx.sess.bug(~\"fictitious type in sizing_type_of()\")\n+            cx.tcx.sess.bug(\n+                fmt!(\"fictitious type %? in sizing_type_of()\",\n+                     ty::get(t).sty))\n         }\n     };\n \n@@ -266,9 +267,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         T_struct(~[T_struct(tys)])\n       }\n \n-      // FIXME(#4804) Bare fn repr\n-      // ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n-      ty::ty_bare_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+      ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n       ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),"}, {"sha": "deede95dc03a396d3b2d6c24aeaa8c8aaaa2c0a8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -172,7 +172,14 @@ impl cmp::Eq for region_variance {\n \n #[auto_encode]\n #[auto_decode]\n-pub struct AutoAdjustment {\n+pub enum AutoAdjustment {\n+    AutoAddEnv(ty::Region, ast::Sigil),\n+    AutoDerefRef(AutoDerefRef)\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub struct AutoDerefRef {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n }\n@@ -198,7 +205,7 @@ pub enum AutoRefKind {\n     AutoBorrowVecRef,\n \n     /// Convert from @fn()/~fn() to &fn()\n-    AutoBorrowFn,\n+    AutoBorrowFn\n }\n \n // Stores information about provided methods (a.k.a. default methods) in\n@@ -1477,7 +1484,6 @@ pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) |\n       ty_closure(_) |\n-      ty_bare_fn(_) | // FIXME(#4804) Bare fn repr\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n@@ -1587,7 +1593,7 @@ pub pure fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n-      ty_ptr(_) => true,\n+      ty_bare_fn(*) | ty_ptr(_) => true,\n       _ => false\n     }\n }\n@@ -2884,7 +2890,25 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n     return match cx.adjustments.find(&expr.id) {\n         None => unadjusted_ty,\n \n-        Some(adj) => {\n+        Some(@AutoAddEnv(r, s)) => {\n+            match ty::get(unadjusted_ty).sty {\n+                ty::ty_bare_fn(ref b) => {\n+                    ty::mk_closure(\n+                        cx,\n+                        ty::ClosureTy {purity: b.purity,\n+                                       sigil: s,\n+                                       onceness: ast::Many,\n+                                       region: r,\n+                                       sig: copy b.sig})\n+                }\n+                ref b => {\n+                    cx.sess.bug(\n+                        fmt!(\"add_env adjustment on non-bare-fn: %?\", b));\n+                }\n+            }\n+        }\n+\n+        Some(@AutoDerefRef(ref adj)) => {\n             let mut adjusted_ty = unadjusted_ty;\n \n             for uint::range(0, adj.autoderefs) |i| {\n@@ -3066,9 +3090,11 @@ pub fn expr_kind(tcx: ctxt,\n     match expr.node {\n         ast::expr_path(*) => {\n             match resolve_expr(tcx, expr) {\n-                ast::def_fn(*) | ast::def_static_method(*) |\n                 ast::def_variant(*) | ast::def_struct(*) => RvalueDpsExpr,\n \n+                // Fn pointers are just scalar values.\n+                ast::def_fn(*) | ast::def_static_method(*) => RvalueDatumExpr,\n+\n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to\n                 // considered rvalues."}, {"sha": "63d09d88f52a54096b8183e5f0715d20653b6342", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -799,26 +799,28 @@ pub impl LookupContext {\n                 let region = self.infcx().next_region_var(self.expr.span,\n                                                           self.expr.id);\n                 (ty::mk_rptr(tcx, region, self_mt),\n-                 ty::AutoAdjustment {\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoRef {kind: AutoPtr,\n                                                 region: region,\n-                                                mutbl: self_mt.mutbl})})\n+                                                mutbl: self_mt.mutbl})}))\n             }\n             ty::ty_evec(self_mt, vstore_slice(_))\n             if self_mt.mutbl == m_mutbl => {\n                 let region = self.infcx().next_region_var(self.expr.span,\n                                                           self.expr.id);\n                 (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n-                 ty::AutoAdjustment {\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n                     autoderefs: autoderefs,\n                     autoref: Some(ty::AutoRef {kind: AutoBorrowVec,\n                                                region: region,\n-                                               mutbl: self_mt.mutbl})})\n+                                               mutbl: self_mt.mutbl})}))\n             }\n             _ => {\n-                (self_ty, ty::AutoAdjustment {autoderefs: autoderefs,\n-                                              autoref: None})\n+                (self_ty,\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                     autoderefs: autoderefs,\n+                     autoref: None}))\n             }\n         };\n     }\n@@ -947,14 +949,14 @@ pub impl LookupContext {\n                 Some(mme) => {\n                     self.fcx.write_adjustment(\n                         self.self_expr.id,\n-                        @ty::AutoAdjustment {\n+                        @ty::AutoDerefRef(ty::AutoDerefRef {\n                             autoderefs: autoderefs,\n                             autoref: Some(ty::AutoRef {\n                                 kind: kind,\n                                 region: region,\n                                 mutbl: *mutbl,\n                             }),\n-                        });\n+                        }));\n                     return Some(mme);\n                 }\n             }"}, {"sha": "ec5156ae1f7bf7dd22ab8088be82a5200bffd942", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -736,7 +736,9 @@ pub impl FnCtxt {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n-            @ty::AutoAdjustment { autoderefs: derefs, autoref: None }\n+            @ty::AutoDerefRef(ty::AutoDerefRef {\n+                autoderefs: derefs,\n+                autoref: None })\n         );\n     }\n "}, {"sha": "7187f15e7495ad7055b7dd13df079ba83c3150a6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -184,8 +184,13 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n-        for adjustment.autoref.each |autoref| {\n-            guarantor::for_autoref(rcx, expr, *adjustment, autoref);\n+        match *adjustment {\n+            @ty::AutoDerefRef(\n+                ty::AutoDerefRef {\n+                    autoderefs: autoderefs, autoref: Some(ref autoref)}) => {\n+                guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -329,9 +334,11 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n \n     let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n     let region = match adjustment {\n-        Some(@ty::AutoAdjustment { autoref: Some(ref auto_ref), _ }) => {\n+        Some(@ty::AutoDerefRef(\n+            ty::AutoDerefRef {\n+                autoref: Some(ref auto_ref), _})) => {\n             auto_ref.region\n-        },\n+        }\n         _ => { return; }\n     };\n \n@@ -563,7 +570,7 @@ pub mod guarantor {\n \n     pub fn for_autoref(rcx: @mut Rcx,\n                        expr: @ast::expr,\n-                       adjustment: &ty::AutoAdjustment,\n+                       autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n         /*!\n          *\n@@ -578,7 +585,7 @@ pub mod guarantor {\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         expr_ct = apply_autoderefs(\n-            rcx, expr, adjustment.autoderefs, expr_ct);\n+            rcx, expr, autoderefs, expr_ct);\n         for expr_ct.cat.guarantor.each |g| {\n             infallibly_mk_subr(rcx, true, expr.span, autoref.region, *g);\n         }\n@@ -723,19 +730,32 @@ pub mod guarantor {\n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n \n-        for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n-            debug!(\"adjustment=%?\", adjustment);\n+        match rcx.fcx.inh.adjustments.find(&expr.id) {\n+            Some(@ty::AutoAddEnv(*)) => {\n+                // This is basically an rvalue, not a pointer, no regions\n+                // involved.\n+                expr_ct.cat = ExprCategorization {\n+                    guarantor: None,\n+                    pointer: NotPointer\n+                };\n+            }\n+\n+            Some(@ty::AutoDerefRef(ref adjustment)) => {\n+                debug!(\"adjustment=%?\", adjustment);\n \n-            expr_ct = apply_autoderefs(\n-                rcx, expr, adjustment.autoderefs, expr_ct);\n+                expr_ct = apply_autoderefs(\n+                    rcx, expr, adjustment.autoderefs, expr_ct);\n \n-            for adjustment.autoref.each |autoref| {\n-                // If there is an autoref, then the result of this\n-                // expression will be some sort of borrowed pointer.\n-                expr_ct.cat.guarantor = None;\n-                expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n-                debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                for adjustment.autoref.each |autoref| {\n+                    // If there is an autoref, then the result of this\n+                    // expression will be some sort of borrowed pointer.\n+                    expr_ct.cat.guarantor = None;\n+                    expr_ct.cat.pointer = BorrowedPointer(autoref.region);\n+                    debug!(\"autoref, cat=%?\", expr_ct.cat);\n+                }\n             }\n+\n+            None => {}\n         }\n \n         debug!(\"result=%?\", expr_ct.cat);"}, {"sha": "a6aed9c7b0c916e3157674cbc1e6e49bd9d7f3bc", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -79,7 +79,24 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n     // Resolve any borrowings for the node with id `id`\n     match fcx.inh.adjustments.find(&id) {\n         None => (),\n-        Some(adj) => {\n+\n+        Some(@ty::AutoAddEnv(r, s)) => {\n+            match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n+                Err(e) => {\n+                    // This should not, I think, happen:\n+                    fcx.ccx.tcx.sess.span_err(\n+                        sp, fmt!(\"cannot resolve bound for closure: %s\",\n+                                 infer::fixup_err_to_str(e)));\n+                }\n+                Ok(r1) => {\n+                    let resolved_adj = @ty::AutoAddEnv(r1, s);\n+                    debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n+                    fcx.tcx().adjustments.insert(id, resolved_adj);\n+                }\n+            }\n+        }\n+\n+        Some(@ty::AutoDerefRef(adj)) => {\n             let resolved_autoref = match adj.autoref {\n                 Some(ref autoref) => {\n                     match resolve_region(fcx.infcx(), autoref.region,\n@@ -99,9 +116,10 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n                 None => None\n             };\n \n-            let resolved_adj = @ty::AutoAdjustment {\n+            let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {\n+                autoderefs: adj.autoderefs,\n                 autoref: resolved_autoref,\n-                ..*adj};\n+            });\n             debug!(\"Adjustments for node %d: %?\", id, resolved_adj);\n             fcx.tcx().adjustments.insert(id, resolved_adj);\n         }"}, {"sha": "17db5d475fdf977d47e41d5c83cf20fffffdb971", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febdb49e9269724058aacf645610912bf26ecdb4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=febdb49e9269724058aacf645610912bf26ecdb4", "patch": "@@ -67,7 +67,7 @@ we may want to adjust precisely when coercions occur.\n use core::prelude::*;\n \n use middle::ty::{TyVar, AutoPtr, AutoBorrowVec, AutoBorrowFn};\n-use middle::ty::{AutoAdjustment, AutoRef};\n+use middle::ty::{AutoAdjustment, AutoDerefRef, AutoRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq, vstore_fixed};\n use middle::ty::{mt};\n use middle::ty;\n@@ -206,14 +206,14 @@ impl Coerce {\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mt_b.mutbl});\n         if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(@AutoAdjustment {\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoRef {\n                 kind: AutoPtr,\n                 region: r_borrow,\n                 mutbl: mt_b.mutbl\n             })\n-        }))\n+        })))\n     }\n \n     fn coerce_borrowed_string(&self,\n@@ -236,14 +236,14 @@ impl Coerce {\n         let r_a = self.infcx.next_region_var_nb(self.span);\n         let a_borrowed = ty::mk_estr(self.infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n-        Ok(Some(@AutoAdjustment {\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoRef {\n                 kind: AutoBorrowVec,\n                 region: r_a,\n                 mutbl: m_imm\n             })\n-        }))\n+        })))\n     }\n \n     fn coerce_borrowed_vector(&self,\n@@ -269,14 +269,14 @@ impl Coerce {\n                                      mt {ty: ty_inner, mutbl: mt_b.mutbl},\n                                      vstore_slice(r_borrow));\n         if_ok!(sub.tys(a_borrowed, b));\n-        Ok(Some(@AutoAdjustment {\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoRef {\n                 kind: AutoBorrowVec,\n                 region: r_borrow,\n                 mutbl: mt_b.mutbl\n             })\n-        }))\n+        })))\n     }\n \n     fn coerce_borrowed_fn(&self,\n@@ -309,14 +309,14 @@ impl Coerce {\n             });\n \n         if_ok!(self.subtype(a_borrowed, b));\n-        Ok(Some(@AutoAdjustment {\n+        Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n             autoref: Some(AutoRef {\n                 kind: AutoBorrowFn,\n                 region: r_borrow,\n                 mutbl: m_imm\n             })\n-        }))\n+        })))\n     }\n \n     fn coerce_from_bare_fn(&self,\n@@ -347,10 +347,12 @@ impl Coerce {\n \n         // for now, bare fn and closures have the same\n         // representation\n+        let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n         let a_closure = ty::mk_closure(\n             self.infcx.tcx,\n             ty::ClosureTy {sig: copy fn_ty_a.sig, ..fn_ty_b});\n-        self.subtype(a_closure, b)\n+        if_ok!(self.subtype(a_closure, b));\n+        Ok(Some(adj))\n     }\n \n     fn coerce_unsafe_ptr(&self,"}]}