{"sha": "bf06deafe63364f4322340eecfe0c3171a3efbcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMDZkZWFmZTYzMzY0ZjQzMjIzNDBlZWNmZTBjMzE3MWEzZWZiY2I=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T21:49:22Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-10T22:12:13Z"}, "message": "Disallow implicitly binding methods in typechecker. Closes #2189.", "tree": {"sha": "2936fb187031c2cb7c16ffbe72399e2354774e7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2936fb187031c2cb7c16ffbe72399e2354774e7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf06deafe63364f4322340eecfe0c3171a3efbcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf06deafe63364f4322340eecfe0c3171a3efbcb", "html_url": "https://github.com/rust-lang/rust/commit/bf06deafe63364f4322340eecfe0c3171a3efbcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf06deafe63364f4322340eecfe0c3171a3efbcb/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4362a59b940073569c05b7e2ae2c6f686ed0bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4362a59b940073569c05b7e2ae2c6f686ed0bb7", "html_url": "https://github.com/rust-lang/rust/commit/e4362a59b940073569c05b7e2ae2c6f686ed0bb7"}], "stats": {"total": 188, "additions": 108, "deletions": 80}, "files": [{"sha": "b4a8c02f3b7e4b8f6079d4f46006bca4bb34f4ea", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 104, "deletions": 79, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=bf06deafe63364f4322340eecfe0c3171a3efbcb", "patch": "@@ -814,7 +814,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n                   f: @ast::expr, args: ~[@ast::expr]) -> bool {\n \n-        let mut bot = check_expr(fcx, f, none);\n+        // Index expressions need to be handled seperately, to inform\n+        // them that they appear in call position.\n+        let mut bot = alt f.node {\n+          ast::expr_field(base, field, tys) {\n+            check_field(fcx, f, true, base, field, tys)\n+          }\n+          _ { check_expr(fcx, f, none) }\n+        };\n         let fn_ty = fcx.expr_ty(f);\n \n         // Call the generic checker.\n@@ -1051,6 +1058,101 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                  is_loop_body, some(fcx));\n     }\n \n+    // Check field access expressions\n+    fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n+                   base: @ast::expr, field: ast::ident, tys: ~[@ast::ty])\n+        -> bool {\n+        let tcx = fcx.ccx.tcx;\n+        let bot = check_expr(fcx, base, none);\n+        let expr_t = structurally_resolved_type(fcx, expr.span,\n+                                                fcx.expr_ty(base));\n+        let base_t = do_autoderef(fcx, expr.span, expr_t);\n+        let mut handled = false;\n+        let n_tys = vec::len(tys);\n+        alt structure_of(fcx, expr.span, base_t) {\n+          ty::ty_rec(fields) {\n+            alt ty::field_idx(field, fields) {\n+              some(ix) {\n+                if n_tys > 0u {\n+                    tcx.sess.span_err(expr.span,\n+                                      \"can't provide type parameters \\\n+                                       to a field access\");\n+                }\n+                fcx.write_ty(expr.id, fields[ix].mt.ty);\n+                handled = true;\n+              }\n+              _ {}\n+            }\n+          }\n+          ty::ty_class(base_id, substs) {\n+              // This is just for fields -- the same code handles\n+              // methods in both classes and traits\n+\n+              // (1) verify that the class id actually has a field called\n+              // field\n+              #debug(\"class named %s\", ty_to_str(tcx, base_t));\n+              /*\n+                check whether this is a self-reference or not, which\n+                determines whether we look at all fields or only public\n+                ones\n+               */\n+              let cls_items = if self_ref(fcx, base.id) {\n+                  // base expr is \"self\" -- consider all fields\n+                  ty::lookup_class_fields(tcx, base_id)\n+              }\n+              else {\n+                  lookup_public_fields(tcx, base_id)\n+              };\n+              alt lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n+                 some(field_ty) {\n+                    // (2) look up what field's type is, and return it\n+                     fcx.write_ty(expr.id, field_ty);\n+                     handled = true;\n+                 }\n+                 none {}\n+              }\n+          }\n+          _ {}\n+        }\n+        if !handled {\n+            let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n+            let is_self_ref = self_ref(fcx, base.id);\n+\n+            // this will be the call or block that immediately\n+            // encloses the method call\n+            let borrow_scope = fcx.tcx().region_map.get(expr.id);\n+\n+            let lkup = method::lookup(fcx, expr, base, borrow_scope,\n+                                      expr.id, field, expr_t, tps,\n+                                      is_self_ref);\n+            alt lkup.method() {\n+              some(entry) {\n+                fcx.ccx.method_map.insert(expr.id, entry);\n+\n+                // If we have resolved to a method but this is not in\n+                // a callee position, error\n+                if !is_callee {\n+                    tcx.sess.span_err(\n+                        expr.span,\n+                        \"attempted to take value of method \\\n+                         (try writing an anonymous function)\");\n+                }\n+              }\n+              none {\n+                let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n+                let msg = #fmt[\"attempted access of field `%s` on type `%s`, \\\n+                                but no public field or method with that name \\\n+                                was found\",\n+                               *field, fcx.infcx.ty_to_str(t_err)];\n+                tcx.sess.span_err(expr.span, msg);\n+                // NB: Adding a bogus type to allow typechecking to continue\n+                fcx.write_ty(expr.id, fcx.infcx.next_ty_var());\n+              }\n+            }\n+        }\n+        ret bot;\n+    }\n+\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n@@ -1489,84 +1591,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n       }\n       ast::expr_field(base, field, tys) {\n-        bot |= check_expr(fcx, base, none);\n-        let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                fcx.expr_ty(base));\n-        let base_t = do_autoderef(fcx, expr.span, expr_t);\n-        let mut handled = false;\n-        let n_tys = vec::len(tys);\n-        alt structure_of(fcx, expr.span, base_t) {\n-          ty::ty_rec(fields) {\n-            alt ty::field_idx(field, fields) {\n-              some(ix) {\n-                if n_tys > 0u {\n-                    tcx.sess.span_err(expr.span,\n-                                      \"can't provide type parameters \\\n-                                       to a field access\");\n-                }\n-                fcx.write_ty(id, fields[ix].mt.ty);\n-                handled = true;\n-              }\n-              _ {}\n-            }\n-          }\n-          ty::ty_class(base_id, substs) {\n-              // This is just for fields -- the same code handles\n-              // methods in both classes and traits\n-\n-              // (1) verify that the class id actually has a field called\n-              // field\n-              #debug(\"class named %s\", ty_to_str(tcx, base_t));\n-              /*\n-                check whether this is a self-reference or not, which\n-                determines whether we look at all fields or only public\n-                ones\n-               */\n-              let cls_items = if self_ref(fcx, base.id) {\n-                  // base expr is \"self\" -- consider all fields\n-                  ty::lookup_class_fields(tcx, base_id)\n-              }\n-              else {\n-                  lookup_public_fields(tcx, base_id)\n-              };\n-              alt lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n-                 some(field_ty) {\n-                    // (2) look up what field's type is, and return it\n-                     fcx.write_ty(id, field_ty);\n-                     handled = true;\n-                 }\n-                 none {}\n-              }\n-          }\n-          _ {}\n-        }\n-        if !handled {\n-            let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n-            let is_self_ref = self_ref(fcx, base.id);\n-\n-            // this will be the call or block that immediately\n-            // encloses the method call\n-            let borrow_scope = fcx.tcx().region_map.get(expr.id);\n-\n-            let lkup = method::lookup(fcx, expr, base, borrow_scope,\n-                                      expr.id, field, expr_t, tps,\n-                                      is_self_ref);\n-            alt lkup.method() {\n-              some(entry) {\n-                fcx.ccx.method_map.insert(id, entry);\n-              }\n-              none {\n-                let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = #fmt[\"attempted access of field `%s` on type `%s`, \\\n-                                but no public field or method with that name \\\n-                                was found\",\n-                               *field, fcx.infcx.ty_to_str(t_err)];\n-                tcx.sess.span_err(expr.span, msg);\n-                // NB: Adding a bogus type to allow typechecking to continue\n-                fcx.write_ty(id, fcx.infcx.next_ty_var());\n-              }\n-            }\n-        }\n+        bot = check_field(fcx, expr, false, base, field, tys);\n       }\n       ast::expr_index(base, idx) {\n         bot |= check_expr(fcx, base, none);"}, {"sha": "57bfd8ea10332c31310eb9026b7d18c6a0badfc6", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=bf06deafe63364f4322340eecfe0c3171a3efbcb", "patch": "@@ -11,5 +11,5 @@ class cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.speak = fn@() { #debug[\"meow\"]; }; //~ ERROR assigning to method\n+  nyan.speak = fn@() { #debug[\"meow\"]; }; //~ ERROR attempted to take value of method\n }"}, {"sha": "d0596fa08b3a5719f86f653249cd3dd827b9ecb7", "filename": "src/test/compile-fail/implicit-method-bind.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf06deafe63364f4322340eecfe0c3171a3efbcb/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs?ref=bf06deafe63364f4322340eecfe0c3171a3efbcb", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _f = 10.times; //~ ERROR attempted to take value of method\n+}"}]}