{"sha": "da6f1369972ad972c60270e073361f727b68d8a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNmYxMzY5OTcyYWQ5NzJjNjAyNzBlMDczMzYxZjcyN2I2OGQ4YTY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-14T09:49:22Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-14T09:49:22Z"}, "message": "I say we take off and nuke the lifetimes from orbit", "tree": {"sha": "21197feb07cd8f6a854431114e82561635be8c10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21197feb07cd8f6a854431114e82561635be8c10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da6f1369972ad972c60270e073361f727b68d8a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da6f1369972ad972c60270e073361f727b68d8a6", "html_url": "https://github.com/rust-lang/rust/commit/da6f1369972ad972c60270e073361f727b68d8a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da6f1369972ad972c60270e073361f727b68d8a6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64d196a9dc14b5cacf7ef12bf8dd691355d0ffc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/64d196a9dc14b5cacf7ef12bf8dd691355d0ffc9", "html_url": "https://github.com/rust-lang/rust/commit/64d196a9dc14b5cacf7ef12bf8dd691355d0ffc9"}], "stats": {"total": 159, "additions": 132, "deletions": 27}, "files": [{"sha": "370d59e5a3a39cafa010aeed9c30eea26495329b", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da6f1369972ad972c60270e073361f727b68d8a6/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6f1369972ad972c60270e073361f727b68d8a6/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=da6f1369972ad972c60270e073361f727b68d8a6", "patch": "@@ -1,14 +1,14 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{PolyFnSig, Ty, layout};\n+use rustc::ty::{FnSig, Ty, layout};\n use memory::{Pointer, Function};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n-    FunctionPointerTyMismatch(PolyFnSig<'tcx>, PolyFnSig<'tcx>),\n+    FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n@@ -151,7 +151,7 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             },\n             EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             EvalError::FunctionPointerTyMismatch(sig, got) =>\n-                write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig.skip_binder(), got.skip_binder()),\n+                write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n             EvalError::Math(span, ref err) =>"}, {"sha": "b0e7b76ae106b2b7a18459167dad9b1b2f0142d4", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da6f1369972ad972c60270e073361f727b68d8a6/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6f1369972ad972c60270e073361f727b68d8a6/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=da6f1369972ad972c60270e073361f727b68d8a6", "patch": "@@ -65,31 +65,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let func_ty = self.operand_ty(func);\n                 let fn_def = match func_ty.sty {\n                     ty::TyFnPtr(bare_sig) => {\n+                        let bare_sig = self.tcx.erase_late_bound_regions(&bare_sig);\n+                        let bare_sig = self.tcx.erase_regions(&bare_sig);\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n                         let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         match fn_def {\n                             Function::Concrete(fn_def) => {\n                                 // transmuting function pointers in miri is fine as long as the number of\n                                 // arguments and the abi don't change.\n-                                // FIXME: also check the size of the arguments' type and the return type\n-                                // Didn't get it to work, since that triggers an assertion in rustc which\n-                                // checks whether the type has escaping regions\n-                                if fn_def.sig.abi() != bare_sig.abi() ||\n-                                    fn_def.sig.variadic() != bare_sig.variadic() ||\n-                                    fn_def.sig.inputs().skip_binder().len() != bare_sig.inputs().skip_binder().len() {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n+                                let sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                                let sig = self.tcx.erase_regions(&sig);\n+                                if sig.abi != bare_sig.abi ||\n+                                    sig.variadic != bare_sig.variadic ||\n+                                    sig.inputs_and_output != bare_sig.inputs_and_output {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n                                 }\n                             },\n                             Function::NonCaptureClosureAsFnPtr(fn_def) => {\n-                                assert_eq!(fn_def.sig.abi(), Abi::RustCall);\n-                                if fn_def.sig.variadic() != bare_sig.variadic() ||\n-                                    fn_def.sig.inputs().skip_binder().len() != 1 {\n-                                    return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n+                                let sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                                let sig = self.tcx.erase_regions(&sig);\n+                                assert_eq!(sig.abi, Abi::RustCall);\n+                                if sig.variadic != bare_sig.variadic ||\n+                                    sig.inputs().len() != 1 {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n                                 }\n-                                if let ty::TyTuple(fields, _) = fn_def.sig.inputs().skip_binder()[0].sty {\n-                                    if fields.len() != bare_sig.inputs().skip_binder().len() {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(fn_def.sig, bare_sig));\n+                                if let ty::TyTuple(fields, _) = sig.inputs()[0].sty {\n+                                    if **fields != *bare_sig.inputs() {\n+                                        return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n                                     }\n+                                } else {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n                                 }\n                             },\n                             other => return Err(EvalError::ExpectedConcreteFunction(other)),\n@@ -165,7 +170,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match fn_def {\n             // Intrinsics can only be addressed directly\n             Function::Concrete(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustIntrinsic => {\n-                let ty = *sig.output().skip_binder();\n+                let sig = self.tcx.erase_late_bound_regions(&sig);\n+                let sig = self.tcx.erase_regions(&sig);\n+                let ty = sig.output();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n                     Some(dest) if is_inhabited(self.tcx, ty) => dest,\n@@ -177,7 +184,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             // C functions can only be addressed directly\n             Function::Concrete(FunctionDefinition { def_id, sig, ..}) if sig.abi() == Abi::C => {\n-                let ty = *sig.output().skip_binder();\n+                let sig = self.tcx.erase_late_bound_regions(&sig);\n+                let sig = self.tcx.erase_regions(&sig);\n+                let ty = sig.output();\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, ty)?;\n                 self.dump_local(ret);\n@@ -266,6 +275,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 )\n             },\n             Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustCall => {\n+                let sig = self.tcx.erase_late_bound_regions(&sig);\n+                let sig = self.tcx.erase_regions(&sig);\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -274,7 +285,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 args.insert(0, (\n                     Value::ByVal(PrimVal::Undef),\n-                    sig.inputs().skip_binder()[0],\n+                    sig.inputs()[0],\n                 ));\n                 self.eval_fn_call_inner(\n                     def_id,\n@@ -285,7 +296,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     span,\n                 )\n             }\n-            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:?}\", other))),\n+            Function::Concrete(fn_def) => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", fn_def.sig.abi()))),\n+            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:#?}\", other))),\n         }\n     }\n "}, {"sha": "19a4f6652d9185cafb63778af9aab60f7a82f804", "filename": "src/traits.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da6f1369972ad972c60270e073361f727b68d8a6/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6f1369972ad972c60270e073361f727b68d8a6/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=da6f1369972ad972c60270e073361f727b68d8a6", "patch": "@@ -123,17 +123,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n                     Function::Concrete(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        let sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                        let sig = self.tcx.erase_regions(&sig);\n+                        trace!(\"sig: {:#?}\", sig);\n                         args[0] = (\n                             Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            fn_def.sig.inputs().skip_binder()[0],\n+                            sig.inputs()[0],\n                         );\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     },\n                     Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                        let sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                        let sig = self.tcx.erase_regions(&sig);\n                         args.insert(0, (\n                             Value::ByVal(PrimVal::Undef),\n-                            fn_def.sig.inputs().skip_binder()[0],\n+                            sig.inputs()[0],\n                         ));\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n@@ -142,20 +146,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n                     Function::FnPtrAsTraitObject(sig) => {\n+                        let sig = self.tcx.erase_late_bound_regions(&sig);\n+                        let sig = self.tcx.erase_regions(&sig);\n                         trace!(\"sig: {:#?}\", sig);\n                         // the first argument was the fat ptr\n                         args.remove(0);\n                         self.unpack_fn_args(args)?;\n                         let fn_ptr = self.memory.read_ptr(self_ptr)?;\n                         let fn_def = match self.memory.get_fn(fn_ptr.alloc_id)? {\n                             Function::Concrete(fn_def) => {\n-                                assert_eq!(sig, fn_def.sig);\n+                                let fn_def_sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                                let fn_def_sig = self.tcx.erase_regions(&fn_def_sig);\n+                                assert_eq!(sig, fn_def_sig);\n                                 fn_def\n                             },\n                             Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                                let fn_def_sig = self.tcx.erase_late_bound_regions(&fn_def.sig);\n+                                let fn_def_sig = self.tcx.erase_regions(&fn_def_sig);\n                                 args.insert(0, (\n                                     Value::ByVal(PrimVal::Undef),\n-                                    fn_def.sig.inputs().skip_binder()[0],\n+                                    fn_def_sig.inputs()[0],\n                                 ));\n                                 fn_def\n                             },\n@@ -280,8 +290,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n+                let fn_ty = self.tcx.erase_late_bound_regions(&fn_ty);\n+                let fn_ty = self.tcx.erase_regions(&fn_ty);\n                 // The real type is taken from the self argument in `fn drop(&mut self)`\n-                let real_ty = match fn_ty.inputs().skip_binder()[0].sty {\n+                let real_ty = match fn_ty.inputs()[0].sty {\n                     ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n                     _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n                 };"}, {"sha": "17453933c8abcdc35b87ca4a20a409d8ec817b8d", "filename": "tests/run-pass/rfc1623.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/da6f1369972ad972c60270e073361f727b68d8a6/tests%2Frun-pass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6f1369972ad972c60270e073361f727b68d8a6/tests%2Frun-pass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frfc1623.rs?ref=da6f1369972ad972c60270e073361f727b68d8a6", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR: &str = \"&'static str\";\n+const CONST_STR: &str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR: &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR: &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] {\n+    arg\n+}\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_fN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_fN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(a: &u8, b: &u8, c: &u8) {}\n+\n+static STATIC_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool],\n+}\n+\n+static STATIC_FOO: Foo = Foo { bools: &[true, false] };\n+const CONST_FOO: Foo = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR: Bar = Bar { bools: &[true, false] };\n+const CONST_BAR: Bar = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> {\n+    e.first().map(|x| *x)\n+}\n+\n+static STATIC_BAZ: &Baz = &(baz as Baz);\n+const CONST_BAZ: &Baz = &(baz as Baz);\n+\n+static BYTES: &[u8] = &[1, 2, 3];\n+\n+fn main() {\n+    // make sure that the lifetime is actually elided (and not defaulted)\n+    let x = &[1u8, 2, 3];\n+    STATIC_SIMPLE_FN(x);\n+    CONST_SIMPLE_FN(x);\n+\n+    STATIC_BAZ(BYTES); // neees static lifetime\n+    CONST_BAZ(BYTES);\n+\n+    // make sure this works with different lifetimes\n+    let a = &1;\n+    {\n+        let b = &2;\n+        let c = &3;\n+        CONST_MULTI_FN(a, b, c);\n+    }\n+}"}]}