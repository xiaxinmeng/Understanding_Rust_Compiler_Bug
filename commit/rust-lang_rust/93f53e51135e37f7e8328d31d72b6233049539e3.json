{"sha": "93f53e51135e37f7e8328d31d72b6233049539e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZjUzZTUxMTM1ZTM3ZjdlODMyOGQzMWQ3MmI2MjMzMDQ5NTM5ZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T20:41:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-13T07:09:03Z"}, "message": "size_and_align_of can return no result for extern types", "tree": {"sha": "e7c5da516a9c7c14d7ef6e151d271e296c7340ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7c5da516a9c7c14d7ef6e151d271e296c7340ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93f53e51135e37f7e8328d31d72b6233049539e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93f53e51135e37f7e8328d31d72b6233049539e3", "html_url": "https://github.com/rust-lang/rust/commit/93f53e51135e37f7e8328d31d72b6233049539e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93f53e51135e37f7e8328d31d72b6233049539e3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f79a22c3d5a6ab20e896df6a0473755db37b96f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f79a22c3d5a6ab20e896df6a0473755db37b96f1", "html_url": "https://github.com/rust-lang/rust/commit/f79a22c3d5a6ab20e896df6a0473755db37b96f1"}], "stats": {"total": 49, "additions": 26, "deletions": 23}, "files": [{"sha": "bc613358152be2e46a5e4ecf416a79af4f0bbe44", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=93f53e51135e37f7e8328d31d72b6233049539e3", "patch": "@@ -332,22 +332,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n-    /// Only the `meta` part of the place matters.\n+    /// Only the \"meta\" (metadata) part of the place matters.\n+    /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of(\n         &self,\n         metadata: Option<Scalar<M::PointerTag>>,\n         layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n-        let metadata = match metadata {\n-            None => {\n-                assert!(!layout.is_unsized());\n-                return Ok(layout.size_and_align())\n-            }\n-            Some(metadata) => {\n-                assert!(layout.is_unsized());\n-                metadata\n-            }\n-        };\n+    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n+        if !layout.is_unsized() {\n+            return Ok(Some(layout.size_and_align()));\n+        }\n         match layout.ty.sty {\n             ty::Adt(..) | ty::Tuple(..) => {\n                 // First get the size of all statically known fields.\n@@ -367,9 +361,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 );\n \n                 // Recurse to get the size of the dynamically sized field (must be\n-                // the last field).\n+                // the last field).  Can't have foreign types here, how would we\n+                // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1)?;\n-                let (unsized_size, unsized_align) = self.size_and_align_of(Some(metadata), field)?;\n+                let (unsized_size, unsized_align) = self.size_and_align_of(metadata, field)?\n+                    .expect(\"Fields cannot be extern types\");\n \n                 // FIXME (#26403, #27023): We should be adding padding\n                 // to `sized_size` (to accommodate the `unsized_align`\n@@ -396,18 +392,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 //\n                 //   `(size + (align-1)) & -align`\n \n-                Ok((size.abi_align(align), align))\n+                Ok(Some((size.abi_align(align), align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.to_ptr()?;\n+                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\").to_ptr()?;\n                 // the second entry in the vtable is the dynamic size of the object.\n-                self.read_size_and_align_from_vtable(vtable)\n+                Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }\n \n             ty::Slice(_) | ty::Str => {\n-                let len = metadata.to_usize(self)?;\n+                let len = metadata.expect(\"slice fat ptr must have vtable\").to_usize(self)?;\n                 let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                Ok((elem_size * len, align))\n+                Ok(Some((elem_size * len, align)))\n+            }\n+\n+            ty::Foreign(_) => {\n+                Ok(None)\n             }\n \n             _ => bug!(\"size_and_align_of::<{:?}> not supported\", layout.ty),\n@@ -417,7 +417,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     pub fn size_and_align_of_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, (Size, Align)> {\n+    ) -> EvalResult<'tcx, Option<(Size, Align)>> {\n         self.size_and_align_of(mplace.meta, mplace.layout)\n     }\n "}, {"sha": "923f0dc4c291a8d305e3d215330d8892c45333cd", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=93f53e51135e37f7e8328d31d72b6233049539e3", "patch": "@@ -319,9 +319,9 @@ where\n         // Offset may need adjustment for unsized fields\n         let (meta, offset) = if field_layout.is_unsized() {\n             // re-use parent metadata to determine dynamic field layout\n-            let (_, align) = self.size_and_align_of(base.meta, field_layout)?;\n+            let (_, align) = self.size_and_align_of(base.meta, field_layout)?\n+                .expect(\"Fields cannot be extern types\");\n             (base.meta, offset.abi_align(align))\n-\n         } else {\n             // base.meta could be present; we might be accessing a sized field of an unsized\n             // struct."}, {"sha": "0c1dc092ce1479a830db749c5de3f38c8398e5bc", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f53e51135e37f7e8328d31d72b6233049539e3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=93f53e51135e37f7e8328d31d72b6233049539e3", "patch": "@@ -208,7 +208,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // for safe ptrs, also check the ptr values itself\n                 if !ty.is_unsafe_ptr() {\n                     // Make sure this is non-NULL and aligned\n-                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?;\n+                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?\n+                        // for the purpose of validity, consider foreign types to have\n+                        // alignment 1 and size 0.\n+                        .unwrap_or_else(|| (Size::ZERO, Align::from_bytes(1, 1).unwrap()));\n                     match self.memory.check_align(place.ptr, align) {\n                         Ok(_) => {},\n                         Err(err) => match err.kind {"}]}