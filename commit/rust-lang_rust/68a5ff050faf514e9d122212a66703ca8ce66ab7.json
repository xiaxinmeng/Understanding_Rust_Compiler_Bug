{"sha": "68a5ff050faf514e9d122212a66703ca8ce66ab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YTVmZjA1MGZhZjUxNGU5ZDEyMjIxMmE2NjcwM2NhOGNlNjZhYjc=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-11T13:31:09Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-11T13:31:09Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "0c389d2680aae82c1805a52f8315312724134341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c389d2680aae82c1805a52f8315312724134341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68a5ff050faf514e9d122212a66703ca8ce66ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68a5ff050faf514e9d122212a66703ca8ce66ab7", "html_url": "https://github.com/rust-lang/rust/commit/68a5ff050faf514e9d122212a66703ca8ce66ab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68a5ff050faf514e9d122212a66703ca8ce66ab7/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd075ff0beb97039cd1d1c6c021abf89339731b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd075ff0beb97039cd1d1c6c021abf89339731b", "html_url": "https://github.com/rust-lang/rust/commit/7cd075ff0beb97039cd1d1c6c021abf89339731b"}, {"sha": "a599147b4232c0d4f6b071a3a96e86f903f4cf52", "url": "https://api.github.com/repos/rust-lang/rust/commits/a599147b4232c0d4f6b071a3a96e86f903f4cf52", "html_url": "https://github.com/rust-lang/rust/commit/a599147b4232c0d4f6b071a3a96e86f903f4cf52"}], "stats": {"total": 1511, "additions": 1072, "deletions": 439}, "files": [{"sha": "af71a9ccea2f16306ab5600820a63328985fe85c", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -14,7 +14,6 @@ matrix:\n           script:\n               - rustup component add rustfmt\n               - rustup component add rust-src\n-              - sed -i \"s/debug = 1/debug = false/g\" Cargo.toml\n               - cargo test --no-run  # let's measure compile time separately\n               - cargo test\n           env:"}, {"sha": "5c57020f72e6116fea211b9f96a49f090db482a6", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -2,7 +2,9 @@\n members = [ \"crates/*\", \"xtask/\" ]\n \n [profile.dev]\n-debug = 1 # only line info\n+# disabling debug info speeds up builds a bunch,\n+# and we don't rely on it for debugging that much.\n+debug = 0\n \n [profile.release]\n incremental = true"}, {"sha": "09c4e97fa98b62767b2c7b190b62d857d28b607f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -22,7 +22,7 @@ use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n use crate::{\n     adt::VariantDef,\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    expr::{validation::ExprValidator, Body, BodySourceMap},\n+    expr::{validation::ExprValidator, BindingAnnotation, Body, BodySourceMap, Pat, PatId},\n     generics::HasGenericParams,\n     ids::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n@@ -32,7 +32,7 @@ use crate::{\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{InferenceResult, Namespace, TraitRef},\n-    Either, HasSource, ImportId, Name, ScopeDef, Ty,\n+    Either, HasSource, ImportId, Name, ScopeDef, Source, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -1070,3 +1070,54 @@ impl AssocItem {\n         .expect(\"AssocItem without container\")\n     }\n }\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Local {\n+    pub(crate) parent: DefWithBody,\n+    pub(crate) pat_id: PatId,\n+}\n+\n+impl Local {\n+    pub fn name(self, db: &impl HirDatabase) -> Option<Name> {\n+        let body = db.body_hir(self.parent);\n+        match &body[self.pat_id] {\n+            Pat::Bind { name, .. } => Some(name.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_self(self, db: &impl HirDatabase) -> bool {\n+        self.name(db) == Some(name::SELF_PARAM)\n+    }\n+\n+    pub fn is_mut(self, db: &impl HirDatabase) -> bool {\n+        let body = db.body_hir(self.parent);\n+        match &body[self.pat_id] {\n+            Pat::Bind { mode, .. } => match mode {\n+                BindingAnnotation::Mutable | BindingAnnotation::RefMut => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn parent(self, _db: &impl HirDatabase) -> DefWithBody {\n+        self.parent\n+    }\n+\n+    pub fn module(self, db: &impl HirDatabase) -> Module {\n+        self.parent.module(db)\n+    }\n+\n+    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+        let infer = db.infer(self.parent);\n+        infer[self.pat_id].clone()\n+    }\n+\n+    pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n+        let (_body, source_map) = db.body_with_source_map(self.parent);\n+        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n+        let root = src.file_syntax(db);\n+        src.map(|ast| ast.map(|it| it.cast().unwrap().to_node(&root), |it| it.to_node(&root)))\n+    }\n+}"}, {"sha": "daf8d8d0795182a2c8de8088f0f1eaef94876ff7", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -17,7 +17,7 @@ impl_arena_id!(ScopeId);\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ExprScopes {\n-    body: Arc<Body>,\n+    pub(crate) body: Arc<Body>,\n     scopes: Arena<ScopeId, ScopeData>,\n     scope_by_expr: FxHashMap<ExprId, ScopeId>,\n }"}, {"sha": "2c441b0f4d51a6daa73fea5070f7cb4083931ff1", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -2,13 +2,17 @@\n \n use hir_def::{StructId, StructOrUnionId, UnionId};\n use hir_expand::name::AsName;\n-use ra_syntax::ast::{self, AstNode, NameOwner};\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner},\n+    match_ast,\n+};\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    AstId, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n-    ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+    AstId, Const, Crate, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasSource,\n+    ImplBlock, Local, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n+    Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -126,6 +130,26 @@ impl FromSource for StructField {\n     }\n }\n \n+impl Local {\n+    pub fn from_source(db: &impl HirDatabase, src: Source<ast::BindPat>) -> Option<Self> {\n+        let file_id = src.file_id;\n+        let parent: DefWithBody = src.ast.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::ConstDef(ast) => { Const::from_source(db, Source { ast, file_id})?.into() },\n+                    ast::StaticDef(ast) => { Static::from_source(db, Source { ast, file_id})?.into() },\n+                    ast::FnDef(ast) => { Function::from_source(db, Source { ast, file_id})?.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let (_body, source_map) = db.body_with_source_map(parent);\n+        let pat_id = source_map.node_pat(&src.ast.into())?;\n+        Some(Local { parent, pat_id })\n+    }\n+}\n+\n impl Module {\n     pub fn from_declaration(db: &impl HirDatabase, src: Source<ast::Module>) -> Option<Self> {\n         let src_parent = Source {"}, {"sha": "806f1daed171e85aaeef8bb174b90f53a6bf1b66", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -65,7 +65,7 @@ pub use crate::{\n         docs::{DocDef, Docs, Documentation},\n         src::{HasBodySource, HasSource},\n         Adt, AssocItem, Const, ConstData, Container, Crate, CrateDependency, DefWithBody, Enum,\n-        EnumVariant, FieldSource, FnData, Function, HasBody, MacroDef, Module, ModuleDef,\n+        EnumVariant, FieldSource, FnData, Function, HasBody, Local, MacroDef, Module, ModuleDef,\n         ModuleSource, Static, Struct, StructField, Trait, TypeAlias, Union,\n     },\n     expr::ExprScopes,\n@@ -76,7 +76,11 @@ pub use crate::{\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{\n-        display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+        display::HirDisplay,\n+        primitive::{\n+            FloatBitness, FloatTy, IntBitness, IntTy, Signedness, UncertainFloatTy, UncertainIntTy,\n+        },\n+        ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n };\n "}, {"sha": "c5fdf3bab8827d8ffc4054a21125de8a61ab752e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -28,7 +28,7 @@ use crate::{\n     ids::LocationCtx,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::{self, implements_trait},\n-    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId,\n+    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, Local,\n     MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n@@ -94,6 +94,7 @@ fn def_with_body_from_child_node(\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n     resolver: Resolver,\n+    body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n     infer: Option<Arc<crate::ty::InferenceResult>>,\n     scopes: Option<Arc<crate::expr::ExprScopes>>,\n@@ -104,7 +105,7 @@ pub enum PathResolution {\n     /// An item\n     Def(crate::ModuleDef),\n     /// A local binding (only value namespace)\n-    LocalBinding(Either<AstPtr<ast::BindPat>, AstPtr<ast::SelfParam>>),\n+    Local(Local),\n     /// A generic parameter\n     GenericParam(u32),\n     SelfType(crate::ImplBlock),\n@@ -152,6 +153,7 @@ impl SourceAnalyzer {\n             let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n             SourceAnalyzer {\n                 resolver,\n+                body_owner: Some(def),\n                 body_source_map: Some(source_map),\n                 infer: Some(def.infer(db)),\n                 scopes: Some(scopes),\n@@ -162,6 +164,7 @@ impl SourceAnalyzer {\n                     .ancestors()\n                     .find_map(|node| try_get_resolver_for_node(db, file_id, &node))\n                     .unwrap_or_default(),\n+                body_owner: None,\n                 body_source_map: None,\n                 infer: None,\n                 scopes: None,\n@@ -233,16 +236,9 @@ impl SourceAnalyzer {\n         });\n         let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n             let res = match val {\n-                ValueNs::LocalBinding(it) => {\n-                    // We get a `PatId` from resolver, but it actually can only\n-                    // point at `BindPat`, and not at the arbitrary pattern.\n-                    let pat_ptr = self\n-                        .body_source_map\n-                        .as_ref()?\n-                        .pat_syntax(it)?\n-                        .ast // FIXME: ignoring file_id here is definitelly wrong\n-                        .map_a(|ptr| ptr.cast::<ast::BindPat>().unwrap());\n-                    PathResolution::LocalBinding(pat_ptr)\n+                ValueNs::LocalBinding(pat_id) => {\n+                    let var = Local { parent: self.body_owner?, pat_id };\n+                    PathResolution::Local(var)\n                 }\n                 ValueNs::Function(it) => PathResolution::Def(it.into()),\n                 ValueNs::Const(it) => PathResolution::Def(it.into()),"}, {"sha": "896bf2924b905146b525b55bc76b85a63b7cbab0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -4810,3 +4810,22 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_builtin_macros_line() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() {\n+    let x = line!();\n+}\n+\"#),\n+        @r###\"\n+        ![0; 1) '6': i32\n+        [64; 88) '{     ...!(); }': ()\n+        [74; 75) 'x': i32        \n+    \"###\n+    );\n+}"}, {"sha": "2ec0c83fe58ee16f5fa00dc7718957975cd78dfb", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -3,6 +3,8 @@\n //! A peculiarity of built-in types is that they are always available and are\n //! not associated with any particular crate.\n \n+use std::fmt;\n+\n use hir_expand::name::{self, Name};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n@@ -61,3 +63,33 @@ impl BuiltinType {\n         (name::F64, BuiltinType::Float { bitness: FloatBitness::X64 }),\n     ];\n }\n+\n+impl fmt::Display for BuiltinType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = match self {\n+            BuiltinType::Char => \"char\",\n+            BuiltinType::Bool => \"bool\",\n+            BuiltinType::Str => \"str\",\n+            BuiltinType::Int { signedness, bitness } => match (signedness, bitness) {\n+                (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n+                (Signedness::Signed, IntBitness::X8) => \"i8\",\n+                (Signedness::Signed, IntBitness::X16) => \"i16\",\n+                (Signedness::Signed, IntBitness::X32) => \"i32\",\n+                (Signedness::Signed, IntBitness::X64) => \"i64\",\n+                (Signedness::Signed, IntBitness::X128) => \"i128\",\n+\n+                (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n+                (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n+                (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n+                (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n+                (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n+                (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n+            },\n+            BuiltinType::Float { bitness } => match bitness {\n+                FloatBitness::X32 => \"f32\",\n+                FloatBitness::X64 => \"f64\",\n+            },\n+        };\n+        f.write_str(type_name)\n+    }\n+}"}, {"sha": "37d0f30936ff164a84eff065c590fb3cdce4053b", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -1,8 +1,9 @@\n //! FIXME: write short doc here\n \n use hir_expand::{\n+    builtin_macro::find_builtin_macro,\n     name::{self, AsName, Name},\n-    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind,\n+    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFileKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n@@ -692,10 +693,30 @@ where\n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n         let ast_id = AstId::new(self.file_id, mac.ast_id);\n \n+        // Case 0: builtin macros\n+        if mac.builtin {\n+            if let Some(name) = &mac.name {\n+                let krate = self.def_collector.def_map.krate;\n+                if let Some(macro_id) = find_builtin_macro(name, krate, ast_id) {\n+                    self.def_collector.define_macro(\n+                        self.module_id,\n+                        name.clone(),\n+                        macro_id,\n+                        mac.export,\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId { ast_id, krate: self.def_collector.def_map.krate };\n+                let macro_id = MacroDefId {\n+                    ast_id,\n+                    krate: self.def_collector.def_map.krate,\n+                    kind: MacroDefKind::Declarative,\n+                };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }\n             return;"}, {"sha": "f52002bc0b74d9d9a55002f1f3b8e8bd92dded32", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -200,6 +200,7 @@ pub(super) struct MacroData {\n     pub(super) path: Path,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n+    pub(super) builtin: bool,\n }\n \n struct RawItemsCollector {\n@@ -367,7 +368,11 @@ impl RawItemsCollector {\n         // FIXME: cfg_attr\n         let export = m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"macro_export\");\n \n-        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n+        // FIXME: cfg_attr\n+        let builtin =\n+            m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"rustc_builtin_macro\");\n+\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export, builtin });\n         self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n "}, {"sha": "97fb0cb552193abea9500a678b3c8c608baeedbb", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -0,0 +1,80 @@\n+//! Builtin macro\n+use crate::db::AstDatabase;\n+use crate::{\n+    ast::{self, AstNode},\n+    name, AstId, CrateId, HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n+    TextUnit,\n+};\n+\n+use crate::quote;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum BuiltinExpander {\n+    Line,\n+}\n+\n+impl BuiltinExpander {\n+    pub fn expand(\n+        &self,\n+        db: &dyn AstDatabase,\n+        id: MacroCallId,\n+        tt: &tt::Subtree,\n+    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+        match self {\n+            BuiltinExpander::Line => line_expand(db, id, tt),\n+        }\n+    }\n+}\n+\n+pub fn find_builtin_macro(\n+    ident: &name::Name,\n+    krate: CrateId,\n+    ast_id: AstId<ast::MacroCall>,\n+) -> Option<MacroDefId> {\n+    // FIXME: Better registering method\n+    if ident == &name::LINE_MACRO {\n+        Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(BuiltinExpander::Line) })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n+    // FIXME: Use expansion info\n+    let file_id = file.original_file(db);\n+    let text = db.file_text(file_id);\n+    let mut line_num = 1;\n+\n+    // Count line end\n+    for (i, c) in text.chars().enumerate() {\n+        if i == pos.to_usize() {\n+            break;\n+        }\n+        if c == '\\n' {\n+            line_num += 1;\n+        }\n+    }\n+\n+    line_num\n+}\n+\n+fn line_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+\n+    let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+    let arg_start = arg.syntax().text_range().start();\n+\n+    let file = id.as_file(MacroFileKind::Expr);\n+    let line_num = to_line_number(db, file, arg_start);\n+\n+    let expanded = quote! {\n+        #line_num\n+    };\n+\n+    Ok(expanded)\n+}"}, {"sha": "5eadee9c28cc64954014645b0348d11fbc1145a4", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -9,10 +9,37 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId,\n-    MacroFile, MacroFileKind,\n+    ast_id_map::AstIdMap, BuiltinExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc,\n+    MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n };\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum TokenExpander {\n+    MacroRules(mbe::MacroRules),\n+    Builtin(BuiltinExpander),\n+}\n+\n+impl TokenExpander {\n+    pub fn expand(\n+        &self,\n+        db: &dyn AstDatabase,\n+        id: MacroCallId,\n+        tt: &tt::Subtree,\n+    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.expand(tt),\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n+        }\n+    }\n+\n+    pub fn shift(&self) -> u32 {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.shift(),\n+            TokenExpander::Builtin(_) => 0,\n+        }\n+    }\n+}\n+\n // FIXME: rename to ExpandDatabase\n #[salsa::query_group(AstDatabaseStorage)]\n pub trait AstDatabase: SourceDatabase {\n@@ -24,7 +51,7 @@ pub trait AstDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>>;\n+    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(\n         &self,\n         macro_file: MacroFile,\n@@ -41,18 +68,25 @@ pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdM\n pub(crate) fn macro_def(\n     db: &dyn AstDatabase,\n     id: MacroDefId,\n-) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>> {\n-    let macro_call = id.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n-        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n-        None\n-    })?;\n-    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n-        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n-        None\n-    })?;\n-    Some(Arc::new((rules, tmap)))\n+) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n+    match id.kind {\n+        MacroDefKind::Declarative => {\n+            let macro_call = id.ast_id.to_node(db);\n+            let arg = macro_call.token_tree()?;\n+            let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+                log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+                None\n+            })?;\n+            let rules = MacroRules::parse(&tt).ok().or_else(|| {\n+                log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n+                None\n+            })?;\n+            Some(Arc::new((TokenExpander::MacroRules(rules), tmap)))\n+        }\n+        MacroDefKind::BuiltIn(expander) => {\n+            Some(Arc::new((TokenExpander::Builtin(expander.clone()), mbe::TokenMap::default())))\n+        }\n+    }\n }\n \n pub(crate) fn macro_arg(\n@@ -74,7 +108,7 @@ pub(crate) fn macro_expand(\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(&macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(db, id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {"}, {"sha": "379562a2c14c542f5e5ebc1b4a0ec4e36703eae5", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     db::AstDatabase,\n     either::Either,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr,\n+    HirFileId, HirFileIdRepr, MacroDefKind,\n };\n \n #[derive(Debug)]\n@@ -24,7 +24,10 @@ impl Hygiene {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                Some(loc.def.krate)\n+                match loc.def.kind {\n+                    MacroDefKind::Declarative => Some(loc.def.krate),\n+                    MacroDefKind::BuiltIn(_) => None,\n+                }\n             }\n         };\n         Hygiene { def_crate }"}, {"sha": "c6ffa2c6f2f0aa08c780c0a0407ccc581bfb4997", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -10,6 +10,8 @@ pub mod either;\n pub mod name;\n pub mod hygiene;\n pub mod diagnostics;\n+pub mod builtin_macro;\n+pub mod quote;\n \n use std::hash::{Hash, Hasher};\n use std::sync::Arc;\n@@ -21,6 +23,7 @@ use ra_syntax::{\n };\n \n use crate::ast_id_map::FileAstId;\n+use crate::builtin_macro::BuiltinExpander;\n \n /// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n@@ -122,6 +125,13 @@ impl salsa::InternKey for MacroCallId {\n pub struct MacroDefId {\n     pub krate: CrateId,\n     pub ast_id: AstId<ast::MacroCall>,\n+    pub kind: MacroDefKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroDefKind {\n+    Declarative,\n+    BuiltIn(BuiltinExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -144,7 +154,7 @@ pub struct ExpansionInfo {\n     pub(crate) def_start: (HirFileId, TextUnit),\n     pub(crate) shift: u32,\n \n-    pub(crate) macro_def: Arc<(mbe::MacroRules, mbe::TokenMap)>,\n+    pub(crate) macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n     pub(crate) macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n     pub(crate) exp_map: Arc<mbe::RevTokenMap>,\n }"}, {"sha": "1bf17d12b5b5818e5c119486cba39d4088fd5c08", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -140,3 +140,6 @@ pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n+\n+// Builtin Macros\n+pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");"}, {"sha": "9cd17f0e35453d83c9933da7673b3eb311dc5739", "filename": "crates/ra_hir_expand/src/quote.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -0,0 +1,261 @@\n+//! A simplified version of quote-crate like quasi quote macro\n+\n+// A helper macro quote macro\n+// FIXME:\n+// 1. Not all puncts are handled\n+// 2. #()* pattern repetition not supported now\n+//    * But we can do it manually, see `test_quote_derive_copy_hack`\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! __quote {\n+    () => {\n+        Vec::<tt::TokenTree>::new()\n+    };\n+\n+    ( @SUBTREE $delim:ident $($tt:tt)* ) => {\n+        {\n+            let children = $crate::__quote!($($tt)*);\n+            let subtree = tt::Subtree {\n+                delimiter: tt::Delimiter::$delim,\n+                token_trees: $crate::quote::IntoTt::to_tokens(children),\n+            };\n+            subtree\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal, $sec:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Joint,\n+                }).into(),\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $sec,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    // hash variable\n+    ( # $first:ident $($tail:tt)* ) => {\n+        {\n+            let token = $crate::quote::ToTokenTree::to_token($first);\n+            let mut tokens = vec![token.into()];\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+\n+    // Brace\n+    ( { $($tt:tt)* } ) => { $crate::__quote!(@SUBTREE Brace $($tt)*) };\n+    // Bracket\n+    ( [ $($tt:tt)* ] ) => { $crate::__quote!(@SUBTREE Bracket $($tt)*) };\n+    // Parenthesis\n+    ( ( $($tt:tt)* ) ) => { $crate::__quote!(@SUBTREE Parenthesis $($tt)*) };\n+\n+    // Literal\n+    ( $tt:literal ) => { vec![$crate::quote::ToTokenTree::to_token($tt).into()] };\n+    // Ident\n+    ( $tt:ident ) => {\n+        vec![ {\n+            tt::Leaf::Ident(tt::Ident {\n+                text: stringify!($tt).into(),\n+                id: tt::TokenId::unspecified(),\n+            }).into()\n+        }]\n+    };\n+\n+    // Puncts\n+    // FIXME: Not all puncts are handled\n+    ( -> ) => {$crate::__quote!(@PUNCT '-', '>')};\n+    ( & ) => {$crate::__quote!(@PUNCT '&')};\n+    ( , ) => {$crate::__quote!(@PUNCT ',')};\n+    ( : ) => {$crate::__quote!(@PUNCT ':')};\n+    ( . ) => {$crate::__quote!(@PUNCT '.')};\n+\n+    ( $first:tt $($tail:tt)+ ) => {\n+        {\n+            let mut tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($first));\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+}\n+\n+/// FIXME:\n+/// It probably should implement in proc-macro\n+#[macro_export]\n+macro_rules! quote {\n+    ( $($tt:tt)* ) => {\n+        $crate::quote::IntoTt::to_subtree($crate::__quote!($($tt)*))\n+    }\n+}\n+\n+pub(crate) trait IntoTt {\n+    fn to_subtree(self) -> tt::Subtree;\n+    fn to_tokens(self) -> Vec<tt::TokenTree>;\n+}\n+\n+impl IntoTt for Vec<tt::TokenTree> {\n+    fn to_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: tt::Delimiter::None, token_trees: self }\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        self\n+    }\n+}\n+\n+impl IntoTt for tt::Subtree {\n+    fn to_subtree(self) -> tt::Subtree {\n+        self\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        vec![tt::TokenTree::Subtree(self)]\n+    }\n+}\n+\n+pub(crate) trait ToTokenTree {\n+    fn to_token(self) -> tt::TokenTree;\n+}\n+\n+impl ToTokenTree for tt::TokenTree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self\n+    }\n+}\n+\n+impl ToTokenTree for tt::Subtree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self.into()\n+    }\n+}\n+\n+macro_rules! impl_to_to_tokentrees {\n+    ($($ty:ty => $this:ident $im:block);*) => {\n+        $(\n+            impl ToTokenTree for $ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.into();\n+                    leaf.into()\n+                }\n+            }\n+\n+            impl ToTokenTree for &$ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.clone().into();\n+                    leaf.into()\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_to_to_tokentrees! {\n+    u32 => self { tt::Literal{text: self.to_string().into()} };\n+    usize => self { tt::Literal{text: self.to_string().into()}};\n+    i32 => self { tt::Literal{text: self.to_string().into()}};\n+    &str => self { tt::Literal{text: self.to_string().into()}};\n+    String => self { tt::Literal{text: self.into()}};\n+    tt::Leaf => self { self };\n+    tt::Literal => self { self };\n+    tt::Ident => self { self };\n+    tt::Punct => self { self }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_quote_delimiters() {\n+        assert_eq!(quote!({}).to_string(), \"{}\");\n+        assert_eq!(quote!(()).to_string(), \"()\");\n+        assert_eq!(quote!([]).to_string(), \"[]\");\n+    }\n+\n+    #[test]\n+    fn test_quote_idents() {\n+        assert_eq!(quote!(32).to_string(), \"32\");\n+        assert_eq!(quote!(struct).to_string(), \"struct\");\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_simple_literal() {\n+        let a = 20;\n+        assert_eq!(quote!(#a).to_string(), \"20\");\n+        let s: String = \"hello\".into();\n+        assert_eq!(quote!(#s).to_string(), \"hello\");\n+    }\n+\n+    fn mk_ident(name: &str) -> tt::Ident {\n+        tt::Ident { text: name.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_token_tree() {\n+        let a = mk_ident(\"hello\");\n+\n+        let quoted = quote!(#a);\n+        assert_eq!(quoted.to_string(), \"hello\");\n+        let t = format!(\"{:?}\", quoted);\n+        assert_eq!(t, \"Subtree { delimiter: None, token_trees: [Leaf(Ident(Ident { text: \\\"hello\\\", id: TokenId(4294967295) }))] }\");\n+    }\n+\n+    #[test]\n+    fn test_quote_simple_derive_copy() {\n+        let name = mk_ident(\"Foo\");\n+\n+        let quoted = quote! {\n+            impl Clone for #name {\n+                fn clone(&self) -> Self {\n+                    Self {}\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {}}}\");\n+    }\n+\n+    #[test]\n+    fn test_quote_derive_copy_hack() {\n+        // Assume the given struct is:\n+        // struct Foo {\n+        //  name: String,\n+        //  id: u32,\n+        // }\n+        let struct_name = mk_ident(\"Foo\");\n+        let fields = [mk_ident(\"name\"), mk_ident(\"id\")];\n+        let fields = fields\n+            .into_iter()\n+            .map(|it| quote!(#it: self.#it.clone(), ).token_trees.clone())\n+            .flatten();\n+\n+        let list = tt::Subtree { delimiter: tt::Delimiter::Brace, token_trees: fields.collect() };\n+\n+        let quoted = quote! {\n+            impl Clone for #struct_name {\n+                fn clone(&self) -> Self {\n+                    Self #list\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {name : self . name . clone () , id : self . id . clone () ,}}}\");\n+    }\n+}"}, {"sha": "30617412a6dfa459ea3af8b85383761ccf37577c", "filename": "crates/ra_ide_api/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -15,7 +15,7 @@ pub use function_signature::FunctionSignature;\n pub use navigation_target::NavigationTarget;\n pub use structure::{file_structure, StructureNode};\n \n-pub(crate) use navigation_target::{description_from_symbol, docs_from_symbol};\n+pub(crate) use navigation_target::{description_from_symbol, docs_from_symbol, ToNav};\n pub(crate) use short_label::ShortLabel;\n \n pub(crate) fn function_label(node: &ast::FnDef) -> String {"}, {"sha": "f7ad085158273f087fd2ea34bb340077b21efe96", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 207, "deletions": 191, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -1,11 +1,11 @@\n //! FIXME: write short doc here\n \n-use hir::{AssocItem, FieldSource, HasSource, ModuleSource};\n+use hir::{AssocItem, Either, FieldSource, HasSource, ModuleSource};\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    ast::{self, DocCommentsOwner},\n-    match_ast, AstNode, AstPtr, SmolStr,\n-    SyntaxKind::{self, NAME},\n+    ast::{self, DocCommentsOwner, NameOwner},\n+    match_ast, AstNode, SmolStr,\n+    SyntaxKind::{self, BIND_PAT},\n     SyntaxNode, TextRange,\n };\n \n@@ -29,19 +29,8 @@ pub struct NavigationTarget {\n     docs: Option<String>,\n }\n \n-fn find_range_from_node(\n-    db: &RootDatabase,\n-    src: hir::HirFileId,\n-    node: &SyntaxNode,\n-) -> (FileId, TextRange) {\n-    let text_range = node.text_range();\n-    let (file_id, text_range) = src\n-        .expansion_info(db)\n-        .and_then(|expansion_info| expansion_info.find_range(text_range))\n-        .unwrap_or((src, text_range));\n-\n-    // FIXME: handle recursive macro generated macro\n-    (file_id.original_file(db), text_range)\n+pub(crate) trait ToNav {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget;\n }\n \n impl NavigationTarget {\n@@ -87,88 +76,6 @@ impl NavigationTarget {\n         self.focus_range\n     }\n \n-    pub(crate) fn from_bind_pat(\n-        db: &RootDatabase,\n-        file_id: FileId,\n-        pat: &ast::BindPat,\n-    ) -> NavigationTarget {\n-        NavigationTarget::from_named(db, file_id.into(), pat, None, None)\n-    }\n-\n-    pub(crate) fn from_symbol(db: &RootDatabase, symbol: FileSymbol) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id: symbol.file_id,\n-            name: symbol.name.clone(),\n-            kind: symbol.ptr.kind(),\n-            full_range: symbol.ptr.range(),\n-            focus_range: symbol.name_range,\n-            container_name: symbol.container_name.clone(),\n-            description: description_from_symbol(db, &symbol),\n-            docs: docs_from_symbol(db, &symbol),\n-        }\n-    }\n-\n-    pub(crate) fn from_pat(\n-        db: &RootDatabase,\n-        file_id: FileId,\n-        pat: AstPtr<ast::BindPat>,\n-    ) -> NavigationTarget {\n-        let parse = db.parse(file_id);\n-        let pat = pat.to_node(parse.tree().syntax());\n-        NavigationTarget::from_bind_pat(db, file_id, &pat)\n-    }\n-\n-    pub(crate) fn from_self_param(\n-        file_id: FileId,\n-        par: AstPtr<ast::SelfParam>,\n-    ) -> NavigationTarget {\n-        let (name, full_range) = (\"self\".into(), par.syntax_node_ptr().range());\n-\n-        NavigationTarget {\n-            file_id,\n-            name,\n-            full_range,\n-            focus_range: None,\n-            kind: NAME,\n-            container_name: None,\n-            description: None, //< No document node for SelfParam\n-            docs: None,        //< No document node for SelfParam\n-        }\n-    }\n-\n-    pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n-        let src = module.definition_source(db);\n-        let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n-        match src.ast {\n-            ModuleSource::SourceFile(node) => {\n-                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n-\n-                NavigationTarget::from_syntax(\n-                    file_id,\n-                    name,\n-                    None,\n-                    text_range,\n-                    node.syntax(),\n-                    None,\n-                    None,\n-                )\n-            }\n-            ModuleSource::Module(node) => {\n-                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n-\n-                NavigationTarget::from_syntax(\n-                    file_id,\n-                    name,\n-                    None,\n-                    text_range,\n-                    node.syntax(),\n-                    node.doc_comment_text(),\n-                    node.short_label(),\n-                )\n-            }\n-        }\n-    }\n-\n     pub(crate) fn from_module_to_decl(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n@@ -183,112 +90,29 @@ impl NavigationTarget {\n                 src.ast.short_label(),\n             );\n         }\n-        NavigationTarget::from_module(db, module)\n-    }\n-\n-    pub(crate) fn from_field(db: &RootDatabase, field: hir::StructField) -> NavigationTarget {\n-        let src = field.source(db);\n-        match src.ast {\n-            FieldSource::Named(it) => NavigationTarget::from_named(\n-                db,\n-                src.file_id,\n-                &it,\n-                it.doc_comment_text(),\n-                it.short_label(),\n-            ),\n-            FieldSource::Pos(it) => {\n-                let (file_id, text_range) = find_range_from_node(db, src.file_id, it.syntax());\n-                NavigationTarget::from_syntax(\n-                    file_id,\n-                    \"\".into(),\n-                    None,\n-                    text_range,\n-                    it.syntax(),\n-                    None,\n-                    None,\n-                )\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn from_def_source<A, D>(db: &RootDatabase, def: D) -> NavigationTarget\n-    where\n-        D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n-    {\n-        let src = def.source(db);\n-        NavigationTarget::from_named(\n-            db,\n-            src.file_id,\n-            &src.ast,\n-            src.ast.doc_comment_text(),\n-            src.ast.short_label(),\n-        )\n-    }\n-\n-    pub(crate) fn from_adt_def(db: &RootDatabase, adt_def: hir::Adt) -> NavigationTarget {\n-        match adt_def {\n-            hir::Adt::Struct(it) => NavigationTarget::from_def_source(db, it),\n-            hir::Adt::Union(it) => NavigationTarget::from_def_source(db, it),\n-            hir::Adt::Enum(it) => NavigationTarget::from_def_source(db, it),\n-        }\n+        module.to_nav(db)\n     }\n \n     pub(crate) fn from_def(\n         db: &RootDatabase,\n         module_def: hir::ModuleDef,\n     ) -> Option<NavigationTarget> {\n         let nav = match module_def {\n-            hir::ModuleDef::Module(module) => NavigationTarget::from_module(db, module),\n-            hir::ModuleDef::Function(func) => NavigationTarget::from_def_source(db, func),\n-            hir::ModuleDef::Adt(it) => NavigationTarget::from_adt_def(db, it),\n-            hir::ModuleDef::Const(it) => NavigationTarget::from_def_source(db, it),\n-            hir::ModuleDef::Static(it) => NavigationTarget::from_def_source(db, it),\n-            hir::ModuleDef::EnumVariant(it) => NavigationTarget::from_def_source(db, it),\n-            hir::ModuleDef::Trait(it) => NavigationTarget::from_def_source(db, it),\n-            hir::ModuleDef::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n+            hir::ModuleDef::Module(module) => module.to_nav(db),\n+            hir::ModuleDef::Function(it) => it.to_nav(db),\n+            hir::ModuleDef::Adt(it) => it.to_nav(db),\n+            hir::ModuleDef::Const(it) => it.to_nav(db),\n+            hir::ModuleDef::Static(it) => it.to_nav(db),\n+            hir::ModuleDef::EnumVariant(it) => it.to_nav(db),\n+            hir::ModuleDef::Trait(it) => it.to_nav(db),\n+            hir::ModuleDef::TypeAlias(it) => it.to_nav(db),\n             hir::ModuleDef::BuiltinType(..) => {\n                 return None;\n             }\n         };\n         Some(nav)\n     }\n \n-    pub(crate) fn from_impl_block(\n-        db: &RootDatabase,\n-        impl_block: hir::ImplBlock,\n-    ) -> NavigationTarget {\n-        let src = impl_block.source(db);\n-        let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n-\n-        NavigationTarget::from_syntax(\n-            file_id,\n-            \"impl\".into(),\n-            None,\n-            text_range,\n-            src.ast.syntax(),\n-            None,\n-            None,\n-        )\n-    }\n-\n-    pub(crate) fn from_assoc_item(\n-        db: &RootDatabase,\n-        assoc_item: hir::AssocItem,\n-    ) -> NavigationTarget {\n-        match assoc_item {\n-            AssocItem::Function(it) => NavigationTarget::from_def_source(db, it),\n-            AssocItem::Const(it) => NavigationTarget::from_def_source(db, it),\n-            AssocItem::TypeAlias(it) => NavigationTarget::from_def_source(db, it),\n-        }\n-    }\n-\n-    pub(crate) fn from_macro_def(db: &RootDatabase, macro_call: hir::MacroDef) -> NavigationTarget {\n-        let src = macro_call.source(db);\n-        log::debug!(\"nav target {:#?}\", src.ast.syntax());\n-        NavigationTarget::from_named(db, src.file_id, &src.ast, src.ast.doc_comment_text(), None)\n-    }\n-\n     #[cfg(test)]\n     pub(crate) fn assert_match(&self, expected: &str) {\n         let actual = self.debug_render();\n@@ -359,6 +183,198 @@ impl NavigationTarget {\n     }\n }\n \n+impl ToNav for FileSymbol {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        NavigationTarget {\n+            file_id: self.file_id,\n+            name: self.name.clone(),\n+            kind: self.ptr.kind(),\n+            full_range: self.ptr.range(),\n+            focus_range: self.name_range,\n+            container_name: self.container_name.clone(),\n+            description: description_from_symbol(db, self),\n+            docs: docs_from_symbol(db, self),\n+        }\n+    }\n+}\n+\n+pub(crate) trait ToNavFromAst {}\n+impl ToNavFromAst for hir::Function {}\n+impl ToNavFromAst for hir::Const {}\n+impl ToNavFromAst for hir::Static {}\n+impl ToNavFromAst for hir::Struct {}\n+impl ToNavFromAst for hir::Enum {}\n+impl ToNavFromAst for hir::EnumVariant {}\n+impl ToNavFromAst for hir::Union {}\n+impl ToNavFromAst for hir::TypeAlias {}\n+impl ToNavFromAst for hir::Trait {}\n+\n+impl<D> ToNav for D\n+where\n+    D: HasSource + ToNavFromAst + Copy,\n+    D::Ast: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+{\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+        NavigationTarget::from_named(\n+            db,\n+            src.file_id,\n+            &src.ast,\n+            src.ast.doc_comment_text(),\n+            src.ast.short_label(),\n+        )\n+    }\n+}\n+\n+impl ToNav for hir::Module {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.definition_source(db);\n+        let name = self.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n+        match src.ast {\n+            ModuleSource::SourceFile(node) => {\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    None,\n+                    None,\n+                )\n+            }\n+            ModuleSource::Module(node) => {\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, node.syntax());\n+\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    name,\n+                    None,\n+                    text_range,\n+                    node.syntax(),\n+                    node.doc_comment_text(),\n+                    node.short_label(),\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+impl ToNav for hir::ImplBlock {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+        let (file_id, text_range) = find_range_from_node(db, src.file_id, src.ast.syntax());\n+\n+        NavigationTarget::from_syntax(\n+            file_id,\n+            \"impl\".into(),\n+            None,\n+            text_range,\n+            src.ast.syntax(),\n+            None,\n+            None,\n+        )\n+    }\n+}\n+\n+impl ToNav for hir::StructField {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+\n+        match src.ast {\n+            FieldSource::Named(it) => NavigationTarget::from_named(\n+                db,\n+                src.file_id,\n+                &it,\n+                it.doc_comment_text(),\n+                it.short_label(),\n+            ),\n+            FieldSource::Pos(it) => {\n+                let (file_id, text_range) = find_range_from_node(db, src.file_id, it.syntax());\n+                NavigationTarget::from_syntax(\n+                    file_id,\n+                    \"\".into(),\n+                    None,\n+                    text_range,\n+                    it.syntax(),\n+                    None,\n+                    None,\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+impl ToNav for hir::MacroDef {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+        log::debug!(\"nav target {:#?}\", src.ast.syntax());\n+        NavigationTarget::from_named(db, src.file_id, &src.ast, src.ast.doc_comment_text(), None)\n+    }\n+}\n+\n+impl ToNav for hir::Adt {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        match self {\n+            hir::Adt::Struct(it) => it.to_nav(db),\n+            hir::Adt::Union(it) => it.to_nav(db),\n+            hir::Adt::Enum(it) => it.to_nav(db),\n+        }\n+    }\n+}\n+\n+impl ToNav for hir::AssocItem {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        match self {\n+            AssocItem::Function(it) => it.to_nav(db),\n+            AssocItem::Const(it) => it.to_nav(db),\n+            AssocItem::TypeAlias(it) => it.to_nav(db),\n+        }\n+    }\n+}\n+\n+impl ToNav for hir::Local {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+        let (full_range, focus_range) = match src.ast {\n+            Either::A(it) => {\n+                (it.syntax().text_range(), it.name().map(|it| it.syntax().text_range()))\n+            }\n+            Either::B(it) => (it.syntax().text_range(), Some(it.self_kw_token().text_range())),\n+        };\n+        let name = match self.name(db) {\n+            Some(it) => it.to_string().into(),\n+            None => \"\".into(),\n+        };\n+        NavigationTarget {\n+            file_id: src.file_id.original_file(db),\n+            name,\n+            kind: BIND_PAT,\n+            full_range,\n+            focus_range,\n+            container_name: None,\n+            description: None,\n+            docs: None,\n+        }\n+    }\n+}\n+\n+fn find_range_from_node(\n+    db: &RootDatabase,\n+    src: hir::HirFileId,\n+    node: &SyntaxNode,\n+) -> (FileId, TextRange) {\n+    let text_range = node.text_range();\n+    let (file_id, text_range) = src\n+        .expansion_info(db)\n+        .and_then(|expansion_info| expansion_info.find_range(text_range))\n+        .unwrap_or((src, text_range));\n+\n+    // FIXME: handle recursive macro generated macro\n+    (file_id.original_file(db), text_range)\n+}\n+\n pub(crate) fn docs_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option<String> {\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax());"}, {"sha": "6c8387f6cd78aab94175015ce3d03e9bce66e0da", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    display::ShortLabel,\n+    display::{ShortLabel, ToNav},\n     references::{classify_name_ref, NameKind::*},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n@@ -56,20 +56,19 @@ pub(crate) fn reference_definition(\n \n     let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n     match name_kind {\n-        Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n-        Some(Field(field)) => return Exact(NavigationTarget::from_field(db, field)),\n-        Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n+        Some(Macro(mac)) => return Exact(mac.to_nav(db)),\n+        Some(Field(field)) => return Exact(field.to_nav(db)),\n+        Some(AssocItem(assoc)) => return Exact(assoc.to_nav(db)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n         },\n         Some(SelfType(ty)) => {\n-            if let Some((def_id, _)) = ty.as_adt() {\n-                return Exact(NavigationTarget::from_adt_def(db, def_id));\n+            if let Some((adt, _)) = ty.as_adt() {\n+                return Exact(adt.to_nav(db));\n             }\n         }\n-        Some(Pat((_, pat))) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n-        Some(SelfParam(par)) => return Exact(NavigationTarget::from_self_param(file_id, par)),\n+        Some(Local(local)) => return Exact(local.to_nav(db)),\n         Some(GenericParam(_)) => {\n             // FIXME: go to the generic param def\n         }\n@@ -79,7 +78,7 @@ pub(crate) fn reference_definition(\n     // Fallback index based approach:\n     let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()\n-        .map(|s| NavigationTarget::from_symbol(db, s))\n+        .map(|s| s.to_nav(db))\n         .collect();\n     Approximate(navs)\n }\n@@ -95,7 +94,7 @@ pub(crate) fn name_definition(\n         if module.has_semi() {\n             let src = hir::Source { file_id: file_id.into(), ast: module };\n             if let Some(child_module) = hir::Module::from_declaration(db, src) {\n-                let nav = NavigationTarget::from_module(db, child_module);\n+                let nav = child_module.to_nav(db);\n                 return Some(vec![nav]);\n             }\n         }"}, {"sha": "71146591df807b2a27bbeab05ae52381f99913db", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -3,7 +3,7 @@\n use ra_db::SourceDatabase;\n use ra_syntax::{ast, AstNode};\n \n-use crate::{db::RootDatabase, FilePosition, NavigationTarget, RangeInfo};\n+use crate::{db::RootDatabase, display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n pub(crate) fn goto_type_definition(\n     db: &RootDatabase,\n@@ -33,7 +33,7 @@ pub(crate) fn goto_type_definition(\n \n     let adt_def = analyzer.autoderef(db, ty).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n \n-    let nav = NavigationTarget::from_adt_def(db, adt_def);\n+    let nav = adt_def.to_nav(db);\n     Some(RangeInfo::new(node.text_range(), vec![nav]))\n }\n "}, {"sha": "086e6dec3a93c239f5d17d9e266b4fae40c29cdc", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -117,27 +117,23 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n                 hir::AssocItem::Const(it) => from_def_source(db, it),\n                 hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n             }),\n-            Some(Def(it)) => {\n-                match it {\n-                    hir::ModuleDef::Module(it) => {\n-                        if let hir::ModuleSource::Module(it) = it.definition_source(db).ast {\n-                            res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                        }\n-                    }\n-                    hir::ModuleDef::Function(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Adt(Adt::Struct(it)) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Adt(Adt::Union(it)) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Adt(Adt::Enum(it)) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::EnumVariant(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Const(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Static(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::Trait(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::TypeAlias(it) => res.extend(from_def_source(db, it)),\n-                    hir::ModuleDef::BuiltinType(_) => {\n-                        // FIXME: hover for builtin Type ?\n+            Some(Def(it)) => match it {\n+                hir::ModuleDef::Module(it) => {\n+                    if let hir::ModuleSource::Module(it) = it.definition_source(db).ast {\n+                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n                     }\n                 }\n-            }\n+                hir::ModuleDef::Function(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Adt(Adt::Struct(it)) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Adt(Adt::Union(it)) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Adt(Adt::Enum(it)) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::EnumVariant(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Const(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Static(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::Trait(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::TypeAlias(it) => res.extend(from_def_source(db, it)),\n+                hir::ModuleDef::BuiltinType(it) => res.extend(Some(it.to_string())),\n+            },\n             Some(SelfType(ty)) => {\n                 if let Some((adt_def, _)) = ty.as_adt() {\n                     res.extend(match adt_def {\n@@ -147,7 +143,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n                     })\n                 }\n             }\n-            Some(Pat(_)) | Some(SelfParam(_)) => {\n+            Some(Local(_)) => {\n                 // Hover for these shows type names\n                 no_fallback = true;\n             }\n@@ -722,4 +718,16 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         assert_eq!(trim_markup_opt(hover.info.first()), Some(\"macro_rules! foo\"));\n         assert_eq!(hover.info.is_exact(), true);\n     }\n+\n+    #[test]\n+    fn test_hover_tuple_field() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            struct TS(String, i32<|>);\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"i32\"));\n+        assert_eq!(hover.info.is_exact(), true);\n+    }\n }"}, {"sha": "bc9b66550766c7f8fc8df5ab7aa549d3f01c1b0a", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -4,7 +4,7 @@ use hir::{db::HirDatabase, ApplicationTy, FromSource, Ty, TypeCtor};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n-use crate::{db::RootDatabase, FilePosition, NavigationTarget, RangeInfo};\n+use crate::{db::RootDatabase, display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n pub(crate) fn goto_implementation(\n     db: &RootDatabase,\n@@ -58,7 +58,7 @@ fn impls_for_def(\n         impls\n             .all_impls()\n             .filter(|impl_block| is_equal_for_find_impls(&ty, &impl_block.target_ty(db)))\n-            .map(|imp| NavigationTarget::from_impl_block(db, imp))\n+            .map(|imp| imp.to_nav(db))\n             .collect(),\n     )\n }\n@@ -75,12 +75,7 @@ fn impls_for_trait(\n     let krate = module.krate();\n     let impls = db.impls_in_crate(krate);\n \n-    Some(\n-        impls\n-            .lookup_impl_blocks_for_trait(tr)\n-            .map(|imp| NavigationTarget::from_impl_block(db, imp))\n-            .collect(),\n-    )\n+    Some(impls.lookup_impl_blocks_for_trait(tr).map(|imp| imp.to_nav(db)).collect())\n }\n \n fn is_equal_for_find_impls(original_ty: &Ty, impl_ty: &Ty) -> bool {"}, {"sha": "484fbcc82319b4d481b06d399597a3db5e80998b", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -56,7 +56,7 @@ use ra_db::{\n };\n use ra_syntax::{SourceFile, TextRange, TextUnit};\n \n-use crate::{db::LineIndexDatabase, symbol_index::FileSymbol};\n+use crate::{db::LineIndexDatabase, display::ToNav, symbol_index::FileSymbol};\n \n pub use crate::{\n     assists::{Assist, AssistId},\n@@ -351,7 +351,7 @@ impl Analysis {\n         self.with_db(|db| {\n             symbol_index::world_symbols(db, query)\n                 .into_iter()\n-                .map(|s| NavigationTarget::from_symbol(db, s))\n+                .map(|s| s.to_nav(db))\n                 .collect::<Vec<_>>()\n         })\n     }"}, {"sha": "9cb9433e7beaabc8fe2f4eb9ad61455bdf680dc6", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -19,7 +19,9 @@ use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_prof::profile;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode, TextUnit};\n \n-use crate::{db::RootDatabase, FilePosition, FileRange, NavigationTarget, RangeInfo};\n+use crate::{\n+    db::RootDatabase, display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo,\n+};\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n@@ -76,16 +78,15 @@ pub(crate) fn find_all_refs(\n     let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n \n     let declaration = match def.kind {\n-        NameKind::Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n-        NameKind::Field(field) => NavigationTarget::from_field(db, field),\n-        NameKind::AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n+        NameKind::Macro(mac) => mac.to_nav(db),\n+        NameKind::Field(field) => field.to_nav(db),\n+        NameKind::AssocItem(assoc) => assoc.to_nav(db),\n         NameKind::Def(def) => NavigationTarget::from_def(db, def)?,\n         NameKind::SelfType(ref ty) => match ty.as_adt() {\n-            Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n+            Some((adt, _)) => adt.to_nav(db),\n             None => return None,\n         },\n-        NameKind::Pat((_, pat)) => NavigationTarget::from_pat(db, position.file_id, pat),\n-        NameKind::SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n+        NameKind::Local(local) => local.to_nav(db),\n         NameKind::GenericParam(_) => return None,\n     };\n "}, {"sha": "217f9951e3cc1f14eea1c50e96edbb51d1c9d271", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -1,13 +1,13 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{Either, FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n+use hir::{FromSource, Module, ModuleSource, Path, PathResolution, Source, SourceAnalyzer};\n use ra_db::FileId;\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode, AstPtr};\n+use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n \n use super::{\n-    name_definition::{from_assoc_item, from_module_def, from_pat, from_struct_field},\n+    name_definition::{from_assoc_item, from_module_def, from_struct_field},\n     NameDefinition, NameKind,\n };\n use crate::db::RootDatabase;\n@@ -25,7 +25,13 @@ pub(crate) fn classify_name(\n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n-                from_pat(db, file_id, AstPtr::new(&it))\n+                let src = hir::Source { file_id, ast: it };\n+                let local = hir::Local::from_source(db, src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: local.module(db),\n+                    kind: NameKind::Local(local),\n+                })\n             },\n             ast::RecordFieldDef(it) => {\n                 let ast = hir::FieldSource::Named(it);\n@@ -159,10 +165,10 @@ pub(crate) fn classify_name_ref(\n     match resolved {\n         Def(def) => Some(from_module_def(db, def, Some(container))),\n         AssocItem(item) => Some(from_assoc_item(db, item)),\n-        LocalBinding(Either::A(pat)) => from_pat(db, file_id, pat),\n-        LocalBinding(Either::B(par)) => {\n-            let kind = NameKind::SelfParam(par);\n-            Some(NameDefinition { kind, container, visibility })\n+        Local(local) => {\n+            let container = local.module(db);\n+            let kind = NameKind::Local(local);\n+            Some(NameDefinition { kind, container, visibility: None })\n         }\n         GenericParam(par) => {\n             // FIXME: get generic param def"}, {"sha": "450f7ea9b6da6229bf96b0ba67d20d82ad0aee67", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -4,10 +4,9 @@\n //! Note that the reference search is possible for not all of the classified items.\n \n use hir::{\n-    db::AstDatabase, Adt, AssocItem, DefWithBody, FromSource, HasSource, HirFileId, MacroDef,\n-    Module, ModuleDef, StructField, Ty, VariantDef,\n+    Adt, AssocItem, HasSource, Local, MacroDef, Module, ModuleDef, StructField, Ty, VariantDef,\n };\n-use ra_syntax::{ast, ast::VisibilityOwner, match_ast, AstNode, AstPtr};\n+use ra_syntax::{ast, ast::VisibilityOwner};\n \n use crate::db::RootDatabase;\n \n@@ -18,8 +17,7 @@ pub enum NameKind {\n     AssocItem(AssocItem),\n     Def(ModuleDef),\n     SelfType(Ty),\n-    Pat((DefWithBody, AstPtr<ast::BindPat>)),\n-    SelfParam(AstPtr<ast::SelfParam>),\n+    Local(Local),\n     GenericParam(u32),\n }\n \n@@ -30,36 +28,6 @@ pub(crate) struct NameDefinition {\n     pub kind: NameKind,\n }\n \n-pub(super) fn from_pat(\n-    db: &RootDatabase,\n-    file_id: HirFileId,\n-    pat: AstPtr<ast::BindPat>,\n-) -> Option<NameDefinition> {\n-    let root = db.parse_or_expand(file_id)?;\n-    let def = pat.to_node(&root).syntax().ancestors().find_map(|node| {\n-        match_ast! {\n-            match node {\n-                ast::FnDef(it) => {\n-                    let src = hir::Source { file_id, ast: it };\n-                    Some(hir::Function::from_source(db, src)?.into())\n-                },\n-                ast::ConstDef(it) => {\n-                    let src = hir::Source { file_id, ast: it };\n-                    Some(hir::Const::from_source(db, src)?.into())\n-                },\n-                ast::StaticDef(it) => {\n-                    let src = hir::Source { file_id, ast: it };\n-                    Some(hir::Static::from_source(db, src)?.into())\n-                },\n-                _ => None,\n-            }\n-        }\n-    })?;\n-    let kind = NameKind::Pat((def, pat));\n-    let container = def.module(db);\n-    Some(NameDefinition { kind, container, visibility: None })\n-}\n-\n pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n     let container = item.module(db);\n     let visibility = match item {"}, {"sha": "2907787c24583468f29abfac6b6eb5e4d6b98203", "filename": "crates/ra_ide_api/src/references/search_scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -71,13 +71,13 @@ impl NameDefinition {\n         let module_src = self.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n-        if let NameKind::Pat((def, _)) = self.kind {\n-            let mut res = FxHashMap::default();\n-            let range = match def {\n+        if let NameKind::Local(var) = self.kind {\n+            let range = match var.parent(db) {\n                 DefWithBody::Function(f) => f.source(db).ast.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).ast.syntax().text_range(),\n                 DefWithBody::Static(s) => s.source(db).ast.syntax().text_range(),\n             };\n+            let mut res = FxHashMap::default();\n             res.insert(file_id, Some(range));\n             return SearchScope::new(res);\n         }"}, {"sha": "79f11ea80ccfa4bfaa0589506df43f9653e81f26", "filename": "crates/ra_ide_api/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -20,14 +20,14 @@\n .keyword\\.control  { color: #F0DFAF; font-weight: bold; }\n </style>\n <pre><code><span class=\"keyword\">fn</span> <span class=\"function\">main</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"3888301305669440875\" style=\"color: hsl(242,59%,59%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"5695551762718493399\" style=\"color: hsl(272,48%,45%);\">x</span> = <span class=\"variable\" data-binding-hash=\"3888301305669440875\" style=\"color: hsl(242,59%,59%);\">hello</span>.<span class=\"text\">to_string</span>();\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"5435401749617022797\" style=\"color: hsl(353,77%,74%);\">y</span> = <span class=\"variable\" data-binding-hash=\"3888301305669440875\" style=\"color: hsl(242,59%,59%);\">hello</span>.<span class=\"text\">to_string</span>();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"14702933417323009544\" style=\"color: hsl(108,90%,49%);\">x</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.<span class=\"text\">to_string</span>();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"5443150872754369068\" style=\"color: hsl(215,43%,43%);\">y</span> = <span class=\"variable\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span>.<span class=\"text\">to_string</span>();\n \n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"1903207544374197704\" style=\"color: hsl(58,61%,61%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n-    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"14878783531007968800\" style=\"color: hsl(265,73%,83%);\">y</span> = <span class=\"variable\" data-binding-hash=\"1903207544374197704\" style=\"color: hsl(58,61%,61%);\">x</span>.<span class=\"text\">to_string</span>();\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span> = <span class=\"string\">\"other color please!\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"variable\" data-binding-hash=\"2073121142529774969\" style=\"color: hsl(320,43%,74%);\">y</span> = <span class=\"variable\" data-binding-hash=\"17358108296605513516\" style=\"color: hsl(331,46%,60%);\">x</span>.<span class=\"text\">to_string</span>();\n }\n \n <span class=\"keyword\">fn</span> <span class=\"function\">bar</span>() {\n-    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"3888301305669440875\" style=\"color: hsl(242,59%,59%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable.mut\" data-binding-hash=\"8723171760279909834\" style=\"color: hsl(307,91%,75%);\">hello</span> = <span class=\"string\">\"hello\"</span>;\n }</code></pre>\n\\ No newline at end of file"}, {"sha": "d53a759ee298494083e1e3f4ef1746eebd624b25", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 67, "deletions": 101, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -2,19 +2,17 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{Mutability, Ty};\n+use hir::{Mutability, Name};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    AstNode, Direction, SmolStr, SyntaxElement, SyntaxKind,\n-    SyntaxKind::*,\n-    TextRange, T,\n-};\n+use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n \n use crate::{\n     db::RootDatabase,\n-    references::{classify_name_ref, NameKind::*},\n+    references::{\n+        classify_name, classify_name_ref,\n+        NameKind::{self, *},\n+    },\n     FileId,\n };\n \n@@ -40,32 +38,12 @@ fn is_control_keyword(kind: SyntaxKind) -> bool {\n     }\n }\n \n-fn is_variable_mutable(\n-    db: &RootDatabase,\n-    analyzer: &hir::SourceAnalyzer,\n-    pat: ast::BindPat,\n-) -> bool {\n-    if pat.is_mutable() {\n-        return true;\n-    }\n-\n-    let ty = analyzer.type_of_pat(db, &pat.into()).unwrap_or(Ty::Unknown);\n-    if let Some((_, mutability)) = ty.as_reference() {\n-        match mutability {\n-            Mutability::Shared => false,\n-            Mutability::Mut => true,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let _p = profile(\"highlight\");\n     let parse = db.parse(file_id);\n     let root = parse.tree().syntax().clone();\n \n-    fn calc_binding_hash(file_id: FileId, text: &SmolStr, shadow_count: u32) -> u64 {\n+    fn calc_binding_hash(file_id: FileId, name: &Name, shadow_count: u32) -> u64 {\n         fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n             use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n \n@@ -74,13 +52,13 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             hasher.finish()\n         }\n \n-        hash((file_id, text, shadow_count))\n+        hash((file_id, name, shadow_count))\n     }\n \n     // Visited nodes to handle highlighting priorities\n     // FIXME: retain only ranges here\n     let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n-    let mut bindings_shadow_count: FxHashMap<SmolStr, u32> = FxHashMap::default();\n+    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n \n     let mut res = Vec::new();\n     for node in root.descendants_with_tokens() {\n@@ -100,81 +78,38 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 if node.ancestors().any(|it| it.kind() == ATTR) {\n                     continue;\n                 }\n-                if let Some(name_ref) = node.as_node().cloned().and_then(ast::NameRef::cast) {\n-                    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n-                    match name_kind {\n-                        Some(Macro(_)) => \"macro\",\n-                        Some(Field(_)) => \"field\",\n-                        Some(AssocItem(hir::AssocItem::Function(_))) => \"function\",\n-                        Some(AssocItem(hir::AssocItem::Const(_))) => \"constant\",\n-                        Some(AssocItem(hir::AssocItem::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::Module(_))) => \"module\",\n-                        Some(Def(hir::ModuleDef::Function(_))) => \"function\",\n-                        Some(Def(hir::ModuleDef::Adt(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::EnumVariant(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Const(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Static(_))) => \"constant\",\n-                        Some(Def(hir::ModuleDef::Trait(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::TypeAlias(_))) => \"type\",\n-                        Some(Def(hir::ModuleDef::BuiltinType(_))) => \"type\",\n-                        Some(SelfType(_)) => \"type\",\n-                        Some(Pat((_, ptr))) => {\n-                            let pat = ptr.to_node(&root);\n-                            if let Some(name) = pat.name() {\n-                                let text = name.text();\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(text.clone()).or_default();\n-                                binding_hash =\n-                                    Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                            }\n \n-                            let analyzer =\n-                                hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n-                            if is_variable_mutable(db, &analyzer, ptr.to_node(&root)) {\n-                                \"variable.mut\"\n-                            } else {\n-                                \"variable\"\n-                            }\n-                        }\n-                        Some(SelfParam(_)) => \"type\",\n-                        Some(GenericParam(_)) => \"type\",\n-                        None => \"text\",\n+                let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n+                let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+\n+                if let Some(Local(local)) = &name_kind {\n+                    if let Some(name) = local.name(db) {\n+                        let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                        binding_hash = Some(calc_binding_hash(file_id, &name, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n-                }\n+                };\n+\n+                name_kind.map_or(\"text\", |it| highlight_name(db, it))\n             }\n             NAME => {\n-                if let Some(name) = node.as_node().cloned().and_then(ast::Name::cast) {\n-                    let analyzer = hir::SourceAnalyzer::new(db, file_id, name.syntax(), None);\n-                    if let Some(pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n-                        if let Some(name) = pat.name() {\n-                            let text = name.text();\n-                            let shadow_count =\n-                                bindings_shadow_count.entry(text.clone()).or_default();\n-                            *shadow_count += 1;\n-                            binding_hash = Some(calc_binding_hash(file_id, &text, *shadow_count))\n-                        }\n-\n-                        if is_variable_mutable(db, &analyzer, pat) {\n-                            \"variable.mut\"\n-                        } else {\n-                            \"variable\"\n-                        }\n-                    } else {\n-                        name.syntax()\n-                            .parent()\n-                            .map(|x| match x.kind() {\n-                                TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => {\n-                                    \"type\"\n-                                }\n-                                RECORD_FIELD_DEF => \"field\",\n-                                _ => \"function\",\n-                            })\n-                            .unwrap_or(\"function\")\n+                let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n+                let name_kind = classify_name(db, file_id, &name).map(|d| d.kind);\n+\n+                if let Some(Local(local)) = &name_kind {\n+                    if let Some(name) = local.name(db) {\n+                        let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                        *shadow_count += 1;\n+                        binding_hash = Some(calc_binding_hash(file_id, &name, *shadow_count))\n                     }\n-                } else {\n-                    \"text\"\n+                };\n+\n+                match name_kind {\n+                    Some(name_kind) => highlight_name(db, name_kind),\n+                    None => name.syntax().parent().map_or(\"function\", |x| match x.kind() {\n+                        TYPE_PARAM | STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_ALIAS_DEF => \"type\",\n+                        RECORD_FIELD_DEF => \"field\",\n+                        _ => \"function\",\n+                    }),\n                 }\n             }\n             INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE => \"literal\",\n@@ -272,6 +207,37 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n     buf\n }\n \n+fn highlight_name(db: &RootDatabase, name_kind: NameKind) -> &'static str {\n+    match name_kind {\n+        Macro(_) => \"macro\",\n+        Field(_) => \"field\",\n+        AssocItem(hir::AssocItem::Function(_)) => \"function\",\n+        AssocItem(hir::AssocItem::Const(_)) => \"constant\",\n+        AssocItem(hir::AssocItem::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::Module(_)) => \"module\",\n+        Def(hir::ModuleDef::Function(_)) => \"function\",\n+        Def(hir::ModuleDef::Adt(_)) => \"type\",\n+        Def(hir::ModuleDef::EnumVariant(_)) => \"constant\",\n+        Def(hir::ModuleDef::Const(_)) => \"constant\",\n+        Def(hir::ModuleDef::Static(_)) => \"constant\",\n+        Def(hir::ModuleDef::Trait(_)) => \"type\",\n+        Def(hir::ModuleDef::TypeAlias(_)) => \"type\",\n+        Def(hir::ModuleDef::BuiltinType(_)) => \"type\",\n+        SelfType(_) => \"type\",\n+        GenericParam(_) => \"type\",\n+        Local(local) => {\n+            if local.is_mut(db) {\n+                \"variable.mut\"\n+            } else {\n+                match local.ty(db).as_reference() {\n+                    Some((_, Mutability::Mut)) => \"variable.mut\",\n+                    _ => \"variable\",\n+                }\n+            }\n+        }\n+    }\n+}\n+\n //FIXME: like, real html escaping\n fn html_escape(text: &str) -> String {\n     text.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")"}, {"sha": "1f60a7aabd06f7ff40217458e3a30f4a8c5e5fea", "filename": "crates/ra_syntax/src/syntax_error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -82,6 +82,7 @@ pub enum SyntaxErrorKind {\n     InvalidBlockAttr,\n     InvalidMatchInnerAttr,\n     InvalidTupleIndexFormat,\n+    VisibilityNotAllowed,\n }\n \n impl fmt::Display for SyntaxErrorKind {\n@@ -99,6 +100,9 @@ impl fmt::Display for SyntaxErrorKind {\n             }\n             ParseError(msg) => write!(f, \"{}\", msg.0),\n             EscapeError(err) => write!(f, \"{}\", err),\n+            VisibilityNotAllowed => {\n+                write!(f, \"unnecessary visibility qualifier\")\n+            }\n         }\n     }\n }"}, {"sha": "2d596763ee376cabca113b93b61ed90bf011d934", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -6,7 +6,7 @@ use rustc_lexer::unescape;\n \n use crate::{\n     ast, match_ast, AstNode, SyntaxError, SyntaxErrorKind,\n-    SyntaxKind::{BYTE, BYTE_STRING, CHAR, INT_NUMBER, STRING},\n+    SyntaxKind::{BYTE, BYTE_STRING, CHAR, CONST_DEF, FN_DEF, INT_NUMBER, STRING, TYPE_ALIAS_DEF},\n     SyntaxNode, SyntaxToken, TextUnit, T,\n };\n \n@@ -102,6 +102,7 @@ pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n                 ast::BlockExpr(it) => { block::validate_block_expr(it, &mut errors) },\n                 ast::FieldExpr(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n                 ast::RecordField(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n+                ast::Visibility(it) => { validate_visibility(it, &mut errors) },\n                 _ => (),\n             }\n         }\n@@ -206,3 +207,23 @@ fn validate_numeric_name(name_ref: Option<ast::NameRef>, errors: &mut Vec<Syntax\n         name_ref?.syntax().first_child_or_token()?.into_token().filter(|it| it.kind() == INT_NUMBER)\n     }\n }\n+\n+fn validate_visibility(vis: ast::Visibility, errors: &mut Vec<SyntaxError>) {\n+    let parent = match vis.syntax().parent() {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    match parent.kind() {\n+        FN_DEF | CONST_DEF | TYPE_ALIAS_DEF => (),\n+        _ => return,\n+    }\n+    let impl_block = match parent.parent().and_then(|it| it.parent()).and_then(ast::ImplBlock::cast)\n+    {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    if impl_block.target_trait().is_some() {\n+        errors\n+            .push(SyntaxError::new(SyntaxErrorKind::VisibilityNotAllowed, vis.syntax.text_range()))\n+    }\n+}"}, {"sha": "a43e7ef10c1f9c59afb9f0cd119d02048f89a376", "filename": "crates/ra_syntax/test_data/parser/err/0037_visibility_in_traits.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.rs?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -0,0 +1,6 @@\n+impl T for () {\n+    fn foo() {}\n+    pub fn bar() {}\n+    pub(crate) type Baz = ();\n+    pub(crate) const C: i32 = 92;\n+}"}, {"sha": "749c8cddbcadcb3a4f0dfdf9616c3c46126cd898", "filename": "crates/ra_syntax/test_data/parser/err/0037_visibility_in_traits.txt", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.txt", "raw_url": "https://github.com/rust-lang/rust/raw/68a5ff050faf514e9d122212a66703ca8ce66ab7/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0037_visibility_in_traits.txt?ref=68a5ff050faf514e9d122212a66703ca8ce66ab7", "patch": "@@ -0,0 +1,99 @@\n+SOURCE_FILE@[0; 118)\n+  IMPL_BLOCK@[0; 117)\n+    IMPL_KW@[0; 4) \"impl\"\n+    WHITESPACE@[4; 5) \" \"\n+    PATH_TYPE@[5; 6)\n+      PATH@[5; 6)\n+        PATH_SEGMENT@[5; 6)\n+          NAME_REF@[5; 6)\n+            IDENT@[5; 6) \"T\"\n+    WHITESPACE@[6; 7) \" \"\n+    FOR_KW@[7; 10) \"for\"\n+    WHITESPACE@[10; 11) \" \"\n+    TUPLE_TYPE@[11; 13)\n+      L_PAREN@[11; 12) \"(\"\n+      R_PAREN@[12; 13) \")\"\n+    WHITESPACE@[13; 14) \" \"\n+    ITEM_LIST@[14; 117)\n+      L_CURLY@[14; 15) \"{\"\n+      WHITESPACE@[15; 20) \"\\n    \"\n+      FN_DEF@[20; 31)\n+        FN_KW@[20; 22) \"fn\"\n+        WHITESPACE@[22; 23) \" \"\n+        NAME@[23; 26)\n+          IDENT@[23; 26) \"foo\"\n+        PARAM_LIST@[26; 28)\n+          L_PAREN@[26; 27) \"(\"\n+          R_PAREN@[27; 28) \")\"\n+        WHITESPACE@[28; 29) \" \"\n+        BLOCK_EXPR@[29; 31)\n+          BLOCK@[29; 31)\n+            L_CURLY@[29; 30) \"{\"\n+            R_CURLY@[30; 31) \"}\"\n+      WHITESPACE@[31; 36) \"\\n    \"\n+      FN_DEF@[36; 51)\n+        VISIBILITY@[36; 39)\n+          PUB_KW@[36; 39) \"pub\"\n+        WHITESPACE@[39; 40) \" \"\n+        FN_KW@[40; 42) \"fn\"\n+        WHITESPACE@[42; 43) \" \"\n+        NAME@[43; 46)\n+          IDENT@[43; 46) \"bar\"\n+        PARAM_LIST@[46; 48)\n+          L_PAREN@[46; 47) \"(\"\n+          R_PAREN@[47; 48) \")\"\n+        WHITESPACE@[48; 49) \" \"\n+        BLOCK_EXPR@[49; 51)\n+          BLOCK@[49; 51)\n+            L_CURLY@[49; 50) \"{\"\n+            R_CURLY@[50; 51) \"}\"\n+      WHITESPACE@[51; 56) \"\\n    \"\n+      TYPE_ALIAS_DEF@[56; 81)\n+        VISIBILITY@[56; 66)\n+          PUB_KW@[56; 59) \"pub\"\n+          L_PAREN@[59; 60) \"(\"\n+          CRATE_KW@[60; 65) \"crate\"\n+          R_PAREN@[65; 66) \")\"\n+        WHITESPACE@[66; 67) \" \"\n+        TYPE_KW@[67; 71) \"type\"\n+        WHITESPACE@[71; 72) \" \"\n+        NAME@[72; 75)\n+          IDENT@[72; 75) \"Baz\"\n+        WHITESPACE@[75; 76) \" \"\n+        EQ@[76; 77) \"=\"\n+        WHITESPACE@[77; 78) \" \"\n+        TUPLE_TYPE@[78; 80)\n+          L_PAREN@[78; 79) \"(\"\n+          R_PAREN@[79; 80) \")\"\n+        SEMI@[80; 81) \";\"\n+      WHITESPACE@[81; 86) \"\\n    \"\n+      CONST_DEF@[86; 115)\n+        VISIBILITY@[86; 96)\n+          PUB_KW@[86; 89) \"pub\"\n+          L_PAREN@[89; 90) \"(\"\n+          CRATE_KW@[90; 95) \"crate\"\n+          R_PAREN@[95; 96) \")\"\n+        WHITESPACE@[96; 97) \" \"\n+        CONST_KW@[97; 102) \"const\"\n+        WHITESPACE@[102; 103) \" \"\n+        NAME@[103; 104)\n+          IDENT@[103; 104) \"C\"\n+        COLON@[104; 105) \":\"\n+        WHITESPACE@[105; 106) \" \"\n+        PATH_TYPE@[106; 109)\n+          PATH@[106; 109)\n+            PATH_SEGMENT@[106; 109)\n+              NAME_REF@[106; 109)\n+                IDENT@[106; 109) \"i32\"\n+        WHITESPACE@[109; 110) \" \"\n+        EQ@[110; 111) \"=\"\n+        WHITESPACE@[111; 112) \" \"\n+        LITERAL@[112; 114)\n+          INT_NUMBER@[112; 114) \"92\"\n+        SEMI@[114; 115) \";\"\n+      WHITESPACE@[115; 116) \"\\n\"\n+      R_CURLY@[116; 117) \"}\"\n+  WHITESPACE@[117; 118) \"\\n\"\n+error [36; 39): unnecessary visibility qualifier\n+error [56; 66): unnecessary visibility qualifier\n+error [86; 96): unnecessary visibility qualifier"}]}