{"sha": "cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDRmYTJhMjE3NmJiODFlM2Q3ZmE5ZTk5NTAzODA1ZDA4ZWViZjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-25T01:19:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-25T01:57:23Z"}, "message": "rustdoc: Add a pass that extracts brief docs from long docs\n\nIf the first paragraph of documentation is short then it will be used as the\nbrief description.", "tree": {"sha": "1ee7b3da18e156441210efcd2d514326fa7cf4f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee7b3da18e156441210efcd2d514326fa7cf4f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "html_url": "https://github.com/rust-lang/rust/commit/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d84b481de8eb5b75774fbaf78f893e35dcca4eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d84b481de8eb5b75774fbaf78f893e35dcca4eb", "html_url": "https://github.com/rust-lang/rust/commit/2d84b481de8eb5b75774fbaf78f893e35dcca4eb"}], "stats": {"total": 221, "additions": 221, "deletions": 0}, "files": [{"sha": "c2412e5b702a2fdd56f9dc05255b606942022e85", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "patch": "@@ -0,0 +1,219 @@\n+#[doc = \"\n+\n+Pulls a brief description out of a long description.\n+\n+If the first paragraph of a long description is short enough then it\n+is interpreted as the brief description.\n+\n+\"];\n+\n+export mk_pass;\n+\n+fn mk_pass() -> pass {\n+    run\n+}\n+\n+fn run(\n+    _srv: astsrv::srv,\n+    doc: doc::cratedoc\n+) -> doc::cratedoc {\n+    let fold = fold::fold({\n+        fold_mod: fold_mod,\n+        fold_const: fold_const,\n+        fold_fn: fold_fn\n+        with *fold::default_seq_fold(())\n+    });\n+    fold.fold_crate(fold, doc)\n+}\n+\n+fn fold_mod(fold: fold::fold<()>, doc: doc::moddoc) -> doc::moddoc {\n+    let doc = fold::default_seq_fold_mod(fold, doc);\n+    let (brief, desc) = modify(doc.brief, doc.desc);\n+\n+    ~{\n+        brief: brief,\n+        desc: desc\n+        with *doc\n+    }\n+}\n+\n+fn fold_const(fold: fold::fold<()>, doc: doc::constdoc) -> doc::constdoc {\n+    let doc = fold::default_seq_fold_const(fold, doc);\n+    let (brief, desc) = modify(doc.brief, doc.desc);\n+\n+    ~{\n+        brief: brief,\n+        desc: desc\n+        with *doc\n+    }\n+}\n+\n+fn fold_fn(fold: fold::fold<()>, doc: doc::fndoc) -> doc::fndoc {\n+    let doc = fold::default_seq_fold_fn(fold, doc);\n+    let (brief, desc) = modify(doc.brief, doc.desc);\n+\n+    ~{\n+        brief: brief,\n+        desc: desc\n+        with *doc\n+    }\n+}\n+\n+#[test]\n+fn should_promote_mod_desc() {\n+    let source = \"#[doc(desc = \\\"desc\\\")] mod m { }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = attr_pass::mk_pass()(srv, doc);\n+    let doc = run(srv, doc);\n+    assert doc.topmod.mods[0].brief == some(\"desc\");\n+    assert doc.topmod.mods[0].desc == none;\n+}\n+\n+#[test]\n+fn should_promote_const_desc() {\n+    let source = \"#[doc(desc = \\\"desc\\\")] const a: bool = true;\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = attr_pass::mk_pass()(srv, doc);\n+    let doc = run(srv, doc);\n+    assert doc.topmod.consts[0].brief == some(\"desc\");\n+    assert doc.topmod.consts[0].desc == none;\n+}\n+\n+#[test]\n+fn should_promote_fn_desc() {\n+    let source = \"#[doc(desc = \\\"desc\\\")] fn a() { }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = attr_pass::mk_pass()(srv, doc);\n+    let doc = run(srv, doc);\n+    assert doc.topmod.fns[0].brief == some(\"desc\");\n+    assert doc.topmod.fns[0].desc == none;\n+}\n+\n+fn modify(\n+    brief: option<str>,\n+    desc: option<str>\n+) -> (option<str>, option<str>) {\n+\n+    if option::is_some(brief) || option::is_none(desc) {\n+        ret (brief, desc);\n+    }\n+\n+    parse_desc(option::get(desc))\n+}\n+\n+fn parse_desc(desc: str) -> (option<str>, option<str>) {\n+\n+    const max_brief_len: uint = 120u;\n+\n+    let paras = paragraphs(desc);\n+\n+    if check vec::is_not_empty(paras) {\n+        let maybe_brief = vec::head(paras);\n+        if str::char_len(maybe_brief) <= max_brief_len {\n+            let desc_paras = vec::tail(paras);\n+            let desc = if vec::is_not_empty(desc_paras) {\n+                some(str::connect(desc_paras, \"\\n\\n\"))\n+            } else {\n+                none\n+            };\n+            (some(maybe_brief), desc)\n+        } else {\n+            (none, some(desc))\n+        }\n+    } else {\n+        (none, none)\n+    }\n+}\n+\n+fn paragraphs(s: str) -> [str] {\n+    let lines = str::lines_any(s);\n+    let whitespace_lines = 0;\n+    let accum = \"\";\n+    let paras = vec::foldl([], lines) {|paras, line|\n+        let res = paras;\n+\n+        if str::is_whitespace(line) {\n+            whitespace_lines += 1;\n+        } else {\n+            if whitespace_lines > 0 {\n+                if str::is_not_empty(accum) {\n+                    res += [accum];\n+                    accum = \"\";\n+                }\n+            }\n+\n+            whitespace_lines = 0;\n+\n+            accum = if str::is_empty(accum) {\n+                line\n+            } else {\n+                accum + \"\\n\" + line\n+            }\n+        }\n+\n+        res\n+    };\n+\n+    if str::is_not_empty(accum) {\n+        paras + [accum]\n+    } else {\n+        paras\n+    }\n+}\n+\n+#[test]\n+fn test_paragraphs_1() {\n+    let paras = paragraphs(\"1\\n\\n2\");\n+    assert paras == [\"1\", \"2\"];\n+}\n+\n+#[test]\n+fn test_paragraphs_2() {\n+    let paras = paragraphs(\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n+    assert paras == [\"1\\n1\", \"2\"];\n+}\n+\n+#[test]\n+fn should_promote_short_descs() {\n+    let brief = none;\n+    let desc = some(\"desc\");\n+    let (newbrief, newdesc) = modify(brief, desc);\n+    assert newbrief == desc;\n+    assert newdesc == none;\n+}\n+\n+#[test]\n+fn should_not_promote_long_descs() {\n+    let brief = none;\n+    let desc = some(\"Warkworth Castle is a ruined medieval building\n+in the town of the same name in the English county of Northumberland.\n+The town and castle occupy a loop of the River Coquet, less than a mile\n+from England's north-east coast. When the castle was founded is uncertain,\n+but traditionally its construction has been ascribed to Prince Henry of\n+Scotland in the mid 12th century, although it may have been built by\n+King Henry II of England when he took control of England'snorthern\n+counties.\");\n+    let (newbrief, _) = modify(brief, desc);\n+    assert newbrief == none;\n+}\n+\n+#[test]\n+fn should_not_promote_descs_over_brief() {\n+    let brief = some(\"brief\");\n+    let desc = some(\"desc\");\n+    let (newbrief, newdesc) = modify(brief, desc);\n+    assert newbrief == brief;\n+    assert newdesc == desc;\n+}\n+\n+#[test]\n+fn should_extract_brief_from_desc() {\n+    let brief = none;\n+    let desc = some(\"brief\\n\\ndesc\");\n+    let (newbrief, newdesc) = modify(brief, desc);\n+    assert newbrief == some(\"brief\");\n+    assert newdesc == some(\"desc\");\n+}"}, {"sha": "4586a02379bbe54014b44f9c17a92b59c1d9a634", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "patch": "@@ -23,4 +23,5 @@ mod attr_pass;\n mod tystr_pass;\n mod prune_undoc_pass;\n mod prune_unexported_pass;\n+mod desc_to_brief_pass;\n mod astsrv;"}, {"sha": "46959b961738e93628bab86051e4687411141934", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb44fa2a2176bb81e3d7fa9e99503805d08eebf2/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=cb44fa2a2176bb81e3d7fa9e99503805d08eebf2", "patch": "@@ -100,6 +100,7 @@ fn run(source_file: str) {\n         attr_pass::mk_pass(),\n         // FIXME: This pass should be optional\n         prune_undoc_pass::mk_pass(),\n+        desc_to_brief_pass::mk_pass(),\n         gen::mk_pass {|| std::io:: stdout()}\n     ]);\n }\n\\ No newline at end of file"}]}