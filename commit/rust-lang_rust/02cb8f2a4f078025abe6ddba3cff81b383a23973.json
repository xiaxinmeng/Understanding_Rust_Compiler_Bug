{"sha": "02cb8f2a4f078025abe6ddba3cff81b383a23973", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyY2I4ZjJhNGYwNzgwMjVhYmU2ZGRiYTNjZmY4MWIzODNhMjM5NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T20:08:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T20:08:16Z"}, "message": "Auto merge of #53564 - MaloJaffre:vecdeque, r=gnzlbg\n\nReoptimize VecDeque::append\n\n~Unfortunately, I don't know if these changes fix the unsoundness mentioned in #53529, so it is stil a WIP.\nThis is also completely untested.\nThe VecDeque code contains other unsound code: one example : [reading unitialized memory](https://play.rust-lang.org/?gist=6ff47551769af61fd8adc45c44010887&version=nightly&mode=release&edition=2015) (detected by MIRI), so I think this code will need a bigger refactor to make it clearer and safer.~\n\nNote: this is based on #53571.\nr? @SimonSapin\nCc: #53529 #52553 @YorickPeterse @jonas-schievink @Pazzaz @shepmaster.", "tree": {"sha": "0e4a68f530d61edb08281b1275034666089c11ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e4a68f530d61edb08281b1275034666089c11ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02cb8f2a4f078025abe6ddba3cff81b383a23973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02cb8f2a4f078025abe6ddba3cff81b383a23973", "html_url": "https://github.com/rust-lang/rust/commit/02cb8f2a4f078025abe6ddba3cff81b383a23973", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02cb8f2a4f078025abe6ddba3cff81b383a23973/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6b35b0e1115f008796e8313574e4a4739b6d39d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6b35b0e1115f008796e8313574e4a4739b6d39d", "html_url": "https://github.com/rust-lang/rust/commit/e6b35b0e1115f008796e8313574e4a4739b6d39d"}, {"sha": "21d2a6c9868541ec9829ced9a5bae936b18741c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d2a6c9868541ec9829ced9a5bae936b18741c5", "html_url": "https://github.com/rust-lang/rust/commit/21d2a6c9868541ec9829ced9a5bae936b18741c5"}], "stats": {"total": 52, "additions": 47, "deletions": 5}, "files": [{"sha": "c53549ab85d6d5aa075e9f0e168f0d4e512ae206", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/02cb8f2a4f078025abe6ddba3cff81b383a23973/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02cb8f2a4f078025abe6ddba3cff81b383a23973/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=02cb8f2a4f078025abe6ddba3cff81b383a23973", "patch": "@@ -19,6 +19,7 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n+use core::isize;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n@@ -202,6 +203,33 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n+    /// Copies all values from `src` to the back of `self`, wrapping around if needed.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The capacity must be sufficient to hold self.len() + src.len() elements.\n+    /// If so, this function never panics.\n+    #[inline]\n+    unsafe fn copy_slice(&mut self, src: &[T]) {\n+        /// This is guaranteed by `RawVec`.\n+        debug_assert!(self.capacity() <= isize::MAX as usize);\n+\n+        let expected_new_len = self.len() + src.len();\n+        debug_assert!(self.capacity() >= expected_new_len);\n+\n+        let dst_high_ptr = self.ptr().add(self.head);\n+        let dst_high_len = self.cap() - self.head;\n+\n+        let split = cmp::min(src.len(), dst_high_len);\n+        let (src_high, src_low) = src.split_at(split);\n+\n+        ptr::copy_nonoverlapping(src_high.as_ptr(), dst_high_ptr, src_high.len());\n+        ptr::copy_nonoverlapping(src_low.as_ptr(), self.ptr(), src_low.len());\n+\n+        self.head = self.wrap_add(self.head, src.len());\n+        debug_assert!(self.len() == expected_new_len);\n+    }\n+\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1024,7 +1052,7 @@ impl<T> VecDeque<T> {\n             iter: Iter {\n                 tail: drain_tail,\n                 head: drain_head,\n-                ring: unsafe { self.buffer_as_mut_slice() },\n+                ring: unsafe { self.buffer_as_slice() },\n             },\n         }\n     }\n@@ -1834,8 +1862,22 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // naive impl\n-        self.extend(other.drain(..));\n+        unsafe {\n+            // Guarantees there is space in `self` for `other`.\n+            self.reserve(other.len());\n+\n+            {\n+                let (src_high, src_low) = other.as_slices();\n+\n+                // This is only safe because copy_slice never panics when capacity is sufficient.\n+                self.copy_slice(src_low);\n+                self.copy_slice(src_high);\n+            }\n+\n+            // Some values now exist in both `other` and `self` but are made inaccessible\n+            // in`other`.\n+            other.tail = other.head;\n+        }\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -2593,8 +2635,8 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n                         let mut right_offset = 0;\n                         for i in left_edge..right_edge {\n                             right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n+                            let src = right_edge + right_offset;\n+                            ptr::swap(buf.add(i), buf.add(src));\n                         }\n                         let n_ops = right_edge - left_edge;\n                         left_edge += n_ops;"}]}