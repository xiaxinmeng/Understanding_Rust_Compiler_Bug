{"sha": "163a7090b8c774785c8daea0e95e70e60ccfc6d0", "node_id": "C_kwDOAAsO6NoAKDE2M2E3MDkwYjhjNzc0Nzg1YzhkYWVhMGU5NWU3MGU2MGNjZmM2ZDA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-16T14:39:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-16T14:39:46Z"}, "message": "Rollup merge of #104394 - oli-obk:suggest_method_call, r=lcnr\n\nvarious cleanups to try to reduce the use of spans inside method resolution\n\ndefinitely review commit by commit.", "tree": {"sha": "82b104920a2afe60b8a62919308fd816c9f81a04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82b104920a2afe60b8a62919308fd816c9f81a04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/163a7090b8c774785c8daea0e95e70e60ccfc6d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjdPYyCRBK7hj4Ov3rIwAAwxIIAFCDakqywhhlxL9msKSgQuMl\nTdoUcAbnK0LheHZH4+vXNU51QbkGg2RGYA/II+0L150eupFagiTISM0brjmZcp8T\nOGEFeFCNAInIbtW+SMWIMmJszbfubNUMNaKgTeocI7mU+6uwvKyR7FmbXsnPZuaH\nGsKjhdBDS3Tgy9j8r9CEfONhc0A5qI/4UNrUGCJ61R/VFaitpg4+SvVLaAmA+UOU\nUmQRhBbgKeKuaW+98neLas3tW+QmY+Rx7zUuXJyZfiYaFHvCxv7ahL59ELo+RJtn\nvmmjFmBxXrE0+r82dYkYoEB6qcv7hLe5QWzMPp1IGve6gaNpDcRrGS5jHvQamag=\n=ltON\n-----END PGP SIGNATURE-----\n", "payload": "tree 82b104920a2afe60b8a62919308fd816c9f81a04\nparent e033a389e1b375e45799398c2c58ece1e23bbb3b\nparent e2fbd01ac3305fd9bfb5ee4f76c42f06df4e1f10\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668609586 +0100\ncommitter GitHub <noreply@github.com> 1668609586 +0100\n\nRollup merge of #104394 - oli-obk:suggest_method_call, r=lcnr\n\nvarious cleanups to try to reduce the use of spans inside method resolution\n\ndefinitely review commit by commit.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/163a7090b8c774785c8daea0e95e70e60ccfc6d0", "html_url": "https://github.com/rust-lang/rust/commit/163a7090b8c774785c8daea0e95e70e60ccfc6d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/163a7090b8c774785c8daea0e95e70e60ccfc6d0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e033a389e1b375e45799398c2c58ece1e23bbb3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e033a389e1b375e45799398c2c58ece1e23bbb3b", "html_url": "https://github.com/rust-lang/rust/commit/e033a389e1b375e45799398c2c58ece1e23bbb3b"}, {"sha": "e2fbd01ac3305fd9bfb5ee4f76c42f06df4e1f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2fbd01ac3305fd9bfb5ee4f76c42f06df4e1f10", "html_url": "https://github.com/rust-lang/rust/commit/e2fbd01ac3305fd9bfb5ee4f76c42f06df4e1f10"}], "stats": {"total": 249, "additions": 126, "deletions": 123}, "files": [{"sha": "ed2218b8746ee9bdd8f898d20ca4cbf3c9742303", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=163a7090b8c774785c8daea0e95e70e60ccfc6d0", "patch": "@@ -504,7 +504,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // method lookup.\n             let Ok(pick) = self\n             .probe_for_name(\n-                call_expr.span,\n                 Mode::MethodCall,\n                 segment.ident,\n                 IsSuggestion(true),"}, {"sha": "3f390cba3e7c2b927ba393893142babc13f742ec", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=163a7090b8c774785c8daea0e95e70e60ccfc6d0", "patch": "@@ -93,17 +93,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr_id: hir::HirId,\n         allow_private: bool,\n     ) -> bool {\n-        let mode = probe::Mode::MethodCall;\n         match self.probe_for_name(\n-            method_name.span,\n-            mode,\n+            probe::Mode::MethodCall,\n             method_name,\n             IsSuggestion(false),\n             self_ty,\n             call_expr_id,\n             ProbeScope::TraitsInScope,\n         ) {\n-            Ok(..) => true,\n+            Ok(pick) => {\n+                pick.maybe_emit_unstable_name_collision_hint(\n+                    self.tcx,\n+                    method_name.span,\n+                    call_expr_id,\n+                );\n+                true\n+            }\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n@@ -125,10 +130,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let params = self\n             .probe_for_name(\n-                method_name.span,\n                 probe::Mode::MethodCall,\n                 method_name,\n-                IsSuggestion(false),\n+                IsSuggestion(true),\n                 self_ty,\n                 call_expr.hir_id,\n                 ProbeScope::TraitsInScope,\n@@ -175,7 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         let pick =\n-            self.lookup_probe(span, segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n+            self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n \n         self.lint_dot_call_from_2018(self_ty, segment, span, call_expr, self_expr, &pick, args);\n \n@@ -200,42 +204,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .mk_ref(*region, ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() });\n                 // We probe again to see if there might be a borrow mutability discrepancy.\n                 match self.lookup_probe(\n-                    span,\n                     segment.ident,\n                     trait_type,\n                     call_expr,\n                     ProbeScope::TraitsInScope,\n                 ) {\n-                    Ok(ref new_pick) if *new_pick != pick => {\n+                    Ok(ref new_pick) if pick.differs_from(new_pick) => {\n                         needs_mut = true;\n                     }\n                     _ => {}\n                 }\n             }\n \n             // We probe again, taking all traits into account (not only those in scope).\n-            let mut candidates = match self.lookup_probe(\n-                span,\n-                segment.ident,\n-                self_ty,\n-                call_expr,\n-                ProbeScope::AllTraits,\n-            ) {\n-                // If we find a different result the caller probably forgot to import a trait.\n-                Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container_id(self.tcx)],\n-                Err(Ambiguity(ref sources)) => sources\n-                    .iter()\n-                    .filter_map(|source| {\n-                        match *source {\n-                            // Note: this cannot come from an inherent impl,\n-                            // because the first probing succeeded.\n-                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n-                            CandidateSource::Trait(_) => None,\n-                        }\n-                    })\n-                    .collect(),\n-                _ => Vec::new(),\n-            };\n+            let mut candidates =\n+                match self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::AllTraits) {\n+                    // If we find a different result the caller probably forgot to import a trait.\n+                    Ok(ref new_pick) if pick.differs_from(new_pick) => {\n+                        vec![new_pick.item.container_id(self.tcx)]\n+                    }\n+                    Err(Ambiguity(ref sources)) => sources\n+                        .iter()\n+                        .filter_map(|source| {\n+                            match *source {\n+                                // Note: this cannot come from an inherent impl,\n+                                // because the first probing succeeded.\n+                                CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                                CandidateSource::Trait(_) => None,\n+                            }\n+                        })\n+                        .collect(),\n+                    _ => Vec::new(),\n+                };\n             candidates.retain(|candidate| *candidate != self.tcx.parent(result.callee.def_id));\n \n             return Err(IllegalSizedBound(candidates, needs_mut, span));\n@@ -247,23 +247,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self, call_expr))]\n     pub fn lookup_probe(\n         &self,\n-        span: Span,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n-        let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_vars_if_possible(self_ty);\n-        self.probe_for_name(\n-            span,\n-            mode,\n+        let pick = self.probe_for_name(\n+            probe::Mode::MethodCall,\n             method_name,\n             IsSuggestion(false),\n             self_ty,\n             call_expr.hir_id,\n             scope,\n-        )\n+        )?;\n+        pick.maybe_emit_unstable_name_collision_hint(self.tcx, method_name.span, call_expr.hir_id);\n+        Ok(pick)\n     }\n \n     pub(super) fn obligation_for_method(\n@@ -587,7 +585,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let pick = self.probe_for_name(\n-            span,\n             probe::Mode::Path,\n             method_name,\n             IsSuggestion(false),\n@@ -596,6 +593,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ProbeScope::TraitsInScope,\n         )?;\n \n+        pick.maybe_emit_unstable_name_collision_hint(self.tcx, span, expr_id);\n+\n         self.lint_fully_qualified_call_from_2018(\n             span,\n             method_name,"}, {"sha": "46a760851893dd5cbe8697b1fb8b2b81717a4027", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 78, "deletions": 59, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=163a7090b8c774785c8daea0e95e70e60ccfc6d0", "patch": "@@ -17,6 +17,7 @@ use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n+use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ParamEnvAnd, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n@@ -83,8 +84,6 @@ struct ProbeContext<'a, 'tcx> {\n     unsatisfied_predicates:\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n \n-    is_suggestion: IsSuggestion,\n-\n     scope_expr_id: hir::HirId,\n }\n \n@@ -193,7 +192,7 @@ impl AutorefOrPtrAdjustment {\n     }\n }\n \n-#[derive(Debug, PartialEq, Clone)]\n+#[derive(Debug, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssocItem,\n     pub kind: PickKind<'tcx>,\n@@ -209,6 +208,9 @@ pub struct Pick<'tcx> {\n     /// `*mut T`, convert it to `*const T`.\n     pub autoref_or_ptr_adjustment: Option<AutorefOrPtrAdjustment>,\n     pub self_ty: Ty<'tcx>,\n+\n+    /// Unstable candidates alongside the stable ones.\n+    unstable_candidates: Vec<(Candidate<'tcx>, Symbol)>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -298,7 +300,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub fn probe_for_name(\n         &self,\n-        span: Span,\n         mode: Mode,\n         item_name: Ident,\n         is_suggestion: IsSuggestion,\n@@ -307,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         scope: ProbeScope,\n     ) -> PickResult<'tcx> {\n         self.probe_op(\n-            span,\n+            item_name.span,\n             mode,\n             Some(item_name),\n             None,\n@@ -446,7 +447,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return_type,\n                 orig_values,\n                 steps.steps,\n-                is_suggestion,\n                 scope_expr_id,\n             );\n \n@@ -541,7 +541,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         return_type: Option<Ty<'tcx>>,\n         orig_steps_var_values: OriginalQueryValues<'tcx>,\n         steps: &'tcx [CandidateStep<'tcx>],\n-        is_suggestion: IsSuggestion,\n         scope_expr_id: hir::HirId,\n     ) -> ProbeContext<'a, 'tcx> {\n         ProbeContext {\n@@ -559,7 +558,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             allow_similar_names: false,\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n-            is_suggestion,\n             scope_expr_id,\n         }\n     }\n@@ -881,7 +879,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn matches_return_type(\n+    fn matches_return_type(\n         &self,\n         method: &ty::AssocItem,\n         self_ty: Option<Ty<'tcx>>,\n@@ -1052,26 +1050,17 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n-        let mut unstable_candidates = Vec::new();\n-        let pick = self.pick_all_method(Some(&mut unstable_candidates));\n+        let pick = self.pick_all_method(Some(&mut vec![]));\n \n         // In this case unstable picking is done by `pick_method`.\n         if !self.tcx.sess.opts.unstable_opts.pick_stable_methods_before_any_unstable {\n             return pick;\n         }\n \n-        match pick {\n-            // Emit a lint if there are unstable candidates alongside the stable ones.\n-            //\n-            // We suppress warning if we're picking the method only because it is a\n-            // suggestion.\n-            Some(Ok(ref p)) if !self.is_suggestion.0 && !unstable_candidates.is_empty() => {\n-                self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n-                pick\n-            }\n-            Some(_) => pick,\n-            None => self.pick_all_method(None),\n+        if pick.is_none() {\n+            return self.pick_all_method(None);\n         }\n+        pick\n     }\n \n     fn pick_all_method(\n@@ -1216,7 +1205,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n-        let mut unstable_candidates = Vec::new();\n \n         for (kind, candidates) in\n             &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n@@ -1226,26 +1214,17 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self_ty,\n                 candidates.iter(),\n                 &mut possibly_unsatisfied_predicates,\n-                Some(&mut unstable_candidates),\n+                Some(&mut vec![]),\n             );\n-            if let Some(pick) = res {\n-                if !self.is_suggestion.0 && !unstable_candidates.is_empty() {\n-                    if let Ok(p) = &pick {\n-                        // Emit a lint if there are unstable candidates alongside the stable ones.\n-                        //\n-                        // We suppress warning if we're picking the method only because it is a\n-                        // suggestion.\n-                        self.emit_unstable_name_collision_hint(p, &unstable_candidates);\n-                    }\n-                }\n-                return Some(pick);\n+            if res.is_some() {\n+                return res;\n             }\n         }\n \n         debug!(\"searching unstable candidates\");\n         let res = self.consider_candidates(\n             self_ty,\n-            unstable_candidates.iter().map(|(c, _)| c),\n+            self.inherent_candidates.iter().chain(&self.extension_candidates),\n             &mut possibly_unsatisfied_predicates,\n             None,\n         );\n@@ -1300,7 +1279,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             Option<ty::Predicate<'tcx>>,\n             Option<ObligationCause<'tcx>>,\n         )>,\n-        unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n+        mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>>\n     where\n         ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n@@ -1324,7 +1303,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n         }\n \n-        if let Some(uc) = unstable_candidates {\n+        if let Some(uc) = &mut unstable_candidates {\n             applicable_candidates.retain(|&(p, _)| {\n                 if let stability::EvalResult::Deny { feature, .. } =\n                     self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n@@ -1343,30 +1322,63 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         applicable_candidates.pop().map(|(probe, status)| {\n             if status == ProbeResult::Match {\n-                Ok(probe.to_unadjusted_pick(self_ty))\n+                Ok(probe\n+                    .to_unadjusted_pick(self_ty, unstable_candidates.cloned().unwrap_or_default()))\n             } else {\n                 Err(MethodError::BadReturnType)\n             }\n         })\n     }\n+}\n+\n+impl<'tcx> Pick<'tcx> {\n+    /// In case there were unstable name collisions, emit them as a lint.\n+    /// Checks whether two picks do not refer to the same trait item for the same `Self` type.\n+    /// Only useful for comparisons of picks in order to improve diagnostics.\n+    /// Do not use for type checking.\n+    pub fn differs_from(&self, other: &Self) -> bool {\n+        let Self {\n+            item:\n+                AssocItem {\n+                    def_id,\n+                    name: _,\n+                    kind: _,\n+                    container: _,\n+                    trait_item_def_id: _,\n+                    fn_has_self_parameter: _,\n+                },\n+            kind: _,\n+            import_ids: _,\n+            autoderefs: _,\n+            autoref_or_ptr_adjustment: _,\n+            self_ty,\n+            unstable_candidates: _,\n+        } = *self;\n+        self_ty != other.self_ty || def_id != other.item.def_id\n+    }\n \n-    fn emit_unstable_name_collision_hint(\n+    /// In case there were unstable name collisions, emit them as a lint.\n+    pub fn maybe_emit_unstable_name_collision_hint(\n         &self,\n-        stable_pick: &Pick<'_>,\n-        unstable_candidates: &[(Candidate<'tcx>, Symbol)],\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        scope_expr_id: hir::HirId,\n     ) {\n-        let def_kind = stable_pick.item.kind.as_def_kind();\n-        self.tcx.struct_span_lint_hir(\n+        if self.unstable_candidates.is_empty() {\n+            return;\n+        }\n+        let def_kind = self.item.kind.as_def_kind();\n+        tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n-            self.scope_expr_id,\n-            self.span,\n+            scope_expr_id,\n+            span,\n             format!(\n                 \"{} {} with this name may be added to the standard library in the future\",\n                 def_kind.article(),\n-                def_kind.descr(stable_pick.item.def_id),\n+                def_kind.descr(self.item.def_id),\n             ),\n             |lint| {\n-                match (stable_pick.item.kind, stable_pick.item.container) {\n+                match (self.item.kind, self.item.container) {\n                     (ty::AssocKind::Fn, _) => {\n                         // FIXME: This should be a `span_suggestion` instead of `help`\n                         // However `self.span` only\n@@ -1375,31 +1387,31 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         lint.help(&format!(\n                             \"call with fully qualified syntax `{}(...)` to keep using the current \\\n                              method\",\n-                            self.tcx.def_path_str(stable_pick.item.def_id),\n+                            tcx.def_path_str(self.item.def_id),\n                         ));\n                     }\n                     (ty::AssocKind::Const, ty::AssocItemContainer::TraitContainer) => {\n-                        let def_id = stable_pick.item.container_id(self.tcx);\n+                        let def_id = self.item.container_id(tcx);\n                         lint.span_suggestion(\n-                            self.span,\n+                            span,\n                             \"use the fully qualified path to the associated const\",\n                             format!(\n                                 \"<{} as {}>::{}\",\n-                                stable_pick.self_ty,\n-                                self.tcx.def_path_str(def_id),\n-                                stable_pick.item.name\n+                                self.self_ty,\n+                                tcx.def_path_str(def_id),\n+                                self.item.name\n                             ),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                     _ => {}\n                 }\n-                if self.tcx.sess.is_nightly_build() {\n-                    for (candidate, feature) in unstable_candidates {\n+                if tcx.sess.is_nightly_build() {\n+                    for (candidate, feature) in &self.unstable_candidates {\n                         lint.help(&format!(\n                             \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n                             feature,\n-                            self.tcx.def_path_str(candidate.item.def_id),\n+                            tcx.def_path_str(candidate.item.def_id),\n                         ));\n                     }\n                 }\n@@ -1408,7 +1420,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             },\n         );\n     }\n+}\n \n+impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn select_trait_candidate(\n         &self,\n         trait_ref: ty::TraitRef<'tcx>,\n@@ -1667,6 +1681,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             autoderefs: 0,\n             autoref_or_ptr_adjustment: None,\n             self_ty,\n+            unstable_candidates: vec![],\n         })\n     }\n \n@@ -1686,7 +1701,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.return_type,\n                 self.orig_steps_var_values.clone(),\n                 steps,\n-                IsSuggestion(true),\n                 self.scope_expr_id,\n             );\n             pcx.allow_similar_names = true;\n@@ -1894,7 +1908,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n }\n \n impl<'tcx> Candidate<'tcx> {\n-    fn to_unadjusted_pick(&self, self_ty: Ty<'tcx>) -> Pick<'tcx> {\n+    fn to_unadjusted_pick(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        unstable_candidates: Vec<(Candidate<'tcx>, Symbol)>,\n+    ) -> Pick<'tcx> {\n         Pick {\n             item: self.item,\n             kind: match self.kind {\n@@ -1919,6 +1937,7 @@ impl<'tcx> Candidate<'tcx> {\n             autoderefs: 0,\n             autoref_or_ptr_adjustment: None,\n             self_ty,\n+            unstable_candidates,\n         }\n     }\n }"}, {"sha": "19f56c738239ba6b64e2881ff817daefaf0fbab7", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163a7090b8c774785c8daea0e95e70e60ccfc6d0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=163a7090b8c774785c8daea0e95e70e60ccfc6d0", "patch": "@@ -376,7 +376,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .hir()\n                             .expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n                         let probe = self.lookup_probe(\n-                            span,\n                             item_name,\n                             output_ty,\n                             call_expr,\n@@ -914,7 +913,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                self.check_for_inner_self(&mut err, source, span, rcvr_ty, item_name);\n+                self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1321,7 +1320,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.bound_type_of(range_def_id).subst(self.tcx, &[actual.into()]);\n \n                     let pick = self.probe_for_name(\n-                        span,\n                         Mode::MethodCall,\n                         item_name,\n                         IsSuggestion(true),\n@@ -1500,7 +1498,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         &|_, field_ty| {\n                             self.lookup_probe(\n-                                span,\n                                 item_name,\n                                 field_ty,\n                                 call_expr,\n@@ -1548,7 +1545,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n-        span: Span,\n         actual: Ty<'tcx>,\n         item_name: Ident,\n     ) {\n@@ -1571,15 +1567,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             return None;\n                         }\n \n-                        self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            field_ty,\n-                            call_expr,\n-                            ProbeScope::TraitsInScope,\n-                        )\n-                        .ok()\n-                        .map(|pick| (variant, field, pick))\n+                        self.lookup_probe(item_name, field_ty, call_expr, ProbeScope::TraitsInScope)\n+                            .ok()\n+                            .map(|pick| (variant, field, pick))\n                     })\n                     .collect();\n \n@@ -1644,12 +1634,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let [first] = ***substs else { return; };\n                 let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n                 let Ok(pick) = self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            ty,\n-                            call_expr,\n-                            ProbeScope::TraitsInScope,\n-                        )  else { return; };\n+                    item_name,\n+                    ty,\n+                    call_expr,\n+                    ProbeScope::TraitsInScope,\n+                )  else { return; };\n \n                 let name = self.ty_to_value_string(actual);\n                 let inner_id = kind.did();\n@@ -1899,7 +1888,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let SelfSource::QPath(ty) = self_source else { return; };\n         for (deref_ty, _) in self.autoderef(rustc_span::DUMMY_SP, rcvr_ty).skip(1) {\n             if let Ok(pick) = self.probe_for_name(\n-                ty.span,\n                 Mode::Path,\n                 item_name,\n                 IsSuggestion(true),\n@@ -2107,7 +2095,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(span, item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n+                match self.lookup_probe(item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -2141,7 +2129,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty\n                         && let Ok(pick) = self.lookup_probe(\n-                            span,\n                             item_name,\n                             new_rcvr_t,\n                             rcvr,\n@@ -2522,7 +2509,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span: method_name.span,\n             };\n             let probe = self.lookup_probe(\n-                expr.span,\n                 new_name,\n                 self_ty,\n                 self_expr,"}]}