{"sha": "4f792f2dbb40ae069b2625425fab58009e19ac74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNzkyZjJkYmI0MGFlMDY5YjI2MjU0MjVmYWI1ODAwOWUxOWFjNzQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-26T23:02:25Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-27T01:14:32Z"}, "message": "Track spans for each local variable in typestate\n\nThis lets us print better messages in situations with name\nshadowing.", "tree": {"sha": "a49ae4549675c7db53cc7afd8321bd6f017c9566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a49ae4549675c7db53cc7afd8321bd6f017c9566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f792f2dbb40ae069b2625425fab58009e19ac74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f792f2dbb40ae069b2625425fab58009e19ac74", "html_url": "https://github.com/rust-lang/rust/commit/4f792f2dbb40ae069b2625425fab58009e19ac74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f792f2dbb40ae069b2625425fab58009e19ac74/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "250643c54926234a5ce5908d3c492d7edae2b5a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/250643c54926234a5ce5908d3c492d7edae2b5a2", "html_url": "https://github.com/rust-lang/rust/commit/250643c54926234a5ce5908d3c492d7edae2b5a2"}], "stats": {"total": 289, "additions": 186, "deletions": 103}, "files": [{"sha": "cd820ba28857769e1f551a30242aaee80936e946", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -91,14 +91,15 @@ fn collect_ids_decl(&@decl d, @vec[uint] res) -> () {\n     }\n }\n \n-fn node_ids_in_fn(&_fn f, &ident i, &def_id d, &ann a, @vec[uint] res) -> () {\n+fn node_ids_in_fn(&_fn f, &span sp, &ident i, &def_id d, &ann a,\n+                  @vec[uint] res) -> () {\n     auto collect_ids = walk::default_visitor();\n     collect_ids = rec(visit_expr_pre  = bind collect_ids_expr(_,res),\n                       visit_block_pre = bind collect_ids_block(_,res),\n                       visit_stmt_pre  = bind collect_ids_stmt(_,res),\n                       visit_decl_pre  = bind collect_ids_decl(_,res)\n                       with collect_ids);\n-    walk::walk_fn(collect_ids, f, i, d, a);\n+    walk::walk_fn(collect_ids, f, sp, i, d, a);\n }\n \n fn init_vecs(&crate_ctxt ccx, @vec[uint] node_ids, uint len) -> () {\n@@ -108,23 +109,24 @@ fn init_vecs(&crate_ctxt ccx, @vec[uint] node_ids, uint len) -> () {\n     }\n }\n \n-fn visit_fn(&crate_ctxt ccx, uint num_locals, &_fn f, &ident i,\n-            &def_id d, &ann a) -> () {\n+fn visit_fn(&crate_ctxt ccx, uint num_locals, &_fn f,\n+            &span sp, &ident i, &def_id d, &ann a) -> () {\n     let vec[uint] node_ids_ = [];\n     let @vec[uint] node_ids = @node_ids_;\n-    node_ids_in_fn(f, i, d, a, node_ids);\n+    node_ids_in_fn(f, sp, i, d, a, node_ids);\n     init_vecs(ccx, node_ids, num_locals);\n }\n \n-fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &ident i, &def_id f_id, &ann a)\n+fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i,\n+                  &def_id f_id, &ann a)\n     -> () {\n     auto f_info = get_fn_info(ccx, f_id);\n-    visit_fn(ccx, num_locals(f_info), f, i, f_id, a);\n+    visit_fn(ccx, num_locals(f_info), f, sp, i, f_id, a);\n }\n \n fn annotate_crate(&crate_ctxt ccx, &crate crate) -> () {\n     auto do_ann = walk::default_visitor();\n-    do_ann = rec(visit_fn_pre = bind annotate_in_fn(ccx,_,_,_,_)\n+    do_ann = rec(visit_fn_pre = bind annotate_in_fn(ccx,_,_,_,_,_)\n                  with do_ann);\n     walk::walk_crate(do_ann, crate);\n }"}, {"sha": "01d07bfc212e85bbb12a709672ca350be7f00153", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -18,7 +18,6 @@ import front::ast::expr_path;\n import front::ast::ident;\n import front::ast::controlflow;\n import front::ast::ann;\n-import front::ast::ts_ann;\n import front::ast::stmt;\n import front::ast::expr;\n import front::ast::block;\n@@ -54,26 +53,60 @@ import tstate::ann::extend_prestate;\n import tstate::ann::extend_poststate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n+import tstate::ann::ts_ann;\n+\n+import util::common::istr;\n \n /* logging funs */\n \n-fn bitv_to_str(fn_info enclosing, bitv::t v) -> str {\n+fn def_id_to_str(def_id d) -> str {\n+   ret (istr(d._0) + \",\" + istr(d._1));\n+}\n+\n+fn bitv_to_str(fn_ctxt fcx, bitv::t v) -> str {\n   auto s = \"\";\n+  auto comma = false;\n \n-  for each (@tup(def_id, tup(uint, ident)) p in enclosing.vars.items()) {\n-    if (bitv::get(v, p._1._0)) {\n-      s += \" \" + p._1._1 + \" \";\n-    }\n+  for each (@tup(def_id, var_info) p in fcx.enclosing.vars.items()) {\n+      if (bitv::get(v, p._1.bit_num)) {\n+          s += (if (comma) { \", \" } else { comma = true; \"\" })\n+               + p._1.name + \" [\" + fcx.ccx.tcx.sess.span_str(p._1.sp) + \"]\";\n+      }\n   }\n   ret s;\n }\n \n-fn log_bitv(fn_info enclosing, bitv::t v) {\n-    log(bitv_to_str(enclosing, v));\n+fn log_bitv(fn_ctxt fcx, bitv::t v) {\n+    log(bitv_to_str(fcx, v));\n+}\n+\n+fn first_difference_string(&fn_ctxt fcx, &bitv::t expected,\n+                           &bitv::t actual) -> str {\n+    let str s = \"\";\n+    auto done = false;\n+    for each (@tup(def_id, var_info) p in fcx.enclosing.vars.items()) {\n+        if (!done) {\n+            if (bitv::get(expected, p._1.bit_num) &&\n+                !bitv::get(actual, p._1.bit_num)) {\n+                \n+            /*\n+              for fun, try either:\n+              * \"ret s\" after the assignment to s\n+              or\n+              * using break here\n+              */\n+            s = (p._1.name + \" [\"\n+                 + fcx.ccx.tcx.sess.span_str(p._1.sp) + \"]\");\n+            \n+            done = true;\n+            }\n+        }\n+    }\n+    ret s;\n }\n \n-fn log_bitv_err(fn_info enclosing, bitv::t v) {\n-    log_err(bitv_to_str(enclosing, v));\n+fn log_bitv_err(fn_ctxt fcx, bitv::t v) {\n+    log_err(bitv_to_str(fcx, v));\n }\n \n fn tos (vec[uint] v) -> str {\n@@ -152,8 +185,10 @@ fn print_idents(vec[ident] idents) -> () {\n /**********************************************************************/\n /* mapping from variable name (def_id is assumed to be for a local\n    variable in a given function) to bit number \n-   (also remembers the ident for error-logging purposes) */\n-type var_info     = tup(uint, ident);\n+   (also remembers the ident and span for error-logging purposes) */\n+type var_info     = rec(uint bit_num,\n+                        ident name,\n+                        span sp);\n type fn_info      = rec(@std::map::hashmap[def_id, var_info] vars,\n                         controlflow cf);\n "}, {"sha": "c3c79d68f579f626c4279a94120c4822c8440e40", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -33,7 +33,7 @@ import tstate::ann::clear_in_poststate;\n              \n fn bit_num(def_id v, fn_info m) -> uint {\n   assert (m.vars.contains_key(v));\n-  ret m.vars.get(v)._0;\n+  ret m.vars.get(v).bit_num;\n }\n \n fn promises(&poststate p, def_id v, fn_info m) -> bool {\n@@ -44,26 +44,26 @@ fn promises(&poststate p, def_id v, fn_info m) -> bool {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n+fn seq_preconds(fn_ctxt fcx, vec[pre_and_post] pps) -> precond {\n   let uint sz = len[pre_and_post](pps);\n-  let uint num_vars = num_locals(enclosing);\n+  let uint num_vars = num_locals(fcx.enclosing);\n \n   if (sz >= 1u) {\n     auto first = pps.(0);\n     assert (pps_len(first) == num_vars);\n-    let precond rest = seq_preconds(enclosing,\n+    let precond rest = seq_preconds(fcx,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n     auto res = clone(first.precondition);\n     union(res, rest);\n \n     log(\"seq_preconds:\");\n     log(\"first.postcondition =\");\n-    log_bitv(enclosing, first.postcondition);\n+    log_bitv(fcx, first.postcondition);\n     log(\"rest =\");\n-    log_bitv(enclosing, rest);\n+    log_bitv(fcx, rest);\n     log(\"returning\");\n-    log_bitv(enclosing, res);\n+    log_bitv(fcx, res);\n \n     ret res;\n   }\n@@ -118,14 +118,14 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n fn gen(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n   log \"gen\";\n   assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id))._0;\n+  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n   ret set_in_postcond(i, (ann_to_ts_ann(fcx.ccx, a)).conditions);\n }\n \n fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n    -> prestate {\n     assert (enclosing.vars.contains_key(id));\n-    let uint i = (enclosing.vars.get(id))._0;\n+    let uint i = (enclosing.vars.get(id)).bit_num;\n     auto res = clone(pre);\n     relax_prestate(i, res);\n     ret res;\n@@ -134,14 +134,14 @@ fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n fn gen_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n   log \"gen_poststate\";\n   assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id))._0;\n+  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n   ret set_in_poststate(i, (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n \n fn kill_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n   log \"kill_poststate\";\n   assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id))._0;\n+  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n   ret clear_in_poststate(i, (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n "}, {"sha": "1aa7b24b47f6ac9a70bb15c183bb88f8d352a121", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -53,6 +53,7 @@ import aux::stmt_to_ann;\n import aux::num_locals;\n import aux::fixed_point_states;\n import aux::bitv_to_str;\n+import aux::first_difference_string;\n \n import util::common::ty_to_str;\n import util::common::log_stmt_err;\n@@ -70,12 +71,14 @@ fn check_states_expr(&fn_ctxt fcx, @expr e) -> () {\n \n     if (!implies(pres, prec)) {\n         auto s = \"\";\n-        s += (\"Unsatisfied precondition constraint for expression:\\n\");\n+        auto diff = first_difference_string(fcx, prec, pres);\n+        s += (\"Unsatisfied precondition constraint (for example, \"\n+              + diff + \") for expression:\\n\");\n         s += util::common::expr_to_str(e);\n         s += (\"\\nPrecondition:\\n\");\n-        s += bitv_to_str(fcx.enclosing, prec);\n+        s += bitv_to_str(fcx, prec);\n         s += (\"\\nPrestate:\\n\");\n-        s += bitv_to_str(fcx.enclosing, pres);\n+        s += bitv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_err(e.span, s);\n     }\n }\n@@ -96,12 +99,14 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n \n     if (!implies(pres, prec)) {\n         auto ss = \"\";\n-        ss += (\"Unsatisfied precondition constraint for statement:\\n\");\n+        auto diff = first_difference_string(fcx, prec, pres);\n+        ss += (\"Unsatisfied precondition constraint (for example, \"\n+              + diff + \") for statement:\\n\");\n         ss += util::common::stmt_to_str(s);\n         ss += (\"\\nPrecondition:\\n\");\n-        ss += bitv_to_str(fcx.enclosing, prec);\n+        ss += bitv_to_str(fcx, prec);\n         ss += (\"\\nPrestate: \\n\");\n-        ss += bitv_to_str(fcx.enclosing, pres);\n+        ss += bitv_to_str(fcx, pres);\n         fcx.ccx.tcx.sess.span_err(s.span, ss);\n     }\n }\n@@ -162,7 +167,8 @@ fn check_fn_states(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     check_states_against_conditions(fcx, f, a);\n }\n \n-fn fn_states(&crate_ctxt ccx, &_fn f, &ident i, &def_id id, &ann a) -> () {\n+fn fn_states(&crate_ctxt ccx, &_fn f, &span sp, &ident i,\n+             &def_id id, &ann a) -> () {\n     /* Look up the var-to-bit-num map for this function */\n     assert (ccx.fm.contains_key(id));\n     auto f_info = ccx.fm.get(id);\n@@ -171,6 +177,8 @@ fn fn_states(&crate_ctxt ccx, &_fn f, &ident i, &def_id id, &ann a) -> () {\n     check_fn_states(fcx, f, a);\n }\n \n+\n+\n fn check_crate(ty::ctxt cx, @crate crate) -> () {\n     let crate_ctxt ccx = new_crate_ctxt(cx);\n \n@@ -182,14 +190,14 @@ fn check_crate(ty::ctxt cx, @crate crate) -> () {\n \n     /* Compute the pre and postcondition for every subexpression */\n     auto do_pre_post = walk::default_visitor();\n-    do_pre_post = rec(visit_fn_pre = bind fn_pre_post(ccx,_,_,_,_)\n+    do_pre_post = rec(visit_fn_pre = bind fn_pre_post(ccx,_,_,_,_,_)\n                       with do_pre_post);\n     walk::walk_crate(do_pre_post, *crate);\n     \n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n     auto do_states = walk::default_visitor();\n-    do_states = rec(visit_fn_pre = bind fn_states(ccx,_,_,_,_)\n+    do_states = rec(visit_fn_pre = bind fn_states(ccx,_,_,_,_,_)\n                     with do_states);\n     walk::walk_crate(do_states, *crate);\n }"}, {"sha": "0a8636a6044f3acb236c1a4bf8910c2acd339d2b", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -23,6 +23,7 @@ import front::ast::ident;\n import middle::walk::walk_crate;\n import middle::walk::walk_fn;\n import middle::walk::ast_visitor;\n+import front::ast::span;\n \n import aux::fn_info;\n import aux::var_info;\n@@ -31,39 +32,44 @@ import aux::crate_ctxt;\n import util::common::new_def_hash;\n import util::common::uistr;\n \n+type identifier = rec(ident name, def_id id, span sp);\n+\n fn var_is_local(def_id v, fn_info m) -> bool {\n   ret (m.vars.contains_key(v));\n }\n \n-fn collect_local(&@vec[tup(ident, def_id)] vars, &@decl d) -> () {\n+fn collect_local(&@vec[identifier] vars, &@decl d) -> () {\n     alt (d.node) {\n       case (decl_local(?loc)) {\n         log(\"collect_local: pushing \" + loc.ident);\n-        vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+        vec::push[identifier](*vars, rec(name=loc.ident,\n+                                         id=loc.id,\n+                                         sp=d.span));\n       }\n       case (_) { ret; }\n     }\n }\n \n-fn find_locals(&_fn f, &ident i, &def_id d, &ann a)\n-    -> @vec[tup(ident,def_id)] {\n-  auto res = @vec::alloc[tup(ident,def_id)](0u);\n+fn find_locals(&_fn f, &span sp, &ident i, &def_id d, &ann a)\n+    -> @vec[identifier] {\n+  auto res = @vec::alloc[identifier](0u);\n   auto visitor = walk::default_visitor();\n   visitor = rec(visit_decl_pre=bind collect_local(res,_) with visitor);\n-  walk_fn(visitor, f, i, d, a);\n+  walk_fn(visitor, f, sp, i, d, a);\n   ret res;\n }\n \n \n-fn add_var(def_id v, ident nm, uint next, fn_info tbl) -> uint {\n+fn add_var(def_id v, span sp, ident nm, uint next, fn_info tbl) -> uint {\n   log(nm + \" |-> \" + util::common::uistr(next));\n-  tbl.vars.insert(v, tup(next,nm));\n+  tbl.vars.insert(v, rec(bit_num=next, name=nm, sp=sp));\n   ret (next + 1u);\n }\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ident f_name, &def_id f_id, &ann a)\n+fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp,\n+              &ident f_name, &def_id f_id, &ann a)\n     -> () {\n     auto res = rec(vars=@new_def_hash[var_info](),\n                    cf=f.decl.cf);\n@@ -73,15 +79,15 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ident f_name, &def_id f_id, &ann a)\n     /* ignore args, which we know are initialized;\n        just collect locally declared vars */\n \n-    let @vec[tup(ident,def_id)] locals = find_locals(f, f_name, f_id, a);\n-    for (tup(ident,def_id) p in *locals) {\n-        next = add_var(p._1, p._0, next, res);\n+    let @vec[identifier] locals = find_locals(f, f_sp, f_name, f_id, a);\n+    for (identifier p in *locals) {\n+        next = add_var(p.id, p.sp, p.name, next, res);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n-    add_var(f_id, f_name, next, res);\n+    add_var(f_id, f_sp, f_name, next, res);\n \n-    log(f_name + \" has \" + uistr(vec::len[tup(ident, def_id)](*locals))\n+    log(f_name + \" has \" + uistr(vec::len[identifier](*locals))\n             + \" locals\");\n    \n     ccx.fm.insert(f_id, res);\n@@ -92,7 +98,7 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ident f_name, &def_id f_id, &ann a)\n    to bit number) */\n fn mk_f_to_fn_info(&crate_ctxt ccx, @crate c) -> () {\n   let ast_visitor vars_visitor = walk::default_visitor();\n-  vars_visitor = rec(visit_fn_pre=bind mk_fn_info(ccx,_,_,_,_)\n+  vars_visitor = rec(visit_fn_pre=bind mk_fn_info(ccx,_,_,_,_,_)\n                      with vars_visitor);\n \n   walk_crate(vars_visitor, *c);"}, {"sha": "8d9e08e51a32f1d71b2f3c5e94d7960a399b6fec", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -151,6 +151,8 @@ import util::common::log_expr_err;\n import util::common::log_block_err;\n import util::common::log_block;\n \n+import front::ast::span;\n+\n fn find_pre_post_mod(&_mod m) -> _mod {\n     log(\"implement find_pre_post_mod!\");\n     fail;\n@@ -238,7 +240,7 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n-    set_pre_and_post(fcx.ccx, a, seq_preconds(enclosing, pps),\n+    set_pre_and_post(fcx.ccx, a, seq_preconds(fcx, pps),\n         union_postconds\n           (nv, (vec::map[pre_and_post, postcond](h, pps))));\n }\n@@ -249,8 +251,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n     find_pre_post_block(fcx, body);\n     log(\"222\");\n     auto loop_precond = declare_var(fcx.enclosing, decl_lhs(d),\n-      seq_preconds(fcx.enclosing, [expr_pp(fcx.ccx, index),\n-                                   block_pp(fcx.ccx, body)]));\n+      seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]));\n     auto loop_postcond = intersect_postconds\n         ([expr_postcond(fcx.ccx, index), block_postcond(fcx.ccx, body)]);\n     set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n@@ -259,13 +260,18 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n                 &ann larger_ann, &ann new_var) -> () {\n   alt (ann_to_def(fcx.ccx, new_var)) {\n-    case (some[def](def_local(?d_id))) {\n-      find_pre_post_expr(fcx, rhs);\n-      auto p = expr_pp(fcx.ccx, rhs);\n-      set_pre_and_post(fcx.ccx, larger_ann,\n-                       p.precondition, p.postcondition);\n-      gen(fcx, larger_ann, d_id);\n-    }\n+      case (some[def](?d)) {\n+          alt (d) {\n+              case (def_local(?d_id)) {\n+                  find_pre_post_expr(fcx, rhs);\n+                  auto p = expr_pp(fcx.ccx, rhs);\n+                  set_pre_and_post(fcx.ccx, larger_ann,\n+                                   p.precondition, p.postcondition);\n+                  gen(fcx, larger_ann, d_id);\n+              }\n+              case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n+          }\n+      }\n     case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n   }\n }\n@@ -401,7 +407,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n                     log \"333\";\n-                    auto precond_res = seq_preconds(enclosing,\n+                    auto precond_res = seq_preconds(fcx,\n                                          [expr_pp(fcx.ccx, antec),\n                                           block_pp(fcx.ccx, conseq)]);\n                     set_pre_and_post(fcx.ccx, a, precond_res,\n@@ -411,17 +417,16 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                     find_pre_post_expr(fcx, altern);\n                     log \"444\";\n                     auto precond_true_case =\n-                        seq_preconds(enclosing,\n-                                     [expr_pp(fcx.ccx, antec),\n-                                      block_pp(fcx.ccx, conseq)]);\n+                        seq_preconds(fcx, [expr_pp(fcx.ccx, antec),\n+                                           block_pp(fcx.ccx, conseq)]);\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n                          [expr_postcond(fcx.ccx, antec),\n                           block_postcond(fcx.ccx, conseq)]);\n                     log \"555\";\n                     auto precond_false_case = seq_preconds\n-                        (enclosing,\n-                         [expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n+                        (fcx, [expr_pp(fcx.ccx, antec),\n+                               expr_pp(fcx.ccx, altern)]);\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n                          [expr_postcond(fcx.ccx, antec),\n@@ -456,7 +461,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             find_pre_post_block(fcx, body);\n             log \"666\";\n             set_pre_and_post(fcx.ccx, a,\n-                    seq_preconds(enclosing,\n+                             seq_preconds(fcx,\n                                [expr_pp(fcx.ccx, test), \n                                    block_pp(fcx.ccx, body)]),\n                     intersect_postconds([expr_postcond(fcx.ccx, test),\n@@ -476,8 +481,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             }\n \n             log \"777\";\n-            set_pre_and_post(fcx.ccx, a, \n-              seq_preconds(enclosing,\n+            set_pre_and_post(fcx.ccx, a, seq_preconds(fcx,\n                            [block_pp(fcx.ccx, body),\n                             expr_pp(fcx.ccx, test)]),\n               loop_postcond);\n@@ -499,19 +503,17 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             }\n             auto f = bind do_an_alt(fcx, _);\n             auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n-            fn combine_pp(pre_and_post antec, \n-                          fn_info enclosing, &pre_and_post pp,\n+            fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n                 log \"777\";\n-                union(pp.precondition, seq_preconds(enclosing,\n-                                                    [antec, next]));\n+                union(pp.precondition, seq_preconds(fcx, [antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n             auto antec_pp = pp_clone(expr_pp(fcx.ccx, e)); \n             auto e_pp  = @rec(precondition=empty_prestate(num_local_vars),\n                              postcondition=false_postcond(num_local_vars));\n-            auto g = bind combine_pp(antec_pp, fcx.enclosing, _, _);\n+            auto g = bind combine_pp(antec_pp, fcx, _, _);\n \n             auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n@@ -668,7 +670,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n     plus_option[pre_and_post](pps,\n        option::map[@expr, pre_and_post](g, b.node.expr));\n \n-    auto block_precond  = seq_preconds(fcx.enclosing, pps);\n+    auto block_precond  = seq_preconds(fcx, pps);\n     auto h = get_post;\n     auto postconds =  vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n@@ -687,7 +689,8 @@ fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) -> () {\n     find_pre_post_block(fcx, f.body);\n }\n \n-fn fn_pre_post(crate_ctxt ccx, &_fn f, &ident i, &def_id id, &ann a) -> () {\n+fn fn_pre_post(crate_ctxt ccx, &_fn f, &span sp, &ident i, &def_id id,\n+               &ann a) -> () {\n     assert (ccx.fm.contains_key(id));\n     auto fcx = rec(enclosing=ccx.fm.get(id),\n                    id=id, name=i, ccx=ccx);\n@@ -704,4 +707,3 @@ fn fn_pre_post(crate_ctxt ccx, &_fn f, &ident i, &def_id id, &ann a) -> () {\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //\n-"}, {"sha": "10dc882166a543f5f8728af52e4f816e716dff0c", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -204,8 +204,10 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@decl d,\n \n fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a) -> bool {\n   alt (ann_to_def(fcx.ccx, a_new_var)) {\n-    case (some[def](def_local(?d))) { ret gen_poststate(fcx, a, d); }\n-    case (_) { ret false; }\n+      case (some[def](def_local(?loc))) {\n+          ret gen_poststate(fcx, a, loc);\n+      }\n+      case (_) { ret false; }\n   }\n }\n \n@@ -420,9 +422,9 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         log(\"if:\");\n         log_expr(*e);\n         log(\"new prestate:\");\n-        log_bitv(fcx.enclosing, pres);\n+        log_bitv(fcx, pres);\n         log(\"new poststate:\");\n-        log_bitv(fcx.enclosing, expr_poststate(fcx.ccx, e));\n+        log_bitv(fcx, expr_poststate(fcx.ccx, e));\n \n         ret changed;\n     }\n@@ -637,10 +639,9 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                             log_stmt(*s);\n                             log(\"prestate = \");\n                             log(bitv::to_str(stmt_ann.states.prestate));\n-                            log_bitv(fcx.enclosing, stmt_ann.states.prestate);\n+                            log_bitv(fcx, stmt_ann.states.prestate);\n                             log(\"poststate =\");\n-                            log_bitv(fcx.enclosing,\n-                                     stmt_ann.states.poststate);\n+                            log_bitv(fcx, stmt_ann.states.poststate);\n                             log(\"changed =\");\n                             log(changed);\n   \n@@ -740,9 +741,9 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n   log(\"poststate = \");\n   log_states(block_states(fcx.ccx, b));\n   log(\"pres0:\");\n-  log_bitv(fcx.enclosing, pres0);\n+  log_bitv(fcx, pres0);\n   log(\"post:\");\n-  log_bitv(fcx.enclosing, post);\n+  log_bitv(fcx, post);\n \n   ret changed;\n }"}, {"sha": "a6246d288f223727f5100470bab7ac32a54c0380", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -4,6 +4,8 @@ import std::option;\n import std::option::some;\n import std::option::none;\n \n+import front::ast::span;\n+\n // FIXME: Should visit patterns as well.\n type ast_visitor =\n     rec(fn () -> bool                  keep_going,\n@@ -32,9 +34,9 @@ type ast_visitor =\n         fn (&@ast::expr e)              visit_expr_post,\n         fn (&@ast::ty t)                visit_ty_pre,\n         fn (&@ast::ty t)                visit_ty_post,\n-        fn (&ast::_fn f, &ast::ident name, \n+        fn (&ast::_fn f, &span sp, &ast::ident name, \n             &ast::def_id d_id, &ast::ann a)  visit_fn_pre,\n-        fn (&ast::_fn f, &ast::ident name,\n+        fn (&ast::_fn f, &span sp, &ast::ident name,\n             &ast::def_id d_id, &ast::ann a)  visit_fn_post);\n \n fn walk_crate(&ast_visitor v, &ast::crate c) {\n@@ -95,8 +97,8 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n             walk_ty(v, t);\n             walk_expr(v, e);\n         }\n-        case (ast::item_fn(?i, ?f, _, ?d, ?a)) {\n-            walk_fn(v, f, i, d, a);\n+        case (ast::item_fn(?nm, ?f, _, ?d, ?a)) {\n+            walk_fn(v, f, i.span, nm, d, a);\n         }\n         case (ast::item_mod(_, ?m, _)) {\n             walk_mod(v, m);\n@@ -120,13 +122,14 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n             }\n             for (@ast::method m in ob.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.node.ident, m.node.id, m.node.ann);\n+                walk_fn(v, m.node.meth, m.span,\n+                        m.node.ident, m.node.id, m.node.ann);\n                 v.visit_method_post(m);\n             }\n             alt (ob.dtor) {\n                 case (none[@ast::method]) {}\n                 case (some[@ast::method](?m)) {\n-                    walk_fn(v, m.node.meth, m.node.ident, m.node.id,\n+                    walk_fn(v, m.node.meth, m.span, m.node.ident, m.node.id,\n                             m.node.ann);\n                 }\n             }\n@@ -232,13 +235,13 @@ fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n     walk_ty(v, fd.output);\n }\n \n-fn walk_fn(&ast_visitor v, &ast::_fn f, &ast::ident i, &ast::def_id d,\n-           &ast::ann a) {\n+fn walk_fn(&ast_visitor v, &ast::_fn f, &span sp, &ast::ident i,\n+           &ast::def_id d, &ast::ann a) {\n     if (!v.keep_going()) { ret; }\n-    v.visit_fn_pre(f, i, d, a);\n+    v.visit_fn_pre(f, sp, i, d, a);\n     walk_fn_decl(v, f.decl);\n     walk_block(v, f.body);\n-    v.visit_fn_post(f, i, d, a);\n+    v.visit_fn_post(f, sp, i, d, a);\n }\n \n fn walk_block(&ast_visitor v, &ast::block b) {\n@@ -471,7 +474,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             // Methods\n             for (@ast::method m in anon_obj.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, m.node.ident, \n+                walk_fn(v, m.node.meth, m.span, m.node.ident, \n                         m.node.id, m.node.ann);\n                 v.visit_method_post(m);\n \n@@ -495,7 +498,8 @@ fn def_visit_arm(&ast::arm a) { }\n fn def_visit_decl(&@ast::decl d) { }\n fn def_visit_expr(&@ast::expr e) { }\n fn def_visit_ty(&@ast::ty t) { }\n-fn def_visit_fn(&ast::_fn f, &ast::ident i, &ast::def_id d, &ast::ann a) { }\n+fn def_visit_fn(&ast::_fn f, &span sp, &ast::ident i, &ast::def_id d,\n+                &ast::ann a) { }\n \n fn default_visitor() -> ast_visitor {\n "}, {"sha": "6a67108dffe22aa5021a645f6dcae4441593c3c9", "filename": "src/test/compile-fail/shadow.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f792f2dbb40ae069b2625425fab58009e19ac74/src%2Ftest%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadow.rs?ref=4f792f2dbb40ae069b2625425fab58009e19ac74", "patch": "@@ -0,0 +1,25 @@\n+// -*- rust -*-\n+// error-pattern: a \\[./src/test/compile-fail/shadow.rs:11:8:11:20\n+fn foo(vec[int] c) {\n+  let int a = 5;\n+  let vec[int] b = [];\n+\n+  alt (none[int]) {\n+    case (some[int](_)) {\n+      for (int i in c) {\n+        log a;\n+        auto a = 17;\n+        b += [a];\n+      }\n+    }\n+  }\n+}\n+\n+tag t[T] {\n+  none;\n+  some(T);\n+}\n+\n+fn main() {\n+  foo([]);\n+}"}]}