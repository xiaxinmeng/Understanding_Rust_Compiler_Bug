{"sha": "7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "node_id": "C_kwDOAAsO6NoAKDdhMjJjNDdjNmFjYmE2ZDM5OTI5NjNhNGQ2YzViYmM2ZWFjMjRjNjg", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2023-02-26T03:22:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-26T03:22:21Z"}, "message": "Merge pull request #254 from rust-lang/feature/simd_scatter_gather\n\nFeature/simd scatter gather", "tree": {"sha": "2bd49a4bd81471771af005c3086e6d7eeb838908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bd49a4bd81471771af005c3086e6d7eeb838908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj+tBtCRBK7hj4Ov3rIwAAEycIAIHBbAY850gNQphFSwjf+g7b\nVdpEdd5NGLh9k8HFmutSO7Rr1WQzSHwU6JGaiulefZ80NuuPjuaSmb/swksXvKDA\nVWShLXv96G8g1FeYdSkvHhboz4YWGBxd3HDeKvA+AEIRqnvRqIoDb4bIO3Y7HxQc\ndkp6b/z5mzFWVaBlxuu5FPvwIG1Fo+ZAaD0Zw98RAYaLh+G9eCmuWG+9vszp0zs3\nqNRA1Zn/WtvhGuG33D9JVzpOsUEGDmNZOovO+dk2IJr5wTWn+oDgfxZx15Efw6SM\n5epSghj5TLoEghgjSmy0sWNI8Jn94A67IfLEaJ3hk/csY0NJba2SvQsJ1e3H/1g=\n=bJl9\n-----END PGP SIGNATURE-----\n", "payload": "tree 2bd49a4bd81471771af005c3086e6d7eeb838908\nparent 8d0ff6bf0776d421ee2a38c09e6d60a8b361c99e\nparent 16b377efbd612c276a6800dbcecbb0fe9ad9a204\nauthor antoyo <antoyo@users.noreply.github.com> 1677381741 -0500\ncommitter GitHub <noreply@github.com> 1677381741 -0500\n\nMerge pull request #254 from rust-lang/feature/simd_scatter_gather\n\nFeature/simd scatter gather"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "html_url": "https://github.com/rust-lang/rust/commit/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0ff6bf0776d421ee2a38c09e6d60a8b361c99e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0ff6bf0776d421ee2a38c09e6d60a8b361c99e", "html_url": "https://github.com/rust-lang/rust/commit/8d0ff6bf0776d421ee2a38c09e6d60a8b361c99e"}, {"sha": "16b377efbd612c276a6800dbcecbb0fe9ad9a204", "url": "https://api.github.com/repos/rust-lang/rust/commits/16b377efbd612c276a6800dbcecbb0fe9ad9a204", "html_url": "https://github.com/rust-lang/rust/commit/16b377efbd612c276a6800dbcecbb0fe9ad9a204"}], "stats": {"total": 301, "additions": 295, "deletions": 6}, "files": [{"sha": "fba8c3db42e4915823ca1ddc2f40639525363fc7", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#1e6ecc67fe73ac995e511516eacf4fe3aec8974e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1bd270d0d130fe31807cfbe509ca095c082e5848\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#1e6ecc67fe73ac995e511516eacf4fe3aec8974e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1bd270d0d130fe31807cfbe509ca095c082e5848\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "f43116544ed246f1e7af8c707cb2f48c0fead7d9", "filename": "failing-ui-tests.txt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/failing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/failing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests.txt?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -22,8 +22,6 @@ src/test/ui/sepcomp/sepcomp-fns-backwards.rs\n src/test/ui/sepcomp/sepcomp-fns.rs\n src/test/ui/sepcomp/sepcomp-statics.rs\n src/test/ui/simd/intrinsic/generic-arithmetic-pass.rs\n-src/test/ui/simd/intrinsic/generic-gather-pass.rs\n-src/test/ui/simd/type-generic-monomorphisation-extern-nonnull-ptr.rs\n src/test/ui/sse2.rs\n src/test/ui/target-feature/missing-plusminus.rs\n src/test/ui/asm/x86_64/may_unwind.rs\n@@ -54,7 +52,6 @@ src/test/ui/issues/issue-43853.rs\n src/test/ui/issues/issue-47364.rs\n src/test/ui/simd/issue-17170.rs\n src/test/ui/simd/issue-39720.rs\n-src/test/ui/simd/issue-85915-simd-ptrs.rs\n src/test/ui/simd/issue-89193.rs\n src/test/ui/statics/issue-91050-1.rs\n src/test/ui/statics/issue-91050-2.rs"}, {"sha": "2a9f39e88ccb09160add452bba8c8a06d14566cf", "filename": "failing-ui-tests12.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/failing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/failing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests12.txt?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -37,3 +37,5 @@ src/test/ui/cfg/cfg-panic.rs\n src/test/ui/generator/size-moved-locals.rs\n src/test/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n src/test/ui/runtime/rt-explody-panic-payloads.rs\n+src/test/ui/simd/intrinsic/generic-gather-pass.rs\n+src/test/ui/simd/issue-85915-simd-ptrs.rs"}, {"sha": "2d7860536c25151677a41e91820044f4dbfa6fc7", "filename": "src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -1419,7 +1419,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+        let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");\n \n         // TODO(antoyo): use a recursive unqualified() here.\n         let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");"}, {"sha": "233d0b7f739d1b67ac3346fccedd5be84e9cb168", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -14,6 +14,8 @@ use rustc_span::{Span, Symbol, sym};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+#[cfg(feature=\"master\")]\n+use crate::context::CodegenCx;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n@@ -507,6 +509,286 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn vector_ty<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, elem_ty: Ty<'tcx>, vec_len: u64) -> Type<'gcc> {\n+        // FIXME: use cx.layout_of(ty).llvm_type() ?\n+        let elem_ty = match *elem_ty.kind() {\n+            ty::Int(v) => cx.type_int_from_ty(v),\n+            ty::Uint(v) => cx.type_uint_from_ty(v),\n+            ty::Float(v) => cx.type_float_from_ty(v),\n+            _ => unreachable!(),\n+        };\n+        cx.type_vector(elem_ty, vec_len)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn gather<'a, 'gcc, 'tcx>(default: RValue<'gcc>, pointers: RValue<'gcc>, mask: RValue<'gcc>, pointer_count: usize, bx: &mut Builder<'a, 'gcc, 'tcx>, in_len: u64, underlying_ty: Ty<'tcx>, invert: bool) -> RValue<'gcc> {\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        let mut values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            let value = ptr.dereference(None).to_rvalue();\n+            values.push(value);\n+        }\n+\n+        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n+\n+        let mut mask_types = vec![];\n+        let mut mask_values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\"));\n+            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n+            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n+            let value = index + masked;\n+            mask_values.push(value);\n+        }\n+        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n+        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n+\n+        if invert {\n+            bx.shuffle_vector(vector, default, mask)\n+        }\n+        else {\n+            bx.shuffle_vector(default, vector, mask)\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_gather {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"second\",\n+            in_len,\n+            in_ty,\n+            arg_tys[1],\n+            out_len\n+        );\n+        require!(\n+            in_len == out_len2,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"third\",\n+            in_len,\n+            in_ty,\n+            arg_tys[2],\n+            out_len2\n+        );\n+\n+        // The return type must match the first argument type\n+        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of second argument `{}` \\\n+                    to be a pointer to the element type `{}` of the first \\\n+                        argument `{}`, found `{}` != `*_ {}`\",\n+                        element_ty1,\n+                        arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        element_ty1,\n+                        in_elem\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of third argument `{}` \\\n+                    to be a signed integer type\",\n+                    element_ty2,\n+                    arg_tys[2]\n+                );\n+            }\n+        }\n+\n+        return Ok(gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, false));\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_scatter {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == element_len1,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"second\",\n+            in_len,\n+            in_ty,\n+            arg_tys[1],\n+            element_len1\n+        );\n+        require!(\n+            in_len == element_len2,\n+            \"expected {} argument with length {} (same as input type `{}`), \\\n+            found `{}` with length {}\",\n+            \"third\",\n+            in_len,\n+            in_ty,\n+            arg_tys[2],\n+            element_len2\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n+            }\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of second argument `{}` \\\n+                    to be a pointer to the element type `{}` of the first \\\n+                        argument `{}`, found `{}` != `*mut {}`\",\n+                        element_ty1,\n+                        arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        element_ty1,\n+                        in_elem\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    \"expected element type `{}` of third argument `{}` \\\n+                    be a signed integer type\",\n+                    element_ty2,\n+                    arg_tys[2]\n+                );\n+            }\n+        }\n+\n+        let result = gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, true);\n+\n+        let pointers = args[1].immediate();\n+\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_int(bx.int_type, i as i32);\n+            let value = bx.context.new_vector_access(None, result, index);\n+\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            bx.llbb().add_assignment(None, ptr.dereference(None), value);\n+        }\n+\n+        return Ok(bx.context.new_rvalue_zero(bx.i32_type));\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;"}, {"sha": "09c79b69ce3cef4e46f0a84ba76ad72df1bd072a", "filename": "src/type_of.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a22c47c6acba6d3992963a4d6c5bbc6eac24c68/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=7a22c47c6acba6d3992963a4d6c5bbc6eac24c68", "patch": "@@ -55,6 +55,14 @@ fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n             let element = layout.scalar_gcc_type_at(cx, element, Size::ZERO);\n+            let element =\n+                // NOTE: gcc doesn't allow pointer types in vectors.\n+                if element.get_pointee().is_some() {\n+                    cx.usize_type\n+                }\n+                else {\n+                    element\n+                };\n             return cx.context.new_vector_type(element, count);\n         },\n         Abi::ScalarPair(..) => {"}]}