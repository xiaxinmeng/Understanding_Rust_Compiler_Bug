{"sha": "e62424944b197e24025b149e2d4ba2347b76c8d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MjQyNDk0NGIxOTdlMjQwMjViMTQ5ZTJkNGJhMjM0N2I3NmM4ZDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T00:51:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T00:56:19Z"}, "message": "rustc: Have trans get the type parameters from the annotation instead of trying to deduce them itself. Un-XFAIL generic-fn-twice.rs.", "tree": {"sha": "368aaba316aa111413a38434f91d52d281f2a7a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/368aaba316aa111413a38434f91d52d281f2a7a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e62424944b197e24025b149e2d4ba2347b76c8d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e62424944b197e24025b149e2d4ba2347b76c8d8", "html_url": "https://github.com/rust-lang/rust/commit/e62424944b197e24025b149e2d4ba2347b76c8d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e62424944b197e24025b149e2d4ba2347b76c8d8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a9532dee0eb8eefc77d0c4885bcfe170e2a6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a9532dee0eb8eefc77d0c4885bcfe170e2a6ef", "html_url": "https://github.com/rust-lang/rust/commit/67a9532dee0eb8eefc77d0c4885bcfe170e2a6ef"}], "stats": {"total": 106, "additions": 81, "deletions": 25}, "files": [{"sha": "d66dba1f99be4ebd983c00a6ac6a69d12150b7d4", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e62424944b197e24025b149e2d4ba2347b76c8d8/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/e62424944b197e24025b149e2d4ba2347b76c8d8/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=e62424944b197e24025b149e2d4ba2347b76c8d8", "patch": "@@ -452,7 +452,6 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         foreach-nested.rs \\\n                         foreach-put-structured.rs \\\n                         foreach-simple-outer-slot.rs \\\n-                        generic-fn-twice.rs \\\n                         generic-iter-frame.rs \\\n                         generic-tag-alt.rs \\\n                         generic-tag-values.rs \\"}, {"sha": "44dc57fdb71fdf3f974575db50b141085e3a544f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 81, "deletions": 24, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e62424944b197e24025b149e2d4ba2347b76c8d8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62424944b197e24025b149e2d4ba2347b76c8d8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e62424944b197e24025b149e2d4ba2347b76c8d8", "patch": "@@ -503,7 +503,8 @@ fn type_of_fn_full(@crate_ctxt cx,\n                    ast.proto proto,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n-                   @ty.t output) -> TypeRef {\n+                   @ty.t output,\n+                   uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n \n     // Arg 0: Output pointer.\n@@ -529,10 +530,6 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n-        auto ty_param_count =\n-            ty.count_ty_params(plain_ty(ty.ty_fn(proto,\n-                                                 inputs,\n-                                                 output)));\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += T_ptr(T_tydesc(cx.tn));\n@@ -547,7 +544,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n         atys += T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          plain_ty(ty.ty_nil)));\n+                                          plain_ty(ty.ty_nil), 0u));\n     }\n \n     // ... then explicit args.\n@@ -558,8 +555,11 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n fn type_of_fn(@crate_ctxt cx,\n               ast.proto proto,\n-              vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n-    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output);\n+              vec[ty.arg] inputs,\n+              @ty.t output,\n+              uint ty_param_count) -> TypeRef {\n+    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output,\n+                        ty_param_count);\n }\n \n fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n@@ -634,7 +634,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n             llty = T_struct(tys);\n         }\n         case (ty.ty_fn(?proto, ?args, ?out)) {\n-            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n+            llty = T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out, 0u));\n         }\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n             llty = T_fn_pair(cx.tn, type_of_native_fn(cx, abi, args, out));\n@@ -648,7 +648,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                 let TypeRef mty =\n                     type_of_fn_full(cx, m.proto,\n                                     some[TypeRef](self_ty),\n-                                    m.inputs, m.output);\n+                                    m.inputs, m.output, 0u);\n                 mtys += T_ptr(mty);\n             }\n             let TypeRef vtbl = T_struct(mtys);\n@@ -2820,7 +2820,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto iter_body_llty = type_of_fn_full(cx.fcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n-                                          plain_ty(ty.ty_nil));\n+                                          plain_ty(ty.ty_nil), 0u);\n \n     let ValueRef lliterbody = decl_fastcall_fn(cx.fcx.ccx.llmod,\n                                                s, iter_body_llty);\n@@ -3447,6 +3447,16 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto lltargetfn = bcx.build.GEP(lltarget.val,\n                                     vec(C_int(0),\n                                         C_int(abi.fn_field_code)));\n+\n+    // Cast the outgoing function to the appropriate type (see the comments in\n+    // trans_bind below for why this is necessary).\n+    auto lltargetty = type_of_fn(bcx.fcx.ccx,\n+                                 ty.ty_fn_proto(outgoing_fty),\n+                                 outgoing_args,\n+                                 outgoing_ret_ty,\n+                                 ty_param_count);\n+    lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n+\n     lltargetfn = bcx.build.Load(lltargetfn);\n \n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n@@ -3551,12 +3561,26 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             bcx = bindings_tydesc.bcx;\n             bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n+            // Determine the LLVM type for the outgoing function type. This\n+            // may be different from the type returned by trans_malloc_boxed()\n+            // since we have more information than that function does;\n+            // specifically, we know how many type descriptors the outgoing\n+            // function has, which type_of() doesn't, as only we know which\n+            // item the function refers to.\n+            auto llfnty = type_of_fn(bcx.fcx.ccx,\n+                                     ty.ty_fn_proto(outgoing_fty),\n+                                     ty.ty_fn_args(outgoing_fty),\n+                                     ty.ty_fn_ret(outgoing_fty),\n+                                     ty_param_count);\n+            auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.ccx.tn, llfnty));\n+\n             // Store thunk-target.\n             auto bound_target =\n                 bcx.build.GEP(closure,\n                               vec(C_int(0),\n                                   C_int(abi.closure_elt_target)));\n             auto src = bcx.build.Load(f_res.res.val);\n+            bound_target = bcx.build.PointerCast(bound_target, llclosurety);\n             bcx.build.Store(src, bound_target);\n \n             // Copy expr values into boxed bindings.\n@@ -4691,7 +4715,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx, proto,\n                                          some[TypeRef](self_ty),\n-                                         inputs, output);\n+                                         inputs, output,\n+                                         _vec.len[ast.ty_param](ty_params));\n             }\n         }\n \n@@ -4990,11 +5015,23 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n fn decl_fn_and_pair(@crate_ctxt cx,\n                     str kind,\n                     str name,\n+                    vec[ast.ty_param] ty_params,\n                     &ast.ann ann,\n                     ast.def_id id) {\n \n-    auto llpairty = node_type(cx, ann);\n-    auto llfty = get_pair_fn_ty(llpairty);\n+    auto llfty;\n+    auto llpairty;\n+    alt (node_ann_type(cx, ann).struct) {\n+        case (ty.ty_fn(?proto, ?inputs, ?output)) {\n+            llfty = type_of_fn(cx, proto, inputs, output,\n+                               _vec.len[ast.ty_param](ty_params));\n+            llpairty = T_fn_pair(cx.tn, llfty);\n+        }\n+        case (_) {\n+            cx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type?!\");\n+            fail;\n+        }\n+    }\n \n     // Declare the function itself.\n     let str s = cx.names.next(\"_rust_\" + kind) + sep() + name;\n@@ -5023,11 +5060,29 @@ fn register_fn_pair(@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n     cx.fn_pairs.insert(id, gvar);\n }\n \n-fn native_fn_wrapper_type(@crate_ctxt cx, &ast.ann ann) -> TypeRef {\n+// Returns the number of type parameters that the given native function has.\n+fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n+    auto count;\n+    auto native_item = cx.native_items.get(id);\n+    alt (native_item.node) {\n+        case (ast.native_item_ty(_,_)) {\n+            cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n+                        \"actually a fn?!\");\n+            fail;\n+        }\n+        case (ast.native_item_fn(_, _, ?tps, _, _)) {\n+            count = _vec.len[ast.ty_param](tps);\n+        }\n+    }\n+    ret count;\n+}\n+\n+fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, &ast.ann ann)\n+        -> TypeRef {\n     auto x = node_ann_type(cx, ann);\n     alt (x.struct) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n-            ret type_of_fn(cx, ast.proto_fn, args, out);\n+            ret type_of_fn(cx, ast.proto_fn, args, out, ty_param_count);\n         }\n     }\n     fail;\n@@ -5037,8 +5092,10 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n                            str name,\n                            &ast.ann ann,\n                            ast.def_id id) {\n+    auto num_ty_param = native_fn_ty_param_count(cx, id);\n+\n     // Declare the wrapper.\n-    auto wrapper_type = native_fn_wrapper_type(cx, ann);\n+    auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, ann);\n     let str s = cx.names.next(\"_rust_wrapper\") + sep() + name;\n     let ValueRef wrapper_fn = decl_fastcall_fn(cx.llmod, s, wrapper_type);\n \n@@ -5063,7 +5120,6 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     alt (abi) {\n         case (ast.native_abi_rust) {\n             call_args += vec(fcx.lltaskptr);\n-            auto num_ty_param = ty.count_ty_params(plain_ty(fn_type.struct));\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 check (llarg as int != 0);\n@@ -5081,6 +5137,7 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n         call_args += vec(llarg);\n         arg_n += 1u;\n     }\n+\n     auto r = bcx.build.Call(function, call_args);\n     bcx.build.Store(r, fcx.llretptr);\n     bcx.build.RetVoid();\n@@ -5102,16 +5159,16 @@ fn collect_native_item(&@crate_ctxt cx, @ast.native_item i) -> @crate_ctxt {\n fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n     alt (i.node) {\n-        case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n+        case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             cx.items.insert(fid, i);\n             if (! cx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(cx, \"fn\", name, ann, fid);\n+                decl_fn_and_pair(cx, \"fn\", name, tps, ann, fid);\n             }\n         }\n \n-        case (ast.item_obj(?name, ?ob, _, ?oid, ?ann)) {\n+        case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             cx.items.insert(oid, i);\n-            decl_fn_and_pair(cx, \"obj_ctor\", name, ann, oid);\n+            decl_fn_and_pair(cx, \"obj_ctor\", name, tps, ann, oid);\n             for (@ast.method m in ob.methods) {\n                 cx.obj_methods.insert(m.node.id, ());\n             }\n@@ -5151,11 +5208,11 @@ fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n     alt (i.node) {\n \n-        case (ast.item_tag(_, ?variants, _, _)) {\n+        case (ast.item_tag(_, ?variants, ?tps, _)) {\n             for (ast.variant variant in variants) {\n                 if (_vec.len[ast.variant_arg](variant.args) != 0u) {\n                     decl_fn_and_pair(cx, \"tag\", variant.name,\n-                                     variant.ann, variant.id);\n+                                     tps, variant.ann, variant.id);\n                 }\n             }\n         }"}]}