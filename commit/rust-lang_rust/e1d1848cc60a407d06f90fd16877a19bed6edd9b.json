{"sha": "e1d1848cc60a407d06f90fd16877a19bed6edd9b", "node_id": "C_kwDOAAsO6NoAKGUxZDE4NDhjYzYwYTQwN2QwNmY5MGZkMTY4NzdhMTliZWQ2ZWRkOWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-04T22:42:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-04T22:42:15Z"}, "message": "Auto merge of #98904 - matthiaskrgr:rollup-05owsx7, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98738 (Clarify MIR semantics of checked binary operations)\n - #98782 (Improve spans for specialization error)\n - #98793 (Lint against executable files in the root directory)\n - #98814 (rustdoc: Censor certain complex unevaluated const exprs)\n - #98878 (add more `rustc_pass_by_value`)\n - #98879 (Fix \"wrap closure in parenthesis\" suggestion for `async` closure)\n - #98886 (incr.comp.: Make split-dwarf commandline options [TRACKED].)\n - #98898 (Add \"no-div-regex\" eslint rule)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "41964c0f3baccf5b045bb76104ebecee450ed6b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41964c0f3baccf5b045bb76104ebecee450ed6b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1d1848cc60a407d06f90fd16877a19bed6edd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d1848cc60a407d06f90fd16877a19bed6edd9b", "html_url": "https://github.com/rust-lang/rust/commit/e1d1848cc60a407d06f90fd16877a19bed6edd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1d1848cc60a407d06f90fd16877a19bed6edd9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27eb6d7018e397cf98d51c205e3576951d766323", "url": "https://api.github.com/repos/rust-lang/rust/commits/27eb6d7018e397cf98d51c205e3576951d766323", "html_url": "https://github.com/rust-lang/rust/commit/27eb6d7018e397cf98d51c205e3576951d766323"}, {"sha": "08d558dbe94618d910d0218e8323b76db1b9a863", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d558dbe94618d910d0218e8323b76db1b9a863", "html_url": "https://github.com/rust-lang/rust/commit/08d558dbe94618d910d0218e8323b76db1b9a863"}], "stats": {"total": 489, "additions": 426, "deletions": 63}, "files": [{"sha": "d34c6d9dee58d7e28b65ee6d900e36ccfe568ec9", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -149,7 +149,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     fn visit_ascribe_user_ty(\n         &mut self,\n         _place: &Place<'tcx>,\n-        _variance: &ty::Variance,\n+        _variance: ty::Variance,\n         _user_ty: &UserTypeProjection,\n         _location: Location,\n     ) {"}, {"sha": "3b7eb820df87531d6a0b186347b8ac0bdfaa1d02", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -311,6 +311,7 @@ pub enum StatementKind<'tcx> {\n \n /// Describes what kind of retag is to be performed.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n+#[rustc_pass_by_value]\n pub enum RetagKind {\n     /// The initial retag when entering a function.\n     FnEntry,\n@@ -990,11 +991,19 @@ pub enum Rvalue<'tcx> {\n     ///   matching types and return a value of that type.\n     BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n-    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n-    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n-    /// unequal to the actual result and sets the `bool` if this is the case.\n+    /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n     ///\n-    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n+    /// When overflow checking is disabled, the error condition is false. Otherwise, the error\n+    /// condition is determined as described below.\n+    ///\n+    /// For addition, subtraction, and multiplication on integers the error condition is set when\n+    /// the infinite precision result would be unequal to the actual result.\n+    ///\n+    /// For shift operations on integers the error condition is set when the value of right-hand\n+    /// side is greater than or equal to the number of bits in the type of the left-hand side, or\n+    /// when the value of right-hand side is negative.\n+    ///\n+    /// Other combinations of types and operators are unsupported.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n     /// Computes a value as described by the operation."}, {"sha": "d1477f9e2ae100bb99a430a420cfe68bc34f3e54", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -147,7 +147,7 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(\n                 &mut self,\n                 place: & $($mutability)? Place<'tcx>,\n-                variance: & $($mutability)? ty::Variance,\n+                variance: $(& $mutability)? ty::Variance,\n                 user_ty: & $($mutability)? UserTypeProjection,\n                 location: Location,\n             ) {\n@@ -164,7 +164,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_retag(\n                 &mut self,\n-                kind: & $($mutability)? RetagKind,\n+                kind: $(& $mutability)? RetagKind,\n                 place: & $($mutability)? Place<'tcx>,\n                 location: Location,\n             ) {\n@@ -425,7 +425,7 @@ macro_rules! make_mir_visitor {\n                 self.visit_source_info(source_info);\n                 match kind {\n                     StatementKind::Assign(\n-                        box(ref $($mutability)? place, ref $($mutability)? rvalue)\n+                        box (place, rvalue)\n                     ) => {\n                         self.visit_assign(place, rvalue, location);\n                     }\n@@ -465,13 +465,13 @@ macro_rules! make_mir_visitor {\n                         );\n                     }\n                     StatementKind::Retag(kind, place) => {\n-                        self.visit_retag(kind, place, location);\n+                        self.visit_retag($(& $mutability)? *kind, place, location);\n                     }\n                     StatementKind::AscribeUserType(\n-                        box(ref $($mutability)? place, ref $($mutability)? user_ty),\n+                        box (place, user_ty),\n                         variance\n                     ) => {\n-                        self.visit_ascribe_user_ty(place, variance, user_ty, location);\n+                        self.visit_ascribe_user_ty(place, $(& $mutability)? *variance, user_ty, location);\n                     }\n                     StatementKind::Coverage(coverage) => {\n                         self.visit_coverage(\n@@ -480,9 +480,9 @@ macro_rules! make_mir_visitor {\n                         )\n                     }\n                     StatementKind::CopyNonOverlapping(box crate::mir::CopyNonOverlapping{\n-                      ref $($mutability)? src,\n-                      ref $($mutability)? dst,\n-                      ref $($mutability)? count,\n+                        src,\n+                        dst,\n+                        count,\n                     }) => {\n                       self.visit_operand(src, location);\n                       self.visit_operand(dst, location);\n@@ -517,8 +517,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable |\n                     TerminatorKind::FalseEdge { .. } |\n-                    TerminatorKind::FalseUnwind { .. } => {\n-                    }\n+                    TerminatorKind::FalseUnwind { .. } => {}\n \n                     TerminatorKind::Return => {\n                         // `return` logically moves from the return place `_0`. Note that the place\n@@ -830,7 +829,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n-                                     _variance: & $($mutability)? ty::Variance,\n+                                     _variance: $(& $mutability)? ty::Variance,\n                                      user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.visit_place(\n@@ -847,7 +846,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _kind: & $($mutability)? RetagKind,\n+                           _kind: $(& $mutability)? RetagKind,\n                            place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.visit_place("}, {"sha": "e7717f1367cb053d4619a7a27f4e9189d2ce3354", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -2724,8 +2724,8 @@ pub(crate) mod dep_tracking {\n     use super::{\n         BranchProtection, CFGuard, CFProtection, CrateType, DebugInfo, ErrorOutputType,\n         InstrumentCoverage, LdImpl, LinkerPluginLto, LocationDetail, LtoCli, OomStrategy, OptLevel,\n-        OutputType, OutputTypes, Passes, SourceFileHashAlgorithm, SwitchWithOptPath,\n-        SymbolManglingVersion, TrimmedDefPaths,\n+        OutputType, OutputTypes, Passes, SourceFileHashAlgorithm, SplitDwarfKind,\n+        SwitchWithOptPath, SymbolManglingVersion, TrimmedDefPaths,\n     };\n     use crate::lint;\n     use crate::options::WasiExecModel;\n@@ -2812,6 +2812,7 @@ pub(crate) mod dep_tracking {\n         Edition,\n         LinkerPluginLto,\n         SplitDebuginfo,\n+        SplitDwarfKind,\n         StackProtector,\n         SwitchWithOptPath,\n         SymbolManglingVersion,"}, {"sha": "be70ea5d5e48059b9c92548af34b446fef2ebf61", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1496,15 +1496,15 @@ options! {\n         \"control if mem::uninitialized and mem::zeroed panic on more UB\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n-    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [UNTRACKED],\n+    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [TRACKED],\n         \"split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n         (default: `split`)\n \n         `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n                  file which is ignored by the linker\n         `single`: sections which do not require relocation are written into object file but ignored\n                   by the linker\"),\n-    split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n+    split_dwarf_inlining: bool = (true, parse_bool, [TRACKED],\n         \"provide minimal debug info in the object/executable to facilitate online \\\n          symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n     symbol_mangling_version: Option<SymbolManglingVersion> = (None,"}, {"sha": "6744536338cbbc6bde9895194bc0b46e24eb8f92", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -599,6 +599,7 @@ impl UnifyKey for FloatVid {\n }\n \n #[derive(Copy, Clone, PartialEq, Decodable, Encodable, Hash)]\n+#[rustc_pass_by_value]\n pub enum Variance {\n     Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell"}, {"sha": "96b1847f8bbca244821b3dc9eef817445464a204", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -280,15 +280,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         callee_node: &hir::ExprKind<'_>,\n         callee_span: Span,\n     ) {\n-        let hir_id = self.tcx.hir().get_parent_node(hir_id);\n-        let parent_node = self.tcx.hir().get(hir_id);\n+        let hir = self.tcx.hir();\n+        let parent_hir_id = hir.get_parent_node(hir_id);\n+        let parent_node = hir.get(parent_hir_id);\n         if let (\n             hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure { fn_decl_span, .. }, ..\n+                kind: hir::ExprKind::Closure { fn_decl_span, body, .. },\n+                ..\n             }),\n             hir::ExprKind::Block(..),\n         ) = (parent_node, callee_node)\n         {\n+            let fn_decl_span = if hir.body(*body).generator_kind\n+                == Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure))\n+            {\n+                // Actually need to unwrap a few more layers of HIR to get to\n+                // the _real_ closure...\n+                let async_closure = hir.get_parent_node(hir.get_parent_node(parent_hir_id));\n+                if let hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Closure { fn_decl_span, .. },\n+                    ..\n+                }) = hir.get(async_closure)\n+                {\n+                    *fn_decl_span\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                *fn_decl_span\n+            };\n+\n             let start = fn_decl_span.shrink_to_lo();\n             let end = callee_span.shrink_to_hi();\n             err.multipart_suggestion("}, {"sha": "4d22e168bb64ca35bc9ac09fbe97938308f4acf2", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -279,11 +279,16 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let tcx = infcx.tcx;\n-    let impl1_predicates: Vec<_> = traits::elaborate_predicates(\n+    let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n+    let impl1_predicates: Vec<_> = traits::elaborate_predicates_with_span(\n         tcx,\n-        tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs).predicates.into_iter(),\n+        std::iter::zip(\n+            instantiated.predicates,\n+            // Don't drop predicates (unsound!) because `spans` is too short\n+            instantiated.spans.into_iter().chain(std::iter::repeat(span)),\n+        ),\n     )\n-    .map(|obligation| obligation.predicate)\n+    .map(|obligation| (obligation.predicate, obligation.cause.span))\n     .collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n@@ -321,7 +326,7 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates.iter().copied().filter(|&predicate| {\n+    let always_applicable_traits = impl1_predicates.iter().copied().filter(|&(predicate, _)| {\n         matches!(\n             trait_predicate_kind(tcx, predicate),\n             Some(TraitSpecializationKind::AlwaysApplicable)\n@@ -345,11 +350,11 @@ fn check_predicates<'tcx>(\n         }\n     }\n     impl2_predicates.extend(\n-        traits::elaborate_predicates(tcx, always_applicable_traits)\n+        traits::elaborate_predicates_with_span(tcx, always_applicable_traits)\n             .map(|obligation| obligation.predicate),\n     );\n \n-    for predicate in impl1_predicates {\n+    for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.contains(&predicate) {\n             check_specialization_on(tcx, predicate, span)\n         }\n@@ -384,9 +389,17 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                     .emit();\n             }\n         }\n+        ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+            tcx.sess\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"cannot specialize on associated type `{projection_ty} == {term}`\",),\n+                )\n+                .emit();\n+        }\n         _ => {\n             tcx.sess\n-                .struct_span_err(span, &format!(\"cannot specialize on `{:?}`\", predicate))\n+                .struct_span_err(span, &format!(\"cannot specialize on predicate `{}`\", predicate))\n                 .emit();\n         }\n     }"}, {"sha": "22b1e2335fd8486358971ec8dd2065773492fa83", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -340,17 +340,98 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n+/// Build a textual representation of an unevaluated constant expression.\n+///\n+/// If the const expression is too complex, an underscore `_` is returned.\n+/// For const arguments, it's `{ _ }` to be precise.\n+/// This means that the output is not necessarily valid Rust code.\n+///\n+/// Currently, only\n+///\n+/// * literals (optionally with a leading `-`)\n+/// * unit `()`\n+/// * blocks (`{ \u2026 }`) around simple expressions and\n+/// * paths without arguments\n+///\n+/// are considered simple enough. Simple blocks are included since they are\n+/// necessary to disambiguate unit from the unit type.\n+/// This list might get extended in the future.\n+///\n+/// Without this censoring, in a lot of cases the output would get too large\n+/// and verbose. Consider `match` expressions, blocks and deeply nested ADTs.\n+/// Further, private and `doc(hidden)` fields of structs would get leaked\n+/// since HIR datatypes like the `body` parameter do not contain enough\n+/// semantic information for this function to be able to hide them \u2013\n+/// at least not without significant performance overhead.\n+///\n+/// Whenever possible, prefer to evaluate the constant first and try to\n+/// use a different method for pretty-printing. Ideally this function\n+/// should only ever be used as a fallback.\n pub(crate) fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n     let hir = tcx.hir();\n     let value = &hir.body(body).value;\n \n-    let snippet = if !value.span.from_expansion() {\n-        tcx.sess.source_map().span_to_snippet(value.span).ok()\n-    } else {\n-        None\n-    };\n+    #[derive(PartialEq, Eq)]\n+    enum Classification {\n+        Literal,\n+        Simple,\n+        Complex,\n+    }\n \n-    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&hir, body.hir_id))\n+    use Classification::*;\n+\n+    fn classify(expr: &hir::Expr<'_>) -> Classification {\n+        match &expr.kind {\n+            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                if matches!(expr.kind, hir::ExprKind::Lit(_)) { Literal } else { Complex }\n+            }\n+            hir::ExprKind::Lit(_) => Literal,\n+            hir::ExprKind::Tup([]) => Simple,\n+            hir::ExprKind::Block(hir::Block { stmts: [], expr: Some(expr), .. }, _) => {\n+                if classify(expr) == Complex { Complex } else { Simple }\n+            }\n+            // Paths with a self-type or arguments are too \u201ccomplex\u201d following our measure since\n+            // they may leak private fields of structs (with feature `adt_const_params`).\n+            // Consider: `<Self as Trait<{ Struct { private: () } }>>::CONSTANT`.\n+            // Paths without arguments are definitely harmless though.\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, hir::Path { segments, .. })) => {\n+                if segments.iter().all(|segment| segment.args.is_none()) { Simple } else { Complex }\n+            }\n+            // FIXME: Claiming that those kinds of QPaths are simple is probably not true if the Ty\n+            //        contains const arguments. Is there a *concise* way to check for this?\n+            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => Simple,\n+            // FIXME: Can they contain const arguments and thus leak private struct fields?\n+            hir::ExprKind::Path(hir::QPath::LangItem(..)) => Simple,\n+            _ => Complex,\n+        }\n+    }\n+\n+    let classification = classify(value);\n+\n+    if classification == Literal\n+    && !value.span.from_expansion()\n+    && let Ok(snippet) = tcx.sess.source_map().span_to_snippet(value.span) {\n+        // For literals, we avoid invoking the pretty-printer and use the source snippet instead to\n+        // preserve certain stylistic choices the user likely made for the sake legibility like\n+        //\n+        // * hexadecimal notation\n+        // * underscores\n+        // * character escapes\n+        //\n+        // FIXME: This passes through `-/*spacer*/0` verbatim.\n+        snippet\n+    } else if classification == Simple {\n+        // Otherwise we prefer pretty-printing to get rid of extraneous whitespace, comments and\n+        // other formatting artifacts.\n+        rustc_hir_pretty::id_to_string(&hir, body.hir_id)\n+    } else if tcx.def_kind(hir.body_owner_def_id(body).to_def_id()) == DefKind::AnonConst {\n+        // FIXME: Omit the curly braces if the enclosing expression is an array literal\n+        //        with a repeated element (an `ExprKind::Repeat`) as in such case it\n+        //        would not actually need any disambiguation.\n+        \"{ _ }\".to_owned()\n+    } else {\n+        \"_\".to_owned()\n+    }\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "548f6c3a98729a13b908104272c8bfab0d30d981", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -716,12 +716,14 @@ fn assoc_const(\n         ty = ty.print(cx),\n     );\n     if let Some(default) = default {\n+        write!(w, \" = \");\n+\n         // FIXME: `.value()` uses `clean::utils::format_integer_with_underscore_sep` under the\n         //        hood which adds noisy underscores and a type suffix to number literals.\n         //        This hurts readability in this context especially when more complex expressions\n         //        are involved and it doesn't add much of value.\n         //        Find a way to print constants here without all that jazz.\n-        write!(w, \" = {}\", default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx())));\n+        write!(w, \"{}\", Escape(&default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx()))));\n     }\n }\n "}, {"sha": "fe00f952e043cda1e12b4698afda4e88983c627b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1360,6 +1360,15 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n                 typ = c.type_.print(cx),\n             );\n \n+            // FIXME: The code below now prints\n+            //            ` = _; // 100i32`\n+            //        if the expression is\n+            //            `50 + 50`\n+            //        which looks just wrong.\n+            //        Should we print\n+            //            ` = 100i32;`\n+            //        instead?\n+\n             let value = c.value(cx.tcx());\n             let is_literal = c.is_literal(cx.tcx());\n             let expr = c.expr(cx.tcx());"}, {"sha": "fcd925bb3582f40a1548b4a5d32392a385dff72a", "filename": "src/librustdoc/html/static/.eslintrc.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -91,5 +91,6 @@ module.exports = {\n         \"no-script-url\": \"error\",\n         \"no-sequences\": \"error\",\n         \"no-throw-literal\": \"error\",\n+        \"no-div-regex\": \"error\",\n     }\n };"}, {"sha": "f2533e4146a84fe1eb19ba8bc661f54ed96adda7", "filename": "src/test/incremental/split_debuginfo_mode.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fincremental%2Fsplit_debuginfo_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fincremental%2Fsplit_debuginfo_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fsplit_debuginfo_mode.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -0,0 +1,33 @@\n+// This test case makes sure that changing split-debuginfo commandline options triggers a full re-compilation.\n+// We only test on x86_64-unknown-linux-gnu because there all combinations split-debuginfo settings are valid\n+// and the test is platform-independent otherwise.\n+\n+// ignore-tidy-linelength\n+// only-x86_64-unknown-linux-gnu\n+// revisions:rpass1 rpass2 rpass3 rpass4\n+\n+// [rpass1]compile-flags: -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=unpacked -Zsplit-dwarf-kind=single -Zsplit-dwarf-inlining=on\n+// [rpass2]compile-flags: -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=single -Zsplit-dwarf-inlining=on\n+// [rpass3]compile-flags: -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split -Zsplit-dwarf-inlining=on\n+// [rpass4]compile-flags: -Zquery-dep-graph -Zunstable-options -Csplit-debuginfo=packed -Zsplit-dwarf-kind=split -Zsplit-dwarf-inlining=off\n+\n+#![feature(rustc_attrs)]\n+// For rpass2 we change -Csplit-debuginfo and thus expect every CGU to be recompiled\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode\", cfg = \"rpass2\")]\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode-another_module\", cfg = \"rpass2\")]\n+// For rpass3 we change -Zsplit-dwarf-kind and thus also expect every CGU to be recompiled\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode\", cfg = \"rpass3\")]\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode-another_module\", cfg = \"rpass3\")]\n+// For rpass4 we change -Zsplit-dwarf-inlining and thus also expect every CGU to be recompiled\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode\", cfg = \"rpass4\")]\n+#![rustc_partition_codegened(module = \"split_debuginfo_mode-another_module\", cfg = \"rpass4\")]\n+\n+mod another_module {\n+    pub fn foo() -> &'static str {\n+        \"hello world\"\n+    }\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", another_module::foo());\n+}"}, {"sha": "a79e93145ba7db99905043b11be0b3ab8b764a83", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -27,6 +27,10 @@ impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAR\"]' \\\n     //      'const BAR: usize'\n     pub const BAR: usize = 3;\n+\n+    // @has - '//*[@id=\"associatedconstant.BAR_ESCAPED\"]' \\\n+    //      \"const BAR_ESCAPED: &'static str = \\\"<em>markup</em>\\\"\"\n+    pub const BAR_ESCAPED: &'static str = \"<em>markup</em>\";\n }\n \n pub struct Baz<'a, U: 'a, T>(T, &'a [U]);"}, {"sha": "5b2f3c48d57fa8a847024b3ad88397927c083ae8", "filename": "src/test/rustdoc/const-value-display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-value-display.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/constant.HOUR_IN_SECONDS.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = 60 * 60; // 3_600u64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = _; // 3_600u64'\n pub const HOUR_IN_SECONDS: u64 = 60 * 60;\n \n // @has 'foo/constant.NEGATIVE.html'\n-// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = -60 * 60; // -3_600i64'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = _; // -3_600i64'\n pub const NEGATIVE: i64 = -60 * 60;"}, {"sha": "644a6e1cf33c52324035a5dd9d8beaaed3290d16", "filename": "src/test/rustdoc/hide-complex-unevaluated-const-arguments.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-const-arguments.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -0,0 +1,82 @@\n+// Test that certain unevaluated constant expression arguments that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+#![feature(const_trait_impl, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+// @has hide_complex_unevaluated_const_arguments/trait.Stage.html\n+pub trait Stage {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: usize;\n+\n+    // Currently considered \"overly complex\" by the `generic_const_exprs`\n+    // feature. If / once this expression kind gets supported, this\n+    // unevaluated const expression could leak the private struct field.\n+    //\n+    // FIXME: Once the line below compiles, make this a test that\n+    //        ensures that the private field is not printed.\n+    //\n+    //const ARRAY0: [u8; Struct { private: () } + Self::ABSTRACT];\n+\n+    // This assoc. const could leak the private assoc. function `Struct::new`.\n+    // Ensure that this does not happen.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARRAY1\"]' \\\n+    //        'const ARRAY1: [u8; { _ }]'\n+    const ARRAY1: [u8; Struct::new(/* ... */) + Self::ABSTRACT * 1_000];\n+\n+    // @has - '//*[@id=\"associatedconstant.VERBOSE\"]' \\\n+    //        'const VERBOSE: [u16; { _ }]'\n+    const VERBOSE: [u16; compute(\"thing\", 9 + 9) * Self::ABSTRACT];\n+\n+    // Check that we do not leak the private struct field contained within\n+    // the path. The output could definitely be improved upon\n+    // (e.g. printing sth. akin to `<Self as Helper<{ _ }>>::OUT`) but\n+    // right now \u201csafe is safe\u201d.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.PATH\"]' \\\n+    //        'const PATH: usize = _'\n+    const PATH: usize = <Self as Helper<{ Struct { private: () } }>>::OUT;\n+}\n+\n+const fn compute(input: &str, extra: usize) -> usize {\n+    input.len() + extra\n+}\n+\n+pub trait Helper<const S: Struct> {\n+    const OUT: usize;\n+}\n+\n+impl<const S: Struct, St: Stage + ?Sized> Helper<S> for St {\n+    const OUT: usize = St::ABSTRACT;\n+}\n+\n+// Currently in rustdoc, const arguments are not evaluated in this position\n+// and therefore they fall under the realm of `print_const_expr`.\n+// If rustdoc gets patched to evaluate const arguments, it is fine to replace\n+// this test as long as one can ensure that private fields are not leaked!\n+//\n+// @has hide_complex_unevaluated_const_arguments/trait.Sub.html \\\n+//      '//*[@class=\"rust trait\"]' \\\n+//      'pub trait Sub: Sup<{ _ }, { _ }> { }'\n+pub trait Sub: Sup<{ 90 * 20 * 4 }, { Struct { private: () } }> {}\n+\n+pub trait Sup<const N: usize, const S: Struct> {}\n+\n+pub struct Struct { private: () }\n+\n+impl Struct {\n+    const fn new() -> Self { Self { private: () } }\n+}\n+\n+impl const std::ops::Add<usize> for Struct {\n+    type Output = usize;\n+\n+    fn add(self, _: usize) -> usize { 0 }\n+}"}, {"sha": "ba623246a01e0da1dea82303ed33a062b0c5ede2", "filename": "src/test/rustdoc/hide-complex-unevaluated-consts.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhide-complex-unevaluated-consts.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -0,0 +1,71 @@\n+// Regression test for issue #97933.\n+//\n+// Test that certain unevaluated constant expressions that are\n+// deemed too verbose or complex and that may leak private or\n+// `doc(hidden)` struct fields are not displayed in the documentation.\n+//\n+// Read the documentation of `rustdoc::clean::utils::print_const_expr`\n+// for further details.\n+\n+// @has hide_complex_unevaluated_consts/trait.Container.html\n+pub trait Container {\n+    // A helper constant that prevents const expressions containing it\n+    // from getting fully evaluated since it doesn't have a body and\n+    // thus is non-reducible. This allows us to specifically test the\n+    // pretty-printing of *unevaluated* consts.\n+    const ABSTRACT: i32;\n+\n+    // Ensure that the private field does not get leaked:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT0\"]' \\\n+    //        'const STRUCT0: Struct = _'\n+    const STRUCT0: Struct = Struct { private: () };\n+\n+    // @has - '//*[@id=\"associatedconstant.STRUCT1\"]' \\\n+    //        'const STRUCT1: (Struct,) = _'\n+    const STRUCT1: (Struct,) = (Struct{private: /**/()},);\n+\n+    // Although the struct field is public here, check that it is not\n+    // displayed. In a future version of rustdoc, we definitely want to\n+    // show it. However for the time being, the printing logic is a bit\n+    // conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.STRUCT2\"]' \\\n+    //        'const STRUCT2: Record = _'\n+    const STRUCT2: Record = Record { public: 5 };\n+\n+    // Test that we do not show the incredibly verbose match expr:\n+    //\n+    // @has - '//*[@id=\"associatedconstant.MATCH0\"]' \\\n+    //        'const MATCH0: i32 = _'\n+    const MATCH0: i32 = match 234 {\n+        0 => 1,\n+        _ => Self::ABSTRACT,\n+    };\n+\n+    // @has - '//*[@id=\"associatedconstant.MATCH1\"]' \\\n+    //        'const MATCH1: bool = _'\n+    const MATCH1: bool = match Self::ABSTRACT {\n+        _ => true,\n+    };\n+\n+    // Check that we hide complex (arithmetic) operations.\n+    // In this case, it is a bit unfortunate since the expression\n+    // is not *that* verbose and it might be quite useful to the reader.\n+    //\n+    // However in general, the expression might be quite large and\n+    // contain match expressions and structs with private fields.\n+    // We would need to recurse over the whole expression and even more\n+    // importantly respect operator precedence when pretty-printing\n+    // the potentially partially censored expression.\n+    // For now, the implementation is quite simple and the choices\n+    // rather conservative.\n+    //\n+    // @has - '//*[@id=\"associatedconstant.ARITH_OPS\"]' \\\n+    //        'const ARITH_OPS: i32 = _'\n+    const ARITH_OPS: i32 = Self::ABSTRACT * 2 + 1;\n+}\n+\n+pub struct Struct { private: () }\n+\n+pub struct Record { pub public: i32 }"}, {"sha": "48b60885974afc7542ddcde7241d95f213f0c458", "filename": "src/test/rustdoc/show-const-contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -21,7 +21,7 @@ pub const CONST_NEG_I32: i32 = -42;\n // @!has show_const_contents/constant.CONST_EQ_TO_VALUE_I32.html '// 42i32'\n pub const CONST_EQ_TO_VALUE_I32: i32 = 42i32;\n \n-// @has show_const_contents/constant.CONST_CALC_I32.html '= 42 + 1; // 43i32'\n+// @has show_const_contents/constant.CONST_CALC_I32.html '= _; // 43i32'\n pub const CONST_CALC_I32: i32 = 42 + 1;\n \n // @!has show_const_contents/constant.CONST_REF_I32.html '= &42;'"}, {"sha": "a751ba793472e6aae0459c3746f5a8f7c619c301", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,8 +1,8 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[54ea]::Id::This) }, Ty((I,))), [])`\n-  --> $DIR/repeated_projection_type.rs:19:1\n+error: cannot specialize on associated type `<V as Id>::This == (I,)`\n+  --> $DIR/repeated_projection_type.rs:19:15\n    |\n LL | impl<I, V: Id<This = (I,)>> X for V {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ba9d6bbe300117b42622512c7d3ef2d5b83cc94c", "filename": "src/test/ui/specialization/min_specialization/spec-marker-supertraits.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-marker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-marker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspec-marker-supertraits.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,8 +1,8 @@\n error: cannot specialize on trait `HasMethod`\n-  --> $DIR/spec-marker-supertraits.rs:22:1\n+  --> $DIR/spec-marker-supertraits.rs:22:9\n    |\n LL | impl<T: Marker> Spec for T {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e935786624b4bb87463e7b4795340e2e4c3d5502", "filename": "src/test/ui/specialization/min_specialization/specialization_super_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,8 +1,8 @@\n error: cannot specialize on trait `Default`\n-  --> $DIR/specialization_super_trait.rs:13:1\n+  --> $DIR/specialization_super_trait.rs:13:9\n    |\n LL | impl<T: Default> SpecMarker for T {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "bc87ae0f8b847f32ef31e4861ee9b93fa59f6a7c", "filename": "src/test/ui/specialization/min_specialization/specialization_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_trait.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -11,10 +11,10 @@ LL | impl<T> SpecMarker for (T, T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot specialize on trait `Clone`\n-  --> $DIR/specialization_trait.rs:21:1\n+  --> $DIR/specialization_trait.rs:21:9\n    |\n LL | impl<T: Clone> SpecMarker for [T] {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7b79c7eb4ad1c3672b637e49a199978b7d71c86c", "filename": "src/test/ui/specialization/min_specialization/specialize_on_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialize_on_trait.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,8 +1,8 @@\n error: cannot specialize on trait `SpecMarker`\n-  --> $DIR/specialize_on_trait.rs:15:1\n+  --> $DIR/specialize_on_trait.rs:15:9\n    |\n LL | impl<T: SpecMarker> X for T {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "496c305bc2aff4947a999342447dfceae16b2e34", "filename": "src/test/ui/suggestions/suggest-on-bare-closure-call.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,4 +1,11 @@\n+// edition:2021\n+\n+#![feature(async_closure)]\n+\n fn main() {\n     let _ = ||{}();\n     //~^ ERROR expected function, found `()`\n+\n+    let _ = async ||{}();\n+    //~^ ERROR expected function, found `()`\n }"}, {"sha": "e65a6eb4939d9b6c3810dbb55a74e3bacbfd7c55", "filename": "src/test/ui/suggestions/suggest-on-bare-closure-call.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-on-bare-closure-call.stderr?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -1,5 +1,5 @@\n error[E0618]: expected function, found `()`\n-  --> $DIR/suggest-on-bare-closure-call.rs:2:15\n+  --> $DIR/suggest-on-bare-closure-call.rs:6:15\n    |\n LL |     let _ = ||{}();\n    |               ^^--\n@@ -11,6 +11,19 @@ help: if you meant to create this closure and immediately call it, surround the\n LL |     let _ = (||{})();\n    |             +    +\n \n-error: aborting due to previous error\n+error[E0618]: expected function, found `()`\n+  --> $DIR/suggest-on-bare-closure-call.rs:9:21\n+   |\n+LL |     let _ = async ||{}();\n+   |                     ^^--\n+   |                     |\n+   |                     call expression requires function\n+   |\n+help: if you meant to create this closure and immediately call it, surround the closure with parentheses\n+   |\n+LL |     let _ = (async ||{})();\n+   |             +          +\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0618`."}, {"sha": "9615c4db6b4b51c4fc09fcdaa8f250539ee71415", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -96,9 +96,25 @@ mod os_impl {\n \n     #[cfg(unix)]\n     pub fn check(path: &Path, bad: &mut bool) {\n+        const ALLOWED: &[&str] = &[\"configure\"];\n+\n         crate::walk_no_read(\n             path,\n-            &mut |path| crate::filter_dirs(path) || path.ends_with(\"src/etc\"),\n+            &mut |path| {\n+                crate::filter_dirs(path)\n+                    || path.ends_with(\"src/etc\")\n+                    // This is a list of directories that we almost certainly\n+                    // don't need to walk. A future PR will likely want to\n+                    // remove these in favor of crate::walk_no_read using git\n+                    // ls-files to discover the paths we should check, which\n+                    // would naturally ignore all of these directories. It's\n+                    // also likely faster than walking the directory tree\n+                    // directly (since git is just reading from a couple files\n+                    // to produce the results).\n+                    || path.ends_with(\"target\")\n+                    || path.ends_with(\"build\")\n+                    || path.ends_with(\".git\")\n+            },\n             &mut |entry| {\n                 let file = entry.path();\n                 let filename = file.file_name().unwrap().to_string_lossy();\n@@ -110,6 +126,11 @@ mod os_impl {\n                 if t!(is_executable(&file), file) {\n                     let rel_path = file.strip_prefix(path).unwrap();\n                     let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n+\n+                    if ALLOWED.contains(&git_friendly_path.as_str()) {\n+                        return;\n+                    }\n+\n                     let output = Command::new(\"git\")\n                         .arg(\"ls-files\")\n                         .arg(&git_friendly_path)"}, {"sha": "aa8d8b4f64d7d0ee3a4e4f5f524480809e8af69b", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d1848cc60a407d06f90fd16877a19bed6edd9b/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=e1d1848cc60a407d06f90fd16877a19bed6edd9b", "patch": "@@ -78,13 +78,8 @@ fn main() {\n         check!(unit_tests, &compiler_path);\n         check!(unit_tests, &library_path);\n \n-        if bins::check_filesystem_support(\n-            &[&src_path, &compiler_path, &library_path],\n-            &output_directory,\n-        ) {\n-            check!(bins, &src_path);\n-            check!(bins, &compiler_path);\n-            check!(bins, &library_path);\n+        if bins::check_filesystem_support(&[&root_path], &output_directory) {\n+            check!(bins, &root_path);\n         }\n \n         check!(style, &src_path);"}]}