{"sha": "d53bf7a67657fc585e13d14cf5023b5ebdf81021", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1M2JmN2E2NzY1N2ZjNTg1ZTEzZDE0Y2Y1MDIzYjVlYmRmODEwMjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T15:11:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T16:43:03Z"}, "message": "Make rustc::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region} free functions.", "tree": {"sha": "91a2b6fa68a1eb96c04782e6d81864794939c3da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a2b6fa68a1eb96c04782e6d81864794939c3da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d53bf7a67657fc585e13d14cf5023b5ebdf81021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d53bf7a67657fc585e13d14cf5023b5ebdf81021", "html_url": "https://github.com/rust-lang/rust/commit/d53bf7a67657fc585e13d14cf5023b5ebdf81021", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d53bf7a67657fc585e13d14cf5023b5ebdf81021/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7118e33bfd3313c850b0656fb9d4a655fb450410", "url": "https://api.github.com/repos/rust-lang/rust/commits/7118e33bfd3313c850b0656fb9d4a655fb450410", "html_url": "https://github.com/rust-lang/rust/commit/7118e33bfd3313c850b0656fb9d4a655fb450410"}], "stats": {"total": 289, "additions": 164, "deletions": 125}, "files": [{"sha": "5c2bafd5ae8d7a5b37ac51c1ed087840d6512902", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 89, "deletions": 88, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d53bf7a67657fc585e13d14cf5023b5ebdf81021", "patch": "@@ -79,98 +79,95 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_region(\n-        self,\n-        region_scope_tree: &region::ScopeTree,\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        region: ty::Region<'tcx>,\n-        suffix: &str,\n-    ) {\n-        let (description, span) = match *region {\n-            ty::ReScope(scope) => {\n-                let new_string;\n-                let unknown_scope = || {\n-                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix)\n-                };\n-                let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir().find(scope.hir_id(region_scope_tree)) {\n-                    Some(Node::Block(_)) => \"block\",\n-                    Some(Node::Expr(expr)) => match expr.kind {\n-                        hir::ExprKind::Call(..) => \"call\",\n-                        hir::ExprKind::MethodCall(..) => \"method call\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                        hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                        hir::ExprKind::Match(..) => \"match\",\n-                        _ => \"expression\",\n-                    },\n-                    Some(Node::Stmt(_)) => \"statement\",\n-                    Some(Node::Item(it)) => item_scope_tag(&it),\n-                    Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n-                    Some(_) | None => {\n-                        err.span_note(span, &unknown_scope());\n-                        return;\n-                    }\n-                };\n-                let scope_decorated_tag = match scope.data {\n-                    region::ScopeData::Node => tag,\n-                    region::ScopeData::CallSite => \"scope of call-site for function\",\n-                    region::ScopeData::Arguments => \"scope of function body\",\n-                    region::ScopeData::Destruction => {\n-                        new_string = format!(\"destruction scope surrounding {}\", tag);\n-                        &new_string[..]\n-                    }\n-                    region::ScopeData::Remainder(first_statement_index) => {\n-                        new_string = format!(\n-                            \"block suffix following statement {}\",\n-                            first_statement_index.index()\n-                        );\n-                        &new_string[..]\n-                    }\n-                };\n-                explain_span(self, scope_decorated_tag, span)\n-            }\n+pub(super) fn note_and_explain_region(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: &region::ScopeTree,\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    region: ty::Region<'tcx>,\n+    suffix: &str,\n+) {\n+    let (description, span) = match *region {\n+        ty::ReScope(scope) => {\n+            let new_string;\n+            let unknown_scope =\n+                || format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix);\n+            let span = scope.span(tcx, region_scope_tree);\n+            let tag = match tcx.hir().find(scope.hir_id(region_scope_tree)) {\n+                Some(Node::Block(_)) => \"block\",\n+                Some(Node::Expr(expr)) => match expr.kind {\n+                    hir::ExprKind::Call(..) => \"call\",\n+                    hir::ExprKind::MethodCall(..) => \"method call\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                    hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n+                    hir::ExprKind::Match(..) => \"match\",\n+                    _ => \"expression\",\n+                },\n+                Some(Node::Stmt(_)) => \"statement\",\n+                Some(Node::Item(it)) => item_scope_tag(&it),\n+                Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n+                Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+                Some(_) | None => {\n+                    err.span_note(span, &unknown_scope());\n+                    return;\n+                }\n+            };\n+            let scope_decorated_tag = match scope.data {\n+                region::ScopeData::Node => tag,\n+                region::ScopeData::CallSite => \"scope of call-site for function\",\n+                region::ScopeData::Arguments => \"scope of function body\",\n+                region::ScopeData::Destruction => {\n+                    new_string = format!(\"destruction scope surrounding {}\", tag);\n+                    &new_string[..]\n+                }\n+                region::ScopeData::Remainder(first_statement_index) => {\n+                    new_string = format!(\n+                        \"block suffix following statement {}\",\n+                        first_statement_index.index()\n+                    );\n+                    &new_string[..]\n+                }\n+            };\n+            explain_span(tcx, scope_decorated_tag, span)\n+        }\n \n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n-                msg_span_from_free_region(self, region)\n-            }\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n+            msg_span_from_free_region(tcx, region)\n+        }\n \n-            ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n+        ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n-            // FIXME(#13998) RePlaceholder should probably print like\n-            // ReFree rather than dumping Debug output on the user.\n-            //\n-            // We shouldn't really be having unification failures with ReVar\n-            // and ReLateBound though.\n-            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n-                (format!(\"lifetime {:?}\", region), None)\n-            }\n+        // FIXME(#13998) RePlaceholder should probably print like\n+        // ReFree rather than dumping Debug output on the user.\n+        //\n+        // We shouldn't really be having unification failures with ReVar\n+        // and ReLateBound though.\n+        ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+            (format!(\"lifetime {:?}\", region), None)\n+        }\n \n-            // We shouldn't encounter an error message with ReClosureBound.\n-            ty::ReClosureBound(..) => {\n-                bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n-            }\n-        };\n+        // We shouldn't encounter an error message with ReClosureBound.\n+        ty::ReClosureBound(..) => {\n+            bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n+        }\n+    };\n \n-        emit_msg_span(err, prefix, description, span, suffix);\n-    }\n+    emit_msg_span(err, prefix, description, span, suffix);\n+}\n \n-    pub fn note_and_explain_free_region(\n-        self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        region: ty::Region<'tcx>,\n-        suffix: &str,\n-    ) {\n-        let (description, span) = msg_span_from_free_region(self, region);\n+pub(super) fn note_and_explain_free_region(\n+    tcx: TyCtxt<'tcx>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    region: ty::Region<'tcx>,\n+    suffix: &str,\n+) {\n+    let (description, span) = msg_span_from_free_region(tcx, region);\n \n-        emit_msg_span(err, prefix, description, span, suffix);\n-    }\n+    emit_msg_span(err, prefix, description, span, suffix);\n }\n \n fn msg_span_from_free_region(\n@@ -1719,7 +1716,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"consider adding an explicit lifetime bound for `{}`\",\n                     bound_kind\n                 ));\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1747,7 +1745,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(\n+        note_and_explain_region(\n+            self.tcx,\n             region_scope_tree,\n             &mut err,\n             \"first, the lifetime cannot outlive \",\n@@ -1771,7 +1770,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n                 {\n                     if sub_expected == sup_expected && sub_found == sup_found {\n-                        self.tcx.note_and_explain_region(\n+                        note_and_explain_region(\n+                            self.tcx,\n                             region_scope_tree,\n                             &mut err,\n                             \"...but the lifetime must also be valid for \",\n@@ -1794,7 +1794,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(\n+        note_and_explain_region(\n+            self.tcx,\n             region_scope_tree,\n             &mut err,\n             \"but, the lifetime must be valid for \","}, {"sha": "7919274c373224678b3e058d6d9a92218a17faa2", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d53bf7a67657fc585e13d14cf5023b5ebdf81021", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use crate::middle::region;\n use crate::ty::error::TypeError;\n@@ -167,8 +168,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(self.tcx, region_scope_tree, &mut err, \"\", sup, \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...does not necessarily outlive \",\n@@ -185,14 +187,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...but the borrowed content is only valid for \",\n@@ -211,14 +215,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 of captured variable `{}`...\",\n                     var_name\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \", var_name),\n@@ -230,14 +236,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...the closure must be valid for \",\n                     sub,\n                     \"...\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"...but the closure's stack frame is only valid \\\n@@ -254,7 +262,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0315,\n                     \"cannot invoke closure outside of its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the closure is only valid for \",\n@@ -270,7 +279,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0473,\n                     \"dereference of reference outside its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the reference is only valid for \",\n@@ -288,14 +298,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 enclosing closure\",\n                     self.tcx.hir().name(id)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"captured variable is valid for \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"closure is valid for \",\n@@ -311,7 +323,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0475,\n                     \"index of slice outside its lifetime\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the slice is only valid for \",\n@@ -328,14 +341,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"object type is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"source pointer is only valid for \",\n@@ -354,14 +369,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n-                    ty::ReStatic => self.tcx.note_and_explain_region(\n+                    ty::ReStatic => note_and_explain_region(\n+                        self.tcx,\n                         region_scope_tree,\n                         &mut err,\n                         \"type must satisfy \",\n                         sub,\n                         \"\",\n                     ),\n-                    _ => self.tcx.note_and_explain_region(\n+                    _ => note_and_explain_region(\n+                        self.tcx,\n                         region_scope_tree,\n                         &mut err,\n                         \"type must outlive \",\n@@ -374,14 +391,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but lifetime parameter must outlive \",\n@@ -399,7 +418,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 parameter) is not valid at this point\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"type must outlive \",\n@@ -416,7 +436,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of method receiver does not outlive the \\\n                                                 method call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the receiver is only valid for \",\n@@ -433,7 +454,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of function argument does not outlive \\\n                                                 the function call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the function argument is only valid for \",\n@@ -450,7 +472,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of return value does not outlive the \\\n                                                 function call\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the return value is only valid for \",\n@@ -467,7 +490,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of operand does not outlive the \\\n                                                 operation\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the operand is only valid for \",\n@@ -483,7 +507,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0484,\n                     \"reference is not valid at the time of borrow\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the borrow is only valid for \",\n@@ -500,7 +525,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"automatically reference is not valid at the time \\\n                                                 of borrow\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the automatic borrow is only valid for \",\n@@ -518,7 +544,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 not valid during the expression: `{}`\",\n                     self.ty_to_string(t)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"type is only valid for \",\n@@ -536,14 +563,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 called while references are dead\"\n                 );\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"superregion: \",\n                     sup,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"subregion: \",\n@@ -560,7 +589,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of variable does not enclose its \\\n                                                 declaration\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the variable is only valid for \",\n@@ -576,7 +606,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     E0489,\n                     \"type/lifetime parameter not in scope here\"\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the parameter is only valid for \",\n@@ -593,14 +624,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"a value of type `{}` is borrowed for too long\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the type is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but the borrow lasts for \",\n@@ -618,14 +651,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 than the data it references\",\n                     self.ty_to_string(ty)\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"the pointer is valid for \",\n                     sub,\n                     \"\",\n                 );\n-                self.tcx.note_and_explain_region(\n+                note_and_explain_region(\n+                    self.tcx,\n                     region_scope_tree,\n                     &mut err,\n                     \"but the referenced data is only valid for \","}, {"sha": "834b8e8e72e02d456572453a4062800b3aedbc5a", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53bf7a67657fc585e13d14cf5023b5ebdf81021/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=d53bf7a67657fc585e13d14cf5023b5ebdf81021", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::middle::region;\n@@ -624,7 +625,8 @@ pub fn unexpected_hidden_region_diagnostic(\n         //\n         // (*) if not, the `tainted_by_errors` flag would be set to\n         // true in any case, so we wouldn't be here at all.\n-        tcx.note_and_explain_free_region(\n+        note_and_explain_free_region(\n+            tcx,\n             &mut err,\n             &format!(\"hidden type `{}` captures \", hidden_ty),\n             hidden_region,\n@@ -649,7 +651,8 @@ pub fn unexpected_hidden_region_diagnostic(\n             // If the `region_scope_tree` is available, this is being\n             // invoked from the \"region inferencer error\". We can at\n             // least report a really cryptic error for now.\n-            tcx.note_and_explain_region(\n+            note_and_explain_region(\n+                tcx,\n                 region_scope_tree,\n                 &mut err,\n                 &format!(\"hidden type `{}` captures \", hidden_ty),"}]}