{"sha": "0b2436f3a466ff077861665197cf35059c811f48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMjQzNmYzYTQ2NmZmMDc3ODYxNjY1MTk3Y2YzNTA1OWM4MTFmNDg=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-05T15:27:46Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:50:26Z"}, "message": "Move more into decorate functions.", "tree": {"sha": "e9b071c516b130a3ccaffb32f9f146e5121e2b82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b071c516b130a3ccaffb32f9f146e5121e2b82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b2436f3a466ff077861665197cf35059c811f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2436f3a466ff077861665197cf35059c811f48", "html_url": "https://github.com/rust-lang/rust/commit/0b2436f3a466ff077861665197cf35059c811f48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b2436f3a466ff077861665197cf35059c811f48/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa3c458c067b399e1f115281f77b7f33513d5920", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3c458c067b399e1f115281f77b7f33513d5920", "html_url": "https://github.com/rust-lang/rust/commit/aa3c458c067b399e1f115281f77b7f33513d5920"}], "stats": {"total": 109, "additions": 58, "deletions": 51}, "files": [{"sha": "9cc3e39726bd957a110d527921beb702607425e7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -645,15 +645,15 @@ impl EarlyLintPass for AnonymousParameters {\n                     match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {\n                             if ident.name == kw::Invalid {\n-                                let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n+                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n+                                    let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n \n-                                let (ty_snip, appl) = if let Ok(snip) = ty_snip {\n-                                    (snip, Applicability::MachineApplicable)\n-                                } else {\n-                                    (\"<type>\".to_owned(), Applicability::HasPlaceholders)\n-                                };\n+                                    let (ty_snip, appl) = if let Ok(snip) = ty_snip {\n+                                        (snip, Applicability::MachineApplicable)\n+                                    } else {\n+                                        (\"<type>\".to_owned(), Applicability::HasPlaceholders)\n+                                    };\n \n-                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n                                     lint.build(\n                                         \"anonymous parameters are deprecated and will be \\\n                                      removed in the next edition.\",\n@@ -869,8 +869,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 if attr::contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    let msg = \"const items should never be `#[no_mangle]`\";\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n+                        let msg = \"const items should never be `#[no_mangle]`\";\n                         let mut err = lint.build(msg);\n \n                         // account for \"pub const\" (#45562)\n@@ -910,11 +910,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n-        let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n-                   consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+                    let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n+                               consider instead using an UnsafeCell\";\n                     cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n                         lint.build(msg).emit()\n                     });\n@@ -1335,12 +1335,12 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             let suggestion = \"use `..=` for an inclusive range\";\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n-                let end = expr_to_string(&end);\n-                let replace = match start {\n-                    Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n-                    None => format!(\"&(..={})\", end),\n-                };\n                 cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, |lint| {\n+                    let end = expr_to_string(&end);\n+                    let replace = match start {\n+                        Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n+                        None => format!(\"&(..={})\", end),\n+                    };\n                     lint.build(msg)\n                         .span_suggestion(\n                             pat.span,"}, {"sha": "7875261911201bf784c73cec388e61f5ccbd4eeb", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -37,9 +37,9 @@ impl_lint_pass!(DefaultHashTypes => [DEFAULT_HASH_TYPES]);\n impl EarlyLintPass for DefaultHashTypes {\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         if let Some(replace) = self.map.get(&ident.name) {\n-            // FIXME: We can avoid a copy here. Would require us to take String instead of &str.\n-            let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n             cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, |lint| {\n+                // FIXME: We can avoid a copy here. Would require us to take String instead of &str.\n+                let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n                 lint.build(&msg)\n                     .span_suggestion(\n                         ident.span,"}, {"sha": "da449ed42fd0051ed371024661e04f689a990da8", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -234,19 +234,19 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                                 let (lvl, src) =\n                                     self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                                let msg = format!(\n-                                    \"lint name `{}` is deprecated \\\n-                                     and may not have an effect in the future. \\\n-                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n-                                    name\n-                                );\n                                 struct_lint_level(\n                                     self.sess,\n                                     lint,\n                                     lvl,\n                                     src,\n                                     Some(li.span().into()),\n                                     |lint| {\n+                                        let msg = format!(\n+                                            \"lint name `{}` is deprecated \\\n+                                             and may not have an effect in the future. \\\n+                                             Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n+                                            name\n+                                        );\n                                         lint.build(&msg)\n                                             .span_suggestion(\n                                                 li.span(),\n@@ -306,15 +306,14 @@ impl<'s> LintLevelsBuilder<'s> {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n-                        let msg = format!(\"unknown lint: `{}`\", name);\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n                             src,\n                             Some(li.span().into()),\n                             |lint| {\n-                                let mut db = lint.build(&msg);\n+                                let mut db = lint.build(&format!(\"unknown lint: `{}`\", name));\n                                 if let Some(suggestion) = suggestion {\n                                     db.span_suggestion(\n                                         li.span(),"}, {"sha": "480df99a01eedeea52c5ff1a3796978693cac4f8", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -202,6 +202,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         // Returns whether an error has been emitted (and thus another does not need to be later).\n+        // FIXME: Args desc_{pre,post}_path could be made lazy by taking Fn() -> &str, but this\n+        // would make calling it a big awkward. Could also take String (so args are moved), but\n+        // this would still require a copy into the format string, which would only be executed\n+        // when needed.\n         fn check_must_use_def(\n             cx: &LateContext<'_, '_>,\n             def_id: DefId,"}, {"sha": "82a9c631b727e6ff0c49ecccae5dc013484cd0b5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -378,8 +378,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n             continue;\n         }\n \n-        let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n         tcx.struct_span_lint_hir(UNUSED_MUT, lint_root, span, |lint| {\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n             lint.build(\"variable does not need to be mutable\")\n                 .span_suggestion_short(\n                     mut_span,"}, {"sha": "6e80338c975eddacde1464053dbfc566baaef810", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -516,18 +516,18 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n         .as_local_hir_id(def_id)\n         .unwrap_or_else(|| bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n-    // FIXME: when we make this a hard error, this should have its\n-    // own error code.\n-    let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-        \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-         type or const parameters (error E0133)\"\n-            .to_string()\n-    } else {\n-        \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-         does not derive Copy (error E0133)\"\n-            .to_string()\n-    };\n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        // FIXME: when we make this a hard error, this should have its\n+        // own error code.\n+        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n+             type or const parameters (error E0133)\"\n+                .to_string()\n+        } else {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n+             does not derive Copy (error E0133)\"\n+                .to_string()\n+        };\n         lint.build(&message).emit()\n     });\n }\n@@ -560,8 +560,8 @@ fn is_enclosed(\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n-    let msg = \"unnecessary `unsafe` block\";\n     tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n+        let msg = \"unnecessary `unsafe` block\";\n         let mut db = lint.build(msg);\n         db.span_label(span, msg);\n         if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {"}, {"sha": "14c0db2def285ff759eb1e4662223c9387f576ba", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -556,12 +556,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n             if r_bits.map_or(false, |b| b >= left_bits as u128) {\n                 let lint_root = self.lint_root(source_info)?;\n-                let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n                 self.tcx.struct_span_lint_hir(\n                     ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n                     lint_root,\n                     source_info.span,\n-                    |lint| lint.build(&format!(\"attempt to shift {} with overflow\", dir)).emit(),\n+                    |lint| {\n+                        let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n+                        lint.build(&format!(\"attempt to shift {} with overflow\", dir)).emit()\n+                    },\n                 );\n                 return None;\n             }"}, {"sha": "651f2f70d9bfb7ba32f9b2786f38ba27639d8dfa", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -286,12 +286,12 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                             variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                         })\n                     {\n-                        let ty_path = cx.tcx.def_path_str(edef.did);\n                         cx.tcx.struct_span_lint_hir(\n                             BINDINGS_WITH_VARIANT_NAME,\n                             p.hir_id,\n                             p.span,\n                             |lint| {\n+                                let ty_path = cx.tcx.def_path_str(edef.did);\n                                 lint.build(&format!(\n                                     \"pattern binding `{}` is named the same as one \\\n                                                 of the variants of the type `{}`\",\n@@ -338,12 +338,14 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n-    let msg = match source {\n-        hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n-        hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n-        _ => bug!(),\n-    };\n-    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| lint.build(msg).emit());\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| {\n+        let msg = match source {\n+            hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n+            hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+            _ => bug!(),\n+        };\n+        lint.build(msg).emit()\n+    });\n }\n \n /// Check for unreachable patterns."}, {"sha": "ef1e99c5a64be940e744a8c643b1b98cb6d03c50", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2436f3a466ff077861665197cf35059c811f48/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0b2436f3a466ff077861665197cf35059c811f48", "patch": "@@ -1805,12 +1805,12 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n         let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n-            let msg = format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", msg)\n+                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n                 } else {\n-                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", msg)\n+                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n                 };\n                 err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n@@ -1821,7 +1821,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n                     self.span,\n-                    |lint| lint.build(&format!(\"{} (error {})\", msg, err_code)).emit(),\n+                    |lint| lint.build(&format!(\"{} (error {})\", make_msg(), err_code)).emit(),\n                 );\n             }\n         }"}]}