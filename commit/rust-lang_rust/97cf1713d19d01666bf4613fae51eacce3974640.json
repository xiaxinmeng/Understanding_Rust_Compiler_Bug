{"sha": "97cf1713d19d01666bf4613fae51eacce3974640", "node_id": "C_kwDOAAsO6NoAKDk3Y2YxNzEzZDE5ZDAxNjY2YmY0NjEzZmFlNTFlYWNjZTM5NzQ2NDA", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-14T21:16:25Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-19T15:41:11Z"}, "message": "Add enum for fieldless unification", "tree": {"sha": "293fdbfcb3aa19f76bb16ad940978de5ecb5e44d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/293fdbfcb3aa19f76bb16ad940978de5ecb5e44d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97cf1713d19d01666bf4613fae51eacce3974640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97cf1713d19d01666bf4613fae51eacce3974640", "html_url": "https://github.com/rust-lang/rust/commit/97cf1713d19d01666bf4613fae51eacce3974640", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97cf1713d19d01666bf4613fae51eacce3974640/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b51adf6ffa1ae2286ea436eb48cbaa8771886e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b51adf6ffa1ae2286ea436eb48cbaa8771886e6", "html_url": "https://github.com/rust-lang/rust/commit/4b51adf6ffa1ae2286ea436eb48cbaa8771886e6"}], "stats": {"total": 121, "additions": 78, "deletions": 43}, "files": [{"sha": "bc7e8b6a22314fc68c4b2cef037734151f7c0662", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -82,7 +82,7 @@ pub fn expand_deriving_clone(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n@@ -177,7 +177,9 @@ fn cs_clone(\n             all_fields = af;\n             vdata = &variant.data;\n         }\n-        EnumTag(..) => cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,)),\n+        EnumTag(..) | AllFieldlessEnum(..) => {\n+            cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,))\n+        }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, &format!(\"associated function in `derive({})`\", name))\n         }"}, {"sha": "3e994f037ad7aa7e2843b0a271257b679bbab3e4", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -36,7 +36,7 @@ pub fn expand_deriving_eq(\n             nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 cs_total_eq_assert(a, b, c)\n             })),"}, {"sha": "a926fca4e65f8ac21fe7eabd06a1c260d5c0b474", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_ord(\n             nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),"}, {"sha": "9051fe0b28abec750146a6435e0b50c021e99d6f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -76,7 +76,7 @@ pub fn expand_deriving_partial_eq(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty: Path(path_local!(bool)),\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|a, b, c| cs_eq(a, b, c))),\n     }];\n "}, {"sha": "c9dc89212622d70d7d6ddc2bdbfac0093a7bf263", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_partial_ord(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })),"}, {"sha": "a586964d0c321dc993e11bb0028d1dc532df41e9", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -31,7 +31,7 @@ pub fn expand_deriving_debug(\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)\n             })),\n@@ -43,16 +43,17 @@ pub fn expand_deriving_debug(\n }\n \n fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+    // We want to make sure we have the ctxt set so that we can use unstable methods\n+    let span = cx.with_def_site_ctxt(span);\n+\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n-        EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n+        AllFieldlessEnum(..) | EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n \n-    // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_str(span, ident.name);\n     let fmt = substr.nonselflike_args[0].clone();\n "}, {"sha": "5f9519dad1b25e91213e145a4ec768cc376f5d01", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -49,7 +49,7 @@ pub fn expand_deriving_rustc_decodable(\n                 PathKind::Std,\n             )),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "18270747296b8f7c7d8762e141f7c8df88da5f36", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|cx, trait_span, substr| {\n                 match substr.fields {\n                     StaticStruct(_, fields) => {"}, {"sha": "2afeed927ac2c7664d8e941f211f7c3f3bccff74", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -133,7 +133,7 @@ pub fn expand_deriving_rustc_encodable(\n                 PathKind::Std,\n             )),\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "17b7ac0eba1209de55bddbee1ba6087945b409ed", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -222,14 +222,27 @@ pub struct MethodDef<'a> {\n \n     pub attributes: ast::AttrVec,\n \n-    /// Can we combine fieldless variants for enums into a single match arm?\n-    /// If true, indicates that the trait operation uses the enum tag in some\n-    /// way.\n-    pub unify_fieldless_variants: bool,\n+    pub fieldless_variants_strategy: FieldlessVariantsStrategy,\n \n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n+/// How to handle fieldless enum variants.\n+#[derive(PartialEq)]\n+pub enum FieldlessVariantsStrategy {\n+    /// Combine fieldless variants into a single match arm.\n+    /// This assumes that relevant information has been handled\n+    /// by looking at the enum's discriminant.\n+    Unify,\n+    /// Don't do anything special about fieldless variants. They are\n+    /// handled like any other variant.\n+    Default,\n+    /// If all variants of the enum are fieldless, expand the special\n+    /// `AllFieldLessEnum` substructure, so that the entire enum can be handled\n+    /// at once.\n+    SpecializeIfAllVariantsFieldless,\n+}\n+\n /// All the data about the data structure/method being derived upon.\n pub struct Substructure<'a> {\n     /// ident of self\n@@ -264,9 +277,14 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    /// A non-static method with `Self` is a struct.\n+    /// A non-static method where `Self` is a struct.\n     Struct(&'a ast::VariantData, Vec<FieldInfo>),\n \n+    /// A non-static method handling the entire enum at once\n+    /// (after it has been determined that none of the enum\n+    /// variants has any fields).\n+    AllFieldlessEnum(&'a ast::EnumDef),\n+\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n@@ -1086,8 +1104,8 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// Creates a tag check combined with a match for a tuple of all\n     /// `selflike_args`, with an arm for each variant with fields, possibly an\n-    /// arm for each fieldless variant (if `!unify_fieldless_variants` is not\n-    /// true), and possibly a default arm.\n+    /// arm for each fieldless variant (if `unify_fieldless_variants` is not\n+    /// `Unify`), and possibly a default arm.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1101,7 +1119,8 @@ impl<'a> MethodDef<'a> {\n         let variants = &enum_def.variants;\n \n         // Traits that unify fieldless variants always use the tag(s).\n-        let uses_tags = self.unify_fieldless_variants;\n+        let unify_fieldless_variants =\n+            self.fieldless_variants_strategy == FieldlessVariantsStrategy::Unify;\n \n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n@@ -1161,23 +1180,35 @@ impl<'a> MethodDef<'a> {\n         // match is necessary.\n         let all_fieldless = variants.iter().all(|v| v.data.fields().is_empty());\n         if all_fieldless {\n-            if uses_tags && variants.len() > 1 {\n-                // If the type is fieldless and the trait uses the tag and\n-                // there are multiple variants, we need just an operation on\n-                // the tag(s).\n-                let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n-                let mut tag_check = self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonselflike_args,\n-                    &EnumTag(tag_field, None),\n-                );\n-                tag_let_stmts.append(&mut tag_check.0);\n-                return BlockOrExpr(tag_let_stmts, tag_check.1);\n-            }\n-\n-            if variants.len() == 1 {\n+            if variants.len() > 1 {\n+                match self.fieldless_variants_strategy {\n+                    FieldlessVariantsStrategy::Unify => {\n+                        // If the type is fieldless and the trait uses the tag and\n+                        // there are multiple variants, we need just an operation on\n+                        // the tag(s).\n+                        let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n+                        let mut tag_check = self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &EnumTag(tag_field, None),\n+                        );\n+                        tag_let_stmts.append(&mut tag_check.0);\n+                        return BlockOrExpr(tag_let_stmts, tag_check.1);\n+                    }\n+                    FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless => {\n+                        return self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &AllFieldlessEnum(enum_def),\n+                        );\n+                    }\n+                    FieldlessVariantsStrategy::Default => (),\n+                }\n+            } else if variants.len() == 1 {\n                 // If there is a single variant, we don't need an operation on\n                 // the tag(s). Just use the most degenerate result.\n                 return self.call_substructure_method(\n@@ -1187,7 +1218,7 @@ impl<'a> MethodDef<'a> {\n                     nonselflike_args,\n                     &EnumMatching(0, 1, &variants[0], Vec::new()),\n                 );\n-            };\n+            }\n         }\n \n         // These arms are of the form:\n@@ -1198,7 +1229,7 @@ impl<'a> MethodDef<'a> {\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n-            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n+            .filter(|&(_, v)| !(unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n@@ -1249,7 +1280,7 @@ impl<'a> MethodDef<'a> {\n         // Add a default arm to the match, if necessary.\n         let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n         let default = match first_fieldless {\n-            Some(v) if self.unify_fieldless_variants => {\n+            Some(v) if unify_fieldless_variants => {\n                 // We need a default case that handles all the fieldless\n                 // variants. The index and actual variant aren't meaningful in\n                 // this case, so just use dummy values.\n@@ -1296,7 +1327,7 @@ impl<'a> MethodDef<'a> {\n         // If the trait uses the tag and there are multiple variants, we need\n         // to add a tag check operation before the match. Otherwise, the match\n         // is enough.\n-        if uses_tags && variants.len() > 1 {\n+        if unify_fieldless_variants && variants.len() > 1 {\n             let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n \n             // Combine a tag check with the match.\n@@ -1580,5 +1611,6 @@ where\n             }\n         }\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n+        AllFieldlessEnum(..) => cx.span_bug(trait_span, \"fieldless enum in `derive`\"),\n     }\n }"}, {"sha": "f8570d8f86a08dd691fe82dbd23c26518afcde24", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cf1713d19d01666bf4613fae51eacce3974640/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=97cf1713d19d01666bf4613fae51eacce3974640", "patch": "@@ -33,7 +33,7 @@ pub fn expand_deriving_hash(\n             nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)\n             })),"}]}