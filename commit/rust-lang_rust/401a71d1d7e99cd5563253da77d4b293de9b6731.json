{"sha": "401a71d1d7e99cd5563253da77d4b293de9b6731", "node_id": "C_kwDOAAsO6NoAKDQwMWE3MWQxZDdlOTljZDU1NjMyNTNkYTc3ZDRiMjkzZGU5YjY3MzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T12:27:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T12:27:59Z"}, "message": "Auto merge of #12629 - flodiebold:proc-macro-error-improvement, r=Veykril\n\nfix: Improve proc macro errors a bit\n\nDistinguish between\n - there is no build data (for some reason?)\n - there is build data, but the cargo package didn't build a proc macro dylib\n - there is a proc macro dylib, but it didn't contain the proc macro we expected\n - the name did not resolve to any macro (this is now an\n unresolved_macro_call even for attributes)\n\nI changed the handling of disabled attribute macro expansion to\nimmediately ignore the macro and report an unresolved_proc_macro,\nbecause otherwise they would now result in loud unresolved_macro_call\nerrors. I hope this doesn't break anything.\n\nAlso try to improve error ranges for unresolved_macro_call / macro_error\nby reusing the code for unresolved_proc_macro. It's not perfect but\nprobably better than before.", "tree": {"sha": "4b7ce4c5a2201b29ed0cdf180ba845d8542b9948", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b7ce4c5a2201b29ed0cdf180ba845d8542b9948"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/401a71d1d7e99cd5563253da77d4b293de9b6731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/401a71d1d7e99cd5563253da77d4b293de9b6731", "html_url": "https://github.com/rust-lang/rust/commit/401a71d1d7e99cd5563253da77d4b293de9b6731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/401a71d1d7e99cd5563253da77d4b293de9b6731/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "434e718b6717246066898a2dfcda1aec5e6f4082", "url": "https://api.github.com/repos/rust-lang/rust/commits/434e718b6717246066898a2dfcda1aec5e6f4082", "html_url": "https://github.com/rust-lang/rust/commit/434e718b6717246066898a2dfcda1aec5e6f4082"}, {"sha": "45fd5e697f6d7cf1d09c6c465cb008eabd1c63fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fd5e697f6d7cf1d09c6c465cb008eabd1c63fb", "html_url": "https://github.com/rust-lang/rust/commit/45fd5e697f6d7cf1d09c6c465cb008eabd1c63fb"}], "stats": {"total": 344, "additions": 174, "deletions": 170}, "files": [{"sha": "22292cdcc674af6a34dd6370c396506bbfa3a225", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -538,6 +538,7 @@ dependencies = [\n  \"mbe\",\n  \"profile\",\n  \"rustc-hash\",\n+ \"stdx\",\n  \"syntax\",\n  \"tracing\",\n  \"tt\","}, {"sha": "9901df2af088f67ffd22f23c6fe6f715a7c7ac02", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -421,30 +421,30 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    /// When the fixed-point loop reaches a stable state, we might still have some unresolved\n-    /// attributes (or unexpanded attribute proc macros) left over. This takes one of them, and\n-    /// feeds the item it's applied to back into name resolution.\n+    /// When the fixed-point loop reaches a stable state, we might still have\n+    /// some unresolved attributes left over. This takes one of them, and feeds\n+    /// the item it's applied to back into name resolution.\n     ///\n     /// This effectively ignores the fact that the macro is there and just treats the items as\n     /// normal code.\n     ///\n-    /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n-    /// before we supported proc. attribute macros.\n+    /// This improves UX for unresolved attributes, and replicates the\n+    /// behavior before we supported proc. attribute macros.\n     fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n         let mut unresolved_macros = mem::take(&mut self.unresolved_macros);\n         let pos = unresolved_macros.iter().position(|directive| {\n             if let MacroDirectiveKind::Attr { ast_id, mod_item, attr, tree } = &directive.kind {\n-                self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n+                self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n                     directive.module_id,\n                     MacroCallKind::Attr {\n                         ast_id: ast_id.ast_id,\n                         attr_args: Default::default(),\n                         invoc_attr_index: attr.id.ast_index,\n                         is_derive: false,\n                     },\n-                    None,\n+                    attr.path().clone(),\n                 ));\n \n                 self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), attr.id);\n@@ -1218,10 +1218,6 @@ impl DefCollector<'_> {\n                         return recollect_without(self);\n                     }\n \n-                    if !self.db.enable_proc_attr_macros() {\n-                        return true;\n-                    }\n-\n                     // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n                     let call_id = attr_macro_as_call_id(\n                         self.db,\n@@ -1233,6 +1229,16 @@ impl DefCollector<'_> {\n                     );\n                     let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n+                    // If proc attribute macro expansion is disabled, skip expanding it here\n+                    if !self.db.enable_proc_attr_macros() {\n+                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n+                            directive.module_id,\n+                            loc.kind,\n+                            Some(loc.def.krate),\n+                        ));\n+                        return recollect_without(self);\n+                    }\n+\n                     // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n                     // due to duplicating functions into macro expansions\n                     if matches!(\n@@ -1245,8 +1251,10 @@ impl DefCollector<'_> {\n \n                     if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n                         if exp.is_dummy() {\n-                            // Proc macros that cannot be expanded are treated as not\n-                            // resolved, in order to fall back later.\n+                            // If there's no expander for the proc macro (e.g.\n+                            // because proc macros are disabled, or building the\n+                            // proc macro crate failed), report this and skip\n+                            // expansion like we would if it was disabled\n                             self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n                                 directive.module_id,\n                                 loc.kind,"}, {"sha": "0e6fad16103dd4826e8bece3597f33e542d6d367", "filename": "crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2FCargo.toml?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -20,6 +20,7 @@ hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n \n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "29d78e21ba3f222229991ae32ca7b2ff2e2f502e", "filename": "crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -1,6 +1,7 @@\n //! Proc Macro Expander stub\n \n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n+use stdx::never;\n \n use crate::{db::AstDatabase, ExpandError, ExpandResult};\n \n@@ -36,18 +37,20 @@ impl ProcMacroExpander {\n                 let krate_graph = db.crate_graph();\n                 let proc_macros = match &krate_graph[self.krate].proc_macro {\n                     Ok(proc_macros) => proc_macros,\n-                    Err(e) => {\n-                        return ExpandResult::only_err(ExpandError::Other(\n-                            e.clone().into_boxed_str(),\n-                        ))\n+                    Err(_) => {\n+                        never!(\"Non-dummy expander even though there are no proc macros\");\n+                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n                     }\n                 };\n                 let proc_macro = match proc_macros.get(id.0 as usize) {\n                     Some(proc_macro) => proc_macro,\n                     None => {\n-                        return ExpandResult::only_err(ExpandError::Other(\n-                            \"No proc-macro found.\".into(),\n-                        ))\n+                        never!(\n+                            \"Proc macro index out of bounds: the length is {} but the index is {}\",\n+                            proc_macros.len(),\n+                            id.0\n+                        );\n+                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n                     }\n                 };\n "}, {"sha": "6a06c6b10f58cfdc5472b5ec2ccb63358f0c0adf", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -69,6 +69,7 @@ pub struct UnresolvedImport {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct UnresolvedMacroCall {\n     pub macro_call: InFile<SyntaxNodePtr>,\n+    pub precise_location: Option<TextRange>,\n     pub path: ModPath,\n     pub is_bang: bool,\n }\n@@ -95,6 +96,7 @@ pub struct UnresolvedProcMacro {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MacroError {\n     pub node: InFile<SyntaxNodePtr>,\n+    pub precise_location: Option<TextRange>,\n     pub message: String,\n }\n "}, {"sha": "7a31a8a41736a9e6d5663c0006bad3dad6be6db2", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -73,7 +73,7 @@ use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n-    AstNode, AstPtr, SmolStr, SyntaxNodePtr, T,\n+    AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n };\n \n use crate::db::{DefDatabase, HirDatabase};\n@@ -628,78 +628,19 @@ fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag:\n         }\n \n         DefDiagnosticKind::UnresolvedProcMacro { ast, krate } => {\n-            let (node, precise_location, macro_name, kind) = match ast {\n-                MacroCallKind::FnLike { ast_id, .. } => {\n-                    let node = ast_id.to_node(db.upcast());\n-                    (\n-                        ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n-                        node.path().map(|it| it.syntax().text_range()),\n-                        node.path().and_then(|it| it.segment()).map(|it| it.to_string()),\n-                        MacroKind::ProcMacro,\n-                    )\n-                }\n-                MacroCallKind::Derive { ast_id, derive_attr_index, derive_index } => {\n-                    let node = ast_id.to_node(db.upcast());\n-                    // Compute the precise location of the macro name's token in the derive\n-                    // list.\n-                    let token = (|| {\n-                        let derive_attr = node\n-                            .doc_comments_and_attrs()\n-                            .nth(*derive_attr_index as usize)\n-                            .and_then(Either::left)?;\n-                        let token_tree = derive_attr.meta()?.token_tree()?;\n-                        let group_by = token_tree\n-                            .syntax()\n-                            .children_with_tokens()\n-                            .filter_map(|elem| match elem {\n-                                syntax::NodeOrToken::Token(tok) => Some(tok),\n-                                _ => None,\n-                            })\n-                            .group_by(|t| t.kind() == T![,]);\n-                        let (_, mut group) = group_by\n-                            .into_iter()\n-                            .filter(|&(comma, _)| !comma)\n-                            .nth(*derive_index as usize)?;\n-                        group.find(|t| t.kind() == T![ident])\n-                    })();\n-                    (\n-                        ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n-                        token.as_ref().map(|tok| tok.text_range()),\n-                        token.as_ref().map(ToString::to_string),\n-                        MacroKind::Derive,\n-                    )\n-                }\n-                MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n-                    let node = ast_id.to_node(db.upcast());\n-                    let attr = node\n-                        .doc_comments_and_attrs()\n-                        .nth((*invoc_attr_index) as usize)\n-                        .and_then(Either::left)\n-                        .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", invoc_attr_index));\n-\n-                    (\n-                        ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n-                        Some(attr.syntax().text_range()),\n-                        attr.path()\n-                            .and_then(|path| path.segment())\n-                            .and_then(|seg| seg.name_ref())\n-                            .as_ref()\n-                            .map(ToString::to_string),\n-                        MacroKind::Attr,\n-                    )\n-                }\n-            };\n+            let (node, precise_location, macro_name, kind) = precise_macro_call_location(ast, db);\n             acc.push(\n                 UnresolvedProcMacro { node, precise_location, macro_name, kind, krate: *krate }\n                     .into(),\n             );\n         }\n \n         DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {\n-            let node = ast.to_node(db.upcast());\n+            let (node, precise_location, _, _) = precise_macro_call_location(ast, db);\n             acc.push(\n                 UnresolvedMacroCall {\n-                    macro_call: InFile::new(node.file_id, SyntaxNodePtr::new(&node.value)),\n+                    macro_call: node,\n+                    precise_location,\n                     path: path.clone(),\n                     is_bang: matches!(ast, MacroCallKind::FnLike { .. }),\n                 }\n@@ -708,23 +649,8 @@ fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag:\n         }\n \n         DefDiagnosticKind::MacroError { ast, message } => {\n-            let node = match ast {\n-                MacroCallKind::FnLike { ast_id, .. } => {\n-                    let node = ast_id.to_node(db.upcast());\n-                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                }\n-                MacroCallKind::Derive { ast_id, .. } => {\n-                    // FIXME: point to the attribute instead, this creates very large diagnostics\n-                    let node = ast_id.to_node(db.upcast());\n-                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                }\n-                MacroCallKind::Attr { ast_id, .. } => {\n-                    // FIXME: point to the attribute instead, this creates very large diagnostics\n-                    let node = ast_id.to_node(db.upcast());\n-                    ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node)))\n-                }\n-            };\n-            acc.push(MacroError { node, message: message.clone() }.into());\n+            let (node, precise_location, _, _) = precise_macro_call_location(ast, db);\n+            acc.push(MacroError { node, precise_location, message: message.clone() }.into());\n         }\n \n         DefDiagnosticKind::UnimplementedBuiltinMacro { ast } => {\n@@ -771,6 +697,78 @@ fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag:\n     }\n }\n \n+fn precise_macro_call_location(\n+    ast: &MacroCallKind,\n+    db: &dyn HirDatabase,\n+) -> (InFile<SyntaxNodePtr>, Option<TextRange>, Option<String>, MacroKind) {\n+    // FIXME: maaybe we actually want slightly different ranges for the different macro diagnostics\n+    // - e.g. the full attribute for macro errors, but only the name for name resolution\n+    match ast {\n+        MacroCallKind::FnLike { ast_id, .. } => {\n+            let node = ast_id.to_node(db.upcast());\n+            (\n+                ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n+                node.path()\n+                    .and_then(|it| it.segment())\n+                    .and_then(|it| it.name_ref())\n+                    .map(|it| it.syntax().text_range()),\n+                node.path().and_then(|it| it.segment()).map(|it| it.to_string()),\n+                MacroKind::ProcMacro,\n+            )\n+        }\n+        MacroCallKind::Derive { ast_id, derive_attr_index, derive_index } => {\n+            let node = ast_id.to_node(db.upcast());\n+            // Compute the precise location of the macro name's token in the derive\n+            // list.\n+            let token = (|| {\n+                let derive_attr = node\n+                    .doc_comments_and_attrs()\n+                    .nth(*derive_attr_index as usize)\n+                    .and_then(Either::left)?;\n+                let token_tree = derive_attr.meta()?.token_tree()?;\n+                let group_by = token_tree\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .filter_map(|elem| match elem {\n+                        syntax::NodeOrToken::Token(tok) => Some(tok),\n+                        _ => None,\n+                    })\n+                    .group_by(|t| t.kind() == T![,]);\n+                let (_, mut group) = group_by\n+                    .into_iter()\n+                    .filter(|&(comma, _)| !comma)\n+                    .nth(*derive_index as usize)?;\n+                group.find(|t| t.kind() == T![ident])\n+            })();\n+            (\n+                ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n+                token.as_ref().map(|tok| tok.text_range()),\n+                token.as_ref().map(ToString::to_string),\n+                MacroKind::Derive,\n+            )\n+        }\n+        MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+            let node = ast_id.to_node(db.upcast());\n+            let attr = node\n+                .doc_comments_and_attrs()\n+                .nth((*invoc_attr_index) as usize)\n+                .and_then(Either::left)\n+                .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", invoc_attr_index));\n+\n+            (\n+                ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n+                Some(attr.syntax().text_range()),\n+                attr.path()\n+                    .and_then(|path| path.segment())\n+                    .and_then(|seg| seg.name_ref())\n+                    .as_ref()\n+                    .map(ToString::to_string),\n+                MacroKind::Attr,\n+            )\n+        }\n+    }\n+}\n+\n impl HasVisibility for Module {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let def_map = self.id.def_map(db.upcast());\n@@ -1156,6 +1154,7 @@ impl DefWithBody {\n                 BodyDiagnostic::MacroError { node, message } => acc.push(\n                     MacroError {\n                         node: node.clone().map(|it| it.into()),\n+                        precise_location: None,\n                         message: message.to_string(),\n                     }\n                     .into(),\n@@ -1173,6 +1172,7 @@ impl DefWithBody {\n                 BodyDiagnostic::UnresolvedMacroCall { node, path } => acc.push(\n                     UnresolvedMacroCall {\n                         macro_call: node.clone().map(|ast_ptr| ast_ptr.into()),\n+                        precise_location: None,\n                         path: path.clone(),\n                         is_bang: true,\n                     }"}, {"sha": "83f2bc2237be683e2f5dc0e9df85ce5912036b4f", "filename": "crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -4,12 +4,12 @@ use crate::{Diagnostic, DiagnosticsContext};\n //\n // This diagnostic is shown for macro expansion errors.\n pub(crate) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) -> Diagnostic {\n-    Diagnostic::new(\n-        \"macro-error\",\n-        d.message.clone(),\n-        ctx.sema.diagnostics_display_range(d.node.clone()).range,\n-    )\n-    .experimental()\n+    // Use more accurate position if available.\n+    let display_range = d\n+        .precise_location\n+        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.node.clone()).range);\n+\n+    Diagnostic::new(\"macro-error\", d.message.clone(), display_range).experimental()\n }\n \n #[cfg(test)]\n@@ -30,10 +30,10 @@ macro_rules! include { () => {} }\n macro_rules! compile_error { () => {} }\n \n   include!(\"doesntexist\");\n-//^^^^^^^^^^^^^^^^^^^^^^^^ error: failed to load file `doesntexist`\n+//^^^^^^^ error: failed to load file `doesntexist`\n \n   compile_error!(\"compile_error macro works\");\n-//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: compile_error macro works\n+//^^^^^^^^^^^^^ error: compile_error macro works\n             \"#,\n         );\n     }\n@@ -111,7 +111,7 @@ macro_rules! env { () => {} }\n macro_rules! concat { () => {} }\n \n   include!(concat!(env!(\"OUT_DIR\"), \"/out.rs\"));\n-//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: `OUT_DIR` not set, enable \"build scripts\" to fix\n+//^^^^^^^ error: `OUT_DIR` not set, enable \"build scripts\" to fix\n \"#,\n         );\n     }\n@@ -153,23 +153,23 @@ fn main() {\n     // Test a handful of built-in (eager) macros:\n \n     include!(invalid);\n-  //^^^^^^^^^^^^^^^^^ error: could not convert tokens\n+  //^^^^^^^ error: could not convert tokens\n     include!(\"does not exist\");\n-  //^^^^^^^^^^^^^^^^^^^^^^^^^^ error: failed to load file `does not exist`\n+  //^^^^^^^ error: failed to load file `does not exist`\n \n     env!(invalid);\n-  //^^^^^^^^^^^^^ error: could not convert tokens\n+  //^^^ error: could not convert tokens\n \n     env!(\"OUT_DIR\");\n-  //^^^^^^^^^^^^^^^ error: `OUT_DIR` not set, enable \"build scripts\" to fix\n+  //^^^ error: `OUT_DIR` not set, enable \"build scripts\" to fix\n \n     compile_error!(\"compile_error works\");\n-  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: compile_error works\n+  //^^^^^^^^^^^^^ error: compile_error works\n \n     // Lazy:\n \n     format_args!();\n-  //^^^^^^^^^^^^^^ error: no rule matches input tokens\n+  //^^^^^^^^^^^ error: no rule matches input tokens\n }\n \"#,\n         );\n@@ -186,7 +186,7 @@ fn f() {\n     m!();\n \n     m!(hi);\n-  //^^^^^^ error: leftover tokens\n+  //^ error: leftover tokens\n }\n       \"#,\n         );"}, {"sha": "4b43124757f06deba2c2c4afbbb303fa372f0a94", "filename": "crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -1,6 +1,3 @@\n-use hir::{db::AstDatabase, InFile};\n-use syntax::{ast, AstNode, SyntaxNodePtr};\n-\n use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: unresolved-macro-call\n@@ -11,25 +8,16 @@ pub(crate) fn unresolved_macro_call(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedMacroCall,\n ) -> Diagnostic {\n-    let last_path_segment = ctx.sema.db.parse_or_expand(d.macro_call.file_id).and_then(|root| {\n-        let node = d.macro_call.value.to_node(&root);\n-        if let Some(macro_call) = ast::MacroCall::cast(node) {\n-            macro_call\n-                .path()\n-                .and_then(|it| it.segment())\n-                .and_then(|it| it.name_ref())\n-                .map(|it| InFile::new(d.macro_call.file_id, SyntaxNodePtr::new(it.syntax())))\n-        } else {\n-            None\n-        }\n-    });\n-    let diagnostics = last_path_segment.unwrap_or_else(|| d.macro_call.clone().map(|it| it.into()));\n+    // Use more accurate position if available.\n+    let display_range = d\n+        .precise_location\n+        .unwrap_or_else(|| ctx.sema.diagnostics_display_range(d.macro_call.clone()).range);\n \n     let bang = if d.is_bang { \"!\" } else { \"\" };\n     Diagnostic::new(\n         \"unresolved-macro-call\",\n         format!(\"unresolved macro `{}{}`\", d.path, bang),\n-        ctx.sema.diagnostics_display_range(diagnostics).range,\n+        display_range,\n     )\n     .experimental()\n }"}, {"sha": "2e8e93c926c00e03c942698f468d678c4bbebc1c", "filename": "crates/project-model/src/tests.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Ftests.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -172,8 +172,8 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -247,8 +247,8 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -312,8 +312,8 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                             },\n                         },\n                         dependencies: [],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: Some(\n@@ -389,8 +389,8 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -464,8 +464,8 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -554,8 +554,8 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -631,8 +631,8 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -696,8 +696,8 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                             },\n                         },\n                         dependencies: [],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: Some(\n@@ -775,8 +775,8 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -852,8 +852,8 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -933,8 +933,8 @@ fn cargo_hello_world_project_model() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -1010,8 +1010,8 @@ fn cargo_hello_world_project_model() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -1075,8 +1075,8 @@ fn cargo_hello_world_project_model() {\n                             },\n                         },\n                         dependencies: [],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: Some(\n@@ -1154,8 +1154,8 @@ fn cargo_hello_world_project_model() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -1231,8 +1231,8 @@ fn cargo_hello_world_project_model() {\n                                 prelude: true,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no build data\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,\n@@ -1505,8 +1505,8 @@ fn rust_project_hello_world_project_model() {\n                                 prelude: false,\n                             },\n                         ],\n-                        proc_macro: Ok(\n-                            [],\n+                        proc_macro: Err(\n+                            \"no proc macro dylib present\",\n                         ),\n                         origin: CratesIo {\n                             repo: None,"}, {"sha": "18c9c2c8106fc4bc445cf76007436c706ef04c16", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401a71d1d7e99cd5563253da77d4b293de9b6731/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=401a71d1d7e99cd5563253da77d4b293de9b6731", "patch": "@@ -459,7 +459,7 @@ fn project_json_to_crate_graph(\n                     krate.display_name.as_ref().map(|it| it.canonical_name()).unwrap_or(\"\"),\n                     &it,\n                 ),\n-                None => Ok(Vec::new()),\n+                None => Err(\"no proc macro dylib present\".into()),\n             };\n \n             let target_cfgs = match krate.target.as_deref() {\n@@ -870,9 +870,10 @@ fn add_target_crate_root(\n         }\n     }\n \n-    let proc_macro = match build_data.as_ref().and_then(|it| it.proc_macro_dylib_path.as_ref()) {\n-        Some(it) => load_proc_macro(it),\n-        None => Ok(Vec::new()),\n+    let proc_macro = match build_data.as_ref().map(|it| it.proc_macro_dylib_path.as_ref()) {\n+        Some(Some(it)) => load_proc_macro(it),\n+        Some(None) => Err(\"no proc macro dylib present\".into()),\n+        None => Err(\"no build data\".into()),\n     };\n \n     let display_name = CrateDisplayName::from_canonical_name(cargo_name.to_string());"}]}