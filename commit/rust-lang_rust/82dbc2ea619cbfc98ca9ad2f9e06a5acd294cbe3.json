{"sha": "82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZGJjMmVhNjE5Y2JmYzk4Y2E5YWQyZjllMDZhNWFjZDI5NGNiZTM=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-07-26T13:24:08Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-08-09T12:17:39Z"}, "message": "Add optional, external tests for floating point parsing.\n\nRunning these tests takes hours, so they are not run by @bors.", "tree": {"sha": "0d22b9a451c9212c8d037b46782cafca4035a8ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d22b9a451c9212c8d037b46782cafca4035a8ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "html_url": "https://github.com/rust-lang/rust/commit/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/comments", "author": null, "committer": null, "parents": [{"sha": "ba792a4baa856d83c3001afa181db91c5b4c9732", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba792a4baa856d83c3001afa181db91c5b4c9732", "html_url": "https://github.com/rust-lang/rust/commit/ba792a4baa856d83c3001afa181db91c5b4c9732"}], "stats": {"total": 664, "additions": 664, "deletions": 0}, "files": [{"sha": "b4a2a593e0118f3fb046915afd445a11a575b301", "filename": "src/etc/test-float-parse/_common.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2F_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2F_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2F_common.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io;\n+use std::io::prelude::*;\n+use std::mem::transmute;\n+\n+// Nothing up my sleeve: Just (PI - 3) in base 16.\n+#[allow(dead_code)]\n+pub const SEED: [u32; 3] = [0x243f_6a88, 0x85a3_08d3, 0x1319_8a2e];\n+\n+pub fn validate(text: String) {\n+    let mut out = io::stdout();\n+    let x: f64 = text.parse().unwrap();\n+    let f64_bytes: u64 = unsafe { transmute(x) };\n+    let x: f32 = text.parse().unwrap();\n+    let f32_bytes: u32 = unsafe { transmute(x) };\n+    writeln!(&mut out, \"{:016x} {:08x} {}\", f64_bytes, f32_bytes, text).unwrap();\n+}"}, {"sha": "390f4da6f63ae22967a567f8798e2becb0970118", "filename": "src/etc/test-float-parse/few-ones.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Ffew-ones.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Ffew-ones.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Ffew-ones.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+\n+fn main() {\n+    let mut pow = vec![];\n+    for i in 0..63 {\n+        pow.push(1u64 << i);\n+    }\n+    for a in &pow {\n+        for b in &pow {\n+            for c in &pow {\n+                validate((a | b | c).to_string());\n+            }\n+        }\n+    }\n+}"}, {"sha": "e62afc7851564faced3372516437c5d8d528a40a", "filename": "src/etc/test-float-parse/huge-pow10.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fhuge-pow10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fhuge-pow10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fhuge-pow10.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+\n+fn main() {\n+    for e in 300..310 {\n+        for i in 0..100000 {\n+            validate(format!(\"{}e{}\", i, e));\n+        }\n+    }\n+}"}, {"sha": "0cbf57183dfc2dbb9e3d4ddf1dd8e0ec08ade8b3", "filename": "src/etc/test-float-parse/many-digits.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rand)]\n+\n+extern crate rand;\n+\n+mod _common;\n+\n+use std::char;\n+use rand::{IsaacRng, Rng, SeedableRng};\n+use rand::distributions::{Range, Sample};\n+use _common::{validate, SEED};\n+\n+fn main() {\n+    let mut rnd = IsaacRng::from_seed(&SEED);\n+    let mut range = Range::new(0, 10);\n+    for _ in 0..5_000_000u64 {\n+        let num_digits = rnd.gen_range(100, 300);\n+        let digits = gen_digits(num_digits, &mut range, &mut rnd);\n+        validate(digits);\n+    }\n+}\n+\n+fn gen_digits<R: Rng>(n: u32, range: &mut Range<u32>, rnd: &mut R) -> String {\n+    let mut s = String::new();\n+    for _ in 0..n {\n+        let digit = char::from_digit(range.sample(rnd), 10).unwrap();\n+        s.push(digit);\n+    }\n+    s\n+}"}, {"sha": "762c3d95ec6eb8e7255179cf73ef82a3ef8395b3", "filename": "src/etc/test-float-parse/rand-f64.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rand)]\n+\n+extern crate rand;\n+\n+mod _common;\n+\n+use _common::{validate, SEED};\n+use rand::{IsaacRng, Rng, SeedableRng};\n+use std::mem::transmute;\n+\n+fn main() {\n+    let mut rnd = IsaacRng::from_seed(&SEED);\n+    let mut i = 0;\n+    while i < 10_000_000 {\n+        let bits = rnd.next_u64();\n+        let x: f64 = unsafe { transmute(bits) };\n+        if x.is_finite() {\n+            validate(format!(\"{:e}\", x));\n+            i += 1;\n+        }\n+    }\n+}"}, {"sha": "17a1b769bd63fa328b96a9c47fec44692690cd4b", "filename": "src/etc/test-float-parse/runtests.py", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,399 @@\n+#!/usr/bin/python2.7\n+#\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+\"\"\"\n+Testing dec2flt\n+===============\n+These are *really* extensive tests. Expect them to run for hours. Due to the\n+nature of the problem (the input is a string of arbitrary length), exhaustive\n+testing is not really possible. Instead, there are exhaustive tests for some\n+classes of inputs for which that is feasible and a bunch of deterministic and\n+random non-exhaustive tests for covering everything else.\n+\n+The actual tests (generating decimal strings and feeding them to dec2flt) is\n+performed by a set of stand-along rust programs. This script compiles, runs,\n+and supervises them. In particular, the programs report the strings they\n+generate and the floating point numbers they converted those strings to.\n+\n+You can run specific tests rather than all of them by giving their names\n+(without .rs extension) as command line parameters.\n+\n+Verification\n+------------\n+The tricky part is not generating those inputs but verifying the outputs.\n+Comparing with the result of Python's float() does not cut it because\n+(and this is apparently undocumented) although Python includes a version of\n+Martin Gay's code including the decimal-to-float part, it doesn't actually use\n+it for float() (only for round()) instead relying on the system scanf() which\n+is not necessarily completely accurate.\n+\n+Instead, we take the input and compute the true value with bignum arithmetic\n+(as a fraction, using the ``fractions`` module).\n+\n+Given an input string and the corresponding float computed via Rust, simply\n+decode the float into f * 2^k (for intergers f, k) and the ULP.\n+We can now easily compute the error and check if it is within 0.5 ULP as it\n+should be. Zero and infinites are handled similarly:\n+\n+- If the approximation is 0.0, the exact value should be *less or equal*\n+  half the smallest denormal float: the smallest denormal floating point\n+  number has an odd mantissa (00...001) and thus half of that is rounded\n+  to 00...00, i.e., zero.\n+- If the approximation is Inf, the exact value should be *greater or equal*\n+  to the largest finite float + 0.5 ULP: the largest finite float has an odd\n+  mantissa (11...11), so that plus half an ULP is rounded up to the nearest\n+  even number, which overflows.\n+\n+Implementation details\n+----------------------\n+This directory contains a set of single-file Rust programs that perform\n+tests with a particular class of inputs. Each is compiled and run without\n+parameters, outputs (f64, f32, decimal) pairs to verify externally, and\n+in any case either exits gracefully or with a panic.\n+\n+If a test binary writes *anything at all* to stderr or exits with an\n+exit code that's not 0, the test fails.\n+The output on stdout is treated as (f64, f32, decimal) record, encoded thusly:\n+\n+- The first eight bytes are a binary64 (native endianness).\n+- The following four bytes are a binary32 (native endianness).\n+- Then the corresponding string input follows, in ASCII (no newline).\n+- The record is terminated with a newline.\n+\n+Incomplete records are an error. Not-a-Number bit patterns are invalid too.\n+\n+The tests run serially but the validaition for a a single test is parallelized\n+with ``multiprocessing``. Each test is launched as a subprocess.\n+One thread supervises it: Accepts and enqueues records to validate, observe\n+stderr, and waits for the process to exit. A set of worker processes perform\n+the validation work for the outputs enqueued there. Another thread listens\n+for progress updates from the workers.\n+\n+Known issues\n+------------\n+Some errors (e.g., NaN outputs) aren't handled very gracefully.\n+Also, if there is an exception or the process is interrupted (at least on\n+Windows) the worker processes are leaked and stick around forever.\n+They're only a few megabytes each, but still, this script should not be run\n+if you aren't prepared to manually kill a lot of orphaned processes.\n+\"\"\"\n+from __future__ import print_function\n+import sys\n+import os.path\n+import time\n+import struct\n+from fractions import Fraction\n+from collections import namedtuple\n+from subprocess import Popen, check_call, PIPE\n+from glob import glob\n+import multiprocessing\n+import Queue\n+import threading\n+import ctypes\n+import binascii\n+\n+NUM_WORKERS = 2\n+UPDATE_EVERY_N = 50000\n+INF = namedtuple('INF', '')()\n+NEG_INF = namedtuple('NEG_INF', '')()\n+ZERO = namedtuple('ZERO', '')()\n+MAILBOX = None  # The queue for reporting errors to the main process.\n+STDOUT_LOCK = threading.Lock()\n+test_name = None\n+child_processes = []\n+exit_status = 0\n+\n+def msg(*args):\n+    with STDOUT_LOCK:\n+        print(\"[\" + test_name + \"]\", *args)\n+        sys.stdout.flush()\n+\n+\n+def write_errors():\n+    global exit_status\n+    f = open(\"errors.txt\", 'w')\n+    have_seen_error = False\n+    while True:\n+        args = MAILBOX.get()\n+        if args is None:\n+            f.close()\n+            break\n+        print(*args, file=f)\n+        f.flush()\n+        if not have_seen_error:\n+            have_seen_error = True\n+            msg(\"Something is broken:\", *args)\n+            msg(\"Future errors logged to errors.txt\")\n+            exit_status = 101\n+\n+\n+def rustc(test):\n+    rs = test + '.rs'\n+    exe = test + '.exe'  # hopefully this makes it work on *nix\n+    print(\"compiling\", test)\n+    sys.stdout.flush()\n+    check_call(['rustc', rs, '-o', exe])\n+\n+\n+def run(test):\n+    global test_name\n+    test_name = test\n+\n+    t0 = time.clock()\n+    msg(\"setting up supervisor\")\n+    exe = test + '.exe'\n+    proc = Popen(exe, bufsize=1<<20 , stdin=PIPE, stdout=PIPE, stderr=PIPE)\n+    done = multiprocessing.Value(ctypes.c_bool)\n+    queue = multiprocessing.Queue(maxsize=5)#(maxsize=1024)\n+    workers = []\n+    for n in range(NUM_WORKERS):\n+        worker = multiprocessing.Process(name='Worker-' + str(n + 1),\n+                                         target=init_worker,\n+                                         args=[test, MAILBOX, queue, done])\n+        workers.append(worker)\n+        child_processes.append(worker)\n+    for worker in workers:\n+        worker.start()\n+    msg(\"running test\")\n+    interact(proc, queue)\n+    with done.get_lock():\n+        done.value = True\n+    for worker in workers:\n+        worker.join()\n+    msg(\"python is done\")\n+    assert queue.empty(), \"did not validate everything\"\n+    dt = time.clock() - t0\n+    msg(\"took\", round(dt, 3), \"seconds\")\n+\n+\n+def interact(proc, queue):\n+    line = \"\"\n+    n = 0\n+    while proc.poll() is None:\n+        line = proc.stdout.readline()\n+        if not line:\n+            continue\n+        assert line.endswith('\\n'), \"incomplete line: \" + repr(line)\n+        queue.put(line)\n+        line = \"\"\n+        n += 1\n+        if n % UPDATE_EVERY_N == 0:\n+            msg(\"got\", str(n // 1000) + \"k\", \"records\")\n+    msg(\"rust is done. exit code:\", proc.returncode)\n+    rest, stderr = proc.communicate()\n+    if stderr:\n+        msg(\"rust stderr output:\", stderr)\n+    for line in rest.split('\\n'):\n+        if not line:\n+            continue\n+        queue.put(line)\n+\n+\n+def main():\n+    global MAILBOX\n+    tests = [os.path.splitext(f)[0] for f in glob('*.rs')\n+                                    if not f.startswith('_')]\n+    whitelist = sys.argv[1:]\n+    if whitelist:\n+        tests = [test for test in tests if test in whitelist]\n+    if not tests:\n+        print(\"Error: No tests to run\")\n+        sys.exit(1)\n+    # Compile first for quicker feedback\n+    for test in tests:\n+        rustc(test)\n+    # Set up mailbox once for all tests\n+    MAILBOX = multiprocessing.Queue()\n+    mailman = threading.Thread(target=write_errors)\n+    mailman.daemon = True\n+    mailman.start()\n+    for test in tests:\n+        if whitelist and test not in whitelist:\n+            continue\n+        run(test)\n+    MAILBOX.put(None)\n+    mailman.join()\n+\n+\n+# ---- Worker thread code ----\n+\n+\n+POW2 = { e: Fraction(2) ** e for e in range(-1100, 1100) }\n+HALF_ULP = { e: (Fraction(2) ** e)/2 for e in range(-1100, 1100) }\n+DONE_FLAG = None\n+\n+\n+def send_error_to_supervisor(*args):\n+    MAILBOX.put(args)\n+\n+\n+def init_worker(test, mailbox, queue, done):\n+    global test_name, MAILBOX, DONE_FLAG\n+    test_name = test\n+    MAILBOX = mailbox\n+    DONE_FLAG = done\n+    do_work(queue)\n+\n+\n+def is_done():\n+    with DONE_FLAG.get_lock():\n+        return DONE_FLAG.value\n+\n+\n+def do_work(queue):\n+    while True:\n+        try:\n+            line = queue.get(timeout=0.01)\n+        except Queue.Empty:\n+            if queue.empty() and is_done():\n+                return\n+            else:\n+                continue\n+        bin64, bin32, text = line.rstrip().split()\n+        validate(bin64, bin32, text)\n+\n+\n+def decode_binary64(x):\n+    \"\"\"\n+    Turn a IEEE 754 binary64 into (mantissa, exponent), except 0.0 and\n+    infinity (positive and negative), which return ZERO, INF, and NEG_INF\n+    respectively.\n+    \"\"\"\n+    x = binascii.unhexlify(x)\n+    assert len(x) == 8, repr(x)\n+    [bits] = struct.unpack(b'>Q', x)\n+    if bits == 0:\n+        return ZERO\n+    exponent = (bits >> 52) & 0x7FF\n+    negative = bits >> 63\n+    low_bits = bits & 0xFFFFFFFFFFFFF\n+    if exponent == 0:\n+        mantissa = low_bits\n+        exponent += 1\n+        if mantissa == 0:\n+            return ZERO\n+    elif exponent == 0x7FF:\n+        assert low_bits == 0, \"NaN\"\n+        if negative:\n+            return NEG_INF\n+        else:\n+            return INF\n+    else:\n+        mantissa = low_bits | (1 << 52)\n+    exponent -= 1023 + 52\n+    if negative:\n+        mantissa = -mantissa\n+    return (mantissa, exponent)\n+\n+\n+def decode_binary32(x):\n+    \"\"\"\n+    Turn a IEEE 754 binary32 into (mantissa, exponent), except 0.0 and\n+    infinity (positive and negative), which return ZERO, INF, and NEG_INF\n+    respectively.\n+    \"\"\"\n+    x = binascii.unhexlify(x)\n+    assert len(x) == 4, repr(x)\n+    [bits] = struct.unpack(b'>I', x)\n+    if bits == 0:\n+        return ZERO\n+    exponent = (bits >> 23) & 0xFF\n+    negative = bits >> 31\n+    low_bits = bits & 0x7FFFFF\n+    if exponent == 0:\n+        mantissa = low_bits\n+        exponent += 1\n+        if mantissa == 0:\n+            return ZERO\n+    elif exponent == 0xFF:\n+        if negative:\n+            return NEG_INF\n+        else:\n+            return INF\n+    else:\n+        mantissa = low_bits | (1 << 23)\n+    exponent -= 127 + 23\n+    if negative:\n+        mantissa = -mantissa\n+    return (mantissa, exponent)\n+\n+\n+MIN_SUBNORMAL_DOUBLE = Fraction(2) ** -1074\n+MIN_SUBNORMAL_SINGLE = Fraction(2) ** -149  # XXX unsure\n+MAX_DOUBLE = (2 - Fraction(2) ** -52) * (2 ** 1023)\n+MAX_SINGLE = (2 - Fraction(2) ** -23) * (2 ** 127)\n+MAX_ULP_DOUBLE = 1023 - 52\n+MAX_ULP_SINGLE = 127 - 23\n+DOUBLE_ZERO_CUTOFF = MIN_SUBNORMAL_DOUBLE / 2\n+DOUBLE_INF_CUTOFF = MAX_DOUBLE + 2 ** (MAX_ULP_DOUBLE - 1)\n+SINGLE_ZERO_CUTOFF = MIN_SUBNORMAL_SINGLE / 2\n+SINGLE_INF_CUTOFF = MAX_SINGLE + 2 ** (MAX_ULP_SINGLE - 1)\n+\n+def validate(bin64, bin32, text):\n+    double = decode_binary64(bin64)\n+    single = decode_binary32(bin32)\n+    real = Fraction(text)\n+\n+    if double is ZERO:\n+        if real > DOUBLE_ZERO_CUTOFF:\n+            record_special_error(text, \"f64 zero\")\n+    elif double is INF:\n+        if real < DOUBLE_INF_CUTOFF:\n+            record_special_error(text, \"f64 inf\")\n+    elif double is NEG_INF:\n+        if -real < DOUBLE_INF_CUTOFF:\n+            record_special_error(text, \"f64 -inf\")\n+    elif len(double) == 2:\n+        sig, k = double\n+        validate_normal(text, real, sig, k, \"f64\")\n+    else:\n+        assert 0, \"didn't handle binary64\"\n+    if single is ZERO:\n+        if real > SINGLE_ZERO_CUTOFF:\n+            record_special_error(text, \"f32 zero\")\n+    elif single is INF:\n+        if real < SINGLE_INF_CUTOFF:\n+            record_special_error(text, \"f32 inf\")\n+    elif single is NEG_INF:\n+        if -real < SINGLE_INF_CUTOFF:\n+            record_special_error(text, \"f32 -inf\")\n+    elif len(single) == 2:\n+        sig, k = single\n+        validate_normal(text, real, sig, k, \"f32\")\n+    else:\n+        assert 0, \"didn't handle binary32\"\n+\n+def record_special_error(text, descr):\n+    send_error_to_supervisor(text.strip(), \"wrongly rounded to\", descr)\n+\n+\n+def validate_normal(text, real, sig, k, kind):\n+    approx = sig * POW2[k]\n+    error = abs(approx - real)\n+    if error > HALF_ULP[k]:\n+        record_normal_error(text, error, k, kind)\n+\n+\n+def record_normal_error(text, error, k, kind):\n+    one_ulp = HALF_ULP[k + 1]\n+    assert one_ulp == 2 * HALF_ULP[k]\n+    relative_error = error / one_ulp\n+    text = text.strip()\n+    try:\n+        err_repr = float(relative_error)\n+    except ValueError:\n+        err_repr = str(err_repr).replace('/', ' / ')\n+    send_error_to_supervisor(err_repr, \"ULP error on\", text, \"(\" + kind + \")\")\n+\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "baefb9c93054346e25b3db9492e80a0d24aba1e0", "filename": "src/etc/test-float-parse/short-decimals.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fshort-decimals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fshort-decimals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fshort-decimals.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+\n+fn main() {\n+    // Skip e = 0 because small-u32 already does those.\n+    for e in 1..301 {\n+        for i in 0..10000 {\n+            // If it ends in zeros, the parser will strip those (and adjust the exponent),\n+            // which almost always (except for exponents near +/- 300) result in an input\n+            // equivalent to something we already generate in a different way.\n+            if i % 10 == 0 {\n+                continue;\n+            }\n+            validate(format!(\"{}e{}\", i, e));\n+            validate(format!(\"{}e-{}\", i, e));\n+        }\n+    }\n+}"}, {"sha": "70682c9b21810a2e3e1d4aaaa484c42b01a15a8b", "filename": "src/etc/test-float-parse/subnorm.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsubnorm.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use std::mem::transmute;\n+use _common::validate;\n+\n+fn main() {\n+    for bits in 0u32..(1 << 21) {\n+        let single: f32 = unsafe { transmute(bits) };\n+        validate(format!(\"{:e}\", single));\n+        let double: f64 = unsafe { transmute(bits as u64) };\n+        validate(format!(\"{:e}\", double));\n+    }\n+}"}, {"sha": "a01c6d5a07893e4b37b98af9a51cde54c04ac1ca", "filename": "src/etc/test-float-parse/tiny-pow10.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Ftiny-pow10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Ftiny-pow10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Ftiny-pow10.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+\n+fn main() {\n+    for e in 301..327 {\n+        for i in 0..100000 {\n+            validate(format!(\"{}e-{}\", i, e));\n+        }\n+    }\n+}"}, {"sha": "a4e8488e74529219c85dd7d7d5f70ab567c85474", "filename": "src/etc/test-float-parse/u32-small.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fu32-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fu32-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fu32-small.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+\n+fn main() {\n+    for i in 0..(1 << 19) {\n+        validate(i.to_string());\n+    }\n+}"}, {"sha": "a31304d3f68aa90caadc0bb740dc033c9c2cb8dc", "filename": "src/etc/test-float-parse/u64-pow2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs?ref=82dbc2ea619cbfc98ca9ad2f9e06a5acd294cbe3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod _common;\n+\n+use _common::validate;\n+use std::u64;\n+\n+fn main() {\n+    for exp in 19..64 {\n+        let power: u64 = 1 << exp;\n+        validate(power.to_string());\n+        for offset in 1..123 {\n+            validate((power + offset).to_string());\n+            validate((power - offset).to_string());\n+        }\n+    }\n+    for offset in 0..123 {\n+        validate((u64::MAX - offset).to_string());\n+    }\n+}"}]}