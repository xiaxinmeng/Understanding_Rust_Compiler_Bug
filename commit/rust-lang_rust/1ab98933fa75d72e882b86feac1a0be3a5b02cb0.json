{"sha": "1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "node_id": "C_kwDOAAsO6NoAKDFhYjk4OTMzZmE3NWQ3MmU4ODJiODZmZWFjMWEwYmUzYTViMDJjYjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-26T11:15:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-26T11:15:15Z"}, "message": "Auto merge of #97168 - SparrowLii:accesses, r=cjgillot\n\nomit `record_accesses` function when collecting `MonoItem`s\n\nThis PR fixes the FIXME in the impl of `record_accesses` function.\n[Edit] We can call `instantiation_mode` when push the `MonoItem` into `neighbors`. This avoids extra local variables `accesses: SmallVec<[_; 128]>`", "tree": {"sha": "a61351a428e65a4da96c5142dca8507831b46110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a61351a428e65a4da96c5142dca8507831b46110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "html_url": "https://github.com/rust-lang/rust/commit/1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ab98933fa75d72e882b86feac1a0be3a5b02cb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e26dc71fdf370ced4d7b9971c5828bef9162290", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e26dc71fdf370ced4d7b9971c5828bef9162290", "html_url": "https://github.com/rust-lang/rust/commit/9e26dc71fdf370ced4d7b9971c5828bef9162290"}, {"sha": "480e6036c5aac0052dae76067b24444292f08014", "url": "https://api.github.com/repos/rust-lang/rust/commits/480e6036c5aac0052dae76067b24444292f08014", "html_url": "https://github.com/rust-lang/rust/commit/480e6036c5aac0052dae76067b24444292f08014"}], "stats": {"total": 110, "additions": 66, "deletions": 44}, "files": [{"sha": "a9ca89217972edc1fbc4a34778b0fccebadd3251", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1ab98933fa75d72e882b86feac1a0be3a5b02cb0/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab98933fa75d72e882b86feac1a0be3a5b02cb0/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "patch": "@@ -201,7 +201,6 @@ use rustc_session::lint::builtin::LARGE_ASSIGNMENTS;\n use rustc_session::Limit;\n use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use rustc_target::abi::Size;\n-use smallvec::SmallVec;\n use std::iter;\n use std::ops::Range;\n use std::path::PathBuf;\n@@ -226,6 +225,44 @@ pub struct InliningMap<'tcx> {\n     inlines: GrowableBitSet<usize>,\n }\n \n+/// Struct to store mono items in each collecting and if they should\n+/// be inlined. We call `instantiation_mode` to get their inlining\n+/// status when inserting new elements, which avoids calling it in\n+/// `inlining_map.lock_mut()`. See the `collect_items_rec` implementation\n+/// below.\n+struct MonoItems<'tcx> {\n+    // If this is false, we do not need to compute whether items\n+    // will need to be inlined.\n+    compute_inlining: bool,\n+\n+    // The TyCtxt used to determine whether the a item should\n+    // be inlined.\n+    tcx: TyCtxt<'tcx>,\n+\n+    // The collected mono items. The bool field in each element\n+    // indicates whether this element should be inlined.\n+    items: Vec<(Spanned<MonoItem<'tcx>>, bool /*inlined*/)>,\n+}\n+\n+impl<'tcx> MonoItems<'tcx> {\n+    #[inline]\n+    fn push(&mut self, item: Spanned<MonoItem<'tcx>>) {\n+        self.extend([item]);\n+    }\n+\n+    #[inline]\n+    fn extend<T: IntoIterator<Item = Spanned<MonoItem<'tcx>>>>(&mut self, iter: T) {\n+        self.items.extend(iter.into_iter().map(|mono_item| {\n+            let inlined = if !self.compute_inlining {\n+                false\n+            } else {\n+                mono_item.node.instantiation_mode(self.tcx) == InstantiationMode::LocalCopy\n+            };\n+            (mono_item, inlined)\n+        }))\n+    }\n+}\n+\n impl<'tcx> InliningMap<'tcx> {\n     fn new() -> InliningMap<'tcx> {\n         InliningMap {\n@@ -235,17 +272,23 @@ impl<'tcx> InliningMap<'tcx> {\n         }\n     }\n \n-    fn record_accesses(&mut self, source: MonoItem<'tcx>, new_targets: &[(MonoItem<'tcx>, bool)]) {\n+    fn record_accesses<'a>(\n+        &mut self,\n+        source: MonoItem<'tcx>,\n+        new_targets: &'a [(Spanned<MonoItem<'tcx>>, bool)],\n+    ) where\n+        'tcx: 'a,\n+    {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n         let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n         self.inlines.ensure(new_items_count_total);\n \n-        for (i, (target, inline)) in new_targets.iter().enumerate() {\n-            self.targets.push(*target);\n-            if *inline {\n+        for (i, (Spanned { node: mono_item, .. }, inlined)) in new_targets.into_iter().enumerate() {\n+            self.targets.push(*mono_item);\n+            if *inlined {\n                 self.inlines.insert(i + start_index);\n             }\n         }\n@@ -321,7 +364,7 @@ pub fn collect_crate_mono_items(\n // start monomorphizing from.\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n-    let mut roots = Vec::new();\n+    let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n \n     {\n         let entry_fn = tcx.entry_fn(());\n@@ -347,8 +390,11 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n     roots\n+        .items\n         .into_iter()\n-        .filter_map(|root| root.node.is_instantiable(tcx).then_some(root.node))\n+        .filter_map(|(Spanned { node: mono_item, .. }, _)| {\n+            mono_item.is_instantiable(tcx).then_some(mono_item)\n+        })\n         .collect()\n }\n \n@@ -368,7 +414,7 @@ fn collect_items_rec<'tcx>(\n     }\n     debug!(\"BEGIN collect_items_rec({})\", starting_point.node);\n \n-    let mut neighbors = Vec::new();\n+    let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n     let recursion_depth_reset;\n \n     //\n@@ -483,10 +529,9 @@ fn collect_items_rec<'tcx>(\n             &format!(\"the above error was encountered while instantiating `{}`\", formatted_item),\n         );\n     }\n+    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n \n-    record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n-\n-    for neighbour in neighbors {\n+    for (neighbour, _) in neighbors.items {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n     }\n \n@@ -497,25 +542,6 @@ fn collect_items_rec<'tcx>(\n     debug!(\"END collect_items_rec({})\", starting_point.node);\n }\n \n-fn record_accesses<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'tcx>,\n-    caller: MonoItem<'tcx>,\n-    callees: impl Iterator<Item = &'a MonoItem<'tcx>>,\n-    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n-) {\n-    let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n-        mono_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n-    };\n-\n-    // We collect this into a `SmallVec` to avoid calling `is_inlining_candidate` in the lock.\n-    // FIXME: Call `is_inlining_candidate` when pushing to `neighbors` in `collect_items_rec`\n-    // instead to avoid creating this `SmallVec`.\n-    let accesses: SmallVec<[_; 128]> =\n-        callees.map(|mono_item| (*mono_item, is_inlining_candidate(mono_item))).collect();\n-\n-    inlining_map.lock_mut().record_accesses(caller, &accesses);\n-}\n-\n /// Format instance name that is already known to be too long for rustc.\n /// Show only the first and last 32 characters to avoid blasting\n /// the user's terminal with thousands of lines of type-name.\n@@ -627,7 +653,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n struct MirNeighborCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &'a mut MonoItems<'tcx>,\n     instance: Instance<'tcx>,\n }\n \n@@ -905,7 +931,7 @@ fn visit_drop_use<'tcx>(\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n     source: Span,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     let instance = Instance::resolve_drop_in_place(tcx, ty);\n     visit_instance_use(tcx, instance, is_direct_call, source, output);\n@@ -916,7 +942,7 @@ fn visit_fn_use<'tcx>(\n     ty: Ty<'tcx>,\n     is_direct_call: bool,\n     source: Span,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     if let ty::FnDef(def_id, substs) = *ty.kind() {\n         let instance = if is_direct_call {\n@@ -934,7 +960,7 @@ fn visit_instance_use<'tcx>(\n     instance: ty::Instance<'tcx>,\n     is_direct_call: bool,\n     source: Span,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_codegen_locally(tcx, &instance) {\n@@ -1117,7 +1143,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n     trait_ty: Ty<'tcx>,\n     impl_ty: Ty<'tcx>,\n     source: Span,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     assert!(!trait_ty.has_escaping_bound_vars() && !impl_ty.has_escaping_bound_vars());\n \n@@ -1159,7 +1185,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n struct RootCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n-    output: &'a mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &'a mut MonoItems<'tcx>,\n     entry_fn: Option<(DefId, EntryFnType)>,\n }\n \n@@ -1305,7 +1331,7 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     item: &'tcx hir::Item<'tcx>,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n@@ -1361,11 +1387,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n }\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n-fn collect_miri<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    alloc_id: AllocId,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n-) {\n+fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoItems<'tcx>) {\n     match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Static(def_id) => {\n             assert!(!tcx.is_thread_local_static(def_id));\n@@ -1396,7 +1418,7 @@ fn collect_miri<'tcx>(\n fn collect_neighbours<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n     let body = tcx.instance_mir(instance.def);\n@@ -1407,7 +1429,7 @@ fn collect_neighbours<'tcx>(\n fn collect_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     value: ConstValue<'tcx>,\n-    output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n+    output: &mut MonoItems<'tcx>,\n ) {\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),"}]}