{"sha": "5415b34ca6077b45a241c51ef2a227993a644d26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MTViMzRjYTYwNzdiNDVhMjQxYzUxZWYyYTIyNzk5M2E2NDRkMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-24T10:49:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-09-06T15:17:03Z"}, "message": "write to inherent_impls during the visitor\n\nThe goal here is to avoid writing to the `inherent_impls` map from\nwithin the general `Coherence` task, and instead write to it as we\nvisit. Writing to it from the Coherence task is actually an information\nleak; it happened to be safe because Coherence read from\n`DepNode::Krate`, but that was very coarse.\n\nI removed the `Rc` here because, upon manual inspection, nobody clones\nthe data in this table, and it meant that we can accumulate the data in\nplace. That said, the pattern that is used for the inherent impls map\nis *generally* an anti-pattern (that is, holding the borrow lock for the\nduration of using the contents), so it'd probably be better to\nclone (and I doubt that would be expensive -- how many inherent impls\ndoes a typical type have?).", "tree": {"sha": "d48d90cf42b73464cefcd77fcd7e9211a52cc822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d48d90cf42b73464cefcd77fcd7e9211a52cc822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5415b34ca6077b45a241c51ef2a227993a644d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5415b34ca6077b45a241c51ef2a227993a644d26", "html_url": "https://github.com/rust-lang/rust/commit/5415b34ca6077b45a241c51ef2a227993a644d26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5415b34ca6077b45a241c51ef2a227993a644d26/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5114f8a29ba29c7a168b46ede82fb62d67a2d619", "url": "https://api.github.com/repos/rust-lang/rust/commits/5114f8a29ba29c7a168b46ede82fb62d67a2d619", "html_url": "https://github.com/rust-lang/rust/commit/5114f8a29ba29c7a168b46ede82fb62d67a2d619"}], "stats": {"total": 73, "additions": 49, "deletions": 24}, "files": [{"sha": "51f7890c7a2f4c8e13d31b97e557a26cc0b1c8f3", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=5415b34ca6077b45a241c51ef2a227993a644d26", "patch": "@@ -80,6 +80,17 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n+\n+    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n+    /// This is considered a write to `k`.\n+    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n+        where M: DepTrackingMapConfig<Value=Vec<E>>\n+    {\n+        self.write(&k);\n+        self.map.entry(k)\n+                .or_insert(Vec::new())\n+                .push(elem);\n+    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "5772d16c6d43d9abe0359b0e258cf567f960211b", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=5415b34ca6077b45a241c51ef2a227993a644d26", "patch": "@@ -39,7 +39,7 @@ dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n-dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "78358ce534d99575ce1fa4872924c313f7d01025", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5415b34ca6077b45a241c51ef2a227993a644d26", "patch": "@@ -2665,7 +2665,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n         }\n \n-        self.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n+        self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n     }\n "}, {"sha": "57d3c46af93069d90d3048f83ab7741ace76cba0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5415b34ca6077b45a241c51ef2a227993a644d26", "patch": "@@ -32,10 +32,7 @@ use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n use rustc::infer::{self, InferCtxt, TypeOrigin};\n-use std::cell::RefCell;\n-use std::rc::Rc;\n use syntax_pos::Span;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::intravisit;\n@@ -49,7 +46,6 @@ mod unsafety;\n struct CoherenceChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'gcx>,\n     inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n-    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n }\n \n struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -109,15 +105,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             DepNode::CoherenceCheckImpl,\n             &mut CoherenceCheckVisitor { cc: self });\n \n-        // Copy over the inherent impls we gathered up during the walk into\n-        // the tcx.\n-        let mut tcx_inherent_impls =\n-            self.crate_context.tcx.inherent_impls.borrow_mut();\n-        for (k, v) in self.inherent_impls.borrow().iter() {\n-            tcx_inherent_impls.insert((*k).clone(),\n-                                      Rc::new((*v.borrow()).clone()));\n-        }\n-\n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n         // the coherence tables contain the trait -> type mappings.\n@@ -175,14 +162,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        if let Some(implementation_list) = self.inherent_impls.borrow().get(&base_def_id) {\n-            implementation_list.borrow_mut().push(impl_def_id);\n-            return;\n-        }\n-\n-        self.inherent_impls.borrow_mut().insert(\n-            base_def_id,\n-            Rc::new(RefCell::new(vec!(impl_def_id))));\n+        let tcx = self.crate_context.tcx;\n+        tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n     }\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n@@ -556,7 +537,6 @@ pub fn check_coherence(ccx: &CrateCtxt) {\n         CoherenceChecker {\n             crate_context: ccx,\n             inference_context: infcx,\n-            inherent_impls: RefCell::new(FnvHashMap()),\n         }.check();\n     });\n     unsafety::check(ccx.tcx);"}, {"sha": "ac6cc3e9826f1dac7230367c852c3adef09891a6", "filename": "src/test/incremental/krate-inherent.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5415b34ca6077b45a241c51ef2a227993a644d26/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inherent.rs?ref=5415b34ca6077b45a241c51ef2a227993a644d26", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![rustc_partition_reused(module=\"krate_inherent-x\", cfg=\"rpass2\")]\n+\n+fn main() { }\n+\n+mod x {\n+    struct Foo;\n+    impl Foo {\n+        fn foo(&self) { }\n+    }\n+\n+    fn method() {\n+        let x: Foo = Foo;\n+        x.foo(); // inherent methods used to add an edge from Krate\n+    }\n+}\n+\n+#[cfg(rpass1)]\n+fn bar() { } // remove this unrelated fn in rpass2, which should not affect `x::method`\n+"}]}