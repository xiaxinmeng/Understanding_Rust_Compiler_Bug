{"sha": "7f8d24590fa9b381eb38e2b007c88a446cf99479", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOGQyNDU5MGZhOWIzODFlYjM4ZTJiMDA3Yzg4YTQ0NmNmOTk0Nzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-17T13:47:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T20:38:29Z"}, "message": "fix coercion behavior for nested references", "tree": {"sha": "0d8b6db2af278bbeef2d9b8d134bf4b207c83203", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d8b6db2af278bbeef2d9b8d134bf4b207c83203"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f8d24590fa9b381eb38e2b007c88a446cf99479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8d24590fa9b381eb38e2b007c88a446cf99479", "html_url": "https://github.com/rust-lang/rust/commit/7f8d24590fa9b381eb38e2b007c88a446cf99479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f8d24590fa9b381eb38e2b007c88a446cf99479/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdaee4aba76bf3c5a3a817715e4ee33f738e3644", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdaee4aba76bf3c5a3a817715e4ee33f738e3644", "html_url": "https://github.com/rust-lang/rust/commit/cdaee4aba76bf3c5a3a817715e4ee33f738e3644"}], "stats": {"total": 93, "additions": 85, "deletions": 8}, "files": [{"sha": "1f7265bdb4ddfbcc8119544a36befa1b2ed97d51", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f8d24590fa9b381eb38e2b007c88a446cf99479/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8d24590fa9b381eb38e2b007c88a446cf99479/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7f8d24590fa9b381eb38e2b007c88a446cf99479", "patch": "@@ -230,6 +230,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n+        let mut r_borrow_var = None;\n         let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n                                                  UnresolvedTypeAction::Ignore,\n                                                  lvalue_pref,\n@@ -264,21 +265,57 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // mutability [1], since it may be that we are coercing\n             // from `&mut T` to `&U`.\n             //\n-            // One fine point concerns the region that we use [2]. We\n+            // One fine point concerns the region that we use. We\n             // choose the region such that the region of the final\n             // type that results from `unify` will be the region we\n             // want for the autoref:\n             //\n-            // - if in lub mode, that means we want to unify `&'a mut [T]`\n-            //   (from source) and `&'b mut [T]` (target).\n-            // - if in sub mode, that means we want to use `'b` for\n-            //   both pointers. This is because sub mode (somewhat\n+            // - if in sub mode, that means we want to use `'b` (the\n+            //   region from the target reference) for both\n+            //   pointers [2]. This is because sub mode (somewhat\n             //   arbitrarily) returns the subtype region.  In the case\n             //   where we are coercing to a target type, we know we\n             //   want to use that target type region (`'b`) because --\n             //   for the program to type-check -- it must be the\n             //   smaller of the two.\n-            let r = if self.use_lub {r_a} else {r_b}; // [2] above\n+            // - if in lub mode, things can get fairly complicated. The\n+            //   easiest thing is just to make a fresh\n+            //   region variable [4], which effectively means we defer\n+            //   the decision to region inference (and regionck, which will add\n+            //   some more edges to this variable). However, this can wind up\n+            //   creating a crippling number of variables in some cases --\n+            //   e.g. #32278 -- so we optimize one particular case [3].\n+            //   Let me try to explain with some examples:\n+            //   - The \"running example\" above represents the simple case,\n+            //     where we have one `&` reference at the outer level and\n+            //     ownership all the rest of the way down. In this case,\n+            //     we want `LUB('a, 'b)` as the resulting region.\n+            //   - However, if there are nested borrows, that region is\n+            //     too strong. Consider a coercion from `&'a &'x Rc<T>` to\n+            //     `&'b T`. In this case, `'a` is actually irrelevant.\n+            //     The pointer we want is `LUB('x, 'b`). If we choose `LUB('a,'b)`\n+            //     we get spurious errors (`run-pass/regions-lub-ref-ref-rc.rs`).\n+            //     (The errors actually show up in borrowck, typically, because\n+            //     this extra edge causes the region `'a` to be inferred to something\n+            //     too big, which then results in borrowck errors.)\n+            //   - We could track the innermost shared reference, but there is already\n+            //     code in regionck that has the job of creating links between\n+            //     the region of a borrow and the regions in the thing being\n+            //     borrowed (here, `'a` and `'x`), and it knows how to handle\n+            //     all the various cases. So instead we just make a region variable\n+            //     and let regionck figure it out.\n+            let r = if !self.use_lub {\n+                r_b // [2] above\n+            } else if autoderef == 1 {\n+                r_a // [3] above\n+            } else {\n+                if r_borrow_var.is_none() { // create var lazilly, at most once\n+                    let coercion = Coercion(span);\n+                    let r = self.fcx.infcx().next_region_var(coercion);\n+                    r_borrow_var = Some(self.tcx().mk_region(r)); // [4] above\n+                }\n+                r_borrow_var.unwrap()\n+            };\n             let derefd_ty_a = self.tcx().mk_ref(r, TypeAndMut {\n                 ty: referent_ty,\n                 mutbl: mt_b.mutbl // [1] above\n@@ -302,18 +339,22 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let ty = match success {\n             Some(ty) => ty,\n             None => {\n-                return Err(first_error.expect(\"coerce_borrowed_pointer had no error\"));\n+                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+                debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n+                return Err(err);\n             }\n         };\n \n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n-            ty::TyRef(r, _) => r,\n+            ty::TyRef(r_borrow, _) => r_borrow,\n             _ => self.tcx().sess.span_bug(span,\n                                           &format!(\"expected a ref type, got {:?}\", ty))\n         };\n         let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n+               ty, autoderefs, autoref);\n         Ok((ty, AdjustDerefRef(AutoDerefRef {\n             autoderefs: autoderefs,\n             autoref: autoref,"}, {"sha": "41c64197acbe835d2f2b4ff9119c3e8326dce0bc", "filename": "src/test/run-pass/regions-lub-ref-ref-rc.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f8d24590fa9b381eb38e2b007c88a446cf99479/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8d24590fa9b381eb38e2b007c88a446cf99479/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs?ref=7f8d24590fa9b381eb38e2b007c88a446cf99479", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a corner case of LUB coercion. In this case, one arm of the\n+// match requires a deref coercion and other other doesn't, and there\n+// is an extra `&` on the `rc`. We want to be sure that the lifetime\n+// assigned to this `&rc` value is not `'a` but something smaller.  In\n+// other words, the type from `rc` is `&'a Rc<String>` and the type\n+// from `&rc` should be `&'x &'a Rc<String>`, where `'x` is something\n+// small.\n+\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+enum CachedMir<'mir> {\n+    Ref(&'mir String),\n+    Owned(Rc<String>),\n+}\n+\n+impl<'mir> CachedMir<'mir> {\n+    fn get_ref<'a>(&'a self) -> &'a String {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => &rc,\n+        }\n+    }\n+}\n+\n+fn main() { }"}]}