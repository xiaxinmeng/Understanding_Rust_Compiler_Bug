{"sha": "72c24e20a9caf49b855b4c0de44aad6b039d09f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYzI0ZTIwYTljYWY0OWI4NTViNGMwZGU0NGFhZDZiMDM5ZDA5ZjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-09T06:07:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-14T05:15:46Z"}, "message": "rustc: remove unnecessary unsafe blocks/methods", "tree": {"sha": "48f9b22aa992ef216722a6576ec0bf96fd1282e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f9b22aa992ef216722a6576ec0bf96fd1282e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72c24e20a9caf49b855b4c0de44aad6b039d09f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72c24e20a9caf49b855b4c0de44aad6b039d09f4", "html_url": "https://github.com/rust-lang/rust/commit/72c24e20a9caf49b855b4c0de44aad6b039d09f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72c24e20a9caf49b855b4c0de44aad6b039d09f4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52445129fdb4ee847332acbf516ced8f73b7990a", "url": "https://api.github.com/repos/rust-lang/rust/commits/52445129fdb4ee847332acbf516ced8f73b7990a", "html_url": "https://github.com/rust-lang/rust/commit/52445129fdb4ee847332acbf516ced8f73b7990a"}], "stats": {"total": 328, "additions": 153, "deletions": 175}, "files": [{"sha": "1c99566280815532df481db91125830e6550fdfb", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -615,9 +615,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n }\n \n pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n-    unsafe {\n-        symbol_hasher.result_str()\n-    }\n+    symbol_hasher.result_str()\n }\n \n "}, {"sha": "bacbeb851aa82624e6376571ff7e54847ed1d593", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -369,7 +369,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn collect_local_language_items(&self) {\n-        let this = unsafe { ptr::addr_of(&self) };\n+        let this = ptr::addr_of(&self);\n         visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {"}, {"sha": "b2225963d2c33738c5c370f54664c42b44dc49fc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n+use middle::lint::{allow, level, unused_imports};\n use middle::lint::{get_lint_level, get_lint_settings_level};\n use middle::pat_util::pat_bindings;\n "}, {"sha": "f58e066526c24bae4efb66a6243f02f261179d2b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -91,10 +91,8 @@ pub struct icx_popper {\n #[unsafe_destructor]\n impl Drop for icx_popper {\n     fn finalize(&self) {\n-        unsafe {\n-            if self.ccx.sess.count_llvm_insns() {\n-                self.ccx.stats.llvm_insn_ctxt.pop();\n-            }\n+        if self.ccx.sess.count_llvm_insns() {\n+            self.ccx.stats.llvm_insn_ctxt.pop();\n         }\n     }\n }\n@@ -145,9 +143,7 @@ pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n         }\n     });\n-    unsafe {\n-        lib::llvm::SetFunctionCallConv(llfn, cc);\n-    }\n+    lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n \n@@ -730,11 +726,9 @@ pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n \n pub fn cast_shift_const_rhs(op: ast::binop,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    unsafe {\n-        cast_shift_rhs(op, lhs, rhs,\n-                       |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n-                       |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n-    }\n+    cast_shift_rhs(op, lhs, rhs,\n+                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n+                   |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n }\n \n pub fn cast_shift_rhs(op: ast::binop,\n@@ -2865,9 +2859,7 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n         }\n     });\n-    unsafe {\n-        lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    }\n+    lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |key, &val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),"}, {"sha": "d6c045bb1158bca2e24ea99ff7e91e27f89c1ea1", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -27,9 +27,7 @@ use core::str;\n use core::vec;\n \n pub fn terminate(cx: block, _: &str) {\n-    unsafe {\n-        cx.terminated = true;\n-    }\n+    cx.terminated = true;\n }\n \n pub fn check_not_terminated(cx: block) {"}, {"sha": "c02417aca8b12db9ff1671126ec9e7316e91e527", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 142, "deletions": 152, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c24e20a9caf49b855b4c0de44aad6b039d09f4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=72c24e20a9caf49b855b4c0de44aad6b039d09f4", "patch": "@@ -172,74 +172,68 @@ fn cast_safely<T:Copy,U>(val: T) -> U {\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T {\n-    unsafe {\n-        match val {\n-          file_metadata(md) => cast_safely(md),\n-          compile_unit_metadata(md) => cast_safely(md),\n-          subprogram_metadata(md) => cast_safely(md),\n-          local_var_metadata(md) => cast_safely(md),\n-          tydesc_metadata(md) => cast_safely(md),\n-          block_metadata(md) => cast_safely(md),\n-          argument_metadata(md) => cast_safely(md),\n-          retval_metadata(md) => cast_safely(md)\n-        }\n+    match val {\n+      file_metadata(md) => cast_safely(md),\n+      compile_unit_metadata(md) => cast_safely(md),\n+      subprogram_metadata(md) => cast_safely(md),\n+      local_var_metadata(md) => cast_safely(md),\n+      tydesc_metadata(md) => cast_safely(md),\n+      block_metadata(md) => cast_safely(md),\n+      argument_metadata(md) => cast_safely(md),\n+      retval_metadata(md) => cast_safely(md)\n     }\n }\n \n fn cached_metadata<T:Copy>(cache: metadata_cache,\n                             mdtag: int,\n                             eq_fn: &fn(md: T) -> bool)\n                          -> Option<T> {\n-    unsafe {\n-        if cache.contains_key(&mdtag) {\n-            let items = cache.get(&mdtag);\n-            for items.each |item| {\n-                let md: T = md_from_metadata::<T>(*item);\n-                if eq_fn(md) {\n-                    return option::Some(md);\n-                }\n+    if cache.contains_key(&mdtag) {\n+        let items = cache.get(&mdtag);\n+        for items.each |item| {\n+            let md: T = md_from_metadata::<T>(*item);\n+            if eq_fn(md) {\n+                return option::Some(md);\n             }\n         }\n-        return option::None;\n     }\n+    return option::None;\n }\n \n fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n-    unsafe {\n-        let cache = get_cache(cx);\n-        let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-        let tg = CompileUnitTag;\n-        match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n-                            |md| md.data.name == crate_name) {\n-          option::Some(md) => return md,\n-          option::None => ()\n-        }\n+    let cache = get_cache(cx);\n+    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n+    let tg = CompileUnitTag;\n+    match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n+                        |md| md.data.name == crate_name) {\n+      option::Some(md) => return md,\n+      option::None => ()\n+    }\n \n-        let (_, work_dir) = get_file_path_and_dir(\n-            cx.sess.working_dir.to_str(), crate_name);\n-        let unit_metadata = ~[lltag(tg),\n-                             llunused(),\n-                             lli32(DW_LANG_RUST),\n-                             llstr(crate_name),\n-                             llstr(work_dir),\n-                             llstr(env!(\"CFG_VERSION\")),\n-                             lli1(true), // deprecated: main compile unit\n-                             lli1(cx.sess.opts.optimize != session::No),\n-                             llstr(~\"\"), // flags (???)\n-                             lli32(0) // runtime version (???)\n-                            ];\n-        let unit_node = llmdnode(unit_metadata);\n-        add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-        let mdval = @Metadata {\n-            node: unit_node,\n-            data: CompileUnitMetadata {\n-                name: crate_name\n-            }\n-        };\n-        update_cache(cache, tg, compile_unit_metadata(mdval));\n+    let (_, work_dir) = get_file_path_and_dir(\n+        cx.sess.working_dir.to_str(), crate_name);\n+    let unit_metadata = ~[lltag(tg),\n+                         llunused(),\n+                         lli32(DW_LANG_RUST),\n+                         llstr(crate_name),\n+                         llstr(work_dir),\n+                         llstr(env!(\"CFG_VERSION\")),\n+                         lli1(true), // deprecated: main compile unit\n+                         lli1(cx.sess.opts.optimize != session::No),\n+                         llstr(~\"\"), // flags (???)\n+                         lli32(0) // runtime version (???)\n+                        ];\n+    let unit_node = llmdnode(unit_metadata);\n+    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n+    let mdval = @Metadata {\n+        node: unit_node,\n+        data: CompileUnitMetadata {\n+            name: crate_name\n+        }\n+    };\n+    update_cache(cache, tg, compile_unit_metadata(mdval));\n \n-        return mdval;\n-    }\n+    return mdval;\n }\n \n fn get_cache(cx: @CrateContext) -> metadata_cache {\n@@ -710,113 +704,109 @@ fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n \n pub fn create_local_var(bcx: block, local: @ast::local)\n     -> @Metadata<LocalVarMetadata> {\n-    unsafe {\n-        let cx = bcx.ccx();\n-        let cache = get_cache(cx);\n-        let tg = AutoVariableTag;\n-        match cached_metadata::<@Metadata<LocalVarMetadata>>(\n-            cache, tg, |md| md.data.id == local.node.id) {\n-          option::Some(md) => return md,\n-          option::None => ()\n+    let cx = bcx.ccx();\n+    let cache = get_cache(cx);\n+    let tg = AutoVariableTag;\n+    match cached_metadata::<@Metadata<LocalVarMetadata>>(\n+        cache, tg, |md| md.data.id == local.node.id) {\n+      option::Some(md) => return md,\n+      option::None => ()\n+    }\n+\n+    let name = match local.node.pat.node {\n+      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      // FIXME this should be handled (#2533)\n+      _ => fail!(~\"no single variable name for local\")\n+    };\n+    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+    let ty = node_id_type(bcx, local.node.id);\n+    let tymd = create_ty(cx, ty, local.node.ty.span);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let context = match bcx.parent {\n+        None => create_function(bcx.fcx).node,\n+        Some(_) => create_block(bcx).node\n+    };\n+    let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n+                            filemd.node, loc.line as int, tymd.node);\n+    let mdval = @Metadata {\n+        node: mdnode,\n+        data: LocalVarMetadata {\n+            id: local.node.id\n         }\n+    };\n+    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-        let name = match local.node.pat.node {\n-          ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n-          // FIXME this should be handled (#2533)\n-          _ => fail!(~\"no single variable name for local\")\n-        };\n-        let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n-        let ty = node_id_type(bcx, local.node.id);\n-        let tymd = create_ty(cx, ty, local.node.ty.span);\n-        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-        let context = match bcx.parent {\n-            None => create_function(bcx.fcx).node,\n-            Some(_) => create_block(bcx).node\n-        };\n-        let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n-                                filemd.node, loc.line as int, tymd.node);\n-        let mdval = @Metadata {\n-            node: mdnode,\n-            data: LocalVarMetadata {\n-                id: local.node.id\n-            }\n-        };\n-        update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n-\n-        let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-          option::Some(&local_mem(v)) => v,\n-          option::Some(_) => {\n-            bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                    something weird\");\n-          }\n-          option::None => {\n-            match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n-              local_imm(v) => v,\n-              _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                                                         something weird\")\n-            }\n-          }\n-        };\n-        let declargs = ~[llmdnode(~[llptr]), mdnode];\n-        trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n-                           declargs);\n-        return mdval;\n-    }\n+    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n+      option::Some(&local_mem(v)) => v,\n+      option::Some(_) => {\n+        bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                something weird\");\n+      }\n+      option::None => {\n+        match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n+          local_imm(v) => v,\n+          _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                                                     something weird\")\n+        }\n+      }\n+    };\n+    let declargs = ~[llmdnode(~[llptr]), mdnode];\n+    trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                       declargs);\n+    return mdval;\n }\n \n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@Metadata<ArgumentMetadata>> {\n-    unsafe {\n-        let fcx = bcx.fcx, cx = *fcx.ccx;\n-        let cache = get_cache(cx);\n-        let tg = ArgVariableTag;\n-        match cached_metadata::<@Metadata<ArgumentMetadata>>(\n-            cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-          option::Some(md) => return Some(md),\n-          option::None => ()\n-        }\n+    let fcx = bcx.fcx, cx = *fcx.ccx;\n+    let cache = get_cache(cx);\n+    let tg = ArgVariableTag;\n+    match cached_metadata::<@Metadata<ArgumentMetadata>>(\n+        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n+      option::Some(md) => return Some(md),\n+      option::None => ()\n+    }\n \n-        let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-        if loc.file.name == ~\"<intrinsic>\" {\n-            return None;\n+    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    if loc.file.name == ~\"<intrinsic>\" {\n+        return None;\n+    }\n+    let ty = node_id_type(bcx, arg.id);\n+    let tymd = create_ty(cx, ty, arg.ty.span);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let context = create_function(bcx.fcx);\n+\n+    match arg.pat.node {\n+        ast::pat_ident(_, path, _) => {\n+            // XXX: This is wrong; it should work for multiple bindings.\n+            let mdnode = create_var(\n+                tg,\n+                context.node,\n+                *cx.sess.str_of(*path.idents.last()),\n+                filemd.node,\n+                loc.line as int,\n+                tymd.node\n+            );\n+\n+            let mdval = @Metadata {\n+                node: mdnode,\n+                data: ArgumentMetadata {\n+                    id: arg.id\n+                }\n+            };\n+            update_cache(cache, tg, argument_metadata(mdval));\n+\n+            let llptr = match *fcx.llargs.get(&arg.id) {\n+              local_mem(v) | local_imm(v) => v,\n+            };\n+            let declargs = ~[llmdnode(~[llptr]), mdnode];\n+            trans::build::Call(bcx,\n+                               *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                               declargs);\n+            return Some(mdval);\n         }\n-        let ty = node_id_type(bcx, arg.id);\n-        let tymd = create_ty(cx, ty, arg.ty.span);\n-        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-        let context = create_function(bcx.fcx);\n-\n-        match arg.pat.node {\n-            ast::pat_ident(_, path, _) => {\n-                // XXX: This is wrong; it should work for multiple bindings.\n-                let mdnode = create_var(\n-                    tg,\n-                    context.node,\n-                    *cx.sess.str_of(*path.idents.last()),\n-                    filemd.node,\n-                    loc.line as int,\n-                    tymd.node\n-                );\n-\n-                let mdval = @Metadata {\n-                    node: mdnode,\n-                    data: ArgumentMetadata {\n-                        id: arg.id\n-                    }\n-                };\n-                update_cache(cache, tg, argument_metadata(mdval));\n-\n-                let llptr = match *fcx.llargs.get(&arg.id) {\n-                  local_mem(v) | local_imm(v) => v,\n-                };\n-                let declargs = ~[llmdnode(~[llptr]), mdnode];\n-                trans::build::Call(bcx,\n-                                   *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n-                                   declargs);\n-                return Some(mdval);\n-            }\n-            _ => {\n-                return None;\n-            }\n+        _ => {\n+            return None;\n         }\n     }\n }"}]}