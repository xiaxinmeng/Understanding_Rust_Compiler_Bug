{"sha": "6caaa34dedc45543e4d2c7600f952e042d9258df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYWFhMzRkZWRjNDU1NDNlNGQyYzc2MDBmOTUyZTA0MmQ5MjU4ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T09:49:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-03T09:49:51Z"}, "message": "auto merge of #7518 : graydon/rust/stats-improvements, r=catamorphism", "tree": {"sha": "9c00e556c7c850bf6597c41d707c9384b97a2a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c00e556c7c850bf6597c41d707c9384b97a2a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6caaa34dedc45543e4d2c7600f952e042d9258df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6caaa34dedc45543e4d2c7600f952e042d9258df", "html_url": "https://github.com/rust-lang/rust/commit/6caaa34dedc45543e4d2c7600f952e042d9258df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6caaa34dedc45543e4d2c7600f952e042d9258df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea31b9cca1e63a01fa75874cebca3f72f46ae029", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea31b9cca1e63a01fa75874cebca3f72f46ae029", "html_url": "https://github.com/rust-lang/rust/commit/ea31b9cca1e63a01fa75874cebca3f72f46ae029"}, {"sha": "652dc73b4db157f46c4a022be7f2fdcf81f3ad56", "url": "https://api.github.com/repos/rust-lang/rust/commits/652dc73b4db157f46c4a022be7f2fdcf81f3ad56", "html_url": "https://github.com/rust-lang/rust/commit/652dc73b4db157f46c4a022be7f2fdcf81f3ad56"}], "stats": {"total": 848, "additions": 830, "deletions": 18}, "files": [{"sha": "0271b393f61163fd0aebd287c4a0bb0690752cab", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 830, "deletions": 18, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/6caaa34dedc45543e4d2c7600f952e042d9258df/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caaa34dedc45543e4d2c7600f952e042d9258df/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=6caaa34dedc45543e4d2c7600f952e042d9258df", "patch": "@@ -8,32 +8,135 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(missing_doc)];\n-\n-\n-use std::f64;\n+use sort;\n use std::cmp;\n+use std::io;\n use std::num;\n+use std::f64;\n use std::vec;\n-use sort;\n \n // NB: this can probably be rewritten in terms of num::Num\n // to be less f64-specific.\n \n+/// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n pub trait Stats {\n+\n+    /// Sum of the samples.\n     fn sum(self) -> f64;\n+\n+    /// Minimum value of the samples.\n     fn min(self) -> f64;\n+\n+    /// Maximum value of the samples.\n     fn max(self) -> f64;\n+\n+    /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n     fn mean(self) -> f64;\n+\n+    /// Median of the samples: value separating the lower half of the samples from the higher half.\n+    /// Equal to `self.percentile(50.0)`.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Median\n     fn median(self) -> f64;\n+\n+    /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n+    /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n+    /// population variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\n+    /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n+    /// than `n`.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Variance\n     fn var(self) -> f64;\n+\n+    /// Standard deviation: the square root of the sample variance.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev` for unknown distributions.\n+    ///\n+    /// See: https://en.wikipedia.org/wiki/Standard_deviation\n     fn std_dev(self) -> f64;\n+\n+    /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev_pct` for unknown distributions.\n     fn std_dev_pct(self) -> f64;\n+\n+    /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n+    /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n+    /// `std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\n+    /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n+    /// deviation.\n+    ///\n+    /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n     fn median_abs_dev(self) -> f64;\n+\n+    /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n     fn median_abs_dev_pct(self) -> f64;\n+\n+    /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n+    /// percentile(95.0) will return the value `v` such that that 95% of the samples `s` in `self`\n+    /// satisfy `s <= v`.\n+    ///\n+    /// Calculated by linear interpolation between closest ranks.\n+    ///\n+    /// See: http://en.wikipedia.org/wiki/Percentile\n+    fn percentile(self, pct: f64) -> f64;\n+\n+    /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n+    /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n+    /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n+    /// is otherwise equivalent.\n+    ///\n+    /// See also: https://en.wikipedia.org/wiki/Quartile\n+    fn quartiles(self) -> (f64,f64,f64);\n+\n+    /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n+    /// percentile (3rd quartile). See `quartiles`.\n+    ///\n+    /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n+    fn iqr(self) -> f64;\n+}\n+\n+/// Extracted collection of all the summary statistics of a sample set.\n+struct Summary {\n+    sum: f64,\n+    min: f64,\n+    max: f64,\n+    mean: f64,\n+    median: f64,\n+    var: f64,\n+    std_dev: f64,\n+    std_dev_pct: f64,\n+    median_abs_dev: f64,\n+    median_abs_dev_pct: f64,\n+    quartiles: (f64,f64,f64),\n+    iqr: f64,\n+}\n+\n+impl Summary {\n+    fn new(samples: &[f64]) -> Summary {\n+        Summary {\n+            sum: samples.sum(),\n+            min: samples.min(),\n+            max: samples.max(),\n+            mean: samples.mean(),\n+            median: samples.median(),\n+            var: samples.var(),\n+            std_dev: samples.std_dev(),\n+            std_dev_pct: samples.std_dev_pct(),\n+            median_abs_dev: samples.median_abs_dev(),\n+            median_abs_dev_pct: samples.median_abs_dev_pct(),\n+            quartiles: samples.quartiles(),\n+            iqr: samples.iqr()\n+        }\n+    }\n }\n \n impl<'self> Stats for &'self [f64] {\n+\n     fn sum(self) -> f64 {\n         self.iter().fold(0.0, |p,q| p + *q)\n     }\n@@ -54,19 +157,11 @@ impl<'self> Stats for &'self [f64] {\n     }\n \n     fn median(self) -> f64 {\n-        assert!(self.len() != 0);\n-        let mut tmp = vec::to_owned(self);\n-        sort::tim_sort(tmp);\n-        if tmp.len() & 1 == 0 {\n-            let m = tmp.len() / 2;\n-            (tmp[m] + tmp[m-1]) / 2.0\n-        } else {\n-            tmp[tmp.len() / 2]\n-        }\n+        self.percentile(50.0)\n     }\n \n     fn var(self) -> f64 {\n-        if self.len() == 0 {\n+        if self.len() < 2 {\n             0.0\n         } else {\n             let mean = self.mean();\n@@ -75,7 +170,10 @@ impl<'self> Stats for &'self [f64] {\n                 let x = *s - mean;\n                 v += x*x;\n             }\n-            v/(self.len() as f64)\n+            // NB: this is _supposed to be_ len-1, not len. If you\n+            // change it back to len, you will be calculating a\n+            // population variance, not a sample variance.\n+            v/((self.len()-1) as f64)\n         }\n     }\n \n@@ -89,11 +187,725 @@ impl<'self> Stats for &'self [f64] {\n \n     fn median_abs_dev(self) -> f64 {\n         let med = self.median();\n-        let abs_devs = self.map(|v| num::abs(med - *v));\n-        abs_devs.median()\n+        let abs_devs = self.map(|&v| num::abs(med - v));\n+        // This constant is derived by smarter statistics brains than me, but it is\n+        // consistent with how R and other packages treat the MAD.\n+        abs_devs.median() * 1.4826\n     }\n \n     fn median_abs_dev_pct(self) -> f64 {\n         (self.median_abs_dev() / self.median()) * 100.0\n     }\n+\n+    fn percentile(self, pct: f64) -> f64 {\n+        let mut tmp = vec::to_owned(self);\n+        sort::tim_sort(tmp);\n+        percentile_of_sorted(tmp, pct)\n+    }\n+\n+    fn quartiles(self) -> (f64,f64,f64) {\n+        let mut tmp = vec::to_owned(self);\n+        sort::tim_sort(tmp);\n+        let a = percentile_of_sorted(tmp, 25.0);\n+        let b = percentile_of_sorted(tmp, 50.0);\n+        let c = percentile_of_sorted(tmp, 75.0);\n+        (a,b,c)\n+    }\n+\n+    fn iqr(self) -> f64 {\n+        let (a,_,c) = self.quartiles();\n+        c - a\n+    }\n+}\n+\n+\n+// Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n+// linear interpolation. If samples are not sorted, return nonsensical value.\n+priv fn percentile_of_sorted(sorted_samples: &[f64],\n+                             pct: f64) -> f64 {\n+    assert!(sorted_samples.len() != 0);\n+    if sorted_samples.len() == 1 {\n+        return sorted_samples[0];\n+    }\n+    assert!(0.0 <= pct);\n+    assert!(pct <= 100.0);\n+    if pct == 100.0 {\n+        return sorted_samples[sorted_samples.len() - 1];\n+    }\n+    let rank = (pct / 100.0) * ((sorted_samples.len() - 1) as f64);\n+    let lrank = rank.floor();\n+    let d = rank - lrank;\n+    let n = lrank as uint;\n+    let lo = sorted_samples[n];\n+    let hi = sorted_samples[n+1];\n+    lo + (hi - lo) * d\n+}\n+\n+\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\n+/// percentile with those percentiles themselves. This is a way of minimizing the effect of\n+/// outliers, at the cost of biasing the sample. It differs from trimming in that it does not\n+/// change the number of samples, just changes the values of those that are outliers.\n+///\n+/// See: http://en.wikipedia.org/wiki/Winsorising\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n+    let mut tmp = vec::to_owned(samples);\n+    sort::tim_sort(tmp);\n+    let lo = percentile_of_sorted(tmp, pct);\n+    let hi = percentile_of_sorted(tmp, 100.0-pct);\n+    for samples.mut_iter().advance |samp| {\n+        if *samp > hi {\n+            *samp = hi\n+        } else if *samp < lo {\n+            *samp = lo\n+        }\n+    }\n+}\n+\n+/// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n+pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n+    let (q1,q2,q3) = s.quartiles;\n+    w.write_str(fmt!(\"(min=%f, q1=%f, med=%f, q3=%f, max=%f)\",\n+                     s.min as float,\n+                     q1 as float,\n+                     q2 as float,\n+                     q3 as float,\n+                     s.max as float));\n+}\n+\n+/// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n+/// provided `Summary` (thus includes the mean) and is scaled to display within the range of the\n+/// nearest multiple-of-a-power-of-ten above and below the min and max of possible values, and\n+/// target `width_hint` characters of display (though it will be wider if necessary).\n+///\n+/// As an example, the summary with 5-number-summary `(min=15, q1=17, med=20, q3=24, max=31)` might\n+/// display as:\n+///\n+/// ~~~~\n+///   10 |        [--****#******----------]          | 40\n+/// ~~~~\n+\n+pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n+\n+    let (q1,q2,q3) = s.quartiles;\n+\n+    let lomag = (10.0_f64).pow(&s.min.log10().floor());\n+    let himag = (10.0_f64).pow(&(s.max.log10().floor()));\n+    let lo = (s.min / lomag).floor() * lomag;\n+    let hi = (s.max / himag).ceil() * himag;\n+\n+    let range = hi - lo;\n+\n+    let lostr = lo.to_str();\n+    let histr = hi.to_str();\n+\n+    let overhead_width = lostr.len() + histr.len() + 4;\n+    let range_width = width_hint - overhead_width;;\n+    let char_step = range / (range_width as f64);\n+\n+    w.write_str(lostr);\n+    w.write_char(' ');\n+    w.write_char('|');\n+\n+    let mut c = 0;\n+    let mut v = lo;\n+\n+    while c < range_width && v < s.min {\n+        w.write_char(' ');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char('[');\n+    c += 1;\n+    while c < range_width && v < q1 {\n+        w.write_char('-');\n+        v += char_step;\n+        c += 1;\n+    }\n+    while c < range_width && v < q2 {\n+        w.write_char('*');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char('#');\n+    c += 1;\n+    while c < range_width && v < q3 {\n+        w.write_char('*');\n+        v += char_step;\n+        c += 1;\n+    }\n+    while c < range_width && v < s.max {\n+        w.write_char('-');\n+        v += char_step;\n+        c += 1;\n+    }\n+    w.write_char(']');\n+    while c < range_width {\n+        w.write_char(' ');\n+        v += char_step;\n+        c += 1;\n+    }\n+\n+    w.write_char('|');\n+    w.write_char(' ');\n+    w.write_str(histr);\n+}\n+\n+// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use stats::Stats;\n+    use stats::Summary;\n+    use stats::write_5_number_summary;\n+    use stats::write_boxplot;\n+    use std::io;\n+\n+    fn check(samples: &[f64], summ: &Summary) {\n+\n+        let summ2 = Summary::new(samples);\n+\n+        let w = io::stdout();\n+        w.write_char('\\n');\n+        write_5_number_summary(w, &summ2);\n+        w.write_char('\\n');\n+        write_boxplot(w, &summ2, 50);\n+        w.write_char('\\n');\n+\n+        assert_eq!(summ.sum, summ2.sum);\n+        assert_eq!(summ.min, summ2.min);\n+        assert_eq!(summ.max, summ2.max);\n+        assert_eq!(summ.mean, summ2.mean);\n+        assert_eq!(summ.median, summ2.median);\n+\n+        // We needed a few more digits to get exact equality on these\n+        // but they're within float epsilon, which is 1.0e-6.\n+        assert_approx_eq!(summ.var, summ2.var);\n+        assert_approx_eq!(summ.std_dev, summ2.std_dev);\n+        assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n+        assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n+        assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n+\n+        assert_eq!(summ.quartiles, summ2.quartiles);\n+        assert_eq!(summ.iqr, summ2.iqr);\n+    }\n+\n+    #[test]\n+    fn test_norm2() {\n+        let val = &[\n+            958.0000000000,\n+            924.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1882.0000000000,\n+            min: 924.0000000000,\n+            max: 958.0000000000,\n+            mean: 941.0000000000,\n+            median: 941.0000000000,\n+            var: 578.0000000000,\n+            std_dev: 24.0416305603,\n+            std_dev_pct: 2.5549022912,\n+            median_abs_dev: 25.2042000000,\n+            median_abs_dev_pct: 2.6784484591,\n+            quartiles: (932.5000000000,941.0000000000,949.5000000000),\n+            iqr: 17.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10narrow() {\n+        let val = &[\n+            966.0000000000,\n+            985.0000000000,\n+            1110.0000000000,\n+            848.0000000000,\n+            821.0000000000,\n+            975.0000000000,\n+            962.0000000000,\n+            1157.0000000000,\n+            1217.0000000000,\n+            955.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9996.0000000000,\n+            min: 821.0000000000,\n+            max: 1217.0000000000,\n+            mean: 999.6000000000,\n+            median: 970.5000000000,\n+            var: 16050.7111111111,\n+            std_dev: 126.6914010938,\n+            std_dev_pct: 12.6742097933,\n+            median_abs_dev: 102.2994000000,\n+            median_abs_dev_pct: 10.5408964451,\n+            quartiles: (956.7500000000,970.5000000000,1078.7500000000),\n+            iqr: 122.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10medium() {\n+        let val = &[\n+            954.0000000000,\n+            1064.0000000000,\n+            855.0000000000,\n+            1000.0000000000,\n+            743.0000000000,\n+            1084.0000000000,\n+            704.0000000000,\n+            1023.0000000000,\n+            357.0000000000,\n+            869.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 8653.0000000000,\n+            min: 357.0000000000,\n+            max: 1084.0000000000,\n+            mean: 865.3000000000,\n+            median: 911.5000000000,\n+            var: 48628.4555555556,\n+            std_dev: 220.5186059170,\n+            std_dev_pct: 25.4846418487,\n+            median_abs_dev: 195.7032000000,\n+            median_abs_dev_pct: 21.4704552935,\n+            quartiles: (771.0000000000,911.5000000000,1017.2500000000),\n+            iqr: 246.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10wide() {\n+        let val = &[\n+            505.0000000000,\n+            497.0000000000,\n+            1591.0000000000,\n+            887.0000000000,\n+            1026.0000000000,\n+            136.0000000000,\n+            1580.0000000000,\n+            940.0000000000,\n+            754.0000000000,\n+            1433.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9349.0000000000,\n+            min: 136.0000000000,\n+            max: 1591.0000000000,\n+            mean: 934.9000000000,\n+            median: 913.5000000000,\n+            var: 239208.9888888889,\n+            std_dev: 489.0899599142,\n+            std_dev_pct: 52.3146817750,\n+            median_abs_dev: 611.5725000000,\n+            median_abs_dev_pct: 66.9482758621,\n+            quartiles: (567.2500000000,913.5000000000,1331.2500000000),\n+            iqr: 764.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm25verynarrow() {\n+        let val = &[\n+            991.0000000000,\n+            1018.0000000000,\n+            998.0000000000,\n+            1013.0000000000,\n+            974.0000000000,\n+            1007.0000000000,\n+            1014.0000000000,\n+            999.0000000000,\n+            1011.0000000000,\n+            978.0000000000,\n+            985.0000000000,\n+            999.0000000000,\n+            983.0000000000,\n+            982.0000000000,\n+            1015.0000000000,\n+            1002.0000000000,\n+            977.0000000000,\n+            948.0000000000,\n+            1040.0000000000,\n+            974.0000000000,\n+            996.0000000000,\n+            989.0000000000,\n+            1015.0000000000,\n+            994.0000000000,\n+            1024.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 24926.0000000000,\n+            min: 948.0000000000,\n+            max: 1040.0000000000,\n+            mean: 997.0400000000,\n+            median: 998.0000000000,\n+            var: 393.2066666667,\n+            std_dev: 19.8294393937,\n+            std_dev_pct: 1.9888308788,\n+            median_abs_dev: 22.2390000000,\n+            median_abs_dev_pct: 2.2283567134,\n+            quartiles: (983.0000000000,998.0000000000,1013.0000000000),\n+            iqr: 30.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10a() {\n+        let val = &[\n+            23.0000000000,\n+            11.0000000000,\n+            2.0000000000,\n+            57.0000000000,\n+            4.0000000000,\n+            12.0000000000,\n+            5.0000000000,\n+            29.0000000000,\n+            3.0000000000,\n+            21.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 167.0000000000,\n+            min: 2.0000000000,\n+            max: 57.0000000000,\n+            mean: 16.7000000000,\n+            median: 11.5000000000,\n+            var: 287.7888888889,\n+            std_dev: 16.9643416875,\n+            std_dev_pct: 101.5828843560,\n+            median_abs_dev: 13.3434000000,\n+            median_abs_dev_pct: 116.0295652174,\n+            quartiles: (4.2500000000,11.5000000000,22.5000000000),\n+            iqr: 18.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10b() {\n+        let val = &[\n+            24.0000000000,\n+            17.0000000000,\n+            6.0000000000,\n+            38.0000000000,\n+            25.0000000000,\n+            7.0000000000,\n+            51.0000000000,\n+            2.0000000000,\n+            61.0000000000,\n+            32.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 263.0000000000,\n+            min: 2.0000000000,\n+            max: 61.0000000000,\n+            mean: 26.3000000000,\n+            median: 24.5000000000,\n+            var: 383.5666666667,\n+            std_dev: 19.5848580967,\n+            std_dev_pct: 74.4671410520,\n+            median_abs_dev: 22.9803000000,\n+            median_abs_dev_pct: 93.7971428571,\n+            quartiles: (9.5000000000,24.5000000000,36.5000000000),\n+            iqr: 27.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10c() {\n+        let val = &[\n+            71.0000000000,\n+            2.0000000000,\n+            32.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            28.0000000000,\n+            13.0000000000,\n+            37.0000000000,\n+            16.0000000000,\n+            36.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 242.0000000000,\n+            min: 1.0000000000,\n+            max: 71.0000000000,\n+            mean: 24.2000000000,\n+            median: 22.0000000000,\n+            var: 458.1777777778,\n+            std_dev: 21.4050876611,\n+            std_dev_pct: 88.4507754589,\n+            median_abs_dev: 21.4977000000,\n+            median_abs_dev_pct: 97.7168181818,\n+            quartiles: (7.7500000000,22.0000000000,35.0000000000),\n+            iqr: 27.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp25() {\n+        let val = &[\n+            3.0000000000,\n+            24.0000000000,\n+            1.0000000000,\n+            19.0000000000,\n+            7.0000000000,\n+            5.0000000000,\n+            30.0000000000,\n+            39.0000000000,\n+            31.0000000000,\n+            13.0000000000,\n+            25.0000000000,\n+            48.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            42.0000000000,\n+            63.0000000000,\n+            2.0000000000,\n+            12.0000000000,\n+            108.0000000000,\n+            26.0000000000,\n+            1.0000000000,\n+            7.0000000000,\n+            44.0000000000,\n+            25.0000000000,\n+            11.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 593.0000000000,\n+            min: 1.0000000000,\n+            max: 108.0000000000,\n+            mean: 23.7200000000,\n+            median: 19.0000000000,\n+            var: 601.0433333333,\n+            std_dev: 24.5161851301,\n+            std_dev_pct: 103.3565983562,\n+            median_abs_dev: 19.2738000000,\n+            median_abs_dev_pct: 101.4410526316,\n+            quartiles: (6.0000000000,19.0000000000,31.0000000000),\n+            iqr: 25.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_binom25() {\n+        let val = &[\n+            18.0000000000,\n+            17.0000000000,\n+            27.0000000000,\n+            15.0000000000,\n+            21.0000000000,\n+            25.0000000000,\n+            17.0000000000,\n+            24.0000000000,\n+            25.0000000000,\n+            24.0000000000,\n+            26.0000000000,\n+            26.0000000000,\n+            23.0000000000,\n+            15.0000000000,\n+            23.0000000000,\n+            17.0000000000,\n+            18.0000000000,\n+            18.0000000000,\n+            21.0000000000,\n+            16.0000000000,\n+            15.0000000000,\n+            31.0000000000,\n+            20.0000000000,\n+            17.0000000000,\n+            15.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 514.0000000000,\n+            min: 15.0000000000,\n+            max: 31.0000000000,\n+            mean: 20.5600000000,\n+            median: 20.0000000000,\n+            var: 20.8400000000,\n+            std_dev: 4.5650848842,\n+            std_dev_pct: 22.2037202539,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 29.6520000000,\n+            quartiles: (17.0000000000,20.0000000000,24.0000000000),\n+            iqr: 7.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda30() {\n+        let val = &[\n+            27.0000000000,\n+            33.0000000000,\n+            34.0000000000,\n+            34.0000000000,\n+            24.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            27.0000000000,\n+            31.0000000000,\n+            28.0000000000,\n+            38.0000000000,\n+            21.0000000000,\n+            33.0000000000,\n+            36.0000000000,\n+            29.0000000000,\n+            37.0000000000,\n+            32.0000000000,\n+            34.0000000000,\n+            31.0000000000,\n+            39.0000000000,\n+            25.0000000000,\n+            31.0000000000,\n+            32.0000000000,\n+            40.0000000000,\n+            24.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 787.0000000000,\n+            min: 21.0000000000,\n+            max: 40.0000000000,\n+            mean: 31.4800000000,\n+            median: 32.0000000000,\n+            var: 26.5933333333,\n+            std_dev: 5.1568724372,\n+            std_dev_pct: 16.3814245145,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 18.5325000000,\n+            quartiles: (28.0000000000,32.0000000000,34.0000000000),\n+            iqr: 6.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda40() {\n+        let val = &[\n+            42.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            46.0000000000,\n+            34.0000000000,\n+            45.0000000000,\n+            34.0000000000,\n+            49.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            40.0000000000,\n+            35.0000000000,\n+            37.0000000000,\n+            39.0000000000,\n+            46.0000000000,\n+            44.0000000000,\n+            32.0000000000,\n+            45.0000000000,\n+            42.0000000000,\n+            37.0000000000,\n+            48.0000000000,\n+            42.0000000000,\n+            33.0000000000,\n+            42.0000000000,\n+            48.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1019.0000000000,\n+            min: 28.0000000000,\n+            max: 50.0000000000,\n+            mean: 40.7600000000,\n+            median: 42.0000000000,\n+            var: 34.4400000000,\n+            std_dev: 5.8685603004,\n+            std_dev_pct: 14.3978417577,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 14.1200000000,\n+            quartiles: (37.0000000000,42.0000000000,45.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda50() {\n+        let val = &[\n+            45.0000000000,\n+            43.0000000000,\n+            44.0000000000,\n+            61.0000000000,\n+            51.0000000000,\n+            53.0000000000,\n+            59.0000000000,\n+            52.0000000000,\n+            49.0000000000,\n+            51.0000000000,\n+            51.0000000000,\n+            50.0000000000,\n+            49.0000000000,\n+            56.0000000000,\n+            42.0000000000,\n+            52.0000000000,\n+            51.0000000000,\n+            43.0000000000,\n+            48.0000000000,\n+            48.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            43.0000000000,\n+            42.0000000000,\n+            60.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1235.0000000000,\n+            min: 42.0000000000,\n+            max: 61.0000000000,\n+            mean: 49.4000000000,\n+            median: 50.0000000000,\n+            var: 31.6666666667,\n+            std_dev: 5.6273143387,\n+            std_dev_pct: 11.3913245723,\n+            median_abs_dev: 4.4478000000,\n+            median_abs_dev_pct: 8.8956000000,\n+            quartiles: (44.0000000000,50.0000000000,52.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_unif25() {\n+        let val = &[\n+            99.0000000000,\n+            55.0000000000,\n+            92.0000000000,\n+            79.0000000000,\n+            14.0000000000,\n+            2.0000000000,\n+            33.0000000000,\n+            49.0000000000,\n+            3.0000000000,\n+            32.0000000000,\n+            84.0000000000,\n+            59.0000000000,\n+            22.0000000000,\n+            86.0000000000,\n+            76.0000000000,\n+            31.0000000000,\n+            29.0000000000,\n+            11.0000000000,\n+            41.0000000000,\n+            53.0000000000,\n+            45.0000000000,\n+            44.0000000000,\n+            98.0000000000,\n+            98.0000000000,\n+            7.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1242.0000000000,\n+            min: 2.0000000000,\n+            max: 99.0000000000,\n+            mean: 49.6800000000,\n+            median: 45.0000000000,\n+            var: 1015.6433333333,\n+            std_dev: 31.8691595957,\n+            std_dev_pct: 64.1488719719,\n+            median_abs_dev: 45.9606000000,\n+            median_abs_dev_pct: 102.1346666667,\n+            quartiles: (29.0000000000,45.0000000000,79.0000000000),\n+            iqr: 50.0000000000,\n+        };\n+        check(val, summ);\n+    }\n }"}]}