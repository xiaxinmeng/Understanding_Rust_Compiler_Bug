{"sha": "77be06b7ed147c80b4b8e035a877cea45ece9f3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YmUwNmI3ZWQxNDdjODBiNGI4ZTAzNWE4NzdjZWE0NWVjZTlmM2Y=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-28T08:44:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-02T08:36:18Z"}, "message": "no longer assume that there is a default tag: give the machine the chance to tag all allocations", "tree": {"sha": "55f5a05c3466ce4ae494061bc9c15867f72c15ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55f5a05c3466ce4ae494061bc9c15867f72c15ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77be06b7ed147c80b4b8e035a877cea45ece9f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77be06b7ed147c80b4b8e035a877cea45ece9f3f", "html_url": "https://github.com/rust-lang/rust/commit/77be06b7ed147c80b4b8e035a877cea45ece9f3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77be06b7ed147c80b4b8e035a877cea45ece9f3f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2726a91ccacb6d3e2936ba3f6d12a85fb1f24e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2726a91ccacb6d3e2936ba3f6d12a85fb1f24e4f", "html_url": "https://github.com/rust-lang/rust/commit/2726a91ccacb6d3e2936ba3f6d12a85fb1f24e4f"}], "stats": {"total": 423, "additions": 196, "deletions": 227}, "files": [{"sha": "215d4295e44e1ed523bfe00a07aff0b8a9c215ad", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -111,9 +111,10 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n // For Tag=() and no extra state, we have is a trivial implementation.\n impl AllocationExtra<()> for () { }\n \n-impl<Tag, Extra> Allocation<Tag, Extra> {\n+// The constructors are all without extra; the extra gets added by a machine hook later.\n+impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n-    pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align, extra: Extra) -> Self {\n+    pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n         let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n         Self {\n@@ -122,23 +123,23 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n             undef_mask,\n             align,\n             mutability: Mutability::Immutable,\n-            extra,\n+            extra: (),\n         }\n     }\n \n-    pub fn from_byte_aligned_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, extra: Extra) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap(), extra)\n+    pub fn from_byte_aligned_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>) -> Self {\n+        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n     }\n \n-    pub fn undef(size: Size, align: Align, extra: Extra) -> Self {\n+    pub fn undef(size: Size, align: Align) -> Self {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n             align,\n             mutability: Mutability::Mutable,\n-            extra,\n+            extra: (),\n         }\n     }\n }"}, {"sha": "4aa83a79d52b8bef5a187e14679eefde153417a2", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -116,13 +116,6 @@ impl<'tcx> Pointer<()> {\n     {\n         Pointer::new_with_tag(self.alloc_id, self.offset, tag)\n     }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n }\n \n impl<'tcx, Tag> Pointer<Tag> {"}, {"sha": "1c24f5c116cced197949022f6aafe557c56917f1", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -140,23 +140,18 @@ impl<'tcx> Scalar<()> {\n \n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n+        // Used by `MemPlace::replace_tag`\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n }\n \n impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn erase_tag(self) -> Scalar {\n+        // Used by error reporting code to avoid having the error type depend on `Tag`\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n@@ -476,27 +471,11 @@ impl<Tag> fmt::Display for ScalarMaybeUndef<Tag> {\n     }\n }\n \n-impl<'tcx> ScalarMaybeUndef<()> {\n-    #[inline]\n-    pub fn with_tag<Tag>(self, new_tag: Tag) -> ScalarMaybeUndef<Tag> {\n-        match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_tag(new_tag)),\n-            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n-}\n-\n impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     #[inline]\n     pub fn erase_tag(self) -> ScalarMaybeUndef\n     {\n+        // Used by error reporting code to avoid having the error type depend on `Tag`\n         match self {\n             ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.erase_tag()),\n             ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,"}, {"sha": "0cd19ca165aadfad69bf53d3b6b223b95191d20f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -1154,7 +1154,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n-        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes, ());\n+        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().create_memory_alloc(alloc)\n     }"}, {"sha": "dc7aa0f17e88cd20c85f02f8f5bf85716430e589", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, VariantIdx, Size};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n@@ -117,7 +117,7 @@ fn op_to_const<'tcx>(\n                 ),\n                 Scalar::Raw { .. } => (\n                     ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(\n-                        b\"\" as &[u8], (),\n+                        b\"\" as &[u8],\n                     )),\n                     0,\n                 ),\n@@ -397,27 +397,27 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn find_foreign_static(\n         _def_id: DefId,\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        _memory_extra: &(),\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n+    fn tag_allocation<'b>(\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n         _memory_extra: &(),\n-    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n-        // We do not use a tag so we can just cheaply forward the reference\n-        Cow::Borrowed(alloc)\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n     }\n \n     #[inline(always)]\n-    fn new_allocation(\n-        _size: Size,\n-        _extra: &Self::MemoryExtra,\n-        _kind: MemoryKind<!>,\n-    ) -> (Self::AllocExtra, Self::PointerTag) {\n-        ((), ())\n+    fn tag_static_base_pointer(\n+        _id: AllocId,\n+        _memory_extra: &(),\n+    ) -> Self::PointerTag {\n+        ()\n     }\n \n     fn box_alloc("}, {"sha": "a5be55d16d488b7049ce0c5239d2804988b3db99", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -30,13 +30,13 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         },\n         LitKind::Err(ref s) => {\n             let s = s.as_str();\n-            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n             let allocation = tcx.intern_const_alloc(allocation);\n             return Ok(tcx.mk_const(ty::Const {\n                 val: ConstValue::Slice{ data: allocation, start: 0, end: s.len() },"}, {"sha": "594802a03410ce14b2b50936b74a5bf3864c0864", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -225,6 +225,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &mut self.memory\n     }\n \n+    #[inline(always)]\n+    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        self.memory.tag_static_base_pointer(ptr)\n+    }\n+\n     #[inline(always)]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         &self.stack\n@@ -363,11 +368,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n-        let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n-        Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self))\n-    }\n-\n     /// Returns the actual dynamic size and alignment of the place at the given type.\n     /// Only the \"meta\" (metadata) part of the place matters.\n     /// This can fail to provide an answer for extern types."}, {"sha": "456fc70fc0d1dc9c5df12861943d0081301f3cb4", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -215,7 +215,7 @@ impl Write for AbsolutePathPrinter<'_, '_> {\n pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let len = path.len();\n-    let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes(), ());\n+    let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     let alloc = tcx.intern_const_alloc(alloc);\n     tcx.mk_const(ty::Const {\n         val: ConstValue::Slice {"}, {"sha": "7bf92711766a033c4cfe86c7e17511376fddbcf1", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -5,13 +5,13 @@\n use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n-use rustc::hir::{self, def_id::DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt, layout::Size};\n+use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, MemoryKind,\n+    InterpretCx, PlaceTy, OpTy, ImmTy, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -65,7 +65,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n-    type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n+    type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n \n     /// Extra data stored in every call frame.\n     type FrameExtra;\n@@ -90,7 +90,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The memory kind to use for copied statics -- or None if statics should not be mutated\n     /// and thus any such attempt will cause a `ModifiedStatic` error to be raised.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n-    /// `static_with_default_tag` or `find_foreign_static` (see below) returns an owned allocation\n+    /// `tag_allocation` or `find_foreign_static` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n@@ -133,11 +133,12 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// This will only be called once per static and machine; the result is cached in\n     /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n+    ///\n+    /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        memory_extra: &Self::MemoryExtra,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -156,36 +157,37 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the right type for this machine.\n+    /// Called to initialize the \"extra\" state of an allocation and make the pointers\n+    /// it contains (in relocations) tagged.  The way we construct allocations is\n+    /// to always first construct it without extra and then add the extra.\n+    /// This keeps uniform code paths for handling both allocations created by CTFE\n+    /// for statics, and allocations ceated by Miri during evaluation.\n+    ///\n+    /// `kind` is the kind of the allocation being tagged; it can be `None` when\n+    /// it's a static and `STATIC_KIND` is `None`.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n+    ///\n+    /// The tag returned must be the same as the one returned by `tag_base_pointer`.\n+    fn tag_allocation<'b>(\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKinds>>,\n         memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n-\n-    /// Computes the extra state and the tag for a new allocation.\n-    fn new_allocation(\n-        size: Size,\n-        extra: &Self::MemoryExtra,\n-        kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> (Self::AllocExtra, Self::PointerTag);\n-\n-    /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the chance to adjust the tag. It should not change anything else!\n-    /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n-    #[inline]\n-    fn tag_dereference(\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Self::PointerTag>,\n-        _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n-        Ok(place.ptr)\n-    }\n+    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n+\n+    /// Return the \"base\" tag for the given static allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation.\n+    ///\n+    /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n+    /// for cyclic statics!\n+    fn tag_static_base_pointer(\n+        id: AllocId,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n     #[inline]"}, {"sha": "2538a82f5c5c4b54756484897b7c24ed75b64061", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 79, "deletions": 53, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -108,33 +108,44 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    #[inline]\n+    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self.extra))\n+    }\n+\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        // Default tag is okay because anyway you cannot access memory with this.\n-        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance)).with_default_tag()\n+        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n+        self.tag_static_base_pointer(Pointer::from(id))\n     }\n \n-    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n-        Pointer::from(self.tcx.allocate_bytes(bytes))\n+    pub fn allocate(\n+        &mut self,\n+        size: Size,\n+        align: Align,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> Pointer<M::PointerTag> {\n+        let alloc = Allocation::undef(size, align);\n+        self.allocate_with(alloc, kind)\n     }\n \n-    pub fn allocate_with(\n+    pub fn allocate_static_bytes(\n         &mut self,\n-        alloc: Allocation<M::PointerTag, M::AllocExtra>,\n+        bytes: &[u8],\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> AllocId {\n-        let id = self.tcx.alloc_map.lock().reserve();\n-        self.alloc_map.insert(id, (kind, alloc));\n-        id\n+    ) -> Pointer<M::PointerTag> {\n+        let alloc = Allocation::from_byte_aligned_bytes(bytes);\n+        self.allocate_with(alloc, kind)\n     }\n \n-    pub fn allocate(\n+    pub fn allocate_with(\n         &mut self,\n-        size: Size,\n-        align: Align,\n+        alloc: Allocation,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n-        let (extra, tag) = M::new_allocation(size, &self.extra, kind);\n-        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)).with_tag(tag)\n+        let id = self.tcx.alloc_map.lock().reserve();\n+        let (alloc, tag) = M::tag_allocation(id, Cow::Owned(alloc), Some(kind), &self.extra);\n+        self.alloc_map.insert(id, (kind, alloc.into_owned()));\n+        Pointer::from(id).with_tag(tag)\n     }\n \n     pub fn reallocate(\n@@ -306,53 +317,68 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n     /// this machine use the same pointer tag, so it is indirected through\n-    /// `M::static_with_default_tag`.\n+    /// `M::tag_allocation`.\n+    ///\n+    /// Notice that every static has two `AllocId` that will resolve to the same\n+    /// thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n+    /// and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n+    /// `const_eval_raw` and it is the \"resolved\" ID.\n+    /// The resolved ID is never used by the interpreted progrma, it is hidden.\n+    /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n+    /// contains a reference to memory that was created during its evaluation (i.e., not to\n+    /// another static), those inner references only exist in \"resolved\" from.\n     fn get_static_alloc(\n         id: AllocId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         memory_extra: &M::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n-        let def_id = match alloc {\n-            Some(GlobalAlloc::Memory(mem)) => {\n-                // We got tcx memory. Let the machine figure out whether and how to\n-                // turn that into memory with the right pointer tag.\n-                return Ok(M::adjust_static_allocation(mem, memory_extra))\n-            }\n-            Some(GlobalAlloc::Function(..)) => {\n-                return err!(DerefFunctionPointer)\n-            }\n-            Some(GlobalAlloc::Static(did)) => {\n-                did\n-            }\n+        let alloc = match alloc {\n+            Some(GlobalAlloc::Memory(mem)) =>\n+                Cow::Borrowed(mem),\n+            Some(GlobalAlloc::Function(..)) =>\n+                return err!(DerefFunctionPointer),\n             None =>\n                 return err!(DanglingPointerDeref),\n-        };\n-        // We got a \"lazy\" static that has not been computed yet, do some work\n-        trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-        if tcx.is_foreign_item(def_id) {\n-            return M::find_foreign_static(def_id, tcx, memory_extra);\n-        }\n-        let instance = Instance::mono(tcx.tcx, def_id);\n-        let gid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        // use the raw query here to break validation cycles. Later uses of the static will call the\n-        // full query anyway\n-        tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-            // no need to report anything, the const_eval call takes care of that for statics\n-            assert!(tcx.is_static(def_id));\n-            match err {\n-                ErrorHandled::Reported => InterpError::ReferencedConstant.into(),\n-                ErrorHandled::TooGeneric => InterpError::TooGeneric.into(),\n+            Some(GlobalAlloc::Static(def_id)) => {\n+                // We got a \"lazy\" static that has not been computed yet.\n+                if tcx.is_foreign_item(def_id) {\n+                    trace!(\"static_alloc: foreign item {:?}\", def_id);\n+                    M::find_foreign_static(def_id, tcx)?\n+                } else {\n+                    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+                    let instance = Instance::mono(tcx.tcx, def_id);\n+                    let gid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    // use the raw query here to break validation cycles. Later uses of the static\n+                    // will call the full query anyway\n+                    let raw_const = tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid))\n+                        .map_err(|err| {\n+                            // no need to report anything, the const_eval call takes care of that\n+                            // for statics\n+                            assert!(tcx.is_static(def_id));\n+                            match err {\n+                                ErrorHandled::Reported => InterpError::ReferencedConstant,\n+                                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                            }\n+                        })?;\n+                    // Make sure we use the ID of the resolved memory, not the lazy one!\n+                    let id = raw_const.alloc_id;\n+                    let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+                    Cow::Borrowed(allocation)\n+                }\n             }\n-        }).map(|raw_const| {\n-            let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n-            // We got tcx memory. Let the machine figure out whether and how to\n-            // turn that into memory with the right pointer tag.\n-            M::adjust_static_allocation(allocation, memory_extra)\n-        })\n+        };\n+        // We got tcx memory. Let the machine figure out whether and how to\n+        // turn that into memory with the right pointer tag.\n+        Ok(M::tag_allocation(\n+            id, // always use the ID we got as input, not the \"hidden\" one.\n+            alloc,\n+            M::STATIC_KIND.map(MemoryKind::Machine),\n+            memory_extra\n+        ).0)\n     }\n \n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {"}, {"sha": "130343d0b2fb6df4f7c651db01a1c0825b2d8eb5", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -37,16 +37,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n         Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n     }\n \n-    #[inline]\n-    pub fn erase_tag(self) -> Immediate\n-    {\n-        match self {\n-            Immediate::Scalar(x) => Immediate::Scalar(x.erase_tag()),\n-            Immediate::ScalarPair(x, y) =>\n-                Immediate::ScalarPair(x.erase_tag(), y.erase_tag()),\n-        }\n-    }\n-\n     pub fn new_slice(\n         val: Scalar<Tag>,\n         len: u64,\n@@ -130,15 +120,6 @@ pub enum Operand<Tag=(), Id=AllocId> {\n }\n \n impl<Tag> Operand<Tag> {\n-    #[inline]\n-    pub fn erase_tag(self) -> Operand\n-    {\n-        match self {\n-            Operand::Immediate(x) => Operand::Immediate(x.erase_tag()),\n-            Operand::Indirect(x) => Operand::Indirect(x.erase_tag()),\n-        }\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MemPlace<Tag>\n         where Tag: ::std::fmt::Debug\n@@ -209,18 +190,6 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n     }\n }\n \n-impl<'tcx, Tag> OpTy<'tcx, Tag>\n-{\n-    #[inline]\n-    pub fn erase_tag(self) -> OpTy<'tcx>\n-    {\n-        OpTy {\n-            op: self.op.erase_tag(),\n-            layout: self.layout,\n-        }\n-    }\n-}\n-\n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n #[inline(always)]\n@@ -537,44 +506,53 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         val: &'tcx ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match val.val {\n+        let tag_scalar = |scalar| match scalar {\n+            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_static_base_pointer(ptr)),\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+        };\n+        // Early-return cases.\n+        match val.val {\n             ConstValue::Param(_) => return err!(TooGeneric),\n-            ConstValue::Infer(_) | ConstValue::Placeholder(_) => bug!(),\n-            ConstValue::ByRef(ptr, alloc) => {\n-                // We rely on mutability being set correctly in that allocation to prevent writes\n-                // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Operand::Indirect(\n-                    MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n-                )\n-            },\n-            ConstValue::Slice { data, start, end } =>\n-                Operand::Immediate(Immediate::ScalarPair(\n-                    Scalar::from(Pointer::new(\n-                        self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                        Size::from_bytes(start as u64),\n-                    )).with_default_tag().into(),\n-                    Scalar::from_uint(\n-                        (end - start) as u64,\n-                        self.tcx.data_layout.pointer_size,\n-                    ).with_default_tag().into(),\n-                )),\n-            ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n                 })?));\n-            },\n-        };\n+            }\n+            _ => {}\n+        }\n+        // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n-        Ok(OpTy {\n-            op,\n-            layout,\n-        })\n+        let op = match val.val {\n+            ConstValue::ByRef(ptr, _alloc) => {\n+                // We rely on mutability being set correctly in that allocation to prevent writes\n+                // where none should happen -- and for `static mut`, we copy on demand anyway.\n+                let ptr = self.tag_static_base_pointer(ptr);\n+                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+            },\n+            ConstValue::Scalar(x) =>\n+                Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),\n+            ConstValue::Slice { data, start, end } => {\n+                let ptr = Pointer::new(\n+                    self.tcx.alloc_map.lock().create_memory_alloc(data),\n+                    Size::from_bytes(start as u64), // offset: `start`\n+                );\n+                Operand::Immediate(Immediate::new_slice(\n+                    self.tag_static_base_pointer(ptr).into(),\n+                    (end - start) as u64, // len: `end - start`\n+                    self,\n+                ))\n+            }\n+            ConstValue::Param(..) |\n+            ConstValue::Infer(..) |\n+            ConstValue::Placeholder(..) |\n+            ConstValue::Unevaluated(..) =>\n+                bug!(\"eval_const_to_op: Unexpected ConstValue {:?}\", val),\n+        };\n+        Ok(OpTy { op, layout })\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index."}, {"sha": "fac9665d968e2a9b7e21d6119ca56c4ca2e081e7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77be06b7ed147c80b4b8e035a877cea45ece9f3f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=77be06b7ed147c80b4b8e035a877cea45ece9f3f", "patch": "@@ -5,7 +5,6 @@\n use std::convert::TryFrom;\n use std::hash::Hash;\n \n-use rustc::hir;\n use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n@@ -294,7 +293,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-    Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n+    Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n@@ -325,25 +324,13 @@ where\n \n     // Take an operand, representing a pointer, and dereference it to a place -- that\n     // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n-    // This calls the \"deref\" machine hook, and counts as a deref as far as\n-    // Stacked Borrows is concerned.\n     pub fn deref_operand(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        let mut place = self.ref_to_mplace(val)?;\n-        // Pointer tag tracking might want to adjust the tag.\n-        let mutbl = match val.layout.ty.sty {\n-            // `builtin_deref` considers boxes immutable, that's useless for our purposes\n-            ty::Ref(_, _, mutbl) => Some(mutbl),\n-            ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n-            ty::RawPtr(_) => None,\n-            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty),\n-        };\n-        place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n-        Ok(place)\n+        self.ref_to_mplace(val)\n     }\n \n     /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n@@ -587,18 +574,23 @@ where\n                     promoted: None\n                 };\n                 // Just create a lazy reference, so we can support recursive statics.\n-                // tcx takes are of assigning every static one and only one unique AllocId.\n+                // tcx takes care of assigning every static one and only one unique AllocId.\n                 // When the data here is ever actually used, memory will notice,\n                 // and it knows how to deal with alloc_id that are present in the\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n                 // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n-                // want!  This way, computing statics works concistently between codegen\n+                // want!  This way, computing statics works consistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation.\n-                let alloc = self.tcx.alloc_map.lock().create_static_alloc(cid.instance.def_id());\n-                MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n+                //\n+                // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n+                // one.  Here we make sure that the interpreted program never sees the\n+                // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n+                let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(cid.instance.def_id());\n+                let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n+                MPlaceTy::from_aligned_ptr(ptr, layout)\n             }\n         })\n     }\n@@ -1032,11 +1024,9 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let ptr = self.tag_static_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n-        Ok(MPlaceTy::from_aligned_ptr(\n-            Pointer::new(raw.alloc_id, Size::ZERO).with_default_tag(),\n-            layout,\n-        ))\n+        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type."}]}