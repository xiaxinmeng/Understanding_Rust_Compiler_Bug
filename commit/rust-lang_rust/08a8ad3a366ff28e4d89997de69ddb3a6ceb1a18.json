{"sha": "08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YThhZDNhMzY2ZmYyOGU0ZDg5OTk3ZGU2OWRkYjNhNmNlYjFhMTg=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-04-01T17:15:47Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-04-01T20:41:25Z"}, "message": "Remove paths from bind_instead_of_map", "tree": {"sha": "d8a30d08160b85f4a334f9f1343dd03d602926c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a30d08160b85f4a334f9f1343dd03d602926c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18", "html_url": "https://github.com/rust-lang/rust/commit/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "html_url": "https://github.com/rust-lang/rust/commit/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588"}], "stats": {"total": 159, "additions": 78, "deletions": 81}, "files": [{"sha": "46d4c674648112a2d747746b81fdc46cd187eb7c", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 78, "deletions": 81, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=08a8ad3a366ff28e4d89997de69ddb3a6ceb1a18", "patch": "@@ -1,80 +1,66 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{in_macro, match_qpath, method_calls, paths, remove_blocks, visitors::find_all_ret_expressions};\n+use clippy_utils::{in_macro, remove_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{LangItem, QPath};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::Span;\n \n pub(crate) struct OptionAndThenSome;\n \n impl BindInsteadOfMap for OptionAndThenSome {\n-    const TYPE_NAME: &'static str = \"Option\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::OptionSome;\n     const BAD_METHOD_NAME: &'static str = \"and_then\";\n-    const BAD_VARIANT_NAME: &'static str = \"Some\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::OPTION_SOME;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map\";\n }\n \n pub(crate) struct ResultAndThenOk;\n \n impl BindInsteadOfMap for ResultAndThenOk {\n-    const TYPE_NAME: &'static str = \"Result\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::ResultOk;\n     const BAD_METHOD_NAME: &'static str = \"and_then\";\n-    const BAD_VARIANT_NAME: &'static str = \"Ok\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_OK;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map\";\n }\n \n pub(crate) struct ResultOrElseErrInfo;\n \n impl BindInsteadOfMap for ResultOrElseErrInfo {\n-    const TYPE_NAME: &'static str = \"Result\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::ResultErr;\n     const BAD_METHOD_NAME: &'static str = \"or_else\";\n-    const BAD_VARIANT_NAME: &'static str = \"Err\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_ERR;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map_err\";\n }\n \n pub(crate) trait BindInsteadOfMap {\n-    const TYPE_NAME: &'static str;\n-    const TYPE_QPATH: &'static [&'static str];\n-\n+    const VARIANT_LANG_ITEM: LangItem;\n     const BAD_METHOD_NAME: &'static str;\n-    const BAD_VARIANT_NAME: &'static str;\n-    const BAD_VARIANT_QPATH: &'static [&'static str];\n-\n     const GOOD_METHOD_NAME: &'static str;\n \n-    fn no_op_msg() -> String {\n-        format!(\n+    fn no_op_msg(cx: &LateContext<'_>) -> Option<String> {\n+        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let item_id = cx.tcx.parent(variant_id)?;\n+        Some(format!(\n             \"using `{}.{}({})`, which is a no-op\",\n-            Self::TYPE_NAME,\n+            cx.tcx.item_name(item_id),\n             Self::BAD_METHOD_NAME,\n-            Self::BAD_VARIANT_NAME\n-        )\n+            cx.tcx.item_name(variant_id),\n+        ))\n     }\n \n-    fn lint_msg() -> String {\n-        format!(\n+    fn lint_msg(cx: &LateContext<'_>) -> Option<String> {\n+        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let item_id = cx.tcx.parent(variant_id)?;\n+        Some(format!(\n             \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n-            Self::TYPE_NAME,\n+            cx.tcx.item_name(item_id),\n             Self::BAD_METHOD_NAME,\n-            Self::BAD_VARIANT_NAME,\n+            cx.tcx.item_name(variant_id),\n             Self::GOOD_METHOD_NAME\n-        )\n+        ))\n     }\n \n     fn lint_closure_autofixable(\n@@ -85,17 +71,12 @@ pub(crate) trait BindInsteadOfMap {\n         closure_args_span: Span,\n     ) -> bool {\n         if_chain! {\n-            if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n-            if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n-            if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n-            if some_args.len() == 1;\n+            if let hir::ExprKind::Call(ref some_expr, [inner_expr]) = closure_expr.kind;\n+            if let hir::ExprKind::Path(QPath::Resolved(_, path)) = some_expr.kind;\n+            if Self::is_variant(cx, path.res);\n+            if !contains_return(inner_expr);\n+            if let Some(msg) = Self::lint_msg(cx);\n             then {\n-                let inner_expr = &some_args[0];\n-\n-                if contains_return(inner_expr) {\n-                    return false;\n-                }\n-\n                 let some_inner_snip = if inner_expr.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n                 } else {\n@@ -109,7 +90,7 @@ pub(crate) trait BindInsteadOfMap {\n                     cx,\n                     BIND_INSTEAD_OF_MAP,\n                     expr.span,\n-                    Self::lint_msg().as_ref(),\n+                    &msg,\n                     \"try this\",\n                     note,\n                     Applicability::MachineApplicable,\n@@ -126,41 +107,46 @@ pub(crate) trait BindInsteadOfMap {\n         let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n-                if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n-                if let hir::ExprKind::Path(ref qpath) = func_path.kind;\n-                if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n-                if args.len() == 1;\n-                if !contains_return(&args[0]);\n+                if let hir::ExprKind::Call(ref func_path, [arg]) = ret_expr.kind;\n+                if let hir::ExprKind::Path(QPath::Resolved(_, path)) = func_path.kind;\n+                if Self::is_variant(cx, path.res);\n+                if !contains_return(arg);\n                 then {\n-                    suggs.push((ret_expr.span, args[0].span.source_callsite()));\n+                    suggs.push((ret_expr.span, arg.span.source_callsite()));\n                     true\n                 } else {\n                     false\n                 }\n             }\n         });\n-\n-        if can_sugg {\n-            span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, Self::lint_msg().as_ref(), |diag| {\n-                multispan_sugg_with_applicability(\n-                    diag,\n-                    \"try this\",\n-                    Applicability::MachineApplicable,\n-                    std::iter::once((*method_calls(expr, 1).2.get(0).unwrap(), Self::GOOD_METHOD_NAME.into())).chain(\n-                        suggs\n-                            .into_iter()\n-                            .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n-                    ),\n-                )\n-            });\n-        }\n-        can_sugg\n+        let (span, msg) = if_chain! {\n+            if can_sugg;\n+            if let hir::ExprKind::MethodCall(_, span, ..) = expr.kind;\n+            if let Some(msg) = Self::lint_msg(cx);\n+            then { (span, msg) } else { return false; }\n+        };\n+        span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, &msg, |diag| {\n+            multispan_sugg_with_applicability(\n+                diag,\n+                \"try this\",\n+                Applicability::MachineApplicable,\n+                std::iter::once((span, Self::GOOD_METHOD_NAME.into())).chain(\n+                    suggs\n+                        .into_iter()\n+                        .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n+                ),\n+            )\n+        });\n+        true\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n     fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) -> bool {\n-        if !match_type(cx, cx.typeck_results().expr_ty(recv), Self::TYPE_QPATH) {\n-            return false;\n+        if_chain! {\n+            if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n+            if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n+            if Some(adt.did) == cx.tcx.parent(vid);\n+            then {} else { return false; }\n         }\n \n         match arg.kind {\n@@ -175,19 +161,30 @@ pub(crate) trait BindInsteadOfMap {\n                 }\n             },\n             // `_.and_then(Some)` case, which is no-op.\n-            hir::ExprKind::Path(ref qpath) if match_qpath(qpath, Self::BAD_VARIANT_QPATH) => {\n-                span_lint_and_sugg(\n-                    cx,\n-                    BIND_INSTEAD_OF_MAP,\n-                    expr.span,\n-                    Self::no_op_msg().as_ref(),\n-                    \"use the expression directly\",\n-                    snippet(cx, recv.span, \"..\").into(),\n-                    Applicability::MachineApplicable,\n-                );\n+            hir::ExprKind::Path(QPath::Resolved(_, path)) if Self::is_variant(cx, path.res) => {\n+                if let Some(msg) = Self::no_op_msg(cx) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BIND_INSTEAD_OF_MAP,\n+                        expr.span,\n+                        &msg,\n+                        \"use the expression directly\",\n+                        snippet(cx, recv.span, \"..\").into(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n                 true\n             },\n             _ => false,\n         }\n     }\n+\n+    fn is_variant(cx: &LateContext<'_>, res: Res) -> bool {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Ok(variant_id) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM) {\n+                return cx.tcx.parent(id) == Some(variant_id);\n+            }\n+        }\n+        false\n+    }\n }"}]}