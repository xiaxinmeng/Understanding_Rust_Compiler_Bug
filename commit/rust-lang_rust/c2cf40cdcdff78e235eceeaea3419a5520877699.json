{"sha": "c2cf40cdcdff78e235eceeaea3419a5520877699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyY2Y0MGNkY2RmZjc4ZTIzNWVjZWVhZWEzNDE5YTU1MjA4Nzc2OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T09:22:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T09:22:54Z"}, "message": "Auto merge of #6284 - camsteffen:rustc-sym, r=flip1995\n\nUse const sym where possible\n\nI ran a regex search and replace to use const `sym` values where possible. This should give some performance boost by avoiding string interning at runtime.\n\nCon: It is not as consistent as always using `sym!`.\n\nI also changed an internal lint to suggest using `sym::{}`, making an assumption that this will always work for diagnostic items.\n\nchangelog: none", "tree": {"sha": "ff61b4304a1c4e875db8bff2be67246bdda9e354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff61b4304a1c4e875db8bff2be67246bdda9e354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2cf40cdcdff78e235eceeaea3419a5520877699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2cf40cdcdff78e235eceeaea3419a5520877699", "html_url": "https://github.com/rust-lang/rust/commit/c2cf40cdcdff78e235eceeaea3419a5520877699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2cf40cdcdff78e235eceeaea3419a5520877699/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a34bc017d2e9334ed2ee3513b248003c2d90a5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a34bc017d2e9334ed2ee3513b248003c2d90a5c", "html_url": "https://github.com/rust-lang/rust/commit/3a34bc017d2e9334ed2ee3513b248003c2d90a5c"}, {"sha": "b2332a7357b5da7220592aea4c711609eed54ef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2332a7357b5da7220592aea4c711609eed54ef7", "html_url": "https://github.com/rust-lang/rust/commit/b2332a7357b5da7220592aea4c711609eed54ef7"}], "stats": {"total": 362, "additions": 198, "deletions": 164}, "files": [{"sha": "a004abb58b83ed0097f64e265a7a4b5126347e8d", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_span::symbol::{Symbol, SymbolStr};\n use semver::Version;\n \n@@ -286,14 +287,14 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     },\n                     _ => {},\n                 }\n-                if items.is_empty() || !attr.has_name(sym!(deprecated)) {\n+                if items.is_empty() || !attr.has_name(sym::deprecated) {\n                     return;\n                 }\n                 for item in items {\n                     if_chain! {\n                         if let NestedMetaItem::MetaItem(mi) = &item;\n                         if let MetaItemKind::NameValue(lit) = &mi.kind;\n-                        if mi.has_name(sym!(since));\n+                        if mi.has_name(sym::since);\n                         then {\n                             check_semver(cx, item.span(), lit);\n                         }\n@@ -309,7 +310,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym!(macro_use)));\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.has_name(sym::macro_use));\n \n                 for attr in item.attrs {\n                     if in_external_macro(cx.sess(), attr.span) {\n@@ -326,7 +327,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                         match item.kind {\n                                             ItemKind::Use(..) => {\n                                                 if is_word(lint, sym!(unused_imports))\n-                                                    || is_word(lint, sym!(deprecated))\n+                                                    || is_word(lint, sym::deprecated)\n                                                     || is_word(lint, sym!(unreachable_pub))\n                                                     || is_word(lint, sym!(unused))\n                                                     || extract_clippy_lint(lint)\n@@ -411,8 +412,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMet\n     let lint_store = cx.lints();\n     for lint in items {\n         if let Some(lint_name) = extract_clippy_lint(lint) {\n-            if let CheckLintNameResult::Tool(Err((None, _))) =\n-                lint_store.check_lint_name(&lint_name, Some(sym!(clippy)))\n+            if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(&lint_name, Some(sym::clippy))\n             {\n                 span_lint_and_then(\n                     cx,\n@@ -529,10 +529,10 @@ fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribut\n \n     for attr in attrs {\n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || !attr.has_name(sym!(inline)) {\n+            if values.len() != 1 || !attr.has_name(sym::inline) {\n                 continue;\n             }\n-            if is_word(&values[0], sym!(always)) {\n+            if is_word(&values[0], sym::always) {\n                 span_lint(\n                     cx,\n                     INLINE_ALWAYS,\n@@ -623,12 +623,12 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n fn check_deprecated_cfg_attr(cx: &EarlyContext<'_>, attr: &Attribute) {\n     if_chain! {\n         // check cfg_attr\n-        if attr.has_name(sym!(cfg_attr));\n+        if attr.has_name(sym::cfg_attr);\n         if let Some(items) = attr.meta_item_list();\n         if items.len() == 2;\n         // check for `rustfmt`\n         if let Some(feature_item) = items[0].meta_item();\n-        if feature_item.has_name(sym!(rustfmt));\n+        if feature_item.has_name(sym::rustfmt);\n         // check for `rustfmt_skip` and `rustfmt::skip`\n         if let Some(skip_item) = &items[1].meta_item();\n         if skip_item.has_name(sym!(rustfmt_skip)) ||\n@@ -690,7 +690,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n     }\n \n     if_chain! {\n-        if attr.has_name(sym!(cfg));\n+        if attr.has_name(sym::cfg);\n         if let Some(list) = attr.meta_item_list();\n         let mismatched = find_mismatched_target_os(&list);\n         if !mismatched.is_empty();"}, {"sha": "90bb0bd555f274169d6144f7b5adb56385a422bb", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -11,6 +11,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for boolean expressions that can be written more\n@@ -253,8 +254,8 @@ fn simplify_not(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n         },\n         ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n             let type_of_receiver = cx.typeck_results().expr_ty(&args[0]);\n-            if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n-                && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n+            if !is_type_diagnostic_item(cx, type_of_receiver, sym::option_type)\n+                && !is_type_diagnostic_item(cx, type_of_receiver, sym::result_type)\n             {\n                 return None;\n             }"}, {"sha": "38a0e27c4cf5b8d1c48cec85d5a8e3b02ff735d6", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use rustc_span::Symbol;\n \n declare_clippy_lint! {\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n                                 filter_args[0].kind {\n                             let p = path.ident.name;\n-                            if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {\n+                            if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                                 &args[0]\n                             } else {\n                                 &filter_args[0]"}, {"sha": "b1bc2ec29e16ee3d2d1f847db6a23aadb6b29bdc", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n+use rustc_span::{sym, BytePos};\n \n use crate::utils::{is_type_diagnostic_item, snippet_opt, span_lint_and_help, LimitStack};\n \n@@ -61,7 +61,7 @@ impl CognitiveComplexity {\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n-        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n+        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::result_type) {\n             returns\n         } else {\n             #[allow(clippy::integer_division)]\n@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         hir_id: HirId,\n     ) {\n         let def_id = cx.tcx.hir().local_def_id(hir_id);\n-        if !cx.tcx.has_attr(def_id.to_def_id(), sym!(test)) {\n+        if !cx.tcx.has_attr(def_id.to_def_id(), sym::test) {\n             self.check(cx, kind, decl, body, span);\n         }\n     }"}, {"sha": "edecba57e44f0a38073d8664ff76211aed3174a7", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -15,7 +15,7 @@ use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n-use rustc_span::{FileName, Pos};\n+use rustc_span::{sym, FileName, Pos};\n use std::io;\n use std::ops::Range;\n use url::Url;\n@@ -237,7 +237,7 @@ fn lint_for_missing_headers<'tcx>(\n         );\n     }\n     if !headers.errors {\n-        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             span_lint(\n                 cx,\n                 MISSING_ERRORS_DOC,\n@@ -255,7 +255,7 @@ fn lint_for_missing_headers<'tcx>(\n                 if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n                 if let ty::Generator(_, subs, _) = gen.kind();\n-                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n+                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym::result_type);\n                 then {\n                     span_lint(\n                         cx,\n@@ -333,7 +333,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n             let (comment, current_spans) = strip_doc_comment_decoration(&comment.as_str(), comment_kind, attr.span);\n             spans.extend_from_slice(&current_spans);\n             doc.push_str(&comment);\n-        } else if attr.has_name(sym!(doc)) {\n+        } else if attr.has_name(sym::doc) {\n             // ignore mix of sugared and non-sugared doc\n             // don't trigger the safety or errors check\n             return DocHeaders {\n@@ -479,7 +479,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n                     | ItemKind::ExternCrate(..)\n                     | ItemKind::ForeignMod(..) => return false,\n                     // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym!(main) => {\n+                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n                         let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n                         let returns_nothing = match &sig.decl.output {\n                             FnRetTy::Default(..) => true,"}, {"sha": "f8038d06e50347ea90c317b7c194c7f69832ffe0", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,6 +5,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `write!()` / `writeln()!` which can be\n@@ -33,7 +34,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n         if_chain! {\n             // match call to unwrap\n             if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;\n-            if unwrap_fun.ident.name == sym!(unwrap);\n+            if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n             if !unwrap_args.is_empty();\n             if let ExprKind::MethodCall(ref write_fun, _, write_args, _) ="}, {"sha": "fe817fe94f2e4c4cdb5bd19cbc839cb8a33d7fb7", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n@@ -95,8 +95,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-                if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+                if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n                 {\n                     self.result.push(expr.span);\n                 }\n@@ -113,7 +113,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n \n     for impl_item in impl_items {\n         if_chain! {\n-            if impl_item.ident.name == sym!(from);\n+            if impl_item.ident.name == sym::from;\n             if let ImplItemKind::Fn(_, body_id) =\n                 cx.tcx.hir().impl_item(impl_item.id).kind;\n             then {"}, {"sha": "8e41e0e34daf75bc6f87242e19dc38756a30248a", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `format!(\"string literal with no\n@@ -91,7 +92,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if pats.len() == 1;\n         then {\n             let ty = cx.typeck_results().pat_ty(&pats[0]).peel_refs();\n-            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 return None;\n             }\n             if let ExprKind::Lit(ref lit) = format_args.kind {\n@@ -186,15 +187,15 @@ fn check_unformatted(expr: &Expr<'_>) -> bool {\n         if exprs.len() == 1;\n         // struct `core::fmt::rt::v1::Argument`\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n-        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n+        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n-        if last_path_segment(precision_path).ident.name == sym!(Implied);\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if last_path_segment(precision_path).ident.name == sym::Implied;\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym::width);\n         if let ExprKind::Path(ref width_qpath) = width_field.expr.kind;\n-        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n+        if last_path_segment(width_qpath).ident.name == sym::Implied;\n         then {\n             return true;\n         }"}, {"sha": "8b58d1f26013aa504fac9978d33e350a89ac474e", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -473,7 +474,7 @@ fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span\n         if !in_external_macro(cx.sess(), item_span);\n         if let hir::FnRetTy::Return(ref ty) = decl.output;\n         if let hir::TyKind::Path(ref qpath) = ty.kind;\n-        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym!(result_type));\n+        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym::result_type);\n         if let Some(ref args) = last_path_segment(qpath).args;\n         if let [_, hir::GenericArg::Type(ref err_ty)] = args.args;\n         if let hir::TyKind::Tup(t) = err_ty.kind;"}, {"sha": "cdd8a42e7cd12c003363c1e538b2f4564b79803b", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for using `x.get(x.len() - 1)` instead of\n@@ -55,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n             // Argument 0 (the struct we're calling the method on) is a vector\n             if let Some(struct_calling_on) = args.get(0);\n             let struct_ty = cx.typeck_results().expr_ty(struct_calling_on);\n-            if is_type_diagnostic_item(cx, struct_ty, sym!(vec_type));\n+            if is_type_diagnostic_item(cx, struct_ty, sym::vec_type);\n \n             // Argument to \"get\" is a subtraction\n             if let Some(get_index_arg) = args.get(1);"}, {"sha": "e0a1f4c5ca4f2cd25f0fbd7d5862a52bbaa3edc1", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -4,6 +4,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:*** Checks for unnecessary `ok()` in if let.\n@@ -45,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym!(result_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {"}, {"sha": "b723d06a6881d27454b4d94a3b5aca6918748739", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -2,6 +2,7 @@ use if_chain::if_chain;\n use rustc_hir::{ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n use crate::utils::{\n     get_trait_def_id, implements_trait, is_type_diagnostic_item, paths, return_ty, span_lint_and_help,\n@@ -107,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if decl.inputs.len() == 1;\n \n             // Check if return type is String\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::string_type);\n \n             // Filters instances of to_string which are required by a trait\n             if trait_ref_of_method(cx, impl_item.hir_id).is_none();"}, {"sha": "d1c3fdc71461b03e6552712c4451e478209f6698", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{TraitFn, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[inline]` on trait methods without bodies\n@@ -41,7 +41,7 @@ impl<'tcx> LateLintPass<'tcx> for InlineFnWithoutBody {\n \n fn check_attrs(cx: &LateContext<'_>, name: Symbol, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if !attr.has_name(sym!(inline)) {\n+        if !attr.has_name(sym::inline) {\n             continue;\n         }\n "}, {"sha": "c7d3f4e9b083bcad06c326d62d975d70eb8fe867", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -619,9 +619,9 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n                 }\n \n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.ident.name == sym!(next)\n+                if method_path.ident.name == sym::next\n                     && match_trait_method(cx, match_expr, &paths::ITERATOR)\n-                    && lhs_constructor.ident.name == sym!(Some)\n+                    && lhs_constructor.ident.name == sym::Some\n                     && (pat_args.is_empty()\n                         || !is_refutable(cx, &pat_args[0])\n                             && !is_used_inside(cx, iter_expr, &arms[0].body)\n@@ -985,13 +985,13 @@ fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n         _ => false,\n     };\n \n-    is_slice || is_type_diagnostic_item(cx, ty, sym!(vec_type)) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n }\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n         if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if method.ident.name == sym!(clone);\n+        if method.ident.name == sym::clone;\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n         then { arg } else { expr }\n@@ -1355,7 +1355,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n             if let Some(self_expr) = args.get(0);\n             if let Some(pushed_item) = args.get(1);\n             // Check that the method being called is push() on a Vec\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym!(vec_type));\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n             if path.ident.name.as_str() == \"push\";\n             then {\n                 return Some((self_expr, pushed_item))\n@@ -1736,7 +1736,7 @@ fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr:\n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(arg);\n-    if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOPS_OVER_FALLIBLES,\n@@ -1753,7 +1753,7 @@ fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n                 snippet(cx, arg.span, \"_\")\n             ),\n         );\n-    } else if is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOPS_OVER_FALLIBLES,\n@@ -2186,8 +2186,8 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n-            if (meth.ident.name == sym!(index) && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.ident.name == sym!(index_mut) && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n             then { return }\n         }\n@@ -2333,7 +2333,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     // will allow further borrows afterwards\n     let ty = cx.typeck_results().expr_ty(e);\n     is_iterable_array(ty, cx) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n     is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n     is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n@@ -2890,7 +2890,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n         then {\n             let ty = cx.typeck_results().node_type(ty.hir_id);\n-            if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                 is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n                 is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {"}, {"sha": "a1450b0d5feaac4ba85e6eba11a5ddd550f39eb3", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,7 +5,7 @@ use rustc_attr as attr;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n@@ -83,9 +83,9 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n     }\n \n     fn is_doc_hidden(attr: &Attribute) -> bool {\n-        attr.has_name(sym!(doc))\n+        attr.has_name(sym::doc)\n             && match attr.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n+                Some(l) => attr::list_contains_name(&l, sym::hidden),\n                 None => false,\n             }\n     }\n@@ -102,7 +102,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n                         let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {\n@@ -154,7 +154,7 @@ fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data:\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n                         let header_span = find_header_span(cx, item, data);\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {"}, {"sha": "9e2c6c7f231dafadba929a53f1a9e444aac5f220", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -8,6 +8,7 @@ use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -97,9 +98,9 @@ fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n     if_chain! {\n         if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n+        if let Some(case) = if utils::is_type_diagnostic_item(cx, ty, sym::option_type) {\n             Some(Case::Option)\n-        } else if utils::is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n+        } else if utils::is_type_diagnostic_item(cx, ty, sym::result_type) {\n             Some(Case::Result)\n         } else {\n             None"}, {"sha": "034cd99a9be06b072ef7a1e8fdafa8e8a912cf42", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `iterator.map(|x| x.clone())` and suggests\n@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n+            if is_type_diagnostic_item(cx, ty, sym::option_type) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);"}, {"sha": "6b782385a38d29f36e0ef3cfb321f820d4feb5e7", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n@@ -65,8 +66,8 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n         if args.len() == 2 && method.ident.as_str() == \"map\";\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if match_trait_method(cx, expr, &paths::ITERATOR)\n-            || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n-            || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n+            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n         then {\n             Some(args)\n         } else {"}, {"sha": "e50d11a4d7175a911194ee5ab05bb7c2dce08b77", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -6,6 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `option.map(f)` where f is a function\n@@ -206,9 +207,9 @@ fn lint_map_unit_fn(cx: &LateContext<'_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr\n     let var_arg = &map_args[0];\n \n     let (map_type, variant, lint) =\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(option_type)) {\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::option_type) {\n             (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym!(result_type)) {\n+        } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(var_arg), sym::result_type) {\n             (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n         } else {\n             return;"}, {"sha": "086dae9422f9b57184af6e39f796377ec285e54d", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `match vec[idx]` or `match vec[n..m]`.\n@@ -90,7 +91,7 @@ fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Opti\n fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     let ty = ty.peel_refs();\n-    is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    is_type_diagnostic_item(cx, ty, sym::vec_type)\n }\n \n fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {"}, {"sha": "c6dca54e2509adbbf493114ffebfcff9b244361d", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -662,7 +662,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             }\n         } else {\n             // not a block, don't lint\n-            return; \n+            return;\n         };\n \n         let ty = cx.typeck_results().expr_ty(ex);\n@@ -840,7 +840,7 @@ fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms\n \n fn check_wild_err_arm(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n+    if is_type_diagnostic_item(cx, ex_ty, sym::result_type) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n@@ -1509,6 +1509,7 @@ mod redundant_pattern_match {\n     use rustc_errors::Applicability;\n     use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind, QPath};\n     use rustc_lint::LateContext;\n+    use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n@@ -1552,7 +1553,7 @@ mod redundant_pattern_match {\n         if_chain! {\n             if keyword == \"while\";\n             if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-            if method_path.ident.name == sym!(next);\n+            if method_path.ident.name == sym::next;\n             if match_trait_method(cx, op, &paths::ITERATOR);\n             then {\n                 return;"}, {"sha": "c83b6f2c32963e779ddc52645046c5f27e009415", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n@@ -50,7 +51,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         return true;\n     }\n \n-    if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+    if is_type_diagnostic_item(cx, ty, sym::string_type) {\n         return true;\n     }\n "}, {"sha": "7186656f4e11a6b73f1011c493136678859fe0d5", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -1722,7 +1722,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, item.span);\n-            if item.ident.name == sym!(new);\n+            if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id);\n             let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n@@ -1812,7 +1812,7 @@ fn lint_or_fun_call<'tcx>(\n                     _ => (),\n                 }\n \n-                if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n                     return;\n                 }\n             }\n@@ -1909,11 +1909,11 @@ fn lint_expect_fun_call(\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n                 hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n                     if call_args.len() == 1\n-                        && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n                         }\n                     {\n                         &call_args[0]\n@@ -1931,7 +1931,7 @@ fn lint_expect_fun_call(\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n         let arg_ty = cx.typeck_results().expr_ty(arg);\n-        if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n+        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n             return false;\n         }\n         if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n@@ -2018,9 +2018,9 @@ fn lint_expect_fun_call(\n     }\n \n     let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n         \"||\"\n-    } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n         \"|_|\"\n     } else {\n         return;\n@@ -2207,7 +2207,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n             \"\"\n-        } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n+        } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n             \"&\"\n         } else {\n             return;\n@@ -2233,14 +2233,14 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n \n fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n-    if is_type_diagnostic_item(cx, obj_ty, sym!(string_type)) {\n+    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n fn lint_iter_cloned_collect<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n     if_chain! {\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym!(vec_type));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n         if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n@@ -2393,7 +2393,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n         || matches!(\n             &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n             ty::Array(_, _)\n@@ -2426,7 +2426,7 @@ fn lint_iter_nth<'tcx>(\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n         \"Vec\"\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n         \"VecDeque\"\n@@ -2479,7 +2479,7 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym!(vec_type)) {\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"Vec\"\n     } else if is_type_diagnostic_item(cx, expr_ty, sym!(vecdeque_type)) {\n@@ -2565,7 +2565,7 @@ fn derefs_to_slice<'tcx>(\n         match ty.kind() {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n-            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n+            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::vec_type),\n             ty::Array(_, size) => size\n                 .try_eval_usize(cx.tcx, cx.param_env)\n                 .map_or(false, |size| size < 32),\n@@ -2575,7 +2575,7 @@ fn derefs_to_slice<'tcx>(\n     }\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym!(iter) && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n+        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n             None\n@@ -2600,9 +2600,9 @@ fn derefs_to_slice<'tcx>(\n fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n         Some((UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2652,7 +2652,7 @@ fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::E\n fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym!(result_type));\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n         let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n@@ -2682,7 +2682,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n                     _ => map_closure_ty.fn_sig(cx.tcx),\n                 };\n                 let map_closure_return_ty = cx.tcx.erase_late_bound_regions(&map_closure_sig.output());\n-                is_type_diagnostic_item(cx, map_closure_return_ty, sym!(option_type))\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n             },\n             _ => false,\n         };\n@@ -2708,7 +2708,7 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n         let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n@@ -2732,8 +2732,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) -> bool {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2786,8 +2786,8 @@ fn lint_map_unwrap_or_else<'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3145,7 +3145,7 @@ fn lint_chars_cmp(\n         if arg_char.len() == 1;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym!(Some);\n+        if segment.ident.name == sym::Some;\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -3441,7 +3441,7 @@ fn lint_option_as_ref_deref<'tcx>(\n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n     let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n-    if !is_type_diagnostic_item(cx, option_ty, sym!(option_type)) {\n+    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n         return;\n     }\n \n@@ -3548,7 +3548,7 @@ fn lint_map_collect(\n         if match_trait_method(cx, map_expr, &paths::ITERATOR);\n         // return of collect `Result<(),_>`\n         let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n-        if is_type_diagnostic_item(cx, collect_ret_ty, sym!(result_type));\n+        if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n         if let ty::Adt(_, substs) = collect_ret_ty.kind();\n         if let Some(result_t) = substs.types().next();\n         if result_t.is_unit();\n@@ -3575,7 +3575,7 @@ fn lint_map_collect(\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     match ty.kind() {\n-        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n         _ => None,\n     }\n }"}, {"sha": "7763fd5f113fa6fa68ba4e59208f15201dfd6bbb", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::{self, HirId, Path};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Symbol};\n \n use super::MAP_UNWRAP_OR;\n \n@@ -20,7 +20,7 @@ pub(super) fn lint<'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n         if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument"}, {"sha": "cde89983a2656aff2d0a50eb646b690699a79c6b", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -3,6 +3,7 @@ use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n@@ -14,8 +15,8 @@ pub(super) fn lint<'tcx>(\n     args: &'tcx [hir::Expr<'_>],\n     simplify_using: &str,\n ) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::result_type);\n \n     if is_option || is_result {\n         if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {"}, {"sha": "009e3d8937e0233e2602ff03c37e7bc5f2311609", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -14,6 +14,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Warns if there is missing doc for any documentable item\n@@ -105,10 +106,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.has_name(sym!(doc))\n+                attr.has_name(sym::doc)\n                     && match attr.meta_item_list() {\n                         None => false,\n-                        Some(l) => attr::list_contains_name(&l[..], sym!(hidden)),\n+                        Some(l) => attr::list_contains_name(&l[..], sym::hidden),\n                     }\n             });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -128,7 +129,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Enum(..) => \"an enum\",\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n-                if it.ident.name == sym!(main) {\n+                if it.ident.name == sym::main {\n                     let def_id = it.hir_id.owner;\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {"}, {"sha": "53abe6086ea411ef5220b9b78e7e75088bf01acf", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_lint::{self, LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** it lints if an exported function, method, trait method with default impl,\n@@ -57,7 +58,7 @@ declare_clippy_lint! {\n }\n \n fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.has_name(sym!(inline)));\n+    let has_inline = attrs.iter().any(|a| a.has_name(sym::inline));\n     if !has_inline {\n         span_lint(\n             cx,"}, {"sha": "405c21d608d978b360b791ca630e6a95dc2a153b", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -10,6 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -112,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     }\n \n     fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if item.attrs.iter().any(|a| a.has_name(sym!(automatically_derived))) {\n+        if item.attrs.iter().any(|a| a.has_name(sym::automatically_derived)) {\n             debug_assert!(self.derived_item.is_none());\n             self.derived_item = Some(item.hir_id);\n         }"}, {"sha": "5c92590f41e2e25ba2088f7b6b47fc1fefb40839", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -13,7 +13,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -204,12 +204,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n                         let deref_span = spans_need_deref.get(&canonical_id);\n                         if_chain! {\n-                            if is_type_diagnostic_item(cx, ty, sym!(vec_type));\n+                            if is_type_diagnostic_item(cx, ty, sym::vec_type);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n                             if let TyKind::Path(QPath::Resolved(_, ref path)) = input.kind;\n                             if let Some(elem_ty) = path.segments.iter()\n-                                .find(|seg| seg.ident.name == sym!(Vec))\n+                                .find(|seg| seg.ident.name == sym::Vec)\n                                 .and_then(|ps| ps.args.as_ref())\n                                 .map(|params| params.args.iter().find_map(|arg| match arg {\n                                     GenericArg::Type(ty) => Some(ty),\n@@ -243,7 +243,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             }\n                         }\n \n-                        if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                        if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                                 diag.span_suggestion(\n@@ -302,7 +302,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n /// Functions marked with these attributes must have the exact signature.\n fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n-        [sym!(proc_macro), sym!(proc_macro_attribute), sym!(proc_macro_derive)]\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n             .iter()\n             .any(|&allow| attr.has_name(allow))\n     })"}, {"sha": "68fdd0eb269ef31af5013d5bee8ef39b8e75bf0c", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n@@ -91,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == sym!(new) && cx.access_levels.is_reachable(id) {\n+                        if sig.decl.inputs.is_empty() && name == sym::new && cx.access_levels.is_reachable(id) {\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if_chain! {"}, {"sha": "485888fa9444f1ae794630b7de64d4c62d94dacf", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,6 +7,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use std::cmp::Ordering;\n \n@@ -384,7 +385,7 @@ impl EarlyLintPass for NonExpressiveNames {\n }\n \n fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n-    if !attrs.iter().any(|attr| attr.has_name(sym!(test))) {\n+    if !attrs.iter().any(|attr| attr.has_name(sym::test)) {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),\n             cx,"}, {"sha": "681dbce97697ece39789b183fb280214f53acbb2", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -8,6 +8,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -66,7 +67,7 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.to_ident_string() == \"ok\"\n-            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym!(result_type))\n+            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n     } else {\n         false\n     }"}, {"sha": "72dfccc1089e9da4e7484c2a542795b22521db02", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!` or `unreachable!` in a function of type result.\n@@ -40,7 +40,7 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n         hir_id: hir::HirId,\n     ) {\n         if !matches!(fn_kind, FnKind::Closure(_))\n-            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type))\n+            && is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type)\n         {\n             lint_impl_body(cx, span, body);\n         }"}, {"sha": "ceecc8dbc06fcbcd872ccc2d5d50187e0318e496", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -3,6 +3,7 @@ use if_chain::if_chain;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual re-implementations of `PartialEq::ne`.\n@@ -39,7 +40,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {\n                 for impl_item in impl_items {\n-                    if impl_item.ident.name == sym!(ne) {\n+                    if impl_item.ident.name == sym::ne {\n                         span_lint_hir(\n                             cx,\n                             PARTIALEQ_NE_IMPL,"}, {"sha": "030650c3256c09819a066afc7e9d22cb38cc1a67", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutabil\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::Target;\n@@ -230,8 +230,8 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n                 }\n                 for a in attrs {\n                     if let Some(meta_items) = a.meta_item_list() {\n-                        if a.has_name(sym!(proc_macro_derive))\n-                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        if a.has_name(sym::proc_macro_derive)\n+                            || (a.has_name(sym::inline) && attr::list_contains_name(&meta_items, sym::always))\n                         {\n                             return;\n                         }"}, {"sha": "dcb643a28aebcceb0cc2420ccde03a87d851589b", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -15,7 +15,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::MultiSpan;\n+use rustc_span::{sym, MultiSpan};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -181,7 +181,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n         }\n \n         if let ty::Ref(_, ty, Mutability::Not) = ty.kind() {\n-            if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n                     if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n@@ -225,7 +225,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n-            } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                     span_lint_and_then(\n                         cx,"}, {"sha": "e0996804a5934a8ad77c83a30fc363c3452c7e82", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -3,6 +3,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use std::fmt;\n \n declare_clippy_lint! {\n@@ -92,7 +93,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n     if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n-            if path_segment.ident.name == sym!(offset) {\n+            if path_segment.ident.name == sym::offset {\n                 return Some((&args[0], &args[1], Method::Offset));\n             }\n             if path_segment.ident.name == sym!(wrapping_offset) {"}, {"sha": "d9b280b7a85970115456e222755b198428a5db02", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -4,6 +4,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n@@ -143,7 +144,7 @@ impl QuestionMark {\n     fn is_option(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.typeck_results().expr_ty(expression);\n \n-        is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n+        is_type_diagnostic_item(cx, expr_ty, sym::option_type)\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {"}, {"sha": "79e9a56af9a196c14a413e9e5094dfae620bd8e5", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -7,6 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n@@ -304,7 +305,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if_chain! {\n             // `.iter()` call\n             if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n-            if iter_path.ident.name == sym!(iter);\n+            if iter_path.ident.name == sym::iter;\n             // range expression in `.zip()` call: `0..x.len()`\n             if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n             if is_integer_const(cx, start, 0);"}, {"sha": "b4a9804fb25a5a5984356f019f4236ce36a3e643", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n+use rustc_span::sym;\n use std::convert::TryFrom;\n use std::ops::ControlFlow;\n \n@@ -115,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             let from_borrow = match_def_path(cx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n                 || match_def_path(cx, fn_def_id, &paths::TO_OWNED_METHOD)\n                 || (match_def_path(cx, fn_def_id, &paths::TO_STRING_METHOD)\n-                    && is_type_diagnostic_item(cx, arg_ty, sym!(string_type)));\n+                    && is_type_diagnostic_item(cx, arg_ty, sym::string_type));\n \n             let from_deref = !from_borrow\n                 && (match_def_path(cx, fn_def_id, &paths::PATH_TO_PATH_BUF)"}, {"sha": "d34e744eb944cd0631f0bc00b6d55ffdc6b6585c", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,6 +5,7 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `.repeat(1)` and suggest the following method for each types.\n@@ -65,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n                         format!(\"{}.to_vec()\", snippet(cx, receiver.span, r#\"\"...\"\"#)),\n                         Applicability::MachineApplicable,\n                     );\n-                } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n                     span_lint_and_sugg(\n                         cx,\n                         REPEAT_ONCE,"}, {"sha": "7f4913a02cbd33eda2c73ce45f5f028bcbbd5342", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n@@ -141,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n }\n \n fn attr_is_cfg(attr: &Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+    attr.meta_item_list().is_some() && attr.has_name(sym::cfg)\n }\n \n fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {"}, {"sha": "0dd2da949c4c33e5d8105148abda3f98430465b0", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -4,6 +4,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use rustc_span::sym;\n \n use if_chain::if_chain;\n \n@@ -154,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym!(string_type))\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::string_type)\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {"}, {"sha": "386987eb181ea9c411c213b5a802f3b058122ded", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for manual swapping.\n@@ -197,7 +198,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n \n                 if matches!(ty.kind(), ty::Slice(_))\n                     || matches!(ty.kind(), ty::Array(_, _))\n-                    || is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+                    || is_type_diagnostic_item(cx, ty, sym::vec_type)\n                     || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n                 {\n                     return Slice::Swappable(lhs1, idx1, idx2);"}, {"sha": "6f6b6999bf0a9cdbace8ae8e28789bae480fa778", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `Err(x)?`.\n@@ -133,7 +134,7 @@ fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> O\n fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ty::Adt(_, subst) = ty.kind();\n-        if is_type_diagnostic_item(cx, ty, sym!(result_type));\n+        if is_type_diagnostic_item(cx, ty, sym::result_type);\n         let err_ty = subst.type_at(1);\n         then {\n             Some(err_ty)\n@@ -151,7 +152,7 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(result_type), ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::result_type, ready_def.did);\n         let err_ty = ready_subst.type_at(1);\n \n         then {\n@@ -170,11 +171,11 @@ fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) ->\n         let ready_ty = subst.type_at(0);\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(option_type), ready_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::option_type, ready_def.did);\n         let some_ty = ready_subst.type_at(0);\n \n         if let ty::Adt(some_def, some_subst) = some_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym!(result_type), some_def.did);\n+        if cx.tcx.is_diagnostic_item(sym::result_type, some_def.did);\n         let err_ty = some_subst.type_at(1);\n \n         then {"}, {"sha": "c7d82da3b8ba4c0f38b6fb76a15321487b5e2f1f", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -522,7 +522,7 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                    } else if cx.tcx.is_diagnostic_item(sym!(vec_type), def_id) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n                         if_chain! {\n                             // Get the _ part of Vec<_>\n                             if let Some(ref last) = last_path_segment(qpath).args;\n@@ -559,7 +559,7 @@ impl Types {\n                                 return; // don't recurse into the type\n                             }\n                         }\n-                    } else if cx.tcx.is_diagnostic_item(sym!(option_type), def_id) {\n+                    } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n                         if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n                             span_lint(\n                                 cx,\n@@ -1610,7 +1610,7 @@ fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         if names.is_empty() {\n             return false;\n         }\n-        if names[0] == sym!(libc) || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n+        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n             return true;\n         }\n     }\n@@ -2777,7 +2777,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                 }\n \n                 if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.ident.name == sym!(new) {\n+                    if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n                     } else if method.ident.name == sym!(with_capacity) {\n@@ -2790,7 +2790,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n                         );\n                     }\n                 } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.ident.name == sym!(new) {\n+                    if method.ident.name == sym::new {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());\n                     } else if method.ident.name == sym!(with_capacity) {"}, {"sha": "0bccfc156788a5984f2731d994567dc5e408b91d", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegme\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n@@ -175,7 +176,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n-        if utils::is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym!(vec_type));\n+        if utils::is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(vec), sym::vec_type);\n         if let closure_body = cx.tcx.hir().body(*closure_body_id);\n         if let &[\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},"}, {"sha": "f4a77e54dd149463a866066cfe43467d16a8b117", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for calls of `unwrap[_err]()` that cannot fail.\n@@ -92,11 +93,11 @@ fn collect_unwrap_info<'tcx>(\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     fn is_relevant_option_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n-        is_type_diagnostic_item(cx, ty, sym!(option_type)) && [\"is_some\", \"is_none\"].contains(&method_name)\n+        is_type_diagnostic_item(cx, ty, sym::option_type) && [\"is_some\", \"is_none\"].contains(&method_name)\n     }\n \n     fn is_relevant_result_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n-        is_type_diagnostic_item(cx, ty, sym!(result_type)) && [\"is_ok\", \"is_err\"].contains(&method_name)\n+        is_type_diagnostic_item(cx, ty, sym::result_type) && [\"is_ok\", \"is_err\"].contains(&method_name)\n     }\n \n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n@@ -168,8 +169,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n             if_chain! {\n                 if let ExprKind::MethodCall(ref method_name, _, ref args, _) = expr.kind;\n                 if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n-                if [sym!(unwrap), sym!(unwrap_err)].contains(&method_name.ident.name);\n-                let call_to_unwrap = method_name.ident.name == sym!(unwrap);\n+                if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n+                let call_to_unwrap = method_name.ident.name == sym::unwrap;\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.ident.res == path.res);\n                 // Span contexts should not differ with the conditional branch"}, {"sha": "fde3102933098415d2aece0bc10df6aac083f302", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for functions of type Result that contain `expect()` or `unwrap()`\n@@ -57,8 +57,8 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n             // first check if it's a method or function\n             if let hir::ImplItemKind::Fn(ref _signature, _) = impl_item.kind;\n             // checking if its return type is `result` or `option`\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(result_type))\n-                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(option_type));\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::result_type)\n+                || is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym::option_type);\n             then {\n                 lint_impl_body(cx, impl_item.span, impl_item);\n             }\n@@ -82,8 +82,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n         // check for `expect`\n         if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n             let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n             {\n                 self.result.push(expr.span);\n             }\n@@ -92,8 +92,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n             let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n-                || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+            if is_type_diagnostic_item(self.lcx, reciever_ty, sym::option_type)\n+                || is_type_diagnostic_item(self.lcx, reciever_ty, sym::result_type)\n             {\n                 self.result.push(expr.span);\n             }"}, {"sha": "c6194b0c6de3ea74fe4cdd49c76cff1a96e74784", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `Into`, `TryInto`, `From`, `TryFrom`,`IntoIter` calls\n@@ -106,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if_chain! {\n                         let a = cx.typeck_results().expr_ty(e);\n                         let b = cx.typeck_results().expr_ty(&args[0]);\n-                        if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                        if is_type_diagnostic_item(cx, a, sym::result_type);\n                         if let ty::Adt(_, substs) = a.kind();\n                         if let Some(a_type) = substs.types().next();\n                         if TyS::same_type(a_type, b);\n@@ -136,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     then {\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n-                            if is_type_diagnostic_item(cx, a, sym!(result_type));\n+                            if is_type_diagnostic_item(cx, a, sym::result_type);\n                             if let ty::Adt(_, substs) = a.kind();\n                             if let Some(a_type) = substs.types().next();\n                             if TyS::same_type(a_type, b);"}, {"sha": "8b59a9541a736fb8d18da04bd7f523ad4add84e4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -225,7 +225,7 @@ declare_clippy_lint! {\n     ///\n     /// Good:\n     /// ```rust,ignore\n-    /// utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    /// utils::is_type_diagnostic_item(cx, ty, sym::vec_type)\n     /// ```\n     pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n     internal,\n@@ -724,7 +724,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n                     expr.span,\n                     \"usage of `utils::match_type()` on a type diagnostic item\",\n                     \"try\",\n-                    format!(\"utils::is_type_diagnostic_item({}, {}, sym!({}))\", cx_snippet, ty_snippet, item_name),\n+                    format!(\"utils::is_type_diagnostic_item({}, {}, sym::{})\", cx_snippet, ty_snippet, item_name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "85e7f055e79de4810ef1322764c9d3dd0e77006b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -52,6 +52,7 @@ use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n+use rustc_span::sym as rustc_sym;\n use rustc_span::symbol::{self, kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n@@ -974,7 +975,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym!(automatically_derived)))\n+    attrs.iter().any(|attr| attr.has_name(rustc_sym::automatically_derived))\n }\n \n /// Remove blocks around an expression."}, {"sha": "ff414f748ef97e5b00ed0c359e527022344f0bd3", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -10,8 +10,7 @@ use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Symbol;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span, Symbol};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -224,7 +223,7 @@ impl EarlyLintPass for Write {\n                 .expect(\"path has at least one segment\")\n                 .ident\n                 .name;\n-            if trait_name == sym!(Debug) {\n+            if trait_name == sym::Debug {\n                 self.in_debug_impl = true;\n             }\n         }"}, {"sha": "82465dbaf6ecc9d9e61b5f99e25f62948da7ebc7", "filename": "tests/ui/match_type_on_diag_item.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2cf40cdcdff78e235eceeaea3419a5520877699/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2cf40cdcdff78e235eceeaea3419a5520877699/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.stderr?ref=c2cf40cdcdff78e235eceeaea3419a5520877699", "patch": "@@ -2,7 +2,7 @@ error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:41:17\n    |\n LL |         let _ = match_type(cx, ty, &paths::VEC);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::vec_type)`\n    |\n note: the lint level is defined here\n   --> $DIR/match_type_on_diag_item.rs:1:9\n@@ -15,19 +15,19 @@ error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:42:17\n    |\n LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(option_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::option_type)`\n \n error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:43:17\n    |\n LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(result_type))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::result_type)`\n \n error: usage of `utils::match_type()` on a type diagnostic item\n   --> $DIR/match_type_on_diag_item.rs:46:17\n    |\n LL |         let _ = utils::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(Rc))`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym::Rc)`\n \n error: aborting due to 4 previous errors\n "}]}